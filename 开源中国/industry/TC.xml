<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 18 Jun 2025 02:41:17 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>騰訊元寶電腦版上線 AI 編程模式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;騰訊元寶於 6 月 17 日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FdzxRkhiptJ2xuc7iWeMwoQ" target="_blank"&gt;發佈更新&lt;/a&gt;，正式上線 AI 編程模式。該功能已在元寶電腦版 2.25 版本中推出。&lt;/p&gt; 
&lt;p&gt;用戶在電腦版選擇 DeepSeek 模型並關閉深度思考後，輸入「@AI 編程」後，即可通過雙欄界面，在左側對話生成代碼，右側實時展示並支持預覽運行。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-c7a712000aa674f9547c40f9e99b7a07ff8.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，除此前已支持直接運行 HTML 外，在騰訊雲代碼助手 CodeBuddy 的技術支持下，現在元寶還能在線運行 Python、Java、C++、JavaScript、Go、Fortran 等多種語言的在線運行，均無需部署環境。不僅元寶 DeepSeek-V3 模型支持雙欄編程，其他模型也支持一句話寫代碼。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355926</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355926</guid>
      <pubDate>Wed, 18 Jun 2025 02:33:15 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌推出輕量級模型 Gemini 2.5 Flash-Lite</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;谷歌發文&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fgemini%2Fgemini-2-5-model-family-expands%2F" target="_blank"&gt;宣佈&lt;/a&gt;，Gemini 2.5 Flash 和 Gemini 2.5 Pro 模型進入穩定階段，同時推出全新輕量級模型 Gemini 2.5 Flash-Lite 預覽版 —— "這是我們迄今為止最經濟實惠、、速度最快的 2.5 模型"。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告稱，2.5 Flash Lite 在編碼、數學、科學、推理和多模態基準測試中全面超越 2.0 Flash-Lite。它在翻譯和分類等高容量、延遲敏感的任務中表現出色，在廣泛的任務樣本中，延遲低於 2.0 Flash-Lite 和 2.0 Flash。它具備 Gemini 2.5 的諸多實用功能，包括在不同預算下開啓思維、連接 Google 搜索和代碼執行等工具、多模態輸入以及 100 萬個 token 的上下文長度。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;可&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstorage.googleapis.com%2Fdeepmind-media%2Fgemini%2Fgemini_v2_5_report.pdf" target="_blank"&gt;在最新的 Gemini 技術報告&lt;/a&gt;&lt;span style="color:#000000"&gt;中查看有關 2.5 系列型號的更多詳細信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="550" src="https://oscimg.oschina.net/oscnet/up-9a697505bd2fc209bd5447bda5db3bcb55b.gif" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，Gemini 2.5 Flash-Lite 預覽版已在 Google AI Studio 和 Vertex AI 中上線，同時還提供 2.5 Flash 和 Pro 穩定版。2.5 Flash 和 Pro 版本均可在 Gemini 應用中訪問。谷歌方面還為 Google 搜索功能引入了 2.5 Flash-Lite 和 Flash 的定製版本。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355920/gemini-2-5-flash-lite</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355920/gemini-2-5-flash-lite</guid>
      <pubDate>Wed, 18 Jun 2025 02:11:15 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>VTJ 公開 AI+低代碼集成架構和全生命週期過程</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;本文檔介紹了 VTJ 的 AI 驅動的代碼生成和設計輔助功能。AI 集成使用戶能夠通過自然語言提示、圖像上傳和元數據文件生成 Vue 組件和頁面。有關處理 AI 生成代碼的核心低代碼引擎的信息，請參閲&lt;strong&gt;核心架構&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;。有關可視化設計器界面的詳細信息，請參閲&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;設計器和渲染器&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;。&lt;/p&gt; 
&lt;h2&gt;AI 系統架構&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23ai-%25E7%25B3%25BB%25E7%25BB%259F%25E6%259E%25B6%25E6%259E%2584" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;VTJ 的 AI 集成由多個層組成，這些層協同工作，將用戶輸入轉換為可執行的 Vue 代碼：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//f786ae742c374228699d1f7bafafc6d5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;AI 集成架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;AI 系統通過分層架構運行，其中接口組件收集用戶輸入，邏輯層管理狀態和 API 通信，後端服務處理 AI 處理。生成的代碼直接與 VTJ 的核心引擎集成，用於解析和渲染。&lt;/p&gt; 
&lt;h2&gt;AI 輸入類型和處理&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23ai-%25E8%25BE%2593%25E5%2585%25A5%25E7%25B1%25BB%25E5%259E%258B%25E5%2592%258C%25E5%25A4%2584%25E7%2590%2586" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;VTJ 支持三種主要的 AI 輸入模式，每種模式都針對不同的用例而設計：&lt;/p&gt; 
&lt;table cellspacing="0" style="--vp-code-copy-copied-text-content:&amp;quot;已複製&amp;quot;; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box; color:#3c3c43; display:table !important; font-family:&amp;quot;Microsoft YaHei&amp;quot;,Arial,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:20px 0px; orphans:2; overflow-x:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:1252px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;輸入類型&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;元件&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;文件擴展名&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;用例&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;文本信息&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;ChatInput&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;不適用&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;自然語言要求&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;圖像&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;ImageInput&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;.png、.jpg .jpeg&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;設計模型、屏幕截圖&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;JSON/元數據&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;JsonInput&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;.json&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;Figma、Sketch 導出&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;文本輸入處理&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E6%2596%2587%25E6%259C%25AC%25E8%25BE%2593%25E5%2585%25A5%25E5%25A4%2584%25E7%2590%2586" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;基於文本的 AI 生成通過 AISendData 接口處理自然語言提示：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//83fb612595834ce006ee4bb2ba7c40aa.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;文本輸入處理流程&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;文本輸入流使用當前項目上下文創建一個主題，包括現有的 DSL 和生成的 Vue 源代碼，為 AI 提供完整的代碼生成上下文。&lt;/p&gt; 
&lt;h3&gt;圖像輸入處理&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E5%259B%25BE%25E5%2583%258F%25E8%25BE%2593%25E5%2585%25A5%25E5%25A4%2584%25E7%2590%2586" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;圖像處理支持從屏幕截圖、模型和設計文件生成設計到代碼：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//3bc6974ec41a139d25743ac4e6c068fb.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;圖像到代碼處理管道&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;圖像輸入系統接受設計文件，並通過經過設計識別訓練的專用 AI 模型對其進行處理，將視覺佈局轉換為語義 Vue 組件。&lt;/p&gt; 
&lt;h2&gt;AI 聊天系統和實時流媒體&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23ai-%25E8%2581%258A%25E5%25A4%25A9%25E7%25B3%25BB%25E7%25BB%259F%25E5%2592%258C%25E5%25AE%259E%25E6%2597%25B6%25E6%25B5%2581%25E5%25AA%2592%25E4%25BD%2593" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;AI 聊天系統管理與流式響應的對話交互：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//4f26eab8cf8fda165885f3d27e08ee3b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;AI 聊天狀態機&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;聊天系統通過結構化狀態機維護對話狀態，該狀態機處理流式響應、錯誤恢復和用戶交互。&lt;/p&gt; 
&lt;h3&gt;實時響應流&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E5%25AE%259E%25E6%2597%25B6%25E5%2593%258D%25E5%25BA%2594%25E6%25B5%2581" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;流式處理實現使用服務器發送事件 （SSE） 進行實時 AI 響應：&lt;/p&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span style="color:#67676c"&gt;&lt;span style="color:#6a737d"&gt;// Key streaming logic from chatCompletions&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#d73a49"&gt;const&lt;/span&gt;&lt;span style="color:#6f42c1"&gt; chatCompletions&lt;/span&gt;&lt;span style="color:#d73a49"&gt; =&lt;/span&gt;&lt;span style="color:#d73a49"&gt; async&lt;/span&gt;&lt;span style="color:#24292e"&gt; (&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#e36209"&gt;  topicId&lt;/span&gt;&lt;span style="color:#d73a49"&gt;:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; string&lt;/span&gt;&lt;span style="color:#24292e"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#e36209"&gt;  chatId&lt;/span&gt;&lt;span style="color:#d73a49"&gt;:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; string&lt;/span&gt;&lt;span style="color:#24292e"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#6f42c1"&gt;  callback&lt;/span&gt;&lt;span style="color:#d73a49"&gt;?:&lt;/span&gt;&lt;span style="color:#24292e"&gt; (&lt;/span&gt;&lt;span style="color:#e36209"&gt;data&lt;/span&gt;&lt;span style="color:#d73a49"&gt;:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; any&lt;/span&gt;&lt;span style="color:#24292e"&gt;, &lt;/span&gt;&lt;span style="color:#e36209"&gt;done&lt;/span&gt;&lt;span style="color:#d73a49"&gt;?:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; boolean&lt;/span&gt;&lt;span style="color:#24292e"&gt;) &lt;/span&gt;&lt;span style="color:#d73a49"&gt;=&amp;gt;&lt;/span&gt;&lt;span style="color:#005cc5"&gt; void&lt;/span&gt;&lt;span style="color:#24292e"&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#6f42c1"&gt;  error&lt;/span&gt;&lt;span style="color:#d73a49"&gt;?:&lt;/span&gt;&lt;span style="color:#24292e"&gt; (&lt;/span&gt;&lt;span style="color:#e36209"&gt;err&lt;/span&gt;&lt;span style="color:#d73a49"&gt;:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; any&lt;/span&gt;&lt;span style="color:#24292e"&gt;, &lt;/span&gt;&lt;span style="color:#e36209"&gt;cancel&lt;/span&gt;&lt;span style="color:#d73a49"&gt;?:&lt;/span&gt;&lt;span style="color:#005cc5"&gt; boolean&lt;/span&gt;&lt;span style="color:#24292e"&gt;) &lt;/span&gt;&lt;span style="color:#d73a49"&gt;=&amp;gt;&lt;/span&gt;&lt;span style="color:#005cc5"&gt; void&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#24292e"&gt;) &lt;/span&gt;&lt;span style="color:#d73a49"&gt;=&amp;gt;&lt;/span&gt;&lt;span style="color:#24292e"&gt; {&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#6a737d"&gt;  // Streaming implementation with AbortController&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#d73a49"&gt;  const&lt;/span&gt;&lt;span style="color:#005cc5"&gt; controller&lt;/span&gt;&lt;span style="color:#d73a49"&gt; =&lt;/span&gt;&lt;span style="color:#d73a49"&gt; new&lt;/span&gt;&lt;span style="color:#6f42c1"&gt; AbortController&lt;/span&gt;&lt;span style="color:#24292e"&gt;();&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#6a737d"&gt;  // Process streaming chunks and update UI reactively&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#24292e"&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;流式處理系統處理增量 AI 響應，實時更新 UI，同時保持對話上下文並處理中斷。&lt;/p&gt; 
&lt;h2&gt;代碼生成和 DSL 集成&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E4%25BB%25A3%25E7%25A0%2581%25E7%2594%259F%25E6%2588%2590%25E5%2592%258C-dsl-%25E9%259B%2586%25E6%2588%2590" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;AI 系統通過雙向代碼轉換與 VTJ 的核心引擎緊密集成：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//90ac06324294fbfaee4d2bd8bffcc081.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;AI 代碼生成和集成管道&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;代碼生成管道從 AI 響應中提取 Vue 代碼，將其解析為 VTJ 的 DSL 格式，並將更改應用於當前塊模型以進行即時渲染。&lt;/p&gt; 
&lt;h3&gt;Vue 代碼提取和解析&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23vue-%25E4%25BB%25A3%25E7%25A0%2581%25E6%258F%2590%25E5%258F%2596%25E5%2592%258C%25E8%25A7%25A3%25E6%259E%2590" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;系統從 AI markdown 響應中提取 Vue 代碼，並將其轉換為 VTJ 的內部 DSL：&lt;/p&gt; 
&lt;table cellspacing="0" style="--vp-code-copy-copied-text-content:&amp;quot;已複製&amp;quot;; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box; color:#3c3c43; display:table !important; font-family:&amp;quot;Microsoft YaHei&amp;quot;,Arial,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:20px 0px; orphans:2; overflow-x:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:1252px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;功能&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;目的&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;輸入&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;輸出&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;getVueCode&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;從 markdown 中提取 Vue&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;AI 響應文本&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;Vue SFC 代碼&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;vue2Dsl&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;轉換為 DSL&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;Vue SFC 代碼&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;塊架構&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;applyAI&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;應用於 engine&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;塊架構&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;更新的 UI&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;解析過程根據 VTJ 的組件規則驗證生成的代碼，並在代碼不符合預期模式時提供錯誤反饋。&lt;/p&gt; 
&lt;h2&gt;AI 主題和聊天管理&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23ai-%25E4%25B8%25BB%25E9%25A2%2598%25E5%2592%258C%25E8%2581%258A%25E5%25A4%25A9%25E7%25AE%25A1%25E7%2590%2586" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;AI 系統通過基於主題的組織維護對話歷史記錄：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//37bb0309614629087630c76bd790a995.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;AI 數據模型關係&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;主題系統按文件上下文組織對話，每個主題包含多個聊天交流。主題鏈接到特定的 BlockModel 實例，以實現上下文感知生成。&lt;/p&gt; 
&lt;h3&gt;主題生命週期管理&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E4%25B8%25BB%25E9%25A2%2598%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F%25E7%25AE%25A1%25E7%2590%2586" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;主題是為每個新的 AI 對話創建的，並在會話中持續存在：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;主題創建&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;：onPostTopic 使用項目上下文創建新主題&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;聊天添加&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;：onPostChat 向現有主題添加消息&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;歷史管理&lt;/strong&gt;：主題按 BlockModel 上下文加載&lt;/li&gt; 
 &lt;li&gt;**清理 **：onRemoveTopic 使用級聯處理主題刪除&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;主題系統使用戶能夠在每個文件中維護多個 AI 對話，同時保留對話上下文和生成的代碼歷史記錄。&lt;/p&gt; 
&lt;h2&gt;自動應用和用戶體驗功能&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E8%2587%25AA%25E5%258A%25A8%25E5%25BA%2594%25E7%2594%25A8%25E5%2592%258C%25E7%2594%25A8%25E6%2588%25B7%25E4%25BD%2593%25E9%25AA%258C%25E5%258A%259F%25E8%2583%25BD" target="_blank"&gt;&lt;/a&gt;&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;VTJ 的 AI 集成包括多項 UX 增強功能，以簡化開發：&lt;/p&gt; 
&lt;h3&gt;自動應用功能&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E8%2587%25AA%25E5%258A%25A8%25E5%25BA%2594%25E7%2594%25A8%25E5%258A%259F%25E8%2583%25BD" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;啓用自動應用功能後，會自動將生成的代碼應用於當前頁面：&lt;/p&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span style="color:#67676c"&gt;&lt;span style="color:#6a737d"&gt;// Auto-apply logic in completions callback&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#d73a49"&gt;if&lt;/span&gt;&lt;span style="color:#24292e"&gt; (data.auto) {&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#6f42c1"&gt;  onApply&lt;/span&gt;&lt;span style="color:#24292e"&gt;(c); &lt;/span&gt;&lt;span style="color:#6a737d"&gt;// Automatically apply generated DSL&lt;/span&gt;&lt;/span&gt;
&lt;span style="color:#67676c"&gt;&lt;span style="color:#24292e"&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;h3&gt;交互式代碼審查&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E4%25BA%25A4%25E4%25BA%2592%25E5%25BC%258F%25E4%25BB%25A3%25E7%25A0%2581%25E5%25AE%25A1%25E6%259F%25A5" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;系統通過&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Detail&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;組件提供詳細的代碼審查界面：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;代碼編輯器&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;：在應用之前修改生成的 Vue 代碼&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DSL 預覽&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;：查看轉換後的 DSL 結構&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;重新生成&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;：修改代碼後更新 DSL&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Apply Control&lt;/strong&gt;：手動應用已審核的代碼&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;錯誤處理和恢復&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2Fwiki%2Fai%2F%23%25E9%2594%2599%25E8%25AF%25AF%25E5%25A4%2584%25E7%2590%2586%25E5%2592%258C%25E6%2581%25A2%25E5%25A4%258D" target="_blank"&gt;&lt;/a&gt;&lt;/h3&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;AI 系統包括全面的錯誤處理：&lt;/p&gt; 
&lt;table cellspacing="0" style="--vp-code-copy-copied-text-content:&amp;quot;已複製&amp;quot;; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; box-sizing:border-box; color:#3c3c43; display:table !important; font-family:&amp;quot;Microsoft YaHei&amp;quot;,Arial,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:20px 0px; orphans:2; overflow-x:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:1252px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;錯誤類型&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;處理器&lt;/th&gt; 
   &lt;th style="background-color:#f6f6f7; border-color:#e2e2e3; text-align:left"&gt;恢復作&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;解析錯誤&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;vue2Dsl 捕獲&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;顯示錯誤消息，報價修復&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;網絡錯誤&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;完成錯誤&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;重試機制&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;驗證錯誤&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;DSL 驗證&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;顯示驗證錯誤&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;取消&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;onCancelChat&lt;/td&gt; 
   &lt;td style="border-color:#e2e2e3; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:1px"&gt;Clean 狀態，允許重試&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;錯誤系統提供上下文反饋和恢復選項，使用戶能夠迭代優化其 AI 生成的代碼。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355902</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355902</guid>
      <pubDate>Sun, 11 May 2025 00:33:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>Mozilla Firefox 新增了固定和取消固定標籤頁的方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Mozilla Firefox 最近推出了一項備受期待的功能：垂直標籤頁。該功能於 2025 年 3 月作為 Firefox 136 更新的一部分推出。&lt;/p&gt; 
&lt;p&gt;現在，Mozilla 在其瀏覽器中推出了另一項備受歡迎的標籤頁管理改進，使用戶能夠更輕鬆地在 Firefox 中固定和取消固定標籤頁。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-93cb835b446a292e28f4b205592bd446ffe.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在最新的 Firefox Nightly 更新中，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1944907" target="_blank"&gt;Mozilla 引入了&lt;/a&gt;一種全新的標籤頁固定或取消固定方式：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;您只需將當前頁面拖拽至另一個已固定的標籤頁即可將其固定，或將其拖拽出即可取消固定&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;就這麼簡單。新的邏輯適用於垂直和水平標籤頁視圖，並且無需使用上下文菜單。唯一的前提條件是，您需要至少有一個已固定的標籤頁才能使用拖動功能。否則，您只能將標籤頁移動到標籤頁的任意位置。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/190024_Z6WI_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;很高興看到 Firefox 為用戶實現了這項小小的便利。然而，一些人認為它仍有改進空間。拖動標籤頁固然很酷，但專門的快捷方式或許能更好、更快捷地固定或取消固定標籤頁。不過，其他主流瀏覽器也缺乏這項功能。&lt;/p&gt; 
&lt;p&gt;改進的標籤頁固定功能現已在 Firefox Nightly 中推出，這是最不穩定的更新渠道。Mozilla 使用它來測試早期更改和重大平台變更，這些變更可能存在錯誤、不穩定或破壞功能。&lt;/p&gt; 
&lt;p&gt;因此，將 Nightly 版本作為您的主瀏覽器可能不是一個好主意。不過，您可以同時運行 Firefox Nightly 和其他渠道進行測試。如果您感興趣，可以通過此鏈接從官方網站獲取。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355850</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355850</guid>
      <pubDate>Sat, 10 May 2025 11:00:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 與美國國防部簽署 2 億美元合同</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 宣佈與美國國防部達成了一項重磅合作，獲得了一份價值 2 億美元的為期一年的合同。這項合同旨在為國防部開發先進的人工智能工具，幫助應對一系列國家安全挑戰。五角大樓在聲明中指出，這項工作將主要在華盛頓及其周邊地區進行，預計將於 2026 年 7 月完成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這是 OpenAI&lt;span&gt;首次&lt;/span&gt;與美國國防部簽署合同，標誌着其在國家安全領域的深入佈局。隨着全球安全形勢的不斷變化，人工智能技術在軍事和安全領域的應用愈發重要。五角大樓表示，OpenAI 將致力於開發前沿的 AI 原型，以應對作戰和企業領域的關鍵挑戰。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bd93bf619f02cc812ac5e03db9d4a666430.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得一提的是，初創公司 Anduril 去年底也獲得了一項 1 億美元的國防合同，而 OpenAI 的競爭對手 Anthropic 則在與 Palantir 和亞馬遜合作，提供其 AI 模型給美國的國防和情報機構。此外，OpenAI 去年曾與 Anduril 合作，專注於提升反無人機系統的能力，以應對空中威脅。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 的聯合創始人兼首席執行官 Sam Altman 在一次關於 AI 與國家安全的峯會上表示，他們希望能夠積極參與國家安全領域的發展。儘管這次合同金額不算龐大，但在 OpenAI 年化收入已經飆升至 100 億美元的背景下，這項合作仍然意義深遠。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年 3 月，OpenAI 還宣佈了新一輪融資計劃，軟銀集團領投，融資額預計達到 400 億美元，投後估值將達 3000 億美元。而截至 3 月底，OpenAI 的每週活躍用戶數已達到 5 億。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355848</guid>
      <pubDate>Sat, 10 May 2025 10:16:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>SCALE 正式開源：一個面向專業級任務的大語言模型 SQL 能力評測框架</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;隨着大語言模型（LLM）在數據科學領域的應用日益廣泛，學術界和工業界湧現出多種評測基準。然而，我們觀察到，現有評測體系大多聚焦於&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Text-to-SQL&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的轉換準確率，而這遠不能全面反映模型在真實、複雜場景下的 SQL 處理能力。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;為了彌補這一關鍵空白，我們經過深入研究，提出了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE ------ 一個面向專業級任務的大語言模型 SQL 能力開源評測框架&lt;/strong&gt;。我們致力於通過開放、透明和社區驅動的方式，建立一個行業公認的評估標準。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="https://sql-llm-leaderboard.com/" src="https://oscimg.oschina.net/oscnet/up-d8de9745f7ddaa54f1659f6175dcbe78d5b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;背景：現有 LLM-SQL 評測的侷限性&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;近年來，大語言模型處理結構化查詢語言（SQL）的能力取得了長足進步。一系列公開的評測基準（Benchmark）也應運而生，它們在很大程度上推動了模型在 Text-to-SQL 任務上的發展。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;儘管如此，我們發現現有的評測體系仍存在顯著的侷限性。在專業的數據庫管理和軟件開發實踐中，開發者面臨的挑戰遠比 "將一句話轉為 SQL" 要複雜得多：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;性能是生命線&lt;/strong&gt;：一個能返回正確結果但執行耗時數分鐘的查詢，在生產環境中是不可接受的。現有評測很少關注模型生成 SQL 的性能和效率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;環境是多樣的&lt;/strong&gt;：數據庫遷移和跨平台適配是常見需求。但模型能否精準處理不同數據庫（如 MySQL，Oracle，PostgreSQL）之間的 "方言" 差異，現有評測也鮮有涉及。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;理解是深度的&lt;/strong&gt;：維護、審查和重構遺留代碼是開發者的日常。這要求模型不僅能 "寫" 代碼，更能深度 "理解" 代碼的邏輯、意圖和潛在風險。這一點同樣是當前評測的薄弱環節。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;現有評測的單一視角，使得開發者和決策者在面對真實、複雜的業務需求時，難以選擇出真正合適的模型。&lt;/p&gt; 
&lt;h2&gt;我們的解決方案：SCALE 評測框架&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;為了系統性地解決上述問題，我們設計並實現了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(SQL Capability Leaderboard for LLMs)&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;大模型 SQL 能力排行榜&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;並非對現有評測的簡單復現，而是一個從數據庫專家和資深開發者真實工作流出發，構建的全新、完全開源的評測框架。我們相信，只有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;開放源代碼、開放數據、開放方法&lt;/strong&gt;，才能建立最廣泛的行業信任。&lt;/p&gt; 
&lt;h2&gt;評測基石：一個高質量、多層次的數據集&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;一個評測框架的公信力，源於其評測數據的質量與廣度。為此，我們構建了一個高質量、多層次、貼近真實世界的數據集，並將其向社區完全開放。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;真實世界案例&lt;/strong&gt;：我們收集並脫敏了來自不同行業的真實查詢案例。這些案例作為數據集的基礎，確保了評測內容與生產環境的實際挑戰保持一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;AI 輔助的典型場景構造&lt;/strong&gt;：為提升測試集的覆蓋深度，我們針對容易引發邏輯錯誤或性能問題的複雜場景，如子查詢、多表連接、嵌套查詢、存儲過程等，利用 AI 輔助構造了大量細粒度的測試用例，旨在精準評估模型在處理複雜查詢時的邏輯穩健性與準確性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評分權重設計&lt;/strong&gt;：為區分不同任務的複雜度，我們為測試用例設置了不同的評分權重。通常，技術複雜度更高的用例會獲得更高的權重。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;答案驗證&lt;/strong&gt;：所有測試用例的參考答案均經過交叉驗證，以確保其準確性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三大核心評測維度&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;基於這一強大的數據集，SCALE 通過三個相互獨立的核心維度，深入考察模型在處理高價值、高複雜度 SQL 任務時的真實水平。&lt;/p&gt; 
&lt;h3&gt;⚡ SQL 優化能力 (SQL Optimization)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;：模型是否具備數據庫專家（DBA）的性能優化意識？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;：我們為模型提供一系列典型的低性能查詢，評估其能否在保證邏輯等價的前提下，改寫出性能更優的版本。評測指標不僅包含語法正確性，更引入了對優化規則複雜度的量化評估，以衡量其優化策略的優劣。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;：當您需要進行數據庫性能調優或代碼重構時，此維度的評測結果將為您提供關鍵參考。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;🔄 方言轉換能力 (Dialect Conversion)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;：模型能否成為一個可靠的、跨數據庫平台的 "代碼翻譯官"？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;：我們評估模型在多種主流數據庫 "方言" 之間進行轉換的邏輯保真度與語法準確性，確保其轉換結果是 "開箱即用" 且完全可靠的。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;：對於面臨數據庫遷移、構建跨平台數據中台等挑戰的團隊，此維度的領先模型是首選。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;📊 SQL 理解能力 (SQL Understanding)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;： 除了寫代碼，模型對 SQL 的理解有多深？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;： 我們從執行結果準確性、語法錯誤識別、執行計劃分析、查詢類型判斷等多個角度，全面考察模型對 SQL 代碼的深度分析能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;： 在進行代碼審查（Code Review）、遺留系統維護、自動化代碼分析等工作中，此維度的評測結果能幫您找到最 "懂"SQL 的 AI 助手。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;SCALE 的價值與應用&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我們相信，一個嚴謹、貼近實踐的評測框架，能為不同角色的專業人士創造價值：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於數據與軟件開發人員&lt;/strong&gt;：提升開發效率，保障交付質量。SCALE 能幫您快速找到最稱手的 AI 工具，處理優化、遷移、代碼審查等專業任務，將寶貴的精力聚焦於更有創造性的工作上。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於 AI 研究員與模型開發者&lt;/strong&gt;：精準定位座標，指明迭代方向。SCALE 透明的評測方法和開源的數據集，能清晰揭示您模型在專業 SQL 任務上的長處與短板，為下一階段的優化和訓練提供明確的、可量化的目標。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於企業 CTO 與技術決策者&lt;/strong&gt;：降低技術風險，驅動業務創新。基於 SCALE 客觀、中立的數據做出技術選型，能確保您為企業引入的 AI 能力是真正可靠、高效的，從而賦能團隊，構建更健壯的數據基礎設施。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;結論與展望&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我們推出 SCALE，旨在為社區提供一個更專業、更深入、更貼近真實需求的 LLM SQL 能力評估標準。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;作為一個開源項目，我們深知社區的力量是其生命力的源泉&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;。 我們不僅發佈評測結果，更開放所有評測腳本、數據集和方法論。我們誠摯地邀請您探索 SCALE 的評測結果，利用這一工具為您的研究和工作做出更精準的技術判斷。更重要的是，我們歡迎您&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;加入我們的社區&lt;/strong&gt;，貢獻代碼、提交測試用例或提出寶貴建議。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;讓我們一同完善 SCALE 的評測體系，共同推動大語言模型在數據庫領域的應用走向新的深度。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;探索 SCALE 實時排行榜 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsql-llm-leaderboard.com%2F" target="_blank"&gt;https://sql-llm-leaderboard.com/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;瞭解評測方法與技術細節 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Factiontech%2Fsql-llm-benchmark" target="_blank"&gt;https://github.com/actiontech/sql-llm-benchmark&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;SCALE：為專業 SQL 任務，選專業 AI 模型。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;更多技術文章，請訪問：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.actionsky.com%2F" target="_blank"&gt;https://opensource.actionsky.com/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355838</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355838</guid>
      <pubDate>Sat, 10 May 2025 09:32:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>GC-QA-RAG —— 檢索增強生成系統</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;GC-QA-RAG 是一款面向葡萄城產品生態（包括&lt;a href="https://www.grapecity.com.cn/solutions/huozige"&gt; 活字格&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/solutions/wyn"&gt;WYN&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/developer/spreadjs"&gt;SpreadJS &lt;/a&gt;和 &lt;a href="https://www.grapecity.com.cn/developer/grapecitydocuments/excel-java"&gt;GCExcel&lt;/a&gt; 等）的檢索增強生成（RAG）系統。該系統通過智能文檔處理、高效知識檢索、精準問答等功能，有效提升了知識管理效率和用戶支持體驗。&lt;/p&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本系統創新性地採用了 QA 預生成技術，克服了傳統文本切片方法在知識庫構建中的若干侷限性。經過實踐驗證，該技術方案能夠顯著提升檢索效果，可為 RAG 領域的技術實踐提供新的思路。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;對於初學者，我們提供了詳細的入門指南，幫助您快速掌握 QA-RAG 系統的構建方法&lt;/li&gt;
&lt;li&gt;對於面臨傳統架構挑戰的開發者，我們的架構設計文檔可為您提供參考，助力現有知識庫的優化升級&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本項目也分享了葡萄城在 RAG 知識庫產品設計方面的實踐經驗，希望能為相關領域的產品和技術探索提供有益參考。&lt;/p&gt;

&lt;p&gt;&lt;img height="356" src="https://oscimg.oschina.net/oscnet/up-322e0ef8752e9e5c72130b47ce44ff2d09a.png" width="802" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/gc-qa-rag</link>
      <guid isPermaLink="false">https://www.oschina.net/p/gc-qa-rag</guid>
      <pubDate>Sat, 10 May 2025 09:26:00 GMT</pubDate>
    </item>
    <item>
      <title>靜態類型函數式編程語言 —— Darklang 宣佈開源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Dark Inc 成立於 2017 年，專注於開發一種名為 Darklang 的靜態類型函數式編程語言，為雲原生應用開發而生，支持構建複雜應用系統，旨在簡化後端編碼。&lt;/p&gt; 
&lt;p&gt;然而，公司發展並不順利，最終資金耗盡。為了確保用戶和粉絲能夠繼續使用 Darklang，以及繼續發展這一重要技術，Dark Inc 決定將其資產，包括 Darklang 語言、博客、託管服務、Discord 等，&lt;strong&gt;出售給由前員工創立的新公司 Darklang Inc&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/154855_nfp3_2720166.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Darklang 新公司創始人 Stachu Korick 宣佈該項目現已開源，下文是官方開源公告的翻譯：&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;作為 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fgoodbye-dark-inc-welcome-darklang-inc%2F" target="_blank"&gt;關閉 Dark Inc.&lt;/a&gt; 和 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Ffirst-steps-of-darklang-inc%2F" target="_blank"&gt;成立 Darklang Inc.&lt;/a&gt; 的一部分，我們終於開源了所有倉庫。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdarklang%3Fref%3Dblog.darklang.com" target="_blank"&gt;我們的源代碼&lt;/a&gt; 現在已採用 Apache License 2.0。&lt;/p&gt; 
&lt;p&gt;多年來，我們一直在思考可持續性問題以及如何構建真正賦能開發者的工具。我們一直從哲學上支持開源，但認為 Darklang 的獨特架構和商業模式需要不同的方法。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;為何我們最初選擇源代碼可用 (&lt;/strong&gt;Source-Available&lt;strong&gt;)&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我們最初設計 Darklang 為一個僅託管的平台，您在 &lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdarklang.com" target="_blank"&gt;darklang.com&lt;/a&gt; 編寫代碼，程序會立即在生產環境中上線。我們認為這種集中的方式對於安全的代碼遷移和統一部署等特性是必要的，而提供自託管選項會損害我們的可持續性模式。&lt;/p&gt; 
&lt;p&gt;核心挑戰是構建有價值的東西，同時確保能夠長期持續開發。傳統的開源資金模式都有侷限性，因此 Darklang 被設計為「一種具有商業模式的語言」——那些有大量工作負載的用戶將通過我們的託管平台資助生態系統的發展。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;是什麼改變了我們的思考&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;有三個關鍵轉變改變了我們的觀點：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;產品成熟度和用戶反饋&lt;/strong&gt;：Darklang 採用的真正障礙從來不是許可問題，而是產品成熟度。隨着我們越來越接近構建人們喜愛的東西，保持源碼可用性開始感覺像不必要的風險。我們一直聽到人們希望我們更加開放。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;面向本地優先開發&lt;/strong&gt;：我們的技術方向發生了顯著變化。我們現在正在構建 Darklang，使其作為 CLI 在本地運行，並能夠部署到我們的雲或其他地方。沒有人希望在自己的機器上運行專有語言的二進制文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;新的商業機會&lt;/strong&gt;：自 2017 年以來，開發工具市場已經成熟。我們現在看到成功的公司對團隊協作功能和 AI 驅動的工具進行收費，同時保持核心平台的可訪問性。這些功能創造了團隊願意支付的附加值，同時始終保留自行託管的選項。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;為何開源&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;開源使 Darklang 具備可訪問性、可檢查性和社區所有。這與我們普及編程的哲學一致，並確保平台無論哪家公司命運如何都能持續發展和演變。&lt;/p&gt; 
&lt;p&gt;我們已經學會在不依賴我們特定編輯器或託管環境的情況下，提供 Darklang 的關鍵優勢——無形的基礎設施、無部署部署、基於追蹤的開發。這使開源成為可能，同時保留了 Darklang 的獨特之處。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;開放性問題&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我們仍在探索 Darklang 生態系統中關於許可的一些有趣技術挑戰。GitHub 通過附加 LICENSE.md 文件來處理這個問題，但在一個包管理器可以直接同步類型和函數的世界裏，有一些值得深入思考的有趣挑戰。核心平台是開源的，這為我們提供了一個堅實的基礎來構建。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;原文：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fdarklang-goes-open-source%2F" target="_blank"&gt;https://blog.darklang.com/darklang-goes-open-source/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355813/darklang-goes-open-source</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355813/darklang-goes-open-source</guid>
      <pubDate>Sat, 10 May 2025 07:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>工作中對 InheritableThreadLocal 使用的思考</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;代碼評審時，發現在線程池中使用 InheritableThreadLocal 上下文會使其中的線程變量失效，無法獲取到預期的變量值，所以對問題進行了覆盤和總結。&lt;/p&gt; 
  &lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
  &lt;h2&gt;1. 先説結論&lt;/h2&gt; 
  &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 只有在父線程&lt;strong&gt;創建&lt;/strong&gt;子線程時，在子線程中才能獲取到父線程中的線程變量；當配合線程池使用時：&lt;strong&gt;「第一次在線程池中開啓線程，能在子線程中獲取到父線程的線程變量，而當該子線程開啓之後，發生線程複用，該子線程仍然保留的是之前開啓它的父線程的線程變量，而無法獲取當前父線程中新的線程變量」&lt;/strong&gt;，所以會發生獲取線程變量錯誤的情況。&lt;/p&gt; 
  &lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
  &lt;h2&gt;2. 實驗例子&lt;/h2&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;創建一個線程數固定為 1 的線程池，先在 main 線程中存入&lt;code&gt;變量 1&lt;/code&gt;，並使用線程池開啓新的線程打印輸出線程變量，之後更改 main 線程的線程變量為&lt;code&gt;變量 2&lt;/code&gt;，再使用線程池中線程（發生線程複用）打印輸出線程變量，對比兩次輸出的值是否不同&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * 測試線程池下 InheritableThreadLocal 線程變量失效的場景
 */&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的線程池，保證線程複用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 線程複用再取還是 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;輸出結果:&lt;/p&gt; 
   &lt;br&gt; main 線程，變量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;br&gt; main 線程，變量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;發現兩次輸出結果值相同，證明發生線程複用時，&lt;strong&gt;子線程獲取父線程變量失效&lt;/strong&gt;&lt;/p&gt; 
  &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
  &lt;h2&gt;3. 詳解&lt;/h2&gt; 
  &lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.1 JavaDoc&lt;/h3&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. Normally the child's values will be identical to the parent's; however, the child's value can be made an arbitrary function of the parent's by overriding the childValue method in this class.&lt;br&gt; Inheritable thread-local variables are used in preference to ordinary thread-local variables when the per-thread-attribute being maintained in the variable (e.g., User ID, Transaction ID) must be automatically transmitted to any child threads that are created.&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 繼承了 &lt;code&gt;ThreadLocal&lt;/code&gt;, 以能夠讓子線程能夠從父線程中繼承線程變量: 當一個子線程&lt;code&gt;被創建&lt;/code&gt;時，它會接收到父線程中所有可繼承的變量。通常情況下，子線程和父線程中的線程變量是完全相同的，但是可以通過重寫 &lt;code&gt;childValue&lt;/code&gt; 方法來使父子線程中的值不同。&lt;/p&gt; 
   &lt;br&gt; 當線程中維護的變量如 UserId, TransactionId 等必須自動傳遞到 
   &lt;strong&gt;新創建的任何子線程&lt;/strong&gt;時，使用 
   &lt;code&gt;InheritableThreadLocal&lt;/code&gt;要優於 
   &lt;code&gt;ThreadLocal&lt;/code&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.2 源碼&lt;/h3&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;/**
     * 當子線程被創建時，通過該方法來初始化子線程中線程變量的值，
     * 這個方法在父線程中被調用，並且在子線程開啓之前。
     * 
     * 通過重寫這個方法可以改變從父線程中繼承過來的值。
     *
     * @param parentValue the parent thread's value
     * @return the child thread's initial value
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; &lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T&lt;/span&gt; parentValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; parentValue&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;,&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;其中&lt;code&gt;childValue&lt;/code&gt;方法來獲取父線程中的線程變量的值，也可通過重寫這個方法來將獲取到的線程變量的值進行修改。&lt;/p&gt; 
  &lt;p&gt;在&lt;code&gt;getMap&lt;/code&gt;方法和&lt;code&gt;createMap&lt;/code&gt;方法中，可以發現&lt;code&gt;inheritableThreadLocals&lt;/code&gt;變量，它是 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，在&lt;code&gt;Thread 類&lt;/code&gt;中&lt;/p&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//8a5c46d2c14c4bd1ce6d1e980efe3e77.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;3.2.1 childValue 方法&lt;/h4&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;開啓新線程時，會調用 Thread 的構造方法&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;沿着構造方法向下，找到&lt;code&gt;init&lt;/code&gt;方法的最終實現，其中有如下邏輯：&lt;strong&gt;為當前線程創建線程變量以繼承父線程中的線程變量&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * @param inheritThreadLocals 為 ture，代表是為，包含可繼承的線程變量，的線程進行初始化
 */&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; g&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; target&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;long&lt;/span&gt; stackSize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AccessControlContext&lt;/span&gt; acc&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;boolean&lt;/span&gt; inheritThreadLocals&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
  
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;inheritThreadLocals &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;// 注意這裏創建子線程的線程變量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt;
            &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createInheritedMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;&lt;code&gt;ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)&lt;/code&gt;創建子線程 &lt;code&gt;InheritedMap&lt;/code&gt; 的具體實現&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p&gt;&lt;code&gt;createInheritedMap&lt;/code&gt; 方法，最終會調用到 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的&lt;strong&gt;私有構造方法&lt;/strong&gt;，傳入的參數 parentMap 即為&lt;strong&gt;父線程中保存的線程變量&lt;/strong&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocalMap&lt;/span&gt; parentMap&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; parentTable &lt;span&gt;=&lt;/span&gt; parentMap&lt;span&gt;.&lt;/span&gt;table&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; len &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        table &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;len&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; j &lt;span&gt;&amp;lt;&lt;/span&gt; len&lt;span&gt;;&lt;/span&gt; j&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Entry&lt;/span&gt; e &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;[&lt;/span&gt;j&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 注意！！！ 這裏調用了 childValue 方法&lt;/span&gt;
                    &lt;span&gt;Object&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;&lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;Entry&lt;/span&gt; c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;threadLocalHashCode &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;len &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        h &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;h&lt;span&gt;,&lt;/span&gt; len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; c&lt;span&gt;;&lt;/span&gt;
                    size&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這個方法會對父線程中的線程變量做&lt;strong&gt;拷貝&lt;/strong&gt;，其中調用了&lt;code&gt;childValue&lt;/code&gt;方法來獲取/初始化子線程中的值，並保存到子線程中&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;由上可見，可繼承的線程變量&lt;strong&gt;只是&lt;/strong&gt;在線程&lt;strong&gt;被創建的時候&lt;/strong&gt;進行了初始化工作，這也就能解釋為什麼在線程池中發生線程複用時不能獲取到父線程線程變量的原因&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
  &lt;h2&gt;4. 實驗例子流程圖&lt;/h2&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//13978e8555584a0539f17ca79e19b1f5.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;main 線程&lt;code&gt;set main 線程，變量 1&lt;/code&gt;時，會調用到&lt;code&gt;InheritableThreadLocal&lt;/code&gt;的 &lt;code&gt;createMap&lt;/code&gt;方法，創建 &lt;code&gt;inheritableThreadLocals&lt;/code&gt; 並保存線程變量&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;開啓子線程 1 時，會拷貝父線程中的線程變量到子線程中，如圖示&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;main 線程&lt;code&gt;set main 線程，變量 2&lt;/code&gt;，會覆蓋主線程中之前 set 的 mian 線程變量 1&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;最後發生線程複用，子線程 1 無法獲取到 main 線程新 set 的值，仍然打印 main 線程，變量 1&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
  &lt;h2&gt;5. 解決方案: TransmittableThreadLocal&lt;/h2&gt; 
  &lt;p&gt;使用阿里巴巴 &lt;code&gt;TransmittableThreadLocal&lt;/code&gt; 能解決&lt;strong&gt;線程變量線程封閉&lt;/strong&gt;的問題，測試用例如下，在線程池提交任務時調用&lt;code&gt;TtlRunnable&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法來完成線程變量傳遞&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的線程池，保證線程複用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 使用 TransmittableThreadLocal 解決問題&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TtlRunnable&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;輸出結果:&lt;br&gt; main 線程，變量 1&lt;br&gt; main 線程，變量 2&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;注意：對象類型需要注意線程安全問題&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;具體用法參考 https://github.com/alibaba/transmittable-thread-local&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;hr&gt; 
  &lt;p&gt;&lt;strong&gt;That's all.&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18626652</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18626652</guid>
      <pubDate>Sat, 10 May 2025 07:45:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>蘋果內置終端應用在 macOS Tahoe 迎來「彩色」視覺設計更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;蘋果內置的終端應用在 macOS Tahoe 中得到了視覺上的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macrumors.com%2F2025%2F06%2F16%2Fapples-terminal-app-macos-tahoe%2F" target="_blank"&gt;更新&lt;/a&gt;，這是該命令行工具亮相以來首次顯著的設計更新。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6fcee60476e7476c2925193298f46bc5185.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據蘋果在 WWDC25 上的平台現狀演示，更新後的終端將支持 24 位色彩和 Powerline 字體。該應用還將採用全新的 Liquid Glass 美學設計，並重新設計主題，以配合 macOS 26 更廣泛的視覺改進。&lt;/p&gt; 
&lt;p&gt;雖然終端應用已經提供了各種顏色配置文件，但 macOS 26 版本承諾提供增強的自定義選項，以更具視覺吸引力的方式顯示系統信息。&lt;/p&gt; 
&lt;p&gt;這是一個早就應該進行的現代化應用程序，對於開發人員和高級用戶來説至關重要，因為它在二十多年來基本保持不變。&lt;/p&gt; 
&lt;p&gt;macOS Tahoe 將於今年秋季推出，開發者測試版現已發佈，第一個公開測試版預計將於 7 月發佈。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</guid>
      <pubDate>Sat, 10 May 2025 07:24:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>X.Org Server 項目回滾了大量代碼</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FX.Org-Server-Lots-Of-Reverts" target="_blank"&gt;據報道&lt;/a&gt;，X.Org Serve 的 Git 代碼庫近日出現了大量&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F%3Fsort%3Dcreated_date%26state%3Dmerged%26first_page_size%3D20" target="_blank"&gt;回滾操作&lt;/a&gt;，主要目的是回滾有問題的代碼。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-52f7b8884d7f58d9a488d0d105f625a75e7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;這些代碼由一名此前被驅逐的開發者提交，部分與不正確處理版權和許可通知有關，還有部分是新補丁導致功能破壞有關。&lt;/p&gt; 
&lt;p&gt;事件梳理如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;開發者變動&lt;/strong&gt; ：一位開發者被項目組織驅逐後創建分支另立門戶（「X11Libre」），其此前提交的大量代碼被資深 X.Org 開發人員審查，發現諸多問題，從而引發了一系列代碼回滾。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;版權和許可證聲明處理不當&lt;/strong&gt; ：原有代碼宏被遷移至新文件時，新文件頭部刪除了既有版權持有者信息，僅保留了新貢獻者署名，且代碼許可證從 「MIT AND X11」 被擅自更改為 「MIT OR X11」，這導致相關代碼被回退。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;功能破壞&lt;/strong&gt; ：此前的 「RandR 清理工作」 導致部分 RandR 功能失效，因此本週合併了針對此的大規模回退 。此外，一些新補丁的添加也可能導致功能破壞，進而引發回滾操作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;對驅動的影響&lt;/strong&gt; ：部分回退是為了避免對 NVIDIA 驅動造成不必要破壞。NVIDIA 方面也表示，後續還將提出更多回退請求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;代碼價值及設計意圖問題&lt;/strong&gt; ：一些代碼的價值存疑，或是開發者在未理解 X.Org 開發者最初添加某些宏的設計意圖就貿然修改，從而引發了回退操作。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="486" src="https://static.oschina.net/uploads/space/2025/0617/144634_Ala5_2720166.png" width="1852" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2012" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2012&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="436" src="https://static.oschina.net/uploads/space/2025/0617/144711_8iBz_2720166.png" width="2050" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2017%23note_2956688" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2017#note_2956688&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="354" src="https://static.oschina.net/uploads/space/2025/0617/144742_k5G0_2720166.png" width="1556" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2019" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2019&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</guid>
      <pubDate>Sat, 10 May 2025 06:57:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AMD 新 MI350 攪動 AI 芯片市場，微美全息加快 AI 算力+產業鏈垂直整合卡位賽道</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;獲悉，日前，在聖何塞舉行的「Advancing AI」大會上，AMD（AMD.US）發佈了下一代人工智能 (AI) 芯片 Instinct MI350 系列，包含 Instinct MI350X 和 MI355X GPU 及平台，代際 AI 計算能力提升 4 倍，代際推理性能躍升 35 倍。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//7763666251c9d02806fc8fc9ac8bd143.png" width="719" referrerpolicy="no-referrer"&gt;
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;strong&gt;&lt;span&gt;新一代 AI 芯片前景廣闊&lt;/span&gt;&lt;/strong&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;此外，AMD 展示了端到端開放式機櫃級 AI 基礎設施，該設施已在 Oracle Cloud Infrastructure（OCI）等超大規模部署中應用，集成 AMD Instinct MI350 系列加速器、第五代 AMD EPYC™處理器和 AMD Pensando™ Pollara 網卡，2025 年下半年將全面上市。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;值得注意的是，該公司還推出了一款名為 Helios 的全服務器機架，搭載 Instinct MI400 系列芯片，最多可在一台服務器中配置 72 顆芯片，預計該芯片系統對雲公司和大型語言模型開發商等人工智能客戶至關重要。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//d8910d810c68fc04fb3945b0e2317bc4.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;span&gt;&lt;span&gt;蘇姿豐稱，AMD 展示了全新的開放、可擴展的人工智能基礎設施產品，目標是與市場領導者英偉達（NVDA.US）競爭。最新發布的 AI 處理器在性能上可挑戰英偉達產品，在價格方面，AMD 的產品遠低於英偉達。&lt;/span&gt;&lt;/span&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;今年 2 月，AMD 發佈的數據中心業務展望顯示其增長速度低於部分分析師預期。AMD 認為，MI 系列的這次更新將重振公司增長勢頭，預測 AI 芯片市場規模未來三年將超 5000 億美元，並證明其有實力與體量遠大的競爭對手正面交鋒。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//a5d5428aeb4d511dbc525631e33349c6.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;strong&gt;&lt;span&gt;AI 芯片博弈混戰&lt;/span&gt;&lt;/strong&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;當下，人工智能 ( AI ) 是這個時代重要的命題之一。尤其以 DeepSeek 為代表的大模型的廣泛應用, 促進了算力迭代; 在全面鋪開的 AI 長卷中, 夯實算力這一基石, 對於企業的數智化轉型升級至關重要。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;隨着全球範圍內的大型科技公司向人工智能基礎設施投入數百億美元，對 AI 芯片的市場需求持續超過供應，推動芯片價格飆升，部分產品甚至高達數萬美元一枚。從底層技術的角度, 充分發揮 CPU 的驅動力, 助力千行百業更好賦能 " 人工智能 +", 需要變中求進。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//7eb6d65ed1bd5d72b439e3c2fa01c026.png" width="612" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;strong&gt;&lt;span&gt;微美全息催生 AI 算力+產業鏈垂直整合&lt;/span&gt;&lt;/strong&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;AI 正在各行各業引爆前所未有的變革，對於企業來説 , 如果選錯賽道可能意味着輸在起跑線上。資料顯示，AI 芯片企業微美全息（WIMI.US）加速 AI 在企業中落地，隨着 AI 應用不斷走向深入，推動其在 AI 算力芯片生態建設和合作研發，憑藉自身的優勢，更好助力 AI 產業全球競爭。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;當前，微美全息通過整合芯片-算法-場景技術鏈，構建覆蓋 AI 算力全流程的創新體系，自主研發的高性能 AI 芯片及計算集羣支持大規模模型訓練和推理，並佈局量子信息技術提升算力密度，適配多模態大模型、邊緣計算等場景需求，實現毫秒級數據傳輸效率，芯片產品覆蓋 AI 人機交互、智能機器人、無人駕駛等新質生產力升級。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;strong&gt;&lt;span&gt;結語&lt;/span&gt;&lt;/strong&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;實際上，從 Advancing AI 2025 大會上獲得信息來看，AMD 將按照既定的人工智能基礎設施推進計劃, 不斷創新和擴展架構, 致力於將新的 GPU 架構整合到完整的 AI 系統中, 為 AI 的深入應用提供源源不斷的算力。而在這場沒有硝煙的戰爭中，真正的贏家，終將是那些堅守長期主義、擁抱開放創新的智者。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355801</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355801</guid>
      <pubDate>Sat, 10 May 2025 06:39:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>豆包電腦版與網頁版上線「AI 播客」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;豆包電腦版已全量上線 AI 播客功能。該功能已在釦子空間、豆包電腦版上線；豆包 App 也已開啓小流量測試，將於近期全量上線。&lt;/p&gt; 
&lt;p&gt;用戶只需訪問&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxn--doubao-295jx85g4v9amh9bmoxa51c.com" target="_blank"&gt; doubao.com&lt;/a&gt;，在頁面中選擇「AI 播客」功能，隨後上傳 pdf 文件或網頁鏈接，便能迅速生成一段雙人對話形式的播客內容。&lt;/p&gt; 
&lt;p&gt;&lt;img height="279" src="https://oscimg.oschina.net/oscnet/up-877916c1b4fad2396c34f71edb9e0b5424b.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據介紹，在語音效果方面，豆包播客生成的語音極為自然，能夠精準模擬真人播客的口語習慣，在對話過程中，停頓、附和等細節處理得恰到好處，完全去除了生硬的機器感。&lt;/p&gt; 
&lt;p&gt;使用「AI 播客」功能，在工作場景下，用戶可將行業報告或競品分析的鏈接發送給豆包，瞬間就能得到一段通俗易懂的播客內容，方便在忙碌的工作間隙快速獲取關鍵信息。在學習場景中，學生可以把課程知識點等基礎資料交給豆包，將文字轉化為對話形式的播客，實現隨時隨地「聽學習」，有效提升知識吸收效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355796</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355796</guid>
      <pubDate>Sat, 10 May 2025 06:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>前百度算法工程師、零一萬物高管李先剛出任阿里通義語音實驗室負責人</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《科創板日報》消息稱，前百度算法工程師、零一萬物高管李先剛已加入阿里，擔任通義語音實驗室負責人。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="375" src="https://oscimg.oschina.net/oscnet/up-3eb7193c346bf36d099ad08b95ac57f8819.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公開資料顯示，李先剛博士畢業於北京大學，先後在百度、滴滴擔任首席算法工程師。離開滴滴後，李先剛加入貝殼，任策略算法中心負責人。2023 年李先剛加入零一萬物團隊，擔任聯合創始人、技術副總裁，後又離職迴歸貝殼。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李先剛在零一萬物任職期間，公司完成了 A 輪融資，金額為數億美元。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355790</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355790</guid>
      <pubDate>Sat, 10 May 2025 06:00:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>我的開源十年</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;🌟&amp;nbsp;依稀記得十年前，發的第一條關於 OpenAuth.Net 的博客：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FOpenAuth.html" target="_blank" rel="nofollow"&gt;領域驅動設計實戰—基於 DDDLite 的權限管理 OpenAuth.net&lt;/a&gt;。那時 star 數只有 1，現在各種平台零零散散東拼西湊加起來也 7K 多了😂。那時候，我對 DDD（領域驅動設計）簡直是走火入魔，覺得它就是我通往高級境界、人生巔峯的不二法門。十年過去了，手搓過的項目多如牛毛，但 DDD 卻早已被拋到九霄雲外，好像啥用沒有，又好像已經融入到我的血液裏。&lt;/p&gt; 
&lt;p&gt;🚀 這十年來，技術棧換了一茬又一茬。從 asp.net mvc 到 asp.net core 到.net 6、7...10，從 jquery 到 vue，寫了 c++、java、python、R 等等等等，直到現在，用上個 cursor，語法都不用學都可以手搓一個站點出來：&lt;a href="https://gitee.com/yubaolee/AstroFast" target="_blank" rel="nofollow"&gt;使用 Astro 三天完成官網&lt;/a&gt;。看着&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2F4652772.html" target="_blank" rel="nofollow"&gt;為了理想，我放棄了一切&lt;/a&gt;，彷彿又回到了十年前，那個對技術充滿好奇的少年。&lt;/p&gt; 
&lt;p&gt;❤️&amp;nbsp;這十年，學過無數、放棄過無數。但唯一堅持的就是&lt;a href="https://gitee.com/dotnetchina/OpenAuth.Net" target="_blank" rel="nofollow"&gt;OpenAuth.Net&lt;/a&gt;，它對我的意義已經不是一個開源項目，而是我這十年來的記憶。心情特別好的時候，更新一下；突然難過的時候，更新一下；喝完酒大醉的時候，更新一下；夜深人靜睡不着的時候，更新一下。這些年忘記很多事請，但它一直都在。&lt;/p&gt; 
&lt;p&gt;📢&amp;nbsp;嘮叨了這麼多，怎麼也得來點乾貨。今天我想讓它被更多人知道，也想它能幫更多人節約開發時間。於是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;✅全面開源原付費 vue2 版本源碼及文檔，免費使用&lt;/span&gt;&lt;/strong&gt;。當然對於以前付費用戶，可以免費升級 vue3 版本。詳見官網説明：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.openauth.net.cn%2Fnewpricing%2F" target="_blank" rel="nofollow"&gt;全新定價&lt;/a&gt;。&lt;/li&gt; 
 &lt;li&gt;✅&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;&lt;strong&gt;放棄&lt;/strong&gt;&lt;/span&gt;原有 mvc 版本。&lt;/li&gt; 
 &lt;li&gt;✅提供 UniApp 版本。&lt;/li&gt; 
 &lt;li&gt;✅更快更新優化 vue3 版本。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;目前市面上快速開發、權限管理方面優秀的.NET 開源項目很多，但我給 OpenAuth.Net 定了以下幾條規則：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;不強制綁定 gitee、github 登錄 star 後才能訪問演示站點、文檔等。&lt;/li&gt; 
 &lt;li&gt;更新快，基本每週都有更新，有問題及時修復。&lt;/li&gt; 
 &lt;li&gt;文檔永不收費，所有人可見。&lt;/li&gt; 
 &lt;li&gt;開源版本代碼不做任何限制，任何人都可以免費學習使用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;💯就是説，要就要&lt;span style="font-size: 18px"&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1)"&gt;真&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;開源！&lt;/p&gt; 
&lt;p&gt;🤔扯了這麼多，OpenAuth.Net 到底值不值得入坑呢？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持最新版.Net 9.0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同時支持 EntityFramework、SqlSugar 兩款最流行的 ORM 框架&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;內置代碼生成器，可快速生成帶有頭/明細結構的頁面，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fvue2%2Fdevnew%2F" target="_blank" rel="nofollow"&gt;代碼生成&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;超強的自定義權限控制功能，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FDataPrivilege.html" target="_blank" rel="nofollow"&gt;通用權限設計與實現&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;完整 API 鑑權，可以控制角色可訪問的 API 資源，及模塊功能字段可見及是否返回，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fapiauth.html%23%25E6%258C%2589%25E8%25A7%2592%25E8%2589%25B2%25E6%258E%2588%25E6%259D%2583api%25E8%25B5%2584%25E6%25BA%2590" target="_blank" rel="nofollow"&gt;按角色授權 API 資源&lt;/a&gt;&amp;nbsp;及&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fdatapropertyrule%2F" rel="nofollow" target="_blank"&gt;字段權限&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可拖拽的表單設計。詳情：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fdragform%2F" rel="nofollow" target="_blank"&gt;可拖拽表單&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可視化流程設計。&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fstartflow%2F" rel="nofollow" target="_blank"&gt;可視化流程設計&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;全網最好用的打印解決方案。詳情:&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fprinterplan%2F" rel="nofollow" target="_blank"&gt;智能打印&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基於 Quartz.Net 的定時任務控制,可隨時啓/停，可視化配置 Cron 表達式功能，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fjob%2F" rel="nofollow" target="_blank"&gt;定時任務&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持 sqlserver、mysql、Oracle、PostgreSql 數據庫，理論上支持所有數據庫&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持同時訪問多數據源&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多租戶&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持搭建自己的 IdentityServer 服務器，實現基於 OAuth2 的登錄體系，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fidentity%2F" rel="nofollow" target="_blank"&gt;登錄認證及 OAuth 集成&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;最後放兩張靚圖養養眼：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153920_WFRd.png" height="575" width="1003" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_YBn9.png" height="644" width="1006" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_wsSc.png" height="484" width="1002" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/yubaolee/blog/18620526</link>
      <guid isPermaLink="false">https://my.oschina.net/yubaolee/blog/18620526</guid>
      <pubDate>Sat, 10 May 2025 05:51:00 GMT</pubDate>
      <author>工作日誌</author>
    </item>
    <item>
      <title>研究：Meta Llama 3.1 能回憶《哈利波特》42% 的內容</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;一組來自斯坦福大學、康奈爾大學和西弗吉尼亞大學的計算機科學家與法律學者近日共同發表了一項引人矚目的研究，分析了幾款開源大型語言模型在文本記憶方面的表現。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這項研究着重考察了五種不同的開放權重模型，它們的能力是否能夠重複經典書籍中的內容。這五款模型中，有三款來自 Meta，另外兩款分別由微軟和 EleutherAI 開發。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究團隊採用了 Books3 這一流行的書籍數據庫，作為訓練這些大模型的素材，值得一提的是，這些書籍中許多依然受到版權保護。研究者們將 36 本書劃分為多個重疊的 100 個標記段落，然後利用前 50 個標記作為提示，計算接下來的 50 個標記與原文相同的概率。如果逐字重複的概率超過 50%，那麼這段內容就被標記為 「已記住」。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="390" src="https://oscimg.oschina.net/oscnet/up-e0eabffd56c2b6277a8c21feb6af1558c4f.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;令人驚訝的是，Meta 於 2024 年發佈的 Llama3.170B 模型在回憶《哈利波特》&lt;span&gt;第一&lt;/span&gt;部的表現中，竟能記住 42% 的內容。而相比之下，Meta 在 2023 年發佈的 Llama165B 模型僅能回憶起 4.4% 的內容。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究人員還發現，相較於冷門書籍，Llama3.170B 在熱門書籍如《霍比特人》和喬治・奧威爾的《1984》中的記憶能力更為突出，記憶量遠高於其他模型。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355785</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355785</guid>
      <pubDate>Sat, 10 May 2025 05:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>🔥 Solon AI 五步構建 RAG 服務：2025 最新 AI + 向量數據庫實戰</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#24292e; text-align:start"&gt;此文參考自：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F7506140643970826779%2F" target="_blank"&gt;https://www.toutiao.com/article/7506140643970826779/&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;引言：RAG 會成為 2025 年 AI 落地核心？&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在 2025 年，檢索增強生成（RAG）技術已成為企業級 AI 應用的標配。傳統大模型受限於知識更新慢、業務適配性差，而 RAG 通過動態外接知識庫，結合向量數據庫與 AI 推理能力，顯著提升回答的準確性與實時性。本文將基於 Solon AI 與 Redis Vector Search，從 0 到 1 搭建 RAG 服務，並結合電商客服場景，揭祕如何通過 5 步實現生產級落地。&lt;/p&gt; 
&lt;h2&gt;一、項目初始化：Solon AI&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;核心依賴：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai-repo-redis&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai-load-pdf&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置參考：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;solon.ai.chat:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;ds3:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;apiUrl:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"http://127.0.0.1:11434/api/chat"&lt;/span&gt; &lt;em&gt;# 使用完整地址（而不是 api_base）&lt;/em&gt;
    &lt;span style="color:#986801"&gt;provider:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"ollama"&lt;/span&gt; &lt;em&gt;# 使用 ollama 服務時，需要配置 provider&lt;/em&gt;
    &lt;span style="color:#986801"&gt;model:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"llama3.2"&lt;/span&gt;

&lt;span style="color:#986801"&gt;solon.ai.embed:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;bgem3:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;apiUrl:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"http://127.0.0.1:11434/api/embed"&lt;/span&gt; &lt;em&gt;# 使用完整地址（而不是 api_base）&lt;/em&gt;
    &lt;span style="color:#986801"&gt;provider:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"ollama"&lt;/span&gt; &lt;em&gt;# 使用 ollama 服務時，需要配置 provider&lt;/em&gt;
    &lt;span style="color:#986801"&gt;model:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"bge-m3:latest"&lt;/span&gt;
        
&lt;span style="color:#986801"&gt;solon.ai.repo:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;redis:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;server:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;localhost:6379&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;實例構建：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.redisx.RedisClient;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.ChatModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.embedding.EmbeddingModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.RepositoryStorable;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.repository.RedisRepository;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.repository.redis.MetadataField;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Bean;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Configuration;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Configuration&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagConfig&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; ChatModel &lt;span style="color:#4078f2"&gt;chatModel&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.chat.ds3}")&lt;/span&gt; ChatModel chatModel)&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; chatModel;
    }

    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; EmbeddingModel &lt;span style="color:#4078f2"&gt;embeddingModel&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.embed.bgem3}")&lt;/span&gt; EmbeddingModel embeddingModel)&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; embeddingModel;
    }

    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; RedisClient &lt;span style="color:#4078f2"&gt;client&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.repo.redis}")&lt;/span&gt; RedisClient client)&lt;/span&gt; {  &lt;em&gt;//構建知識庫的連接客戶端&lt;/em&gt;
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; client;
    }
    
    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; RepositoryStorable &lt;span style="color:#4078f2"&gt;repository&lt;/span&gt;&lt;span&gt;(EmbeddingModel embeddingModel, RedisClient client)&lt;/span&gt; { &lt;em&gt;//構建知識庫&lt;/em&gt;
        &lt;em&gt;// 創建元數據索引字段列表（用於支持混合搜索）&lt;/em&gt;
        List&amp;lt;MetadataField&amp;gt; metadataFields = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();
        metadataFields.add(MetadataField.tag(&lt;span style="color:#50a14f"&gt;"title"&lt;/span&gt;));
        metadataFields.add(MetadataField.tag(&lt;span style="color:#50a14f"&gt;"category"&lt;/span&gt;));
        metadataFields.add(MetadataField.numeric(&lt;span style="color:#50a14f"&gt;"price"&lt;/span&gt;));
        metadataFields.add(MetadataField.numeric(&lt;span style="color:#50a14f"&gt;"stock"&lt;/span&gt;));

        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; RedisRepository.builder(embeddingModel, client.jedis())
                .metadataIndexFields(metadataFields)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;技術選型優勢：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Redis Vector Search（建議 Redis 8+）：支持千億級向量毫秒檢索，實時數據更新秒級可見&lt;/li&gt; 
 &lt;li&gt;Solon AI：統一接口支持各種主流向量數據庫，內置流式輸出與異步處理。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;二、數據處理：文檔分塊與向量化&lt;/h2&gt; 
&lt;h3&gt;1. 文檔加載與分塊&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;{
        &lt;em&gt;// 加載 PDF/Word 文檔&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分塊（動態調整塊大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;分塊策略：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;動態分塊：根據語義邊界（如段落、表格）自動調整塊大小，避免信息割裂；&lt;/li&gt; 
 &lt;li&gt;重疊機制：設置 64 Token 的重疊區，確保上下文連貫性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2. 向量嵌入與存儲&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在 RagService 的基礎上，進一步補充&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.embedding.EmbeddingModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.Document;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.RepositoryStorable;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.splitter.TokenSizeTextSplitter;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Component;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.io.IOException;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; RepositoryStorable  repository;
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; EmbeddingModel embeddingModel;

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;em&gt;// 加載 PDF/Word 文檔&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分塊（動態調整塊大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);

        &lt;em&gt;// 存儲（內部自動完成向量嵌入，內部支持分批入庫）&lt;/em&gt;
        repository.insert(docs);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;性能優化：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;批量處理：數據批次插入，降低 I/O 開銷；&lt;/li&gt; 
 &lt;li&gt;元數據附加：為每個向量附加來源、時間戳等字段，支持精準過濾。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三、檢索增強：混合搜索&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;使用元信息字段 category 過濾（減少匹配範圍），並使用向量檢索&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; RepositoryStorable repository;
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; EmbeddingModel embeddingModel;

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;em&gt;// 加載 PDF/Word 文檔&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分塊（動態調整塊大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);

        &lt;em&gt;// 存儲（內部自動完成向量嵌入）&lt;/em&gt;
        repository.insert(docs);
    }

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; List&amp;lt;Document&amp;gt; &lt;span style="color:#4078f2"&gt;find&lt;/span&gt;&lt;span&gt;(String category, String query)&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; repository.search(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;QueryCondition&lt;/span&gt;(query)
                .filterExpression(&lt;span style="color:#50a14f"&gt;"category == '"&lt;/span&gt; + category + &lt;span style="color:#50a14f"&gt;"'"&lt;/span&gt;));
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;場景適配：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;元數據檢索：處理明確實體（如商品目錄）；&lt;/li&gt; 
 &lt;li&gt;向量檢索：應對複雜語義（如「性價比高的手機推薦」）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;四、生成優化：提示工程與流式輸出&lt;/h2&gt; 
&lt;h3&gt;1. 動態 Prompt 設計&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;promptTemplate&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"""
    你是一名電商客服專家，請根據以下上下文回答問題：
    #{context}
    問題：#{question}
    要求：回答需包含具體數據，若信息不足則回覆「暫未收錄」。
    示例：庫存查詢 → 「當前 iPhone 20 庫存為 500 件，預計 48 小時發貨。」
    """&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;關鍵技巧：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;指令約束：限制回答範圍，減少幻覺；&lt;/li&gt; 
 &lt;li&gt;示例引導：提供標準回答格式，提升一致性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2. 流式響應與溯源&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;寫一個控制器，整合 ChatModel 和 RagService&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.ChatModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.message.ChatMessage;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.Document;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Controller;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Mapping;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; reactor.core.publisher.Flux;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.io.IOException;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Controller&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagController&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    RagService ragService;

    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    ChatModel chatModel;

    &lt;span style="color:#a626a4"&gt;static&lt;/span&gt; &lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;promptTemplate&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"""
        你是一名電商客服專家，請根據以下上下文回答問題：
        #{context}
        問題：#{question}
        要求：回答需包含具體數據，若信息不足則回覆「暫未收錄」。
        示例：庫存查詢 → 「當前 iPhone 20 庫存為 500 件，預計 48 小時發貨。」
        """&lt;/span&gt;;

    &lt;span style="color:#4078f2"&gt;@Mapping("/ask")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; Flux&amp;lt;String&amp;gt; &lt;span style="color:#4078f2"&gt;streamAnswer&lt;/span&gt;&lt;span&gt;(String question)&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        List&amp;lt;Document&amp;gt; context = ragService.find(&lt;span style="color:#50a14f"&gt;"商品"&lt;/span&gt;, question);
        
        &lt;span style="color:#986801"&gt;ChatMessage&lt;/span&gt; &lt;span style="color:#986801"&gt;message&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; ChatMessage.ofUserTmpl(promptTemplate)
                .paramAdd(&lt;span style="color:#50a14f"&gt;"question"&lt;/span&gt;, question)
                .paramAdd(&lt;span style="color:#50a14f"&gt;"context"&lt;/span&gt;, context)
                .generate();

        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; Flux.from(chatModel.prompt(message).stream())
                .filter(resp -&amp;gt; resp.hasChoices())
                .map(resp -&amp;gt; resp.getMessage().getContent());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;用戶體驗優化：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;逐字輸出：響應延遲降低至 100ms 以內（要看模型服務的性能）；&lt;/li&gt; 
 &lt;li&gt;來源標記：返回答案關聯的文檔 ID 與置信度。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;五、實戰案例：電商客服 RAG 系統&lt;/h2&gt; 
&lt;h3&gt;場景：秒殺活動問答&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;需求：用戶詢問「iPhone 20 秒殺庫存和優惠規則」。&lt;/p&gt; 
&lt;h4&gt;RAG 處理流程：&lt;/h4&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;檢索：從商品手冊中匹配「iPhone 20」的庫存條款與促銷規則； 生成：返回「當前庫存 2000 件，限購 1 台，疊加滿減券再降 500 元」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355781</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355781</guid>
      <pubDate>Sat, 10 May 2025 03:48:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>木蘭編程語言重現項目五年回顧</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;h3&gt;簡介&lt;/h3&gt; 
&lt;p&gt;旨在重現 2020 年初報道後即被指為「Python 套殼」、「換皮」的木蘭編程語言工具的所有功能。揣摩設計思路、驗證實現技術路徑及其可持續維護性。為低代價實現原創編程語言工具尤其是前端部分提供標本，也通過懸賞任務為開源合作探索新模式。&lt;/p&gt; 
&lt;h3&gt;歷程&lt;/h3&gt; 
&lt;p&gt;五年前 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F265091649" target="_blank"&gt;因緣巧合的邂逅&lt;/a&gt; 後，一月二十三日啓動 &lt;a href="https://gitee.com/MulanRevive/mulan-rework"&gt;木蘭重現項目&lt;/a&gt; 並重金懸賞。&lt;/p&gt; 
&lt;p&gt;一月二十五日即於 GitHub 迎來首位響應者。感激 @thautwarm，受教良多。期間項目目標精確化。&lt;/p&gt; 
&lt;p&gt;2020 年六月項目搬遷到開源中國的 Gitee 平台。&lt;/p&gt; 
&lt;p&gt;至 2023 年一月復現幾乎所有命令行選項，作了講座 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Flives%2F1596877608825921536" target="_blank"&gt;三年小結&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;繼 2023 年四月添加對 Python 3.8 的支持後，2024 年陸續添加了對 Python 3.9-3.12 的支持。&lt;/p&gt; 
&lt;p&gt;下圖是懸賞歷史，詳見&lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E6%94%B6%E6%94%AF%E8%B4%A6%E6%9C%AC"&gt;收支賬本&lt;/a&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://gitee.com/MulanRevive/bounty/raw/master/%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/%E6%88%AA%E5%9B%BE/2025-04-15-%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E.png" alt="懸賞歷史" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;合作體會：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;平台支持之重要：Gitee 懸賞功能於 2021 年四月底上線，合作從此加速&lt;/li&gt; 
 &lt;li&gt;任務細化，確保可控&lt;/li&gt; 
 &lt;li&gt;團隊之珍貴&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;項目相關文章匯於 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Fcolumn%2Fulang" target="_blank"&gt;知乎專欄&lt;/a&gt;。&lt;/p&gt; 
&lt;h3&gt;希冀&lt;/h3&gt; 
&lt;p&gt;原創編程語言的最大困難之一，是要「從零手寫編譯器」的心理陰影。希望此項目能讓更多業務開發者可以更專注於語言工具與人的交互設計，並在需要時藉助現有生態、以儘可能小的代價完成原型驗證並逐漸過渡到實用產品。&lt;/p&gt; 
&lt;h3&gt;鳴謝&lt;/h3&gt; 
&lt;p&gt;期間碰到開發流程和懸賞等相關問題提出報告後，Gitee 官方充分支持響應，非常感激！&lt;/p&gt; 
&lt;p&gt;感激所有項目參與者的資助、合作時的耐心和探究精神！&lt;/p&gt; 
&lt;p&gt;為重現五年前曇花一現的 &lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%96%99/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"&gt;ulang-0.2.2.exe&lt;/a&gt; 的花費雖可觀，但和原創團隊從設計到推廣所耗心血不可相提並論。致敬他們的創意、熱情和付出！&lt;/p&gt; 
&lt;p&gt;天涯若比鄰。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4552012/blog/18489924</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4552012/blog/18489924</guid>
      <pubDate>Sat, 10 May 2025 03:46:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>得物自研 DScript2.0 腳本能力從 0 到 1 演進</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
 &lt;h1&gt;一、前言&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在高併發推薦引擎場景中，C++的極致性能往往以開發效率為妥協，尤其在業務頻繁迭代時，C++的開發效率流程成為顯著瓶頸。傳統嵌入式腳本（如 Lua）雖支持動態加載，但其與 C++的交互成本（如虛擬棧數據中轉、類型轉換）仍會帶來額外性能損耗。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;為此，我們探索設計 DScript2.0——一種與 C++內存佈局及調用約定深度兼容的動態腳本語言，通過自研編譯器實現即時編譯與無縫嵌入，嘗試在保留腳本靈活性的同時，儘可能貼近 C++的原生性能，為性能與效率的平衡提供了輕量化解決方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
 &lt;h1&gt;二、動態腳本在引擎中的引用&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;C++引擎的迭代效率瓶頸&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在搜推引擎中的實踐中，出於對高併發場景下極致性能的追求，使用 C++進行引擎自研成為了一種業界常態。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;眾所周知，C++通過開放底層控制權限（如內存分配，指令優化等），提升了可達的性能上限，但這種提升伴隨了大量底層細節的處理，消耗了更多的開發時間，追求性能優先的同時，卻又限制了開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我們希望能夠在保持性能的同時，提升引擎的開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;利用嵌入式腳本提升迭代效率&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我們的目標是尋求一種平衡性能與迭代效率的方案，一種主流方案是在 C++中嵌入腳本語言。例如，在遊戲引擎和 Nginx 開發中集成 Lua，在 C/C++代碼中實現性能需求，結合腳本代碼中實現控制邏輯，從而提升開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式腳本對迭代效率的提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持動態加載，無需編譯部署。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;無需 C/C++經驗，腳本學習成本低，提升參與迭代的人力總量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;引擎的迭代拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎內部的技術性迭代&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;業務側的需求支持&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;業務側的需求非常適合引入嵌入式腳本，實現對易變需求的自迭代，提升開發效率，這也是一種業界主流方案。例如，一些搜索中台中，對於相關性和粗排邏輯封裝為插件，業務側的算法工程師使用 Lua 開發計算邏輯，可以極大地提升迭代效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;嵌入式腳本的額外性能開銷&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在引擎中嵌入腳本，雖然可以提升迭代效率，但並非全無代價，高階語言與低階語言的交互存在着額外的性能開銷。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，Lua 和 C++的交互機制基於 Lua 提供的虛擬棧來實現，這個棧是兩者進行數據交換的核心通道。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用虛擬棧實現語言交互存在額外的開銷，包括但不限於壓棧和彈棧操作、棧空間管理、類型檢查和轉換、複雜數據結構的處理等。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="473" src="https://oscimg.oschina.net/oscnet/up-0054288a2e3e644efffe3b1ed219cd34818.jpg" width="920" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;更加極致的方案&amp;nbsp;&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;基於以上的瓶頸，我們期望一種更加極致的方案，實現性能與效率的平衡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式腳本的額外性能開銷&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;（主要源於兩種語言在 ABI 層面的不一致）&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;函數調用約定不一致，需要一個虛擬棧進行中轉。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據類型內存佈局不一致，需要額外的檢查和轉換。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;一個直觀的解決方案就是我們設計一種編程語言，在底層實現上與 C++具有一致內存佈局與調用約定，從而消除額外的轉換開銷。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;同時，這種編程語言可以在 C++嵌入，也支持即時編譯，提升效率的同時，也擁有與原生 C++近似的執行性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;以上是我們規劃 DScript2.0 項目初衷。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_7"&gt;&lt;/span&gt; 
 &lt;h1&gt;三、DScript2.0 的編譯器實現&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;語法設計&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 被設計為一種輕量級面向過程的編程語言，同時它也是靜態類型的編譯語言。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在語法支持上，包含了基礎數據類型、變量、運算符、控制流和函數，額外支持了與 C++的語言互操作。&lt;/span&gt;&lt;/p&gt; 
 &lt;table style="width:574px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;數據類型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;int，long，bool，float，double，void&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;變量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自定義變量，隱式類型轉換。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++變量：支持訪問和操作外部註冊的 C++變量，支持 C++的結構體部分操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;運算符&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;算術運算符：+，-，*，/，%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;關係運算符：==，!=，&amp;gt;=，&amp;gt;，&amp;lt;=，&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;邏輯運算符：!，&amp;amp;&amp;amp;，||&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;賦值運算符：=，+=&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自增自減運算符：++i，--i&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;控制流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;分支語句：if (...) else if (...) else&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;循環語句: for 循環&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;函數&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;自定義函數：基礎類型值傳遞，對象類型引用傳遞。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++API：支持調用外部註冊的 C++函數。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;淺析編譯器架構&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;img height="114" src="https://oscimg.oschina.net/oscnet/up-cc6c2fd61871eded90a60e6e26ea2d701a2.png" width="998" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（編譯器的三段結構）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;一個完整的編譯器通常由三個主要部分組成：前端、優化器和後端。&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;前端：&lt;/strong&gt;負責詞法分析、語法分析、語義分析、生成中間代碼。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;優化器（中端）：&lt;/strong&gt;負責對中間代碼進行優化。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;後端：&lt;/strong&gt;負責將中間代碼轉換成目標機器的的機器碼。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;基於 LLVM 實現 DScript2.0 編譯器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="206" src="https://oscimg.oschina.net/oscnet/up-3b5d7a82e72a82da5af334b5f4b8f4218be.png" width="558" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM 是一個模塊化且高度可重用的編譯器基礎設施項目。它提供了前端、優化器和後端工具鏈，已支持多種編程語言和平台。LLVM 具有跨平台性，允許開發者靈活定製編譯流程，提供高級優化能力，支持即時編譯，被廣泛用於編譯器開發、虛擬機和代碼分析工具場景。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;採用 LLVM 實現 DScript2.0 的優勢&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;提升開發效率：&lt;/strong&gt;LLVM 的前端、中端和後端採用了模塊化設計，每個部分都可以獨立替換或擴展，這種靈活性使得 LLVM 非常適合定製編譯器，&lt;strong&gt;我們可以複用 LLVM 的中端與後端，專注於前端開發，減少開發成本。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持高級優化：&lt;/strong&gt;LLVM 提供了一套強大的優化工具，能夠對代碼進行靜態和動態優化。這些優化不僅能夠提高代碼的執行效率，還可以減少代碼體積。&lt;strong&gt;這是 DScript2.0 理論上可能提供接近原生 C++性能的關鍵因素之一。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持即時編譯：&lt;/strong&gt;LLVM 支持即時編譯（JIT），通過 JIT 編譯，LLVM 能夠在運行時生成和執行代碼，大大提升了執行效率。通過運行時進行編譯後運行，&lt;strong&gt;這是 DScript2.0 理論上可能提供接近原生 C++性能的關鍵因素之二&lt;/strong&gt;。支持在線的即時編譯能力，&lt;strong&gt;同時也是算子開發與分發效率的保障。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;DScript2.0 編譯器架構&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1454" src="https://oscimg.oschina.net/oscnet/up-e75e425f479ce08e65ea5b597f1b04f7366.jpg" width="1594" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 編譯器同樣包含前端、中端、後端三部分，前端能力自研，優化器和後端基於 LLVM 的 Pass 和 JIT 實現。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;編譯器最終輸出為 x86_64 平台的可執行二進制，以 JIT 實例的方式常駐內存，通過入口函數地址執行。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;編譯器支持注入 C++類型與函數參與編譯，實現 DScript2.0 對 C++的調用。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器前端實現&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;前端的實現流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;編譯器前端的任務是&lt;strong&gt;將源碼轉換為優化器可處理的中間代碼&lt;/strong&gt;，這個轉換的流程通常包含 4 個步驟：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;詞法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語義分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中間代碼生成&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="653" src="https://oscimg.oschina.net/oscnet/up-184dcf9ec5eea648706894ea1f861cf8399.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（編譯器前端架構）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;詞法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;源代碼是一堆連續的字符，計算機要先識別出這些字符組成的基本單元，才能進一步理解代碼含義。就像讀句子先得認出單詞一樣，這是理解程序的第一步。詞法分析的本質是&lt;strong&gt;將代碼的字符流，轉換為更易處理的 token 流。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：字符流-&amp;gt;記號流（Tokens）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;詞法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中了使用 Flex，可以根據自定義的正則表達式規則，自動生成詞法分析的掃描器，減少手工編寫詞法分析器的工作量。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 工作流程&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-a4857fc6f269c2441e72179493b1a628b42.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 語法&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 Flex 的定義文件中包含三部分：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;定義段：&lt;/strong&gt;包含頭文件和全局變量，如輸入和輸出流的定義。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;規則段：&lt;/strong&gt;由模式和對應的動作組成。當掃描器匹配到模式時，執行對應的動作。例如，匹配到"int"字符串時，將其識別為 INT 標識。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;用戶代碼段：&lt;/strong&gt;通常可以在此區域定義&lt;strong&gt;&amp;nbsp;main()&amp;nbsp;&lt;/strong&gt;函數，它調用&lt;strong&gt;&amp;nbsp;yylex()&amp;nbsp;&lt;/strong&gt;，啓動詞法分析過程。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 定義段段開始 */
/* 引入的 c/c++代碼 */
%{
#include &amp;lt;string&amp;gt;
%}


/* 正則表達式的宏定義 */
LineTerminator &amp;nbsp; &amp;nbsp; &amp;nbsp; \n|\r|\r\n
WhiteSpace &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [ \t\f]|{LineTerminator}
Identifier &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [a-zA-Z_][a-zA-Z0-9_]*
/* 定義段結束 */


%%




/* 規則段開始 */
/* 規則：正則表達式 { return 傳遞給語法分析器的記號類型 } */
"int"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;INT; }
"float"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;FLOAT; }
"void"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;VOID; }


{Identifier} {
&amp;nbsp; &amp;nbsp; yylval.identifier = new std::string(yytext);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;IDENTIFIER;
}
{LineTerminator} {}
{WhiteSpace} {}


&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;END;
}
/* 規則段結束 */




%%




/* 用戶代碼段開始 */
/* 用戶代碼段結束 */&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;匹配規則&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;最長匹配：當多個規則可匹配時，Flex 選擇&lt;strong&gt;最長匹配&lt;/strong&gt;的詞素。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;最先定義：若多個規則長度相同，則選擇&lt;strong&gt;最先定義&lt;/strong&gt;的規則。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;語法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;語法分析的原理是根據上下文無關文法（CFG）對輸入的 tokens 序列進行分析，驗證其是否符合某種語言的語法規則，並構建對應的抽象語法樹。其核心在於建立程序的分層邏輯結構，並確保這種結構符合語法約束。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：記號流-&amp;gt;抽象語法樹（AST）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;由語法分析原理拆分&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;結構驗證：&lt;/strong&gt;檢查記號流的排列是否符合語法規則，DScript2.0 的語法規則由上下文無關文法（CFG）描述，驗證算法採用了自底向上的 LR 算法。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;// 示例：分支語法規則：if (conditon) { stmts }
// 符合語法規則
if&amp;nbsp;(a &amp;lt;&amp;nbsp;1) {


// 不符合語法規則
if&amp;nbsp;a &amp;lt;&amp;nbsp;1&amp;nbsp;{&lt;/code&gt;&lt;/pre&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;層次構建：&lt;/strong&gt;將線性的記號流轉換為樹狀或嵌套的語法結構，以抽象語法樹為例：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;FunctionDefinition
&amp;nbsp; ├── ReturnType:&amp;nbsp;int
&amp;nbsp; ├── FunctionName: func
&amp;nbsp; ├── Parameters
&amp;nbsp; │ &amp;nbsp; └── Parameter
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Name: a
&amp;nbsp; └── Body
&amp;nbsp; &amp;nbsp; &amp;nbsp; ├── VariableDeclaration
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├── Name: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; └── InitialValue
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── +
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ├── Variable: a
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Constant:&amp;nbsp;1
&amp;nbsp; &amp;nbsp; &amp;nbsp; └── ReturnStatement
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Variable: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;上下文無關文法（CFG)&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;上下文無關文法（CFG） 是編譯器語法分析的核心工具，用於形式化描述編程語言的語法結構。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;其核心要素包括：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;終結符&lt;/strong&gt;（如標識符、運算符），對應詞法分析的 Token，不可再分解。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非終結符&lt;/strong&gt;（如表達式、語句），需通過產生式規則展開為終結符或其他非終結符。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;產生式規則（如 E → E + T）&lt;/strong&gt;&amp;nbsp;，定義語法結構的生成方式。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;起始符號&lt;/strong&gt;（如&lt;strong&gt;&amp;nbsp;Program&amp;nbsp;&lt;/strong&gt;），代表語法分析的入口。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;產生式規則定義示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 局部變量聲明 -&amp;gt; 類型，變量聲明 */
/* 例如&amp;nbsp;int&amp;nbsp;a =&amp;nbsp;1&amp;nbsp;*/
/* Type 對應 int&amp;nbsp;*/
/* Variable_Declartor 對應 a =&amp;nbsp;1&amp;nbsp;*/
Local_Variable_Declartor -&amp;gt;
&amp;nbsp; &amp;nbsp; Type Variable_Declartor;


/* 變量聲明 -&amp;gt; 變量 ID 或，變量 ID = 變量初始化 */
Variable_Declartor -&amp;gt;&amp;nbsp;
&amp;nbsp; &amp;nbsp; Variable_ID
&amp;nbsp; &amp;nbsp; | Variable_ID EQ Variable_Initializer;


/* 變量 ID -&amp;gt; 標識符 */ &amp;nbsp; &amp;nbsp;
Variable_ID -&amp;gt; IDENTIFIER;


/* 變量初始化 -&amp;gt; 任意表達式 */
Variable_initializer -&amp;gt; expression;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;示例中根據形式化的語法，描述了變量定義和變量初始化規則。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;示例中包含 4 條產生式規則：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;局部變量聲明規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量聲明表達式規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量 ID 規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量初始化規則&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;終止符：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;Type 對應一個 C++的 TypeNode&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;IDENTIFIER 對應詞法定義的 Token&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;語法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;語法分析器採用 Bison 來實現，Bison 可以與 Flex 進行協作，將詞法分析器生成的記號序列解析為語法樹，供編譯器進一步處理。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;通過與 Flex 協同工作，Bison 可以自動化地處理複雜的語法分析任務，使編譯器的開發更加高效和靈活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;語義分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;通過遍歷抽象語法樹，實現上下文相關的文法檢查，對程序的類型、作用域和標識符等進行詳細檢查，&lt;strong&gt;確保程序在邏輯上符合編程語言的規則，同時生成中間表示代碼&lt;/strong&gt;，作為優化器或後端的輸入。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：&lt;/strong&gt;抽象語法樹-&amp;gt;中間代碼。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;語法分析與語義分析的區別：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;輸出目標不同：語法分析的主要任務是將記號流轉換為結構化信息，語義分析是將結構化信息翻譯為優化器可以處理的中間表示語言。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語法正確的語句，語義未必正確：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;例如，有函數原型&lt;strong&gt;&amp;nbsp;void echo(int a)&amp;nbsp;&lt;/strong&gt;，在調用時&lt;strong&gt;&amp;nbsp;int b = echo("a")&amp;nbsp;&lt;/strong&gt;，這是符合語法的，但不符合語義。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;再比如，語言要求使用變量前先定義，在未定義變量&lt;strong&gt;&amp;nbsp;a&amp;nbsp;&lt;/strong&gt;的前提下，執行賦值&lt;strong&gt;&amp;nbsp;a = 1;&amp;nbsp;&lt;/strong&gt;，這樣也是符合語法但不符合語義的。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;語義分析的主要任務&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;符號表管理&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;作用域解析&lt;/strong&gt;：追蹤變量/函數的作用域（如塊級作用域、全局作用域）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;符號綁定：&lt;/strong&gt;將標識符與其聲明關聯（如變量類型、函數簽名）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;重複定義檢查：&lt;/strong&gt;禁止同一作用域內同名符號的重複聲明。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;類型系統校驗&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;類型推斷與檢查：&lt;/strong&gt;驗證表達式和操作的合法性，如&lt;strong&gt;&amp;nbsp;int a = "str";&amp;nbsp;&lt;/strong&gt;類型不匹配。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;隱式類型轉換：&lt;/strong&gt;處理類型提升，如&lt;strong&gt;&amp;nbsp;int + float&amp;nbsp;&lt;/strong&gt;自動轉為浮點運算。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;函數簽名匹配：&lt;/strong&gt;檢查實參與形參的個數、類型一致性。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;控制流合法性&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;語句上下文檢查：&lt;/strong&gt;確保&lt;strong&gt;&amp;nbsp;break&amp;nbsp;&lt;/strong&gt;僅在循環內、&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;與函數返回類型一致。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;可達性分析：&lt;/strong&gt;檢測不可達代碼（如&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;後的語句）。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;常量表達式求值&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;優化常量計算（如&lt;strong&gt;&amp;nbsp;const x = 2 + 3*4; &amp;nbsp;&lt;/strong&gt;直接計算為&lt;strong&gt;&amp;nbsp;14&amp;nbsp;&lt;/strong&gt;）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;用於數組長度、條件編譯等需編譯期確定值的場景。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;中間代碼生成&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;中間代碼的生成流程是通過遞歸遍歷 AST 完成的，將語義檢查無誤的邏輯，轉換為中間表示語言，這是編譯器前端工作的最後一步。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中使用了&lt;strong&gt;LLVM IR&lt;/strong&gt;作為中間代碼語言，它介於高級語言和目標代碼之間，既能表達高級語言的抽象概念，又能適應底層機器代碼的生成需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 提供了豐富的指令集，涵蓋了從基本運算到複雜控制流、內存操作、同步操作等各種編程需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 指令集示例&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令種類&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令/作用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;算術和位操作指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;&amp;nbsp;add:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數加法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;sub:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數減法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;mul:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數乘法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;udiv/&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;sdiv:&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;無符號/有符號整數除法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;內存訪問指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;alloca:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;在棧上分配內存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;load:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;從內存中加載值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;store:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;將值存儲到內存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;getelementptr:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;計算數組或結構體成員的地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;比較指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;icmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span&gt;整數比較&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;fcmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;浮點數比較&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;br:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;條件或無條件分支&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;函數管理指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;call:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;調用函數&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;invoke:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;類似&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;call&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;，但支持異常處理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;ret:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;函數返回&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;phi:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;選擇多個前驅塊中的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;轉換示例：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（源代碼）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;; 函數定義: 函數名為 func，返回類型為 i32（32 位整數），參數為 i32 類型的 a
define i32 @func(i32 %a) {
entry:
&amp;nbsp; ; 定義局部變量 b，並將其初始化為 a +&amp;nbsp;1&amp;nbsp;的結果
&amp;nbsp; %b = add i32 %a,&amp;nbsp;1


&amp;nbsp; ; 返回 b 的值
&amp;nbsp; ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（與之對應的 LLVM 的中間代碼）&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器中端：中間代碼優化&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="416" src="https://oscimg.oschina.net/oscnet/up-80b965c5be150535603d8f702d40fdfd6cb.png" width="1824" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;在 DScript2.0 中，優化器是通過&lt;strong&gt;複用 LLVM 的中端優化能力&lt;/strong&gt;來實現的，通過一系列 LLVM 預置的優化遍 (Pass)，對程序生成的中間代碼進行優化，以&lt;strong&gt;提高代碼的性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中端的輸出為優化過後的 IR 指令，這些 IR 指令需要提供給後端進行編譯。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 LLVM 中，優化遍是指按照一定順序執行的一個或多個優化算法。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;以下是一些常用的優化算法：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table style="width:792px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;數據流分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;死代碼消除 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;DCE&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過數據流分析，LLVM 能夠精確地識別和刪除這些無用的指令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;全局值編號 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;GVN&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;檢測並消除等價的冗餘表達式，減少重複計算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環展開&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Unrolling)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過展開循環體中的指令，減少循環控制的開銷，並增加指令級並行性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環分割&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Split)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;將複雜的循環拆分為多個更簡單的循環，以便更好地優化每個循環。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環不變代碼外提&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;LICM&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;將循環中不變的計算移出循環體，從而減少不必要的重複計算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流優化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;條件合併&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Conditional Merging)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;合併控制流中多餘的條件判斷，從而簡化分支結構。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;跳轉線程化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Jump Threading)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;在控制流圖中，將多個條件判斷組合為一個單一的跳轉，以減少不必要的分支。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;尾調用優化 (TCO)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;優化遞歸函數調用，使得尾遞歸調用能夠直接重用當前棧幀，從而避免棧溢出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;內存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;訪問優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;內存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;別名分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Alias Analysis)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;確定不同指針是否指向相同的內存位置，從而幫助優化器在內存訪問上進行優化，如消除冗餘的內存加載和存儲操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;堆棧分配優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Stack Allocation Optimization)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過分析棧上變量的生命週期，減少不必要的內存分配和釋放，或者將棧分配的變量優化到寄存器中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器後端：即時編譯&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="267" src="https://oscimg.oschina.net/oscnet/up-f3e50fa3a189d76959930ec8fab07c58aae.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 使用 LLVM 的 ORC JIT 作為即時編譯器的實現，支持在程序運行時編譯腳本，並通過查找函數地址的方式執行腳本。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;採用即時編譯器的優勢：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;避免了開發調試過程中，頻繁的啓停程序，&lt;strong&gt;提升迭代效率。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;且經過編譯的代碼，在執行時能夠顯著&lt;strong&gt;提升運行性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;語言互操作性&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;語言互操作性是指不同編程語言能夠相互調用、協同工作的能力。通過這種能力，開發者可以在同一項目中結合多種語言的優勢。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，&lt;strong&gt;C++ 與 Lua 的結合&lt;/strong&gt;是就互操作的經典場景，常見於遊戲開發、搜推引擎、嵌入式系統等領域。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在我們的需求中，要支持動態腳本訪問引擎的表列資源，就需要 DScript2.0 也能具備與 C++交互操作的能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 與 C++的語言互操作性體現在&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以調用 C++的函數，並向 C++傳遞數據。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++可以調用 DScript2.0 的函數，並向 DScript 腳本傳遞數據。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以訪問和操作 C++傳遞的基礎類型和結構體類型變量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;調試能力&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 基於 GDB 實現了基本的調試能力：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持通過 Attach 進程進行實時調試&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;支持在 coredump 中保留棧信息&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;調試能力的實現主要基於 GDB 的通用調試接口，在編譯 DScript2.0 源碼時，生成調試信息，插入到 LLVM IR 的元數據中，然後通過 JIT 的監聽器掛載 GDB 調試接口，並注入調試信息，最終實現調試能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1066" src="https://oscimg.oschina.net/oscnet/up-f80ad594f8632e01339667c91c3e30ae47b.jpg" width="2010" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;異常處理&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中也實現了異常處理能力，主要包括了硬件異常的主動防禦和跨 C++與 DScript2.0 邊界的異常傳播。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;硬件異常防禦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;程序異常可以劃分為硬件異常和主動異常：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;硬件異常&lt;/strong&gt;是底層不可控錯誤，硬件異常的處理需依賴信號鈎子或語言運行時封裝。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;典型例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;段錯誤（SIGSEGV）：&lt;/strong&gt;非法內存訪問&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;浮點運算錯誤（SIGFPE）：&lt;/strong&gt;如整數除零或浮點運算異常&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非法指令（SIGILL）：&lt;/strong&gt;執行未定義的機器指令&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;總線錯誤 （SIGBUS）：&lt;/strong&gt;如未對齊的內存訪問&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;主動異常&lt;/strong&gt;是代碼邏輯的一部分，用於可控的錯誤處理與資源管理，主動異常由開發者顯式拋出，也可由語言運行時隱式轉換。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;硬件異常的主動防禦&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 在語言層面上，對代碼引發的硬件異常進行了主動防禦。實現上，是在語義分析階段，對中間代碼添加防禦邏輯，防禦策略則採用了可被捕獲的主動異常拋出。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如下圖所示，在編譯階段，編譯器對於結構體指針進行了空引用檢查邏輯，將硬件異常轉換為了主動異常，而主動異常可以通過捕獲來進行處理，避免了進程崩潰。&lt;/span&gt;&lt;/p&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//330561eb2fd5d29de05f211a5205a6fe.webp" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;跨語言邊界傳播&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;因為 DScript2.0 的語言互操作性特性，會涉及到 C++與 DScript2.0 的函數互相調用（如下圖所示），就會涉及到異常處理時，異常在 C++和 DScript2.0 之間傳播，即所謂跨語言邊界。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 主要實現瞭如下的異常傳播機制：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;腳本調用 C++ 函數時若拋出異常，在腳本端不進行捕獲，但支持異常傳播到 C++端，同時正常完成棧回退。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++ 調用腳本函數時若拋出異常，可以在 C++ 端捕獲。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="854" src="https://oscimg.oschina.net/oscnet/up-21add7106f9e6fac929e9d7c4c917d64c6c.jpg" width="1370" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h1_16"&gt;&lt;/span&gt; 
 &lt;h1&gt;四、DScript2.0 在線開發工作流&lt;/h1&gt; 
 &lt;img height="646" src="https://oscimg.oschina.net/oscnet/up-e203b933862df54885aa58b955cee294427.png" width="840" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 通過平台化實現了在線開發的工作流：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎集成：以 SDK 方式與引擎進行集成，提供在線編譯和加載的能力。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在線 IDE：實現編輯、編譯的在線開發環境。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在線工作流：通過平台化支持腳本的在線分發與管理。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
 &lt;h1&gt;五、總結&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 的實踐為推薦引擎的敏捷迭代探索了一條新路徑。通過編譯器架構與 C++底層機制的高度兼容設計，它在降低跨語言交互成本、支持動態加載等方面展現出潛力，同時保持了接近原生 C++的運行時性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其即時編譯能力與在線開發流程，使業務團隊能獨立完成邏輯更新，減少對傳統 C++開發中編譯部署的依賴，初步驗證了兼顧性能與效率的可能性。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未來，我們計劃進一步完善調試工具鏈與異常處理機制，並探索其在混合語言場景下的擴展性，以更輕量的方式推動引擎架構的持續優化。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;算法團隊大量 HC，歡迎加入我們：&lt;/strong&gt;得物技術大量算法崗位多地上線，「職」等你來！&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;往期回顧&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;社區造數服務接入 MCP｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;CSS 闖關指南：從手寫地獄到「類」積木之旅｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;從零實現模塊級代碼影響面分析方案｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以細節詮釋專業，用成長定義價值——對話&lt;a href="https://my.oschina.net/u/2550946" class="referer" target="_blank"&gt;@孟同學&lt;/a&gt; ｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;得物可觀測平台架構升級：基於 GreptimeDB 的全新監控體系實踐&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 明遠&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18627049</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18627049</guid>
      <pubDate>Sat, 10 May 2025 03:28:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>月之暗面開源面向軟件工程的代碼大模型 Kimi-Dev-72B</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;月之暗面&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoonshotai.github.io%2FKimi-Dev%2F" target="_blank"&gt;宣佈開源 Kimi-Dev-72B&lt;/a&gt;，這是面向軟件工程的代碼大模型，並在 SWE-bench 上達到了開源模型中的 SOTA。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45476d7e8f257fde3b6a320ba89fcc0606c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b6ade9fe36167189fac92bab26ef34765ba.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Kimi-Dev-72B 的設計理念和技術細節包括 BugFixer 和 TestWriter 的雙重角色、中期訓練、強化學習以及測試時自博弈。&lt;/p&gt; 
&lt;p&gt;據介紹，Kimi-Dev-72B 通過大規模強化學習進行優化，能夠自主地在 Docker 中修補真實代碼庫。通過 mid-train，RL，讓模型在真實環境中修復代碼並通過測試，有效提升了性能。測試顯示，Kimi-Dev 在 SWE-bench Verified 上解決了 60.4% 的 issue。&lt;/p&gt; 
&lt;p&gt;模型現已在 Hugging Face 和 GitHub 開源：&lt;/p&gt; 
&lt;p&gt;Page: https://moonshotai.github.io/Kimi-Dev/&lt;br&gt; GitHub: https://github.com/MoonshotAI/Kimi-Dev&lt;br&gt; HuggingFace: https://huggingface.co/moonshotai/Kimi-Dev-72B&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355762/moonshotai-kimi-dev</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355762/moonshotai-kimi-dev</guid>
      <pubDate>Sat, 10 May 2025 02:46:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
