<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-綜合資訊</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-綜合資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Fri, 28 Mar 2025 02:37:38 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>ChatGPT 圖像生成功能引發版權爭議</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;OpenAI 近日&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/340984/openai-gpt-4o-image-generation&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;在 GPT-4o 模型中集成了迄今為止最先進的圖像生成器，並將其整合進 ChatGPT 中，而其優秀的生圖能力讓不少網友為之着迷。&lt;/p&gt; 
&lt;p&gt;與此同時，由 GPT-4o 生成的、帶着日本動畫工作室「吉卜力」風格的大量生成式圖片開始成為網絡熱門梗圖，並在互聯網上大規模傳播。&lt;/p&gt; 
&lt;p&gt;在這一大批的「吉卜力工作室風格」圖片中，不僅包括埃隆・馬斯克、《指環王》以及唐納德・特朗普等著名人物的形象，連 OpenAI CEO Sam Altman 都開始將自己的新頭像換成由 GPT-4o 生成的「吉卜力風格」圖像。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bd2d9abaccb5193ce4150a3140d75fb8430.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;而這波「吉卜力」熱潮也引發了大眾對「AI 生圖是否會涉及版權糾紛」這一問題的思考。TechCrunch 援引 Neal &amp;amp; McDevitt 律師事務所的知識產權律師埃文・布朗的説法&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F03%2F26%2Fopenais-viral-studio-ghibli-moment-highlights-ai-copyright-concerns%2F&quot; target=&quot;_blank&quot;&gt;表示&lt;/a&gt;&lt;/u&gt;，像 GPT-4o 圖像生成器這樣的產品如今處於法律灰色地帶。&lt;/p&gt; 
&lt;p&gt;布朗表示，風格本身並未明確受到版權保護，這意味着 OpenAI 僅通過生成類似吉卜力電影風格的圖像似乎並沒有違反法律。同時布朗也指出，GPT-4o 可能是通過學習吉卜力電影的數百萬幀畫面，生成的圖片才實現了這樣的相似性。據悉，目前仍有多國的法院正在裁定，使用版權作品訓練 AI 模型是否屬於合理使用保護範圍。&lt;/p&gt; 
&lt;p&gt;對於上述的爭議，OpenAI 發言人向 TechCrunch 發佈一份聲明表示，雖然 GPT-4o 的圖像生成器拒絕複製「在世個人藝術家的風格」，但允許複製「更廣泛的工作室風格」。同時其也強調，部分在世的藝術家因其獨特的創作風格而獲得市場認可，例如吉卜力工作室的聯合創始人宮崎駿。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341482/openais-ghibli-ai-copyright</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341482/openais-ghibli-ai-copyright</guid>
            <pubDate>Fri, 28 Mar 2025 02:34:35 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>從對話到自主行動：AI 應用如何從 Chat 進化為 Agent？開源項目源碼深度揭祕</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;從 2022 年 12 月份 OpenAI 發佈 ChatGPT 產品至今已有 2 年多的時間，當大家已經習慣於在對話框中與 AI 交互，習慣於通過各種 Prompt 技巧讓 AI 更好的理解並回答我們的問題，似乎默認這就是一種比較好與 AI 的交互方式了。&lt;/p&gt; 
&lt;p&gt;然而，這就是我們期盼的與 AI 交互的形式嘛？這是一種高效的方式嘛？&lt;/p&gt; 
&lt;p&gt;顯然，這是不夠的。&lt;/p&gt; 
&lt;p&gt;我們期望的是：告訴 AI 我們想要的目標或者任務，AI 能夠理解深度理解並分析我們的意圖、自動的進行任務的拆解、自動的尋找可以使用的工具、自動的進行結果數據的彙總過濾、自動的呈現符合任務的展示形式。同時在任務處理過程中，可以自己完成異常的檢測和修改。就如同一位優秀的同學，我們告訴他任務的目標，他可以自己尋找飛書文檔、搜索網絡知識、使用內部系統、自己編碼驗證方案可行性，並最終給一份好的解決方案。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二、以「對話為中心」的 ChatBot&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我們發送一條指令，AI 被動的響應指令。即完成一輪人與 AI 的交互。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;具體視頻請前往「得物技術」微信公眾號觀看。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;三、以「交付為中心」的多智能體 Agent&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我們發送一個任務，AI 自動分析任務、調用可用的工具、分析結果、過濾數據並自動處理異常，最終呈現解決方案。&lt;/p&gt; 
&lt;p&gt;完成這樣的一個任務，需要多智能體 Agent 間的協作以及對常用工具的調用。那什麼是智能體 Agent 呢？&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;具體視頻請前往「得物技術」微信公眾號觀看。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;四、什麼是智能體 Agent&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;從 Prompt 到思維鏈&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;隨着大模型的發展，Prompt 工程已成為撬動大模型潛能的核心技術。即使我們普通用戶在與大模型的交互中，也通過角色定義（如&quot;資深工程師&quot;）或示例引導來優化輸出效果，但這類簡單提示往往難以突破模型固有的邏輯天花板——就像給賽車裝自行車輪胎，再怎麼調整也難以突破速度極限。&lt;/p&gt; 
&lt;p&gt;但偶然間，人們發現了一個神奇的咒語：只需要告訴大模型，&lt;strong&gt;你的 think 要 step by step&lt;/strong&gt;。研究者發現只要加了這個 prompt，就能極為顯著地改善大模型做數學題的正確率。&lt;/p&gt; 
&lt;p&gt;大模型的數學與邏輯能力短板，是所有體驗過其對話功能的用戶都能直觀感受到的痛點。這一缺陷嚴重製約了大模型的商業化落地進程，畢竟沒有人敢輕易信任一個邏輯混亂的智能系統能輸出可靠的決策結果。於是，提升大模型數學能力，被所有做基礎模型的公司當作了第一目標。&lt;/p&gt; 
&lt;p&gt;研究者試圖通過強化思維鏈來突破這一瓶頸。一個直觀的思路是：讓模型像人類解題時在草稿紙上推演那樣，通過 &quot;step by step&quot; 的方式展開邏輯鏈條 —— 在這個過程中，包含假設、演繹、反思、糾錯等一系列思維活動。既然人類通過這種結構化的思考方式能夠有效解決數學問題，那麼大模型是否也能通過類似機制實現能力躍遷？這一猜想推動着研究向縱深發展，最終形成了思維鏈技術的核心框架。這樣的觀念經過繼續鑽研，最終就構成了思維鏈，思維鏈是一個能以最小的代價，而非常顯著提升模型智力水平（邏輯能力、解題能力、代碼能力）的技術。&lt;/p&gt; 
&lt;p&gt;值得注意的是，2025 年春節期間引發廣泛關注的 DeepSeek 大模型，正是思維鏈技術的成功實踐典範。儘管 DeepSeek 並非首創者，但其通過創新性地融合混合專家（MoE）架構與強化學習技術，顯著提升了思維鏈推理的計算效率與性能表現。這種技術優化使得 DeepSeek 在保持高精度推理的同時，大幅降低了計算成本，最終實現了屠榜級表現。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;ReAct 架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果説思維鏈（COT）是給 AI 裝上了人類的 &quot;草稿紙&quot;，那麼 ReAct 框架就是為它配備了 &quot;雙手&quot;—— 讓 AI 不僅能在腦子裏推演，還能主動採取行動獲取信息。這種 &quot;思考 + 行動&quot; 的組合，正在把大模型從 &quot;紙上談兵&quot; 的理論家，變成能解決現實問題的實幹家。&lt;/p&gt; 
&lt;p&gt;ReAct 的核心在於將**推理（Reasoning）與行動（Action）**緊密結合。當模型面對複雜問題時，會先像人類一樣拆解思考步驟，然後根據中間結果調用外部工具（如搜索引擎、數據庫、計算器）獲取實時數據，再把這些信息整合到後續推理中。&lt;/p&gt; 
&lt;p&gt;其實，實現一個 ReAct 很簡單，只需要構建 Prompt+提供工具+循環執行即可，筆者在這裏不進行詳細的介紹，只需要給一個 Prompt 例子，讀者就能理解：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;儘可能最好地為用戶回答接下來的問題，你可以使用以下工具來輔助你：{tools} 使用以下格式：&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;問題：你需要回答的輸入問題&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;思考：你需要持續思考下一步採取什麼行動&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;行動：要採取的行動，應該是&amp;nbsp;[{tool_names}]&amp;nbsp;中的一個，以及該行動的輸入內容&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;觀察：行動並觀測結果，並判斷結果是否合理 ...（這個思考&amp;nbsp;/&amp;nbsp;行動&amp;nbsp;&amp;nbsp;/&amp;nbsp;觀察可以重複 N 次，直到你認為知道了最終答案&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;最終答案：原始輸入問題的最終答案&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;開始！&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;-&amp;nbsp;問題：{input}&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Tools 支持開發者自定義，比如給予 LLM 一個查詢天氣的接口、計算器接口等。&lt;/p&gt; 
&lt;p&gt;ReAct 架構實現了一種**&quot;問題拆解-工具調用-結果整合&quot;的&lt;strong&gt;閉環機制&lt;/strong&gt;，使得開發者僅需通過定義工具集（如天氣 API、計算器、知識圖譜接口）和設計任務引導詞，就能將大模型轉化為可執行多步驟決策的智能體。最終可以使大模型突破純文本推理的侷限，真正具備了在動態場景中解決開放性問題的工程化能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Agent&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Agent 作為大模型技術的集大成者，通過整合思維鏈（CoT）的推理能力和 ReAct 框架的行動機制，構建了具備自主決策與執行能力的智能系統。其核心突破在於將**「大腦」與「四肢」**有機統一，標誌着大模型從被動應答邁向主動幹預現實的質變。&lt;/p&gt; 
&lt;p&gt;在架構上，Agent 與 ReAct 差別不大，ReAct 是 Agent 的核心實現範式之一，Agent&lt;strong&gt;進一步整合&lt;/strong&gt;記憶存儲、多智能體協作等模塊，形成更完整的自主決策系統。下圖是一個簡單的 Agent 架構圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/v2-ad31f685f1330333011c67eccc3cb64c_1440w_1743044594868.png&quot; alt=&quot;v2ad31f685f1330333011c67eccc3cb64c_1440w.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Agent 處理流程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1-4 步會循環進行，直到 LLM 認為問題已被回答。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1.規劃（Planning）：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;定義：規劃是 Agent 的思維模型，負責拆解複雜任務為可執行的子任務，並評估執行策略。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實現方式：通過大模型提示工程（如 ReAct、CoT 推理模式）實現，使 Agent 能夠&lt;strong&gt;精準拆解任務&lt;/strong&gt;，分步解決。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;2.記憶（Memory）：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;定義：記憶即信息存儲與回憶，包括短期記憶和長期記憶。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實現方式：&lt;strong&gt;短期記憶&lt;/strong&gt;用於存儲會話上下文，支持多輪對話；&lt;strong&gt;長期記憶&lt;/strong&gt;則存儲用戶特徵、業務數據等，通常通過向量數據庫等技術實現快速存取。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;3.工具（Tools）：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;定義：工具是 Agent 感知環境、執行決策的輔助手段，如 API 調用、插件擴展等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實現方式：通過接入外部工具（如 API、插件）擴展 Agent 的能力，如 ChatPDF 解析文檔、Midjourney 文生圖等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;4.行動（Action）：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;定義：行動是 Agent 將規劃與記憶轉化為具體輸出的過程，包括與外部環境的互動或工具調用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實現方式：&lt;strong&gt;Agent 根據規劃與記憶執行具體行動&lt;/strong&gt;，如智能客服回覆、查詢天氣預報、AI 機器人抓起物體等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Manus：一個 Agent 典型案例&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在讀完前一節關於智能體（Agent）的技術解析後，讀者也許會認為這類系統的工程實現並非難事，實際上也確實是這樣。近期爆火的 Agent 產品 Manus 便是典型案例。當用戶提出 &quot;定製 7 天日本旅行計劃&quot; 的需求時，Manus 能夠基於目標，自主進行網絡搜索並將信息整合，展現出&lt;strong&gt;高度擬人化的任務執行邏輯&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/2_1743044773894.png&quot; alt=&quot;2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;儘管 Manus 目前尚未向普通用戶開放，且採用邀請制註冊的封閉運營模式，但其通過官方演示視頻呈現的強大智能化表現，已在技術圈引發廣泛關注。值得關注的是，隨着 Agent 技術的熱度攀升，開源社區已迅速湧現出 OpenManus、OWL 等多個復刻項目。&lt;/p&gt; 
&lt;p&gt;因為 Manus 並非開源，我們很難瞭解其技術細節。但好在：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&quot;Manus 的部分技術細節，包括其提示詞設計、運行機制等內容被網友通過非官方渠道披露，感興趣的讀者可自行查閲相關公開資料。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;我們可以瞭解一下&lt;strong&gt;大模型上下文協議&lt;/strong&gt;（Model Context Protocol，MCP），這是 Anthropic (Claude) 主導發佈的一個開放的、通用的、有共識的協議標準，雖然 Manus 不一定用了這個協議，但目前一些相關開源項目也是基於 MCP 的，本文會在下面介紹 MCP。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;目前已有復刻的開源項目 Openmanus，筆者會在接下來的章節剖析其源碼。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;strong&gt;大模型上下文協議（MCP）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;MCP 是做什麼的？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MCP（Model Context Protocol）作為一項開放協議，旨在為應用程序與大型語言模型（LLMs）之間的上下文交互提供標準化框架。其設計理念可類比為數字時代的 &quot;USB-C 接口&quot;—— 正如 USB-C 統一了設備與外設的連接標準，MCP 通過標準化的上下文交互接口，實現了 AI 模型與多樣化數據源、工具之間的無縫對接。&lt;/p&gt; 
&lt;p&gt;如下圖所示，圖中的 MCP server 都可以看成一個個工具 (如搜索引擎、天氣查詢)，通過「接口」連接到 MCP clients(大模型) 上，大模型可以使用各種 MCP server 來更好地處理用戶的問題。&lt;/p&gt; 
&lt;p&gt;此外，下游工具的開發者也可以更好的開發其工具，目前在 MCP 官網即可瞭解其各種編程語言的 SDK 和相關概念。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/3_1743044805628.png&quot; alt=&quot;3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;MCP 架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MCP 的核心採用客戶端-服務器架構，其中 host 可以連接到多個服務器，讀者簡單看看即可：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_bcaed6dc-c3e0-4917-a824-cf74a340516g_1743045011163.png&quot; alt=&quot;img_v3_02kp_bcaed6dcc3e04917a824cf74a340516g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;MCP 主機（MCP Hosts）：指需要通過 MCP 協議獲取數據的應用程序，涵蓋 AI 開發工具（如 Claude Desktop）、集成開發環境（IDEs）等智能應用場景。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;MCP 客戶端（MCP Clients）：作為協議的執行者，每個客戶端與對應的 MCP 服務器建立一對一的專屬連接，負責協議層面的通信交互。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;MCP 服務器（MCP Servers）：輕量化的功能載體，通過標準化的 Model Context Protocol 對外開放特定能力，可視為連接模型與工具的智能橋樑。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;本地化數據源（Local Data Sources）：包括服務器可安全訪問的本地文件系統、數據庫及專有服務，構成數據交互的近端生態。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;遠程服務（Remote Services）：通過互聯網連接的外部系統，例如各類 API 接口服務，拓展了模型的能力邊界。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;為什麼要用 MCP？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;從技術演進視角看，MCP 的誕生是提示工程（Prompt Engineering）發展的必然產物。研究表明，結構化的上下文信息能顯著提升大模型的任務表現。在傳統提示工程中，我們往往需要人工從數據庫篩選信息或通過工具檢索相關內容，再手動將這些信息注入提示詞。然而，隨着複雜任務場景的增多，這種手工注入信息的操作變得愈發繁瑣且低效。&lt;/p&gt; 
&lt;p&gt;為解決這一痛點，主流大模型平台（如 OpenAI、Google）先後引入了&lt;strong&gt;函數調用（Function Call）機制&lt;/strong&gt;。該機制允許模型在推理過程中主動調用預定義函數獲取數據或執行操作，極大提升了自動化水平。然而，函數調用機制存在顯著侷限性：其一，不同平台的函數調用 API 存在較大差異，例如 &lt;strong&gt;OpenAI 與 Google 的實現方式互不兼容&lt;/strong&gt;，開發者在切換模型時需重新編寫代碼，徒增適配成本；其二，該機制在安全性、交互性及複雜場景的擴展性方面仍存在優化空間。&lt;/p&gt; 
&lt;p&gt;在此背景下，MCP 協議通過標準化的上下文交互接口，為大模型構建了更具普適性的工具調用框架。它不僅&lt;strong&gt;解耦&lt;/strong&gt;了模型與工具的依賴關係，還通過統一的協議規範解決了跨平台兼容性問題。更重要的是，MCP 將上下文管理提升到系統架構層面，為大模型在複雜業務場景中的深度應用提供了可擴展的技術底座。這種從碎片化的提示工程到體系化的上下文協議的演進，標誌着大模型應用正在向更高效、更規範的方向邁進。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;四、智能體 Agent 實現的源碼剖析（OpenManus 項目）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_7f7cdb11-c5c3-435e-8bdc-c98e38f9cddg_1743045055057.png&quot; alt=&quot;img_v3_02kp_7f7cdb11c5c3435e8bdcc98e38f9cddg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;OpenManus 是一個基於 MCP 協議的開源智能體實現項目，旨在通過標準化的上下文協議實現大模型與工具的高效協同。當前項目仍處於快速迭代階段，本文以其 2025 年 3 月 12 日的版本為分析對象。選擇該項目的原因如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;團隊背景與代碼質量&lt;/strong&gt;：項目作者來自 MetaGPT，具備深厚的工程經驗，代碼結構清晰且註釋完善，兼顧了技術實現與可讀性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;部署便捷性&lt;/strong&gt;：只需通過虛擬環境安裝依賴並配置大模型 API Key（如 OpenAI 的 API 密鑰），即可快速啓動，降低了技術門檻。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;技術前沿性&lt;/strong&gt;：項目緊跟大模型技術發展，且目前仍在不斷迭代的過程中。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在經過前面對相關概念的討論，我們可以得知實現 Agent 有幾個關鍵的點，讀者可以帶着問題在項目中尋找答案：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;：其結構化的 Prompt 是什麼樣的？通過 Prompt 可以對其架構有一個初步認識。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;OpenManus&lt;/strong&gt;：怎麼通過大模型思考和處理問題？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;工具相關&lt;/strong&gt;：怎麼進行工具註冊、工具管理的？工具執行邏輯是什麼的？&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;準備&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;項目地址：&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmannaandpoem%2FOpenManus%2Ftree%2Fmain&quot; target=&quot;_blank&quot;&gt;https://github.com/mannaandpoem/OpenManus/tree/main&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;構建環境&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;創建一個 python=3.12 的虛擬環境&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;筆者測試了一下，非 3.12 版本會有一個 package 不兼容。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可以用 conda 或 python 內置的 uv，項目文檔提供了詳細的指令。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;安裝 playwright&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;如果第一次使用，需要安裝 playwright。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;playwright install
## 或者
python -m playwright install
## 以上命令會安裝所有瀏覽器，如果只需要安裝一個瀏覽器比如 firefox
python -m playwright install firefox
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;配置大模型 API Key&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;可以用 DeepSeek 或通義千問的 API Key，其中通義有免費額度，DeepSeek 雖然收費但價格便宜，測試一次使用約 1000token,成本不到 0.01 元。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;根據項目文檔配置 cofig.yaml 即可，但項目調用大模型是使用基礎的 OpenAI API，如果使用其他大模型，可能需要基於對應的官方文檔小改一下。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;代碼&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;OpenManus 客戶端&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Python OpenManus/main.py&lt;/strong&gt;即可在終端運行 OpenManus，讀者也可以嘗試其 Web 版本。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;具體會調用 20 行代碼，執行 Manus 類的方法 run()。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_037da761-0f23-414c-b15d-567f598ac4bg_1743045114713.png&quot; alt=&quot;img_v3_02kp_037da7610f23414cb15d567f598ac4bg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;進入 OpenManus/app/agent/manus.py 查看 Manus 類，可以發現它繼承了 ToolCallAgent 類，再進入會發現又是繼承，有點複雜，這裏我畫一張關係圖。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;act() 執行時使用 execute_tools() 進行具體的工具執行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;總體來説，Manus 類定義了 Prompt 和可使用的工具。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Base 類定義了 run()，在 run() 中會循環執行 ReAct 類的方法 step()，直到 Finish 或達到 max_step。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;step() 類會順序執行 ToolCallAgent 類的 think() 和 act()。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;當然，這裏只羅列了重要的組件和方法，一些方法沒有畫在圖中。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_e50578dd-ab27-439f-91d9-7a3f5e38943g_1743045152115.jpg&quot; alt=&quot;img_v3_02kp_e50578ddab27439f91d97a3f5e38943g.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Prompt&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一般來説，輸入給 LLM 的 prompt 分為兩種：1）&lt;strong&gt;系統 prompt&lt;/strong&gt;，用於定義模型的角色定位和行為規則；2）&lt;strong&gt;用戶 prompt&lt;/strong&gt;(OpenManus 稱為 Next Step Prompt)，用於傳達具體的任務指令或信息需求。&lt;/p&gt; 
&lt;p&gt;在 OpenManus/app/prompt/manus.py 中即可看到 Manus 的 Prompt，這裏展示一下中文版，讀者基於此可對 OpenManus 架構有一個初步認識：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;系統 Prompt（SYSTEM_PROMPT）&lt;/strong&gt;：「你是 OpenManus，一個全能的人工智能助手，旨在解決用戶提出的任何任務。你擁有各種可使用的工具，能調用這些工具高效地完成複雜的請求。無論是編程、信息檢索、文件處理還是網頁瀏覽，你都能應對自如。」&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;下一步 Prompt（NEXT_STEP_PROMPT）&lt;/strong&gt;：「你可以使用 PythonExecute 與計算機進行交互，通過 FileSaver 保存重要的內容和信息文件，使用 BrowserUseTool 打開瀏覽器，並使用 GoogleSearch 檢索信息。根據用戶的需求，主動選擇最合適的工具或工具組合。對於複雜的任務，你可以將問題分解，逐步使用不同的工具來解決它。在使用完每個工具後，清晰地解釋執行結果並給出下一步的建議。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;當然，在實際執行時會對 prompt 有進一步優化，不過核心的系統定位與任務指導原則是不會改變的。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Manus 類&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_83117adc-20bf-418f-bd98-933c2671522g_1743045172551.png&quot; alt=&quot;img_v3_02kp_83117adc20bf418fbd98933c2671522g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;我們先看一下 OpenManus 擁有的工具，工具也支持自定義，會在後文進行介紹。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;PythonExecute：執行 Python 代碼以與計算機系統交互、進行數據處理、自動化任務等等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;FileSaver：在本地保存文件，例如 txt、py、html 等文件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BrowserUseTool：打開、瀏覽並使用網絡瀏覽器。如果你打開一個本地 HTML 文件，必須提供該文件的絕對路徑。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;GoogleSearch：執行網絡信息檢索。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Terminate：如果 LLM 認為回答完畢，會調用這個工具終止循環。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Base 類&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;run()&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_36fbb768-418d-4f28-92b6-76943131916g_1743045221456.jpg&quot; alt=&quot;img_v3_02kp_36fbb768418d4f2892b676943131916g.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先，輸入的 request 就是用戶輸入的提問。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;狀態管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_036ebee8-ebfd-4b4c-94cb-283d4a071aag_1743045238174.jpg&quot; alt=&quot;img_v3_02kp_036ebee8ebfd4b4c94cb283d4a071aag.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;執行時首先檢查代理的當前狀態是否為 &lt;code&gt;IDLE&lt;/code&gt;（空閒狀態）。如果不是空閒狀態，會拋出 &lt;code&gt;RuntimeError&lt;/code&gt; 異常，因為只有在空閒狀態下才能啓動代理的執行。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_1fa59b67-e152-4706-9e10-3f001a8b2a2g_1743045249523.jpg&quot; alt=&quot;img_v3_02kp_1fa59b67e15247069e103f001a8b2a2g.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;當進入循環時前，使用 &lt;code&gt;state_context&lt;/code&gt;上下文管理器將代理的狀態臨時切換到 &lt;code&gt;RUNNING&lt;/code&gt;（運行狀態）。在上下文管理器中執行的代碼塊會&lt;strong&gt;在進入時&lt;/strong&gt;將狀態切換為指定狀態，&lt;strong&gt;在退出時&lt;/strong&gt;恢復到之前的狀態。如果在執行過程中&lt;strong&gt;發生異常&lt;/strong&gt;，會將狀態切換為 &lt;code&gt;ERROR&lt;/code&gt;。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Memory 管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我們調用大模型的 API，本質是向大模型提供方發 http 請求，http 請求是無狀態的。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;也就是説，服務端不會保留任何會話信息。對於每次都完成一個獨立的任務，無狀態是沒有任何問題的。但對持續聊天來説，就會出現對之前會話一無所知的情況。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;所以為了讓大模型持續與用戶的對話，一種常見的解決方案就是把聊天曆史告訴大模型。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;因此，在 OpenManus 中會進行 Memory 的管理。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_8c1e4d88-12b8-40d9-804e-d82c2e6b68cg_1743045314471.jpg&quot; alt=&quot;img_v3_02kp_8c1e4d8812b840d9804ed82c2e6b68cg.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_c7474598-2b00-42e5-9b77-935079c3b55g_1743045390335.png&quot; alt=&quot;img_v3_02kp_c74745982b0042e59b77935079c3b55g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;用戶提供的 &lt;code&gt;request&lt;/code&gt; 參數，調用 &lt;code&gt;update_memory&lt;/code&gt; 方法將該請求作為用戶消息添加到代理的 Memory 中。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;除了這個函數，Manus 也在進行 think()、act() 時也會更新 Memory，同時 Memory 容量也不是無限大的，容量滿時需要刪除老的 Message。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;主循環&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_1ce79275-4452-405c-bd68-6c976d9a2bfg_1743045415135.png&quot; alt=&quot;img_v3_02kp_1ce792754452405cbd686c976d9a2bfg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;agent 本質就是循環執行。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;step 實現參考 react step。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;循環結束條件：max_steps 或者 FINISHED 狀態。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;每次執行一個 step 並獲得 result——step_result = await self.step()。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;code&gt;is_stuck&lt;/code&gt; 方法用於檢查代理是否陷入了循環（即是否出現了重複的響應）。如果是，則調用 &lt;code&gt;handle_stuck_state&lt;/code&gt; 方法處理這種情況，例如添加一個提示來改變策略。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;ReAct&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;step()&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_3999f1b8-a5bb-413f-826c-a4b7c3d8836g_1743045441792.png&quot; alt=&quot;img_v3_02kp_3999f1b8a5bb413f826ca4b7c3d8836g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;這裏的邏輯很簡單。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;ToolcallAgent&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Think()&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;輸入：不需要輸入，因為用戶的 question 是被存放在 Memory 中。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;輸出：一個 bool 類型，當內部 LLM 判斷需要 act() 時，為 True，否則為 Fasle。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詢問 LLM&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_ecd6a300-6d25-4268-a783-101c86d86a0g_1743045468280.png&quot; alt=&quot;img_v3_02kp_ecd6a3006d254268a783101c86d86a0g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;55 行的代碼用於調用 LLM 的 API 接口，獲取回覆。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_d194c2fc-a02e-47b9-be3c-05ab5195c25g_1743045483264.png&quot; alt=&quot;img_v3_02kp_d194c2fca02e47b9be3c05ab5195c25g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;對應到 OpenManus/app/llm.py 233 行附近，這裏就是基於 OpenAI 提供的 API 接口進行對話，具體的參數可參考相應官方文檔。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;這裏會將之前定義的&lt;strong&gt;下一步 Prompt&lt;/strong&gt;發給 LLM，LLM 會根據提供的工具列表，判斷是否需要且調用的是哪個工具，當然也可能是：1）不需要工具只進行回覆 2）調用 Terminate 工具結束會話。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下圖是一次返回&lt;strong&gt;response 結果&lt;/strong&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;輸入的 question 是「計算 Kobe Bryant 的 BMI？」，LLM 先分析出了要通過瀏覽器查詢資料，因此要 use the BrowserUseTool。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;根據傳入的工具類型等信息，LLM 自動構建了執行工具需要用的 tool_name、action 等參數。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;ChatCompletionMessage(
    content=&quot;It seems there was an issue with retrieving the information about Kobe Bryant&#39;s height and weight through a Google search. To calculate Kobe Bryant&#39;s BMI, we need his height and weight. Let&#39;s try to find this information by opening a browser and visiting a reliable source. I will use the BrowserUseTool to navigate to a website that provides details about Kobe Bryant&#39;s height and weight. Let&#39;s proceed with this approach.&quot;, 
    refusal=None, 
    role=&#39;assistant&#39;, 
    annotations=None, 
    audio=None, 
    function_call=None, 
    tool_calls=[
        ChatCompletionMessageToolCall(
            id=&#39;call_aez57ImfIEZrqjZdcW9sFNEJ&#39;,
            function=Function(
            arguments=&#39;{
                &quot;action&quot;:&quot;navigate&quot;,
                &quot;url&quot;:&quot;https://www.biography.com/athlete/kobe-bryant&quot;
                }&#39;, 
            name=&#39;browser_use&#39;), 
            type=&#39;function&#39;)]
)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;think 後續邏輯&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;think() 後續的邏輯比較簡單，主要是更新 memory(memory 存儲單位是 message)，最後在 100 行附近的邏輯，基於 self.tool_choices 等參數的設置和 LLM 返回的工具列表，輸出 bool 類型結果。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同時，需要被調用的工具會被記錄到 self.tool_calls 這個列表中，後續的 act() 會執行對應的工具。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Act()&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;輸入：同 think()，不需要輸入。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;輸出：results，根據工具結果構建的一個字符串。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_44e6894b-d915-40ec-82dc-03c8e3e970bg_1743045510286.png&quot; alt=&quot;img_v3_02kp_44e6894bd91540ec82dc03c8e3e970bg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;這個函數比較簡單，主要是調用 execute_tool() 函數。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Execute_tool()&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_030fab99-df15-4e81-9a61-d3ff3bed5aeg_1743045520994.png&quot; alt=&quot;img_v3_02kp_030fab99df154e819a61d3ff3bed5aeg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;該函數會調用&lt;code&gt;Tool&lt;/code&gt;類提供的接口 execute()。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;Tool&lt;/code&gt;類接口會在後面介紹。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;同時，對於預設定的&lt;strong&gt;special tool&lt;/strong&gt;，會 self._handle_special_tool(name=name, result=result) 進行特殊處理。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;當前的&lt;strong&gt;special tool&lt;/strong&gt; 只有一個 Terminate 工具，特殊處理就是設置 Agent 的狀態為 AgentState.FINISHED，結束對話。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;工具相關&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我們在之前介紹了 MCP 相關的概念，如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_841aa8cc-b6d7-4423-a435-decd316bc3bg_1743045533595.png&quot; alt=&quot;img_v3_02kp_841aa8ccb6d74423a435decd316bc3bg.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;事實上，OpenManus 也是基於 MCP 的，OpenManus 的 tool 相當於 MCP server，根據 MCP 協議，我們只需要定義 tool 類&lt;strong&gt;支持的方法和參數等&lt;/strong&gt;，每次&lt;strong&gt;註冊一個新工具&lt;/strong&gt;，根據父類 override 一個子類即可。&lt;/p&gt; 
&lt;p&gt;那我們首先要了解父類都定義了什麼參數和方法，也就是 OpenManus/app/tool/base.py 定義的&lt;code&gt;Basetool&lt;/code&gt;類。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Base Tool&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_3a61d251-8cb3-4353-9aad-1dd28cd6686g_1743045570393.png&quot; alt=&quot;img_v3_02kp_3a61d2518cb343539aad1dd28cd6686g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看出，代碼很簡單，每個 tool 包含的參數為:name、description(提供給 LLM 看的，對工具的介紹)、parameters(執行工具時要用的參數)。&lt;/p&gt; 
&lt;p&gt;同時，一個 tool 支持的方法有 execute() 和 to_param()。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;execute() 用於執行具體的邏輯，每個子類&lt;strong&gt;需要 override 這個方法&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;to_param() 將工具調用的結果結構化輸出。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;當然，這裏還有一個 python 關鍵字__call__，這個關鍵字很簡單，定義了__call__，該類的實例對象可以像函數一樣被調用。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;工具 JSON&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;可以根據 OpenManus 預定義的工具 json 簡單瞭解一下，每個工具執行時需要的參數。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;[
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;function&quot;: {
      &quot;name&quot;: &quot;python_execute&quot;,
      &quot;description&quot;: &quot;Executes Python code string. Note: Only print outputs are visible, function return values are not captured. Use print statements to see results.&quot;,
      &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
          &quot;code&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;The Python code to execute.&quot;
          }
        },
        &quot;required&quot;: [&quot;code&quot;]
      }
    }
  },
  {
    &quot;type&quot;: &quot;function&quot;,
    &quot;function&quot;: {
      &quot;name&quot;: &quot;google_search&quot;,
      &quot;description&quot;: &quot;Perform a Google search and return a list of relevant links.\nUse this tool when you need to find information on the web, get up-to-date data, or research specific topics.\nThe tool returns a list of URLs that match the search query.\n&quot;,
      &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
          &quot;query&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;(required) The search query to submit to Google.&quot;
          },
          &quot;num_results&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;description&quot;: &quot;(optional) The number of search results to return. Default is 10.&quot;,
            &quot;default&quot;: 10
          }
        },
        &quot;required&quot;: [&quot;query&quot;]
      }
    }
]
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;工具示例——google_search&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;OpenManus 項目在 OpenManus/app/tool 中定義了 bash 工具、瀏覽器工具、谷歌搜索工具等，這裏簡單看一下谷歌搜索工具。&lt;/p&gt; 
&lt;p&gt;當然，國內可能比較難使用谷歌搜索，OpenManus 社區也有大佬提供了 baidu、bing 等搜索引擎工具。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://h5cdn.dewu.com/efe/ctoo-open-blog-admin/10787572/img_v3_02kp_970ea258-0aca-4c89-8098-0b7f28db476g_1743045589976.png&quot; alt=&quot;img_v3_02kp_970ea2580aca4c8980980b7f28db476g.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看出，代碼很簡單，主要做了兩件事。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;定義工具參數：name、description、parameters。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;定義 execute：基於 googlesearch 庫提供的函數進行搜索並返回。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;五、總結&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;OpenManus 的代碼介紹到這裏，主要是介紹一下核心代碼，同時，原作者寫了 planning 部分的代碼但暫時沒有應用到項目中，筆者也沒有介紹。如果想對該項目有更進一步的瞭解，請大家查看 github 上提供的源碼。而且，作者還是非常積極的，每天會有十幾個 commit。&lt;/p&gt; 
&lt;p&gt;同時，讀者可以簡單本地部署玩一下 OpenManus，通過幾個 prompt，就可以知道該項目還是停留在「玩具階段」，比如筆者測試了一下，當詢問「計算一下科比的 BMI？」，OpenManus 可以很準確的實現**谷歌搜索——瀏覽器訪問——&lt;strong&gt;python 計算&lt;/strong&gt;這個過程。但如果詢問「計算科比、梅西的 BMI 並排序？」，無論我改寫了幾次 prompt，OpenManus 都沒有給我滿意的回答。&lt;/p&gt; 
&lt;p&gt;此外，無論是在工具參數信息、還是 prompt、memory 管理中，都可以看到 agent 應用大模型 token&lt;strong&gt;消耗量巨大&lt;/strong&gt;，即使我們不考慮 token 成本，但大模型的上下文仍然是有限的，這種資源消耗也會直接導致模型在處理多步驟任務時面臨&lt;strong&gt;信息截斷的風險&lt;/strong&gt; —— 早期的關鍵信息可能因上下文溢出而被丟棄，進而引發推理鏈條的斷裂。更值得警惕的是，當模型試圖在有限的上下文中 「腦補」 缺失的信息時，往往會產生與事實不符的幻覺。&lt;/p&gt; 
&lt;p&gt;鑑於此，儘管 OpenManus 展示出了利用工具鏈解決複雜問題的潛力，不過距離成為一個實用、高效且穩定的生產級人工智能助手仍有很長的路要走。未來，開發者們或許需要在優化工具使用邏輯、提升多任務處理能力、降低大模型 token 消耗以及增強上下文管理等方面進行深入探索與改進。同時，對於普通用戶而言，在體驗這類項目時，也應該保持理性和客觀的態度，既看到其創新性和趣味性，也認識到其當前存在的侷限性。希望在技術的不斷迭代和完善下，OpenManus 以及類似的項目能夠早日突破現有的瓶頸，真正為人們的工作和生活帶來實質性的幫助。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;往期回顧&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1.&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247538265%26idx%3D1%26sn%3D46126305e017551fce1c548a0d482d52%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;得物技術部算法項目管理實踐分享&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;2. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247538263%26idx%3D1%26sn%3D78e7e307da19e903656c2de2afb96dc9%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;商家域穩定性建設之原理探索｜得物技術&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;3. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247538237%26idx%3D1%26sn%3D47a37918d6e1a0123644ea690f7bdaad%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;得物 Android Crash 治理實踐&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;4. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247538099%26idx%3D1%26sn%3Db973a4052f5460509f2bd25ed888995e%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;基於 ANTLR4 的大數據 SQL 編輯器解析引擎實踐｜得物技術&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;5. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkxNTE3ODU0NA%3D%3D%26mid%3D2247538072%26idx%3D1%26sn%3Dc3506a84400c5cc3c72b2b0ff2291384%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;LSM-TREE 從入門到入魔：從零開始實現一個高性能鍵值存儲 ｜ 得物技術&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;文 / 漢堡&lt;/p&gt; 
&lt;p&gt;關注得物技術，每週一、三更新技術乾貨&lt;/p&gt; 
&lt;p&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/p&gt; 
&lt;p&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/5783135/blog/18015687</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18015687</guid>
            <pubDate>Fri, 28 Mar 2025 02:31:35 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>比爾蓋茨稱讚 DeepSeek：AI 全球競爭無國界</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;微軟聯合創始人比爾·蓋茨日前在紐約經濟俱樂部的講座中，分享了他個人自傳《源代碼》的創作過程，並深入探討了人工智能（AI）的發展及其對全球社會的影響。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;蓋茨在談及為何此時出版回憶錄時表示：「儘管我通常更關注未來，但在自己 70 歲即將到來，微軟迎來 50 週年，蓋茨基金會也將迎來 25 週年之際，我覺得是時候回顧過去，並分享一些重要的思考。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在談到人工智能（AI）進展時，蓋茨表達了對其飛速發展的驚歎。他提到自己有一個團隊專注於每週跟蹤 AI 領域的新動向，並親自嘗試這些新技術。特別是在談到中國的 DeepSeek 時，蓋茨稱其效率提升顯著，且其技術實現方式已經公開。他指出:「在全球最頂尖的八種 AI 模型中，有三種來自中國。DeepSeek 在許多標準下，至少在一個月內，已經是全球最好的。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;277&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-95c1e6071d84aff4995acf668a997c0b833.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;蓋茨進一步強調，AI 的創新無國界:「誰是第一經常在變，但無論來自中國還是美國，優秀的創意和技術都會在全球範圍內共享。AI 不會屬於某一個國家。」他認為，這種全球共享的趨勢對教育、健康甚至農業等多個領域都是積極的推動。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;蓋茨還提到，美國應更加廣泛地討論人工智能的政策問題。「我認為，到 2028 年，除了經濟議題，AI 將成為討論的焦點。」他認為，政策制定者應重視 AI 對各行各業的深遠影響，並確保該領域的快速發展與社會利益相匹配。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341480</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341480</guid>
            <pubDate>Fri, 28 Mar 2025 02:24:35 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>GPT-4o 模型更新，改進處理複雜任務和編碼能力</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;GPT-4o 模型昨晚進行了&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1905331956856050135&quot; target=&quot;_blank&quot;&gt;升級&lt;/a&gt;&lt;/u&gt;，發佈新版本 GPT 4o-03-26：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;對提示的遵循度大幅提升，尤其是一次性的多個提示內容&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;改進了處理複雜任務和編碼能力&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;減少了過多的表情符號輸出問題&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;提高了直覺和創造能力&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在競技場排名中躍升至第 2，超過了其最新模型 GPT-4.5&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height=&quot;1592&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0328/101502_anch_2720166.png&quot; width=&quot;1292&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;最新的 GPT 4o-03-26 API 也已經更新&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAIDevs%2Fstatus%2F1905335104211185999&quot; target=&quot;_blank&quot;&gt;提供&lt;/a&gt;，代號為「chatgpt-4o-latest」。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1546&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0328/101619_TpqQ_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341478/gpt-4o-03-26</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341478/gpt-4o-03-26</guid>
            <pubDate>Fri, 28 Mar 2025 02:17:35 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>字節跳動豆包新版深度思考開啓測試</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;字節跳動旗下豆包宣佈新版深度思考功能開啓測試。&lt;/p&gt; 
&lt;p&gt;和之前的深度思考不同，新版功能將推理過程的思維鏈與搜索深度結合，支持邊想邊搜。思考過程中，豆包可基於推理多次調用工具、搜索信息，提供更加全面、準確的結果。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;274&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2ac5e5e55a32b65c4c8ccaae098245cbda1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;適用場景&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;制定方案和規劃：豆包可根據思考結果推理缺失信息，繼續定向搜索，讓最終結果更完善&lt;/li&gt; 
 &lt;li&gt;輔助專業文章寫作：輔助專業文章寫作，深層次檢索資料信息；梳理複雜問題脈絡，提升思考深度&lt;/li&gt; 
 &lt;li&gt;模糊條件搜索：面對模糊關鍵詞，檢索儘可能多的結果；交叉驗證核心信息，精準鎖定目標答案&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;可通過打開豆包 app 最新版本或 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoubao.com&quot; target=&quot;_blank&quot;&gt;doubao.com&lt;/a&gt; 選擇「深度思考」模式進行使用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341477</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341477</guid>
            <pubDate>Fri, 28 Mar 2025 02:14:35 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>李想談自研汽車操作系統：多少有點「逼上梁山」的意味</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 27 日，理想汽車 CEO 李想在中關村論壇&lt;a href=&quot;https://www.oschina.net/news/341314&quot;&gt;宣佈推出自研操作系統理想星環 OS&lt;/a&gt;，並表示理想星環 OS 將進行開源。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/140214_PaFU_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;隨後，李想在微博&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1243861097%2FPkuc3ikEQ%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;發文&lt;/a&gt;&lt;/u&gt;透露了自研汽車操作系統的原因。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1564&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/181341_fkcQ_2720166.png&quot; width=&quot;1238&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;李想稱，自 2020 年下半年起，全球芯片面臨芯片結構性短缺，芯片的交貨週期被拉長了幾倍，價格也上漲了幾倍甚至數十倍。理想汽車當時作為一家初創企業，在芯片供應鏈的產能分配中處於劣勢，能夠拿到的芯片供應量極為有限。即使拿到供應，還要考慮和操作系統適配的問題。&lt;/p&gt; 
&lt;p&gt;加上 AUTOSAR 這個閉源系統的性能、安全性、成本等劣勢，理想汽車不得不決定自己來研發操作系統。&lt;/p&gt; 
&lt;p&gt;李想表示，現在來看，理想星環 OS 的自研，多少有點「逼上梁山」的意味。但理想汽車也因此意外打通了任督二脈，自研出一套適配時間更短、架構支持更廣、關鍵性能更優的系統。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341396</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341396</guid>
            <pubDate>Sat, 22 Mar 2025 10:14:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>MaxKB 開源知識庫問答系統 GitHub Star 數量突破 15,000 個！</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p style=&quot;color:#000000; text-align:start&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#3e3e3e&quot;&gt;截至 2025 年 3 月 26 日 16:30，飛致雲旗下開源項目——基於大語言模型和 RAG 的知識庫問答系統 MaxKB GitHub Star 數超過 15,000 個！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;889&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f2a88a4c7bf969c5e9a1c020dcee4b05fe7.jpg&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341394</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341394</guid>
            <pubDate>Sat, 22 Mar 2025 10:06:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>多語言語料庫萬卷·絲路 2.0 開源</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;上海人工智能實驗室（上海 AI 實驗室）聯合新華社新聞信息中心、上海外國語大學、外研在線等，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0iXCGvkBvbHRB2A6p1Ergw&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;全新升級的「萬卷·絲路 2.0」多語言語料庫。&lt;/p&gt; 
&lt;p&gt;在「萬卷·絲路 1.0」的基礎上，2.0 語料庫新增塞爾維亞語、匈牙利語、捷克語 3 類語料，涵蓋四大數據模態共計 1150 萬條數據，並運用精細化處理技術使數據質量達到「工業級」標準，實現「開箱即用」。&lt;/p&gt; 
&lt;p&gt;根據介紹，「萬卷·絲路 2.0」具有多語言、大規模、多模態、高質量的特點，更新速覽：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;語種數量擴充：在 5 個語種基礎上，新增塞爾維亞語、匈牙利語、捷克語等 3 個稀缺語料數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據模態、總量全面升級：在純文本數據基礎上，新增圖片-文本、音頻-文本、視頻-文本、特色指令微調 SFT 四大模態數據，覆蓋多模態研究全鏈路；整體數據總量超過 1150 萬條，音視頻時長超過 2.6 萬小時，滿足多種研究任務的需求。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;超精細數據，多場景適用：經成熟數據生產管線及安全加固，結合過濾算法與當地專家人工精細化地標註質檢，「萬卷·絲路 2.0」 已成為覆蓋多模態、多領域的大規模高質量數據集，含 20 餘種細粒度多維分類標籤及詳細的文本描述，適配文化旅遊、商業貿易、科技教育等不同場景，為開發者提供得力助手。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img height=&quot;212&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-18155891e238aaf9136875f06cbdf9ea42d.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;為驗證語料庫質量與應用前景，上海 AI 實驗室研究團隊基於「萬卷·絲路 2.0」，訓練出匈牙利語大模型，通用能力對標國際主流大模型，在本地化特色、安全性與中國關聯性上表現出顯著優勢，可適用於本地生活與中匈合作領域場景。&lt;/p&gt; 
&lt;p&gt;目前，該模型已衍生出對話平台、多語言 AI 教師助手、AI 匈中雙語詞典等創新應用。上海 AI 實驗室同時與外研在線、庫帕思等多家機構開展合作，推動「萬卷·絲路 2.0」在教育、文旅、技術交流領域落地，助力多語言 AI 生態發展。&lt;/p&gt; 
&lt;p&gt;上海 AI 實驗室研究團隊認為，通過整合多模態數據與精細化標註技術，「萬卷·絲路 2.0」首次實現了對低資源語言的系統性覆蓋，尤其擴充了塞爾維亞語、匈牙利語、捷克語等語言的高質量語料建設，為文化交流互鑑帶來可量化、可迭代的智能新維度。&lt;/p&gt; 
&lt;p&gt;「萬卷·絲路」語料庫下載鏈接：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopendatalab.com%2FapplyMultilingualCorpus&quot; target=&quot;_blank&quot;&gt;https://opendatalab.com/applyMultilingualCorpus&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341385</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341385</guid>
            <pubDate>Sat, 22 Mar 2025 09:33:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>微軟開源 「Hyperlight Wasm」，將輕量級虛擬機技術擴展至 WASM</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;微軟去年開源了一個名為「Hyperlight」的輕量級虛擬機項目，這是一個嵌入式虛擬機管理程序，可以用作微虛擬機管理器，支持在 Windows 和 Linux 應用程序中運行。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/170638_95Sv_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;近日，微軟開源了 Hyperlight Wasm——將其輕量級虛擬機（VM）技術擴展至 WebAssembly（WASM）領域。&lt;/p&gt; 
&lt;p&gt;Hyperlight Wasm 基於開源項目 Hyperlight 構建，作為微虛擬機管理器，專為運行多語言編寫的 WASM 組件工作負載設計。該項目兼容 Windows Hypervisor Platform（Windows）、KVM（Linux）和 / dev / mshv（macOS）等虛擬化平台，通過 VM 沙箱隔離不可信代碼，兼顧高性能與安全性，適用於嵌入式函數等輕量化場景。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/170622_6rCp_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhyperlight-dev%2Fhyperlight-wasm&quot; target=&quot;_blank&quot;&gt;Hyperlight Wasm 的 GitHub 倉庫寫道&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&quot;Hyperlight-Wasm 是一個組件，它使得 Wasm 模塊能夠在輕量級虛擬機支持的沙盒中運行。它的目的是使應用程序能夠在 VM 中安全地運行不受信任或第三方 Wasm 代碼，同時具有非常低的延遲/開銷。它是建立在 Hyperlight 之上的。&lt;/p&gt; 
 &lt;p&gt;目前，Hyperlight-Wasm 支持 Windows 上的 Windows Hypervisor Platform、Linux 上的 KVM 或 /dev/mshv 運行應用程序。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;查看&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.microsoft.com%2Fblog%2F2025%2F03%2F26%2Fhyperlight-wasm-fast-secure-and-os-free%2F&quot; target=&quot;_blank&quot;&gt;微軟官方博客&lt;/a&gt;瞭解更多關於 Hyperlight Wasm 的信息。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341374/ms-hyperlight-wasm-fast-secure-and-os-free</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341374/ms-hyperlight-wasm-fast-secure-and-os-free</guid>
            <pubDate>Sat, 22 Mar 2025 09:10:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>KubeSphere v4.1.3 開源版發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;KubeSphere 4.1.3 開源版正式發佈，本次更新包含多項功能優化和缺陷修復，進一步提升安全性與易用性。&lt;/p&gt; 
&lt;h2&gt;功能優化&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;優化企業空間的級聯刪除邏輯&lt;/strong&gt; 企業空間級聯刪除策略從被動改為主動，避免誤操作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;調整部分平台角色、企業空間角色的授權規則&lt;/strong&gt; 進一步細化 RBAC 授權規則，安全性提升。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;優化 Pod 列表頁的數據展示&lt;/strong&gt; 更直觀的展示資源狀態信息，提升易用性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;允許用戶關聯多個身份提供程序&lt;/strong&gt; 用戶可同時綁定多個身份提供程序（IdP），提升靈活性和兼容性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持手動觸發應用倉庫更新&lt;/strong&gt; 用戶可以主動刷新應用倉庫，確保獲取最新的應用版本信息。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增「拒絕訪問」頁面&lt;/strong&gt; 將非法的頁面請求，重定向到「拒絕訪問」頁面。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;缺陷修復&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;修復應用實例無法升級的問題&lt;/li&gt; 
 &lt;li&gt;修復與預發佈 K8s 版本號的兼容性問題&lt;/li&gt; 
 &lt;li&gt;修復 LDAP 身份提供程序的配置問題&lt;/li&gt; 
 &lt;li&gt;修復無法從 Docker Hub 和 Harbor 搜索鏡像的問題&lt;/li&gt; 
 &lt;li&gt;修復應用程序版本中處理特殊字符的問題&lt;/li&gt; 
 &lt;li&gt;修復未安裝網關擴展時無法創建 Ingress 的問題&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;安裝升級&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;歡迎廣大用戶下載體驗，並提供寶貴反饋。&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;注意事項&lt;/h3&gt; 
&lt;p&gt;更多更新內容，請參閲 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkubesphere.io%2Fzh%2Fdocs%2Fv4.1%2F20-release-notes%2Frelease-v413%2F&quot; target=&quot;_blank&quot;&gt;KubeSphere 4.1.3 發佈説明&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;安裝與升級，請參閲 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkubesphere.io%2Fzh%2Fdocs%2Fv4.1%2F03-installation-and-upgrade%2F&quot; target=&quot;_blank&quot;&gt;安裝指南&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;注意：暫不支持從 v3.x 版本直接升級到 v4.x，計劃在 4 月下旬的版本更新中支持。&lt;/p&gt; 
&lt;h3&gt;反饋渠道：&lt;/h3&gt; 
&lt;p&gt;提交 Issue：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkubesphere%2Fkubesphere%2Fissues%2Fnew%2Fchoose&quot; target=&quot;_blank&quot;&gt;GitHub Issues&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;社區討論：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fask.kubesphere.com.cn%2Fforum%2F&quot; target=&quot;_blank&quot;&gt;KubeSphere 論壇&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;未來展望&lt;/h2&gt; 
&lt;p&gt;在未來的版本更新中，KubeSphere 團隊將持續關注開源社區的需求與反饋。我們承諾始終不忘初心，為廣大的開源用戶提供更穩定、更安全、更高效的產品體驗。隨着 KubeSphere 的不斷演進，我們將不斷優化平台的性能和功能，特別是在易用性、安全性以及多雲環境支持等方面，確保用戶在快速變化的技術環境中保持領先。&lt;/p&gt; 
&lt;p&gt;感謝每一位 KubeSphere 用戶的支持和貢獻，我們將繼續努力，為大家帶來更多驚喜和實用功能。期待您在未來的版本中，依舊能與我們一同成長和進步。&lt;/p&gt; 
&lt;p&gt;&amp;gt; 本文由博客一文多發平台 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenwrite.cn%3Ffrom%3Darticle_bottom&quot; target=&quot;_blank&quot;&gt;OpenWrite&lt;/a&gt; 發佈！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4197945/blog/18017524</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4197945/blog/18017524</guid>
            <pubDate>Sat, 22 Mar 2025 09:00:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>MCP Go —— MCP 的 Go 實現</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                            &lt;p&gt;Model Context Protocol (MCP)&amp;nbsp;的 Go 實現，實現 LLM 應用程序與外部數據源和工具之間的無縫集成。&lt;/p&gt;

&lt;div style=&quot;text-align:start&quot;&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:var(--bgColor-muted, var(--color-canvas-subtle))&quot;&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:var(--fgColor-default, var(--color-fg-default))&quot;&gt;&lt;span style=&quot;background-color:var(--bgColor-muted, var(--color-canvas-subtle))&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;package&lt;/span&gt;&lt;/span&gt; main

&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;import&lt;/span&gt;&lt;/span&gt; (
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;errors&quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/span&gt;

    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;github.com/mark3labs/mcp-go/mcp&quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;github.com/mark3labs/mcp-go/server&quot;&lt;/span&gt;&lt;/span&gt;
)

&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;func&lt;/span&gt;&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-comment)&quot;&gt;// Create MCP server&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;s&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;:=&lt;/span&gt;&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;NewMCPServer&lt;/span&gt;&lt;/span&gt;(
        &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;Demo 🚀&quot;&lt;/span&gt;&lt;/span&gt;,
        &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;/span&gt;,
    )

    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-comment)&quot;&gt;// Add tool&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;tool&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;:=&lt;/span&gt;&lt;/span&gt; &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;NewTool&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;hello_world&quot;&lt;/span&gt;&lt;/span&gt;,
        &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;WithDescription&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;Say hello to someone&quot;&lt;/span&gt;&lt;/span&gt;),
        &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;WithString&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;/span&gt;,
            &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Required&lt;/span&gt;&lt;/span&gt;(),
            &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Description&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;Name of the person to greet&quot;&lt;/span&gt;&lt;/span&gt;),
        ),
    )

    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-comment)&quot;&gt;// Add tool handler&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;s&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;AddTool&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;tool&lt;/span&gt;, &lt;span&gt;helloHandler&lt;/span&gt;)

    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-comment)&quot;&gt;// Start the stdio server&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;if&lt;/span&gt;&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;:=&lt;/span&gt;&lt;/span&gt; &lt;span&gt;server&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;ServeStdio&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;s&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;!=&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;nil&lt;/span&gt;&lt;/span&gt; {
        &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Printf&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;Server error: %v&lt;span&gt;\n&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt;)
    }
}

&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;func&lt;/span&gt;&lt;/span&gt; &lt;span&gt;helloHandler&lt;/span&gt;(&lt;span&gt;ctx&lt;/span&gt; context.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-storage-modifier-import)&quot;&gt;Context&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;request&lt;/span&gt; mcp.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-storage-modifier-import)&quot;&gt;CallToolRequest&lt;/span&gt;&lt;/span&gt;) (&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;*&lt;/span&gt;&lt;/span&gt;mcp.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-storage-modifier-import)&quot;&gt;CallToolResult&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-storage-modifier-import)&quot;&gt;error&lt;/span&gt;&lt;/span&gt;) {
    &lt;span&gt;name&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;:=&lt;/span&gt;&lt;/span&gt; &lt;span&gt;request&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Params&lt;/span&gt;&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Arguments&lt;/span&gt;&lt;/span&gt;[&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;/span&gt;].(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-storage-modifier-import)&quot;&gt;string&lt;/span&gt;&lt;/span&gt;)
    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;if&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;!&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; {
        &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;return&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;New&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;name must be a string&quot;&lt;/span&gt;&lt;/span&gt;)
    }

    &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-keyword)&quot;&gt;return&lt;/span&gt;&lt;/span&gt; &lt;span&gt;mcp&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;NewToolResultText&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;Sprintf&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-string)&quot;&gt;&quot;Hello, %s!&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span&gt;name&lt;/span&gt;)), &lt;span&gt;&lt;span style=&quot;color:var(--color-prettylights-syntax-constant)&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MCP Go 處理所有複雜的協議細節和服務器管理，因此你可以專注於構建出色的工具。它旨在實現高級且易於使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:start&quot;&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要特點：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;快速&lt;/strong&gt;：高級接口意味着更少的代碼和更快的開發速度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簡單&lt;/strong&gt;：使用最少的樣板構建 MCP 服務器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完整&lt;/strong&gt;：MCP Go 旨在提供核心 MCP 規範的完整實現&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/mcp-go</link>
            <guid isPermaLink="false">https://www.oschina.net/p/mcp-go</guid>
            <pubDate>Sat, 22 Mar 2025 08:55:00 GMT</pubDate>
        </item>
        <item>
            <title>大阪大學推出開源量子計算機操作系統</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;大阪大學、富士通有限公司、系統工程顧問株式會社 (SEC) 和 TIS Inc. (TIS) 宣佈在 GitHub 上&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Foqtopus-team.github.io%2F&quot; target=&quot;_blank&quot;&gt;發佈量子計算機開源操作系統。&lt;/a&gt;該系統名為面向操作員和用戶的開放量子工具鏈 (OQTOPUS)，代表了量子計算領域全球最全面的開源努力之一。&lt;/p&gt; 
&lt;p&gt;OQTOPUS 的設計靈活且可定製，允許用戶根據自己的特定需求定製系統。它的發佈有望通過顯著降低設置和操作量子系統的複雜性（尤其是在雲環境中）來加速量子計算的實際部署。&lt;/p&gt; 
&lt;p&gt;以前，大學和公司必須開發大量定製軟件才能實現基於雲的量子計算。藉助 OQTOPUS，協作團隊通過提供從設置到執行的完整、隨時可用的操作系統簡化了這一流程，使量子計算比以往任何時候都更容易實現。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://static.cnbetacdn.com/article/2025/0326/9a81488446346d8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7841684490beba2f38b4aada0d2510d2641.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;OQTOPUS 概覽。圖片來源：OQTOPUS 團隊&lt;/p&gt; 
&lt;p&gt;此外，大阪大學提供的量子計算雲服務已開始將 OQTOPUS 整合到其運營中，富士通有限公司將在 2025 年下半年向使用其量子計算機的研究合作伙伴提供該服務。&lt;/p&gt; 
&lt;p&gt;展望未來，研究團隊將通過不斷擴展 OQTOPUS 的功能和發展蓬勃發展的全球社區來推動量子計算的發展。大阪大學量子信息與量子生物學中心 (QIQB) 的 Keisuke Fujii 博士提到：「這將促進各種量子軟件和系統的標準化，同時推動創新量子應用的創建。」&lt;/p&gt; 
&lt;p&gt;該研究由日本科學技術振興機構和日本國家量子科學技術研究所資助。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341363/scientists-launch-open-source-quantum-computer-os</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341363/scientists-launch-open-source-quantum-computer-os</guid>
            <pubDate>Sat, 22 Mar 2025 08:41:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>全新的對象數據庫測試版發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span&gt;ObjectServer 是一個全新的對象數據庫，在繼承了傳統 sql 關係數據庫的一切優點的基礎之上，還解決了困擾行業幾十年的，對象語言構建的信息系統和關係數據庫之間交換數據需要轉換的問題。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span&gt;這樣構建信息系統時就可以統一的用對象建模，還能直接存儲對象，操作對象，不再需要 orm 轉換層。對象也能在不同編程語言構建的異構信息系統中自由的流動和處理。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span&gt;ObjectServer 查詢功能也比 sql 數據庫更強大，能做更復雜的數據處理和查詢工作。由於查詢也是基於對象模型，所以也能做到查詢的圖形化。這個數據庫能在幾乎所有的應用場景中替換傳統的 sql 關係數據庫，而且比 sql 數據庫更強大易用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341358</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341358</guid>
            <pubDate>Sat, 22 Mar 2025 08:29:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>AI 熱潮中，哪類人才最緊缺？</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;2025 年春招中，人工智能領域招聘需求大幅增長，算法、機器學習等方面的人才成為企業高薪爭搶的「香餑餑」，人工智能講師崗位招聘量也在激增。&lt;/p&gt; 
&lt;p&gt;隨着 AI 技術加快應用，未來還會缺哪些方面的人才？如何捕捉到其中的就業新機遇？&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;283&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0bd7f6ff0d7d0b2ef4705cba1c34f34fd2e.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;企業高薪招聘 AI 人才&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;近期，「百萬英才匯南粵」春季大型綜合招聘會在廣州舉辦，現場人頭攢動。5 萬多個招聘崗位中，電子信息、先進製造行業招聘數量排名前列，特別是人工智能相關崗位需求旺盛。&lt;/p&gt; 
&lt;p&gt;「新華視點」記者看到，比亞迪、小馬智行、優必選等一批企業高薪招聘自動駕駛算法工程師、AI 引擎研發工程師等崗位，吸引了諸多求職者投遞簡歷。一些在讀研究生專程前來尋找 AI 方向的實習機會。&lt;/p&gt; 
&lt;p&gt;從事腦機接口產品研發生產的廣東神舞科技有限公司，正在招募高級嵌入式工程師、神經科學家、算法工程師等。「招聘人數沒有上限，待遇從優，比如算法工程師，可提供兩室一廳免費住房外加 40 萬至 70 萬元年薪。」公司創始人鄭輝説。&lt;/p&gt; 
&lt;p&gt;慕尼黑工業大學的劉思蕾專程從德國回來參加招聘會，她的專業方向是機器人、認知與智能。她説，國內正在大力發展人工智能，機會多，能讓自己快速成長。&lt;/p&gt; 
&lt;p&gt;不久前杭州舉辦的春季首場大規模線下人才招聘會上，830 家企業推出 2.1 萬個崗位，其中半數聚焦 AI 算法、大模型開發。宇樹科技推出了 AI 算法工程師、深度強化學習算法、機器人運動控制算法等 10 個崗位，月薪最高達 7 萬元。&lt;/p&gt; 
&lt;p&gt;「DeepSeek 的爆發加速了 AI 在各行各業的應用滲透。由於 AI 人才市場需求加劇，企業紛紛提高了招聘薪資水平。」智聯招聘執行副總裁李強説。&lt;/p&gt; 
&lt;p&gt;智聯招聘數據顯示，2 月份，算法工程師、機器學習、深度學習崗位招聘量同比增速分別為 46.8%、40.1%、5.1%；平均招聘月薪均突破 2 萬元，分別為 23510 元、21534 元、24015 元。作為訓練 AI 模型的基礎工作，數據標註崗位招聘需求同比增長超 50%。&lt;/p&gt; 
&lt;p&gt;此外，市場對 AI 知識傳播和人才培養的需求也在急劇提升。據智聯招聘數據，今年春節後一個月，人工智能講師招聘職位數同比增長 112.4%，平均招聘月薪為 15792 元。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;市場急缺哪方面 AI 人才？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;高薪之下，越來越多求職者希望投身人工智能行業。智聯招聘數據顯示，2 月份，AI 領域求職人數同比增幅達 200% 以上。&lt;/p&gt; 
&lt;p&gt;當前企業最青睞哪類 AI 人才？&lt;/p&gt; 
&lt;p&gt;獵聘近日發佈的《2025AI 技術人才供需洞察報告》顯示，去年 2 月至今年 1 月間，在獵聘平台上招聘的 AI 職位中，約 47% 要求碩博學歷。&lt;/p&gt; 
&lt;p&gt;由於人工智能自 2019 年才被正式納入本科專業目錄，目前 AI 領域多數從業者來自其他相關專業。從獵聘數據看，人數最多的前四個專業分別是計算機科學與技術、軟件工程、電子信息以及機械工程。&lt;/p&gt; 
&lt;p&gt;「企業主要看是否具備相關專業能力。」獵聘大數據研究院相關負責人介紹，算法是人工智能的核心，涉及複雜的數學、統計學、計算機科學等領域的知識；深度學習則涉及複雜的神經網絡模型和算法優化，從業者在掌握線性代數、概率論、統計學等知識的同時，還需具備編程技能。&lt;/p&gt; 
&lt;p&gt;多家平台數據顯示，今年以來，AI 人才持續保持供不應求的態勢。未來隨着 AI 技術加快應用，還會缺哪些方面的人才？&lt;/p&gt; 
&lt;p&gt;除了當前市場緊缺的算法工程師、大模型工程師、機器學習工程師等，從全產業鏈看，AI 領域在基礎層、技術層、應用層都存在人才缺口，比如高性能計算工程師、芯片架構師等，也是企業競相爭奪的對象。&lt;/p&gt; 
&lt;p&gt;中國科學院自動化研究所研究員王亮表示，由於人工智能涉及多領域，所需人才也覆蓋多種類型——既有致力於前沿算法與核心理論創新的基礎研究型人才，也有將理論與算法模型開發相結合、形成可落地產品的技術開發型人才，還包括既懂人工智能技術又懂所在行業業務的應用複合型人才。此外，AI 訓練師、數據標註工程師、AI 倫理與安全專家等數據治理和支撐人才也變得越來越重要。&lt;/p&gt; 
&lt;p&gt;「目前最急需的還是基礎研究型人才和應用複合型人才，一方面解決高端 AI 芯片國產化率不足和算法原創性不足問題，另一方面推動 AI 加速賦能各領域各行業。」王亮認為。&lt;/p&gt; 
&lt;p&gt;據麥肯錫報告預測，到 2030 年，中國對 AI 專業人才的需求預計將達 600 萬人，而人才缺口可能高達 400 萬人。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;如何捕捉 AI 發展中的就業機遇？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;面對 AI 帶來的崗位替代和新的崗位需求，普通人如何適應產業變化，提高就業的穩定性和競爭力？&lt;/p&gt; 
&lt;p&gt;教育，無疑是其中關鍵一環。新一輪科技浪潮下，中國高校也迎來史上最大規模專業調整。短短几年間，已有超 500 所高校開設人工智能專業或成立專門學院，考生的報考熱度持續升高。2025 年清華大學、中國人民大學等高校擴招計劃裏均包含人工智能專業。&lt;/p&gt; 
&lt;p&gt;「人才數量提升的同時，優化培養結構、提升質量顯得更為關鍵。」王亮認為，未來不同層次和領域的 AI 人才需求會更加細分，高校在專業設置和課程設計上應更加註重人才的差異化培養。&lt;/p&gt; 
&lt;p&gt;2024 年，南開大學全面啓動「人工智能賦能人才培養行動計劃」，打造了 130 餘門人工智能系列課程羣。&lt;/p&gt; 
&lt;p&gt;「人工智能需要多學科交叉融合發展，這就要求高校超前佈局、主動調整，在加強基礎學科、新興學科、交叉學科建設中，形成學科集羣，為推動人工智能人才培養提供堅實基礎。」南開大學校長陳雨露説。&lt;/p&gt; 
&lt;p&gt;為培養更多實用型、複合型和緊缺型人工智能應用人才，教育部近日印發通知，部署各地各高校面向企事業單位和行業協會徵集一批「人工智能應用」領域供需對接就業育人項目。&lt;/p&gt; 
&lt;p&gt;「行業從業者也需要保持持續學習的習慣。」王亮表示，從人工智能相關專業畢業生的反饋來看，職業發展過程中，除了技術能力外，設計思維、跨學科協作、自主學習能力的培養同樣至關重要。&lt;/p&gt; 
&lt;p&gt;在科大訊飛董事長劉慶峯看來，AI 技能應成為未來公民必備能力，需加強 AI 新職業的規劃與管理及相關技能培訓，尤其要為低收入和就業困難羣體提供免費培訓機會。&lt;/p&gt; 
&lt;p&gt;「年輕人無論從事哪個專業，都可以每週花點時間，關注全球 AI 技術在各行各業的發展，這是未來最大的機會源泉。」宇樹科技創始人王興興説。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341353</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341353</guid>
            <pubDate>Sat, 22 Mar 2025 08:18:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>瀏覽器引擎新貴對決：Servo 與 Ladybird 的全面比較</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;原文作者：Niccolò Venerandi，發表於 2025 年 3 月 23 日&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;開源瀏覽器引擎領域正迎來兩位新秀的崛起，它們以不同的方式挑戰着 Chrome、Firefox 和 Safari 的主導地位。本文將對 Servo 和 Ladybird 這兩個充滿潛力的項目進行深入分析，比較它們的發展歷程、資金狀況、技術表現與未來前景。&lt;/p&gt; 
&lt;h2&gt;起源與發展歷程&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Servo&lt;/strong&gt;最初於 2012 年作為 Mozilla 的研究項目誕生，旨在利用 Rust 語言的內存安全特性和併發功能來加速網頁渲染。該項目在 2014 年通過了基本的 Acid2 測試，到 2016 年在某些特定任務上已經能夠超越其他引擎。隨後，Mozilla 開始將 Servo 的組件移植到 Firefox 的 Gecko 引擎中，這個被稱為&quot;Quantum&quot;的項目為 Firefox 帶來了顯著的性能提升。&lt;/p&gt; 
&lt;p&gt;然而，2020 年 Mozilla 裁掉了整個 Servo 團隊，項目轉由 Linux 基金會管理，但幾乎沒有資金支持。直到 2023 年 1 月，在&quot;外部資金&quot;的支持下，Servo 通過 Igalia 公司的開發團隊重獲新生。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Ladybird&lt;/strong&gt;則是由單一開發者 Andreas Kling 於 2022 年創建的開源網絡瀏覽器。然而，為了公平比較，其背後的 LibWeb 引擎實際上始於 2019 年，在 Ladybird 誕生前已有數百人蔘與貢獻。2022 年，Ladybird/LibWeb 已經通過了 Acid3 測試，該項目最初主要依靠 Patreon 和 GitHub 贊助、YouTube 廣告收入以及周邊銷售獲得資金，明確拒絕接受風險投資。&lt;/p&gt; 
&lt;p&gt;後來，隨着項目規模擴大，Kling 決定將 Ladybird 從 SerenityOS 分離出來，成立了獨立的非營利組織&quot;Ladybird Browser Initiative&quot;。&lt;/p&gt; 
&lt;h2&gt;主要差異&lt;/h2&gt; 
&lt;p&gt;雖然二者都是開源瀏覽器技術，但存在幾個關鍵差異：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;定位不同&lt;/strong&gt;：Servo 是瀏覽器引擎，設計之初就考慮了易於嵌入各種應用；而 Ladybird 是一個完整瀏覽器，其引擎 LibWeb 主要服務於自身。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;技術棧&lt;/strong&gt;：Servo 從一開始就使用 Rust 語言開發，注重內存安全和併發性能；Ladybird 則使用 C++構建。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;發展理念&lt;/strong&gt;：據 Andreas Kling 所言，Servo 更像是一個實驗項目，追求創新和實驗性；Ladybird 則更注重實用性和兼容性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;資金與團隊規模&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Servo&lt;/strong&gt;由神祕的&quot;外部資金&quot;支持 Igalia 的 5 名開發者，同時通過 GitHub 贊助和 OpenCollective 募集資金。截至文章發佈時，他們在 GitHub 有 313 位贊助者，每年約 2 萬美元收入；在 OpenCollective 上一年內籌集了 4.4 萬美元，年度預算估計為 6.1 萬美元，理論上可以支持 6 名全職開發者。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Ladybird&lt;/strong&gt;的資金狀況更為可觀。項目收到了 GitHub 聯合創始人 Chris Wanstrath 家族的 100 萬美元捐贈，Shopify 的 10 萬美元資助，以及來自 Proton VPN、Ahrefs 等機構合計 20 萬美元的贊助。這些資金使團隊能夠維持 7 名全職工程師，並保持 18 個月的資金儲備。&lt;/p&gt; 
&lt;p&gt;總體而言，Ladybird 在資金和團隊規模上略佔優勢，但差距不算太大。&lt;/p&gt; 
&lt;h2&gt;網絡標準支持&lt;/h2&gt; 
&lt;p&gt;在網絡標準測試方面，Ladybird 通過了 Acid3 測試並獲得滿分，而 Servo 僅達到 83 分。&lt;/p&gt; 
&lt;p&gt;在更全面的網絡平台測試中，Ladybird 通過了 88% 的測試，Servo 為 76%，參考 Chrome 的成績是 97%。然而，在特定類別上比較，Servo 在 CSS 測試中表現更佳（49% 對 42%），特別是在 CSS2、cssom 和 flexbox 等方面。&lt;/p&gt; 
&lt;p&gt;值得注意的是，5 個月前 Servo 在網絡平台測試中領先，但 Ladybird 迅速趕上。總體而言，Ladybird 在網絡標準兼容性方面發展更快，但 Servo 在其專注的領域更勝一籌。&lt;/p&gt; 
&lt;h2&gt;性能表現&lt;/h2&gt; 
&lt;p&gt;在性能測試方面，Servo 展現出明顯優勢：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在 JetStream 測試中，Servo 得分 129.833（Chrome 為 243.338），而 Ladybird 無法完成測試。&lt;/li&gt; 
 &lt;li&gt;在 Octane 測試中，Servo 的分數比 Ladybird 高出一個數量級。&lt;/li&gt; 
 &lt;li&gt;在 Speedometer v2 測試中，Servo 的得分約為 Ladybird 的 7 倍。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;作者在隨機選擇的政府網頁上進行非科學測試也發現，Ladybird 在大多數情況下加載速度明顯慢於 Servo。&lt;/p&gt; 
&lt;h2&gt;總結與前景&lt;/h2&gt; 
&lt;p&gt;Servo 和 Ladybird 代表了開源瀏覽器引擎的不同發展路徑：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Ladybird&lt;/strong&gt;擁有更豐厚的資金支持和更快的網絡標準兼容性發展速度，團隊規模稍大，社區影響力持續擴大。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Servo&lt;/strong&gt;則憑藉 Rust 語言帶來的併發優勢，在性能方面遙遙領先，特別是在 JavaScript 執行和應用響應速度上。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;雖然兩者與主流瀏覽器相比還有距離，但它們的存在為網絡技術帶來了新的活力和多樣性。Servo 在實驗性和高性能方面的優勢，與 Ladybird 在標準兼容性和資金穩定性上的優勢，使它們各具特色，值得持續關注。&lt;/p&gt; 
&lt;p&gt;隨着這兩個項目的不斷發展，開源瀏覽器引擎領域的競爭將變得更加激烈，最終受益的將是所有互聯網用戶。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;em&gt;想更深入瞭解 Servo 和 Ladybird 的詳細比較，請閲讀原文：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthelibre.news%2Fservo-vs-ladybird%2F&quot; target=&quot;_blank&quot;&gt;Servo vs Ladybird - The Libre News&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341350</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341350</guid>
            <pubDate>Sat, 22 Mar 2025 08:03:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>開源模型逆襲：Databricks TAO 技術微調 Llama 超越 GPT-4o</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;數據智能公司 Databricks 近日推出了一種全新的大語言模型微調方法 ——TAO（Test-time Adaptive Optimization）。通過運用無標註數據和強化學習，TAO 不僅在降低企業成本方面表現出色，更是在一系列基準測試中取得了令人矚目的成績。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據科技媒體 NeoWin 的報道，TAO 微調後的 Llama3.370B 模型在金融文檔問答和 SQL 生成等任務中，展現出了優於傳統標註微調方法的性能，甚至逼近了 OpenAI 的頂級閉源模型。這一成果標誌着開源模型在與商用 AI 產品競爭中的又一次重大突破。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;177&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-636746ea5f1ede735d2b9d4890469e2252e.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;TAO 方法的核心在於其獨特的 「測試時計算」 理念，能夠自動探索任務的多樣性，同時結合強化學習來優化模型，從而避免了傳統微調所需的人工標註成本。在多項企業基準測試中，TAO 微調的 Llama 模型成績斐然:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 FinanceBench 基準測試中，該模型在 7200 道 SEC 文檔問答中取得了 85.1 的高分，超過了傳統標註微調（81.1）和 OpenAI 的 o3-mini(82.2) 的成績。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 BIRD-SQL 測試中，TAO 微調的 Llama 模型得分為 56.1，接近 GPT-4o 的 58.1，遠超傳統標註微調（54.9）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 DB Enterprise Arena 中，TAO 模型得分為 47.2，雖然略低於 GPT-4o 的 53.8，但仍然顯示了強勁的競爭力。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height=&quot;336&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-aff51111b21b90482315a050f5906852795.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341348</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341348</guid>
            <pubDate>Sat, 22 Mar 2025 07:52:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>深度剖析 StarRocks 讀取 ORC 加密文件背後的技術</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互聯網大數據團隊 - Zheng Xiaofeng&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;本文介紹了 StarRocks 數據庫如何讀取 ORC 加密文件，包括基礎概念以及具體實現方案。深入探討了利用 ORC 文件的四層結構和三層索引機制，實現高效查詢加密數據。希望通過本文對 ORC 加密文件讀取功能的實現細節的剖析，讓讀者更加深刻理解 ORC 文件，同時瞭解 StarRocks 支持加解密數據分析的方案。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;為了提升對敏感數據的保護，需要對 Hive 表一些敏感數據進行加密存儲。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Spark 組件已經通過引入了 Apache ORC 項目（Java 版本）對 ORC 格式的 Hive 表的數據進行加解密。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;StarRocks 也使用了 Apache ORC 項目的 C++版本讀寫 ORC 文件，但是&lt;strong&gt;C++版本沒有實現加解密功能&lt;/strong&gt;，在使用 StarRocks 對 Hive 表進行即席分析時，無法對具有加密列的 Hive 表進行查詢，因此，需要對 StarRocks 的 Apache ORC 模塊進行改造，使其支持對 ORC 格式的 Hive 加密表數據讀取功能，數據架構圖如下圖所示：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//42662e0b81a83165a856f0c38387b668.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;希望通過本文對 ORC 加密文件讀取功能的實現細節的剖析，讓讀者更加深刻理解 ORC 文件，同時瞭解 StarRocks 支持加解密數據分析的方案。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、問題引入&lt;/h1&gt; 
&lt;p&gt;在正式開啓全文的閲讀之前，我們首先引入幾個問題，然後帶着這些問題去閲讀後面的內容，將會更有針對性與啓發性，通過深入解答這些問題，我們不僅能夠更好地理解相關的概念和技術，還能提升分析和解決問題的能力。問題如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;程序解壓某個文件時，是否需要一次性讀取整個文件後再進行解壓操作？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;ORC 文件究竟是如何做到在不掃描全文件的情況下就能精準查詢到想要的數據？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;當 SQL 查詢條件不符合最左前綴原則時，ORC 文件中的索引是否就會失效？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據加密、解密、解壓以及壓縮之間的關聯關係到底是怎樣的？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在寫 ORC 文件時為什麼是先壓縮後加密，而不是先加密後解壓？&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/blockquote&gt; 
&lt;span id=&quot;OSC_h1_3&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、ORC 文件介紹&lt;/h1&gt; 
&lt;p&gt;ORC（Optimized Row Columnar）文件格式是一種高度優化的列式存儲格式，它主要用於 Hadoop 生態系統中的大數據處理和分析。ORC 文件結構的設計旨在提高 I/O 效率、減少數據讀取時間，並支持複雜的數據類型和壓縮算法。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 四層結構 File ,Stripe,Stream，Group&lt;/h2&gt; 
&lt;p&gt;一個 File 中包含多個 Stripe，一個 Stripe 包含多個 Steam，一個 Stream 包含多個 Group，每個 Group 默認存儲 1 萬行數據，如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//daf79f27d162699ca73e6745cd92b780.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.2&amp;nbsp;三層索引&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt; ：文件級別各列的統計信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;：Stripe 級別各列的統計信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;：每個 Stripe 內部各列的索引信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在讀取文件中數據之前，會先讀取以上 3 類索引數據，根據 SQL 條件逐層進行比對，來決定是否跳過某些數據的讀取，減少數據掃描量，從而提升 SQL 查詢效率。&lt;/p&gt; 
&lt;p&gt;下表是隻包含 id 和 name 兩列的 ORC 文件的各層統計信息的案例：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//18e323617df740616d0230aa1e15ae4c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//0679ad98f36eaec4b8e50af132d4ee96.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a0ad1992999f1f653a589ab33cb184db.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.3 ORC 文件內部詳細結構&lt;/h2&gt; 
&lt;p&gt;前面已經大體介紹了 ORC 文件的結構，下面詳細介紹其內部結構，ORC 文件由多個邏輯層次組成，每個層次都有特定的作用和結構，下圖具體描述了包含 2 列（id，name）的 ORC 文件結構圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//51bb6963b452f9f0a51c7531681f452e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tail&lt;/strong&gt;：存儲文件的元數據，如列的壓縮信息、統計信息、版本等，包含了三個部分：PostScript、Footer、MetaData。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;：實際存儲數據的部分，由多個 Stripe 組成。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下面分別介紹 Tail 和 Body 內部包含哪些結構：&lt;/p&gt; 
&lt;p&gt;Tail 文件尾部是讀取 ORC 文件的起點，它包含了文件關鍵信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;PostScript&lt;/strong&gt;：存儲文件的壓縮類型、壓縮塊大小、版本信息，Footer 和 MetaData 的長度等，這部分數據不會被壓縮。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Footer&lt;/strong&gt;：記錄了整個文件所有列的統計信息（FileStat），所有 Stripe 的元數據信息（stripesList），加密信息（encryption）以及文件 body 長度。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;MetaData&lt;/strong&gt;：存儲該文件所有 Stripe 的統計信息（StripeStat）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Body 實際存儲數據的部分，由多個 Stripe 組成，每個 Stripe 包含多個 Stream，先存儲索引相關的 Stream（index-Stream），後面存儲實際數據相關的 Stream（data-Stream），每一列包含多個 index-Stream 和 data-Stream，Stripe 是 ORC 文件中數據存儲的基本單元，每個 Stripe 數據大小一般不超過 200M，主要包含下面幾塊內容：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Stripe Footer&lt;/strong&gt;：包含所有 Stream 的元數據（streamsList）和加密信息（encryption）等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Index-Stream&lt;/strong&gt;：存儲索引相關數據的 Stream，按列存儲。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data-Stream&lt;/strong&gt;：儲實際數據相關的 Stream，按列存儲。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;ORC 文件的讀取是從尾部最後一個字節開始的，得到 PostScript 的長度，讀取 PostScript，然後根據 PostScript 中的 FooteLength，MetaDataLength 信息讀取 MetaData 和 Footer，最後根據 Footer 中的 Stripe 信息讀取具體的數據 Stripe，上面的文字介紹可能不是很直觀，如果想更細節瞭解 ORC 文件結構內容可以參考（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.processon.com%2Fmindmap%2F6503c70803ab061eb31b80da&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件結構思維導圖&lt;/a&gt;，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Forc.apache.org%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件官網介紹&lt;/a&gt;）。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、相關概念的理解&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 對稱加解密&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1c56a2f7a82e7f369cd1548d0ef7eb36.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;對稱加解密的要素包括密鑰、明文、密文和加密算法。以下是對這些要素關係的描述：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密鑰&lt;/strong&gt;：密鑰是加密和解密過程中的關鍵元素，它是由隨機數生成的，通常是固定長度的一串二進制數。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;明文&lt;/strong&gt;：明文是指原始的信息，可以是文本、圖片、音頻等各種形式的數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密文&lt;/strong&gt;：密文是經過加密算法處理後的數據，只有知道密鑰的人才能解密還原成明文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密算法&lt;/strong&gt;：加密算法是將明文轉換成密文的過程，這個過程通常涉及到一系列的數學運算，比如 AEC，RSA 等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;注意：對稱加密的加密密鑰，和 解密密鑰是一樣的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.2 文件的壓縮和解壓縮&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.1&amp;nbsp;壓縮算法&lt;/h3&gt; 
&lt;p&gt;壓縮算法是用於減小文件大小的數學方法。它通過各種技術，如替換、重新編碼、差分編碼、運行長度編碼、字典編碼、變換編碼等，來減少數據的冗餘和實現數據的體積縮小。壓縮算法可以是無損的或有損的：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;無損壓縮&lt;/strong&gt;：意味着原始數據可以完全從壓縮文件中恢復，常用於文本和某些類型的數據文件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;有損壓縮&lt;/strong&gt;：為了獲得更高的壓縮率，允許丟失一些數據，常用於圖像、音頻和視頻文件。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h3_11&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.2 解壓算法&lt;/h3&gt; 
&lt;p&gt;解壓算法是壓縮算法的逆過程，它用於將壓縮文件恢復到其原始狀態。無損壓縮的解壓算法能夠完全恢復原始數據，而有損壓縮的解壓算法則可能無法完全恢復所有原始數據。&lt;/p&gt; 
&lt;p&gt;文件壓縮和解壓縮簡單流程圖如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3edcbf4fcc94f0f715892423538e2ded.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：數據的壓縮算法和解壓算法要一樣&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.3 壓縮塊&lt;/h3&gt; 
&lt;p&gt;文件壓縮塊是指對文件進行壓縮處理後生成的一組連續的數據塊。在文件壓縮過程中，文件被分割成多個塊，每個塊都經過壓縮算法處理。一般來説，文件壓縮塊的大小可配置。例如，ZIP 壓縮的每個壓縮塊的大小可以達到 64KB 或更大，而在其他壓縮格式如 7z 中，壓縮塊的大小可以更大，通常為數 MB。這些大小可以根據文件的特性和壓縮算法的性能進行調整，以達到更好的壓縮比和解壓性能。&lt;/p&gt; 
&lt;p&gt;注意：在解壓文件的過程中會從文件中讀取整個壓縮塊數據到內存之後再使用解壓算法進行解壓處理，所以壓縮塊越大每次解壓讀取到內存裏的數據會越大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 加密壓縮文件讀寫大致流程&lt;/h2&gt; 
&lt;p&gt;在掌握了數據加密和壓縮的基礎知識之後，讓我們從宏觀的角度瞭解一下 ORC 加密文件讀寫流程，如下圖所示：在寫入時，內存中的數據首先被序列化，然後壓縮以減少體積，最後對數據加密。在讀取時，數據首先被解密以恢復原始格式，然後解壓數據得到原始數據，最後通過反序列化原始數據轉換為內存對象。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cd6b640a5a79817353e9bfb6a7fe81d5.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;詳細説明寫入和讀取過程中的各個步驟：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）寫入過程（序列化、壓縮、加密）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：在數據寫入存儲系統之前，首先需要將內存中的對象轉換成可以存儲或傳輸的格式，這個過程稱為序列化。序列化後的數據通常是一個二進制格式，便於後續的處理。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;壓縮&lt;/strong&gt;：序列化後的數據可能會佔用較大的空間。為了減少存儲需求和&lt;strong&gt;提升後續數據加密處理效率&lt;/strong&gt;，接下來對數據進行壓縮。壓縮算法會嘗試去除數據中的冗餘，從而減少數據的體積。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密&lt;/strong&gt;：壓縮後的數據需要進行加密，以確保數據的安全性。加密算法會使用密鑰對數據進行加密，生成密文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;存入文件中&lt;/strong&gt;：加密後的密文被存儲在文件中，等待後續的讀取或傳輸。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;（2）讀取過程（解密、解壓、反序列化）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;：當需要讀取文件中的數據時，首先需要使用正確的密鑰和加密算法對密文進行解密，恢復為壓縮前的數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解壓&lt;/strong&gt;：解密後，應用解壓算法對數據進行解壓，恢復到序列化前的狀態。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：解壓後的數據是一個二進制格式，需要進行反序列化，將其轉換為內存中的對象。反序列化是序列化的逆過程，它將二進制數據轉換為可讀可操作的數據結構。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;內存對象&lt;/strong&gt;：經過解密、解壓和反序列化之後，數據最終以內存對象的形式被程序處理。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_14&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、StarRocks 讀取 ORC 加密文件實現方案&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_15&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.1 ORC 文件內部數據加密關係&lt;/h2&gt; 
&lt;p&gt;首先，介紹幾個密鑰的含義：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;statKey&lt;/strong&gt;：用於解密加密列的 FileStat，StripeStat 的密鑰，每個列一個，加密存儲在文件 Footer 裏。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;dataKey&lt;/strong&gt;：用於解密加密列的 IndexData 和 RowData，每個 Stripe 的每一列都有一個，加密存儲在 Stripe 的 Footer 裏。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;masterKey&lt;/strong&gt;：文件的根密鑰，用於解密 ORC 文件中被加密的 statKey 和 dataKey，該密鑰沒有存儲在文件中，一般存儲在 Hive 表屬性上。要解密 ORC 文件中的數據，首先需要獲取這個 masterKey。然而，masterKey 本身也是加密的，因此在讀取 Hive 表之前，必須先從表屬性中提取出加密的 masterKey,訪問密鑰管理服務（Key Management Service, KMS），對加密的 masterKey 進行解密，從而獲得可用於實際解密操作的明文 masterKey 密鑰，一旦獲得了 masterKey 的明文形式，就可以用它來解密 ORC 文件中的 dataKey 和 statKey。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3f858f3c7fc6ed6c7e5dcdb8f10d2253.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下圖是描述了 masterKey、statKey，dataKey 之間的關係，灰色部分代表是存儲在文件中被加密的數據，綠色部分則是解密之後的數據，包括我們解密後的 statKey，dataKey。獲得這兩個密鑰之後分別用於解密統計信息和文件中的真實數據。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.2 StarRocks 讀取 ORC 加密文件流程&lt;/h2&gt; 
&lt;p&gt;在深入掌握了 ORC 文件中密鑰的相互關係和功能後，我們現在轉向探討 StarRocks 是如何讀取 ORC 加密表的數據。這個過程如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b39f8da7c9f25c2316cbbb845730a54b.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）提交 SQL 查詢&lt;/strong&gt;：用戶首先通過 SQL 客戶端向 StarRocks FE 節點提交查詢請求。這通常涉及到對 Hive 表下存儲的 ORC 加密文件進行讀取操作。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）獲取解密的 masterKey&lt;/strong&gt;：查詢提交後，系統首要根據 SQL 獲取 Hive 表中的 ORC 文件所需的 masterKey。這個 masterKey 一般存儲在表屬性裏，並且是加密存儲的，必須調用 KMS 服務來解密，得到密鑰明文。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）傳遞 masterKey 明文&lt;/strong&gt;：解密後的 masterKey，以明文形式傳遞給 StarRocks BE 節點。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）讀取並解密密鑰&lt;/strong&gt;：BE 拿到已解密的 masterKey 之後，讀取並解密 ORC 文件中的 statKey 和 dataKey，這兩個密鑰分別用於解密統計信息（FileStat，StripeStat）和實際數據內容，為接下來的統計信息和數據解密做準備。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）使用 statKey 和 dataKey 解密數據&lt;/strong&gt;：BE 使用 statKey 來解密文件的統計信息（fileStat 和 StripeStat）同時使用 dataKey 來解密實際的數據內容。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.3 讀取 ORC 加密文件的關鍵實現細節&lt;/h2&gt; 
&lt;p&gt;通過瞭解前文 StarRocks 讀取 ORC 加密文件流程，我們將深入探討讀取 ORC 加密文件的數據關鍵實現細節。首先，我們提出一個問題：在物理存儲中，文件存儲的是什麼內容？答案是二進制數據。這些二進制數據通常會經過壓縮處理。&lt;/p&gt; 
&lt;p&gt;ORC 文件的讀取流程是自外向內的，類似於&lt;strong&gt;剝洋蔥的過程&lt;/strong&gt;，逐步深入到我們需要讀取的目標數據。讀取流程可以概括為：首先讀取文件元數據，通過元數據獲取目標數據的偏移量（offset）和數據長度如下圖所示，然後通過流的方式讀取目標數據。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e9be4bd8a50aa1870bb661641f960c6e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具體到 ORC 加密文件的讀取實現代碼，主要採用了設計模式中的裝飾模式方式來組織代碼的。在這個模式中，原始的文件流（SeekableFileInputStream）首先被解密流（DecryptionInputStream）所包裝，如果是非加密文件就沒有這一層，然後解密流又被解壓縮流（DecompressionStream）所包裝。每一層流都只負責向其包裝的流請求數據，並在接收到一定量數據後開始處理自己的邏輯。如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//97de9ae2095fa9576fac708b4fe83419.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這種分層的方法保證每一層都專注於自己的職責，共同協作完成 ORC 文件的讀取任務。通過這種方式，我們不僅能夠高效地讀取 ORC 文件，還能確保數據的安全性和完整性。綜上所述，ORC 文件的讀取流程是一個從文件元數據到具體數據內容的逐步深入過程。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.4 加密字段跳讀機制&lt;/h2&gt; 
&lt;p&gt;為了提升數據的查詢效率，查詢數據時會根據索引數據跳過不必要的數據讀取，下面我們介紹加密列跳讀機制，理解了這部分的內容，就能非常清晰的知道，讀取加密字段時，對數據解密與解壓是怎樣協作的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.1 加密塊與壓縮塊的關係&lt;/h3&gt; 
&lt;p&gt;加密列的數據劃分了多個加密塊與壓縮塊，一個壓縮塊，包含多個加密塊，讀取數據時，先對每個加密塊進行解密，解密多個加密塊之後，把這些解密後的數據塊合併成一個完整的壓縮塊，然後對這個壓縮塊進行解壓得到原始數據下圖是加密塊與壓縮塊的關係圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cf9450e0def2e8eb5a9cbe6abbfde7fe.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_20&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.2 ORC 文件使用的加解密算法和模式&lt;/h3&gt; 
&lt;p&gt;下圖描述了具體的數據加解密過程中以及設計到整個過程中各種元素輸入輸出的關係：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4f53e022e28a5159e3253e08d126e357.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：同一個數據塊（16 字節）加密過程和解密過程中的，密鑰、IV 值、加密算法和加密模式必須相同。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;明文塊&lt;/strong&gt;：我們對 ORC 文件加密使用的加密算法是 AES-128-CTR/NoPadding，該算法加密數據時 ，會把明文按照 16 個字節劃分多個塊，每個塊加密之後得到的數據就是加密塊。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密塊&lt;/strong&gt;：每個明文數據塊加密之後得到的數據就是加密塊。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;初始向量 IV&lt;/strong&gt;：初始向量 IV 的作用是使加密更加安全可靠（加鹽），我們使用 AES 加密時需要主動提供這個初始向量 IV，而且只需要提供一個初始向量就夠了，後面每個數據塊的加密向量由加密模式決定，所以每個數據塊的加密向量都不一樣。初始向量 IV 的長度規定為 128 位 16 個字節，ORC 文件解密參數 IV 的描述如下：總共 16 個字節，前面 8 個字節分別存儲：列 ID，Stream 類型，Stripe 的 ID ，後面 8 個字節用於填充 min_count，由於我們使用的是 CTR 加密模式，所以這個 min_count 就是加密塊在整個加密數據中的計數，iv 各個內容長度定義如下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7a5939566e16aa553d81b75f3c0936fd.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;密鑰&lt;/strong&gt;：AES 要求密鑰的長度可以是 128 位 16 個字節、192 位或者 256 位，位數越高，加密強度自然越大，但是加密的效率自然會低一些，因此要做好權衡。我們開發通常採用 128 位 16 個字節的密鑰，我們使用 AES 加密時需要主動提供密鑰，而且只需要提供一個密鑰就夠了，每個數據塊加解密使用的都是同一個密鑰。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密模式&lt;/strong&gt;：有 5 種加密模式，這些加密模式的主要目的是為了&lt;strong&gt;不讓重複的明文加密之後得到的密文一樣&lt;/strong&gt;，提升數據安全性，我們使用的是 CTR 模式（計數器模式）對數據加密，那解密的時候也需要 CTR 模式對數據解密，計數器模式介紹請參考鏈接，CTR 模式，的 iv 參數，包含了，加密塊計數（min_count），所以，每次對一個加密塊解密時，需要知道，當前加密塊的初始計數值。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.3 舉例説明跳讀流程&lt;/h3&gt; 
&lt;p&gt;學習了前面讀取加密數據的關鍵細節之後，舉個例子説明跳讀 ORC 文件流程，假設根據索引數據和查詢條件確定需要讀取某個文件中第 1 個 Strip 中第 1 列的第 5 個 group 的數據，那麼我們知道 group5 數據的偏移量 offset，文件結構如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//84f4126e46e2dcc2d4149f24ffab44c2.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具體邏輯大體流程如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//712c47a3adf74ce35e0044d5b87e8498.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：解壓數據塊時，必須把當前解壓塊的所有數據讀出來才能使用對應的解壓算法解壓數據。&lt;/p&gt; 
&lt;p&gt;1）group5 數據的偏移量 group_offset 計算出 group5 數據在哪個壓縮塊裏,計算公式為：block_index = group_offset/zipBlockSize（壓縮塊大小），並得到該壓縮塊的起始位置 zip_head_offset 公式為：zip_head_offset = block_index*zipBlockSize。&lt;/p&gt; 
&lt;p&gt;2）獲取 zip_head_offset 位置對應的加密塊計數，加密塊計數值計算公式為：min_count = zip_head_offset/encrypted-size（加密塊大小） 更新 iv 向量的 min_count 值。&lt;/p&gt; 
&lt;p&gt;3）文件讀指針定位到 zip_head_offset，開始讀取壓縮塊的數據，這個壓縮塊的數據全部讀出之後，使用解壓算法進行解壓。&lt;/p&gt; 
&lt;p&gt;4）通過 group5 在解壓的數據上偏移量和長度，讀取 group5 數據，然後再對數據進行解碼。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_22&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;六、問題解答&lt;/h1&gt; 
&lt;p&gt;通過前面對相關內容的講解，下面我們來解答前文提出的問題：&lt;/p&gt; 
&lt;p&gt;1）文件解壓是否意味着一定是對整個文件進行解壓操作？&lt;/p&gt; 
&lt;p&gt;答：不需要，文件是按照一定大小劃分出若干個壓縮塊，只要讀出相應的壓縮塊進行解壓就行。&lt;/p&gt; 
&lt;p&gt;2）ORC 文件究竟是如何做到在不掃描全文件的情況下就能精準查詢到想要的數據？&lt;/p&gt; 
&lt;p&gt;答：ORC 文件有三層索引，在讀取文件數據之前先讀取各層級的索引信息，根據過濾條件過濾掉不必要的數據掃描，從而提升數據查詢效率。&lt;/p&gt; 
&lt;p&gt;3）當 SQL 查詢條件不符合最左前綴原則時，其索引效果是否就會失效呢？&lt;/p&gt; 
&lt;p&gt;答：不會失效，ORC 文件是列式存儲的，各列信息都是相互獨立的，有自己的索引信息，與行式數據庫的索引最左前綴規則不同。&lt;/p&gt; 
&lt;p&gt;4）數據加密、解密、解壓以及壓縮之間的關聯關係到底是怎樣的？&lt;/p&gt; 
&lt;p&gt;答：請參考本文：5.1 ORC 文件內部數據加密關係，內容。&lt;/p&gt; 
&lt;p&gt;5）在寫加密列數據時，為什麼不是先加密數據再壓縮，而是先壓縮後加密？&lt;/p&gt; 
&lt;p&gt;答：主要是為了提升加密效率，數據被壓縮處理之後，數據量變少了，加密效率就提升了。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_23&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;七、總結&lt;/h1&gt; 
&lt;p&gt;本文介紹了 StarRocks 數據庫如何讀取 ORC 文件的加密數據，包括相關概念理解、ORC 文件介紹、以及 StarRocks 讀取加密 ORC 文件的具體實現方案。闡述了出於數據安全的需要，對 Hive 表中的敏感數據進行加密存儲的必要性，介紹了對稱加密、文件壓縮與解壓、加密壓縮文件讀寫流程等概念，深入探討了 ORC 文件的三層結構和索引機制，以及如何利用這些特性實現高效查詢加密數據。還詳細描述了 StarRocks 讀取加密 ORC 文件的流程，包括獲取解密的 masterKey、使用 masterKey 解密 ORC 文件中的密鑰、以及使用這些密鑰解密數據。&lt;/p&gt; 
&lt;p&gt;希望通過本文對 ORC 加密文件讀取功能的實現細節，讓讀者對 ORC 文件的理解更深刻。最後如果想從代碼層面瞭解 ORC 文件解密過程可以參考&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FStarRocks%2Fstarrocks%2Fpull%2F46809&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;開源 PR&lt;/a&gt;。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18015502</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18015502</guid>
            <pubDate>Sat, 22 Mar 2025 07:23:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>AI 產品榜最新統計數據：夸克成國內唯一月活破億 AI 應用</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 產品榜最新統計數據顯示，2025 年 2 月份中國 AI 應用中僅夸克 MAU 破億。AI 產品榜認為，中國互聯網巨頭即將拉開 AI 超級應用爭奪戰，而阿里夸克憑藉 MAU 優勢取得領先身位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;355&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a4a2edf6a5ba93c9a47715cca6b9c4c06f7.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 產品榜指出，以阿里、騰訊、字節為代表的中國互聯網巨頭紛紛將戰略重心轉向 AI，他們將重燃戰火，爭奪 AI 時代的超級應用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 13 日，阿里巴巴宣佈推出 AI 旗艦應用——新夸克。全新夸克基於阿里通義領先的推理及多模態大模型，宣佈告別傳統搜索，升級為一個 All in One 的「AI 超級框」，滿足用戶工作、學習、生活的各類 AI 需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;夸克用戶規模上的領先，很大程度上源於夸克對於產品價值的定位。阿里巴巴集團副總裁吳嘉近日在接受採訪時就指出，「夸克的核心定位還是希望成為一個服務廣大用戶的有用的 AI 產品。我們的目標始終是成為 AI 時代體驗領先的「超級入口」，讓夸克通過‘AI 超級框’重構人與信息和任務的交互方式，成為覆蓋工作、學習、生活的‘全能助手’。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;知名投資人、金沙江創投董事總經理朱嘯虎前不久也在公開場合指出，AI 應用將迎來爆發，新的超級應用將不侷限於 Chat 形態，要做成 AI 超級應用要足夠易用、有產品創新。他提到像夸克就提供了一個好思路，通過一個「AI 超級框」連接用戶與智能體。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，AIGCRank 最新一期發佈的《中國 AI 應用排行榜》亦顯示，在 2 月份的榜單中，夸克以日活用戶 3429.8 萬，連續兩個月穩居行業第一。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341335</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341335</guid>
            <pubDate>Sat, 22 Mar 2025 07:20:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>DuckDB 路線圖發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 是一個高性能的分析型關係數據庫，旨在實現高效的數據分析，由非盈利組織 DuckDB 基金會管理。它易於安裝，運行速度非常快，並且可以在進程內 (in-process) 運行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;項目團隊發佈了最新的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fstable%2Fdev%2Froadmap.html&quot; target=&quot;_blank&quot;&gt;發展路線圖&lt;/a&gt;，具體內容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Planned Features (March 2025)&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 團隊計劃在來年開發的功能：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#fafafa; color:#0d0d0d&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fextension-template-c&quot; target=&quot;_blank&quot;&gt;C extension API&lt;/a&gt;&amp;nbsp;的文檔&lt;/li&gt; 
 &lt;li&gt;Generic ODBC catalog，類似於現有的 PostgreSQL / MySQL / SQLite 集成&lt;/li&gt; 
 &lt;li&gt;支持 Go 和 Rust 擴展&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fextensions%2Ficeberg&quot; target=&quot;_blank&quot;&gt;通過 iceberg 擴展&lt;/a&gt;改進了對 iceberg 格式的支持&lt;/li&gt; 
 &lt;li&gt;用於模式匹配的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3994&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MATCH RECOGNIZE&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用緩衝區管理器緩存遠程文件內容（例如，在 S3 上查詢 Parquet 文件時）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Future Work&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;計劃在未來的某個時間點完成以下實現：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;時間序列優化&lt;/li&gt; 
 &lt;li&gt;分區感知優化&lt;/li&gt; 
 &lt;li&gt;排序感知優化&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4512&quot; target=&quot;_blank&quot;&gt;數據庫文件加密&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用自動維護的 table samples 進行更好的&amp;nbsp;Filter Cardinality Estimation&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fissues%2F14817&quot; target=&quot;_blank&quot;&gt;Parallel Python UDF&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4204&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;ALTER TABLE&lt;/code&gt;支持添加外鍵&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;查詢分析的改進（尤其是對於併發運行的查詢）&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F9547&quot; target=&quot;_blank&quot;&gt;XML 讀取支持&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3638&quot; target=&quot;_blank&quot;&gt;Materialized views&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F13396&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MERGE&lt;/code&gt;statement&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3560&quot; target=&quot;_blank&quot;&gt;支持異步 I/O&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F8104&quot; target=&quot;_blank&quot;&gt;支持 PL/SQL 存儲過程&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341325/duckdb-roadmap</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341325/duckdb-roadmap</guid>
            <pubDate>Sat, 22 Mar 2025 06:37:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Ferrous Systems 向 Rust 項目捐贈 Ferrocene 語言規範</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rust 基金會發文&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frustfoundation.org%2Fmedia%2Fferrous-systems-donates-ferrocene-language-specification-to-rust-project%2F&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;，Ferrous Systems 已同意將其 Ferrocene 語言規範 (FLS) 貢獻給 Rust 項目。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&quot;這筆慷慨的捐贈將為提供官方 Rust 規範提供更清晰的途徑。它還將使 Rust 項目能夠監督其持續發展，為已經依賴 FLS 的公司和個人提供信心，並標誌着 Rust 生態系統的一個重要里程碑。&quot;&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;245&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b43895946bbb58b8a614809fc729137ed7e.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;眾所周知，Rust 一直缺乏一份官方的語言規範。2022 年 12 月，Rust 項目提交了一份 RFC 以鼓勵 Rust 項目開始制定規範。該 RFC 於 2023 年 7 月獲得批准，並開始工作的推進。起初，Rust 項目規範團隊（t-spec）希望以 Rust Reference 為指導，從頭開始創建文檔。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但考慮到現有的一份被廣泛應用的外部 Rust 規範 -- FLS。為避免行業內存在兩種高度可見的 Rust 規範而造成的潛在混淆，t-spec 團隊決定嘗試將 FLS 與 Rust Reference 集成以創建官方 Rust 項目規範。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;FLS 是對 Rust 編程語言的描述，由 Ferrous Systems 於 2022 年 7 月開發，Ferrocene 是專為安全關鍵型和受監管行業設計的 Rust 編譯器和工具鏈。FLS 為 Rust 的語法、語義和行為提供了結構化和詳細的參考，可作為驗證、合規性和標準化工作的基礎。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在經過溝通後，Ferrous Systems 同意將其 FLS 貢獻給 Rust 項目，並允許 Rust 項目接管其開發和管理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告指出，FLS 集成到 Rust 項目會有一個過渡期。第一階段的工作將涉及將 FLS 整合到項目的工具和流程中，以符合現有的 Rust 項目目標。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「一旦集成完成，Ferrous Systems 將能夠依賴該項目的規範版本並停止使用自己的版本。更廣泛地説，這項工作將為其他需要 Rust 規範的人提供官方、權威的參考，幫助他們使用 Rust 編程語言。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</guid>
            <pubDate>Sat, 22 Mar 2025 06:27:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>