<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 25 Jul 2025 07:44:16 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Qwen3-Coder 和 Kimi-K2 均已上線模力方舟</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Kimi-K2 和 Qwen3-Coder 這兩個模型是最近在編程任務上表現不錯的開源模型，關於二者的比較可閲讀這篇文章：&lt;em&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/news/362129/kimi-k2-vs-qwen-3-coder-coding-comparison"&gt;Kimi K2 和 Qwen-3 Coder 在編程任務的詳細對比&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/360215/kimi-k2"&gt;&lt;strong&gt;Kimi K2&lt;/strong&gt;&amp;nbsp;&lt;/a&gt;是一個最先進的混合專家 (MoE) 語言模型，激活參數為 320 億，總參數為 1 萬億。通過 Muon 優化器進行訓練，Kimi K2 在前沿知識、推理和編碼任務上表現出色，同時在智能體能力方面進行了精心優化。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/361848"&gt;&lt;strong&gt;Qwen3-Coder-480B-A35B-Instruct&lt;/strong&gt;&lt;/a&gt;&amp;nbsp; 是一款專為代碼生成、代碼理解和高效開發場景設計的大型語言模型。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;模力方舟已上線這兩個模型：&lt;/p&gt; 
&lt;p&gt;&lt;img height="798" src="https://static.oschina.net/uploads/space/2025/0725/153841_vb9V_2720166.png" width="2540" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153900_equi_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;訪問網址&amp;nbsp;&lt;a href="https://ai.gitee.com/serverless-api" target="_blank"&gt;https://ai.gitee.com/serverless-api&amp;nbsp;&lt;/a&gt;即可體驗。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362345</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362345</guid>
      <pubDate>Fri, 25 Jul 2025 07:40:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌 CEO 皮查伊個人財富達 11 億美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#242424"&gt;Alphabet Inc. 本週憑藉一份重磅財報跨越了一個新的里程碑，標誌着該公司自 2023 年初以來市值增長超過 1 萬億美元的驚人增長曆程。據彭博社報道，Alphabet 在此期間為投資者帶來了 120% 的回報。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;這一飆升也使印度裔首席執行官桑達爾·皮查伊（Sundar Pichai）一躍成為億萬富翁。根據彭博億萬富翁指數，現年 53 歲的皮查伊目前的身價為 11 億美元，這主要得益於 Alphabet 的強勁增長以及多年來穩定的薪酬。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="370" src="https://oscimg.oschina.net/oscnet/up-bb4910901988674d27aa1657be7af73ddd9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;對於非公司創始 CEO 來説，這是一項罕見的成就，尤其是在科技行業，包括 Meta Platforms 的扎克伯格和英偉達的黃仁勳在內的許多高管的財富都來自於在各自公司的創始股權。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;儘管皮查伊在 1998 年穀歌創立時並不在場，但截至本月他將成為了任職時間最長的首席執行官，今年 8 月就將是他上任 10 週年。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Alphabet 股價週四一度上漲 4.1%，此前該公司公佈的第二季度業績好於預期。該公司將 2025 年的資本支出預期上調了 100 億美元，達到 850 億美元，主要用於資助人工智能基礎設施建設。「我們的人工智能基礎設施投資對於滿足雲客戶需求的增長至關重要。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span style="color:#000000"&gt;該公司還公佈研發支出增長了 16%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:start"&gt;&lt;a href="https://www.oschina.net/news/362043" target="news"&gt;谷歌母公司發佈 Q2 財報：全年資本支出飆升至 850 億美元&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362344</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362344</guid>
      <pubDate>Fri, 25 Jul 2025 07:37:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>清華大學&amp;生數科技提出可控長時文生音頻系統 FreeAudio</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;清華大學與生數科技&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FRmYYXiW0yU8Ey8BbzkYMSw" target="_blank"&gt;合作&lt;/a&gt;發表論文，提出了一種名為&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffreeaudio.github.io%2FFreeAudio%2F" target="_blank"&gt;FreeAudio&lt;/a&gt;的精準時間可控長時文生音頻系統。該系統無需額外訓練，即可基於自然語言文本和時間提示，生成超過 10 秒且時間點精確可控的音頻，突破了現有技術普遍存在的 10 秒時長限制。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153316_1wmg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://arxiv.org/abs/2507.08557&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;FreeAudio 系統利用大語言模型（LLM）對時間結構進行規劃，將複雜的文本和時間提示解析為一系列不重疊的時間窗口，併為每個窗口生成獨立的描述。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153346_YDxo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153420_m0XE_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;隨後，通過「解耦與聚合注意力控制」機制，在 DiT-based T2A 模型中引導各子段與對應描述對齊。最後，通過上下文潛變量合成、參考引導和上下文修剪與拼接等長時生成優化技術，確保音頻片段間的平滑過渡和全局一致性。在 AudioCondition 測試集上，FreeAudio 的事件級和片段級得分均排名第一，並在多項客觀和主觀評估中表現優異。&lt;/p&gt; 
&lt;p&gt;該研究成果已被計算機多媒體領域的頂級會議 ACM Multimedia 2025 錄用，並可能在未來應用於生數科技的 Vidu 產品中。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362341</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362341</guid>
      <pubDate>Fri, 25 Jul 2025 07:35:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源企業級智能體平台 MaxKB 正式發佈 v1.10.9 LTS 版本</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="color:#000000; text-align:start"&gt;2025 年 7 月 24 日，MaxKB 開源企業級智能體平台正式發佈 v1.10.9 LTS 版本。這一版本主要進行了一些問題修復工作。&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;問題修復&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;安全：修復 MCP 調用時可能存在的遠程命令執行漏洞（CVE-2025-53928）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;知識庫：修復飛書知識庫文檔在「設置」功能中修改「命中處理方式」選項時保存報錯的問題（X-Pack）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;知識庫：修復在文檔中添加、刪除、修改分段操作後，文檔列表的更新時間未同步更新的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;函數庫：修復內置的數據庫查詢函數序列化為 JSON 字符串時失敗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;問答頁面：修復通過快捷鍵複製粘貼圖片時，會覆蓋此前上傳圖片的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;問答頁面：修復 Firefox 瀏覽器無法通過拖拽方式上傳文件的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;問答頁面：修復上傳的文件名稱中含有「&lt;/span&gt;&lt;em&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt;&lt;/em&gt;&lt;span&gt;」 字符時，不顯示 URL 的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;問答頁面：修復應用名稱過長導致界面顯示錯位的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;問答頁面：修復對話記錄超過 20 條後無法展示最新提問的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;問答頁面：修復開場白中單個英文單詞被拆分顯示到兩行的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;應用：修復簡易應用未在「顯示設置」功能中勾選「顯示歷史記錄」選項時，問答頁面顯示異常的問題（X-Pack）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;應用：修復高級編排應用中，部分情況下丟失思考過程標籤的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;應用：修復對話用戶併發較多時，特殊情況下會出現數據庫文件損壞的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;應用：修復在對話日誌中自定義查詢時間後導出報錯的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;應用：修復通過 API Key 進行非流式對話時未統計 Token 消耗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;應用：修復指定回覆節點輸出的表單參數中含有特殊字符導致報錯的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;應用：修復 MCP 節點的配置信息填寫錯誤時提示信息不正確的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;應用：修復使用阿里雲百鍊的 DeepSeek-R1 模型通過 Streamable HTTP MCP 方式調用 MCP 服務時無法返回內容的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;安裝部署：修復若干已知問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;API 文檔：修復若干已知問題。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4736111/blog/18685802</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/18685802</guid>
      <pubDate>Fri, 25 Jul 2025 07:29:13 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>從 「卡頓」 到 「秒開」：外投首屏性能優化的 6 個實戰錦囊</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    
    ********************************************************************************************************************
    ********************************************************************************************************************
    ********************************************************************************************************************
    ********************************************************************************************************************
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18684649</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18684649</guid>
      <pubDate>Fri, 25 Jul 2025 07:26:13 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Anthropic 組建「AI 精神病學」團隊</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;昨日，Anthropic 神經科學研究員 Jack Lindsey &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FJack_W_Lindsey%2Fstatus%2F1948138767753326654" target="_blank"&gt;宣佈&lt;/a&gt;，公司將成立「AI 精神病學」團隊，作為其可解釋性部門的重要組成部分，旨在研究模型的角色、動機和情境意識，以及如何導致詭異、失控等行為表現，以建立對神經網絡的機制性理解並確保其安全性。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-02d75dfdeeb8071e8534839cdb867691694.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該團隊短期內重點攻克「疊加」問題（導致模型神經元和注意力頭等計算單元難以單獨解釋），並致力於將模型分解為更具可解釋性的組件。&lt;/p&gt; 
&lt;p&gt;目前，Anthropic 正在招聘研究科學家（年薪 31.5-56 萬美元，約合人民幣 220 萬-400 萬元）加入該團隊，鼓勵任何有意願的人申請，並非所有候選人需完全符合列出的資格要求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362333</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362333</guid>
      <pubDate>Fri, 25 Jul 2025 07:25:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>新起點·新徵程·新高度！禪道軟件全面升級為集團公司</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;2025 年 7 月，禪道軟件（青島）有限公司全面升級，正式更名為禪道軟件（青島）集團有限公司（&lt;strong&gt;以&lt;/strong&gt;下簡稱「禪道集團」）。&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;此次戰略升級標誌着禪道在深耕項目管理領域 16 年後，正式邁入規模化、多元化發展的全新格局，也標誌着禪道在企業規模、業務佈局和發展戰略上邁入了全新階段。&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:center"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zentao.net%2Ffile.php%3Ff%3Dzentao%2F202507%2Ff_9ddee713753c983c95c1c0405e560671%26t%3Dpng%26o%3D%26s%3D%26v%3D1753082376" target="_blank"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//7f1679fb170766fcc44a1592300e0a77.jpg" referrerpolicy="no-referrer"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;集團化升級，開創發展新高度&lt;/h2&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#39485d"&gt;禪道集團的升級，是公司戰略佈局的重要里程碑，也是對客戶價值的深度承諾。升級後的禪道集團，依託在項目管理領域的深厚積累，持續深耕項目管理領域，聚焦企業協作效率提升，通過技術創新與管理實踐的融合，讓更多企業享受數字化轉型紅利。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;聚力前行，共築項目管理新生態&lt;/h2&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#39485d"&gt;作為國內領先的項目管理軟件提供商，禪道集團始終致力於為企業提供專業、高效的項目管理解決方案。升級後的禪道集團將進一步整合資源優勢，完善旗下產品和服務生態，為廣大用戶提供更加全面、優質的項目管理服務體驗。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;不忘初心，賦能每一個成長中的企業&lt;/h2&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;升級後的禪道集團將繼續堅持自主研發與開源開放的初心，秉承「讓每一個成長中的企業都可高效協作」的使命，不斷創新產品技術，拓展業務領域，全面賦能企業智能化轉型，為推動項目管理行業發展貢獻更大力量。&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;站在新的起點，未來的禪道集團將以更開放的姿態、更專業的服務，與百萬用戶共同書寫國產項目管理新篇章！&lt;/strong&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362330</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362330</guid>
      <pubDate>Fri, 25 Jul 2025 07:23:13 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>AI 編程工具 Lovable 年收入突破 1 億美元，全面轉向 Agentic 模式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 編程工具初創公司 Lovable&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flovable.dev%2Fblog%2Fagent" target="_blank"&gt;宣佈&lt;/a&gt;其年度經常性收入（ARR）已正式突破 1 億美元，距離其實現首個 100 萬美元 ARR 僅用時 8 個月，成為全球增長最快的初創公司之一。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/151258_YWyp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前，用戶已在 Lovable 上構建了超過 1000 萬個項目，每天新增項目達 10 萬個。公司團隊現有 45 人，並在近期以 18 億美元估值完成了 2 億美元的融資。&lt;/p&gt; 
&lt;p&gt;同時，Lovable 發佈了重大的產品更新，全面轉向 Agentic 模式，並將其設為新用戶的默認體驗。新的 Agent 模式旨在更像一個真正的開發者，當接收到請求時，它會解釋需求、探索代碼庫以理解上下文、發現缺失部分、進行修改並修復出現的問題，最後提供清晰的總結，整個過程無需用戶逐步指導。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-dc15c72df0829afada2bde8461a321e6adc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據稱，這種新模式將錯誤減少了 91%。Agentic 模式還解鎖了與現實世界的集成能力，Lovable 現在可以利用外部工具執行代碼編寫之外的操作，如瀏覽網站、從 URL 獲取內容、搜索網絡信息、生成和編輯圖像、在代碼庫中搜索特定模式以及跨多個文件同步更新代碼。&lt;/p&gt; 
&lt;p&gt;隨着模式的轉變，Lovable 也轉向了基於用量的定價模型。請求的成本根據其複雜性可能低於 1 個積分或需要數個積分。&lt;/p&gt; 
&lt;p&gt;公司表示，這種模式下許多操作的成本會降低，且編輯更精確，每次交互能完成更多工作，對大多數用戶而言更實惠。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362329/lovable-agent</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362329/lovable-agent</guid>
      <pubDate>Fri, 25 Jul 2025 07:17:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 計劃於 8 月初發布 GPT-5</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2Fnotepad-microsoft-newsletter%2F712950%2Fopenai-gpt-5-model-release-date-notepad" target="_blank"&gt;據報道&lt;/a&gt;&lt;/u&gt;，OpenAI 計劃於 8 月初發布 GPT-5。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/145718_7osQ_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/145405_JoVW_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;這一備受矚目的升級版 AI 模型由 OpenAI CEO 奧特曼親自預熱，集成了 o 系列推理能力，定位為通往 AGI（通用人工智能）的關鍵一步。&lt;/p&gt; 
&lt;p&gt;奧特曼表示，他測試新模型時，GPT-5 成功解答了一封郵件中他自己都沒看懂的問題，&lt;strong&gt;讓他感受到前所未有的「無能為力」，他甚至誇張地表示「那時我靠在椅子上，心裏想：哇，這一刻終於來了……」。&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;那本來是我覺得自己應該能搞定的問題，但我卻做不到。這真的挺難受的。但 AI 就輕輕鬆鬆地完成了。那是一種很奇怪的感覺。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height="340" src="https://static.oschina.net/uploads/space/2025/0725/145818_Frtu_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;GPT-5 相關情況如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;版本信息&lt;/strong&gt;：GPT-5 將包含標準版、mini 版和僅通過 API 提供的 nano 版。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;功能特點&lt;/strong&gt;：GPT-5 將不再單獨推出 o 系列模型，而是將其推理能力內嵌其中，成為 OpenAI 整合大模型架構的重要里程碑，有望提升泛用性與一致性，為通用人工智能（AGI）奠定基礎。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;發佈時間的不確定性&lt;/strong&gt;：儘管定檔 8 月初，但消息人士透露，OpenAI 仍可能依據開發測試、安全審查甚至競品動向調整發布時間表。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/145323_0uW1_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，奧特曼此前預告的開源模型也即將上線，趕在 GPT-5 前夕，是一款類似 o3 mini 的開源語言模型。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362321/openai-gpt-5-model-release-date-notepad</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362321/openai-gpt-5-model-release-date-notepad</guid>
      <pubDate>Fri, 25 Jul 2025 06:55:13 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>浙大校友推出 AI 代碼測試神器，30 分鐘打造無 bug 網站</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;浙江大學校友團隊開發出了一款名為 TestSprite2.0 的智能測試平台，聲稱可以在 30 分鐘內創建一個全新的網站，而且全程不需要人工幹預。且 AI 生成代碼的準確率也實現了從 42% 提升至 93%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;根據介紹，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.testsprite.com%2F" target="_blank"&gt;TestSprite&lt;/a&gt; 是首個專為 AI 編程設計的測試平台，用戶只需在集成開發環境（IDE）中輸入一句簡單的命令：「使用 TestSprite 測試這個項目」。隨後，平台會自動審查項目需求文檔、描述符和代碼庫，並生成一個全面的集成測試計劃。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="389" src="https://oscimg.oschina.net/oscnet/up-dfabcc9bef641e981714d4f0a849a8180aa.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在測試過程中，TestSprite 會自動完成以下幾個步驟:生成所需的測試用例、編寫測試代碼、編譯測試腳本，並在雲端基礎設施上並行執行這些測試。最後，系統會將結構化報告反饋給開發者，清楚地指出哪些功能通過了測試，哪些存在問題。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;測試結果顯示，在使用 Trae 編寫代碼時，TestSprite 能夠自動進行測試、調試和修復錯誤，最終只用了 30 分鐘就創建出了一個無 bug 的網站。這個效率不僅讓開發團隊大大節省了時間，也幫助他們更好地聚焦於問題，迅速優化代碼。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;TestSprite2.0 引入了強大的調度和監控功能，旨在為持續測試提供保障，確保系統始終處於可發佈狀態。該平台的智能調度引擎實現了跨時區的自動化測試，實時推送 QA 預警與故障分析，有效降低了版本回退的風險。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362311</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362311</guid>
      <pubDate>Thu, 17 Jul 2025 06:18:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>財躍星辰發佈「AI 小財神 Pro」智能體</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;大模型科技公司財躍星辰宣佈推出自主研發的金融深度研究智能體產品——「AI 小財神 Pro」，具備創新性智能體框架、獨家數據與專業工具集、專屬長期記憶等核心優勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;財躍星辰由上海報業集團旗下國內領先的財經媒體和金融信息服務商界面財聯社與國內頭部通用大模型公司階躍星辰聯合成立。根據介紹，AI 小財神 Pro 基於階躍星辰 Deep Research 能力構建了一套專為複雜研究任務設計的大模型智能體框架。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="276" src="https://oscimg.oschina.net/oscnet/up-2454159c179b4fd18f6e6d5c48964d42aa8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;當用戶提出需求時，先由規劃智能體（Plan Agent）模擬研究人員的思考與行為邏輯做出規劃，將研究任務拆解為多個獨立的子任務，分發給對應的「子智能體」。隨後，多個子智能體會同步開展企業基本面分析等，互不依賴和幹擾，極大縮短了信息蒐集與分析的時間。最後，專家報告智能體會對所有子任務結果進行整合，不僅進行金融信息整理、加工、編輯與校準，確保產出內容的邏輯性與專業性，還能按照機構研報的標準生成邏輯嚴密、可讀性強的最終報告。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;這種創新架構帶來了顯著的效率提升。在實際應用中，能夠將傳統需要 5 小時完成的深度研究報告縮短至半小時內完成。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外， AI 小財神 Pro 深度融合了財聯社的獨家數據資源，並提供化繁為簡的智能繪圖工具，將枯燥的財務數據自動轉化為直觀、清晰的可視化圖表，如 K 線圖、財務比率圖、趨勢分析圖等。AI 小財神 Pro 還內置獨特的長期記憶機制，能夠主動學習並記憶用戶的個人偏好、研究習慣與特定需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;財躍星辰還同步自主研發了 FinResearchBench——一個專為金融深度研究量身打造的評測框架。在這一評測體系下， AI 小財神 Pro 的綜合得分達到 70.73，在國內所有參評產品中位列第一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在衡量數據可視化與文本內容融合能力的「圖文結合能力」（Visual-Linguistic Synergy）維度上，AI 小財神 Pro 以 70.05 分的絕對優勢高居所有參評模型（包括 Gemini、OpenAI 等國際頂尖模型）的榜首。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="138" src="https://oscimg.oschina.net/oscnet/up-45e2c4da7e4bfa54086b0ccf55ecc1f4ec8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;而在 GitHub 上公佈的外部評測榜單 FinGAIA 上，AI 小財神 Pro 也獲得了國內第一的成績。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="196" src="https://oscimg.oschina.net/oscnet/up-bcdb37d0e9f531837a0c5700e3f0e0bf499.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362303</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362303</guid>
      <pubDate>Thu, 17 Jul 2025 06:09:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌：只要 AI 內容合規，SEO 基本原則依舊適用</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;在最近舉辦的搜索中央直播會議上，谷歌的搜索專家加里・伊利斯 (Gary Illyes) 和切瑞・西瑞通・普羅馬溫 (Cherry Sireetorn Prommawin) 詳細闡述了人工智能 (AI) 如何影響谷歌搜索，並強調了 SEO (搜索引擎優化) 基本規則依舊有效。他們的觀點由谷歌產品專家鈴木健一在 LinkedIn 上分享，指出像 AI 概述和 AI 模式這樣的新 AI 功能是建立在傳統谷歌搜索的基礎設施上的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="312" src="https://static.oschina.net/uploads/space/2025/0725/113206_VdRO_4252687.jpg" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;伊利斯和普羅馬溫表示，核心系統如谷歌機器人 (Googlebot)、搜索索引和排名算法仍然在驅動 AI 搜索結果。因此，現有的 SEO 原則依然適用，沒有必要重新思考你的策略或單獨制定 「AI SEO」 策略。只要網站遵循谷歌的質量指導方針，情況就不會發生變化。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;伊利斯還強調，谷歌並不試圖區分人類生成的內容和 AI 生成的內容。關鍵在於內容是否高質量、有用和可信。如果 AI 生成的材料符合這些標準，那麼就沒有問題。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;隨着 AI 技術的發展，AI 模型現在參與了谷歌搜索的每個環節。在爬蟲階段，AI 幫助決定何時抓取網站；在索引階段，BERT 語言模型分析文本以理解其含義並過濾掉被谷歌認為低價值的頁面。同時，SpamBrain 用於檢測垃圾信息，RankBrain 用於理解新的和不尋常的搜索查詢，幫助提供相關結果，即使是谷歌以前未見過的問題。多任務統一模型 (MUM) 則將不同格式的信息 (包括文本、圖像和視頻) 整合在一起。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 概述在搜索過程的最後階段有所不同。谷歌會將用戶查詢拆解為多個聚焦的子查詢（「查詢分發」），並並行發送去探索不同角度。生成的摘要隨後經過與索引的 「基礎驗證」 過程進行核對，以減少錯誤信息的出現。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;儘管 SEO 的技術規則沒有改變，但其影響正在減小。根據最近皮尤研究中心的研究，AI 摘要出現在搜索結果中時，普通結果的點擊率下降至 8%，而沒有 AI 概述時為 15%。用戶直接點擊概述中的源鏈接的比例僅為 1%。其他研究也顯示了相同的趨勢:SEO 的技術細節沒有改變，但隨着用戶越來越依賴 AI 生成的答案，訪問外部網站的需求減少，傳統網站的曝光度和可見性也在下降。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;對於出版商、零售商和內容創作者而言，這意味着即使你可以影響聊天機器人鏈接到你的網站，但由於點擊率的急劇下降，回報的價值也變得值得懷疑。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362278</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362278</guid>
      <pubDate>Thu, 17 Jul 2025 03:40:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>螞蟻新設通用人工智能研究中心</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;雷峯網「AI 科技評論」爆料稱，螞蟻集團近日新設了通用人工智能研究中心，隸屬於螞蟻技術研究院，人員包括藍振忠、武威、吳翼、趙俊博等一眾「明星 AI 新秀」，發力 AGI 基礎技術研究。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;今年年初，就有消息稱螞蟻將設立 AGI 研究部門，不過上半年是隸屬於螞蟻集團 CTO 線，由何徵宇直接領導。這次的調整則是由 AGI 研究轉向研究院，並由藍振忠擔任中心主任，趙俊博、吳翼、武威等人向其彙報。報道稱，此舉或是旨在更聚焦 AGI 的基礎研究並強調技術創新，而非商業潛力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;藍振忠本科畢業於中山大學，後在卡內基梅隆大學（CMU）取得博士學位，研究方向涵蓋計算機視覺與多媒體分析。IT 之家從爆料中獲悉，他是谷歌的 Google Lab 前科學家，也是知名輕量化預訓練語言模型 ALBERT 的第一作者。ALBERT 是 BERT 之後的重要架構創新，在參數量上實現了驚人的壓縮：模型參數僅為 BERT 的 1/18，但在多個任務上的性能卻能達到 95% 以上甚至持平。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;2020 年，藍振忠加入西湖大學，創建「深度學習實驗室」並擔任博士生導師。他是國內第一批大模型研究科學家，早在 2022 年就率先創立「西湖心辰科技」，是國內最早探索 AIGC、AGI 等技術產業化落地的團隊，曾打造日活百萬 AIGC 應用「造夢師」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;武威本科與博士均畢業於北京大學數學科學學院。2012 年加入微軟亞洲研究院，歷任主管研究員、小冰首席科學家。隨後擔任美團 NLP 中心負責人，在語言模型與應用場景結合方面經驗豐富，現為螞蟻 AGI 中心的重要技術骨幹。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;吳翼本碩就讀於清華大學，博士階段在加州大學伯克利分校深造，師從著名 AI 學者 Stuart Russell，專注深度強化學習與多智能體系統研究。吳翼曾在 OpenAI 任職，是為數不多在硅谷核心 AI 實驗室做過一線研究的中國學者之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;趙俊博畢業於紐約大學，師從圖靈獎得主、Meta 首席科學家 Yann LeCun。曾在 Meta（原 Facebook）人工智能實驗室工作，參與 PyTorch 與向量數據庫 Faiss 的開發，並主導了 Meta 內部對話機器人相關研究。他目前也是浙江大學「百人計劃」研究員。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362273</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362273</guid>
      <pubDate>Thu, 17 Jul 2025 03:17:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>讓複雜 AI 應用構建就像搭積木：Spring AI Alibaba Graph 使用指南與源碼解讀</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;作者：羅天，懷玉，劉宏宇，劉軍&lt;/p&gt; 
&lt;h2&gt;目錄&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;引言與概述&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心架構與設計理念&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心概念深度解析&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;預定義組件與工具箱&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;高級特性與擴展能力&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;快速開始與實戰指南&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;引言與概述&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;1.1 Spring AI Alibaba Graph 概述&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 是社區核心實現之一，也是整個框架在設計理念上區別於 Spring AI 只做底層原子抽象的地方，Spring AI Alibaba 期望幫助開發者更容易的構建智能體應用。基於 Graph 開發者可以構建工作流、多智能體應用。&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 在設計理念上借鑑 LangGraph，社區在此基礎上增加了大量預置 Node、簡化了 State 定義過程等，讓開發者更容易編寫對等低代碼平台的工作流、多智能體等。&lt;/p&gt; 
&lt;h3&gt;1.2 核心特性與優勢&lt;/h3&gt; 
&lt;p&gt;相比傳統的 AI 應用開發方式，Spring AI Alibaba Graph 具有以下核心優勢：&lt;/p&gt; 
&lt;h4&gt;Java 生態深度集成&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Spring 原生支持&lt;/strong&gt;：完整的依賴注入、配置管理、監控觀測。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高併發處理&lt;/strong&gt;：Java 天然的多線程優勢，支持高併發場景。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;豐富的預置組件&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;15+ 預定義節點類型&lt;/strong&gt;：QuestionClassifierNode、LlmNode、ToolNode、KnowledgeRetrievalNode 等。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多種 Agent 模式&lt;/strong&gt;：內置 React、Reflection、Supervisor 等智能體模式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;簡化的 State 管理&lt;/strong&gt;：統一的狀態定義和合並策略。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;聲明式 API 設計&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;類似 LangGraph 的 API&lt;/strong&gt;：Java 開發者更容易上手。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;鏈式調用&lt;/strong&gt;：簡潔的流式 API，代碼更加優雅。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;條件分支&lt;/strong&gt;：支持複雜的條件邏輯和並行處理。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;生產級特性&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;觀測性支持&lt;/strong&gt;：完整的指標收集、鏈路追蹤。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;容錯機制&lt;/strong&gt;：支持檢查點、狀態恢復、錯誤處。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;人機協作&lt;/strong&gt;：Human-in-the-loop 支持，支持修改狀態、恢復執行。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;快速開始：客戶評價分類系統&lt;/h2&gt; 
&lt;p&gt;讓我們通過一個具體示例瞭解 Spring AI Alibaba Graph 的使用方式。這個示例展示瞭如何構建一個客戶評價分類系統：&lt;/p&gt; 
&lt;h3&gt;系統架構&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-f4319279c59e197905a18836855bc4b2464.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;核心代碼實現&lt;/h3&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class CustomerServiceWorkflow {

    @Bean
    public StateGraph customerServiceGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel)
            .defaultAdvisors(new SimpleLoggerAdvisor())
            .build();

        // 評價分類器 - 區分正面/負面評價
        QuestionClassifierNode feedbackClassifier = QuestionClassifierNode.builder()
            .chatClient(chatClient)
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("positive feedback", "negative feedback"))
            .build();

        // 問題細分器 - 對負面評價進行細分
        QuestionClassifierNode specificQuestionClassifier = QuestionClassifierNode.builder()
            .chatClient(chatClient)
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("after-sale service", "transportation", "product quality", "others"))
            .build();

        // 狀態工廠定義 - 簡化的狀態管理
        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("classifier_output", new ReplaceStrategy());
            strategies.put("solution", new ReplaceStrategy());
            return strategies;
        };

        // 構建工作流 - 聲明式 API
        return new StateGraph("客戶服務評價處理", stateFactory)
            .addNode("feedback_classifier", node_async(feedbackClassifier))
            .addNode("specific_question_classifier", node_async(specificQuestionClassifier))
            .addNode("recorder", node_async(new RecordingNode()))
            .addEdge(START, "feedback_classifier")
            .addConditionalEdges("feedback_classifier",
                edge_async(new FeedbackQuestionDispatcher()),
                Map.of("positive", "recorder", "negative", "specific_question_classifier"))
            .addEdge("recorder", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;以上代碼只展示了圖結構（StateGraph）的構建，具體的代碼實現你可以關注 &lt;strong&gt;spring-ai-alibaba-example&lt;/strong&gt; 倉庫：spring-ai-alibaba-example【1】。&lt;/p&gt; 
&lt;p&gt;這個示例展示了 Spring AI Alibaba Graph 的核心特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;預置組件&lt;/strong&gt;：使用 QuestionClassifierNode 快速實現分類功能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;簡化狀態管理&lt;/strong&gt;：通過 KeyStrategyFactory 統一管理狀態。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;聲明式 API&lt;/strong&gt;：鏈式調用構建複雜工作流。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Spring Boot 集成&lt;/strong&gt; ：通過 &lt;a href="https://my.oschina.net/pointdance"&gt;@Configuration&lt;/a&gt; 和 &lt;a href="https://my.oschina.net/bean"&gt;@Bean&lt;/a&gt; 完成依賴注入。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol start="2"&gt; 
 &lt;li&gt;核心架構與設計理念&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;2.1 整體數據流轉架構&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 採用工作流模型，整個框架的數據流轉遵循"構建→編譯→執行"的三階段模式：&lt;/p&gt; 
&lt;h4&gt;2.1.1 完整數據流轉圖&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8044bb577ef789fad03f0b89260211c26c7.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.1.2 核心執行流程詳解&lt;/h4&gt; 
&lt;p&gt;數據流轉的核心理念：整個框架圍繞 OverAllState 這個數據載體進行流轉，每個節點都是狀態的轉換器，通過 AsyncNodeGenerator 這個狀態機來驅動整個流程的執行。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-862e32dc74bfcdbbb3d062d0f24239917cc.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.1.3 關鍵數據結構流轉&lt;/h4&gt; 
&lt;p&gt;StateGraph → CompiledGraph 轉換：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0671a9be50153ec784ca8f6e11ba0162347.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AsyncNodeGenerator 執行機制：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1c6a5464beb66a4f3eef18a879cf98702ff.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.2 整體架構設計&lt;/h3&gt; 
&lt;p&gt;基於上述數據流轉機制，Spring AI Alibaba Graph 的整體架構設計具有以下特點：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;清晰的執行流程&lt;/strong&gt;：每個節點代表一個處理步驟，邊表示數據流向。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;靈活的條件分支&lt;/strong&gt;：支持根據狀態動態選擇執行路徑。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;並行處理能力&lt;/strong&gt;：多個節點可以並行執行，提高處理效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;狀態可追溯&lt;/strong&gt;：完整的狀態變化歷史，便於調試和監控。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;架構核心理念&lt;/strong&gt;：Spring AI Alibaba Graph 將複雜的 AI 任務分解為可組合的原子操作，每個節點專注於單一職責，通過狀態驅動的方式實現節點間的協調。這種設計讓開發者可以像搭積木一樣構建複雜的 AI 應用，既保證了系統的可維護性，又提供了足夠的靈活性。&lt;/p&gt; 
&lt;h4&gt;2.2.1 系統架構總覽&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b992e1bb969c3fc0b17dd65eb6554a6aef1.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.2.2 StateGraph 構建流程&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;StateGraph 是工作流的藍圖設計器&lt;/strong&gt;，它負責定義整個工作流的結構和執行邏輯，就像建築師繪製建築圖紙一樣。通過聲明式的 API，開發者可以輕鬆定義節點、邊和狀態管理策略，最終編譯成可執行的 CompiledGraph。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a36870845eb1c5f38fdd00194a2ee6c354c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;關鍵設計思想&lt;/strong&gt;：StateGraph 採用了"先定義後執行"的模式，將工作流的結構定義與實際執行分離，這樣可以在編譯時進行各種驗證和優化，確保運行時的穩定性和高效性。&lt;/p&gt; 
&lt;h4&gt;2.2.3 CompiledGraph 執行流程&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;CompiledGraph 是工作流的運行時引擎&lt;/strong&gt;，它將 StateGraph 的靜態定義轉換為可執行的動態流程。就像將建築圖紙變成真正的建築物一樣，CompiledGraph 負責協調各個組件的執行，管理狀態流轉，確保整個工作流按照預期運行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;AsyncNodeGenerator 是整個圖流轉執行的唯一狀態機&lt;/strong&gt;，它控制着工作流的每一步執行，包括節點調度、狀態更新、條件判斷和異常處理。這種單一狀態機的設計確保了執行的一致性和可預測性。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-93700281d0161f7006ae41c50a561496883.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心執行機制&lt;/strong&gt;：CompiledGraph 採用了基於迭代器模式的異步執行機制，每次調用 next() 方法都會推進工作流的執行，這種設計既支持同步調用，也支持流式處理，為不同的使用場景提供了靈活性。&lt;/p&gt; 
&lt;h3&gt;2.3 核心組件關係圖&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;組件職責説明&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;StateGraph&lt;/strong&gt;：工作流的架構師，負責定義整個流程的結構和規則。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;CompiledGraph&lt;/strong&gt;：工作流的指揮官，負責協調和管理整個執行過程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;OverAllState&lt;/strong&gt;：工作流的記憶中心，負責存儲和管理所有狀態數據。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;：工作流的執行單元，每個節點專注於特定的業務邏輯。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Edge&lt;/strong&gt;：工作流的連接器，定義節點之間的轉換關係和條件。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AsyncNodeGenerator&lt;/strong&gt;：工作流的執行引擎，是推動整個流程運轉的核心狀態機。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1a8ca5f21d61ad2e4cc88459e9bfe38ca01.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.4 核心設計理念&lt;/h3&gt; 
&lt;h4&gt;2.4.1 聲明式編程模型&lt;/h4&gt; 
&lt;p&gt;借鑑 LangGraph 的設計理念，Spring AI Alibaba Graph 採用聲明式編程模型，開發者只需要描述"做什麼"：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 聲明式定義工作流
StateGraph graph = new StateGraph("客戶服務工作流", stateFactory)
    .addNode("feedback_classifier", node_async(feedbackClassifier))
    .addNode("specific_question_classifier", node_async(specificQuestionClassifier))
    .addNode("recorder", node_async(recorderNode))
    .addEdge(START, "feedback_classifier")
    .addConditionalEdges("feedback_classifier", 
        edge_async(new FeedbackQuestionDispatcher()),
        Map.of("positive", "recorder", "negative", "specific_question_classifier"))
    .addEdge("recorder", END);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.4.2 狀態驅動的執行模型&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-41abdcbf09f142ffec106f9e638a1e30cf0.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;所有的數據流轉都通過 &lt;code&gt;OverAllState &lt;/code&gt;進行管理，確保狀態的一致性和可追溯性：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 狀態工廠定義
KeyStrategyFactory stateFactory = () -&amp;gt; {
    Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
    strategies.put("input", new ReplaceStrategy());
    strategies.put("classifier_output", new ReplaceStrategy());
    strategies.put("solution", new ReplaceStrategy());
    return strategies;
};
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.4.3 異步優先的設計&lt;/h4&gt; 
&lt;p&gt;框架優先支持異步處理，提高系統的吞吐量和響應性，同時還原生支持了&lt;strong&gt;節點內模型流式透傳&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-78603d91cb1abd542ef4076133cadf120a5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 異步節點定義
AsyncNodeAction asyncNode = node_async(new CustomNodeAction());

// 並行節點處理
public class ParallelNode extends Node {
    record AsyncParallelNodeAction(
        List&amp;lt;AsyncNodeActionWithConfig&amp;gt; actions,
        Map&amp;lt;String, KeyStrategy&amp;gt; channels
    ) implements AsyncNodeActionWithConfig {

        @Override
        public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
            var futures = actions.stream()
                .map(action -&amp;gt; action.apply(state, config))
                .toArray(CompletableFuture[]::new);

            return CompletableFuture.allOf(futures)
                .thenApply(v -&amp;gt; {
                    // 合併所有結果
                    Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
                    for (CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; future : futures) {
                        result.putAll(future.join());
                    }
                    return result;
                });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.5 Spring 生態集成&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 與 Spring 生態深度集成，你可以輕鬆在你的 Spring 應用中引入 AI 模型工作流以開發智能 Java 應用。&lt;/p&gt; 
&lt;h4&gt;2.5.1 依賴注入架構&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8602e6c328daa5d3ce74093335accb575bd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.5.2 依賴注入支持&lt;/h4&gt; 
&lt;p&gt;以下代碼演示了 Spring AI Alibaba Graph 是如何被 IOC 容器所管理的。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class GraphConfiguration {

    @Bean
    public StateGraph workflowGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel)
            .defaultAdvisors(new SimpleLoggerAdvisor())
            .build();

        // 構建圖定義...
        return stateGraph;
    }

    @Bean
    public CompiledGraph compiledGraph(StateGraph stateGraph, 
                                      ObservationRegistry observationRegistry) {
        return stateGraph.compile(CompileConfig.builder()
            .withLifecycleListener(new GraphObservationLifecycleListener(observationRegistry))
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.5.3 觀測性集成&lt;/h4&gt; 
&lt;p&gt;Spring AI Alibaba Graph 基於 Micrometer 內置了可觀測支持，可以無縫集成 Spring Boot 可觀測性。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
public class GraphController {

    public GraphController(@Qualifier("workflowGraph") StateGraph stateGraph,
                          ObjectProvider&amp;lt;ObservationRegistry&amp;gt; observationRegistry) {
        this.compiledGraph = stateGraph.compile(CompileConfig.builder()
            .withLifecycleListener(new GraphObservationLifecycleListener(
                observationRegistry.getIfUnique(() -&amp;gt; ObservationRegistry.NOOP)))
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="3"&gt; 
 &lt;li&gt;核心概念深度解析&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;3.1 StateGraph (狀態圖)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;StateGraph 是整個框架的設計藍圖&lt;/strong&gt;，它就像建築師的設計圖紙一樣，定義了工作流的完整結構和執行邏輯。StateGraph 採用聲明式 API，讓開發者可以用簡潔的代碼描述複雜的業務流程，而不需要關心底層的執行細節。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心設計理念&lt;/strong&gt;：StateGraph 將複雜的工作流抽象為節點和邊的組合，每個節點代表一個具體的操作，邊定義了操作之間的流轉關係。這種抽象讓開發者可以專注於業務邏輯的設計，而不是執行機制的實現。&lt;/p&gt; 
&lt;h4&gt;3.1.1 StateGraph 生命週期&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-26e2710bcff04e78bdd9f100f1b4ed03177.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.1.2 基本構造&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class StateGraph {
    // 核心數據結構
    final Nodes nodes = new Nodes();  // 存儲所有節點
    final Edges edges = new Edges();  // 存儲所有邊

    // 特殊節點常量
    public static final String END = "__END__";
    public static final String START = "__START__";
    public static final String ERROR = "__ERROR__";

    // 狀態管理
    private KeyStrategyFactory keyStrategyFactory;
    private PlainTextStateSerializer stateSerializer;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;3.1.3 節點管理流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1b5c60e1ca41dbf2f83e8baca9e68fb7ebd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;支持的節點添加方式：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 添加普通節點
public StateGraph addNode(String id, AsyncNodeAction action) {
    Node node = new Node(id, (config) -&amp;gt; AsyncNodeActionWithConfig.of(action));
    return addNode(id, node);
}

// 添加帶配置的節點
public StateGraph addNode(String id, AsyncNodeActionWithConfig actionWithConfig) {
    Node node = new Node(id, (config) -&amp;gt; actionWithConfig);
    return addNode(id, node);
}

// 添加子圖節點
public StateGraph addNode(String id, StateGraph subGraph) {
    subGraph.validateGraph(); // 先驗證子圖
    var node = new SubStateGraphNode(id, subGraph);
    return addNode(id, node);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;3.1.4 邊管理流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-3fb278877a662cf572a677630d2eb39898c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.1.5 圖驗證機制&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c090a594bcea54323db6c34775029fe7f89.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.2 OverAllState (全局狀態)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;OverAllState 是工作流的數據中樞&lt;/strong&gt;，它就像工作流的記憶系統一樣，負責在各個節點之間傳遞和管理狀態數據。OverAllState 不僅存儲數據，還定義了數據的合併策略，確保不同節點產生的數據能夠正確地整合在一起。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;設計巧思&lt;/strong&gt;：OverAllState 採用了策略模式來處理狀態更新，不同的數據類型可以採用不同的合併策略（如替換、追加、合併等），這種設計讓狀態管理變得非常靈活，能夠適應各種複雜的業務場景。&lt;/p&gt; 
&lt;h4&gt;3.2.1 狀態管理架構&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9fd248301844eb71ba85b5c3c2caaa26df2.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.2.2 狀態更新流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9ee4261e5ddb0bb06bb3ba404168df290ac.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.2.3 狀態策略詳解&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;策略模式架構&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8f44cfca5c89147a8710ea303bb8ebd6ad2.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;內置策略實現&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 替換策略 - 新值覆蓋舊值
public class ReplaceStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        return newValue;
    }
}

// 追加策略 - 新值追加到列表，支持複雜的列表操作
public class AppendStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (newValue == null) {
            return oldValue;
        }

        // 處理 Optional 類型
        if (oldValue instanceof Optional&amp;lt;?&amp;gt; oldValueOptional) {
            oldValue = oldValueOptional.orElse(null);
        }

        boolean oldValueIsList = oldValue instanceof List&amp;lt;?&amp;gt;;

        // 處理移除操作
        if (oldValueIsList &amp;amp;&amp;amp; newValue instanceof AppenderChannel.RemoveIdentifier&amp;lt;?&amp;gt;) {
            var result = new ArrayList&amp;lt;&amp;gt;((List&amp;lt;Object&amp;gt;) oldValue);
            removeFromList(result, (AppenderChannel.RemoveIdentifier) newValue);
            return unmodifiableList(result);
        }

        // 處理新值為集合的情況
        List&amp;lt;Object&amp;gt; list = null;
        if (newValue instanceof List) {
            list = new ArrayList&amp;lt;&amp;gt;((List&amp;lt;?&amp;gt;) newValue);
        } else if (newValue.getClass().isArray()) {
            list = Arrays.asList((Object[]) newValue);
        } else if (newValue instanceof Collection) {
            list = new ArrayList&amp;lt;&amp;gt;((Collection&amp;lt;?&amp;gt;) newValue);
        }

        // 合併邏輯
        if (oldValueIsList) {
            List&amp;lt;Object&amp;gt; oldList = (List&amp;lt;Object&amp;gt;) oldValue;
            if (list != null) {
                if (list.isEmpty()) {
                    return oldValue;
                }
                // 合併並去重
                var result = evaluateRemoval(oldList, list);
                return Stream.concat(result.oldValues().stream(), result.newValues().stream())
                    .distinct()
                    .collect(Collectors.toList());
            } else {
                oldList.add(newValue);
            }
            return oldList;
        } else {
            ArrayList&amp;lt;Object&amp;gt; arrayResult = new ArrayList&amp;lt;&amp;gt;();
            if (list != null) {
                arrayResult.addAll(list);
            } else {
                arrayResult.add(newValue);
            }
            return arrayResult;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;自定義策略示例&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 自定義 Map 合併策略
public class MapMergeStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (oldValue instanceof Map &amp;amp;&amp;amp; newValue instanceof Map) {
            Map&amp;lt;String, Object&amp;gt; merged = new HashMap&amp;lt;&amp;gt;((Map) oldValue);
            merged.putAll((Map) newValue);
            return merged;
        }
        return newValue; // 默認替換
    }
}

// 自定義字符串連接策略
public class StringConcatStrategy implements KeyStrategy {
    private final String separator;

    public StringConcatStrategy(String separator) {
        this.separator = separator;
    }

    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (oldValue instanceof String &amp;amp;&amp;amp; newValue instanceof String) {
            return oldValue + separator + newValue;
        }
        return newValue;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;策略工廠模式&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class StrategyFactory {

    public static KeyStrategyFactory createDefaultFactory() {
        return () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("messages", new AppendStrategy());
            strategies.put("input", new ReplaceStrategy());
            strategies.put("output", new ReplaceStrategy());
            return strategies;
        };
    }

    public static KeyStrategyFactory createCustomFactory(Map&amp;lt;String, KeyStrategy&amp;gt; customStrategies) {
        return () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            // 添加默認策略
            strategies.put("messages", new AppendStrategy());
            strategies.put("input", new ReplaceStrategy());
            // 覆蓋自定義策略
            strategies.putAll(customStrategies);
            return strategies;
        };
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3.3 Node (節點)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Node 是工作流的功能模塊&lt;/strong&gt;，每個節點就像一個專門的工作站，負責執行特定的業務邏輯。Node 的設計遵循單一職責原則，每個節點只關注一件事情，這樣既保證了代碼的可維護性，也提高了節點的可複用性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;執行特性&lt;/strong&gt;：Node 支持同步和異步兩種執行模式，還支持並行執行多個子任務。這種靈活的執行機制讓 Node 既能處理簡單的數據轉換，也能處理複雜的外部服務調用，滿足各種性能要求。&lt;/p&gt; 
&lt;h4&gt;3.3.1 節點執行流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0f32a073a0c333563e611cab19f961d7f95.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.3.2 節點類型層次結構&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a485bb79a834cbc7d6f6db17a52684b0ef4.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.3.3 並行節點處理機制&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6fd1b90acfbdc8be027db48ec175b56e697.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.4 Edge (邊)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Edge 是工作流的路由器&lt;/strong&gt;，它決定了數據在節點之間的流轉路徑。Edge 不僅僅是簡單的連接線，它還包含了複雜的條件判斷邏輯，能夠根據當前狀態動態決定下一步的執行路徑。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能路由&lt;/strong&gt;：Edge 支持靜態路由和動態路由兩種模式。靜態邊提供固定的轉換路徑，而條件邊則可以根據狀態內容進行智能判斷，這種設計讓工作流具備了強大的條件分支能力，能夠處理各種複雜的業務邏輯。&lt;/p&gt; 
&lt;h4&gt;3.4.1 邊的類型與結構&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-37f3702ab9000b7fbb0acb82335d5041701.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.4.2 條件邊路由流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0a87569b8fe010a8fdd21fd5b64b0409064.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.4.3 邊驗證機制&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class Edge {
    public void validate(Nodes nodes) throws GraphStateException {
        // 驗證源節點存在
        if (!nodes.anyMatchById(sourceId)) {
            throw Errors.missingNodeInEdgeMapping.exception(sourceId);
        }

        // 驗證目標節點
        for (EdgeValue target : targets()) {
            if (target.id() != null) {
                // 靜態邊：直接驗證目標節點
                if (!nodes.anyMatchById(target.id()) &amp;amp;&amp;amp; !END.equals(target.id())) {
                    throw Errors.missingNodeInEdgeMapping.exception(target.id());
                }
            } else if (target.value() != null) {
                // 條件邊：驗證映射中的所有目標節點
                for (String targetNodeId : target.value().mappings().values()) {
                    if (!nodes.anyMatchById(targetNodeId) &amp;amp;&amp;amp; !END.equals(targetNodeId)) {
                        throw Errors.missingNodeInEdgeMapping.exception(targetNodeId);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3.5 CompiledGraph (編譯圖)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;CompiledGraph 是工作流的執行引擎&lt;/strong&gt;，它將 StateGraph 的靜態定義轉換為高效的運行時代碼。就像將高級語言編譯成機器碼一樣，CompiledGraph 對工作流進行了各種優化，包括節點預處理、邊路由優化、狀態管理策略等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;運行時優化&lt;/strong&gt;：CompiledGraph 在編譯過程中會進行多種優化，如節點依賴分析、並行執行規劃、狀態訪問優化等，這些優化確保了工作流在運行時的高效性和穩定性。&lt;/p&gt; 
&lt;h4&gt;3.5.1 編譯過程詳解&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8f37fa869476a45f5d807052d17e6dd1b3d.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.5.2 AsyncNodeGenerator 執行機制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;AsyncNodeGenerator 是工作流執行的核心狀態機&lt;/strong&gt;，它負責推動整個工作流的運行。AsyncNodeGenerator 採用了基於迭代器的設計模式，每次調用 next() 方法都會執行一個步驟，這種設計既支持同步執行，也支持異步流式處理。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;執行控制&lt;/strong&gt;：AsyncNodeGenerator 內置了完善的執行控制機制，包括最大迭代次數檢查、中斷條件處理、錯誤恢復等，確保工作流在各種情況下都能穩定運行。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-57b304d6487ce5a1d9e7531319e3916f1cd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.5.3 狀態流轉核心邏輯&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncNodeGenerator&amp;lt;Output extends NodeOutput&amp;gt; implements AsyncGenerator&amp;lt;Output&amp;gt; {

    @Override
    public Data&amp;lt;Output&amp;gt; next() {
        try {
            // 1. 檢查最大迭代次數
            if (++iteration &amp;gt; maxIterations) {
                return Data.error(new IllegalStateException(
                    format("Maximum number of iterations (%d) reached!", maxIterations)));
            }

            // 2. 檢查是否結束
            if (nextNodeId == null &amp;amp;&amp;amp; currentNodeId == null) {
                return releaseThread().map(Data::&amp;lt;Output&amp;gt;done)
                    .orElseGet(() -&amp;gt; Data.done(currentState));
            }

            // 3. 處理 START 節點
            if (START.equals(currentNodeId)) {
                doListeners(START, null);
                var nextNodeCommand = getEntryPoint(currentState, config);
                nextNodeId = nextNodeCommand.gotoNode();
                currentState = nextNodeCommand.update();

                var cp = addCheckpoint(config, START, currentState, nextNodeId);
                var output = (cp.isPresent() &amp;amp;&amp;amp; config.streamMode() == StreamMode.SNAPSHOTS)
                    ? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);

                currentNodeId = nextNodeId;
                return Data.of(output);
            }

            // 4. 處理 END 節點
            if (END.equals(nextNodeId)) {
                nextNodeId = null;
                currentNodeId = null;
                doListeners(END, null);
                return Data.of(buildNodeOutput(END));
            }

            // 5. 檢查中斷條件
            if (shouldInterruptAfter(currentNodeId, nextNodeId)) {
                return Data.done(currentNodeId);
            }
            if (shouldInterruptBefore(nextNodeId, currentNodeId)) {
                return Data.done(currentNodeId);
            }

            // 6. 執行節點
            currentNodeId = nextNodeId;
            var action = nodes.get(currentNodeId);
            return Data.of(evaluateAction(action, overAllState));

        } catch (Exception e) {
            return Data.error(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;預定義組件與工具箱&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;4.1 預定義節點類型&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Spring AI Alibaba Graph 提供了豐富的預定義節點工具箱&lt;/strong&gt;，這些節點就像樂高積木一樣，開發者可以通過組合這些預定義節點快速構建複雜的 AI 應用。每個預定義節點都經過了精心設計和優化，不僅功能強大，而且易於使用。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;設計理念&lt;/strong&gt;：預定義節點的設計遵循了"開箱即用"的原則，開發者只需要提供必要的配置參數，就能立即使用這些節點的強大功能，大大降低了 AI 應用的開發門檻。&lt;/p&gt; 
&lt;h4&gt;4.1.1 節點分類架構&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c36ae118bcf46fbe9a86dc3e82c8e4dd136.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;4.1.2 QuestionClassifierNode - 智能分類節點&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;QuestionClassifierNode 是工作流的智能分揀員&lt;/strong&gt;，它能夠理解文本內容並將其歸類到預定義的類別中。這個節點內置了少樣本學習機制，即使沒有大量訓練數據，也能實現準確的分類效果。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心優勢&lt;/strong&gt;：QuestionClassifierNode 採用了提示工程的最佳實踐，通過精心設計的提示詞模板和少樣本示例，讓大語言模型能夠準確理解分類任務的要求，實現高質量的文本分類。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-cb2c43e28f75f6c4b0848eb194aeabff20a.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;應用場景&lt;/strong&gt;：QuestionClassifierNode 特別適合客服系統的問題分類、內容審核的類型判斷、郵件的自動分揀等場景，能夠顯著提高業務處理的自動化程度。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;QuestionClassifierNode classifier = QuestionClassifierNode.builder()
    .chatClient(chatClient)
    .inputTextKey("input")
    .outputKey("classifier_output")
    .categories(List.of("positive feedback", "negative feedback"))
    .classificationInstructions(List.of(
        "Try to understand the user's feeling when giving feedback."
    ))
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;核心實現原理：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Override
public Map&amp;lt;String, Object&amp;gt; apply(OverAllState state) throws Exception {
    // 1. 從狀態獲取輸入文本
    if (StringUtils.hasLength(inputTextKey)) {
        this.inputText = (String) state.value(inputTextKey).orElse(this.inputText);
    }

    // 2. 構建少樣本學習消息
    List&amp;lt;Message&amp;gt; messages = new ArrayList&amp;lt;&amp;gt;();
    messages.add(new UserMessage(QUESTION_CLASSIFIER_USER_PROMPT_1));
    messages.add(new AssistantMessage(QUESTION_CLASSIFIER_ASSISTANT_PROMPT_1));
    messages.add(new UserMessage(QUESTION_CLASSIFIER_USER_PROMPT_2));
    messages.add(new AssistantMessage(QUESTION_CLASSIFIER_ASSISTANT_PROMPT_2));

    // 3. 調用大模型進行分類
    ChatResponse response = chatClient.prompt()
        .system(systemPromptTemplate.render(Map.of(
            "inputText", inputText, 
            "categories", categories,
            "classificationInstructions", classificationInstructions)))
        .user(inputText)
        .messages(messages)
        .call()
        .chatResponse();

    // 4. 返回分類結果
    Map&amp;lt;String, Object&amp;gt; updatedState = new HashMap&amp;lt;&amp;gt;();
    updatedState.put(outputKey, response.getResult().getOutput().getText());
    return updatedState;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.1.3 LlmNode - 大模型調用節點&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;LlmNode 是工作流的智能大腦&lt;/strong&gt;，它封裝了與大語言模型的所有交互邏輯，讓開發者可以輕鬆地在工作流中使用 AI 的強大能力。LlmNode 不僅支持簡單的文本生成，還支持複雜的對話管理和流式輸出。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能特性&lt;/strong&gt;：LlmNode 內置了提示詞模板引擎，支持動態參數替換，還能管理完整的對話歷史，這些特性讓它能夠處理各種複雜的 AI 交互場景。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-13aa9a44b060d42bf0c7f49fb158a29fe41.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;流式處理優勢&lt;/strong&gt;：LlmNode 原生支持流式輸出，這意味着用戶可以實時看到 AI 的生成過程，而不需要等待完整的響應，大大提升了用戶體驗。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;LlmNode llmNode = LlmNode.builder()
    .chatClient(chatClient)
    .systemPromptTemplate("You are a helpful assistant.")
    .userPromptTemplate("Please process: {input}")
    .messagesKey("messages")
    .outputKey("llm_response")
    .stream(true)  // 啓用流式輸出
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;核心特性&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;模板支持&lt;/strong&gt;：支持系統提示詞和用戶提示詞模板。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;消息歷史&lt;/strong&gt;：支持消息歷史管理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;流式輸出&lt;/strong&gt;：原生支持流式處理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;參數渲染&lt;/strong&gt;：支持動態參數替換。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;4.1.4 ToolNode - 工具調用節點&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ToolNode 是工作流的萬能工具箱&lt;/strong&gt;，它讓 AI 能夠調用外部工具和 API，極大地擴展了 AI 的能力邊界。ToolNode 不僅能執行單個工具調用，還能並行執行多個工具，顯著提高了處理效率。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心價值&lt;/strong&gt;：ToolNode 將 AI 從純文本生成擴展到了實際的行動能力，讓 AI 能夠查詢數據庫、調用 API、執行計算等，真正實現了 AI Agent 的概念。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1839ec7060e57c080ada3efe2ae17df7634.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;靈活性設計&lt;/strong&gt;：ToolNode 支持各種類型的工具調用，從簡單的函數調用到複雜的 API 集成，都能輕鬆處理，這種靈活性讓 AI 應用能夠適應各種業務場景。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ToolNode toolNode = ToolNode.builder()
    .toolCallbacks(toolCallbacks)
    .llmResponseKey("llm_response")
    .outputKey("tool_response")
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;執行機制：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Override
public Map&amp;lt;String, Object&amp;gt; apply(OverAllState state) throws Exception {
    // 1. 獲取助手消息（包含工具調用）
    this.assistantMessage = (AssistantMessage) state.value(this.llmResponseKey)
        .orElseGet(() -&amp;gt; {
            List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElseThrow();
            return messages.get(messages.size() - 1);
        });

    // 2. 執行工具調用
    ToolResponseMessage toolResponseMessage = executeFunction(assistantMessage, state);

    // 3. 返回工具響應
    Map&amp;lt;String, Object&amp;gt; updatedState = new HashMap&amp;lt;&amp;gt;();
    updatedState.put("messages", toolResponseMessage);
    if (StringUtils.hasLength(this.outputKey)) {
        updatedState.put(this.outputKey, toolResponseMessage);
    }
    return updatedState;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.1.5 KnowledgeRetrievalNode - 知識檢索節點&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;KnowledgeRetrievalNode 是工作流的知識專家&lt;/strong&gt;，它能夠從龐大的知識庫中快速找到與問題相關的信息，為 AI 提供準確的背景知識。這個節點結合了向量檢索和重排序技術，確保檢索結果的準確性和相關性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;技術優勢&lt;/strong&gt;：KnowledgeRetrievalNode 採用了先進的 RAG（檢索增強生成）技術，通過向量相似度計算找到相關文檔，再通過重排序模型進一步優化結果質量，這種兩階段的設計確保了檢索的精準性。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-52f61bd24f4b307bb15eb00c5cbab458b1b.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;應用價值&lt;/strong&gt;：KnowledgeRetrievalNode 讓 AI 能夠基於企業的私有知識庫回答問題，這對於構建企業級 AI 助手、智能客服等應用具有重要意義。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;KnowledgeRetrievalNode retrievalNode = KnowledgeRetrievalNode.builder()
    .vectorStore(vectorStore)
    .userPromptKey("query")
    .topK(5)
    .similarityThreshold(0.7)
    .enableRanker(true)
    .rerankModel(rerankModel)
    .outputKey("retrieved_docs")
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;4.2 預定義 Agent 類型&lt;/h3&gt; 
&lt;h4&gt;4.2.1 ReactAgent - 反應式 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReactAgent 是工作流的智能決策者&lt;/strong&gt;，它實現了經典的 ReAct（Reasoning and Acting）模式，能夠根據當前情況動態決定是否需要調用工具。ReactAgent 就像一個有經驗的助手，知道什麼時候需要查找信息，什麼時候可以直接回答。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：ReactAgent 將推理和行動結合在一起，讓 AI 不僅能思考，還能行動。這種設計讓 AI 具備瞭解決複雜問題的能力，能夠通過多輪推理和工具調用來完成複雜任務。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-5d013d61cb33f9a717b97fd8f4455c4a025.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能循環&lt;/strong&gt;：ReactAgent 的執行過程是一個智能循環，每次循環都會評估當前狀態，決定下一步行動，這種設計讓 AI 能夠處理各種複雜和動態的任務場景。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ReactAgent reactAgent = new ReactAgent(
    "weatherAgent",
    chatClient,
    toolCallbacks,
    10  // 最大迭代次數
);

// 編譯並使用
CompiledGraph compiledGraph = reactAgent.getAndCompileGraph();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;內部圖結構構建&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private StateGraph initGraph() throws GraphStateException {
    StateGraph graph = new StateGraph(name, this.keyStrategyFactory);

    // 添加核心節點
    graph.addNode("llm", node_async(this.llmNode));
    graph.addNode("tool", node_async(this.toolNode));

    // 構建執行流程
    graph.addEdge(START, "llm")
         .addConditionalEdges("llm", edge_async(this::think),
             Map.of("continue", "tool", "end", END))
         .addEdge("tool", "llm");

    return graph;
}

// 決策邏輯
private String think(OverAllState state) {
    if (iterations &amp;gt; max_iterations) {
        return "end";
    }

    List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElseThrow();
    AssistantMessage message = (AssistantMessage) messages.get(messages.size() - 1);

    // 檢查是否有工具調用
    return message.hasToolCalls() ? "continue" : "end";
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.2.2 ReflectAgent - 反思 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReflectAgent 是工作流的質量監督者&lt;/strong&gt;，它實現了反思模式，能夠對自己的輸出進行評估和改進。ReflectAgent 就像一個嚴格的編輯，會反覆檢查和修改內容，直到達到滿意的質量標準。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;自我改進機制&lt;/strong&gt;：ReflectAgent 採用了雙節點協作的設計，一個節點負責生成內容，另一個節點負責評估質量，通過多輪迭代不斷提升輸出質量。這種設計讓 AI 具備了自我完善的能力。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-dac4641f7e3e156e5cb802a28d0ac2db271.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;質量保證&lt;/strong&gt;：ReflectAgent 特別適合對輸出質量要求較高的場景，如文檔寫作、代碼生成、創意內容等，通過反思機制確保最終輸出的質量。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ReflectAgent reflectAgent = ReflectAgent.builder()
    .graph(assistantGraphNode)      // 生成節點
    .reflection(judgeGraphNode)     // 評判節點
    .maxIterations(3)
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;執行流程詳解：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public StateGraph createReflectionGraph(NodeAction graph, NodeAction reflection, int maxIterations) {
    StateGraph stateGraph = new StateGraph(() -&amp;gt; {
        HashMap&amp;lt;String, KeyStrategy&amp;gt; keyStrategyHashMap = new HashMap&amp;lt;&amp;gt;();
        keyStrategyHashMap.put(MESSAGES, new ReplaceStrategy());
        keyStrategyHashMap.put(ITERATION_NUM, new ReplaceStrategy());
        return keyStrategyHashMap;
    })
    .addNode(GRAPH_NODE_ID, node_async(graph))
    .addNode(REFLECTION_NODE_ID, node_async(reflection))
    .addEdge(START, GRAPH_NODE_ID)
    .addConditionalEdges(GRAPH_NODE_ID, edge_async(this::graphCount),
        Map.of(REFLECTION_NODE_ID, REFLECTION_NODE_ID, END, END))
    .addConditionalEdges(REFLECTION_NODE_ID, edge_async(this::apply),
        Map.of(GRAPH_NODE_ID, GRAPH_NODE_ID, END, END));

    return stateGraph;
}

// 迭代次數檢查
private String graphCount(OverAllState state) {
    int iterationNum = state.value(ITERATION_NUM, Integer.class).orElse(0);
    state.updateState(Map.of(ITERATION_NUM, iterationNum + 1));

    return iterationNum &amp;gt;= maxIterations ? END : REFLECTION_NODE_ID;
}

// 消息類型檢查
private String apply(OverAllState state) {
    List&amp;lt;Message&amp;gt; messages = state.value(MESSAGES, List.class).orElse(new ArrayList&amp;lt;&amp;gt;());
    if (messages.isEmpty()) return END;

    Message lastMessage = messages.get(messages.size() - 1);
    return lastMessage instanceof UserMessage ? GRAPH_NODE_ID : END;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.2.3 ReactAgentWithHuman - 人機協作 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReactAgentWithHuman 是工作流的人機協作專家&lt;/strong&gt;，它在 ReactAgent 的基礎上增加了人工幹預能力，讓 AI 和人類能夠協作完成複雜任務。這種設計特別適合需要人工審核、決策確認或專業判斷的場景。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;協作機制&lt;/strong&gt;：ReactAgentWithHuman 內置了完善的中斷和恢復機制，當遇到需要人工幹預的情況時，系統會自動暫停執行，等待人工處理，然後無縫恢復執行。這種設計讓人機協作變得自然而流暢。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b1377a00599660d4661b88f5b2ba11abceb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;人機協作實現：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private StateGraph initGraph() throws GraphStateException {
    StateGraph graph = new StateGraph(name, keyStrategyFactory)
        .addNode("agent", node_async(this.llmNode))
        .addNode("human", node_async(this.humanNode))
        .addNode("tool", node_async(this.toolNode))
        .addEdge(START, "agent")
        .addEdge("agent", "human")
        .addConditionalEdges("human", edge_async(humanNode::think),
            Map.of("agent", "agent", "tool", "tool", "end", END))
        .addEdge("tool", "agent");

    return graph;
}

// HumanNode 的決策邏輯
public String think(OverAllState state) {
    // 檢查是否需要中斷
    if (shouldInterruptFunc != null &amp;amp;&amp;amp; shouldInterruptFunc.apply(state)) {
        // 設置中斷消息，等待人工處理
        state.setInterruptMessage("等待人工審批");
        return "human_interrupt";
    }

    // 檢查是否需要工具調用
    List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElse(new ArrayList&amp;lt;&amp;gt;());
    if (!messages.isEmpty()) {
        Message lastMessage = messages.get(messages.size() - 1);
        if (lastMessage instanceof AssistantMessage &amp;amp;&amp;amp; 
            ((AssistantMessage) lastMessage).hasToolCalls()) {
            return "tool";
        }
    }

    return "agent";
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="5"&gt; 
 &lt;li&gt;高級特性與擴展能力&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;5.1 可觀測性&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 提供了企業級的全鏈路觀測能力，基於 OpenTelemetry 和 Micrometer 標準，實現了從 Graph 執行到模型調用的完整追蹤。&lt;/p&gt; 
&lt;h4&gt;5.1.1 核心特性&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;全鏈路可觀測&lt;/strong&gt;：實時追蹤每個節點的輸入、輸出和狀態變化。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;流式數據採集&lt;/strong&gt;：支持異步、並行、流式節點的觀測。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;異常溯源&lt;/strong&gt;：快速定位異常節點和數據。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多平台支持&lt;/strong&gt;：兼容 Langfuse、Jaeger、Zipkin、Prometheus 等主流平台。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;5.1.2 快速接入&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;使用觀測性 Starter&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-ai-alibaba-starter-graph-observation&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

@Bean
public CompiledGraph compiledGraph(StateGraph observabilityGraph, 
                                  CompileConfig observationCompileConfig) throws GraphStateException {
    return observabilityGraph.compile(observationCompileConfig);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.1.3 詳細文檔&lt;/h4&gt; 
&lt;p&gt;關於 Spring AI Alibaba Graph 觀測性的完整架構設計、實現原理、配置方式、最佳實踐等詳細內容，請參考官方觀測性文檔：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;📚&lt;/strong&gt; &lt;strong&gt;Graph 觀測性完整指南&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 觀測性設計與實現【2】&lt;/p&gt; 
&lt;p&gt;該文檔涵蓋：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;觀測性設計理念與架構&lt;/li&gt; 
 &lt;li&gt;並行與流式觀測實現&lt;/li&gt; 
 &lt;li&gt;多平台集成配置&lt;/li&gt; 
 &lt;li&gt;Langfuse 等可視化平台使用&lt;/li&gt; 
 &lt;li&gt;最佳實踐與擴展建議&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;🔗完整示例代碼&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;graph-observability-langfuse【3】&lt;/p&gt; 
&lt;h3&gt;5.2 並行節點與流式處理&lt;/h3&gt; 
&lt;h4&gt;5.2.1 並行節點的兩種創建方式&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;Spring AI Alibaba Graph 提供了兩種創建並行節點的方式&lt;/strong&gt;，這兩種方式在底層實現上有所不同，但都能實現並行處理的效果。&lt;/p&gt; 
&lt;h5&gt;方式一：直接創建 ParallelNode&lt;/h5&gt; 
&lt;p&gt;直接創建一個 ParallelNode 實例，並將其註冊到 StateGraph 中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 創建並行任務列表
List&amp;lt;AsyncNodeActionWithConfig&amp;gt; parallelActions = List.of(
    node_async(new DataProcessingNode1()),
    node_async(new DataProcessingNode2()),
    node_async(new DataProcessingNode3())
);

// 定義狀態合併策略
Map&amp;lt;String, KeyStrategy&amp;gt; channels = Map.of(
    "results", new AppendStrategy(),
    "metadata", new ReplaceStrategy()
);

// 創建並行節點
ParallelNode parallelNode = new ParallelNode(
    "data_processing",           // 節點內部 ID  
    parallelActions,            // 並行任務列表
    channels                    // KeyStrategy 映射
);

// 添加到 StateGraph
stateGraph.addNode("parallel_tasks", parallelNode);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;方式二：通過 StateGraph 描述並行邊&lt;/h5&gt; 
&lt;p&gt;&lt;strong&gt;這是更常用的方式&lt;/strong&gt;，通過添加多個指向相同目標的邊來定義並行結構：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;StateGraph workflow = new StateGraph(keyStrategyFactory)
    .addNode("source", node_async(sourceNode))
    .addNode("task1", node_async(task1Node))
    .addNode("task2", node_async(task2Node))
    .addNode("task3", node_async(task3Node))
    .addNode("merger", node_async(mergerNode))

    // 創建並行分支 - 從 source 到多個任務
    .addEdge("source", "task1")
    .addEdge("source", "task2")
    .addEdge("source", "task3")

    // 匯聚到 merger 節點
    .addEdge("task1", "merger")
    .addEdge("task2", "merger")
    .addEdge("task3", "merger")

    .addEdge(START, "source")
    .addEdge("merger", END);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;編譯時轉換機制&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;當 StateGraph 編譯時，框架會自動檢測並行邊模式，並在內部創建 ParallelNode：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// CompiledGraph 編譯過程中的處理邏輯
if (targets.size() &amp;gt; 1) {
    // 檢測到並行邊，獲取所有並行目標節點的 Action
    var actions = parallelNodeStream.get()
        .map(target -&amp;gt; nodes.get(target.id()))
        .toList();

    // 自動創建 ParallelNode
    var parallelNode = new ParallelNode(e.sourceId(), actions, keyStrategyMap);

    // 替換原有節點和邊的映射
    nodes.put(parallelNode.id(), parallelNode.actionFactory().apply(compileConfig));
    edges.put(e.sourceId(), new EdgeValue(parallelNode.id()));
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.2.2 並行節點的內部執行機制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ParallelNode 的核心實現&lt;/strong&gt;基於 CompletableFuture.allOf()，實現真正的並行執行：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class ParallelNode extends Node {

    record AsyncParallelNodeAction(
        List&amp;lt;AsyncNodeActionWithConfig&amp;gt; actions,
        Map&amp;lt;String, KeyStrategy&amp;gt; channels
    ) implements AsyncNodeActionWithConfig {

        @Override
        public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
            Map&amp;lt;String, Object&amp;gt; partialMergedStates = new HashMap&amp;lt;&amp;gt;();
            Map&amp;lt;String, Object&amp;gt; asyncGenerators = new HashMap&amp;lt;&amp;gt;();

            // 並行執行所有 Action
            var futures = actions.stream()
                .map(action -&amp;gt; action.apply(state, config)
                    .thenApply(partialState -&amp;gt; {
                        // 分離普通結果和 AsyncGenerator
                        partialState.forEach((key, value) -&amp;gt; {
                            if (value instanceof AsyncGenerator&amp;lt;?&amp;gt; || value instanceof GeneratorSubscriber) {
                                ((List) asyncGenerators.computeIfAbsent(key, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;())).add(value);
                            } else {
                                partialMergedStates.put(key, value);
                            }
                        });
                        // 立即更新狀態
                        state.updateState(partialMergedStates);
                        return action;
                    }))
                .toList()
                .toArray(new CompletableFuture[0]);

            // 等待所有任務完成
            return CompletableFuture.allOf(futures)
                .thenApply((p) -&amp;gt; CollectionUtils.isEmpty(asyncGenerators) 
                    ? state.data() 
                    : asyncGenerators);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.2.3 並行流式處理的合併機制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;核心挑戰&lt;/strong&gt;：當多個並行分支都產生流式輸出時，如何將這些異步流合併成統一的輸出流？&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 通過 &lt;code&gt;AsyncGeneratorUtils.createMergedGenerator &lt;/code&gt;在&lt;strong&gt;框架內核中&lt;/strong&gt;解決了這個複雜問題：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-819552cef2022851091a8cde1f4c15e25af.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.2.4 MergedGenerator 核心實現&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;AsyncGeneratorUtils.createMergedGenerator&lt;/strong&gt; 是框架內核的核心算法，實現了多個異步流的智能合併：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; AsyncGenerator&amp;lt;T&amp;gt; createMergedGenerator(
    List&amp;lt;AsyncGenerator&amp;lt;T&amp;gt;&amp;gt; generators,
    Map&amp;lt;String, KeyStrategy&amp;gt; keyStrategyMap) {

    return new AsyncGenerator&amp;lt;&amp;gt;() {
        // 使用 StampedLock 優化併發性能
        private final StampedLock lock = new StampedLock();
        private AtomicInteger pollCounter = new AtomicInteger(0);
        private Map&amp;lt;String, Object&amp;gt; mergedResult = new HashMap&amp;lt;&amp;gt;();
        private final List&amp;lt;AsyncGenerator&amp;lt;T&amp;gt;&amp;gt; activeGenerators = new CopyOnWriteArrayList&amp;lt;&amp;gt;(generators);

        @Override
        public AsyncGenerator.Data&amp;lt;T&amp;gt; next() {
            while (true) {
                // 樂觀讀鎖快速檢查
                long stamp = lock.tryOptimisticRead();
                boolean empty = activeGenerators.isEmpty();
                if (!lock.validate(stamp)) {
                    stamp = lock.readLock();
                    try {
                        empty = activeGenerators.isEmpty();
                    } finally {
                        lock.unlockRead(stamp);
                    }
                }
                if (empty) {
                    return AsyncGenerator.Data.done(mergedResult);
                }

                // 輪詢策略選擇 Generator
                final AsyncGenerator&amp;lt;T&amp;gt; current;
                long writeStamp = lock.writeLock();
                try {
                    final int size = activeGenerators.size();
                    if (size == 0) return AsyncGenerator.Data.done(mergedResult);

                    int currentIdx = pollCounter.updateAndGet(i -&amp;gt; (i + 1) % size);
                    current = activeGenerators.get(currentIdx);
                } finally {
                    lock.unlockWrite(writeStamp);
                }

                // 在無鎖狀態下執行 Generator
                AsyncGenerator.Data&amp;lt;T&amp;gt; data = current.next();

                // 處理結果並更新狀態
                writeStamp = lock.writeLock();
                try {
                    if (!activeGenerators.contains(current)) {
                        continue;
                    }

                    if (data.isDone() || data.isError()) {
                        handleCompletedGenerator(current, data);
                        if (activeGenerators.isEmpty()) {
                            return AsyncGenerator.Data.done(mergedResult);
                        }
                        continue;
                    }

                    handleCompletedGenerator(current, data);
                    return data;
                } finally {
                    lock.unlockWrite(writeStamp);
                }
            }
        }

        private void handleCompletedGenerator(AsyncGenerator&amp;lt;T&amp;gt; generator, AsyncGenerator.Data&amp;lt;T&amp;gt; data) {
            // 移除完成的 Generator
            if (data.isDone() || data.isError()) {
                activeGenerators.remove(generator);
            }

            // 使用 KeyStrategy 合併結果
            data.resultValue().ifPresent(result -&amp;gt; {
                if (result instanceof Map) {
                    Map&amp;lt;String, Object&amp;gt; mapResult = (Map&amp;lt;String, Object&amp;gt;) result;
                    mergedResult = OverAllState.updateState(mergedResult, mapResult, keyStrategyMap);
                }
            });
        }
    };
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;核心算法特點&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;輪詢機制&lt;/strong&gt;：通過 pollCounter 實現公平的輪詢調度。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;StampedLock 優化&lt;/strong&gt;：使用樂觀讀鎖提高併發性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;狀態合併&lt;/strong&gt;：通過 KeyStrategy 實現靈活的狀態合併策略。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;線程安全&lt;/strong&gt;：CopyOnWriteArrayList 確保併發訪問的安全性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;5.2.5 流式輸出配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping("/stream")
public class StreamingController {

    private final CompiledGraph compiledGraph;

    @GetMapping(value = "/process", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&amp;lt;ServerSentEvent&amp;lt;String&amp;gt;&amp;gt; processStream(@RequestParam String input) {
        return Flux.create(sink -&amp;gt; {
            try {
                AsyncGenerator&amp;lt;NodeOutput&amp;gt; generator = compiledGraph.stream(
                    Map.of("input", input),
                    RunnableConfig.builder()
                        .threadId(UUID.randomUUID().toString())
                        .build()
                );

                generator.forEachAsync(output -&amp;gt; {
                    if (output instanceof StreamingOutput) {
                        StreamingOutput streamingOutput = (StreamingOutput) output;
                        String chunk = streamingOutput.chunk().toString();
                        sink.next(ServerSentEvent.builder(chunk).build());
                    }
                }).thenRun(() -&amp;gt; {
                    sink.complete();
                }).exceptionally(throwable -&amp;gt; {
                    sink.error(throwable);
                    return null;
                });

            } catch (Exception e) {
                sink.error(e);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;5.3 子圖節點&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;子圖節點是工作流的模塊化組件&lt;/strong&gt;，它允許將複雜的工作流分解為可重用的子模塊。子圖節點就像函數調用一樣，可以在主工作流中調用預定義的子工作流，實現代碼複用和模塊化設計。&lt;/p&gt; 
&lt;h4&gt;5.3.1 子圖節點類型&lt;/h4&gt; 
&lt;p&gt;Spring AI Alibaba Graph 支持兩種類型的子圖節點：&lt;/p&gt; 
&lt;h5&gt;SubStateGraphNode - 未編譯子圖節點&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;public class SubStateGraphNode extends Node {
    private final StateGraph subGraph;

    public SubStateGraphNode(String id, StateGraph subGraph) {
        super(id, (config) -&amp;gt; {
            // 在運行時編譯子圖
            CompiledGraph compiledSubGraph = subGraph.compile(config);
            return new SubGraphAction(compiledSubGraph);
        });
        this.subGraph = subGraph;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;SubCompiledGraphNode - 預編譯子圖節點&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;public class SubCompiledGraphNode extends Node {
    private final CompiledGraph subGraph;

    public SubCompiledGraphNode(String id, CompiledGraph subGraph) {
        super(id, (config) -&amp;gt; new SubGraphAction(subGraph));
        this.subGraph = subGraph;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.3.2 子圖定義與使用&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;定義文檔處理子圖&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class DocumentProcessingSubGraph {

    public static StateGraph createDocumentProcessingGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel).build();

        // 文檔提取節點
        DocumentExtractorNode extractorNode = new DocumentExtractorNode(
            "document_path", "extracted_text", List.of("pdf", "docx", "txt")
        );

        // 文檔分析節點
        LlmNode analysisNode = LlmNode.builder()
            .chatClient(chatClient)
            .systemPromptTemplate("你是一個文檔分析專家，請分析文檔內容並提取關鍵信息。")
            .userPromptTemplate("請分析以下文檔內容：\n{extracted_text}")
            .outputKey("analysis_result")
            .build();

        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("document_path", new ReplaceStrategy());
            strategies.put("extracted_text", new ReplaceStrategy());
            strategies.put("analysis_result", new ReplaceStrategy());
            return strategies;
        };

        return new StateGraph("文檔處理子圖", stateFactory)
            .addNode("extractor", node_async(extractorNode))
            .addNode("analyzer", node_async(analysisNode))
            .addEdge(START, "extractor")
            .addEdge("extractor", "analyzer")
            .addEdge("analyzer", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;在主工作流中使用子圖&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class MainWorkflowConfiguration {

    @Bean
    public StateGraph mainWorkflow(ChatModel chatModel) {
        // 創建子圖
        StateGraph documentProcessingSubGraph = DocumentProcessingSubGraph
            .createDocumentProcessingGraph(chatModel);

        // 創建其他節點
        QuestionClassifierNode classifierNode = QuestionClassifierNode.builder()
            .chatClient(ChatClient.builder(chatModel).build())
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("document_processing", "general_question"))
            .build();

        LlmNode generalAnswerNode = LlmNode.builder()
            .chatClient(ChatClient.builder(chatModel).build())
            .systemPromptTemplate("你是一個通用助手，請回答用戶的問題。")
            .userPromptTemplate("用戶問題：{input}")
            .outputKey("general_answer")
            .build();

        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("classifier_output", new ReplaceStrategy());
            strategies.put("document_path", new ReplaceStrategy());
            strategies.put("extracted_text", new ReplaceStrategy());
            strategies.put("analysis_result", new ReplaceStrategy());
            strategies.put("general_answer", new ReplaceStrategy());
            return strategies;
        };

        return new StateGraph("主工作流", stateFactory)
            .addNode("classifier", node_async(classifierNode))
            .addNode("document_processor", documentProcessingSubGraph)  // 添加子圖
            .addNode("general_answer", node_async(generalAnswerNode))
            .addEdge(START, "classifier")
            .addConditionalEdges("classifier", 
                edge_async(new ClassifierDispatcher()),
                Map.of("document_processing", "document_processor", 
                       "general_question", "general_answer"))
            .addEdge("document_processor", END)
            .addEdge("general_answer", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.3.3 子圖執行流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bb60589b6217b7b551946b05fb8c22e0214.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.3.4 子圖狀態管理&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;狀態隔離與傳遞&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class SubGraphAction implements AsyncNodeActionWithConfig {
    private final CompiledGraph subGraph;

    @Override
    public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            try {
                // 從主狀態中提取子圖需要的數據
                Map&amp;lt;String, Object&amp;gt; subGraphInput = extractSubGraphInput(state);

                // 執行子圖
                Optional&amp;lt;OverAllState&amp;gt; subGraphResult = subGraph.invoke(subGraphInput, config);

                // 將子圖結果映射回主狀態
                return mapSubGraphOutput(subGraphResult.orElse(null));

            } catch (Exception e) {
                throw new RuntimeException("子圖執行失敗", e);
            }
        });
    }

    private Map&amp;lt;String, Object&amp;gt; extractSubGraphInput(OverAllState state) {
        Map&amp;lt;String, Object&amp;gt; input = new HashMap&amp;lt;&amp;gt;();
        // 根據子圖的輸入需求提取數據
        state.value("document_path").ifPresent(value -&amp;gt; input.put("document_path", value));
        state.value("input").ifPresent(value -&amp;gt; input.put("input", value));
        return input;
    }

    private Map&amp;lt;String, Object&amp;gt; mapSubGraphOutput(OverAllState subGraphState) {
        Map&amp;lt;String, Object&amp;gt; output = new HashMap&amp;lt;&amp;gt;();
        if (subGraphState != null) {
            // 將子圖的輸出映射到主狀態
            subGraphState.value("analysis_result").ifPresent(value -&amp;gt; 
                output.put("analysis_result", value));
            subGraphState.value("extracted_text").ifPresent(value -&amp;gt; 
                output.put("extracted_text", value));
        }
        return output;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;5.4 中斷與恢復機制&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;中斷與恢復機制是工作流的容錯保障&lt;/strong&gt;，它讓工作流能夠在遇到需要人工幹預或外部條件不滿足時優雅地暫停執行，並在條件滿足後無縫恢復。這種機制對於構建可靠的企業級 AI 應用至關重要。&lt;/p&gt; 
&lt;h4&gt;5.4.1 中斷機制原理&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-87ca42d66647b36a58fa828a43d2c65a556.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.4.2 中斷條件配置&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;InterruptBefore - 節點執行前中斷&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class InterruptConfiguration {

    @Bean
    public CompiledGraph interruptableGraph(StateGraph stateGraph) {
        return stateGraph.compile(CompileConfig.builder()
            .withInterruptBefore("human_approval")  // 在 human_approval 節點前中斷
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;InterruptAfter - 節點執行後中斷&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Bean
public CompiledGraph interruptableGraph(StateGraph stateGraph) {
    return stateGraph.compile(CompileConfig.builder()
        .withInterruptAfter("data_processing")  // 在 data_processing 節點後中斷
        .build());
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;動態中斷條件&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class DynamicInterruptNode implements AsyncNodeActionWithConfig {

    @Override
    public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            // 檢查是否需要中斷
            if (shouldInterrupt(state)) {
                // 設置中斷消息
                state.setInterruptMessage("需要人工審批，請檢查數據質量");

                Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
                result.put("interrupt_reason", "data_quality_check");
                result.put("requires_approval", true);
                return result;
            }

            // 正常處理邏輯
            return processData(state);
        });
    }

    private boolean shouldInterrupt(OverAllState state) {
        // 自定義中斷條件邏輯
        Double confidence = (Double) state.value("confidence_score").orElse(1.0);
        return confidence &amp;lt; 0.8;  // 置信度低於 80% 時中斷
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.4.3 狀態快照管理&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;內存快照存儲&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Component
public class MemorySnapshotManager {

    private final Map&amp;lt;String, OverAllState&amp;gt; snapshots = new ConcurrentHashMap&amp;lt;&amp;gt;();

    public String saveSnapshot(OverAllState state) {
        String snapshotId = UUID.randomUUID().toString();
        snapshots.put(snapshotId, state.snapShot().orElse(state));
        return snapshotId;
    }

    public OverAllState loadSnapshot(String snapshotId) {
        OverAllState snapshot = snapshots.get(snapshotId);
        if (snapshot == null) {
            throw new IllegalArgumentException("快照不存在: " + snapshotId);
        }
        return snapshot;
    }

    public void removeSnapshot(String snapshotId) {
        snapshots.remove(snapshotId);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;持久化快照存儲&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Component
public class PersistentSnapshotManager {

    private final RedisTemplate&amp;lt;String, String&amp;gt; redisTemplate;
    private final ObjectMapper objectMapper;

    public String saveSnapshot(OverAllState state) {
        try {
            String snapshotId = UUID.randomUUID().toString();
            String serializedState = objectMapper.writeValueAsString(state);

            redisTemplate.opsForValue().set(
                "snapshot:" + snapshotId, 
                serializedState, 
                Duration.ofHours(24)  // 24 小時過期
            );

            return snapshotId;
        } catch (Exception e) {
            throw new RuntimeException("保存快照失敗", e);
        }
    }

    public OverAllState loadSnapshot(String snapshotId) {
        try {
            String serializedState = redisTemplate.opsForValue().get("snapshot:" + snapshotId);
            if (serializedState == null) {
                throw new IllegalArgumentException("快照不存在: " + snapshotId);
            }

            return objectMapper.readValue(serializedState, OverAllState.class);
        } catch (Exception e) {
            throw new RuntimeException("加載快照失敗", e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="6"&gt; 
 &lt;li&gt;快速開始與實戰指南&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;6.1 環境準備&lt;/h3&gt; 
&lt;h4&gt;6.1.1 依賴配置&lt;/h4&gt; 
&lt;p&gt;在你的 Spring Boot 項目中添加 Spring AI Alibaba Graph 依賴：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;spring-ai-alibaba.version&amp;gt;1.0.0.3-SNAPSHOT&amp;lt;/spring-ai-alibaba.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-ai-alibaba-starter-dashscope&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-ai-alibaba-graph-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.2 快速開始流程&lt;/h3&gt; 
&lt;h4&gt;6.2.1 創建第一個工作流&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class MyFirstGraphConfiguration {

    @Bean
    public StateGraph myFirstGraph(ChatModel chatModel) {
        // 1. 創建 ChatClient
        ChatClient chatClient = ChatClient.builder(chatModel).build();

        // 2. 定義節點
        LlmNode welcomeNode = LlmNode.builder()
            .chatClient(chatClient)
            .systemPromptTemplate("你是一個友好的助手")
            .userPromptTemplate("歡迎用戶：{input}")
            .outputKey("welcome_message")
            .build();

        // 3. 定義狀態策略
        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("welcome_message", new ReplaceStrategy());
            return strategies;
        };

        // 4. 構建工作流
        return new StateGraph("我的第一個工作流", stateFactory)
            .addNode("welcome", node_async(welcomeNode))
            .addEdge(START, "welcome")
            .addEdge("welcome", END);
    }

    @Bean
    public CompiledGraph compiledGraph(StateGraph myFirstGraph) {
        return myFirstGraph.compile();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;6.2.2 使用工作流&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
public class GraphController {

    private final CompiledGraph compiledGraph;

    @PostMapping("/chat")
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; chat(@RequestBody String input) {
        Optional&amp;lt;OverAllState&amp;gt; result = compiledGraph.invoke(Map.of("input", input));
        return ResponseEntity.ok(result.map(OverAllState::data).orElse(Map.of()));
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.3 完整示例項目&lt;/h3&gt; 
&lt;p&gt;為了幫助開發者更好地理解和使用 Spring AI Alibaba Graph，我們提供了完整的示例項目：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;📚官方示例倉庫&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;spring-ai-alibaba-graph-example【1】&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;快速體驗步驟&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. 克隆倉庫&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;git clone https://github.com/springaialibaba/spring-ai-alibaba-examples.git
cd spring-ai-alibaba-examples/spring-ai-alibaba-graph-example
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;2. 配置環境&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 設置 DashScope API Key
export AI_DASHSCOPE_API_KEY=your_api_key_here
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;3. 運行示例&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;mvn spring-boot:run
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.4 社區支持&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;技術支持&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;GitHub Issues&lt;/strong&gt; ：&lt;br&gt; 提交問題和建議【4】&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;官方文檔&lt;/strong&gt; ：&lt;br&gt; 完整文檔站點【5】&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;示例代碼&lt;/strong&gt; ：&lt;br&gt; 更多示例【6】&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;通過以上指南和完整的示例項目，你可以快速掌握 Spring AI Alibaba Graph 的使用方法，並在實際項目中高效地構建智能化應用。&lt;/p&gt; 
&lt;p&gt;【1】spring-ai-alibaba-example 倉庫&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples%2Ftree%2Fmain%2Fspring-ai-alibaba-graph-example" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples/tree/main/spring-ai-alibaba-graph-example&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【2】Spring AI Alibaba Graph 觀測性設計與實現&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.yuque.com%2Fdisaster-4qc4i%2Fxhs01z%2Fqrh6lv7m3sexgvr4" target="_blank"&gt;https://www.yuque.com/disaster-4qc4i/xhs01z/qrh6lv7m3sexgvr4&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【3】完整示例代碼&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples%2Ftree%2Fmain%2Fspring-ai-alibaba-graph-example%2Fgraph-observability-langfuse" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples/tree/main/spring-ai-alibaba-graph-example/graph-observability-langfuse&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【4】提交問題和建議&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Falibaba%2Fspring-ai-alibaba%2Fissues" target="_blank"&gt;https://github.com/alibaba/spring-ai-alibaba/issues&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【5】完整文檔站點&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava2ai.com%2F" target="_blank"&gt;https://java2ai.com/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【6】更多示例&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3874284/blog/18685786</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3874284/blog/18685786</guid>
      <pubDate>Thu, 17 Jul 2025 03:10:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>祕塔搜索 API 上線，每次查詢 3 分錢</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;祕塔&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FAKYOZfBM_Ph0OiIj_8lCeg" target="_blank"&gt;宣佈&lt;/a&gt;正式上線搜索 API，為開發者提供了在 Bing Search API 下線後的一個新選擇。&lt;/p&gt; 
&lt;p&gt;該 API 的定價為每次查詢 0.03 元，。祕塔表示，該服務基於其過去一年自建的數百億規模的多語言索引庫，該索引庫已在「祕塔 AI 搜索」產品中經受了每天千萬級的調用考驗。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/110223_NAmj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;訪問 metaso.cn，點擊首頁 「API」 按鈕，測試和接入。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;API 支持網頁、圖片、視頻、文庫等多模態搜索，並且沒有使用門檻，開發者可以即時測試和接入。除了常規搜索 API，祕塔還提供網頁全文獲取和問答接口，可按需調用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362265</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362265</guid>
      <pubDate>Thu, 17 Jul 2025 03:03:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>築牢軟件供應鏈安全屏障，鏈圖・SBOM 管理服務平台重磅來襲</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;進入數字化時代，軟件已成為支撐經濟社會正常運行的關鍵基礎設施，而隨着軟件開發模式逐步由閉源集約開發轉變為開源規模化協作，軟件供應鏈也愈發複雜多元。與此同時，漏洞缺陷、協議合規、供應鏈「投毒」等安全事件屢有發生，給軟件供應鏈安全帶來巨大挑戰。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;去年 9 月，國家工業信息安全發展研究中心依託「開源社區軟件物料清單（SBOM）平台」國家專項，牽頭建設「SBOM 標準社區」，並&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;發起&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;了「SBOM 築鏈計劃」。聚焦 SBOM 標準開源、技術突破、應用實踐、生態繁榮等方面，旨在&lt;/span&gt;提升軟件供應鏈的透明度與安全性，強化對軟件供應鏈風險的管控與治理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;7 月 24 日，由開放原子開源基金會主辦，國家工業信息安全發展研究中心、開源風險評估與治理技術實驗室聯合承辦的「2025 開放原子開源生態大會軟件物料清單（SBOM）分論壇」在北京國家會議中心二期正式召開。&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="845" src="https://oscimg.oschina.net/oscnet/up-ed2e42e5f9fb13ace71f50f03422df2ce81.png" width="1267" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;會上，&lt;strong&gt;&lt;strong&gt;國家工業信息安全發展研究中心牽頭 11 家聯合體成員單位建設的「鏈圖·SBOM 管理服務平台」正式發佈&lt;/strong&gt;&lt;/strong&gt;。該平台面向個人開發者、企業用戶、開源社區、重點行業四類用戶提供 SBOM 全生命週期管理，助力提升軟件透明度和供應鏈管理水平，防範開源代碼風險。&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="827" src="https://oscimg.oschina.net/oscnet/up-9eae602569c72746369e7da3ab9161eebed.png" width="1264" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;官方鏈接：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.csbom.cn" rel="nofollow" target="_blank"&gt;https://www.csbom.cn&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;平台核心功能，全方位保障軟件供應鏈安全&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;鏈圖·SBOM 管理服務平台提供了較為完善的 SBOM 管理功能，為保障軟件供應鏈安全提供有力支撐，涵蓋 SBOM 生成、SBOM 下載、SBOM 分享、SBOM 對比、格式轉換等功能，同時通過集成多種類型的安全檢測能力，實現 SBOM 風險分析及有效管理，提高軟件供應鏈的透明度，有助於發現潛在的安全風險及合規問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;平台支持源碼文件、包管理器配置文件、二進制格式文件、容器鏡像文件等多類型軟件格式的 SBOM 生成，生成的文件格式不僅支持《T/CQAE 19004-2025 軟件物料清單構成和要求》（BOM-SW）這一標準，還兼容 SPDX、CycloneDX、SWID 等主流格式，確保了平台的廣泛適用性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-a47d1745f3f7df56f5ea6319e7aa346ee33.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;值得一提的是，藉助平台內置的智能算法和規則引擎，用戶只需一鍵操作，就能快速獲得一份詳細且準確的 SBOM 文件，提高了工作效率，同時也保證了文件質量，為後續的軟件供應鏈安全管理奠定了堅實基礎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="406" src="https://oscimg.oschina.net/oscnet/up-427ba61fe6e92232b96a2c1fe73162c8c0c.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;BOM-SW 標準結構圖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在軟件管理過程中，文件分享又是必不可少的。平台的 SBOM 分享功能既靈活又安全。用戶選中文件點擊分享後，可根據需求設置分享信息，通過鏈接分享給特定用戶，並能設置驗證碼和時效。這一設計在確保信息順利傳遞的同時，又為用戶提供了便利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-e518ce71cc2e5becd87860d3d134243d72c.png" width="546" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;因格式不兼容，在軟件物料清單交互時帶來的不便，平台的 SBOM 轉換功能也相應給出瞭解決方案。根據交互需求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;平台支持 SBOM 文件的格式在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;BOM-SW、SPDX、CycloneDX、SWID 標準&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;之間相互轉換，並且在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;轉換過程中嚴格保證數據的完整性和準確性，確保軟件物料清單信息不丟失，為跨系統、跨組織的軟件供應鏈安全管理提供了支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="196" src="https://oscimg.oschina.net/oscnet/up-b3132918e81f33ee4454103df0d8549003b.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在軟件的開發、更新迭代過程中，SBOM 對比功能同樣發揮着重要作用。用戶只需要在平台選擇兩份需要對比的 SBOM 文件，平台就能迅速分析並直觀呈現出對比結果，如組件的增減、版本差異、許可證變動等關鍵信息。用戶可通過 SBOM 對比功能快速把握軟件物料清單的變化，為軟件升級、整合等決策提供可靠依據，避免因軟件變動引發的安全問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="265" src="https://oscimg.oschina.net/oscnet/up-0f21c1b68eb57c42b397f051d120cdce314.png" width="552" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;個性化服務，滿足多元安全需求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;針對不同用戶在軟件供應鏈安全管理方面有着不同的需求，鏈圖·SBOM 管理服務平台為個人用戶、企業用戶、行業用戶及開源社區用戶分別提供了個性化服務。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、個人用戶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;個人用戶登錄平台後，會看到簡潔明瞭且功能豐富的 SBOM 總覽頁面，進行中的項目、SBOM 數量、組件數量、許可證數量，及平台工具等關鍵信息一目瞭然。側邊欄還擁有一個「快速使用」的入口，涵蓋常用的 SBOM 管理操作，極大簡化了操作流程，降低了使用門檻，讓個人用戶也能輕鬆管理軟件安全事務。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="268" src="https://oscimg.oschina.net/oscnet/up-12f4e07c9de6b6aa624ada76967e105d897.png" width="548" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、企業用戶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;企業用戶增設專屬的總覽頁面，呈現企業層面更為全面的數據視圖。企業管理者可以查看項目數量、SBOM 數量、格式及類型分佈、組件許可證使用情況和風險情況等。通過這些數據，管理者能從全局視角把握企業軟件供應鏈的整體狀況，為戰略決策提供數據支撐，合理調配資源，優化風險管理策略，確保企業軟件供應鏈的穩健運營。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="303" src="https://oscimg.oschina.net/oscnet/up-a3c718e765b3bad397e1c5d3860c77d9b28.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、行業用戶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;行業用戶在平台的後台監測大屏上則可以快速查看整個行業的 SBOM 管理情況概覽。平台以直觀的統計圖表和關鍵數據指標，呈現行業內軟件物料清單的分佈、風險水平和合規狀況等重要信息，為制定行業政策、規範行業標準提供有力依據。同時，行業用戶還能深入查看單個企業的詳細情況，實現精準監管，保障行業軟件供應鏈的安全與合規。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="362" src="https://oscimg.oschina.net/oscnet/up-853841a6f01ec94fdf7d1a8a0bec84dacf9.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、開源社區用戶&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;開源社區用戶在平台上擁有便捷的使用體驗。他們可以通過授權第三方社區賬號權限直接登錄，開啓分享功能後能將 SBOM 信息在社區內高效傳播。平台與開源社區通過插件集成實現深度融合，社區用戶在社區界面就能進行 SBOM 上傳、下載等操作，優化了操作體驗，促進了開源生態的協同發展，讓開源社區的軟件安全管理更加高效。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-e044c8efb12389bc4a5ac467f99a28d8c55.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此前，開源中國 Gitee 平台積極響應國家戰略，已上線鏈圖·SBOM 管理服務平台相關服務並試運行。在此期間，Gitee 上已有超過 350 家企業試用了鏈圖·SBOM 管理服務平台，而在開源社區層面，也有超 40 家開源社區試用，生成 SBOM 文件數量超 1000 份。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;除此之外，鏈圖·SBOM 管理服務平台還為各類型用戶提供了一個「工具市場」，例如：容器鏡像成分分析工具、開源代碼自動化巡檢工具、許可證合規分析工具原型、二進制文件安全驗證工具等，以支持不同使用場景下的工具調用，在使用者無需跨平台調用工具的同時，也保證了賬號的數據安全，進一步為軟件供應鏈安全護航。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-4076142b6b7c6e007b5e27eeb7a0f290d2b.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;未來展望，持續守護軟件安全&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;鏈圖·SBOM 管理服務平台後續將為開源社區等組織提供軟件資產管理、漏洞感知、鏈路追溯等一系列服務。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通過這些服務，平台能夠及時掌握產業發展動態及安全威脅，為相關單位提供決策支撐，有效保障開源供應鏈安全，助力軟件產業高質量發展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;未來，國家工業信息安全發展研究中心依託「築鏈計劃」深化與業界各方的交流合作，持續加強標準應用、工具測評、平台推廣等方面創新和實踐，進一步完善軟件供應鏈安全體系，護航我國開源軟件高質量發展，為數字化時代的安全發展保駕護航！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4806939/blog/18685839</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4806939/blog/18685839</guid>
      <pubDate>Thu, 17 Jul 2025 03:00:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>智譜即將發佈 GLM-4.5 系列模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智譜 AI 即將發佈其 GLM-4.5 系列模型，預計將包括一個 106B 和一個 355B 的大模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/105226_VfFm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;從 vLLM 和 modelscope/ms-swift 代碼庫中的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmodelscope%2Fms-swift%2Fcommit%2Fa26c6a1369f42cfbd1affa6f92af2514ce1a29e7" target="_blank"&gt;提交記錄&lt;/a&gt;可以看到，此次發佈預計將包括兩個型號：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;名為 GLM-4.5-Air 的 106B-A12B 模型&lt;/li&gt; 
 &lt;li&gt;名為 GLM-4.5 的 355B-A32B 模型。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;智譜在 2025 年 4 月 15 日發佈 GLM-4-32B/9B 系列開源模型（含基座、推理、沉思三類模型），並在 7 月 2 日開源了 GLM-4.1V-Thinking 視覺語言模型。此外，智譜在 2024 年 ICLR 大會上曾提出 GLM-4.5 及後續升級模型的技術方向，強調將基於 「超級認知」 和 「超級對齊」 技術，構建原生多模態大模型，並推動 GLM-OS（以大模型為中心的通用計算系統）的發展 。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362260</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362260</guid>
      <pubDate>Thu, 17 Jul 2025 02:54:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>字節 Agent 產品釦子空間上線網頁設計功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;字節系 Agent 產品釦子空間&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(Coze Space)&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;宣佈正式推出其網頁設計功能，5 分鐘即可完成一個網頁設計。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;用戶可打開釦子空間網站 (&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fcoze.cn" target="_blank"&gt;coze.cn&lt;/a&gt;&lt;span style="color:#000000"&gt;)，點擊「網頁」標籤，然後在對話框中輸入具體的設計需求，系統即可自動生成一個符合用戶描述的網頁。例如，用戶可以要求生成一個現代、響應式的招聘網站，指定主題色、背景色、佈局風格等細節，釦子空間能夠在短時間內生成一個完整的網站，並提供實時預覽。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="273" src="https://oscimg.oschina.net/oscnet/up-7add01b828e3be5ec8bdbdd6ee694594fbd.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;這一功能不僅支持自然語言輸入，還允許用戶通過點擊元素進行二次編輯，調整細節，如顏色、佈局等。此外，釦子空間還支持上傳參考圖片，無論是截圖、Figma 設計稿、網站鏈接還是手繪稿，系統都能一鍵復刻，實現 1:1 還原設計。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;釦子空間的網頁設計功能適用於多種場景，包括活動營銷頁面、機構主頁、個人主頁、生活網頁和前端工具等。用戶可以根據不同的需求，輸入相應的指令公式，生成符合特定場景的網頁。例如，用戶可以生成一個專注於北極探險的旅遊預訂頁面，或者一個創意設計工作室的官方網站，甚至是一個個人技術簡歷網站。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362259</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362259</guid>
      <pubDate>Thu, 17 Jul 2025 02:51:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>從 Workflow 到 Agent：構建自己的自主智能體</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;「自主智能體」正從論文熱詞變成真實生產力，相較於傳統 Workflow 只能按圖索驥，自主智能體把方向盤直接交給大模型，讓它在動態、開放、甚至不可收斂的問題裏自由馳騁。&lt;/p&gt; 
&lt;p&gt;可一旦落地，排隊時間長、環境隔離難、幻覺失控、工具對接碎片化……每一道都是現實的高牆。&lt;/p&gt; 
&lt;p&gt;網易 CodeWave 技術負責人姜天意和其團隊正在探索從如何讓自主智能能通過各種技術達成最佳實踐。&lt;/p&gt; 
&lt;p&gt;本週六，姜天意也將出席【Al Agent：從工具助手到自主行動】OSC 源創會・杭州站活動，並發表《從 Workflow 到 Agent：構建自己的自主智能體》主題演講，從網易自研自主智能體平台 CoreAgent 出發，講解如何通過自主 Agent，MCP 協議，運行沙箱，長短記憶管理等技術構建一個自主智能體產品。&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;即刻報名：&lt;/span&gt;&lt;a href="https://www.oschina.net/event/8597955"&gt;https://www.oschina.net/event/8597955&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1440" src="https://oscimg.oschina.net/oscnet/up-d11d0a649fa2a9c9416a212f5addcdeb230.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：「自主智能體」這個概念近來非常火爆，在您看來，「自主智能體」區別於傳統「Workflow 自動化」最核心的、革命性的特質是什麼？它帶來了哪些之前難以實現的場景可能性？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;Workflow 則是按照預設去完成標準化、重複性的任務，是很死板的，完全依賴預設的流程。自主智能體主要是交給大模型自主完成複雜，動態的目標，解決個性化，不收斂的問題。所以你像編程方面的 Code Agent，科研方面的 DeepResearch，甚至説你在日常遇到的比如旅遊路線推薦，幫我分析下 Excel 做總結等，均是 WorkFlow 智能體非常難以實現的。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：網易自研的 CoreAgent 平台在解決當前主流的 Agent 框架面臨的哪些關鍵挑戰上有獨特的優勢？它的核心設計哲學是什麼？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;其實像 Manus 這類自主智能體的創業公司，他們產品體驗時最常出現的一個問題是排隊、執行時間長。為什麼會有這個問題呢，因為自主智能體在每個實例運行時，都需要動態去分配一個虛擬化的運行容器，還要有容器的生命週期管理的機制，心跳等等。這一類產品在容器的動態擴縮容，資源複用，啓動加速等其實比較難有積累。網易這邊之前做過很多雲原生項目的積累，對容器、沙箱管理、資源加載等都比較擅長。同時因為我們團隊長期做一些智能開發產品，對 Code Agent、數據分析 Agent 等場景非常熟悉，也能夠針對性地對任務調優，這也是我們的優勢。還有一點由於我們做過很多 toB 項目，在 toB 裏自主智能體他並不一定是一個全發散的場景也會有一定收斂，所以我們設計了一個機制叫最佳實踐，用戶可以每次跑自主智能體都積累這個最佳實踐並針對性修正，下次跑的時候可以召回參考，同時也可以作為全局的經驗供其他類似場景的自主智能體參考，這樣會越跑越準確。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：能否簡要透露一下 MCP 協議主要解決了自主 Agent 協同中的哪些核心問題？而「運行沙箱」對於 Agent 的可靠性和安全性起到了怎樣的保障作用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;其實原先 OpenAI 通過 Function Calling 提供了類似工具使用的能力。MCP 協議最重要的是提供了一個標準化的萬物互聯的協議，我們認為他是 Function Calling 的標準實現，對於工具提供商再也不需要寫那麼多不同種類的 SDK 給外面用了，統一暴露 MCP 服務即可，對於模型應用開發者，調用工具更簡單更穩定，不需要通過像 Prompt 工程來約束 LLM 的返回，也不需要做複雜的參數解析等。這樣極大地擴展了 LLM 的上限。&lt;/p&gt; 
&lt;p&gt;運行時沙箱主要提供了硬件級別的隔離，因為自主智能體他操作的能力很多，包括電腦的，代碼的，環境的瀏覽器的，很容易影響到運行環境。因此通過沙箱可以有效的做環境的隔離。同時自主智能體經常是長尾需求，也能通過沙箱及時回收資源降低資源佔用。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：在構建和落地像 CoreAgent 這樣的自主智能體平台過程中，您認為面臨的最大技術挑戰或工程挑戰是什麼？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;最大的技術挑戰有兩個&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;保證智能體運行的穩定，避免幻覺。在工程上我們做了很多兜底，比如對工具使用的、返回結果的約束，運行過程中的優化等，同時我們也通過像最佳實踐、知識召回的能力來約束智能體的行為，讓他儘可能反思&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;對沙箱環境的管理和穩定性等，包括沙箱生命週期的管理、沙箱的存活時間、沙箱跟外界的通信，沙箱環境啓動速度的加快和預熱等&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：您認為「自主智能體」從技術概念走向大規模實際應用，最迫切需要跨越的門檻是什麼？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;主要還是依賴模型能力的提升和周邊 MCP 能力的建設。自主智能體對模型的 Plan 能力和 MCP 支持，要求非常高，目前我們測試下來可能只有 Claude 能夠達到較好的效果。同時我們發現在公司內部落地的時候，很多工具平台都缺少 MCP 服務，對接困難，所以都會有個打磨的過程。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;問：對於想要開始在自己的項目中嘗試構建或集成「自主智能體」能力的開發者/工程師，您有什麼最重要的建議或關鍵考量？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;自主智能體雖然以開放性任務為主，但還是要在任務過程中做好足夠的幹預，避免跑偏。可以在跑完後進行最佳實踐的修正&lt;/p&gt; 
&lt;p&gt;同時要注意提供足夠的工具來完成任務，對接該工具的 MCP 服務。比如跑的過程中要發消息之類，就需要提前先把這個消息工具準備好。&lt;/p&gt; 
&lt;p&gt;&lt;img height="6021" src="https://oscimg.oschina.net/oscnet/up-4f94d78edf59b79e2169b9509b4d9e02a2e.png" width="1800" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4489239/blog/18685831</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/18685831</guid>
      <pubDate>Thu, 17 Jul 2025 02:44:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>阿里通義千問推出機器翻譯模型 Qwen-MT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里雲通義千問 Qwen 團隊發文宣佈推出機器翻譯模型 Qwen-MT，基於 Qwen3 模型打造，進一步使用超大規模多語言和翻譯數據對模型進行訓練，全面增強其多語言理解與翻譯能力，並結合強化學習技術，顯著提升了翻譯結果的準確性與語言流暢度。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;核心亮點包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;92 種語言互譯 ：支持超過 92 種主流官方語言及重要方言之間的高質量互譯，覆蓋全球 95% 以上的人口，滿足廣泛的語言交流需求。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;高度可控性：提供術語幹預、領域提示、記憶庫等專業翻譯功能，並支持用戶自定義提示，有效提升模型在複雜、專業或特定應用場景下的翻譯表現。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;低延遲、低成本：採用輕量級 MoE（Mixture of Experts）架構，在保證卓越性能的同時實現更快的響應速度和更低的 API 調用價格（每百萬輸出 token 低至 2 元），更適合高併發、實時性要求高的應用場景。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告稱，在中英、英德多領域翻譯以及 WMT24 多語言翻譯任務中，Qwen-MT 顯著優於同規模模型，如 GPT-4.1-mini、Gemini-2.5-Flash 和 Qwen3-8B。甚至與 GPT-4.1、Gemini-2.5-Pro、Qwen3-235B-A22B 等頂級大模型相比，翻譯效果依然毫不遜色。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="292" src="https://oscimg.oschina.net/oscnet/up-e8768779345866a736fcf524d45915410a8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;人工評估結果也表明，&lt;span style="color:#000000"&gt;在合格率、優良率上，Qwen-MT 均展現出顯著優勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-4ce65be0c17a1234532e45315784dd1cf8d.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-b94159e883c125cebe49827b6b92ede7c3a.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;更多詳情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2LQIrsaBgXcxw76BYshfdw" target="_blank"&gt;查看官方公告&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362251</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362251</guid>
      <pubDate>Thu, 17 Jul 2025 02:21:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
