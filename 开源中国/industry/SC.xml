<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 28 Aug 2025 07:40:42 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>IDC 全球 ICT 市场预测：AI 算力驱动未来五年 7.6 万亿美元市场</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;国际数据公司（IDC）发布了&lt;span&gt;最新&lt;/span&gt;的《全球 ICT 支出指南:行业与企业规模》。根据 IDC 的预测，到 2025 年，全球信息和通信技术 (ICT) 市场总投资规模将接近 5.9 万亿美元，并预计在 2029 年增至 7.6 万亿美元，五年复合增长率 (CAGR) 为 7.0%。特别是在中国，预计到 2029 年，市场规模将接近 8894.3 亿美元，同样保持 7.0% 的复合增长率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="380" src="https://oscimg.oschina.net/oscnet/up-ec3411c02528d7031bf6d5f495b813246aa.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;报告指出，中国的企业级 ICT 市场将在 2025 年达到 3147 亿美元，较 2024 年增长 14.3%，这个增长速度将持续高于 GDP 增速。从 2025 年开始，中国企业级 ICT 市场的年均增长率将达到 12.2%。在这一过程中，人工智能及算力的部署成为了市场增长的重要驱动力。生成式人工智能对算力的需求显著增加，推动了服务器市场的迅速发展。IDC 预测，2024 至 2029 年期间，中国企业级服务器和存储投资的年均复合增长率将达到 21.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，随着国产芯片的不断进步，未来算力的发展将会获得更多市场机遇。同时，人工智能技术正在逐步渗透至各个行业，推动了公有云基础设施即服务（IaaS）市场的快速增长。根据 IDC 的数据，中国 IaaS 支出的年均复合增长率将达到 14.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在国际市场方面，国内云服务厂商正在积极拓展海外市场，尤其是在云与人工智能结合的产品及服务领域。越来越多的云服务企业开始加快布局，积极输出在国内市场积累的经验和技术。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;从技术维度来看，IDC 对市场进行了详细的细分，涵盖了五大技术领域和 120 个细分技术。这些技术的广泛应用为中国企业级 ICT 市场的发展提供了广阔的前景。报告指出，硬件市场支出仍然&lt;span&gt;最大&lt;/span&gt;，预计到 2029 年将超过 2495.5 亿美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在软件和信息服务领域，随着企业数字化转型的加速，相关需求不断增长，预计到 2029 年，企业级软件市场将达到 1506.5 亿美元。教育行业也在积极探索 AI 应用，促进了市场的快速发展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368974</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368974</guid>
      <pubDate>Thu, 28 Aug 2025 07:39:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>可扩展系统设计的黄金法则与 Go 语言实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、&amp;nbsp;引言：为什么需要可扩展的系统？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在软件开发领域，需求变更如同家常便饭。一个缺乏扩展性的系统，往往在面对新功能需求或业务调整时，陷入「改一行代码，崩整个系统」的困境。可扩展性设计的核心目标是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;让系统能够以最小的修改成本，适应未来的变化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。对于 Go 语言开发者而言，利用其接口、并发、组合等特性，可以高效构建出适应业务演进的系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;本文将从架构设计原则、编码实践、架构实现模式、验证指标到演进路线，系统讲解如何设计一个「生长型」系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、可扩展系统的核心设计原则&lt;/h1&gt; 
&lt;p style="text-align:center"&gt;&lt;strong&gt;2.1&amp;nbsp; 开闭原则：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;对扩展开放，对修改关闭&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;开闭原则是面向对象设计的基石之一。它要求系统中的模块、类或函数，应该对扩展新功能保持开放，而对修改现有代码保持关闭。这意味着，当需求变更时，我们应通过添加新代码（如新增实现类）来满足需求，而不是修改已有的代码逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过接口（Interface）和组合（Composition）特性，天然支持开闭原则。接口定义了稳定的契约，具体实现可以独立变化；组合则允许通过「搭积木」的方式扩展功能，而无需修改原有结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：数据源扩展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设我们需要支持从不同数据源（如 MySQL、S3）读取数据，核心逻辑是「读取数据」，而具体数据源的实现可能频繁变化。此时，我们可以通过接口定义稳定的读取契约：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// DataSource 定义数据读取的稳定接口（契约）
type&amp;nbsp;DataSource&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Read(p []byte) (n&amp;nbsp;int, err&amp;nbsp;error) &amp;nbsp;// 读取数据到缓冲区
&amp;nbsp; &amp;nbsp; Close()&amp;nbsp;error&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 关闭数据源
}


// MySQLDataSource 具体实现：MySQL 数据源
type&amp;nbsp;MySQLDataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; db *sql.DB &amp;nbsp;// 依赖 MySQL 连接
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 实现 MySQL 数据读取逻辑（如执行查询、填充缓冲区）
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.QueryRow("SELECT data FROM table").Scan(&amp;amp;p)
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.Close() &amp;nbsp;// 关闭数据库连接
}


// S3DataSource 新增实现：S3 数据源（无需修改原有代码）
type&amp;nbsp;S3DataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *s3.Client &amp;nbsp;// 依赖 AWS S3 客户端
&amp;nbsp; &amp;nbsp; bucket&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 存储桶名
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 实现 S3 数据读取逻辑（如下载对象到缓冲区）
&amp;nbsp; &amp;nbsp; obj, err := s.client.GetObject(context.Background(), &amp;amp;s3.GetObjectInput{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Bucket: aws.String(s.bucket),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp;aws.String("data.txt"),
&amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;obj.Body.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;obj.Body.Read(p) &amp;nbsp;// 读取数据到缓冲区
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 客户端通常无需显式关闭，可根据需要实现
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;接口定义了所有数据源必须实现的方法（&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Read&lt;/span&gt;&lt;/span&gt;和&amp;nbsp;&lt;span style="background-color:#e5e5e5"&gt;Close&lt;/span&gt;），这是系统的「稳定契约」。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;当需要新增数据源（如 S3）时，只需实现该接口，无需修改现有的 MySQL 数据源或其他依赖&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;的代码。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;这一设计符合开闭原则：系统对扩展（新增 S3 数据源）开放，对修改（无需改动现有代码）关闭。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;2.2 模块化设计：低耦合、高内聚&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模块化设计的核心是将系统拆分为独立的功能模块，模块之间通过明确的接口交互。衡量模块化质量的关键指标是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;耦合度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块之间的依赖程度（越低越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;内聚度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块内部功能的相关性（越高越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理想情况下，模块应满足「高内聚、低耦合」：模块内部功能高度相关（如订单处理模块仅处理订单相关逻辑），模块之间通过接口通信（如订单模块通过接口调用支付模块，而非直接依赖支付模块的实现）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过包（Package）管理模块边界，通过接口隔离依赖。开发者可以通过以下方式提升模块化质量：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;单一职责原则&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：每个模块/包仅负责单一功能（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包处理订单逻辑，&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包处理支付逻辑）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;接口隔离&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块间通过小而精的接口交互，避免暴露内部实现细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：订单模块的模块化设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// order/order.go：订单核心逻辑（高内聚）
package&amp;nbsp;order


// Order 表示一个订单（核心数据结构）
type&amp;nbsp;Order&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ID &amp;nbsp; &amp;nbsp;&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Items &amp;nbsp;[]Item
&amp;nbsp; &amp;nbsp; Status OrderStatus
}


// Item 表示订单中的商品项
type&amp;nbsp;Item&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ProductID&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Quantity &amp;nbsp;int
&amp;nbsp; &amp;nbsp; Price &amp;nbsp; &amp;nbsp;&amp;nbsp;float64
}


// OrderStatus 订单状态枚举
type&amp;nbsp;OrderStatus&amp;nbsp;string


const&amp;nbsp;(
&amp;nbsp; &amp;nbsp; OrderStatusCreated &amp;nbsp;OrderStatus =&amp;nbsp;"created"
&amp;nbsp; &amp;nbsp; OrderStatusPaid &amp;nbsp; &amp;nbsp; OrderStatus =&amp;nbsp;"paid"
&amp;nbsp; &amp;nbsp; OrderStatusShipped &amp;nbsp;OrderStatus =&amp;nbsp;"shipped"
)


// CalculateTotal 计算订单总金额（核心业务逻辑，无外部依赖）
func&amp;nbsp;(o *Order)&amp;nbsp;CalculateTotal()&amp;nbsp;float64&amp;nbsp;{
&amp;nbsp; &amp;nbsp; total :=&amp;nbsp;0.0
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, item :=&amp;nbsp;range&amp;nbsp;o.Items {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; total += item.Price *&amp;nbsp;float64(item.Quantity)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;total
}


// payment/payment.go：支付模块（独立模块）
package&amp;nbsp;payment


// PaymentService 定义支付接口（与订单模块解耦）
type&amp;nbsp;PaymentService&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 支付操作
}


// AlipayService 支付宝支付实现
type&amp;nbsp;AlipayService&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *alipay.Client &amp;nbsp;// 支付宝 SDK 客户端
}


func&amp;nbsp;(a *AlipayService)&amp;nbsp;Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 调用支付宝 API 完成支付
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;a.client.TradeAppPay(orderID, amount)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;包专注于订单的核心逻辑（如计算总金额），不依赖任何外部支付实现。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;包定义支付接口，具体实现（如支付宝、微信支付）独立存在。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;订单模块通过&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;PaymentService&lt;/span&gt;接口调用支付功能，与具体支付实现解耦。当需要更换支付方式时，只需新增支付实现（如&lt;span style="background-color:#e5e5e5"&gt;WechatPayService&lt;/span&gt;），无需修改订单模块。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、Go 语言的扩展性编码实践&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.1 策略模式：动态切换算法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;策略模式（Strategy Pattern）属于行为型设计模式，用于定义一系列算法（策略），并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用它的客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过接口实现策略的抽象，通过上下文（Context）管理策略的切换。这种模式适用于需要动态选择不同算法的场景（如缓存策略、路由策略）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：缓存策略的动态切换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设系统需要支持多种缓存（Redis、Memcached），且可以根据业务场景动态切换。通过策略模式，可以将缓存的&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;和&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;操作抽象为接口，具体实现由不同缓存提供。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// cache/cache.go：缓存策略接口
package&amp;nbsp;cache


// CacheStrategy 定义缓存操作的接口
type&amp;nbsp;CacheStrategy&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 从缓存获取数据
&amp;nbsp; &amp;nbsp; Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 向缓存写入数据
}
// redis_cache.go：Redis 缓存实现


type&amp;nbsp;RedisCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *redis.Client &amp;nbsp;// Redis 客户端
&amp;nbsp; &amp;nbsp; ttl &amp;nbsp; &amp;nbsp;time.Duration &amp;nbsp;// 默认过期时间
}


func&amp;nbsp;NewRedisCache(client *redis.Client, ttl time.Duration)&amp;nbsp;*RedisCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;RedisCache{client: client, ttl: ttl}
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Get(context.Background(), key).Result()
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Set(context.Background(), key, value, ttl).Err()
}


// memcached_cache.go：Memcached 缓存实现
type&amp;nbsp;MemcachedCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *memcache.Client &amp;nbsp;// Memcached 客户端
}


func&amp;nbsp;NewMemcachedCache(client *memcache.Client)&amp;nbsp;*MemcachedCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;MemcachedCache{client: client}
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; item, err := m.client.Get(key)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;value&amp;nbsp;interface{}
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := json.Unmarshal(item.Value, &amp;amp;value); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;value,&amp;nbsp;nil
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; data, err := json.Marshal(value)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.client.Set(&amp;amp;memcache.Item{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;key,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Value: &amp;nbsp; &amp;nbsp; &amp;nbsp;data,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Expiration:&amp;nbsp;int32(ttl.Seconds()),
&amp;nbsp; &amp;nbsp; }).Err()
}


// cache_context.go：缓存上下文（管理策略切换）
type&amp;nbsp;CacheContext&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; strategy CacheStrategy &amp;nbsp;// 当前使用的缓存策略
}


func&amp;nbsp;NewCacheContext(strategy CacheStrategy)&amp;nbsp;*CacheContext {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;CacheContext{strategy: strategy}
}


// SwitchStrategy 动态切换缓存策略
func&amp;nbsp;(c *CacheContext)&amp;nbsp;SwitchStrategy(strategy CacheStrategy) {
&amp;nbsp; &amp;nbsp; c.strategy = strategy
}


// Get 使用当前策略获取缓存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Get(key)
}


// Set 使用当前策略写入缓存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Set(key, value, ttl)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;接口定义了缓存的核心操作（&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;），所有具体缓存实现必须实现该接口。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;RedisCache&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;MemcachedCache&lt;/span&gt;是具体的策略实现，分别封装了 Redis 和 Memcached 的底层逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;作为上下文，持有当前使用的缓存策略，并提供&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;方法动态切换策略。客户端只需与&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;交互，无需关心具体使用的是哪种缓存。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;当需要新增缓存类型（如本地内存缓存）时，只需实现&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口，无需修改现有代码；切换缓存策略时，只需调用&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;方法，客户端无感知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.2 中间件链：可插拔的请求处理流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;中间件（Middleware）是位于请求处理链中的组件，用于实现横切关注点（如日志记录、限流、鉴权）。中间件链模式允许将多个中间件按顺序组合，形成处理流水线，每个中间件可以处理请求、传递请求或终止请求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过函数类型（&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;func(http.HandlerFunc) http.HandlerFunc&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）定义中间件，通过组合多个中间件形成处理链。这种模式灵活且易于扩展，适用于 HTTP 服务的请求处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：HTTP 中间件链的实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设需要为 Web 服务添加日志记录、限流和鉴权功能，通过中间件链可以将这些功能解耦，按需组合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// middleware/middleware.go：中间件定义
package&amp;nbsp;middleware


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


// Middleware 定义中间件类型：接收 http.HandlerFunc，返回新的 http.HandlerFunc
type&amp;nbsp;Middleware&amp;nbsp;func(http.HandlerFunc)&amp;nbsp;http.HandlerFunc


// LoggingMiddleware 日志中间件：记录请求信息
func&amp;nbsp;LoggingMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; start := time.Now()
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 记录请求方法和路径
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request received:", r.Method, r.URL.Path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 调用下一个中间件或处理函数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 记录请求耗时
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request completed in:", time.Since(start))
&amp;nbsp; &amp;nbsp; }
}


// RateLimitMiddleware 限流中间件：限制请求频率
func&amp;nbsp;RateLimitMiddleware(next http.HandlerFunc, limiter *rate.Limiter)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!limiter.Allow() {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Too Many Requests", http.StatusTooManyRequests)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// AuthMiddleware 鉴权中间件：验证请求令牌
func&amp;nbsp;AuthMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; token := r.Header.Get("Authorization")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;token !=&amp;nbsp;"valid-token"&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Unauthorized", http.StatusUnauthorized)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// chain.go：中间件链组合
func&amp;nbsp;Chain(middlewares ...Middleware)&amp;nbsp;Middleware {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(final http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 反向组合中间件（确保执行顺序正确）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i :=&amp;nbsp;len(middlewares) -&amp;nbsp;1; i &amp;gt;=&amp;nbsp;0; i-- {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final = middlewares[i](final)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;final
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用示例：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：Web 服务入口
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"middleware"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 创建限流器：每秒允许 100 个请求，突发 10 个
&amp;nbsp; &amp;nbsp; limiter := rate.NewLimiter(100,&amp;nbsp;10)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 定义业务处理函数
&amp;nbsp; &amp;nbsp; handleRequest :=&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; w.Write([]byte("Hello, World"))
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 组合中间件链：日志 → 限流 → 鉴权
&amp;nbsp; &amp;nbsp; middlewareChain := middleware.Chain(
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.LoggingMiddleware,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.RateLimitMiddlewareWithLimiter(limiter),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.AuthMiddleware,
&amp;nbsp; &amp;nbsp; )
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 应用中间件链到处理函数
&amp;nbsp; &amp;nbsp; http.HandleFunc("/", middlewareChain(handleRequest))
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 启动服务
&amp;nbsp; &amp;nbsp; http.ListenAndServe(":8080",&amp;nbsp;nil)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;每个中间件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;LoggingMiddleware&lt;/span&gt;、&lt;span style="background-color:#e5e5e5"&gt;RateLimitMiddleware&lt;/span&gt;）专注於单一功能，通过&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;类型定义，确保接口统一。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函数将多个中间件按顺序组合，形成一个处理链。请求会依次经过日志记录、限流、鉴权，最后到达业务处理函数。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;新增中间件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;CORS&lt;/span&gt;跨域中间件）时，只需实现&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;类型，即可通过&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函数轻松加入处理链，无需修改现有中间件或业务逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、可扩展架构的实现模式&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.1 插件化架构：热插拔的功能扩展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件化架构允许系统在运行时动态加载、卸载插件，从而实现功能的灵活扩展。这种架构适用于需要支持第三方扩展或多租户定制的场景（如 IDE 插件、电商平台应用市场）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包支持动态库加载，结合接口定义插件契约，可以实现安全的插件化架构。插件需实现统一的接口，主程序通过接口调用插件功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：插件化系统的实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设需要开发一个支持插件的数据处理系统，主程序可以动态加载处理数据的插件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;json_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// plugin/interface.go：插件接口定义（主程序与插件共享）
package&amp;nbsp;plugin


// DataProcessor 定义数据处理插件的接口
type&amp;nbsp;DataProcessor&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Name()&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件名称（如"csv_parser"）
&amp;nbsp; &amp;nbsp; Process(input []byte) (output []byte, err&amp;nbsp;error) &amp;nbsp;// 处理数据
}


// plugin/csv_parser/csv_processor.go：CSV 处理插件（动态库）
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/csv"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"io"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
)


// CSVProcessor 实现 DataProcessor 接口
type&amp;nbsp;CSVProcessor&amp;nbsp;struct{}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Name()&amp;nbsp;string&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;"csv_parser"
}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Process(input []byte) ([]byte,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 解析 CSV 数据
&amp;nbsp; &amp;nbsp; r := csv.NewReader(bytes.NewReader(input))
&amp;nbsp; &amp;nbsp; records, err := r.ReadAll()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 转换为 JSON 格式输出
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;result []map[string]string
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, record :=&amp;nbsp;range&amp;nbsp;records {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row :=&amp;nbsp;make(map[string]string)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i, field :=&amp;nbsp;range&amp;nbsp;record {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row[fmt.Sprintf("col_%d", i)] = field
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result =&amp;nbsp;append(result, row)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; jsonData, err := json.Marshal(result)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;jsonData,&amp;nbsp;nil
}


// 插件的入口函数（必须命名为"Plugin"，主程序通过此函数获取插件实例）
var&amp;nbsp;Plugin plugin.DataProcessor = &amp;amp;CSVProcessor{}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：主程序（加载插件并调用）
package main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
)


func&amp;nbsp;main() {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件路径（假设编译为 so 文件）
&amp;nbsp; &amp;nbsp; pluginPath :=&amp;nbsp;filepath.Join("plugins",&amp;nbsp;"csv_parser.so")
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载插件
&amp;nbsp; &amp;nbsp; p, err :=&amp;nbsp;plugin.Open(pluginPath)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 获取插件实例（通过接口类型断言）
&amp;nbsp; &amp;nbsp; sym, err :=&amp;nbsp;p.Lookup("Plugin")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; processor, ok :=&amp;nbsp;sym.(plugin.DataProcessor)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic("插件未实现 DataProcessor 接口")
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 使用插件处理数据
&amp;nbsp; &amp;nbsp; inputData :=&amp;nbsp;[]byte("name,age
张三,20
李四,25")
&amp;nbsp; &amp;nbsp; output, err :=&amp;nbsp;processor.Process(inputData)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; fmt.Println(string(output)) &amp;nbsp;// 输出 JSON 格式数据
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;接口定义&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序定义&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，规定插件必须实现的方法（&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Process&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;插件实现&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：插件（如&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）实现&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，并导出名为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Plugin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的全局变量（主程序通过此变量获取插件实例）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;动态加载&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin.Open&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;加载插件，通过&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Lookup&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;获取插件实例，并转换为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;主程序与插件解耦，插件的添加、删除或升级不影响主程序运行。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;支持热插拔：插件可以在运行时动态加载（需注意 Go 插件的局限性，如版本兼容性）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.2 配置驱动架构：外部化的灵活配置&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置驱动架构（Configuration-Driven Architecture）通过将系统行为参数化，使系统可以通过修改配置（而非代码）来适应不同的运行环境或业务需求。这种架构适用于需要支持多环境（开发、测试、生产）、多租户定制或多场景适配的系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/yaml&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等包支持配置文件的解析，结合&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;viper&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等第三方库可以实现更复杂的配置管理（如环境变量覆盖、热更新）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：配置驱动的数据库连接&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设系统需要支持不同环境（开发、生产）的数据库配置，通过配置文件动态加载数据库连接参数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// config/config.go：配置结构体定义
package&amp;nbsp;config


// DBConfig 数据库配置
type&amp;nbsp;DBConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; DSN &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;string&amp;nbsp;`json:"dsn"`&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 数据库连接字符串
&amp;nbsp; &amp;nbsp; MaxOpenConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_open_conn"`&amp;nbsp;// 最大打开连接数
&amp;nbsp; &amp;nbsp; MaxIdleConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_idle_conn"`&amp;nbsp;// 最大空闲连接数
&amp;nbsp; &amp;nbsp; ConnTimeout&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"conn_timeout"`&amp;nbsp;&amp;nbsp;// 连接超时时间（秒）
}


// AppConfig 应用全局配置
type&amp;nbsp;AppConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Env &amp;nbsp;string&amp;nbsp; &amp;nbsp;`json:"env"`&amp;nbsp; &amp;nbsp;// 环境（dev/test/prod）
&amp;nbsp; &amp;nbsp; DB &amp;nbsp; DBConfig&amp;nbsp;`json:"db"`&amp;nbsp; &amp;nbsp;&amp;nbsp;// 数据库配置
&amp;nbsp; &amp;nbsp; Log &amp;nbsp;LogConfig&amp;nbsp;`json:"log"`&amp;nbsp; &amp;nbsp;// 日志配置
}


// LogConfig 日志配置
type&amp;nbsp;LogConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Level&amp;nbsp;string&amp;nbsp;`json:"level"`&amp;nbsp;// 日志级别（debug/info/warn/error）
&amp;nbsp; &amp;nbsp; Path &amp;nbsp;string&amp;nbsp;`json:"path"`&amp;nbsp;&amp;nbsp;// 日志文件路径
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// config/loader.go：配置加载器（支持热更新）
package&amp;nbsp;config


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/json"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"github.com/fsnotify/fsnotify"
)


// LoadConfig 加载配置文件
func&amp;nbsp;LoadConfig(path&amp;nbsp;string)&amp;nbsp;(*AppConfig,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; file, err := os.Open(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;file.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;cfg AppConfig
&amp;nbsp; &amp;nbsp; decoder := json.NewDecoder(file)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := decoder.Decode(&amp;amp;cfg); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;cfg,&amp;nbsp;nil
}


// WatchConfig 监听配置文件变化（热更新）
func&amp;nbsp;WatchConfig(path&amp;nbsp;string, callback&amp;nbsp;func(*AppConfig))&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; watcher, err := fsnotify.NewWatcher()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;watcher.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 监听配置文件所在目录
&amp;nbsp; &amp;nbsp; dir := filepath.Dir(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := watcher.Add(dir); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;event, ok := &amp;lt;-watcher.Events:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 仅处理写事件
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;event.Op&amp;amp;fsnotify.Write == fsnotify.Write {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 重新加载配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; newCfg, err := LoadConfig(path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("加载配置失败:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 触发回调（通知其他模块配置已更新）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(newCfg)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;err, ok := &amp;lt;-watcher.Errors:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("配置监听错误:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 保持程序运行
&amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{}
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：使用配置驱动的数据库连接
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"database/sql"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"config"
&amp;nbsp; &amp;nbsp; _&amp;nbsp;"github.com/go-sql-driver/mysql"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载初始配置
&amp;nbsp; &amp;nbsp; cfg, err := config.LoadConfig("config.json")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 初始化数据库连接
&amp;nbsp; &amp;nbsp; db, err := sql.Open("mysql", cfg.DB.DSN)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;db.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 设置连接池参数（从配置中读取）
&amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(cfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(cfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(cfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 启动配置监听（热更新）
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err := config.WatchConfig("config.json",&amp;nbsp;func(newCfg *config.AppConfig)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 配置更新时，重新设置数据库连接池参数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(newCfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(newCfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(newCfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println("配置已更新，数据库连接池参数调整")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 业务逻辑...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置结构化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;AppConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DBConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等结构体定义配置的层次结构，确保配置的清晰性和可维护性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;热更新支持&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;fsnotify&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;监听配置文件变化，触发回调函数重新加载配置，并更新系统状态（如数据库连接池参数）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;多环境适配&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过不同的配置文件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-dev.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-prod.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）或环境变量覆盖，实现不同环境的配置隔离。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系统行为的调整无需修改代码，只需修改配置文件，降低了维护成本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;支持动态调整关键参数（如数据库连接池大小、日志级别），提升了系统的灵活性和可观测性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、可扩展性的验证与演进&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.1 扩展性验证指标&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了确保系统具备良好的扩展性，需要从多个维度进行验证。以下是关键指标及测量方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;指标&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;目标值&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新功能开发周期&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;统计新增一个中等复杂度功能所需的时间（包括设计、编码、测试）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 2 人日&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;修改影响范围&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;统计修改一个功能时，需要修改的模块数量和代码行数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 5 个模块，&amp;lt; 500 行代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置生效延迟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量配置变更到系统完全应用新配置的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 100ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;并发扩展能力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量系统在增加 CPU 核数时，吞吐量的增长比例（理想为线性增长）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;吞吐量增长 ≥ 核数增长 × 80%&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件加载时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量动态加载一个插件的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 1 秒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.2 扩展性演进路线&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系统的扩展性不是一蹴而就的，需要随着业务的发展逐步演进。以下是一个典型的演进路线：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;graph TD
&amp;nbsp; &amp;nbsp; A[单体架构]&amp;nbsp;--&amp;gt;|垂直拆分| B[核心服务+支撑服务]
&amp;nbsp; &amp;nbsp; B&amp;nbsp;--&amp;gt;|接口抽象| C[模块化架构]
&amp;nbsp; &amp;nbsp; C&amp;nbsp;--&amp;gt;|策略模式/中间件| D[可扩展的分布式架构]
&amp;nbsp; &amp;nbsp; D&amp;nbsp;--&amp;gt;|插件化/配置驱动| E[云原生可扩展架构]&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 1&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;单体架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：初期业务简单，系统以单体形式存在。此时应注重代码的可读性和可维护性，为后续扩展打下基础。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 2&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心服务+支撑服务&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：随着业务增长，将核心功能（如订单、用户）与非核心功能（如日志、监控）拆分，降低耦合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 3&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模块化架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过接口抽象和依赖倒置，将系统拆分为高内聚、低耦合的模块，支持独立开发和部署。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 4&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可扩展的分布式架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：引入策略模式、中间件链等模式，支持动态切换算法和处理流程，适应多样化的业务需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 5&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;云原生可扩展架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：结合容器化（Docker）、编排（Kubernetes）和 Serverless 技术，实现资源的弹性扩展和自动伸缩。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;六、结，语&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可扩展性设计是软件系统的「生命力」所在。通过遵循开闭原则、模块化设计等核心原则，结合策略模式、中间件链、插件化架构等 Go 语言友好的编码模式，开发者可以构建出适应业务变化的「生长型」系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，扩展性设计并非追求「过度设计」，而是在当前需求和未来变化之间找到平衡。建议定期进行架构评审，通过压力测试和代码分析（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;go mod graph&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;查看模块依赖）评估系统的扩展性健康度，及时调整设计策略。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最后，记住：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优秀的系统不是完美的，而是能够持续进化的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。保持开放的心态，拥抱变化，才能在快速发展的技术领域中立于不败之地。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;得物新商品审核链路建设分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;营销会场预览直通车实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;基于 TinyMce 富文本编辑器的客服自研知识库的技术探索和实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;AI 质量专项报告自动分析生成｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;Rust 性能提升「最后一公里」：详解 Profiling 瓶颈定位与优化｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 悟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18689869</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18689869</guid>
      <pubDate>Thu, 28 Aug 2025 07:29:39 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>腾讯混元开源端到端视频音效生成模型 HunyuanVideo-Foley</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯混元宣布开源端到端视频音效生成模型 HunyuanVideo-Foley，&lt;strong&gt;只需输入视频和文字，就能&lt;strong&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;/strong&gt;视频&lt;strong&gt;&lt;strong&gt;匹配&lt;/strong&gt;&lt;/strong&gt;电影级音效&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;比如，输入文本描述"With a faint sound as their hands parted, the two embraced, a soft 'mm' escaping between them.」&lt;/p&gt; 
&lt;p&gt;就会得到一个声色俱佳的视频：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/151052_IFKo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;技术亮点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;泛化能力强&lt;/strong&gt;：适配人物、动物、自然景观、卡通动画等各类视频，生成精准匹配画面的音频。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多模态语义均衡响应&lt;/strong&gt;：创新双流多模态扩散变换器（MMDIT）架构，平衡文本与视频语义，避免「顾文失画」问题。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;专业级音频保真度&lt;/strong&gt;：引入表征对齐（REPA）损失函数，抑制底噪，确保音频质量达到专业制作水准。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-8072afd58fae2af02917f8e2c87f453b039.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方介绍称，HunyuanVideo-Foley 不仅打破了 AI&amp;nbsp;生成的视频只能 「看」 不能 「听」 的局限，让无声 AI 视频成为历史，更是真正做到了 「看懂画面、读懂文字、配准声音」 ，带来沉浸式视听体验。这款音效生成工具可广泛应用于短视频创作、电影制作、广告创意和游戏开发等场景。&lt;/p&gt; 
&lt;p&gt;即日起，用户可在 Github,HuggingFace 下载模型，也可以在混元官网直接体验。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;体验入口：https://hunyuan.tencent.com/video/zh?tabIndex=0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;项目官网：https://szczesnys.github.io/hunyuanvideo-foley/&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;代码：https://github.com/Tencent-Hunyuan/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技术报告：https://arxiv.org/abs/2508.16930&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Hugging Face：https://huggingface.co/tencent/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368967</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368967</guid>
      <pubDate>Thu, 28 Aug 2025 07:12:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>HarmonyOS 教育行业解决方案，使能教育 App 开发者一键开发、轻松创新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;为帮助开发者实现快速开发及上架，华为已推出&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;HarmonyOS 教育行业解决方案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;，结合 HarmonyOS 的技术特性如一次开发多端部署、应用接续等；创新能力如 POI 推荐、碰一碰、小艺智能体、AI 朗读等，以独特的创新引擎，为教育类 App 开发者提供高效解决方案，同时也为用户打造无缝畅享的智慧学习体验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;登录优化与多设备协同：流畅性跨越式提升&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;HarmonyOS 提供了华为账号一键登录等能力优化身份认证，结合智能填充和 Asset 敏感资产存储技术，可有效简化登录流程，构建更顺畅安全的登录体验。同时，在多端、跨端使用时，基于 HarmonyOS 多端协同及应用接续能力，可助力用户打破边界流畅使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;如宝宝巴士 App，基于 HarmonyOS「一次开发，多端部署」的特性，开发者在多端多设备上的开发效率有效提升，同时降低了开发成本，并支持应用跨设备的接续。当用户外出返家后，原本通过手机端收听的节目可在平板端接续播放，实现鸿蒙生态内多设备形态的无缝部署和一致体验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="652" src="https://oscimg.oschina.net/oscnet/up-cd0135c52ed2fa17dd0f91c2db1cb2cc2ce.png" width="960" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;精准意图识别与智慧交互：简化操作路径，辅助优化学习效率&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;基于 HarmonyOS 的意图框架及 AI 大模型能力，教育类应用可在日常使用时更智能地响应用户需求。如在洪恩识字 App 中，结合用户日常使用习惯，小艺建议可定期、定时推送「待学字」的相关课程，帮助用户轻松完成学习规划；如在宝宝巴士 App 中，用户可以通过小艺推荐、呼唤小艺语音唤醒等方式，快速直达需求功能页，省去层层跳转步骤。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="672" src="https://oscimg.oschina.net/oscnet/up-15c456546b84afa55a957d8fc12024a9a61.png" width="678" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;同时，HarmonyOS 还提供了多样化智慧交互方式，常见如服务卡片这一高效桌面入口，可智能更新一键直达，显著简化用户获取信息和启动核心功能的路径；还有如使用折叠屏时，利用悬停手势实现 360 度自由旋转交互，快速获取沉浸体验；其他如让文字开口说话的 AI 朗读控件、能够准确识别拍摄题目、材料内容的拍照一致性等功能，都为作业帮、小猿搜题、网易有道词典、百词斩等众多应用，提供了创新交互体验的底层技术支撑。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;场景化服务与碰一碰支付：延伸智慧教育边界&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;除上述应用使用场景之外，在线下及实际场景交互上，HarmonyOS 同样提供了智慧新体验。如在宝宝巴士 App 中，家长通过手机碰一碰儿童平板便可实现快速、安全的支付操作；如在英语趣配音 App 中，用户通过碰一碰即可快速分享配音作品、学习笔记或专题素材包等，协作交流零延迟。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;在高校类应用及元服务中，基于用户 POI 位置，结合小艺建议的服务推荐能力，在用户到达学园校区、食堂/餐厅等地点时，桌面还将主动推荐定位打卡、校园卡付款码等服务功能，为常用服务提供系统级桌面入口，简化用户操作流程。据了解，当前包括北京大学、西北工业大学在内的诸多院校已接入 POI 相关能力，与 HarmonyOS 一起，探索高校类应用的数智场景边界。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="709" src="https://oscimg.oschina.net/oscnet/up-825319d77499a4fc98d563936f4b0c60cc3.png" width="430" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;从幼儿启蒙到高校场景服务，从功能开发到交互细节的优化，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;HarmonyOS 教育行业解决方案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;正以创新技术为教育行业全链路提供支撑。相信随着越来越多教育行业 App 的加入，HarmonyOS 将在教育领域持续探索与深入，为用户带来更加智慧、便捷的使用体验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;欢迎感兴趣的教育行业开发者前往 HarmonyOS 官网搜索「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;HarmonyOS 教育行业解决方案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;」或点击下方链接了解相关内容~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="color:#333333"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;https://developer.huawei.com/consumer/cn/market/landing/educationsolution&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://inews.gtimg.com/om_bt/O3l7h1AQ4-a_if5HP0nU40zuishX2wIBUqw7G7-3nLYBYAA/641" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="320" src="https://oscimg.oschina.net/oscnet/up-56e016fa3fba77e2272ab26b7fc62204a7a.png" width="960" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368965</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368965</guid>
      <pubDate>Thu, 28 Aug 2025 07:09:39 GMT</pubDate>
      <author>作者: 开源科技</author>
    </item>
    <item>
      <title>不设限的 SCADA - 易控天地集成管控平台</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; text-align:left"&gt;&lt;span style="color:#4472c4"&gt;SCADA 平台发展困境&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;SCADA 平台凭借其强大的数据采集、实时数据管理、人机交互以及脚本编程能力，一直以来都被视为开发监控系统的优选解决方案。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;然而，随着终端用户对监控系统要求的不断提高，以及对管控一体化需求的日益普及，SCADA 平台在实际应用中逐渐暴露出诸多局限性。尤其在需要实现非原生或非传统功能时，系统开发往往会变得异常复杂和困难。造成这一现象的根本原因在于平台的可扩展能力较弱，限制了用户在进行项目定制和功能拓展方面的空间。另一方面，若完全放弃 SCADA 平台，选择从零开始的完全定制开发，则往往面临开发周期长、技术风险高、成本投入大、系统稳定性难以保障、以及高度依赖特定技术人员等一系列严峻挑战。这种「进退两难」的处境，严重制约了监控或管控系统的开发。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;SCADA 平台能否突破自身局限，通过增强开放性，提升灵活性与可扩展性，从而显著拓宽用户在平台中的自定义能力和二次开发空间，已成为破解界当前开发困境的关键。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span style="color:#4472c4"&gt;原因分析及解决之道&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;纵观国内外 SCADA 平台市场，大多数产品普遍存在底层技术支持薄弱、开放性有限、灵活性和扩展性不足的问题。究其根源，可归结为以下五个方面：&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:47px; text-align:left"&gt;&lt;strong&gt;1.&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;历史&lt;/strong&gt;&lt;strong&gt;因素：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;许多产品基于早期技术体系构建，开发理念与手段相对落后，导致底层技术能力先天不足。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:47px; text-align:left"&gt;&lt;strong&gt;2.&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;技术因素：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;SCADA 平台涉及数据采集、实时数据库、人机交互、脚本编程等多方面技术，体系复杂、开发门槛高，对专业技术人才依赖性强，开发难度大。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:47px; text-align:left"&gt;&lt;strong&gt;3.&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;资源因素：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;SCADA 平台的不断进步依赖持续的产品专注和长期且大量的人力与资金投入，而许多厂商在产品专注、资源分配、研发投入方面明显不足。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:47px; text-align:left"&gt;&lt;strong&gt;4.&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;战略与规划因素&lt;/strong&gt;&lt;strong&gt;：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;部分研发团队对行业变革、用户需求演进、技术发展趋势缺乏前瞻性判断，产品定位高度不够，顶层设计存在局限。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:47px; text-align:left"&gt;&lt;strong&gt;5.&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;架构因素&lt;/strong&gt;&lt;strong&gt;：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;平台底层架构在模块化、组件化和服务化方面表现不足、结构不合理、耦合度高，导致整体缺乏健壮性、开放性和灵活性，难以支持持续的功能迭代。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="图片 1.jpg" src="https://oscimg.oschina.net/oscnet//b1054310e53c5b5d107cfb8989bb1d5b.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;市场正迫切期待新一代的 SCADA 平台的出现。它应立足于全新高度，以「管控一体化」为核心理念，拓展功能边界，融合过程控制、生产管理甚至企业信息化管理（L2、L3、L4）等多层级业务需求。其架构应更强健、更开放、更灵活，能够支持行业特殊需求，并为用户提供充分的定制与扩展能力。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span style="color:#4472c4"&gt;易控天地集成管控平台：定位和视角更为宏观+系统架构更为健壮和开放&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;易控天地是九思易公司从 2010 年开始，在成熟的易控 SCADA 基础上全新设计的集成管控平台。该产品承载了九思易在自动化软件领域的深厚积累，凝聚了对行业趋势和用户需求的深刻观察，定位为一款融合自动化、信息化、数字化和智能化技术的综合监控与管控系统开发平台。它不仅完整涵盖 SCADA 核心功能，更在横向应用宽度和纵向技术深度上实现了功能的显著扩展与增强。基于健壮和开放的系统架构，依托强大的底层技术支撑，历经 15 年的持续研发和精进，易控天地已成为一款功能全面，高度可扩展，极具弹性的新一代应用开发平台。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;具体而言，易控天地凭借稳健的架构设计，展现出卓越的系统承载能力。无论是常规的监控场景、增强型监控应用，还是复杂的综合管控系统，均可基于该平台高效、稳定地构建。其高度开放的架构，支持在保持平台完整性的前提下灵活进行扩展，有效应对行业特殊需求，实现平台的可持续「成长」。易控天地继承了易控 SCADA 基于 C#高级语言的脚本编程能力，并进一步强化了其深度与灵活性。 这种强大的二次编程能力为应用系统的开发注入了无限的可能性，显著提升了复杂业务的实现能力。 同时，易控天地支持无缝集成用户使用高级语言自主开发或第三方提供的外部程序模块、类库或控件，能显著拓展系统能力边界，有效保护投资。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;易控天地自 2015 年推出标准版以来，已在光伏、半导体、制药等多个新兴行业实现深度应用，并获得用户的广泛认可与好评。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="图片 2.jpg" src="https://oscimg.oschina.net/oscnet//74282ee3dd05e2f18dcfdf2bd9d2a958.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span style="color:#4472c4"&gt;易控天地 PRO 的行业特需扩展性实践&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;最新发布的易控天地 PRO 版本，进一步内置了多项行业特需功能，显著强化了在垂直领域的应用深度。例如：&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:57px; text-align:left"&gt;●针对制药、化工等流程行业，PRO 版本集成了完整的批次生产管理模块。该模块将 PLC 控制、批次处理、SCADA 监控与 MES 信息管理深度融合，为用户提供了一体化的批次生产解决方案。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:57px; text-align:left"&gt;●在半导体行业，为满足严格的 SEMI 标准通信规范，易控天地 PRO 提供了原生支持。即可开发设备侧的监控系统与工厂主机进行信息交互，也可应用于主机侧，实现对生产设备的集中监控与生产管理。&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:57px; text-align:left"&gt;●面向智慧城市和安防指控领域，PRO 版本新增了灵活的预案管理功能。既可实现按预定计划自动执行的任务流程，也允许运行时的实时介入，动态调整任务的执行策略或顺序，有效提升应急响应与指挥调度的智能化水平。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;正是这些特性，让易控天地成为一个真正「不设限」的应用系统开发平台。它不仅能够轻松应对日益复杂的生产系统需求，还能高效满足各行业特需功能的定制，展现出卓越的业务适应性与扩展能力。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span style="color:#4472c4"&gt;不设限的 SCADA&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;在数字化转型和智能化升级的浪潮下，一个真正「不设限」的应用系统开发平台，必须具备从「监控」到「管控」再到「智控」的高度和视野，以开放的架构打破系统边界，以灵活扩展赋能用户创新。唯有如此，才能应对日益复杂的应用需求，实现柔性生产和行业深度定制，切实帮助企业在提高生产效率、提升产品质量和降低生产成本的核心目标上取得突破，赢得竞争。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368963</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368963</guid>
      <pubDate>Thu, 28 Aug 2025 07:07:39 GMT</pubDate>
      <author>作者: 开源科技</author>
    </item>
    <item>
      <title>开源 IDE 项目 Zed 完成 3200 万美元 B 轮融资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源 IDE 项目 Zed &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fsequoia-backs-zed" target="_blank"&gt;宣布&lt;/a&gt;完成 3200 万美元 B 轮融资，由红杉资本领投，使其累计融资总额突破 4200 万美元。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-08cd4e91d1394290d041152f5dcb7ef153e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zed 最初因「极致性能的代码编辑器」受到关注，而此次融资背后的核心目标，是推动其向协作平台转型。团队提出的重点创新是 DeltaDB ——一种基于操作级别（edit-level）的全新版本控制系统，能够记录每一次字符修改，并与讨论、AI 建议深度绑定。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/150503_ItlB_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;与传统依赖 Git 快照的开发方式不同，DeltaDB 采用 CRDT 技术实现实时同步，并提供「字符级永久链接」，让代码讨论和历史演化可以直接嵌入到 IDE 中。Zed 希望借此打造出一个既能支撑团队协作，也能与 AI 高效共创的开发环境。&lt;/p&gt; 
&lt;p&gt;未来，Zed 与 DeltaDB 都将继续保持开源，并探索付费服务模式。同时，团队也在积极扩招，涵盖字体渲染、GPU Shader、编辑预测模型等方向。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368962/sequoia-backs-zed-32m</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368962/sequoia-backs-zed-32m</guid>
      <pubDate>Thu, 28 Aug 2025 07:06:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>超千家 AI 企业「智汇」鹏城 2025 AGIC 深圳（国际）通用人工智能大会暨产业博览会启幕</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; text-align:left"&gt;昨晚，1.2 万架无人机在夜空组成梦幻矩阵，楼宇灯光随 AI 算法实时变幻出流光溢彩的城市年轮，共同庆祝深圳经济特区建立 45 周年，奏响人工智能澎湃序曲。今天，一场未来式的 AI 盛宴接过城市庆典的科技接力棒。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;8 月 27 日，2025 AGIC 深圳（国际）通用人工智能大会暨深圳（国际）通用人工智能产业博览会（以下简称「大会」）在深圳国际会展中心（宝安）拉开序幕。现场发布了 2025 最受欢迎的人形机器人、AI PC、智能体、AI 眼镜等十大 AI 产品，表彰了 2025 十大首席人工智能官，揭晓了 2025 粤港澳大湾区人工智能、人工智能+ TOP50 榜单。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//b468f4b9b98435619cdfab76e0708a5f.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;大会为期三天，将持续到 8 月 29 日，展览面积达 8 万平方米，1001 家品牌企业参展，举办 1 场开幕式，3 场主论坛，超 40 场平行论坛，500 多位行业大咖齐聚，预计吸引超 12 万专业观众到场。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//9e4bfb73a99da7d98682d24a7312f42c.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;本次大会主题为「模驱具身・智启未来」，由全国工商联人工智能委员会、深圳市工业和信息化局、深圳市人力资源和社会保障局、深圳市龙岗区人工智能（机器人）署、深圳市宝安区人工智能产业办公室、前海科技创新集团有限公司等单位指导，深圳市人工智能产业协会主办，延续「国际化、专业化、市场化、品牌化、高端化」办会理念，搭建 「技术展示--商业对接--生态共建」 的高端平台，加速产业链融合与技术转化，为全球 AI 产业提供创新引擎与跨界合作枢纽。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//bebaa92ae08978c7a43198c0625fda88.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;大会让前沿科技可感、可触、可用，特别设置了多个互动体验区，让参会者能够亲身操作、体验前沿科技产品，零距离感受 AI 带来的变革。例如在「AI 未来城」实景演示区，比亚迪携方程豹、腾势旗舰车型登场，观众可感受其 AI 辅助驾驶带来的安全与便捷，深度体验「AI+汽车」的独特魅力。众擎机器人的工业级协作机器人、优必选的人形服务机器人以及数字华夏的智能交互机器人将在此「上岗」，为观众演示人形机器人工作场景。在这里，观众不再是被动的观看者，而是未来生活的参与者。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//ddf71f8a8437d3e645fb7a4ea84e1e69.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;strong&gt;加快打造&lt;/strong&gt;&lt;strong&gt;人工智能先锋城市&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;构建通用人工智能产业集群&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;人工智能作为引领未来的战略性技术，是新一轮科技革命和产业变革的重要驱动力量。2025 年 3 月，深圳市发布《加快打造人工智能先锋城市行动计划（2025—2026 年）》，明确提出到 2026 年建成「场景应用最开放、算力供给最普惠、产业生态最健全、创新创业最便捷」的人工智能先锋城市，形成具有国际影响力的产业创新高地。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;开幕上，国家广播电视总局原副局长乐玉成表示，深圳作为我国改革开放的重要窗口，不仅是创新创业的热土，更是人工智能应用的前沿高地。从人形机器人、AI 玩具，到 AI 耳机、AI PC、AI 手机，层出不穷的创新产品不断刷新着人们对智能科技的认知。尤其在人工智能逐步迈向通用智能、AI 产品迎来爆发式增长的当下，大会充分展现出「见买家、见产品、见订单」的独特优势。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//12d405780040f27e482672ed32b05a69.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;第十四届全国政协委员、第二届全国新材料专咨委主任、工信部电子科技委主任，工信部原副部长王江平提出，随着 AI 和科学研究深度的融合，AI for Science 这一前沿领域迅猛发展，在蛋白质结构的预测、药物材料的发现方面取得了显著成果，展现出巨大潜力，被称为「科学研究的第五范式」。尽管 AI 科学发现能力呈指数级增长，但是人类的实验验证和转化能力却在缓慢爬坡，导致了海量的预测成果得不到及时的验证和应用，形成了一座「堰塞湖」，因此他建议：第一要建立行业认可的 AI 预测结果的评估标准体系，推动跨学科的合作；第二要加强科研数据集的建设以及相关模型数据的开源共享；第三要提升 AI 自主实验的能力，加快自动化实验技术的迭代升级；第四要加强中试平台的建设，发挥应用场景优势，推动工程化创新，充分发挥我国完整的工业体系和全产业链的优势，特别是要聚焦国家重大需求和产业短板，推动 AI for Science 在这些领域按需预测，实现精准赋能。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//05eb0997c1812288ba698fdfced29f24.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;AGIC 深圳（国际）通用人工智能大会主席夏佐全介绍称，本届大会汇聚了来自德国、法国、日本、新加坡等 20 个国家的顶尖科技力量，吸引全球 1001 家人工智能企业展示最新成果，已有超过 1.1 万名海外采购商登记参观，百项前沿 AI 技术全球首发。来自海内外的专家学者、企业家和合作伙伴齐聚一堂，不仅为深圳人工智能产业注入了新的活力，也为全球人工智能发展搭建了一个交流互鉴、合作共赢的重要平台。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//e69dd49e6ed07e58cee55e3f712d21e6.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;AGIC 深圳（国际）通用人工智能大会组委会执行主席范丛明表示，紧扣国家「人工智能+」战略部署，以「一会一展一赛」为载体，搭建起学术、产业与人才深度融合的平台。大会期间，面向全球发布《人工智能发展倡议》，以共识引领未来；重磅推出人工智能产业 17 大榜单，从「2025 深圳人工智能企业 TOP50」，到「十大首席人工智能官」，再到「最受欢迎的十大 AI 产品」，全面展现产业标杆与创新力量；「全球 AI 采购专场」预计将促成超 20 亿元意向合作，大会整体签约额有望突破 30 亿元，为人工智能产业发展注入澎湃动能。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//ef9d1852636a78748aa2e456cc8c0539.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;据深圳市人工智能产业协会研究部统计,2024 年深圳 AI 产业规模达 3685 亿元，典型企业数量达 2887 家。两项指标均居全国前列，彰显深圳打造「全球人工智能先锋城市」的强劲动能。深圳已构建起人工智能产业强大产业集群，其中规上企业超 2600 家，形成以华为、腾讯为龙头，比亚迪、大疆等为支撑，优必选、云天励飞等众多创新企业为支撑，初创企业竞相发展的「雁阵梯队」。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;strong&gt;超千家 AI 企业「智汇」鹏城&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;外地企业占比超四成&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;本次大会设置 AGI（通用人工智能）、智能传感（通信）、智能终端、智能物联网四大主题展馆，展览面积 8 万平方米，1001 家品牌企业携 2000 多件前沿产品或技术亮相，企业数量较 2024 年增长 23.6%，产品数量预计较 2024 年增长 25% 以上，集中展示人工智能技术的最新趋势与落地应用。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;深圳本土企业阵容亮眼，机器人领域的深圳「十三太保」、南山「八大金刚」，以及腾讯、比亚迪、优必选等头部企业悉数亮相，带来近 160 款最新产品首发，较 2024 年增长 1.62 倍。参展展品中，围绕 AI Agent、AI 大模型的应用型产品占比突出，人形机器人、智能体、AI 玩具等 「可用、可看、可体验」的产品成为现场焦点，直观展现深圳在 AI 与机器人领域的技术和落地能力。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//ef0574f48c08d232a592e7c691998593.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;值得注意的是，本次大会吸引深圳市以外企业四百多家，占比达 42.3%，其中来自日本、美国、德国的参展企业达 27 家，创下大会新高。在这里，外地企业不仅能够展示产品、拓展市场、获取订单，更能融入产业生态、对接全球资源、把握发展趋势。正如业内人士所言，「到深圳参展，寻求市场机遇」已成为众多厂商的共识。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//c93eac9ca845f56e66c24ee9676d9a95.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;strong&gt;「最强大脑」集结&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;打造全球 AGI 风向标&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;大会期间，同期举办超 40 场高水平平行论坛，15 位以上院士及 500 多位人工智能领域企业家、学者等，共同探讨通用人工智能（AGI）的前沿发展、产业落地与全球协作。在开幕式上，多位全球 AI 领域重磅嘉宾发表主旨演讲，分享前沿洞见：&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;日本 AGI 专家、全脑架构倡议（WBAI）代表理事、原日本人工智能学会委员长山川宏教授表示，当前，人工智能已成为全球科技发展的前沿领域之一，正以惊人的速度和规模改变着我们的生活、工作方式乃至整个社会。它不仅带来了生产力的飞跃提升，同时也带来了前所未有的机遇与挑战。他特别提到，深圳作为中国科技创新的枢纽，一直都是全球人工智能研究与应用的重要策源地，希望通过此次大会交流思想、分享经验、探索合作，推动人工智能技术实现更大突破。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//2369a14dac443cc5c03234d477017766.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;中国工程院外籍院士、教授张建伟院士围绕「具身智能连接世界模型造福人类」主题发表演讲，系统阐释了具身智能与世界模型的融合路径，创新性提出「多模态具身智能是 AI 技术应用于物理世界的关键跃迁」，并深入探索 AI 如何从「工具」进化为「伙伴」的可行方向，为 AGI 服务人类社会提供全新思路。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//d513112940aa2a283c476359cb8d4c29.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;在 AI 算力领域，长期存在着一个「不可能三角」--弹性、低价、稳定，这三者似乎永远无法兼得。清华大学创业团队共绩科技 CEO 付智以「弹性算力」为支点，揭示了如何构建一个「按需分配、成本可控、人人可用」的普惠算力体系，致力于打破算力资源壁垒，让更多个人开发者和中小企业享受到平价、可靠的 AI 算力服务。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//0da99f9b8a34cc4fb0aae9156d5d6689.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;strong&gt;市场化特色鲜明&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;深度联动大湾区&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;大会强调「民间发起、民间主办、政府大力支持」的市场化基因。坚持「从市场中来，到市场中去」，专注于呈现市场上最具亮点的产品和需求。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;为促进交易达成，大会组织了 300 个专业买家巡馆团，吸引了内地工商联、校友会、商会等机构的 7000 余位买家代表，围绕其关注的领域（如 AI PC、AI 玩具、智能体等）进行精准对接。同时设立直播专区，线上线下同步推进。上届大会促成超 10 亿元人民币的意向签约，本届大会已设置两轮签约环节，目前初步统计意向签约额超 20 亿元人民币，预计总签约额有望超 30 亿元人民币。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;大会创新构建 「主会场+分会场」联动模式，同步设立中山分会场，粤港澳大湾区香港、澳门、东莞、惠州、珠海、广州、湛江等「9+2」城市组团参会。8 月 28 日组织企业家赴中山开展对接活动，由中山市工信局、翠亨新区与深圳协同推进产业融合，实现技术研发、产品制造、场景应用的全链条展示，充分发挥区域协同创新优势。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;这场以「模驱具身・智启未来」为主题的盛会，既是深圳人工智能产业实力的「全景答卷」—— 从 3685 亿元产业规模、2887 家典型企业构筑的 「雁阵梯队」，到腾讯、比亚迪等龙头与优必选、云天励飞、力维智联等创新企业共同演绎的「技术突围」，尽显 「全球人工智能先锋城市」的底气；也是粤港澳大湾区协同创新的「生动范本」——中山分会场的联动、「9+2」城市组团的参与，让「技术研发-产品制造 - 场景应用」的全链条协作从蓝图落地为实景，为广东制造业转型升级注入智能活水。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;勇立潮头再出发，站在深圳特区建立 45 周年的新起点，这场 AI 盛会承载着对未来的无限憧憬。它不仅是全球 AI「智汇」鹏城的璀璨瞬间，更是中国以开放姿态拥抱全球、以创新驱动引领变革、以科技向善普惠人类的重要里程碑。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368960</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368960</guid>
      <pubDate>Thu, 28 Aug 2025 06:56:39 GMT</pubDate>
      <author>作者: 开源科技</author>
    </item>
    <item>
      <title>开源代码编辑器 Zed 推出智能体集成协议：Agent Client Protocol (ACP)</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源编辑器 &lt;strong&gt;Zed&lt;/strong&gt; 宣布推出全新的 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fbring-your-own-agent-to-zed" target="_blank"&gt;&lt;strong&gt;Agent Client Protocol (ACP)&lt;/strong&gt;&lt;/a&gt;，这一协议让开发者可以在编辑器中自由接入任意第三方智能体（Agent），无需依赖官方内置工具。其理念类似于 &lt;strong&gt;语言服务器协议（LSP）&lt;/strong&gt;，通过解耦编辑器与智能体的交互方式，提供更灵活的扩展能力。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2f621ad18024ec580d997b820ea9139346e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/zed-industries/agent-client-protocol&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;首个落地案例是与 &lt;strong&gt;Google Gemini CLI&lt;/strong&gt; 的合作。Zed 已在终端中集成该工具，并通过 &lt;strong&gt;JSON-RPC&lt;/strong&gt; 替代传统的 ANSI 转义码，实现更精准的交互。这让开发者在 Zed 内获得了更流畅的 AI 编程体验：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;实时可视化的智能编辑体验&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多缓冲区（multi-buffer）查看和审阅&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在代码与智能体交互之间实现流畅导航&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-de6cc0bed05ae096d65f7a6d98e326feab1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，ACP 协议已经以 Apache 开源许可证发布，任何开发者都可基于它集成自己的 AI Agent。目前不仅 Zed 内置的智能体已迁移到这一统一框架，社区中也有人正探索将 ACP 带到 Neovim 等其他编辑器。这意味着所有为内置 Agent 开发的用户界面组件，也会开箱即用支持外部智能体。这种内核与 UI 的清晰分离显著加快了 Zed 的迭代速度。&lt;/p&gt; 
&lt;p&gt;Zed 团队表示，他们希望 ACP 能像 LSP 一样成为行业标准，推动形成一个开放、健康的智能体生态系统。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</guid>
      <pubDate>Thu, 28 Aug 2025 06:51:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>​腾讯开源智能体框架 Youtu-agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;腾讯近日发布了 Youtu-agent，这是一个灵活且高性能的框架，旨在构建、运行和评估自主智能体。该框架不仅在基准测试中表现出色，还提供了强大的智能体能力，如数据分析、文件处理和深入研究，所有这些功能都基于开源模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 的主要特点之一是其经过验证的性能。在 WebWalkerQA 基准测试中，该框架使用 DeepSeek-V3 系列模型达到了 71.47% 的准确率，而在 GAIA 基准测试中，达到了 72.8% 的准确率，显示出开源模型的强大潜力。通过优化框架，Youtu-agent 实现了低成本、便捷的部署，无需依赖封闭模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="398" src="https://oscimg.oschina.net/oscnet/up-df9ff0c7515f666fdb5c9d2c521ef538464.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，Youtu-agent 还支持多种实际应用场景，包括 CSV 分析、文献综述、个人文件整理，以及即将推出的播客和视频生成。它采用了灵活的架构，支持多样的模型 API，从 DeepSeek 到 gpt-oss 都可兼容，方便用户进行扩展和集成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="299" src="https://oscimg.oschina.net/oscnet/up-30ecda52cd4aeefc59ae83bccbe4a385e80.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在自动化和简化操作方面，Youtu-agent 引入了基于 YAML 的配置，用户可以通过简单的配置文件快速生成智能体。其内置的 「元智能体」 能够与用户交互，自动捕捉需求并生成配置。这种方法大大减少了手动设置的工作量，让用户能迅速上手。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 还拥有全异步执行的特性，极大地提高了性能效率，特别是在评估基准时的表现尤为突出。该框架不仅支持用户进行深入研究和数据收集，还能帮助开发者快速构建现实世界中的智能体应用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了帮助用户更快上手，Youtu-agent 提供了详细的文档和示例，用户只需简单的脚本便能运行多种智能体，极大地降低了学习曲线。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368953</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368953</guid>
      <pubDate>Thu, 28 Aug 2025 06:41:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>互联网标准组织发布新草案，提议网页标注 AI 使用情况</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;互联网工程任务组（IETF）近日发布《AI 内容披露头字段》（AI Content Disclosure Header）草案，提议在网页 HTTP 响应中新增可机读的 AI 使用标记，以说明 AI 在内容生成中的参与情况。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143226_iWtj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;https://www.ietf.org/archive/id/draft-abaris-aicdh-00.html&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;该草案拟为网页服务器响应添加一个新的 HTTP 头字段，用于标记人工智能在网页内容生成中的参与情况，目标是在保持低资源消耗的前提下，让搜索引擎、归档系统及浏览器等能够快速识别 AI 相关内容。&lt;/p&gt; 
&lt;p&gt;此头字段将包含五个主要信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;mode（AI 使用模式）&lt;/li&gt; 
 &lt;li&gt;model（使用的 AI 模型名称）&lt;/li&gt; 
 &lt;li&gt;provider（模型提供方）&lt;/li&gt; 
 &lt;li&gt;reviewed-by（内容审查人）&lt;/li&gt; 
 &lt;li&gt;date（生成或修改日期时间）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其中，mode 有四种取值：none（未使用 AI 生成或修改内容）、ai-modified（原有人类创作，经 AI 修改）、ai-originated（内容由 AI 生成，经人工编辑修改并审核）、machine-generated（几乎完全由 AI 生成，几乎无人为干预）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143133_J3wR_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;与现有的 AI 生成内容提示（如文字声明或图片/视频水印）不同，这一 HTTP 头字段无需依赖人工判断或解析复杂元数据文件，是完全机器可读的，可帮助搜索引擎进行更精准的索引，提升合规审查和数据归档的效率。&lt;/p&gt; 
&lt;p&gt;IETF 指出，这种标准化的标记方式可为网络爬虫、内容分析工具和归档系统提供低延迟的 AI 检测途径，减少不必要的计算和资源浪费。目前，该草案尚未成为正式标准，未来可能根据业界反馈进一步调整和扩展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368947</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368947</guid>
      <pubDate>Tue, 19 Aug 2025 06:32:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>研发提效新选择：Oinone 企业级产品化引擎正式开源 ，邀你体验</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;不少软件企业长期陷于「交付优先」，重复开发、规范难落地、资产难沉淀，既要应对高强度的个性化需求，又要维护统一标品，效率与质量常陷拉扯。解决的关键是将产品迭代与项目交付分离，在统一架构下沉淀可复用的模块与扩展包，让项目逐步转化为可升级、可规模化的标品&lt;/p&gt; 
&lt;p&gt;Oinone 产品化架构&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span style="color:#035dff"&gt;&lt;strong&gt;上层承接客户差异化与行业特性，中层直面市场的标准业务产品，底层沉淀通用能力与标准，确保迭代稳定&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。通过将需求拆解为模块与扩展包，实现标准化与个性化在同一框架内协同；依托低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无代码一体化、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;被集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;原则及国产化全栈支持，保障生态适配与持续演进。现场演示中，标准产品与个性化需求都能快速落地，开发到上线全程在统一规范下完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Oinone demo 体验&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Segoe UI&amp;quot;,Helvetica,Arial,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Liberation Sans&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Wenquanyi Micro Hei&amp;quot;,&amp;quot;WenQuanYi Zen Hei&amp;quot;,&amp;quot;ST Heiti&amp;quot;,SimHei,SimSun,&amp;quot;WenQuanYi Zen Hei Sharp&amp;quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:856px; word-break:initial; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;演示环境&lt;/th&gt; 
   &lt;th&gt;相关视频&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fdemo.oinone.top" target="_blank"&gt;⚡ 直达演示环境&lt;/a&gt;&lt;br&gt; ☕ 账号：admin&lt;br&gt; ☕ 密码：admin&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt; &lt;p&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEts%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 1. [数式 Oinone] #产品化演示# 后端研发与无代码辅助&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1DoMizbECt%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 2. [数式 Oinone] #产品化演示# 前端开发&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RDMizYELg%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 3. [数式 Oinone] #个性化二开# 后端逻辑&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYED1%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 4. [数式 Oinone] #个性化二开# 前端交互&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEdF%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 5. [数式 Oinone] #个性化二开# 无代码模式&lt;/a&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h1&gt;6.2.0 版本正式开源&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;Gitee: 
  &lt;ul&gt; 
   &lt;li&gt;后端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250822 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;修复集成设计器新建或复制 API 时未正确记录日志的问题&lt;/li&gt; 
 &lt;li&gt;修复发布为开放接口时出入参转换异常的问题&lt;/li&gt; 
 &lt;li&gt;修复开放接口调用集成接口时日志保存异常的问题&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250818 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;前端版本升级&lt;/li&gt; 
 &lt;li&gt;集成应用-集成接口新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器集成接口详情页面新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器 body 参数支持保留空值功能&lt;/li&gt; 
 &lt;li&gt;集成设计器的集成接口发布为开放接口后，删除时进行二次确认提示&lt;/li&gt; 
 &lt;li&gt;集成设计器数据库连接支持断开连接和重新连接功能（支持分布式启停）&lt;/li&gt; 
 &lt;li&gt;集成设计器 WebService API 支持 xml 解析功能&lt;/li&gt; 
 &lt;li&gt;修复元数据继承计算未正确处理由界面设计器创建的提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制视图到子模型时无法复制提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制时切换模型时验证不通过的问题&lt;/li&gt; 
 &lt;li&gt;修复从上游生成的菜单无法正确导出的问题&lt;/li&gt; 
 &lt;li&gt;修复集成设计器导出时出现 getDriver 序列化异常的问题&lt;/li&gt; 
 &lt;li&gt;修复数据可视化快捷日期选择错误的问题&lt;/li&gt; 
 &lt;li&gt;开放 dataflow-api 和 eip-designer-api 包&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;doc 教程文档：https://guide.oinone.top/zh-cn/DevManual/Tutorials/#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0%E5%90%8E%E7%AB%AF%E5%92%8C%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368943</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368943</guid>
      <pubDate>Tue, 19 Aug 2025 06:26:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>阿里云百炼部分模型将从限时免费改为限时额度</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里云百炼&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aliyun.com%2Fnotice%2F117503" target="_blank"&gt;宣布&lt;/a&gt;，部分模型调用计费将于北京时间 2025 年 8 月 29 日 03:00 起从限时免费变更为发放限时免费额度。用户将享受 100 万的免费 token 额度，免费额度用尽后平台将自动停止服务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;本次影响模型范围如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="168" src="https://oscimg.oschina.net/oscnet/up-d9dd38cf3830efd579ab292f1f353d732f6.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368942</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368942</guid>
      <pubDate>Tue, 19 Aug 2025 06:23:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>理想汽车可以写游戏代码，还能直接在车机上玩</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;理想汽车产品线负责人@老汤哥 Tango 在微博发布」理想同学「写游戏代码的视频，从响应需求到游戏生成持续了约 3 分钟时间。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-581559e21893b110ff447556e3176c9d526.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-004e5ec1d909771531577171d2f8b3a2f8a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ff70aabed01e3e77bca5848c5bc95395622.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-786b0c2666f658ebc6f9a070a9111477fa8.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-eda646532086b95eb00c99dde042c4f0d64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据理想官方介绍，理想同学手机、网页端已正式接入 DeepSeek R1-0528 最新版，切换「DeepSeek 模型」并开启「深度思考」模式即可体验最新的 AI 问答、创作能力。&lt;/p&gt; 
&lt;p&gt;据悉，更新后的 R1 模型在数学、编程与通用逻辑等多个基准测评中取得了当前国内所有模型中首屈一指的优异成绩，并且在整体表现上已接近其他国际顶尖模型，如 o3 与 Gemini-2.5-Pro。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368941</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368941</guid>
      <pubDate>Tue, 19 Aug 2025 06:22:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>a16z 最新 AI 报告：移动端 Top50 的应用中 22 款由中国开发</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;根据风险投资公司 Andreessen Horowitz 最新发布的一份专注于消费者 AI 领域的新&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fa16z.com%2F100-gen-ai-apps-5%2F" target="_blank"&gt;报告&lt;/a&gt;， ChatGPT 的竞争对手，如谷歌的 Gemini、xAI 的 Grok 以及 Meta AI，正在缩小与 ChatGPT 的差距。&lt;/p&gt; 
&lt;p&gt;该报告已是第五次发布。14 家公司第五次出现在顶级 AI 产品榜单上：ChatGPT、Perplexity、Poe、Character AI、Midjourney、Leonardo、Veed、Cutout、ElevenLabs、Photoroom、Gamma、QuillBot、Civitai 和 Hugging Face。&lt;/p&gt; 
&lt;p&gt;&lt;img height="288" src="https://oscimg.oschina.net/oscnet/up-504e271a3f148910434873e07a715ea1259.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该公司指出，除第一份报告外，其他五家公司都出现在了报告中，包括 Claude、DeepAI、Janitor AI、Pixelcut 和 Suno，分别代表通用人工智能应用、陪伴、图像编辑和音乐生成。&lt;/p&gt; 
&lt;p&gt;&lt;img height="305" src="https://oscimg.oschina.net/oscnet/up-2e8fb44cb4232566939732e5f0076528ea9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在本系列报告中，谷歌首次在顶级生成式 AI 消费网络产品榜单上增加了四个席位，分别是 Gemini、AI Studio、NotebookLM 和 Google Labs。这些产品现在拥有各自独立的域名，因此可以分别跟踪它们的增长情况。&lt;/p&gt; 
&lt;p&gt;&lt;img height="378" src="https://oscimg.oschina.net/oscnet/up-752ac9ec98d43bf0cfd8c70cd9bc8752cbd.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，在移动设备上，排名第二的应用 Gemini 正在缩小与排名第一的应用 ChatGPT 的差距，但月活跃用户数几乎只有后者的一半。Gemini 的 AI 技术在 Android 平台上的应用更为广泛，占据了近 90% 的月活跃用户群。在网页端，Gemini 也仅次于 ChatGPT，排名第二，约占 ChatGPT 访问量的 12%。&lt;/p&gt; 
&lt;p&gt;&lt;img height="323" src="https://oscimg.oschina.net/oscnet/up-e433ed7d554499571d95f76fdf1bb182f1c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该公司的 AI Studio 是一款面向开发人员的 &lt;span style="color:#212623"&gt;sandbox&lt;/span&gt;，用于使用 Gemini 模型进行构建，进入了十大 AI 网络产品榜单，位居第十位；NotebookLM 排名第十三。&lt;/p&gt; 
&lt;p&gt;&lt;img height="335" src="https://oscimg.oschina.net/oscnet/up-1d046af086fb1c731602a315ddfd7f282c1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Grok 在网页端排名第四，移动端排名第 23。考虑到 Grok 从 2024 年底还没有独立应用（在 X 上首次推出）到现在拥有多达 2000 万月活跃用户，这是一个快速的增长。2025 年 7 月， Grok 4 发布后，Grok 的用户增长了近 40% 。&lt;/p&gt; 
&lt;p&gt;&lt;img height="326" src="https://oscimg.oschina.net/oscnet/up-7276f5b0dc0753d758a96bbb20c8d2c2bba.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Meta 的通用助手在网络上排名第 46 位，与 3 月份相同，但它并未进入顶级移动 AI 应用榜单。部分原因是，有消息称 Meta AI 在未经用户知情同意的情况下，公开分享了部分用户的帖子。&lt;/p&gt; 
&lt;p&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-490ce7eaf61c586775a809535a4137b600c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;DeepSeek 和 Claude 在移动端的增长也趋于平缓，前者从峰值下降了 22%。在网页端，DeepSeek 的下降幅度更大，较 2025 年 2 月的峰值下降了 40% 以上。然而，Perplexity 和 Claude 仍在继续增长。&lt;/p&gt; 
&lt;p&gt;其他中国 AI 开发者也进入了网络榜单前 20 名，包括排名第 9 的阿里巴巴 AI 助手夸克（移动榜单第 47 位）；排名第 12 的豆宝（移动榜单第 4 位）；以及排名第 17 的 Kimi。这些公司都拥有中文网站，75% 的流量来自中国。&lt;/p&gt; 
&lt;p&gt;Web 榜单上还有七家公司在中国发展，但将其 AI 技术出口到全球：DeepSeek、Hailuo、Kling、SeaArt、Cutout Pro、Manus 和 Monica。&lt;/p&gt; 
&lt;p&gt;在移动端，排名前 50 的应用中有 22 款由中国开发，但主要在中国使用的只有 3 款。其中，排名靠前的包括美图（Photo &amp;amp; Video Editor, BeautyPlus, BeautyCam, Wink 和 Airbrush）、字节跳动（豆宝和 Cici）、Gauth 和 Hypic。&lt;/p&gt; 
&lt;p&gt;氛围编码初创公司 Lovable 和 Replit 此次首次亮相主榜单，而它们在 a16z 今年 3 月发布的榜单中均未入选。&lt;/p&gt; 
&lt;p&gt;&lt;img height="189" src="https://oscimg.oschina.net/oscnet/up-05006cf5ea2bdd595a0a2b22c96ea9aa400.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Andreessen Horowitz 还花时间列举了即将跻身顶级 AI 应用程序榜单的 AI 应用程序，包括网络上的 PixAI、Bolt、Blackbox AI、Clipchamp 和 Getliner，以及移动设备上的 Talkie、Seekee、Photo AI、AI Mirror 和 Arvin。&lt;/p&gt; 
&lt;p&gt;该公司指出，本月报告中的移动榜单中新上榜的应用（14 个）已经比以前更多，因为两个应用商店早已严厉打击 ChatGPT 的模仿者和克隆产品，从而让更多原创应用找到了立足之地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368938</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368938</guid>
      <pubDate>Tue, 19 Aug 2025 06:13:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Meta 计划推出超级政治行动委员会，力挺 AI 监管轻松化</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 公司计划成立一个新的超级政治行动委员会（PAC），旨在支持那些倡导轻松化人工智能 (AI) 监管的加州候选人。这一消息的发布恰逢其他硅谷巨头，如安德森・霍洛维茨和 OpenAI 的格雷格・布罗克曼，共同承诺为一个新的支持 AI 的超级&amp;nbsp;PAC 提供 1 亿美元的资金。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="242" src="https://oscimg.oschina.net/oscnet/up-e60c86bbcc18a7651619abeab3ca5d668e1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;据悉，Meta 将在其新成立的 PAC 「加州经济转型动员」（Mobilizing Economic Transformation Across California）中投入数千万美元。Meta 公共政策副总裁兼新 PAC 负责人布赖恩・瑞斯 (Brian Rice) 表示，萨克拉门托的监管环境可能会抑制创新，阻碍 AI 进步，并危及加州在科技领域的领导地位。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年早些时候，Meta 的游说力量曾针对加州州参议员斯科特・维纳（Scott Wiener）的 SB-53 法案进行干预，该法案要求 AI 公司公布安全和安保协议，并在发生安全事件时发布报告。去年，Meta 还帮助阻止了广受期待的《儿童在线安全法案》。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 已经向各党派的下级候选人捐款，而这个新 PAC 的成立则表明了其希望在包括 2026 年下任州长选举在内的州级选举中产生影响的意图。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368931</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368931</guid>
      <pubDate>Tue, 19 Aug 2025 05:39:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>英伟达单季营收 467 亿美元暴涨 56%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;英伟达（&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnvidianews.nvidia.com%2Fnews%2Fnvidia-announces-financial-results-for-second-quarter-fiscal-2026" target="_blank"&gt;公布&lt;/a&gt;截至 2025 年 7 月 27 日的第二季度营收为 467 亿美元，环比增长 6%，同比增长 56%。NVIDIA Blackwell 数据中心营收环比增长 17%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第二季度，中国客户未售出 H20 芯片。NVIDIA 受益于此前释放的 1.8 亿美元 H20 库存，这得益于此前向中国境外客户无限制销售约 6.5 亿美元的 H20 芯片。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 毛利率分别为 72.4% 和 72.7%。若不计入 1.8 亿美元释放，本季度非 GAAP 毛利率应为 72.3%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 稀释每股收益分别为 1.08 美元和 1.05 美元。若不计 1.8 亿美元释放及相关税费影响，本季度非 GAAP 稀释每股收益为 1.04 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 创始人兼首席执行官黄仁勋表示：「Blackwell 是全世界翘首以盼的 AI 平台，它实现了非凡的跨越式发展——Blackwell Ultra 的产量正在全速提升，市场需求也异常旺盛。NVIDIA NVLink 机架级计算技术具有革命性，它的到来恰逢推理 AI 模型推动训练和推理性能数量级提升的时代。AI 竞赛已拉开帷幕，而 Blackwell 正是这场竞赛的核心平台。」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2026 财年上半年，NVIDIA 以股票回购和现金股息的形式向股东返还了 243 亿美元。截至第二季度末，公司剩余的股票回购授权金额为 147 亿美元。2025 年 8 月 26 日，董事会批准公司额外增加 600 亿美元的股票回购授权，且该授权金额无有效期。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 将于 2025 年 10 月 2 日向 2025 年 9 月 11 日登记在册的所有股东支付下一季度现金股息，每股 0.01 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="175" src="https://oscimg.oschina.net/oscnet/up-0884edd1756e5c3e624f756bf9373b7e007.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bf88c6496d006ca5fa7f48b7ede76abe46b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 对 2026 财年第三季度的展望如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc"&gt; 
 &lt;li&gt;预计营收为 540 亿美元，上下浮动 2%。该公司在展望中未考虑任何 H20 对华出口。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 毛利率分别为 73.3% 和 73.5%，上下浮动 50 个基点。公司预计今年年底的非 GAAP 毛利率将保持在 70% 左右。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 运营费用分别约为 59 亿美元和 42 亿美元。预计 2026 财年全年运营费用增长率将达到 30% 以上。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 其他收入和支出约为 5 亿美元的收入，不包括非流通股本证券和公开持有的股权证券的损益。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 税率为 16.5%，上下浮动 1%，不包括任何单项项目。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368915</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368915</guid>
      <pubDate>Tue, 19 Aug 2025 03:44:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智谱开源项目阅读工具 Zread 发布更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/news/361635" target="_blank"&gt;Zread&lt;/a&gt; 是智谱为帮助用户阅读和理解复杂开源项目打造的 AI 工具，其功能类似于 Cognition 推出的 DeepWiki，优点是支持中文，目前已经索引了大部分热门开源项目，冷门代码仓库可以申请发起索引。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-47cb47c2059cdf185a53799496a0fbd8091.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zread 近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FZread_ai%2Fstatus%2F1960734929639145494" target="_blank"&gt;发布更新&lt;/a&gt;增加了三大功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;根据用户设定的主题，提供个性化的代码仓库推荐&lt;/li&gt; 
 &lt;li&gt;支持查看 AI 回答背后的搜索来源，增加透明度&lt;/li&gt; 
 &lt;li&gt;支持一键刷新仓库，以方便用户获取最新的代码更新&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;体验：&lt;em&gt;https://zread.ai/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368914</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368914</guid>
      <pubDate>Tue, 19 Aug 2025 03:43:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenSearch Software Foundation 一周年庆</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;作为 OpenSearch 项目的中立平台，&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;OpenSearch&amp;nbsp;&lt;/span&gt;&lt;span&gt;Software Foundation 庆祝其在 Linux 基金会下成立一周年。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;公告称，成立首年，基金会致力于发展和壮大 OpenSearch 开源平台，推动 AI 驱动的搜索、可观测性和分析技术。通过持续的功能开发、社区参与扩大和行业融合，OpenSearch 已成为现代数据驱动应用的基础技术。随着行业向 Agentic AI 转型，OpenSearch Software Foundation 将继续打造高性能、完全开源的信息检索平台，支持更快、更高效的 AI 开发与实时洞察。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;img height="264" src="https://oscimg.oschina.net/oscnet/up-e3edcc23f4749032fea4ca2f17aba64a082.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;Linux 基金会法律与战略项目高级副总裁 Mike Dolan 表示：「OpenSearch 在 Linux 基金会下的首年进展，展现了开放协作在应对现代数据挑战中的力量。项目增长和社区活跃证明了开源在现代搜索和分析基础设施中的关键作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;自 2024 年 9 月基金会成立以来，OpenSearch 项目下载量同比增长 78%，累计下载超过 10 亿次。首年成果包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;社区活跃度提升，超 400 家活跃贡献组织，贡献超过 8800 次&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;全球协作增强，美国、德国、英国、澳大利亚和印度贡献最多&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;会员扩展至 16 家新组织，新增 ByteDance、DataStax、DTEX 和 Seacom Srl&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;组建由 15 名成员组成的技术指导委员会，涵盖 Aryn、AWS、ByteDance、IBM、Paessler、Salesforce、SAP 和 Uber 等企业与独立机构&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;3.0、3.1 和 3.2 版本亮点：&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量引擎和 Agentic AI 能力增强，推动生成式 AI 创新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量数据库功能增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过 Model Context Protocol (MCP) 和 GPU 加速，支持原生 Agentic AI，简化开发部署&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;支持新型 FP16、Byte 和二进制向量类型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提高资源利用效率，构建更广泛的 GPU 加速应用&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本引入的实验性查询类型，支持自然语言交互，触发基于 Agent 的查询理解、规划与执行&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 记忆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 实验功能，支持 AI 代理利用语义搜索调用历史上下文，提升后续会话质量&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;混合搜索速度和效率提升，实现实时洞察&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;搜索性能增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：OpenSearch 3.2 查询速度较 1.3 版本快 11 倍，混合搜索算法提升查询速度达 65%，吞吐量提升 3.5 倍&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;gRPC 支持正式发布&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：加快数据传输与处理效率&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;近似查询框架升级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本提升分页搜索、实时仪表盘和分析工作负载响应速度，扩展所有数值字段类型的近似查询能力&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;流式聚合功能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 实验功能，基于流式传输，优化资源分配，实现协调器单点扩展&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;高级可观测性功能提升准确性与效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;跨集群 Trace 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支持企业跨集群无缝追踪分析&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Piped Processing Language (PPL) 升级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升复杂查询性能和准确性，简化复杂日志分析流程&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;平台现代化，助力未来社区协作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc; margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;升级 Lucene 10&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升性能和可维护性，支持日益壮大的开源开发者社区贡献&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;OpenSearch Software Foundation 治理委员会主席、AWS 产品管理总监 Carl Meadows 表示：「进入第二年，我们将继续发力，打造 AI 时代最强大的开源搜索、分析和可观测性平台。社区和会员的坚实基础让我们能应对行业挑战，持续交付开发者和企业信赖的技术。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;行业领导者贡献亮点：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;ByteDance&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 OpenSearch k-NN 贡献派生源功能，并优化分段复制协议性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;IBM DataStax&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献 JVector 引擎，为向量搜索提供纯 Java 实现并支持 AstraDB 集成&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Intel&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献 SIMD 支持，提升 k-NN 在支持硬件上的性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;SAP&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：推动 FIPS 合规支持，满足特定安全规范需求&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Uber&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献基于拉取的采集方式，简化客户端配置，支持 OpenSearch 直接集成现有系统&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368909</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368909</guid>
      <pubDate>Tue, 19 Aug 2025 03:35:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Linux 内核贡献者借助 AI 判断是否回退补丁到稳定版本</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Linux 长期支持（LTS）分支的维护工作正在尝试引入生成式 AI 技术，以帮助判断哪些补丁需要回退到稳定版本。&lt;/p&gt; 
&lt;p&gt;目前，开发者通常会在补丁中添加 「CC: stable」 标签，提醒维护者将其回退。但不少补丁并未明确标注，导致 LTS 维护负担较重。为此，Linux LTS 联合维护者、现任 NVIDIA 工程师 Sasha Levin &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fstable%2F20250825121505.2983941-5-sashal%40kernel.org%2F" target="_blank"&gt;尝试&lt;/a&gt;了基于大语言模型（LLM）的新流程，让 AI 自动分析补丁的重要性，并生成回退建议与说明。&lt;/p&gt; 
&lt;p&gt;在近期提交的部分补丁中，已经可以看到 AI 生成的提示，例如 「Backport Status: YES」，并附带理由说明，尽管 Levin 也坦言这些解释可能并不完全可靠。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45e58d6544cd83524a2549342d46ca5c1fc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;业内认为，这种做法有望显著减轻维护者压力，加快企业用户获取稳定更新的速度。但也有人担心 AI 可能出现「幻觉」，错误推荐不适合回退的补丁，从而将风险引入 LTS 版本。因此，社区正在讨论如何在流程中明确标注 AI 的参与，并制定相关规范，确保透明与安全。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</guid>
      <pubDate>Tue, 19 Aug 2025 03:31:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>构建 AI 智能体的实用开源技术栈</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;编者按：&lt;/strong&gt; 面对市面上琳琅满目的开源工具，我们往往迷失在选择的焦虑中 —— 哪些工具真正经得起生产环境的考验？哪些只是看起来很酷的演示项目？更重要的是，如何避免把宝贵的开发时间浪费在那些半成品工具上？&lt;/p&gt; 
 &lt;p&gt;我们今天为大家带来的文章，作者的观点是：构建可靠的 AI 智能体需要的不是最新最炫的工具，而是经过实战检验、务实可靠的开源技术栈。&lt;/p&gt; 
 &lt;p&gt;本文作者系统梳理出一套经过实战检验的开源技术栈，涵盖智能体开发的九个核心领域：从用于构建和编排智能体的框架 ，到计算机与浏览器操控、语音交互、文档理解、记忆机制等功能模块；从测试评估到监控部署的全流程工具链；最后还包括仿真环境和垂直领域的专用智能体。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;作者 | Paolo Perrone&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;编译 | 岳扬&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;还记得在某个周末，我坐下来，坚信自己终于能构建一个像样的研究助手智能体原型了。不需要多么高大上 —— 只要它能读取 PDF、提取关键信息、也许还能回答几个后续问题就行。本该很简单对吧？&lt;/p&gt; 
&lt;p&gt;结果，我花了整整两天时间，在文档不全的代码仓库、沉寂的 GitHub issues 和模糊不清的博客文章间反复折腾。有个工具看起来很靠谱，直到我发现它已经八个月没更新了。另一个工具需要启动四个不同的服务，仅仅是为了解析一份文档。最终，我的「智能体」连文件名都几乎读不出来，更别提内容了。&lt;/p&gt; 
&lt;p&gt;但支撑我做下去的不是挫败感 —— 而是好奇。我想知道：真正的智能体开发者究竟在用哪些工具？不是那些创投圈热捧的明星项目，而是那些你会默默安装、保留在你的技术栈中、并真心信赖的工具。那些不需要三页 Notion 文档来解释的工具。&lt;/p&gt; 
&lt;p&gt;这次探索让我发现了一套出乎意料扎实的开源库 —— 这些工具轻量、可靠，且专为开发者而打造。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;所以，如果你还在为智能体跑不通而焦头烂额，本文就是为你准备的。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;01 那么，你准备好构建 AI 智能体了吗？&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;你可能会问：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;人们用什么来构建语音智能体？&lt;/li&gt; 
 &lt;li&gt;解析文档的最佳开源工具是什么？&lt;/li&gt; 
 &lt;li&gt;如何在不把向量数据库（vector DB）像万能胶一样到处粘贴的情况下给我的智能体添加记忆功能？&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;本指南并未试图覆盖市面上所有工具 —— 这是我有意为之。这是一份经过筛选的工具清单，是我真正使用过、保留在我的技术栈中、并在构建智能体原型时会反复使用的工具。不是那些在演示中看起来很酷或在每个炒作帖子里出现的工具，而是那些能帮助我从「想法（idea）」推进到「能工作的东西（working thing）」、而不会让人迷失方向的工具。&lt;/p&gt; 
&lt;p&gt;以下是按类别划分的技术栈：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）用于构建和编排智能体的框架（Frameworks for Building and Orchestrating Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你是从零开始构建智能体，可以从这里开始。这些工具能够帮助你结构化智能体的逻辑 —— 做什么、何时做以及如何处理工具。可以将其视为将原始语言模型转变为更自主的智能体的核心大脑。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）计算机与浏览器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一旦你的智能体能制定计划，它就需要执行操作。这一类工具能让你的智能体点击按钮、在数据字段中键入内容、抓取数据、以及像人类一样操作应用程序或网站。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）语音功能（Voice）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你的智能体需要说话或聆听，这些工具负责处理音频部分 —— 将语音转为文本（speech to text），再将文本转回语音（text to speech）。适用于免提场景或语音优先型智能体（voice-first agents）。有些工具甚至能很好地处理实时对话。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）文档理解（Document Understanding）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;大量现实世界的数据存在于 PDF、扫描文件或其他杂乱格式中。这些工具能够帮助你的智能体读取和理解这些内容 —— 无论是发票、合同还是基于图像的文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）记忆（Memory）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;要实现持续学习的能力，你的智能体就需要记忆功能。这些工具库能帮助智能体记住刚刚发生了什么、你之前告诉过它什么，甚至能随时间的推移构建长期用户画像。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;6）测试与评估（Testing and Evaluation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;系统总会出故障。这些工具可以帮助你在系统上线前发现问题 —— 通过预设用户操作路径、模拟交互，并检查智能体的行为是否符合预期。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;7）监控与可观测性（Monitoring and Observability）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当智能体正式上线后，你需要知道它在做什么以及表现如何。这些工具能够帮助你跟踪使用情况、调试出现的问题并分析成本或延迟影响。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;8）仿真环境（Simulation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在将智能体投入真实场景前，需要先在安全的沙箱世界中测试它。仿真环境让你能在受控条件中进行实验、优化决策逻辑并发现边界案例。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;9）垂直领域智能体（Vertical Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;并非所有东西都需要从零构建。这些是为特定工作（如编程、研究或客户支持）打造的预置智能体。你可以直接使用它们，或根据你的工作流进行定制。&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;02 用于构建和编排智能体的框架&lt;/strong&gt; &lt;strong&gt;(Frameworks for Building and Orchestrating Agents)&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要打造真正能解决问题的智能体，你需要一个扎实的底层架构 —— 它必须能驾驭工作流、记忆机制和工具协同，而不是沦为一堆东拼西凑的脚本代码。这些框架为你的智能体提供了所需的结构，使其能够准确理解目标、制定可行方案并执行到底。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;CrewAI&lt;/strong&gt;&amp;nbsp;— 协调多个协同工作的智能体。非常适合需要协调和基于角色行为的任务。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agno&lt;/strong&gt;&amp;nbsp;— 专注于记忆机制、工具使用和长期交互。对于需要记忆能力和适应能力的 AI 助手来说非常理想。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Camel&lt;/strong&gt;&amp;nbsp;— 专为多智能体协同、仿真推演和任务分工场景打造。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGPT&lt;/strong&gt;&amp;nbsp;— 通过「规划-执行」闭环实现复杂工作流的自动化运行。最适合需要独立运行的智能体。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGen&lt;/strong&gt;&amp;nbsp;— 让智能体之间进行协作，共同解决复杂问题。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SuperAGI&lt;/strong&gt; — 简化的设置，用于快速构建和部署自主智能体（autonomous agents）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Superagent&lt;/strong&gt;&amp;nbsp;— 一个灵活的开源工具包，用于创建自定义 AI 助手。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain &amp;amp; LlamaIndex&lt;/strong&gt;&amp;nbsp;— 用于智能记忆管理、高效检索和工具链整合的首选工具。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;03 计算机与浏览器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;当你的智能体能推理、思考后，下一步就是让它能采取行动。这意味着智能体要像人类一样与计算机或网络进行交互 —— 点击按钮、填写表单、浏览页面并执行命令。这些工具在推理（reasoning）与行动（action）之间架起了一座桥梁，让智能体能在现实场景中运作。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Open Interpreter&lt;/strong&gt;&amp;nbsp;— 将自然语言翻译成能在你机器上执行的代码。想移动文件或运行脚本？描述需求即可。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Self-Operating Computer&lt;/strong&gt;&amp;nbsp;— 让智能体完全控制你的桌面环境，使其能像真人一样与操作系统（OS）进行交互。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agent-S&lt;/strong&gt;&amp;nbsp;— 这是一个灵活的框架，允许 AI 智能体像真实用户那样操作各类应用程序（apps）、工具（tools）和交互界面（interfaces）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LaVague&lt;/strong&gt;&amp;nbsp;— 使网页智能体（web agents）能够实时浏览网站、填写表单并做出决策，是实现浏览器任务自动化的理想选择。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Playwright&lt;/strong&gt;&amp;nbsp;— 跨浏览器自动化网页操作。适合测试或模拟用户流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Puppeteer&lt;/strong&gt;&amp;nbsp;— 控制 Chrome 或 Firefox 的可靠工具。非常适用于数据抓取和前端行为自动化。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;04 语音功能（Voice）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;语音是人类与 AI 智能体交互最直观的方式之一。这些工具处理语音识别（speech recognition）、语音合成（voice synthesis）及实时交互（real-time interactions） —— 让你的智能体更具「人性化」。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;4.1 语音对话（Speech2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Ultravox&lt;/strong&gt;&amp;nbsp;— 顶级的语音对话模型，可流畅处理实时语音对话。响应迅速灵敏。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Moshi&lt;/strong&gt;&amp;nbsp;— 语音对话任务的另一个强劲选择。在实时语音交互方面表现可靠，但 Ultravox 在性能上更胜一筹。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Pipecat&lt;/strong&gt;&amp;nbsp;— 用于构建语音交互智能体的全栈框架。支持语音转文本、文本转语音，甚至基于视频的交互（video-based interactions）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.2 语音识别（Speech2text）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Whisper&lt;/strong&gt;&amp;nbsp;— OpenAI 的语音转文本模型 —— 适用于跨多语言的转录和语音识别。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Stable-ts&lt;/strong&gt;&amp;nbsp;— 针对 Whisper 的、对开发者更友好的封装工具。添加了时间戳和实时支持，非常适合对话型智能体。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Speaker Diarization 3.1&lt;/strong&gt;&amp;nbsp;— Pyannote 的说话人分离模型。对多人对话及会议类音频等场景至关重要。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.3 语音合成（Text2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;ChatTTS&lt;/strong&gt;&amp;nbsp;— 目前我发现的最佳模型。速度快、稳定，满足大多数生产需求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ElevenLabs（商业版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 当音质要求高于开源产品时，这是首选方案。提供高度自然的拟真语音，并支持多种风格。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Cartesia（商业版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 如果你追求超越开源模型表现的高清语音合成，这是另一个强有力的商业选项。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.4 实用工具（Miscellaneous Tools）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vocode&lt;/strong&gt;&amp;nbsp;— 用于构建语音驱动的大语言模型智能体的工具包。轻松连接语音输入/输出与语言模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 用于测试和评估语音智能体的框架。可调试优化提示词、语音角色（voice persona）或模型配置（model setup）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;05 文档理解（Document Understanding）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;大部分有价值的业务数据仍以非结构化格式存在 —— PDF 文件、扫描文件、基于图像的报表。这些工具能够帮助你的智能体读取、提取并理解这些复杂内容，而无需依赖脆弱的 OCR 处理流程。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Qwen2-VL&lt;/strong&gt;&amp;nbsp;— 阿里巴巴推出的强大视觉语言模型。在处理混合图像与文本的文档任务时，表现优于 GPT-4 和 Claude 3.5 Sonnet，非常适合处理复杂的实际业务格式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DocOwl2&lt;/strong&gt;&amp;nbsp;— 为文档理解场景打造的轻量级多模态模型，无需依赖 OCR。快速高效，且在从杂乱的输入中提取内容结构和语义时准确度惊人。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;06 记忆（Memory）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;没有记忆机制的智能体会陷入一种将每次交互都视为初次接触的循环。这些工具赋予它们回忆过往对话、追踪用户偏好和建立持续交互记忆的能力。正是这种能力，让一次性的助手逐步进化为持续增值的智能伙伴。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Mem0&lt;/strong&gt;&amp;nbsp;— 可自我迭代的记忆层，让智能体能够适配先前的交互。非常适合构建更个性化、持久化的 AI 体验。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Letta（前身为 MemGPT）&lt;/strong&gt; &amp;nbsp;— 为 LLM 智能体增加长期记忆和工具使用能力。可视为智能体的核心支架，使其具备记忆、推理和进化的能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain&lt;/strong&gt;&amp;nbsp;— 包含即插即用的记忆组件，用于追踪对话历史和用户上下文 —— 在构建需跨多轮对话保持连续性的智能体时非常实用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;07 测试与评估（Testing and Evaluation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;当你的智能体不再仅限于聊天，而是开始浏览网页、做出决策、发出语音时，你需要预判它在边界情况中的表现。这些工具可帮助你测试智能体在不同场景下的行为、及早发现 bug，并定位系统故障点。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 测试语音智能体的综合框架，确保语音识别和响应准确且自然。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 用于追踪和通过基准测试测试 AI 智能体的工具集，帮助你在问题影响用户之前发现隐患并优化性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentBench&lt;/strong&gt;&amp;nbsp;— 评估 LLM 智能体的基准测试工具，覆盖从网页浏览到游戏等多种任务场景，确保通用性与有效性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;08 监控与可观测性（Monitoring and Observability）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要确保 AI 智能体大规模地部署运行时能够流畅高效地工作，你需要对它们的性能与资源消耗进行监控。这些工具提供的关键可观测性数据，能够助你监控智能体行为、优化资源，并在问题波及用户前及时拦截。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;openllmetry&lt;/strong&gt;&amp;nbsp;— 基于 OpenTelemetry 为 LLM 应用提供端到端的可观测性，清晰展示性能表现，并帮助你快速排查故障和优化系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 一款全面的监控工具，能够追踪智能体性能、成本开支及基准测试数据，确保其高效运行且成本可控。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;09 仿真环境（Simulation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;在部署前模拟真实环境具有突破性意义。这些工具让你能创建受控的虚拟空间，使智能体在其中互动、学习并做出决策，而无需承担在实际环境中可能产生的意外后果。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;AgentVerse&lt;/strong&gt;&amp;nbsp;— 支持在多种应用程序和模拟环境中部署基于 LLM 的多智能体，确保其在各种环境下都能有效运作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Tau-Bench&lt;/strong&gt;&amp;nbsp;— 评估智能体在特定行业（如零售业/航空业）中用户交互表现的基准测试工具，确保专业领域任务的流畅执行。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ChatArena&lt;/strong&gt;&amp;nbsp;— 一个多智能体语言游戏环境，智能体在其中交互协作，适合在安全受控空间内研究智能体的行为模式并优化沟通模式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AI Town&lt;/strong&gt;&amp;nbsp;— AI 角色进行社交互动、决策测试和现实场景模拟的虚拟环境，帮助精细化调优智能体行为。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Generative Agents&lt;/strong&gt;&amp;nbsp;— 斯坦福的智能体项目，专注于模拟人类复杂行为，非常适合在社交语境中测试记忆与决策能力。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;10 垂直领域智能体（Vertical Agents）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;垂直领域智能体是解决特定行业问题或优化专业任务的专用工具。尽管这类工具的生态系统正在不断发展，但还是分享我个人使用过并认为特别有用的几款工具：&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;10.1 编程开发（Coding）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;OpenHands&lt;/strong&gt;&amp;nbsp;— 基于 AI 的软件开发平台，可自动化编程任务并加速开发流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;aider&lt;/strong&gt;&amp;nbsp;— 可直接集成到终端的结对编程工具（pair programming tool），提供直接嵌入编程环境的 AI 协作编程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Engineer&lt;/strong&gt;&amp;nbsp;— 用自然语言构建应用程序；用户只需描述需求，AI 将解析用户意图并生成代码。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;screenshot-to-code&lt;/strong&gt;&amp;nbsp;— 将设计图转换为采用 HTML/Tailwind/React/Vue 的完整网站，快速实现设计稿转代码。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.2 学术研究（Research）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Researcher&lt;/strong&gt;&amp;nbsp;— 一款能够进行全面研究、分析数据并撰写报告的自主智能体（autonomous agent），能够简化研究流程。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.3 数据库交互（SQL）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vanna&lt;/strong&gt;&amp;nbsp;— 使用自然语言查询与 SQL 数据库交互。无需编写复杂的 SQL 命令，提问即可获取数据。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;11 总结（Conclusion）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;回顾我早期构建研究助手时的尝试，我意识到自己当初把问题复杂化了。那个项目最终是一团糟 —— 充斥着过时的代码、半成品的工具，以及连 PDF 这种简单文件都处理得力不从心的系统。&lt;/p&gt; 
&lt;p&gt;但正是在这次失败中我收获最多。&lt;/p&gt; 
&lt;p&gt;关键不在于寻找最完美的工具，而在于坚持有效的方案并保持简单。那次教训让我明白：&lt;strong&gt;构建最可靠的智能体，凭的是务实、直接的技术栈，而非追逐每一款花哨的新工具。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;成功的智能体开发无需重复造轮子。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心在于选择适合目标任务的工具、有条不紊地整合它们，并持续不断地优化智能体原型。&lt;/strong&gt; 无论你是要自动化工作流程、构建语音智能体，还是解析文档，一套精心挑选的技术栈都能让流程更流畅高效。&lt;/p&gt; 
&lt;p&gt;因此，立即行动，大胆尝试，让好奇心引领你前行。技术生态系统正在不断演进，可能性是无穷无尽的。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;应原作者要求，在此放置 Substack 订阅链接和宣传语：&lt;/p&gt; 
&lt;p&gt;&amp;gt; 作为科技内容从业者，还在为粉丝增长发愁？ &amp;gt; &amp;gt; 《The Tech Audience Accelerator》正是为你量身打造的必备指南 —— 专为认真扩大受众群体的科技创作者而生。 &amp;gt; &amp;gt; 这里浓缩了我实现 3000 万+ 曝光量（且持续攀升）的实战方法论、即用模板与高效策略， &amp;gt; &amp;gt; 所有干货，皆经市场验证。 &amp;gt; &amp;gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechaudienceaccelerator.substack.com%2F" target="_blank"&gt;https://techaudienceaccelerator.substack.com/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本期互动内容 🍻&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;❓分享一次你构建 AI 智能体时最让你血压飙升的工具使用踩坑经历！🫠 是文档失踪？还是兼容性噩梦？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本文经原作者授权，由 Baihai IDP 编译。如需转载译文，请联系获取授权。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdecodingml.substack.com%2Fp%2Fthe-open-source-stack-for-ai-agents" target="_blank"&gt;https://decodingml.substack.com/p/the-open-source-stack-for-ai-agents&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/IDP/blog/18689820</link>
      <guid isPermaLink="false">https://my.oschina.net/IDP/blog/18689820</guid>
      <pubDate>Tue, 19 Aug 2025 03:19:00 GMT</pubDate>
      <author>原创</author>
    </item>
  </channel>
</rss>
