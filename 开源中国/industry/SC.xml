<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 25 Jun 2025 16:45:51 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>低代码平台这么多，Oinone 有何特别之处？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;Oinone 是一个低代码平台，但又跟传统低代码平台不一样。&lt;/p&gt; 
&lt;p&gt;对此，数式 Oinone 引入了一个新概念——企业级产品化引擎，是一个&lt;span style="background-color:#ffffff; color:#1f2328"&gt;集标准化研发和敏捷交付于一体的平台。从公开资料来看，&lt;/span&gt;Oinone&amp;nbsp;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;已经是一个很成熟的平台了。并且该&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#1a1a1a"&gt;平台的内核源码也开源了，开源版本具备一些基础特性和能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;仅仅基于 Oinone 这一套统一架构，就能支撑产品打磨与交付复用，软件公司也能像搭乐高一样构建属于自己的标准产品体系。如此一来，长期存在的标品开发与定制交付割裂难题就解决了，让研发重心真正回归产品打磨，避免定制绑架，积累企业自身的产品化能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;听起来有些夸张，具体是怎么实现的呢？7 月 4 日晚，&lt;span style="color:#2980b9"&gt;数式 Oinone 技术总监王海明&lt;/span&gt;将做客开源中国直播栏目《技术领航》，在实战环节，王海明将全面展示数式 Oinone 在数字化建设中的全栈能力：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先分别从后端研发与前端开发视角，呈现开箱即用的标准化功能模块如何快速满足企业基础需求。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
  &lt;li&gt;随后重点展开个性化二次开发深度演示：依次剖析后端业务逻辑定制、前端交互优化设计，以及无代码模式下的可视化配置方案，完整呈现从标准化产品到个性化定制的平滑过渡路径，帮助观众理解如何基于统一平台实现"标准化功能直接调用+个性化需求灵活扩展"的敏捷开发模式。&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;strong&gt;至于 Oinone &amp;nbsp;所宣传的&lt;span style="background-color:#ffffff; color:#1f2328"&gt;「集标准化研发和敏捷交付于一体」，是不是夸张，到时候就知道了！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;直播主题：&lt;/strong&gt;满足个性化需求，企业级产品化引擎 Oinone 实战演示&lt;/p&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
 &lt;/ul&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;直播时间：&lt;/strong&gt;7 月 4 日周五 19:00-20:00&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;直播平台：&lt;/strong&gt;视频号 「OSC 开源社区」&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;直播嘉宾：&lt;/strong&gt;王海明，数式 Oinone 技术总监&lt;/p&gt; 
&lt;div&gt; 
 &lt;p&gt;&lt;strong&gt;直播亮点：&lt;/strong&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;详解低代码平台 Oinone 一体化架构及其全栈能力&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;如何基于 Oinone 搭建业务产品？如何基于业务产品做交付？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;作为一名研发，要如何脱离交付项目「泥潭」？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;实操演示：标准化开箱即用，以及个性化二次开发深度演示&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;img height="706" src="https://oscimg.oschina.net/oscnet/up-a8fb468294a2b29c1ed3636883550f65bce.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;ul&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;strong&gt;直播福利：&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;p&gt;本次直播中，我们将有 5 轮抽奖，参与就有机会获得 OSC T 恤、马建仓蛇年公仔（限量版）、代码圣杯、马克杯、冰箱贴等。特别值得一提的是，我们将送出 5 本由数式 CEO 陈鹏程撰写的技术书籍《精讲面向软件公司的低代码平台》，立即扫码预约直播吧！&lt;/p&gt; 
&lt;p&gt;&lt;img height="374" src="https://oscimg.oschina.net/oscnet/up-13a1563ccd37e58e03a903a2981244ad66e.jpg" width="400" referrerpolicy="no-referrer"&gt;&lt;br&gt; &lt;br&gt; 我们还建了一个交流群，可以经进来唠唠嗑，或者你有好的开源项目，也欢迎推荐过来呀~&lt;/p&gt; 
&lt;p&gt;&lt;img height="200" src="https://oscimg.oschina.net/oscnet/up-500a286b215fe8d8b5219b218bdd2e9d451.png" width="200" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;strong&gt;关于数式 Oinone&lt;/strong&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;数式 Oinone 是一款企业级产品化引擎：用低代码驱动标准化研发与敏捷交付的一体化平台。围绕 「企业级产品化、标准化研发与敏捷交付」 三项核心突破，数式 Oinone 为开发者、研发团队带来从能力沉淀到规模化交付的完整体系。&lt;/p&gt; 
  &lt;p&gt;官网：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oinone.top%2F" rel="nofollow" target="_blank"&gt;https://www.oinone.top/&lt;/a&gt;&lt;/p&gt; 
  &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
  &lt;h1&gt;6.2.0 版本&lt;/h1&gt; 
  &lt;ul&gt; 
   &lt;li&gt;GitHub: 
    &lt;ul&gt; 
     &lt;li&gt;后端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Foinone%2Foinone-pamirs" rel="nofollow" target="_blank"&gt;https://github.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
     &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Foinone%2Foinone-kunlun" rel="nofollow" target="_blank"&gt;https://github.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;Gitee: 
    &lt;ul&gt; 
     &lt;li&gt;后端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs" rel="nofollow"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
     &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun" rel="nofollow"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;hr&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《技术领航》是开源中国 OSCHINA 推出的一档直播栏目，旨在为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开源软件、商业产品、前沿技术、知名品牌活动等各类项目&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供一个展示平台，基本上每周五晚上开播&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;栏目邀请项目的创始人、核心团队成员或资深用户作为嘉宾，通过路演式直播分享项目的亮点和经验，有助于提高项目的知名度，吸引更多的用户和开发者关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你手上也有好的项目，想要跟同行交流分享，欢迎联系我，栏目随时开放～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"&gt;&lt;img height="537" src="https://oscimg.oschina.net/oscnet/up-4dd54c1b0b817689ceefa15aa66d79cfae8.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3859945/blog/18638239</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/18638239</guid>
      <pubDate>Sat, 10 May 2025 13:55:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>一个 40 岁程序员，想做 AI 时代的 HTTP 协议</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;大家好，我叫常高伟。写下这篇东西的时候，我已经离开阿里快一年了。很多人问我，一个在华为、阿里干了近二十年的老程序员，40 多岁了，为什么还要出来折腾？折腾的，甚至还是一个听起来很不现实，甚至有点疯狂的项目：为 AI Agent 之间的沟通，制定一套开放的网络协议（ANP）。有人给我起了个外号，叫「当代堂吉诃德」。这个比喻很形象，因为刚开始的时候，除了一个遥远的「故事」，我一无所有。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;一、一个困扰我十年的问题&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;故事的起点，要回到十多年前。那时我还在通信行业工作。在通信行业，移动、联通、电信的设备天生就是要互联互通的，这是刻在骨子里的规则。可在互联网，我发现微信、来往、飞信，彼此都是孤岛。我当时很困惑，以为是技术问题，想着做个「个人门户」就能解决。很快就发现自己太天真了，大厂的数据主权是他们最核心的壁垒，不可能开放。后来我明白了，这是商业问题，封闭生态的效率在当时就是更高。&lt;/p&gt; 
&lt;p&gt;这个问题，就这么断断续续地在我脑子里盘旋了十年。直到 2024 年，AI Agent 的浪潮来了。我突然意识到，转机出现了。未来的个人 AI 助手，要想发挥最大价值，就必须能访问所有信息。这意味着数据必须回归个人，互联网必须再次走向开放。当 AI 处理任务的成本足够低，开放网络的综合效率（使用体验、使用成本（交易成本+时间成本））终将超过封闭的平台。&lt;/p&gt; 
&lt;p&gt;这是我思考的「第一性原理」。而要支撑起一个开放、互通的智能体网络，最底层的基石，就是一套统一的协议——就像 HTTP 之于 Web 时代一样。并且我发现，这里存在一个巨大的技术空白。那个念头压不住了，隔三差五就往外冒。我花了一整周的时间反复推演，最后确认这不是妄想。尽管对 40 多岁、断了收入、未来能不能再找到工作这些问题充满了恐惧，但一种使命感推着我必须走出去。&lt;/p&gt; 
&lt;p&gt;我后来一篇随笔写过：「我不知道多少人能够听到，属于你的使命召唤？我当时真的听到了」。这种感觉当时真的很清晰。并且，我真的不想错过这次技术浪潮。「当一个大的技术浪潮来临的时候，我们要做的只有一件事情：保持在场（Be There）」。&lt;/p&gt; 
&lt;p&gt;离开阿里，也许是保持在场唯一的方法。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二、无响应之地，即绝望之地&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;离开后的头半年，是我最难熬的日子。我不敢告诉任何人我在做什么，因为连我自己都觉得这事儿「很大很空」，像天方夜谭。我只是闷头看资料、写代码，拿出了协议的第一个版本，发到网上。然后，石沉大海。没有正反馈，也没有负反馈。那种感觉，就像对着深渊呼喊，却连一点回声都没有。&lt;/p&gt; 
&lt;p&gt;这是一种绝望的感觉：无响应之地，即绝望之地。&lt;/p&gt; 
&lt;p&gt;后来我试着把想法发给朋友，大多没了下文。有的朋友比较直接：「这事未来可能需要，但做不成，也不该是你来做。」自我怀疑像野草一样疯长。我混迹在各种技术社群，却不敢介绍自己的项目，怕被人觉得不靠谱。那段时间，协议本身的设计也遇到了瓶颈。感觉自己选错了方向，进退两难。仅靠使命感，或许真的撑不过半年。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;三、同路人，在缝隙中聚集&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;转机出现在我决定硬着头皮走出去之后。2024 年 10 月，在一个出海社群里，我鼓起最大勇气，介绍了我的项目。没想到，立刻有人加我好友，说「你这个东西还蛮有想法的」。这是我收到的第一个正向反馈，至今都记得。&lt;/p&gt; 
&lt;p&gt;后来，通过朋友介绍，我认识了一位海外做智能体创业的朋友。他看到我的东西，脱口而出：「你这个协议非常不错。」那一刻，我感觉像是找到了知己。他后来成了我事实上的「联合发起人」，还把我引荐给了 W3C 的「Web Agent」工作组。我把工作组所有的历史邮件和技术文档翻了个遍，又从牛津大学一个类似的项目里汲取了养分，加上之前对 Web 3.0 去中心化理念的思考，ANP 协议的技术路线终于清晰了起来。&lt;/p&gt; 
&lt;p&gt;真正的东风，来自行业本身。2025 年 3 月份 Anthropic 发布 MCP 协议，以及谷歌发布 A2A，整个行业开始意识到协议的重要性。因为我一直在公众号和社区里分享思考，很快就有人找了过来。我的公众号粉丝开始上涨，加我的人也越来越多。声网 RTE 社区邀请我去做线上分享，那是我第一次面对几千人完整地介绍 ANP，效果出乎意料的好。关注的人多了，我顺势建起了开源社区。现在，ANP 协议在 GitHub 上有了很多的贡献者，我们的线上讨论群也聚集了上千位同路人。今年 4 月，在互联网协会成立了智能体互联网工作组，我们是核心参与方。5 月，我们又牵头在 W3C 成立了 AI Agent Protocol 社区组，很多国内外的大厂比如华为、谷歌、字节、微软、蚂蚁、中移动等，都是社区组成员。雪球，就这么滚了起来。这一切，都是当初那个在绝望中挣扎的我，完全无法预料的。&lt;/p&gt; 
&lt;p&gt;一位大厂前技术高管给我留言：「请保持在技术深水区游泳的勇气。真正的协议战争从来不是功能堆砌，而是世界观的对决」。我不再是一个人了。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;四、功成，不必在我&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;质疑声一直都在。有人觉得这事没商业模式，有人觉得技术还不成熟。我现在心态很平和，有价值的思考我听，纯粹的吐槽自动过滤。我判断自己成功的概率，可能有三成。最大的风险，已经不是大厂下场竞争，而是大模型技术本身的发展，如果一个足够好用的智能体迟迟无法诞生，那协议也就成了无源之水。&lt;/p&gt; 
&lt;p&gt;但我也想清楚了，什么叫成功。如果 ANP 最终没有成为主流，但它的核心理念和设计能成为未来行业标准的一部分养料，那我们社区的目标也就达成了。归根结底，我们想构建的是一个开放的互联网，这是我们社区的理念，也是我们社区最有价值的东西。只要我们的理念能够成功，就是我们社区的成功。所谓「功成不必在我」。如果有其他人或组织有同样的理念，我们社区会无保留开放我们的技术。&lt;/p&gt; 
&lt;p&gt;在一次分享的结尾，我放了一页 PPT，上面写着「连接即力量」。我真正想说的是，我们希望互联网回归到最原始的、开放连接的设想：只要一个人能够自由地连接信息、连接他人、连接工具，他就拥有了改变世界的能力。&lt;/p&gt; 
&lt;p&gt;最后，做自己热爱的事情，事情本身会滋养人的。希望你也能够找到你真正热爱的事情。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;我们的开源社区：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;GitHub: &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fagent-network-protocol%2FAgentNetworkProtocol" target="_blank"&gt;https://github.com/agent-network-protocol/AgentNetworkProtocol&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="color:#252933; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;如果你也对智能体通信协议感兴趣，或者有类似的需求，欢迎联系我们：&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;微信：flow10240&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;邮箱：chgaowei@gmail.com&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/9297178/blog/18638237</link>
      <guid isPermaLink="false">https://my.oschina.net/u/9297178/blog/18638237</guid>
      <pubDate>Sat, 10 May 2025 13:51:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>图形格式 PNG 发布 3.0 版本规范</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;PNG（Portable Network Graphics），便携式网络图形，是一种采用无损压缩算法的位图格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。其设计目的是试图替代 GIF 和 TIFF 文件格式，同时增加一些 GIF 文件格式所不具备的特性。PNG 文件的扩展名为.png。&lt;/p&gt; 
&lt;p&gt;6 月 24 日，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fpng-3%2F" target="_blank"&gt;PNG 正式发布 3.0 版本规范&lt;/a&gt;，并标记为「Recommendation（推荐）」状态，意味着正式成为 W3C 标准。&lt;/p&gt; 
&lt;p&gt;&lt;img height="930" src="https://static.oschina.net/uploads/space/2025/0625/192132_To5V_2720166.png" width="1636" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"&gt;PNG 3.0 规范支持 HDR（高动态范围）功能，能够在保证色彩丰富度的同时，实现更高的亮度和对比度，增强图像的视觉效果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"&gt;此外，它还支持 APNG 动画，使 PNG 格式能够用于动画制作，并且正式支持 Exif 数据，可以存储如版权信息、相机镜头和照片的 GPS 位置等附加信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;目前，多个浏览器和软件（如 Chrome、Safari、Firefox、iOS/macOS、Photoshop 等）以及一些硬件和工具都已支持新的 PNG 规范。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357264/png-3-spec</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357264/png-3-spec</guid>
      <pubDate>Sat, 10 May 2025 11:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Oasis —— 3D 打印智能玻璃容器</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Oasis 是一款完全开源、主要由 3D 打印而成的智能玻璃容器。它为苔藓、蕨类植物、兰花等喜湿植物提供了理想的生长环境。其设计包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://oasis-terrarium.com/docs/random_notes/#light-intensity"&gt;大功率 LED 照明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为植物提供水分并保持高湿度的喷雾器&lt;/li&gt;
&lt;li&gt;风扇用于空气流通&lt;/li&gt;
&lt;li&gt;用于监测环境条件的温度/湿度传感器&lt;/li&gt;
&lt;li&gt;wifi 连接允许通过手机或电脑进行控制和配置（参见&lt;a href="https://oasis-terrarium.com/docs/usage_guide/#web-interface"&gt;网络界面&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;外部尺寸：直径约 8 英寸，高约 13 英寸&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;img alt="" height="489" src="https://static.oschina.net/uploads/space/2025/0625/153625_COKE_4252687.jpg" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;访问网站查看图片、构建细节等：&lt;a href="https://oasis-terrarium.com/"&gt;https://oasis-terrarium.com&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/oasis</link>
      <guid isPermaLink="false">https://www.oschina.net/p/oasis</guid>
      <pubDate>Sat, 10 May 2025 10:49:00 GMT</pubDate>
    </item>
    <item>
      <title>国家网络身份认证公共服务管理办法 7 月 15 日起施行</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;公安部等部门近日联合公布的《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.mps.gov.cn%2Fn6557558%2Fc10087550%2Fcontent.html" target="_blank"&gt;国家网络身份认证公共服务管理办法&lt;/a&gt;》（以下简称《管理办法》）将于 2025 年 7 月 15 日起施行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="286" src="https://oscimg.oschina.net/oscnet/up-4b433ec984b38d283dee4d9335da41dbb7a.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理办法》共 16 条，主要规定四方面内容。一是明确了国家网络身份认证公共服务及网号、网证的概念、申领方式；二是明确了使用国家网络身份认证公共服务的效力、应用场景；三是强调了国家网络身份认证公共服务平台、互联网平台等对数据安全和个人信息保护的责任；四是对未成年人申领、使用国家网络身份认证公共服务作出特殊规定。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理办法》明确网号、网证的自愿使用原则，鼓励有关主管部门、重点行业、互联网平台按照用户自愿原则推广应用，但同时保留、提供现有的或者其他合法方式进行登记、核验身份。《管理办法》鼓励互联网平台接入国家网络身份认证公共服务，但应当保障未使用网号、网证的用户与使用网号、网证的用户享有同等服务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理办法》严格依照个人信息保护法等规定，充分保护公民个人信息权益。在信息收集方面，对选择使用网号、网证登记、核验真实身份的用户，除法律、行政法规另有规定或者用户同意外，互联网平台不得要求用户另行提供明文身份信息。在信息提供方面，国家网络身份认证公共服务平台坚持「最小化提供」原则，对依法需要核验用户真实身份但无需留存法定身份证件信息的，仅向互联网平台提供核验结果；对依法确需获取、留存用户法定身份证件信息的，经用户单独同意，可以向互联网平台提供必要的明文身份信息。对法律、行政法规规定应当履行协助义务的，国家网络身份认证公共服务平台应当依法提供相关信息，但提供的信息仅限网号、网证对应的真实身份信息和认证日志信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，国家网络身份认证公共服务平台已经上线运行，用户可通过国家网络身份认证 App 申领并使用网号、网证，以减少相关服务管理环节对个人信息的采集、留存，实现公民身份信息「可用不可见」，同时降低互联网平台在个人信息保护方面的投入成本。（科技日报）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357253</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357253</guid>
      <pubDate>Sat, 10 May 2025 10:27:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>.NET Core 工作流 WorkFlow 流程控制条件审批（执行动作）</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&lt;span&gt;控制条件审批（执行动作）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;官网：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.wikesoft.com%2F" target="_blank"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;http://www.wikesoft.com&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;学习版演示地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fworkflow.wikesoft.com%2F" target="_blank"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;http://workflow.wikesoft.com&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;学习版源代码下载：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://gitee.com/wikesoft/WorkFlow"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;https://gitee.com/wikesoft/WorkFlow&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow2.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;演示地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fworkflow2.wikesoft.com%2F" target="_blank"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;http://workflow2.wikesoft.com&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow2.0-Vue3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;演示地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fworkflow2-vue3.wikesoft.com%3A8080%2F" target="_blank"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;http://workflow2-vue3.wikesoft.com:8080/&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;WikeFlow2.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;帮助文档：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwikeflowhelp.wikesoft.com%2F" target="_blank"&gt;&lt;u&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;http://wikeflowhelp.wikesoft.com/&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;说&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;明：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;1、执行动作=流程设计设置的连接线。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;2、该文档讲解某一流程节点的执行动作的显示和隐藏。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;3、应用场景：如不同的条件进入不同的审批流程，如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&amp;nbsp; &amp;nbsp;3.1、如果员工提交的费用报销单超过 5000，则要求部门经理提交给副总。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&amp;nbsp; &amp;nbsp;3.2、如果员工提交的费用报销单没有超过 5000，则直接提交给财务人员。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#337ab7"&gt;&lt;span&gt;&amp;nbsp; 条件表达式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;当一个节点上有多条线路可以选择时，流程引擎会将未设置条件表达式和满足条件表达式的连接线显示出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;规则：条件表达式里设置 Key 值，通过设置 Key 和 Key 对应的 SQL 语句。最后再通过 SQL 查询的结果替换条件表达式里的 Key。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&lt;strong&gt;实际应用：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;1、如果员工提交的费用报销单超过 5000，则要求部门经理提交给副总。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;2、如果员工提交的费用报销单没有超过 5000，则直接提交给财务人员。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;img alt="" height="677" src="https://oscimg.oschina.net/oscnet/up-2ea64d81d457fe6e8dbe46ffd175000c84e.png" width="1336" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&lt;strong&gt;1、【提交副总（&amp;gt;5000）】设置&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" style="border-collapse:collapse; border:1.0000pt outset #000000; font-family:&amp;quot;Times New Roman&amp;quot;; font-size:10pt; margin-left:5.4000pt; width:681.0000pt"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:1.0000pt outset #000000"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;条件表达式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:1.0000pt outset #000000"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;[SumAmmount]&amp;gt;5000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SQL Key&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SumAmmount&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SQL 语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SELECT SUM(AMOUNT) FROM&amp;nbsp; COST_DETAIL WHERE COST_ID IN (SELECT ID FROM COST WHERE INSTANCEID= '[instanceId]')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;br&gt; &lt;img alt="" height="757" src="https://oscimg.oschina.net/oscnet/up-c63425ce2ed3912d3112796ad33681e981b.png" width="1495" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;&lt;strong&gt;2、【提交财务审核 (不超过 5000)】设置&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" style="border-collapse:collapse; border:1.0000pt outset #000000; font-family:&amp;quot;Times New Roman&amp;quot;; font-size:10pt; margin-left:5.4000pt; width:681.0000pt"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:1.0000pt outset #000000"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;条件表达式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:1.0000pt outset #000000"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;[SumAmmount]&amp;lt;=5000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SQL Key&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SumAmmount&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:1.0000pt outset #000000; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SQL 语句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="background-color:#ffffff; border-bottom:1.0000pt outset #000000; border-left:none; border-right:1.0000pt outset #000000; border-top:none"&gt; &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SELECT SUM(AMOUNT) FROM&amp;nbsp; COST_DETAIL WHERE COST_ID IN (SELECT ID FROM COST WHERE INSTANCEID= '[instanceId]')&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;br&gt; &lt;span&gt;&lt;span&gt;&lt;img alt="" height="726" src="https://oscimg.oschina.net/oscnet/up-cf93c2d39e110a842fb999426d0a524fc47.png" width="1480" referrerpolicy="no-referrer"&gt;&lt;br&gt; &lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;假如一部员工提交的费用报销单总额是 6000 元，在部门主管处理节点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;【提交副总（&amp;gt;5000）】的条件表达式最后会转换成 6000&amp;gt;5000。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;【提交财务审核 (不超过 5000)】的条件表达式最后会转换成 6000&amp;lt;=5000。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;最后【提交财务审核 (不超过 5000)】这条线则不会显示，【提交提交副总（&amp;gt;5000）】这条线会显示出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;条件表达式可以设置多个 SQL KEY ，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;条件表达式支持.net if 判断的所有写法，并且要求所有的逻辑判断跟.net 的 if 判断写法一样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;特别提示：判断相等是要写「==」而不是「=」，判断不相等要用「!=」，而不是"&amp;lt;&amp;gt;"。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;SQL 可以传参数[instanceId]和[userId]，流程引擎会自动替换[instanceId]和[userId]。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;[instanceId]和[userId]两个参数不是必须，如果你的 SQL 语句中带有[instanceId]、[userId]会自动替换实际的值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e53333"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;特别提示：SqlServer 的 SQL 语句，有同学习惯「[字段名]」的写法，当你的字段名是 instanceid 时，如果你用[字段名]的写法，SQL 语句在替换参数的时候出问题，SQL 执行的时候会报错，下面的 SQL 写法黄色部分是有问题的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;错误示例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;SELECT SUM(AMOUNT) FROM&amp;nbsp; COST_DETAIL WHERE COST_ID IN (SELECT ID FROM COST WHERE&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;span style="background-color:#ff9900"&gt;&lt;span&gt;&lt;span style="color:#ffffff"&gt;[INSTANCEID]= '[instanceId]'&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span style="color:#393939"&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357244</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357244</guid>
      <pubDate>Sat, 10 May 2025 09:33:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>对话 MoonBit 张宏波 ：很多 AI Coding 只提供情绪价值，而我们要重做一门编程语言</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;img height="1080" src="https://oscimg.oschina.net/oscnet/up-8342e8624d18299ad8c0db9edcfd1135b17.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;作者&lt;/span&gt;&lt;em&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;周一笑&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span&gt;编辑&lt;/span&gt;&lt;em&gt;&lt;span&gt;｜&lt;/span&gt;&lt;span style="color:#999999"&gt;&lt;span&gt;王兆洋&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;2022 年末，当 ChatGPT 的火种刚刚在全球点燃，引发第一波的震撼与惊叹时，张宏波进行了一项实验。他将自己刚刚孕育雏形的编程语言&lt;/span&gt;&lt;span&gt;MoonBit&lt;/span&gt;&lt;span&gt;的文法（Grammar）——一段描述语言规则的枯燥文本，喂给了那个强大的新模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;结果让他始料未及。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;「它就能生成 MoonBit 代码，虽然它之前从未‘见过’这门语言」，时隔两年多，张宏波回忆起那一刻，依然反复使用一个词：「不可思议。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;那一刻的「不可思议」，如今已结出果实。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2025 年 6 月 18 日，经过无数次的迭代与优化，MoonBit 发布了它的 Beta 正式版。它正在摆脱「实验性技术」的标签，演进为一门适用于企业正式场景的工具。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;或许大多数人对「编程语言」的认知还停留在大学课堂上的 C 语言，或是如今因 AI 而无处不在的 Python。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;简单来说，MoonBit 就是一门全新的编程语言，和它们一样，是构建所有软件的基石。它的目标是成为一门可以用来开发网站、APP、服务器后台等各种应用的「通用语言」。但在 AI 时代，它选择了一条与前辈们截然不同的道路。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;近年来，像 GitHub Copilot、Cursor 这样能帮你自动写代码的 AI coding 工具层出不穷，AI coding 工具的主要目标是提升开发者在现有语言上的编程效率，张宏波和他的团队也是这些工具的重度用户，他坦言，AI 的辅助让他「一天提交七八个 PR」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;但这些工具终究是「外挂」，是在现有语言的规则下进行辅助。而 MoonBit 所做的，是从源头开始，重新设计一张更适合「AI 副驾驶」来阅读和驰骋的地图。这就是 MoonBit「AI 原生」的核心理念：它并非要自己成为一个 AI，而是要创造一门能让 AI 用起来最得心应手、最不容易出错的语言。它的语法、类型系统、错误处理机制等，在设计之初就深度考虑了如何让 AI 更容易地理解、生成和验证代码，从而解决 AI 编程中「代码写出来但不知道怎么维护」等痛点，保证代码的可维护性 。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;张宏波举了一个例子，MoonBit 使用 let x = 3 而不是类似 Go 语言的 x := 3。因为 let 关键字为 AI 提供了一个明确的「新变量声明」信号，让 AI 在生成代码时可以做「受限解码」，从而更可靠。而后者则有歧义，AI 难以判断是新声明还是赋值，容易出错 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;简单来说，一个设计良好的&lt;/span&gt;&lt;span&gt;AI 原生&lt;/span&gt;&lt;span&gt;语言，能让通用的 AI Coding 工具在操作这门语言时表现得更好。更进一步，MoonBit 团队正在开发自己的 AI 编程 Agent。因为完全掌控 MoonBit 的工具链，所以可以做到通用工具无法实现的功能。例如，通过分析代码结构，并发地让 AI 去修复多个 Bug，而不是像其他工具那样只能一个一个地串行修复。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;要实现如此构想，需要对编程语言的整个工具链有极强的掌控力与理解。而这一切，正来源于张宏波近二十年的技术积累。时间拨回到 2009 年，他在清华大学与微软亚洲研究院的联合培养项目中，完成了自己的本科毕业设计——一门名为「悟空」的动画编程语言 。此后，从研究可以创造新语言的「元编程语言」，到进入宾夕法尼亚大学攻读博士，他的学术路径始终精准地指向编译与语言设计这个基础软件领域最核心的地带 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;一个偶然的机遇让他的人生轨迹从学术转向工业。当时，金融巨头彭博社（Bloomberg）急需一位能维护其核心交易软件的 OCaml 编译器专家，这个小众而关键的岗位，让彭博为还在读博的张宏波开出了难以拒绝的条件，最终使他中断学业，投身华尔街 。在彭博，他再次展现了自己的天赋与热情——为了统一公司上千万行 JavaScript 前端代码与 OCaml 后端的技术栈，他在业余时间，独自开发了一个能将 OCaml 高效编译成可读 JavaScript 的编译器。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;这个无心插柳的项目，后来演变成了知名的开源项目 BuckleScript（ReScript 的前身），并吸引了另一家科技巨头 Facebook 的注意。2017 年，当张宏波决定回国时，Facebook 为了留住这位关键的编译器开发者，破例允许他作为唯一的员工在中国远程办公 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;在 Facebook 的五年，是他技术生涯的成熟期，也是一段漫长的蓄力。直到 2022 年，几个关键节点汇集到了一起：个人上，他渴望在优厚的薪资之外，寻求更大的挑战和创造空间；外部，他昔日在清华的导师 Harry &lt;/span&gt;&lt;span&gt;沈向洋&lt;/span&gt;&lt;span&gt;向他发出了加入 IDEA 研究院（粤港澳大湾区数字经济研究院）的邀请，在「加入已经拥有数百人团队的某编程语言团队」和「从零开始组建自己的团队」之间，他选择了后者——那个更具不确定性，也更具想象力的选项。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;于是，在深圳，MoonBit 项目正式立项。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;命运的奇妙之处在于它的时机。MoonBit 项目启动于 2022 年 10 月，一个月后，ChatGPT 发布，引爆了全球的 AI 浪潮。当所有主流编程语言——Java、Python、Rust——都已在 AI 时代来临前定型，只能在现有基础上「嫁接」AI 能力时，MoonBit 这门「生于 AI 纪元之初」的语言，获得了一个千载难逢的历史机遇。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="428" src="https://oscimg.oschina.net/oscnet/up-e39c86ac937a5c9d8a3bb426b93b8edddf9.png" width="750" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;「我们几乎是没有浪费任何时间」，张宏波说 。从使用 Llama 模型第一次在他个人电脑上成功生成 MoonBit 代码的那天起，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;团队就决定「All-in」 AI。他们开始从语言设计的最底层，从语法的每一个细节，去思考如何让 AI 能更可靠、更高效地生成代码。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;两年半后的今天，MoonBit Beta 版本中，在语言层面提供了原生的异步与错误处理机制。相较于 Python 需要通过 async/await 和第三方库实现的异步模型，MoonBit 提供了一种更自然、零语法负担的并发范式，并在编译期就能追踪错误传播路径，为构建稳定、可维护的智能系统打下了坚实基础。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;MoonBit 的故事，既是张宏波个人技术生涯的延续，也是对「AI 时代，编程究竟该如何演变？」的另一种回答。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;在 MoonBit Beta 正式发布，在架构稳定性和工程实用性上取得关键突破，正式进入可落地应用的新阶段，朝着可被实际部署的基础设施技术前进的关键节点，我们和张宏波聊了聊，以下为对话实录，经不改变原意的编辑。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#fffed5"&gt;AI Coding 有时候提供的只是情绪价值，我们要从底层做一门新语言，这才是 AI 编程的未来&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;人&lt;/span&gt;&lt;span style="color:#454545"&gt;：您如&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#454545"&gt;何理解「AI 原生」编程语言这个概念？在这个理念上，MoonBit 与业界其他探索者有何不同？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在大模型时代，Python 可能并没有大家想象中那么大的优势，它只是起步快一点。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于「AI 原生」，很多人有不同的理解。比如 Mojo，它的创始人 Chris Lattner 是 LLVM 项目的奠基人，他对「AI 原生」的理解是，让 Mojo 这门语言非常适合开发高性能计算程序。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我们认为，AI 原生编程语言的核心议题是：如何让 AI 更高、更好、更高效地、甚至是并发地生成目标代码。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;为什么我觉得这个方向的市场是最大的？开发高性能算子固然重要，但这就像用 C 语言写操作系统内核，是金字塔尖少数人的工作，需求量有限 。而 AI agent，我们自己也开发了很多，它的生态其实很小，核心逻辑可能就几千行代码，很难构成真正的技术护城河，一个通用的库就能解决大部分问题。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，我们对「AI 原生」的理解聚焦于赋能大模型本身。我们希望大模型可以更高效、并发地生成可靠、高性能的 MoonBit 代码。这意味着最终生成的代码不仅可信度要更好、性能要高，而且整个生成过程也必须是快速且可靠的 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;span style="color:#454545"&gt;：这个「为 AI 而设计」的理念，具体是如何影响 MoonBit 语言本身的设计决策的？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;这个理念带来了深刻的变化，很多传统语言设计中非常重视的特性，在我们看来优先级就没有那么高了 。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;最直接的一点就是，我们不会像过去那样，过度强调语法是不是要节省一两个字符，&lt;/span&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;因为未来绝大部分代码都将由 AI 生成，为人类节省几秒钟的打字时间意义不大。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;更重要的是，你需要在一个巨大的设计空间里找到一个精妙的平衡点。这个空间的两端，一端是像 Python、 JavaScript 这样最自由（liberal）的语言，另一端是像 Rust，尤其是 Lean（一种用于形式化数学证明的逻辑编程语言）那样最严格的语言 。Lean 的严格性可以从数学上证明代码的正确性，但正因如此，它对人类来说极难书写 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;我们的实践经验是，如果一门语言过于复杂，以至于人类专家都很难一次性写对，那么 AI 大概率也无法稳定地生成正确的代码 。我们发现，如果一个大模型在某个问题上尝试一两次都无法搞定，那它基本就永远也搞不定了，至少以目前的技术水准是这样。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，MoonBit 的选择是在中间找到一个最佳平衡（sweet spot）。我们既要保证代码的可靠性，又不能让类型系统过于复杂，以至于超出 AI 的能力边界。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：既然 AI 是核心，那么在您看来，一个真正的「AI 原生」语言，未来需要在语言层面提供什么样的功能？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我认为它会深度影响语言的设计，而不仅仅是一个外挂。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们现在主要关注的是代码生成，但这只是开始。例如，未来我们可能会有新的语法特性来原生支持 AI。比如我写完一个函数，我希望语言能直接支持生成它的文档字符串（doc string），而不是像现在这样需要通过外部插件来完成。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;这就像一门为数据库设计的语言，如果它不在语法层面提供对数据库操作的支持，只是通过外挂库来连接，那么它就不能算「数据库原生」的。AI 原生语言也是同样的道理，它需要在语言的基因里就植入与 AI 协同的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：很多开发者担心，AI 生成的代码虽然快，但项目做大后会变得难以维护，像一个「黑盒」。MoonBit 作为一门「为 AI 而生」的语言，是如何从设计上解决这个「可维护性」问题的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个担忧非常普遍，也切中了要害。我之前也看到有人吐槽说，用 AI 两天写了一个视频编辑器，但完全不知道后续该怎么维护。这通常是因为代码是用动态语言写的，正所谓「动态语言一时爽，重构火葬场」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，解决这个问题的核心在于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;代码的可维护性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，而这正是需要从编程语言的底层设计上来保证的。比如，MoonBit 拥有一个非常强大的静态类型系统。我们会为每个代码包（package）自动生成一个形式化的「签名」（我们称之为&lt;/span&gt;&lt;span&gt;MBI 文件&lt;/span&gt;&lt;span&gt;），它就像一份精确的接口摘要。当你需要理解或维护一段代码时，你不再需要去阅读海量的实现细节，只需查看这份由工具保证其正确性的摘要文档即可，大大降低了维护成本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;此外，我们还非常注重语言的「&lt;/span&gt;&lt;span&gt;局部化&lt;/span&gt;&lt;span&gt;」（localization）设计。这意味着，当你修改一个函数时，它的影响应该被严格限制在局部，不会意外地波及到其他不相关的代码。很多语言，比如 C++或者 OCaml，改动一个地方可能会导致全局语义发生变化，这对于人类和 AI 来说都是一场灾难。一个具有良好局部性的语言，能让 AI 在处理代码时，只用聚焦于当前的小代码块，极大地简化了上下文，从而提升了维护性和可靠性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：您认为在 AI 时代，编程语言本身的价值会发生变化吗？它会更偏向于让人类使用，还是让 AI 使用？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我认为未来是人机协同的模式，而不是单纯给 AI 用的语言。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我个人感觉，AI 的智能水平可能正在接近一个平台期，指望它很快变得比人聪明很多并不现实。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;只要人类还需要审查（review）、理解和维护代码，那么语言就必须同时兼顾人类和机器的可读性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;有趣的是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;AI 的出现，反而可能会淘汰掉一些「过度为人类交互而设计」的东西&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如曾经有一个叫「结构化编辑器」的概念，它通过限制你的编辑方式来确保语法永远正确。这种模式对人类的交互很友好，但对大模型来说却是一种束缚，因为它破坏了代码作为纯文本的自由格式，反而不利于 AI 的理解和生成。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，未来的编程语言设计，需要在两者之间找到新的平衡：它要足够结构化和清晰，以便机器能高效、可靠地处理；同时也要保持足够的简洁和直观，让人类能够轻松地审查和验证 AI 生成的结果。这正是我们在 MoonBit 中努力探索的方向。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：您提到 AI 能极大提升效率，在 MoonBit 团队内部，你们具体是如何利用 AI 来辅助日常工作的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们每天都在高强度地使用 AI，可以说，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果没有 AI，我的个人生产力会大幅下降&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。特别是现在我需要花更多精力带领团队、考虑各方面的事情，写代码的时间越来越少。AI 的辅助真的可以让我的生产力翻倍地提高。举个例子，就在前一天，我在不到 24 小时内，利用 AI 辅助完成了七八个代码提交（Commit/PR），这在过去是难以想象的。这些工作有的是修复 Bug，有的是补充文档和注释，AI 都能处理得很好。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;除了个人提效，我们还在探索更有组织性的 AI 用法。比如，MoonBit 现在最缺的就是生态库，我们畅想在年底之前，能有上百个「AI Agent」在夜以继日地为 MoonBit 写代码，将其他语言的成熟生态（比如一些加密算法库）高效地「搬运」过来。这比雇佣 100 个工程师要容易得多。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;更进一步，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;因为我们完全掌控 MoonBit 的语言和工具链，我们可以开发出比通用工具更高效的 AI Agent。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;例如，当需要修复代码库中的多个警告或 Bug 时，通用工具可能只能一个一个地串行修复。而我们的 Agent 可以利用对 MoonBit 代码结构的深度理解，先将代码库智能地拆分成许多互不影响的小块，然后并发地让大模型去并行修复，最后再将结果安全地合并回来。这种利用语言设计来优化 AI 工作流的能力，是我们的核心优势之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：你们团队也使用 Cursor 等通用 AI 编程工具。作为资深开发者和语言设计者，如何评价这些当红产品？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们团队确实都用，包括 Cursor、Copilot、Codex，以及我们自己的 moon-agent。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我个人感觉，还是小团队更有活力，比如 Cursor 的整体体验就要比 Copilot 强很多。可以说，如果 Copilot 做得足够好，根本不会留给 Cursor 这样的初创公司机会。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;但同时，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我也认为像 Cursor 这类产品的技术护城河并没有大家想象中那么高&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。它的核心功能可以分为两部分：一个是你打字时实时补全代码（tap-to-type），另一个是基于对话的 Agent。前者技术含量更高，可能需要训练专门的小模型，&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;但它提供的更多是一种让你感觉编码更快的「情绪价值」，对生产力的根本提升有限。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;真正能大幅提升生产力的是后者，即 Agent 帮你编写完整的代码块，而这部分的技术门槛并不算特别高，更多是依赖底层大模型（基模）的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;此外，&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;过度依赖通用 AI 编程工具还存在被「卡脖子」的风险&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;比如 Google 之前就限制过插件的安装。我们做 MoonBit，坚持自己写底层的语言服务，就是希望站在产业链更上游的位置，不把自己的命运交到别人手里。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我们的策略是，不做通用的 AI 编程工具，而是专注于为 MoonBit 这一门语言提供最强大、最深度的 AI 增强功能，这才是我们自己宽广的护城河。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#fffed5"&gt;比现有主流语言都好一个数量级以上，才能抢夺市场，beta 版发布意味着进入稳定期&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我注意到 MoonBit 初期非常强调在 WebAssembly 领域的优势，这是出于怎样的战略考量？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这是一个刻意的战略选择，很多人会误以为 MoonBit 只做 WebAssembly，其实我们支持所有主流后端，包括 JavaScript 和原生机器码。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我们之所以首先聚焦 WebAssembly，是因为新语言的推广周期非常长，动辄需要数年才能获得第一个真正的商业用户。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;作为一个有资金支持的机构项目，我们不可能像个人爱好者那样「为爱发电」，等上十年再拿出成果。我们需要在一年、两年、三年，每年都交付出实实在在的东西，让大家看到进展。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;要在这么短的时间内让开发者愿意尝试一门全新的语言，唯一的办法，就是在某个特定的、有痛点的平台上，做到比所有现有主流语言都好一个数量级以上。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;我们审视了一圈，发现 WebAssembly 就是那个机会。它在 2017 年才发布 1.0 标准，而所有现在的主流语言，其核心设计都早已在那之前定型，它们在编译到 Wasm 时，或多或少都有历史包袱，导致性能和体积表现都不理想。最典型的例子就是 Go，一个「Hello World」程序编译成 Wasm 后体积竟高达 1.8 兆，这与 Wasm 轻量的初衷背道而驰。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;MoonBit 作为一门没有历史包袱的新语言，完全可以为 Wasm 进行深度优化。我们的判断是，我们有希望在这个单点上做到比所有对手都好一个数量级。事实也证明了这个策略的成功。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我们早期的商业客户，包括付费客户，几乎都是看中了我们在 Wasm 后端上的抢眼表现，这让我们获得了宝贵的初始动力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。有了这个根据地，我们才不会焦虑，可以更有耐心地去做更宏大的事情，比如完善我们的原生和 JavaScript 后端。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：你们近期宣布项目进入了 Beta 里程碑，这对用户和社区意味着什么？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Beta 版本的发布主要意味着三件事。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第一，语言特性已经足够丰富，覆盖了工业级开发的核心需求&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括完善的异步支持、泛型和错误处理。坦白说，我们 Beta 版的特性比 Go 1.0 发布时还要全面。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第二，也是更重要的，语法进入了稳定期。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;在此之前，为了追求最佳设计，我们迭代非常快，可能今天写的代码，两周后就因为语法变动而无法编译了。进入 Beta 阶段后，我们承诺不会再轻易进行破坏性的语法修改，这意味着用户可以放心地在生产项目中使用 MoonBit，不用再担心当「小白鼠」了。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第三，我们将建立更正规的社区沟通机制。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;过去很多决策是内部决定的，未来任何涉及语言语法的改动，我们都会通过公开的 RFC（Request for Comments）流程，与社区提前沟通，让大家更早地参与进来，培养一种共建的参与感。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：MoonBit 作为一门新语言，如何解决生态冷启动的问题？我注意到你们提到了「无缝融合 Python 生态」。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;生态确实是新语言最大的挑战。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;关于 Python 生态，我们的策略是「复用」而非「重造」。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Python 的官方解释器 CPython 是用 C 语言写的。由于 MoonBit 现在支持直接编译到 C 代码，我们就能实现与 C 的良好互操作，从而直接调用 CPython 的运行时。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;这意味着，我们可以为成熟的 Python 库（如 Matplotlib、PyQt 等）编写绑定（binding），让开发者可以在 MoonBit 项目中直接使用它们，比如快速搭建一个 UI 原型。这提供了一条渐进式的迁移路径：你可以先用 Python 库快速出成果，然后逐步地、在性能瓶颈处用原生的 MoonBit 代码重写那部分功能，极大地降低了迁移成本和风险。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：MoonBit 的长期商业模式是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：我们长期的愿景，是成为一家软件服务公司，而非像 JetBrains 那样售卖开发工具。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我们的商业化分两步走。短期内，通过为有深度定制需求（比如修改编译器）的大客户提供授权和服务，我们完全可以覆盖一个十几人团队的开销，保证生存。我们的早期付费客户，比如那家数据库公司，就是有这样的需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;但我们真正的目标在更远处。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;当 MoonBit 生态成熟，拥有百万级用户和我们完全掌控的工具链（从 IDE 到包管理）后，我们将有能力打造一个前所未有的、高效的代码交付云平台。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;在这个平台上，用户只需通过自然语言提出需求（Prompt），我们的 AI Agent 就能利用对 MoonBit 语言的深度理解，自动地为你生成、构建、测试甚至部署一整个软件服务。我们最终向用户交付的，是一个可以直接使用的软件服务，而不仅仅是代码。为了保护这个长远目标，避免未来被云厂商「摘桃子」，我们对编译器的核心部分保留了所有权，这也是我们开源策略中相对保守一面的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一位编程语言「老兵」的二十年&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在创立 MoonBit 之前，您已经在 ReScript 等多个编程语言项目上取得了卓越成就。能和我们分享一下您的这段技术历程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我从 2009 年的本科毕设就开始做编程语言了。当时在清华大学和微软亚洲研究院（MSRA）的联合培养项目中，我开发了一款名叫「悟空」的动画编程语言，算是一个小型的领域特定语言（DSL）吧。从那时算起，到现在快 20 年了。我的硕士课题则是一门「元编程语言」，即一种可以用来创造新编程语言的语言 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我本来是在宾夕法尼亚大学读编程语言的博士，但人生轨迹因为 OCaml 发生了变化。OCaml 是我深度参与维护的一门函数式编程语言。当时，纽约的彭博社（Bloomberg）收购了一家法国公司，其核心的金融衍生品定价软件就是用 OCaml 的一个内部方言（dialect）写的。市场上懂 OCaml 的人才非常稀缺，他们找不到人，于是就找到了我，并给了一份非常优厚的录用信。最终我决定中止学业，硕士毕业后就直接去了纽约，负责维护他们那个私有的 OCaml 编译器。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;在彭博工作期间，我又利用业余时间开启了一个新项目。当时（大约 2014 年），彭博已经拥有上千万行用 JavaScript 写的前端 UI 代码，而后端则在使用 OCaml。为了统一技术栈，我写了一个编译器，可以把 OCaml 编译成非常可读、高效的 JavaScript 代码。我的法国老板（OCaml 正是法国人开发的）看到后非常喜欢，就让我放下原来的业务，全职投入这个项目。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这应该就是后来知名的 BuckleScript/ReScript 项目的前身了。听说后来 Facebook 也因为这个项目向您抛出了橄榄枝？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是的。这个项目后来以 BuckleScript 的名字开源了，成了当时公司最受欢迎的开源项目之一 。到 2017 年，我个人想回国发展，但就在这时，Facebook 联系到我，说他们内部的 Facebook Chats 和 Messenger 等产品深度使用了我的编译器，如果我走了，项目就没人维护了，而他们内部有几十人的团队依赖这个工具链。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;为了留住我，Facebook 做出了一个破例的决定：允许我一个人在中国远程办公，继续维护这个项目。要知道，Facebook 在中国是没有办公室的 。于是，我回国后，从 2017 年到 2022 年，一直在 Facebook 远程参与这个项目。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它也逐渐从 BuckleScript 演进成了一门独立的、专门用于 Web 开发的编程语言——ReScript。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：是什么契机让您最终决定离开 Facebook，创立 MoonBit 呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;到了 2022 年，几个因素汇集到了一起。首先，我在 ReScript 这个项目上已经投入了五六年，而 Facebook 的待遇非常优厚，我一个人在国内，薪资是按照硅谷顶尖标准来支付的。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;对我个人而言，我开始想追求一些薪资之外的东西。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我之前在微软亚洲研究院的导师 Harry，他从微软退休以后，也回到了深圳。我们见了一面，深聊了一次 。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;他建议我来 IDEA 研究院这边，灵活性会更大，可以组建自己的团队。和自己的导师合作，彼此知根知底，完全不用担心信任问题。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;于是，我便来到了 IDEA，从零开始，创立了 MoonBit。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;套壳与否取决于你的 added value&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提到「国产编程语言」，很多人会联想到「套壳」的争议。您如何看待这个问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;「套壳」现象确实很多 。但我们不担心这个问题，因为 MoonBit 的代码是完全公开的，我们甚至几乎没有使用任何第三方依赖，一切都是从零构建。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我认为，判断是否「套壳」的关键标准在于，你提供了多大的价值增量（added value）。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;比如，用 JavaScript 的 eval 函数，五行代码就能做出一个「新语言」，但这没有价值。相比之下，微软的 TypeScript，虽然它最终也编译成 JavaScript，但没人会说它是套壳，因为它提供了一套强大而完善的类型系统，解决了 JavaScript 的原生痛点，带来了巨大的价值增量 。反面例子是曾经的 CoffeeScript，它在很大程度上只是换了一套语法，提供的价值增量有限，那更像是一种套壳。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：作为国内为数不多投身基础软件核心领域的团队，您觉得目前中国的技术环境缺少什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：我个人觉得，我们最缺的可能不是技术，也不是人才，而是两样东西：信心和伯乐。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;首先是信心。我们需要有一种发自内心的信念，觉得我们自己能做出世界一流的东西，而不是总想着等国外做出来了我们再去模仿。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这种信仰必须是基于真实实力的，不是盲目自信。我之所以有信心做 MoonBit，也是因为我过去的经历，比如 ReScript，它的技术含量其实已经比谷歌的 Dart 语言高很多，但因为种种非技术因素，没有达到应有的高度，这是我一直的遗憾。这份遗憾，也成了我做 MoonBit 的动力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;&lt;span&gt;其次，我们缺少「伯乐」。中国的千里马非常多，尤其是 90 后、00 后这一代，既有天赋又极其勤奋，他们的综合能力，我个人觉得甚至比美国同龄人要强很多。但我们的文化环境，可能缺少那种由衷欣赏、不计回报去提携和传播好技术的「伯乐」氛围。很多时候，你得先「拜码头」，或者用商业合作的方式才能获得关注。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;这也是我们想把 MoonBit 做成的原因之一。我们不仅仅是想做出一门很多人用的语言，更希望把它成功地商业化。当我们成功之后，我们自己就能成为「伯乐」，因为我们真正懂技术，可以去识别和扶持下一代更聪明的年轻人，带动一个良性的产业链发展。所以，我深切地感受到，我们缺的是伯乐，而不是千里马。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用 AI 吧，使劲用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于那些在 AI 时代希望提升自己竞争力的开发者，您有什么建议？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我的建议是高强度地去使用它，并且去理解它的能力边界。AI 不是万能的，你要清楚地知道它擅长做什么，不擅长做什么。比如，让 AI 串行地去修改一百个编译警告，效率可能还不如有经验的开发者手动修改来得快。但如果你懂得利用工具，让 AI 去并发地处理这些任务，效率就会指数级提升。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;AI 无疑会加剧马太效应，拉大个体间的差距。厉害的人用上好的 AI 工具会变得更厉害。所以，年轻人应该更主动、更高强度地去拥抱它，了解它的脾性，而不是简单地把它当成一个黑盒。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对于那些想要尝试 MoonBit 的开发者，您有什么想说的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，我们的工具链非常好用。我们提供了一流的在线 IDE，你不需要在本地安装任何东西，打开浏览器就能立即开始编写 MoonBit 代码。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;其次，现在加入是一个非常好的时机。MoonBit 刚刚进入 Beta 阶段，生态系统还是一片全新的大陆。更早地参与进来，你不仅可以见证一门编程语言从零到一的成长过程，更有机会成为早期生态的核心贡献者，留下自己的印记。MoonBit 本身在数据处理等方面有很多非常有意思的特性，我们把数据变换的体验做得非常好，相信会给你带来不一样的感受。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最后，对于那些有志于投身基础技术领域的年轻人，您有什么经验可以分享？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;张宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我的建议是，要做好打持久战的准备，并且先在产业界充分历练。基础软件是一个周期特别长的领域，它不可能让你一夜暴富，而是一个慢工出细活的过程。以我自己为例，我也是在个人职业生涯和财务上有了足够的积累，不再为生计担忧之后，才全身心投入到这件事情中来的。这个领域需要深厚的经验积累，所以，年轻人如果心怀此志，最好先在相关的岗位上磨砺数年，再来挑战。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357239</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357239</guid>
      <pubDate>Sat, 10 May 2025 09:26:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>德国汽车企业就开源软件开发达成非竞争性合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;德国汽车行业的 11 家公司已就开源软件开发达成非竞争性合作&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在德国汽车工业协会（VDA）的支持下，包括宝马集团、大陆集团、ETAS GmbH 等 11 家汽车企业于 2025 年 6 月 24 日在第 29 届国际汽车电子大会上签署了在开源软件开发方面进行前竞争性合作的&lt;strong&gt;谅解备忘录 (Memorandum of Understanding，MoU)&lt;/strong&gt;，旨在提升汽车软件开发的速度、效率和安全性，为建立开放协作的生态系统奠定基础。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0625/171504_8ecy_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;随着车辆软件重要性与复杂性的增加，行业急需加快开发速度、提升效率并确保高质量与安全性。&lt;strong&gt;因大量车辆软件用户无法直接接触且不具差异化，所以可在开放协作生态中联合开发相应软件模块&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;为使汽车系列软件满足功能安全需求，相关方开发了开创性的开源开发流程，为按相关标准认证做好准备，并通过 「代码优先」 方法实现标准化及加快开发速度，即提供可执行软件模块而非详细规格说明。&lt;/p&gt; 
&lt;p&gt;软件开发在 Eclipse 基金会透明且无供应商依赖的环境中进行，属于 S-CORE 项目一部分，该生态系统开放，既通过与行业标准软件互操作性体现，也对欧洲及国际其他公司贡献协作开放。&lt;/p&gt; 
&lt;p&gt;该倡议时间规划显示，2026 年将推出适用于自动驾驶平台系列开发的软件范围，其模块化软件范围可调整或扩展，作为定制发行版供行业用于系列开发，使制造商和供应商能专注于差异化特性，同时共同维护核心组件，为创新奠定坚实基础，也让企业能专注于为客户创造差异化的部分。&lt;/p&gt; 
&lt;p&gt;VDA 主任马库斯・博利希表示，各方正共同构建一个面向未来且强大的软件生态系统，该系统开放、透明且安全。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357237</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357237</guid>
      <pubDate>Sat, 10 May 2025 09:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>大促数据库压力激增，如何一眼定位 SQL 执行来源？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"&gt; 
 &lt;p data-nodeid="1247" data-pm-slice="0 0 []" style="margin-bottom: 8px;text-indent: 2em;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;你是否曾经遇到过这样的情况：在大促活动期间，用户访问量骤增，数据库的压力陡然加大，导致响应变慢甚至服务中断？更让人头疼的是，当你试图快速定位问题所在时，却发现难以确定究竟是哪个业务逻辑中的 &amp;nbsp;SQL 语句成为了性能瓶颈。面对这样的困境，本篇文章提出了对 SQL 进行 「染色」 的方法来帮助大家&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1379"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;一眼定位问题 SQL，而无需再在多处逻辑中辗转腾挪&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;。本文的思路主要受之前郭忠强老师发布的，如何一眼定位 SQL 的代码来源：一款 SQL 染色标记的简易 MyBatis&lt;/span&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;插件 &amp;nbsp;文章启发，我在这个基础上对逻辑进行了简化，去除了一些无关的逻辑和工具类，并只对查询 SQL 进行染色，使这个插件「更轻」。此外，本文除了提供 &amp;nbsp;Mybatis 拦截器的实现以外，还提供了针对 ibatis 框架实现拦截的方法，用于切入相对比较老的应用，希望对大家有所启发~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1248" style="margin-bottom: 8px;text-indent: 2em;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;在文章开展之前，我们先来了解一下什么是 SQL 染色：染色的含义是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1385"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;在 SQL 执行前，在 SQL 上进行注释打标，标记内容为这条 SQL 对应的是 Mapper 文件中的哪条 SQL 以及相关的方法执行堆栈&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;，如下为在 SGM 的 SQL 执行监控端能直接看到 SQL 染色信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section data-nodeid="1249" style="margin-bottom: 8px;text-align: left;" nodeleaf=""&gt; 
  &lt;img src="https://oscimg.oschina.net/oscnet/fe12d217-d240-4765-b861-5d0f7c45c70b.png" alt="image.png" class="rich_pages wxw-img" data-ratio="0.5175925925925926" data-type="png" data-w="1080" data-imgfileid="100029296" referrerpolicy="no-referrer"&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1250" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;这样便能够非常轻松地看到到底是什么逻辑执行了哪段 SQL，并且经过实际生产性能验证，染色操作耗时在 0 ~ 1ms 左右：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="css"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗时：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1251" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="text"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;现在我们已经对 SQL 染色有了基本的了解，下面将介绍两种实现染色的方式：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;strong data-nodeid="1397"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 拦截器实现和基于 AspectJ 织入实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;。在接下来的内容中我会展示染色实现的源码信息，但是并不复杂，代码量只有百行，所以大家可以直接将文章中的代码逻辑复制到项目中实现即可。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid="1253" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;快速接入 SQL 染色&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1256" style="margin-bottom: 8px;text-align: left;"&gt;&lt;strong data-nodeid="1405"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 框架应用接入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：跳转 「全量源码」 小节，复制拦截器源码到应用中，并在 Mybatis 拦截器配置中添加该拦截器便可以生效，注意修改源码中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1403" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;com.your.package&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;包路径为当前应用的有效包路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;p data-nodeid="1258" style="margin-bottom: 8px;text-align: left;"&gt;&lt;strong data-nodeid="1410"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;非 Mybatis 框架应用接入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：参考 「基于 AspectJ 织入实现」 小节，通过对 SQL 执行相关 Jar 包进行拦截实现&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid="1259" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;Mybatis 拦截器实现&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;p data-nodeid="1260" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在展示具体实现前，我还是想通过给大家介绍原理的形式一步步将其实现，这样也能加深大家对 Mybatis 框架的理解，也欢迎大家阅读、订阅专栏，由 Mybatis 源码畅谈软件设计。如果不想看实现原理，直接看实现的话请跳转&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1421"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;全量源码&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;小节。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_3"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1261" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;拦截器的作用范围&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1262" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 的拦截器不像 Spring 的 AOP 机制，它并不能在任意逻辑处进行切入。在 Mybatis 源码的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1424" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;类中，定义了它的拦截器的作用范围，即创建「四大处理器」时调用的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1426" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;protected&lt;/span&gt;&amp;nbsp;final&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;interceptorChain =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newParameterHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;MappedStatement mappedStatement,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;parameterObject,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;parameterHandler = mappedStatement.&lt;span class="code-snippet__title"&gt;getLang&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;createParameterHandler&lt;/span&gt;(mappedStatement,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parameterObject, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(parameterHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newResultSetHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement mappedStatement, RowBounds rowBounds,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;resultSetHandler =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;DefaultResultSetHandler&lt;/span&gt;(executor, mappedStatement, parameterHandler,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; resultHandler, boundSql, rowBounds);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(resultSetHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newStatementHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement mappedStatement,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&amp;nbsp;parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;statementHandler =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;(executor, mappedStatement, parameterObject,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(statementHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newExecutor&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Transaction transaction, ExecutorType executorType&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executorType = executorType ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;&amp;nbsp;? defaultExecutorType : executorType;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 创建具体的 Executor 实现类&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;executor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;BATCH&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BatchExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;REUSE&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ReuseExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cacheEnabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1262" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;是让拦截器生效的逻辑，它具体是如何做的呢：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 所有配置的拦截器&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;final&amp;nbsp;&lt;span class="code-snippet__title"&gt;List&lt;/span&gt;&amp;lt;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;gt; interceptors =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;target&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;interceptor : interceptors) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 注意 target 引用不断变化，会不断引用已经添加拦截器的对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = interceptor.&lt;span class="code-snippet__title"&gt;plugin&lt;/span&gt;(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1265" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;实现非常简单，内部定义了集合来保存所有配置的拦截器，执行&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1432" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法时会遍历该集合，逐个调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1434" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Interceptor#plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法来 「不断地叠加拦截器」（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1436" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;interceptor.plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法执行时，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1438" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;引用不断变更）。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;blockquote&gt; 
  &lt;p data-nodeid="1268" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;注意这里使用到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1461"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;责任链模式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1445" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的命名中包含&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1447" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Chain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;也能联想到该模式，之后我们在使用责任链时也可以考虑在命名中增加&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1449" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Chain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;以增加可读性。&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1451" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;将多个拦截器串联在一起，每个拦截器负责其特定的逻辑处理，并在执行完自己的逻辑后，调用下一个拦截器或目标方法，这样设计允许不同的拦截器之间的逻辑&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1462"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;解耦&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，同时提供了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1463"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;可扩展性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;/blockquote&gt; 
 &lt;p data-nodeid="1269" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;由此可知，拦截器的作用范围是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1465" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1467" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1469" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1471" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;处理器（Handler），但是拦截它们又能实现什么效果呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1270" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要弄清楚这个问题，首先我们需要了解拦截器能够切入的粒度。在 Mybatis 框架中，定义拦截器时需要使用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1474" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;@Intercepts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1476" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;@Signature&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;注解来&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1482"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;配置切入的方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="ruby"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Intercepts&lt;/span&gt;({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Signature&lt;/span&gt;(method =&amp;nbsp;&lt;span class="code-snippet__string"&gt;"prepare"&lt;/span&gt;, type =&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;, args = {&lt;span class="code-snippet__title"&gt;Connection&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Integer&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;implements&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__regexp"&gt;//&lt;/span&gt;&amp;nbsp;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1271" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;每个拦截器切入的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;strong data-nodeid="1490"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;粒度是方法级别的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的，比如在我们定义的这个拦截器中，切入的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1488" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，那么如果我们了解了四个处理器方法的作用是不是就能知道 Mybatis 拦截器所能实现的功能了？所以接下来我们简单了解一下它们的各个方法的作用：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1275" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1491" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 核心方法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1493" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;setParameters&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，它的作用主要是将 Java 对象转换为 SQL 语句中的参数，并处理参数的设置和映射，所以拦截器切入它能&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1498"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;对 SQL 执行的入参进行修改&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;Object&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;getParameterObject&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;setParameters&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;(&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__params"&gt;PreparedStatement ps&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;) throws SQLException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1276" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 负责将 SQL 查询返回的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1501" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSet&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;结果集转换为 Java 对象，拦截器切入它的方法能&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1506"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;对结果集进行处理&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 处理 Statement 对象并返回结果对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;stmt SQL 语句执行后返回的 Statement 对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@return&lt;/span&gt;&amp;nbsp;映射后的结果对象列表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleResultSets&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement stmt)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 处理 Statement 对象并返回一个 Cursor 对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 它用于处理从数据库中获取的大量结果集，与传统的 List 或 Collection 不同，Cursor 提供了一种流式处理结果集的方式，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 这在处理大数据量时非常有用，因为它可以避免将所有数据加载到内存中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;stmt SQL 语句执行后返回的 Statement 对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@return&lt;/span&gt;&amp;nbsp;游标对象，用于迭代结果集&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleCursorResultSets&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement stmt)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 处理存储过程的输出参数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;cs 存储过程调用的 CallableStatement 对象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleOutputParameters&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(CallableStatement cs)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1283" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1507" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 它的方法很多，概括来说它负责数据库操作，包括增删改查等基本的 SQL 操作、管理缓存和事务的提交与回滚，所以拦截器切入它主要是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1512"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;管理执行过程或事务&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;ResultHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;NO_RESULT_HANDLER&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于执行更新操作（包括插入、更新和删除），它接受一个 `MappedStatement` 对象和更新参数，并返回受影响的行数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;update&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于执行查询操作，接受 `MappedStatement` 对象（包含 SQL 语句的映射信息）、查询参数、分页信息、结果处理器等，并返回查询结果的列表&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; CacheKey cacheKey, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;queryCursor&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于刷新批处理语句并返回批处理结果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; List&amp;lt;BatchResult&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;flushStatements&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于提交事务，参数 `required` 表示是否必须提交事务&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;commit&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;required)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于回滚事务。参数 `required` 表示是否必须回滚事务&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;rollback&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;required)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于创建缓存键，缓存键用于标识缓存中的唯一查询结果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; CacheKey&amp;nbsp;&lt;span class="code-snippet__title"&gt;createCacheKey&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于检查某个查询结果是否已经缓存在本地&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;isCached&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, CacheKey key)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于清空一级缓存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;clearLocalCache&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于延迟加载属性&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;deferLoad&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&amp;lt;?&amp;gt; targetType)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于获取当前的事务对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; Transaction&amp;nbsp;&lt;span class="code-snippet__title"&gt;getTransaction&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于关闭执行器。参数 `forceRollback` 表示是否在关闭时强制回滚事务&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;close&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;forceRollback)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;isClosed&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 该方法用于设置执行器的包装器&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;setExecutorWrapper&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Executor executor)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1287" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1513" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 它的主要职责是准备（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1515" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;）、「承接」封装 SQL 执行参数的逻辑，执行 SQL（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1517" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;update&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;/&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1519" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;）和「承接」处理结果集的逻辑，这里描述成「承接」的意思是这两部分职责并不是由它处理，而是分别由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1521" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1523" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成，所以拦截器切入它主要是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1528"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在准备和执行阶段对 SQL 进行加工等&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; Statement&amp;nbsp;&lt;span class="code-snippet__title"&gt;prepare&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Connection connection, Integer transactionTimeout)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;parameterize&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;batch&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;update&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement, ResultHandler resultHandler)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;queryCursor&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; BoundSql&amp;nbsp;&lt;span class="code-snippet__title"&gt;getBoundSql&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; ParameterHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;getParameterHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1288" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;为了加深大家对这四个处理器的理解，了解它在查询 SQL 执行时作用的时机，我们来看一下查询 SQL 执行时的流程图：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section data-nodeid="1290" style="margin-bottom: 8px;text-align: left;" nodeleaf=""&gt; 
  &lt;img src="https://oscimg.oschina.net/oscnet/11f9fe6e-8276-482a-be20-4ead1b5f1d20.png" alt="image.png" class="rich_pages wxw-img" data-ratio="0.37222222222222223" data-type="png" data-w="1080" data-imgfileid="100029298" referrerpolicy="no-referrer"&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1291" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;每个声明 SQL 查询语句的 Mapper 接口都会被&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1534" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperProxy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;代理，接口中每个方法都会被定义为&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1536" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperMethod&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，借助&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1538" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;PlainMethodInvoker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;执行（动态代理模式和策略模式），&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1540" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperMethod&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中组合了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1542" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1544" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MethodSignature&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1546" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象很重要，它的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1548" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand#name&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段记录的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1550" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象的 ID 值（eg: org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor），根据它来获取唯一的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1552" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;（每个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1554" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象对应 XML 映射文件中一个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1556" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;select&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1558" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;insert&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1560" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;update&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;, 或&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1562" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;delete&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;标签定义），&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1564" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand#type&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段用来标记 SQL 的类型。当方法被执行时，会先调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1566" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlSession&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中的查询方法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1568" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultSqlSession#selectOne&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，接着由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1614"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;执行器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1574" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;去承接，默认类型是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1576" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，注意在这里它会调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1578" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法获取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1580" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，这个对象实际上最终都是在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1582" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StaticSqlSource#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法中获取的，也就是说&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1615"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;此时我们定义在 Mapper 文件中的 SQL 此时已经被解析、处理好了（动态标签等内容均已被处理）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，保存在了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1588" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象中。此时，要执行的 SQL 已经准备好了，它会接着调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1616"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SQL 处理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1594" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法创建与数据库交互的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1596" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Statement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，其中记录了要执行的 SQL 信息 ，而封装 SQL 的执行参数则由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1617"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;参数处理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1602" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1604" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;TypeHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1606" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSet&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;结果的处理：将数据库中数据转换成所需要的 Java 对象由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1618"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;结果处理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1612" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1292" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;现在我们对拦截器的原理和查询 SQL 的执行流程已经有了基本的了解，回过头来再想一下我们的需求：「使用 Mybatis 的拦截器在 SQL 执行前进行打标」，那么我们该选择哪个方法作为切入点更合适呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1293" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;理论上来说在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1621" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1623" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1625" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;相关的方法中切入都可以，但实际上我们还要多考虑一步：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1627" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;是用来处理参数相关的，在这里切入一般我们是要对入参 SQL 的入参进行处理，所以不选择这里避免为后续同学维护时增加理解成本；&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1629" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;「有时不是很合适」，它其中有两个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1631" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，先被执行的方法，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1675"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;对应图中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1635" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CacheExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;左侧的直线&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1637" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1641" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor#query(MappedStatement, Object, RowBounds, ResultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在方法中它会去调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1643" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法获取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1645" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1676"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成 SQL 的处理和解析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，处理和解析后的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1651" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象是我们需要进行拦截处理的，随后&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1677"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在该方法内部&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;调用另一个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1657" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1659" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor#query(MappedStatement, Object, RowBounds, ResultHandler, CacheKey, BoundSql)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1678"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;对应图中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1663" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CacheExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;右侧的曲线&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1665" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，它会将&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1669" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;作为入参去执行查询逻辑，结合本次需求，选择后者切入是合适的，因为它有&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1671" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;入参，对这个入参进行打标即可，我们来看一下&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1673" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的源码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;Executor delegate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 先调用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getBoundSql(parameterObject);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;CacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;key&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;createCacheKey(ms, parameterObject, rowBounds, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 在方法内部调用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CacheKey key, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 二级缓存相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Cache&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;cache&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getCache();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cache !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; flushCacheIfRequired(ms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(ms.isUseCache() &amp;amp;&amp;amp; resultHandler ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@SuppressWarnings("unchecked")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(list ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 执行查询逻辑（被拦截）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tcm.putObject(cache, key, list);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;list;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 执行查询逻辑（被拦截）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1294" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;它使用了静态代理模式，其中封装的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1680" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;实现类型为&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1682" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SimpleExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在注释中标记了「被拦截」处的方法会让拦截器生效。那么前文中为什么要说它「有时不是很合适」呢？我们来看一种情况，将 Mybatis 配置中的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1684" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;cacheEnable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;置为 false，那么在创建执行器时实际类型不是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1686" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;而是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1688" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SimpleExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，如下源码所示：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newExecutor&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Transaction transaction, ExecutorType executorType&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executorType = executorType ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;&amp;nbsp;? defaultExecutorType : executorType;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 创建具体的 Executor 实现类&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;executor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;BATCH&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BatchExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;REUSE&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ReuseExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// false 不走这段逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cacheEnabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1294" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;当有 SELECT 查询语句被执行时，它会直接调用到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1691" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BaseExecutor#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，在方法内部调用另一个需要被拦截的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1693" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;abstract&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BaseExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getBoundSql(parameter);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// cache key 缓存操作&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;CacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;key&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;createCacheKey(ms, parameter, rowBounds, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 需要拦截的&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;query(ms, parameter, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@SuppressWarnings("unchecked")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CacheKey key, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1298" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;由于该方法是在方法内部被调用的，所以无法使拦截器生效&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;（动态代理），这也是说它「有时不是很合适」的原因所在。因为存在这种情况，我们现在也只能选择&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1699" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;作为切入点了，那么是选择切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1701" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法还是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1703" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法呢？&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;extends&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BaseExecutor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;doQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Statement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stmt&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Configuration&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;configuration&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getConfiguration();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 创建 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;handler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 准备 Statement，其中会调用 StatementHandler#prepare 方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stmt = prepareStatement(handler, ms.getStatementLog());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 由 StatementHandler 执行 query 方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;handler.query(stmt, resultHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;finally&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; closeStatement(stmt);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1298" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根据源码，要被执行打标的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1707" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象会在调用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1709" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法前会将&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1711" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象封装在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1713" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中，如果选择切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1715" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，那么在该方法执行前在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1717" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中拿到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1719" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象进行修改便能实现我们的需求；如果选择切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1721" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，同样是需要在该方法执行前想办法获取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1723" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，但是由于此时 SQL 信息已经被保存在了即将与数据库交互的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1725" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Statement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象中，它的实现类有很多，比如常见的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1727" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;PreparedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在其中获取 SQL 字符串相对复杂，所有还是选择&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1729" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法作为切点相对容易。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1302" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;拦截器的定义和源码解析&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1303" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;接下来我们来对拦截器进行实现，首先我们先对拦截器的切入点进行定义：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="ruby"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Intercepts&lt;/span&gt;({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Signature&lt;/span&gt;(method =&amp;nbsp;&lt;span class="code-snippet__string"&gt;"prepare"&lt;/span&gt;, type =&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;, args = {&lt;span class="code-snippet__title"&gt;Connection&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Integer&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;implements&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;intercept(&lt;span class="code-snippet__title"&gt;Invocation&lt;/span&gt;&amp;nbsp;invocation) throws&amp;nbsp;&lt;span class="code-snippet__title"&gt;Throwable&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__regexp"&gt;//&lt;/span&gt;&amp;nbsp;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1304" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;接着来实现其中的逻辑：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Intercepts({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Signature(method = "prepare", type = StatementHandler.class, args = {Connection.class, Integer.class})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Log&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;log&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;LogFactory.getLog(SQLMarkingInterceptor.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;intercept&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Invocation invocation)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 1. 找到 StatementHandler（SQL 执行时，StatementHandler 的实际类型为 RoutingStatementHandler）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;routingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getRoutingStatementHandler(invocation.getTarget());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(routingStatementHandler !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 其中 delegate 是实际类型的 StatementHandler （静态代理模式），获取到实际的 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;delegate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RoutingStatementHandler.class, routingStatementHandler,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"delegate"&lt;/span&gt;, StatementHandler.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 2. 找到 StatementHandler 之后便能拿到 SQL 相关信息，现在对 SQL 信息打标即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; marking(delegate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1304" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;将自定义的逻辑添加上了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1735" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;try-catch&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，避免异常影响正常业务的执行。在主要逻辑中，需要先在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1737" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Invocation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中找到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1739" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的实际被代理的对象，它被封装在了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1741" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中，随后在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1743" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中获取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1745" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，对 SQL 进行打标即可（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1747" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;marking&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法）。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h5_5"&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid="1308" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;获取 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt; 
 &lt;p data-nodeid="1309" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;拦截&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1751" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;为什么要获取的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1753" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;类型呢？我们回到拦截器拦截&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1755" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;生效的源码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;protected&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;interceptorChain&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;StatementHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;newStatementHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Executor executor, MappedStatement mappedStatement,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 可以发现拦截器实际针对的是类型便是 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;(executor, mappedStatement, parameterObject,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 拦截器相关逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(StatementHandler) interceptorChain.pluginAll(statementHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1310" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;我们可以发现拦截器在生效时，针对的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1758" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;类型，所以我们要获取该类型，如下源码：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;getRoutingStatementHandler&lt;/span&gt;(&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;target)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; throws&amp;nbsp;&lt;span class="code-snippet__title"&gt;NoSuchFieldException&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;IllegalAccessException&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 如果被代理，那么一直找到具体被代理的对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Proxy&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;isProxyClass&lt;/span&gt;(target.&lt;span class="code-snippet__title"&gt;getClass&lt;/span&gt;())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target =&amp;nbsp;&lt;span class="code-snippet__title"&gt;Proxy&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;getInvocationHandler&lt;/span&gt;(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;&amp;nbsp;plugin = (&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target =&amp;nbsp;&lt;span class="code-snippet__title"&gt;getFieldValue&lt;/span&gt;(&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;class&lt;/span&gt;, plugin,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"target"&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 找到了 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1312" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;源码中前两步为处理代理关系的逻辑，因为&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1761" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;可能被代理，需要获取到实际的被代理对象，找到之后返回即可。那么后续为什么还要获取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1763" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中的被代理对象呢？我们还需要再回到 Mybatis 的源码中：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 代理对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;final StatementHandler&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;(&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 在调用构造方法时，根据 statementType 字段为代理对象 delegate 赋值，那么这样便实现了复杂度隐藏，只由代理对象去帮忙路由具体的实现即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;switch&lt;/span&gt;&amp;nbsp;(ms.getStatementType()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;STATEMENT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;PREPARED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;CALLABLE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;ExecutorException(&lt;span class="code-snippet__string"&gt;"Unknown statement type: "&lt;/span&gt;&amp;nbsp;+ ms.getStatementType());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1314" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;使用了静态代理模式，实际的类型被赋值到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1767" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段中，我们需要在这个对象中获取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1769" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，获取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1771" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象则通过反射来完成。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h5_6"&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid="1316" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;染色打标 marking&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt; 
 &lt;p data-nodeid="1317" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;现在我们已经获取到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1775" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，我们可以 SQL 进行打标了，但在打标之前我们需要先思考下要打标的内容是什么：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1320" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要清楚的知道被执行的 SQL 是定义在 Mapper 中的哪条：声明在 Mapper 中各个方法的唯一 ID，也就是 StatementId&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;p data-nodeid="1322" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要清楚的知道这条 SQL 被执行时，有哪些相关方法被执行了：方法的调用栈&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p data-nodeid="1323" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根据我们所需去找相关的内容就好了，以下是源码，需要注意的是由于所有类型的 SQL 都会执行到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1780" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，但我们只对 SELECT 语句进行打标，所以需要添加逻辑判断：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;marking&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementHandler delegate)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;delegate.getBoundSql();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 实际的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;boundSql.getSql().trim();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只对 select 打标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sql,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 获取其基类中的 MappedStatement 即定义的 SQL 声明对象，获取它的 ID 值表示它是哪条 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BaseStatementHandler.class, delegate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"mappedStatement"&lt;/span&gt;, MappedStatement.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;mappedStatement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法调用栈&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按顺序创建打标的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 打标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sql = String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 反射更新&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(BoundSql.class,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"sql"&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.set(boundSql, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1324" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;执行打标的逻辑是修改&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1783" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;对象，将其中的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1785" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;sql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段用打标后的 SQL 替换掉。获取方法调用栈的逻辑我们具体来看一下，其实并不复杂，在全量堆栈信息中将不需要关注的堆栈排除掉，需要注意将&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1787" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;!className.startsWith("com.your.package")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;修改成有效的路径判断：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;trace&lt;/span&gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 全量调用栈&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StackTraceElement&lt;/span&gt;[] stackTraceArray =&amp;nbsp;&lt;span class="code-snippet__title"&gt;Thread&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;currentThread&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;getStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(stackTraceArray.&lt;span class="code-snippet__property"&gt;length&lt;/span&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;EMPTY&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;gt; methodInfoList =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(int i = stackTraceArray.&lt;span class="code-snippet__property"&gt;length&lt;/span&gt;&amp;nbsp;-&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;&amp;nbsp;-&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;; i &amp;gt;=&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;; i--) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StackTraceElement&lt;/span&gt;&amp;nbsp;stackTraceElement = stackTraceArray[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 排除掉不想看到的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;className = stackTraceElement.&lt;span class="code-snippet__title"&gt;getClassName&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!className.&lt;span class="code-snippet__title"&gt;startsWith&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"com.your.package"&lt;/span&gt;) || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"FastClassBySpringCGLIB"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"EnhancerBySpringCGLIB"&lt;/span&gt;) || stackTraceElement.&lt;span class="code-snippet__title"&gt;getMethodName&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"lambda$"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 过滤拦截器相关&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"Interceptor"&lt;/span&gt;) || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"Aspect"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只拼接类和方法，不拼接文件名和行号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;methodInfo =&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;format&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"%s#%s"&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; className.&lt;span class="code-snippet__title"&gt;substring&lt;/span&gt;(className.&lt;span class="code-snippet__title"&gt;lastIndexOf&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;'.'&lt;/span&gt;) +&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stackTraceElement.&lt;span class="code-snippet__title"&gt;getMethodName&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methodInfoList.&lt;span class="code-snippet__title"&gt;add&lt;/span&gt;(methodInfo);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(methodInfoList.&lt;span class="code-snippet__title"&gt;isEmpty&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;EMPTY&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 格式化结果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;&amp;nbsp;stringJoiner =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;" ==&amp;gt; "&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;method : methodInfoList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stringJoiner.&lt;span class="code-snippet__title"&gt;add&lt;/span&gt;(method);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;stringJoiner.&lt;span class="code-snippet__title"&gt;toString&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1324" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;以上便完成了 SQL 「染色」 拦截器的实现，将其添加到 mybatis 相关的拦截器配置中就可以生效了。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_7"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1328" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;全量源码&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;com.jd.laf.config.spring.annotation.LafValue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;lombok.extern.slf4j.Slf4j;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.commons.lang3.StringUtils;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.BaseStatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.RoutingStatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.StatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.mapping.BoundSql;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.mapping.MappedStatement;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.plugin.*;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.springframework.stereotype.Service;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.lang.reflect.Field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.lang.reflect.Proxy;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.sql.Connection;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.util.*;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.util.concurrent.ConcurrentHashMap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;org.apache.commons.lang3.StringUtils.EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Intercepts({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Signature(method = "prepare", type = StatementHandler.class, args = {Connection.class, Integer.class})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 默认线程栈数组下标&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 是否开启 SQL 染色标记&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@LafValue("sql.marking.enable")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;enabled;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;Map&amp;lt;String, Field&amp;gt; FIELD_CACHE =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;intercept&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Invocation invocation)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!enabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 1. 找到 StatementHandler（SQL 执行时，StatementHandler 的实际类型为 RoutingStatementHandler）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;routingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getRoutingStatementHandler(invocation.getTarget());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(routingStatementHandler !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 其中 delegate 是实际类型的 StatementHandler （静态代理模式），获取到实际的 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;delegate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RoutingStatementHandler.class, routingStatementHandler,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"delegate"&lt;/span&gt;, StatementHandler.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 2. 找到 StatementHandler 之后便能拿到 SQL 相关信息，现在对 SQL 信息打标即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; marking(delegate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;RoutingStatementHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;getRoutingStatementHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Object target)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 如果被代理，那么一直找到具体被代理的对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(Proxy.isProxyClass(target.getClass())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = Proxy.getInvocationHandler(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;Plugin) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Plugin&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;plugin&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;(Plugin) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = getFieldValue(Plugin.class, plugin,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"target"&lt;/span&gt;, Object.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 找到了 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;RoutingStatementHandler) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(RoutingStatementHandler) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 打标&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 1. 要清楚的知道被执行的 SQL 是定义在 Mapper 中的哪条&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 2. 要清楚的知道这条 SQL 被执行时方法的调用栈&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;marking&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementHandler delegate)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;delegate.getBoundSql();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 实际的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;boundSql.getSql().trim();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只对 select 打标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sql,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 获取其基类中的 MappedStatement 即定义的 SQL 声明对象，获取它的 ID 值表示它是哪条 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BaseStatementHandler.class, delegate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"mappedStatement"&lt;/span&gt;, MappedStatement.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;mappedStatement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法调用栈&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按顺序创建打标的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 打标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sql = String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 反射更新&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(BoundSql.class,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"sql"&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.set(boundSql, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 获取某类型 clazz 某对象 object 下某字段 fieldName 的值 fieldClass&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&amp;lt;T&amp;gt; T&amp;nbsp;&lt;span class="code-snippet__title"&gt;getFieldValue&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Class&amp;lt;?&amp;gt; clazz, Object object, String fieldName, Class&amp;lt;T&amp;gt; fieldClass)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 获取到目标类的字段&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(clazz, fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;fieldClass.cast(field.get(object));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;String&amp;nbsp;&lt;span class="code-snippet__title"&gt;trace&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; StackTraceElement[] stackTraceArray = Thread.currentThread().getStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(stackTraceArray.length &amp;lt;= DEFAULT_INDEX) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedList&amp;lt;String&amp;gt; methodInfoList =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;i&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceArray.length -&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;&amp;nbsp;- DEFAULT_INDEX; i &amp;gt;= DEFAULT_INDEX; i--) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StackTraceElement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stackTraceElement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceArray[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;className&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceElement.getClassName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!className.startsWith(&lt;span class="code-snippet__string"&gt;"com.your.package"&lt;/span&gt;) || className.contains(&lt;span class="code-snippet__string"&gt;"FastClassBySpringCGLIB"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; || className.contains(&lt;span class="code-snippet__string"&gt;"EnhancerBySpringCGLIB"&lt;/span&gt;) || stackTraceElement.getMethodName().contains(&lt;span class="code-snippet__string"&gt;"lambda$"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 过滤拦截器相关&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(className.contains(&lt;span class="code-snippet__string"&gt;"Interceptor"&lt;/span&gt;) || className.contains(&lt;span class="code-snippet__string"&gt;"Aspect"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只拼接类和方法，不拼接文件名和行号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;methodInfo&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;"%s#%s"&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; className.substring(className.lastIndexOf(&lt;span class="code-snippet__string"&gt;'.'&lt;/span&gt;) +&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stackTraceElement.getMethodName()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methodInfoList.add(methodInfo);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(methodInfoList.isEmpty()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 格式化结果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StringJoiner&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stringJoiner&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;" ==&amp;gt; "&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(String method : methodInfoList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stringJoiner.add(method);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;stringJoiner.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;Field&amp;nbsp;&lt;span class="code-snippet__title"&gt;getField&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Class&amp;lt;?&amp;gt; clazz, String fieldName)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Field field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;cacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;"%s.%s"&lt;/span&gt;, clazz.getName(), fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(FIELD_CACHE.containsKey(cacheKey)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field = FIELD_CACHE.get(cacheKey);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field = clazz.getDeclaredField(fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.setAccessible(&lt;span class="code-snippet__literal"&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; FIELD_CACHE.put(cacheKey, field);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1329" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;基于 AspectJ 织入实现&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p data-nodeid="1331" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;这种方法主要用于在未使用 Mybatis 框架的系统中，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1797"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;基于 AspectJ 实现对 Maven 依赖中 Jar 包类的织入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，完成 SQL 染色打标的操作。同时，这种方法并不限于此，大家可以借鉴这种方法用于其他 Jar 包的织入，而不局限于 Spring 提供的 AOP 机制，毕竟 Spring 的 AOP 只能对 Bean 进行织入。所以在本小节中，更注重方法的介绍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_8"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1332" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;添加依赖和配置插件&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1333" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;借助 AspectJ 在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1804"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;编译期&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;实现对 Maven 依赖中 Jar 包类的织入，这与运行时织入（如 Spring AOP 使用的代理机制）不同，编译期织入是在生成的字节码中直接包含切面逻辑，生成的类文件已经包含了切面代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1334" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;首先，需要先添加依赖：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="xml"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;dependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.aspectj&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;aspectjrt&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8.13&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;dependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1334" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;并且在 Maven 的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1807" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;plugins&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;标签下添加&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1809" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;aspectj-maven-plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;插件配置，否则无法实现在编译期织入：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="xml"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.codehaus.mojo&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;aspectj-maven-plugin&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.11&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;configuration&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 解决与 Lombok 的冲突 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;forceAjcCompile&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;true&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;forceAjcCompile&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;sources&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectories&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectory&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;${project.build.directory}/classes&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectory&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectories&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- JDK 版本 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;complianceLevel&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;complianceLevel&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 展示织入信息 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;showWeaveInfo&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;true&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;showWeaveInfo&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 重点！配置要织入的 maven 依赖 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependencies&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.apache.ibatis&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;ibatis-sqlmap&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependencies&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;configuration&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;executions&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;execution&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goals&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goal&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;compile&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goal&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goals&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;execution&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;executions&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1337" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="xml"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;解决与 Lombok 的冲突配置内容不再解释，详细请看 CSDN: AspectJ 和 lombok。重点需要关注的配置内容是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1816" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;标签：配置织入依赖（详细可参见 Maven: aspectj-maven-plugin 官方文档），也就是说如果我们想对&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1822" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;进行织入，那么需要将它对应的 Maven 依赖添加到这个标签下才能生效，否则无法完成织入。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;p data-nodeid="1339" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成以上内容之后，现在去实现对应的拦截器即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1340" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;拦截器实现&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1341" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;拦截器的实现原理非常简单，要织入的方法是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1827" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;com.ibatis.sqlmap.engine.execution.SqlExecutor#executeQuery&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，这个方法的签名如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;executeQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementScope statementScope, Connection conn, String sql, Object[] parameters,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;skipResults,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;maxResults, RowHandlerCallback callback)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1341" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根据我们的诉求：在 SQL 执行前对 SQL 进行染色打标，那么可以直接在这个方法的第三个参数&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1830" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;String sql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;上打标，以下是拦截器的实现：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Around("execution(* com.ibatis.sqlmap.engine.execution.SqlExecutor.executeQuery(..))")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;aroundExecuteQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(ProceedingJoinPoint joinPoint)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 获取方法参数&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] args = joinPoint.getArgs();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sqlTemplate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;""&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;arg2&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(arg2&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;String) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 实际的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sqlTemplate = (String) arg2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sqlTemplate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// SQL 声明的 ID&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;""&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;arg0&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;args[&lt;span class="code-snippet__number"&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(arg0&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;StatementScope) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementScope&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statementScope&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;(StatementScope) arg0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;statementScope.getStatement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(statement !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mappedStatementId = statement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法调用栈&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按顺序创建打标的内容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 先打标后 SQL，避免有些平台展示 SQL 时进行尾部截断，而看不到染色信息&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;markingSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sqlTemplate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;] = markingSql;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 发生异常的话恢复最原始 SQL 保证执行&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;] = sqlTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 正常执行逻辑&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;joinPoint.proceed(args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1344" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;逻辑上非常简单，获取了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1833" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatementId&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和线程的执行堆栈以注释的形式标记在 SELECT 语句前，注意如果大家要&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1841"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;对 INSERT 语句进行打标时，需要将标记打在 SQL 的最后&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，因为部分插件如&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1839" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InsertStatementParser&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;会识别 INSERT，如果注释在前，INSERT 识别会有误报错。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1346" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;验证织入&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1347" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成以上工作后，我们需要验证拦截器是否织入成功，因为织入是在编译期完成的，所以执行以下 Maven 编译命令即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="nginx"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__attribute"&gt;mvn&lt;/span&gt;&amp;nbsp;clean compile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1348" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="shell"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在控制枱中可以发现如下日志信息提示织入成功：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] --- aspectj-maven-plugin:&lt;span class="code-snippet__number"&gt;1.11&lt;/span&gt;:compile (&lt;span class="code-snippet__literal"&gt;default&lt;/span&gt;) @ ---&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] Showing AJC message detail&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;messages of types: [error, warning, fail]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] Join point&amp;nbsp;&lt;span class="code-snippet__string"&gt;'method-execution(void com.ibatis.sqlmap.engine.execution.SqlExecutor.executeQuery(com.ibatis.sqlmap.engine.scope.StatementScope, java.sql.Connection, java.lang.String, java.lang.Object[], int, int, com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback))'&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;in&lt;/span&gt;&amp;nbsp;Type&amp;nbsp;&lt;span class="code-snippet__string"&gt;'com.ibatis.sqlmap.engine.execution.SqlExecutor'&lt;/span&gt;&amp;nbsp;(SqlExecutor.java:&lt;span class="code-snippet__number"&gt;163&lt;/span&gt;) advised&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;by&lt;/span&gt;&amp;nbsp;around advice&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;from&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;'com.your.package.sqlmarking.SqlExecutorInterceptor'&lt;/span&gt;&amp;nbsp;(SqlExecutorInterceptor.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;(&lt;span class="code-snippet__keyword"&gt;from&lt;/span&gt;&amp;nbsp;SqlExecutorInterceptor.java))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1348" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="shell"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;并且在相应的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1846" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;target/classes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;目录下的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1848" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlExecutor.class&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;文件中也能发现被织入的逻辑：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;executeQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementScope statementScope, Connection conn, String sql, Object[] parameters,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;skipResults,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;maxResults, RowHandlerCallback callback)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; JoinPoint.&lt;span class="code-snippet__type"&gt;StaticPart&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var10000&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ajc$tjp_0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] var24 =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;[]{statementScope, conn, sql, parameters, Conversions.intObject(skipResults), Conversions.intObject(maxResults), callback};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;JoinPoint&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var23&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;Factory.makeJP(var10000,&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;, var24);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var26&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;SqlExecutorInterceptor.aspectOf();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] var25 =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;[]{&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;, statementScope, conn, sql, parameters, Conversions.intObject(skipResults), Conversions.intObject(maxResults), callback, var23};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var26.aroundExecuteQuery((&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutor$AjcClosure1&lt;/span&gt;(var25)).linkClosureAndJoinPoint(&lt;span class="code-snippet__number"&gt;69648&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;section style="text-align: center;margin-bottom: 8px;" data-pm-slice="0 0 []"&gt; 
  &lt;span style="font-size: 16px;letter-spacing: normal;"&gt;&lt;span leaf=""&gt;&lt;img alt="图片" class="rich_pages wxw-img" data-imgfileid="100028809" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/46c7d8db-baf6-4d84-b93c-634d251ca487.png" data-type="webp" data-w="396" style="pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style="text-align: center;margin-bottom: 8px;" data-pm-slice="0 0 []"&gt; 
  &lt;span style="font-size: 16px;letter-spacing: normal;"&gt;&lt;span leaf=""&gt;扫一扫，加入技术交流群&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style="display: none;"&gt; 
  &lt;mp-style-type data-value="3"&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style="color: #858585; font-size: 13px;"&gt;本文分享自微信公众号 - 京东云开发者（JDT_Developers）。&lt;br&gt;如有侵权，请联系 support@oschina.cn 删除。&lt;br&gt;本文参与「&lt;a href="https://www.oschina.net/sharing-plan" target="_blank"&gt;OSC 源创计划&lt;/a&gt;」，欢迎正在阅读的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18604552</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18604552</guid>
      <pubDate>Sat, 10 May 2025 08:35:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Solon Flow：轻量级流程编排引擎，让业务逻辑更优雅</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#24292e; text-align:start"&gt;在当今快速迭代的软件开发环境中，如何高效地管理和执行业务流程成为了开发者面临的重要挑战。Solon Flow 作为 Solon 生态中的流程编排引擎，以其轻量级、高灵活性和强大的表达能力，为开发者提供了一种全新的解决方案。&lt;/p&gt; 
&lt;h2&gt;为什么选择 Solon Flow？&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 是一款基于 YAML/JSON 配置的流程编排引擎，它完美融合了"配置即代码"的理念，具有以下核心优势：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;极简配置：采用 YAML/JSON 格式，配置简洁直观，支持自动推断和简化模式&lt;/li&gt; 
 &lt;li&gt;多场景支持：无缝支持业务规则编排、计算任务编排、审批流程等多种场景&lt;/li&gt; 
 &lt;li&gt;强大脚本能力：内置完整 Java 语法支持，可与多种脚本引擎集成&lt;/li&gt; 
 &lt;li&gt;事件驱动架构：基于 DamiBus 实现的事件总线，实现组件间解耦&lt;/li&gt; 
 &lt;li&gt;双模式引擎：同时支持无状态和有状态流程，满足不同业务需求&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;快速入门体验&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;让我们通过一个简单的 Hello World 示例，感受 Solon Flow 的魅力：&lt;/p&gt; 
&lt;h3&gt;1. 添加依赖&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-flow&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 配置流程 (demo1.chain.yml)&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"c1"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"n1"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"n2"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"n2"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"n3"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"System.out.println(\"Hello Solon Flow!\");"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"n3"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. 执行流程&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;DemoApp&lt;/span&gt; &lt;span style="color:#a626a4"&gt;implements&lt;/span&gt; &lt;span style="color:#c18401"&gt;LifecycleBean&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; FlowEngine flowEngine;
    
    &lt;span style="color:#4078f2"&gt;@Override&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;start&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        flowEngine.eval(&lt;span style="color:#50a14f"&gt;"c1"&lt;/span&gt;); &lt;em&gt;// 输出：Hello Solon Flow!&lt;/em&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;核心功能解析&lt;/h2&gt; 
&lt;h3&gt;1. 灵活的流程配置&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 支持完整的流程图概念，包括链 (Chain)、节点 (Node) 和连接 (Link)。节点类型丰富：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;开始节点 (start)：流程入口，每个链必须有且只有一个&lt;/li&gt; 
 &lt;li&gt;活动节点 (activity)：执行具体任务，支持条件和脚本&lt;/li&gt; 
 &lt;li&gt;网关节点 (inclusive/exclusive/parallel)：控制流程分支&lt;/li&gt; 
 &lt;li&gt;结束节点 (end)：流程终点&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;em&gt;# 审批流程示例&lt;/em&gt;
&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"leave-approval"&lt;/span&gt;
&lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"请假审批"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"发起申请"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;form:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"leave"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"tl-review"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"tl-review"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"主管审批"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;role:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"team-leader"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"gate-3days"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"gate-3days"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"exclusive"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; [
      {&lt;span style="color:#986801"&gt;nextId:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"dm-review"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"超过 3 天"&lt;/span&gt;, &lt;span style="color:#986801"&gt;condition:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"days &amp;gt; 3"&lt;/span&gt;},
      {&lt;span style="color:#986801"&gt;nextId:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"3 天内"&lt;/span&gt;}
    ]}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"dm-review"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"部门经理审批"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;role:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"dept-manager"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 强大的脚本与表达式&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 默认支持完整的 Java 语法脚本，同时可通过定制驱动器集成 Aviator、Beetl 等脚本引擎：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;em&gt;# 业务规则示例&lt;/em&gt;
&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"risk-control"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"score &amp;lt; 60"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"context.result = '高风险'; actions.add('人工审核')"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"score &amp;gt;= 60 &amp;amp;&amp;amp; score &amp;lt; 80"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"context.result = '中风险'"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"score &amp;gt;= 80"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"context.result = '低风险'; actions.add('自动通过')"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. 组件化开发模式&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;通过实现 TaskComponent 接口，可以将业务逻辑封装为可复用的组件：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component("scoreCalc")&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;ScoreCalculator&lt;/span&gt; &lt;span style="color:#a626a4"&gt;implements&lt;/span&gt; &lt;span style="color:#c18401"&gt;TaskComponent&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Override&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;run&lt;/span&gt;&lt;span&gt;(FlowContext context, Node node)&lt;/span&gt; {
        &lt;span style="color:#986801"&gt;Order&lt;/span&gt; &lt;span style="color:#986801"&gt;order&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; context.get(&lt;span style="color:#50a14f"&gt;"order"&lt;/span&gt;);
        &lt;em&gt;// 计算逻辑...&lt;/em&gt;
        order.setScore(calculateScore(order));
    }
    
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; &lt;span style="color:#986801"&gt;int&lt;/span&gt; &lt;span style="color:#4078f2"&gt;calculateScore&lt;/span&gt;&lt;span&gt;(Order order)&lt;/span&gt; {
        &lt;em&gt;// 评分算法实现&lt;/em&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在流程中引用组件：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"order-process"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"@scoreCalc"&lt;/span&gt;}  &lt;em&gt;# 使用评分组件&lt;/em&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"@riskCheck"&lt;/span&gt;}  &lt;em&gt;# 使用风控组件&lt;/em&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;4. 事件驱动架构&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 内置基于 DamiBus 的事件总线，实现组件间解耦：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;em&gt;# 事件发送示例&lt;/em&gt;
&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"event-demo"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;|
      // 发送事件
      context.eventBus().send("order.created", order);
&lt;/span&gt;  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;|
      // 发送并等待响应
      String result = context.&amp;lt;String,String&amp;gt;eventBus()
          .sendAndRequest("risk.check", order);
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;事件监听处理：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RiskListener&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; FlowEngine engine;
    
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        &lt;span style="color:#986801"&gt;FlowContext&lt;/span&gt; &lt;span style="color:#986801"&gt;context&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;FlowContext&lt;/span&gt;();
        context.&amp;lt;String,String&amp;gt;eventBus().listen(&lt;span style="color:#50a14f"&gt;"risk.check"&lt;/span&gt;, event -&amp;gt; {
            &lt;span style="color:#986801"&gt;Order&lt;/span&gt; &lt;span style="color:#986801"&gt;order&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; event.getContent();
            event.reply(checkRisk(order));
        });
        
        engine.eval(&lt;span style="color:#50a14f"&gt;"event-demo"&lt;/span&gt;, context);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;企业级特性&lt;/h2&gt; 
&lt;h3&gt;1. 有状态流程支持&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;对于审批类场景，Solon Flow 提供了 StatefulFlowEngine：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 配置有状态引擎&lt;/em&gt;
&lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; StatefulFlowEngine &lt;span style="color:#4078f2"&gt;flowEngine&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
    &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; StatefulFlowEngine.newInstance(
        StatefulSimpleFlowDriver.builder()
            .stateController(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;RoleBasedStateController&lt;/span&gt;())
            .stateRepository(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;RedisStateRepository&lt;/span&gt;())
            .build()
    );
}

&lt;em&gt;// 审批处理示例&lt;/em&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;approve&lt;/span&gt;&lt;span&gt;(String instanceId, String nodeId, String userId)&lt;/span&gt; {
    &lt;span style="color:#986801"&gt;FlowContext&lt;/span&gt; &lt;span style="color:#986801"&gt;context&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;FlowContext&lt;/span&gt;(instanceId).put(&lt;span style="color:#50a14f"&gt;"user"&lt;/span&gt;, userId);
    flowEngine.postActivityState(context, nodeId, StateType.COMPLETED);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 拦截器机制&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;通过 ChainInterceptor 可以实现流程监控、日志记录等横切关注点：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;MetricsInterceptor&lt;/span&gt; &lt;span style="color:#a626a4"&gt;implements&lt;/span&gt; &lt;span style="color:#c18401"&gt;ChainInterceptor&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Override&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;doIntercept&lt;/span&gt;&lt;span&gt;(ChainInvocation inv)&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; Throwable {
        &lt;span style="color:#986801"&gt;long&lt;/span&gt; &lt;span style="color:#986801"&gt;start&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; System.currentTimeMillis();
        &lt;span style="color:#a626a4"&gt;try&lt;/span&gt; {
            inv.invoke();
        } &lt;span style="color:#a626a4"&gt;finally&lt;/span&gt; {
            &lt;span style="color:#986801"&gt;long&lt;/span&gt; &lt;span style="color:#986801"&gt;cost&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; System.currentTimeMillis() - start;
            Metrics.record(inv.getChain().id(), cost);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. 多环境支持&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 可以轻松集成到各种环境：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// Spring 集成示例&lt;/em&gt;
&lt;span style="color:#4078f2"&gt;@Configuration&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;SpringConfig&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; FlowEngine &lt;span style="color:#4078f2"&gt;flowEngine&lt;/span&gt;&lt;span&gt;(ApplicationContext ctx)&lt;/span&gt; {
        &lt;span style="color:#986801"&gt;FlowEngine&lt;/span&gt; &lt;span style="color:#986801"&gt;engine&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; FlowEngine.newInstance();
        engine.register(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;SimpleFlowDriver&lt;/span&gt;(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;SpringAdapter&lt;/span&gt;(ctx)));
        engine.load(&lt;span style="color:#50a14f"&gt;"classpath:flows/**/*.yml"&lt;/span&gt;);
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; engine;
    }
}

&lt;em&gt;// 原生 Java 环境&lt;/em&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;NativeApp&lt;/span&gt; {
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;static&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; {
        &lt;span style="color:#986801"&gt;FlowEngine&lt;/span&gt; &lt;span style="color:#986801"&gt;engine&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; FlowEngine.newInstance();
        engine.load(&lt;span style="color:#50a14f"&gt;"file:conf/flows/*.json"&lt;/span&gt;);
        engine.eval(&lt;span style="color:#50a14f"&gt;"main-flow"&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;典型应用场景&lt;/h2&gt; 
&lt;h3&gt;1. 业务规则引擎&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;替代 Drools 等规则引擎，配置更简单：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"discount-rule"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"user.level == 'VIP' &amp;amp;&amp;amp; cart.total &amp;gt; 1000"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"cart.discount = 0.2"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"user.level == 'VIP'"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"cart.discount = 0.1"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;when:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"cart.total &amp;gt; 500"&lt;/span&gt;, &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"cart.discount = 0.05"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 计算任务编排&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;类似 LiteFlow 的编排能力，但风格很不同：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"data-pipeline"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"@dataExtract"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"@dataTransform"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;task:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"@dataLoad"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. 审批流程管理&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;类似 Flowable 的效果。支持会签、或签等审批模式：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"contract-approval"&lt;/span&gt;
&lt;span style="color:#986801"&gt;layout:&lt;/span&gt;
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"start"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"发起合同"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"finance"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"finance"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"parallel"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"财务会签"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; [&lt;span style="color:#50a14f"&gt;"f1"&lt;/span&gt;, &lt;span style="color:#50a14f"&gt;"f2"&lt;/span&gt;]}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"f1"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"财务经理审批"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;role:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"finance-mgr"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"join"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"f2"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"财务总监审批"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;role:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"finance-dir"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"join"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"join"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"parallel"&lt;/span&gt;, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"legal"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;id:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"legal"&lt;/span&gt;, &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"activity"&lt;/span&gt;, &lt;span style="color:#986801"&gt;title:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"法务审核"&lt;/span&gt;, &lt;span style="color:#986801"&gt;meta:&lt;/span&gt; {&lt;span style="color:#986801"&gt;role:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"legal"&lt;/span&gt;}, &lt;span style="color:#986801"&gt;link:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
  &lt;span style="color:#4078f2"&gt;-&lt;/span&gt; { &lt;span style="color:#986801"&gt;type:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"end"&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;为什么 Solon Flow 值得尝试？&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;学习成本低：基于熟悉的 YAML/JSON 配置，半小时即可上手&lt;/li&gt; 
 &lt;li&gt;无缝集成：轻松融入 Spring、Solon 等各种 Java 生态&lt;/li&gt; 
 &lt;li&gt;性能优异：轻量级设计，单线程每秒可执行上万次简单流程&lt;/li&gt; 
 &lt;li&gt;灵活扩展：支持驱动器定制，满足各种特殊需求&lt;/li&gt; 
 &lt;li&gt;生产验证：已在多家企业生产环境稳定运行&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Solon Flow 重新定义了流程编排的方式，让开发者能够以更声明式的方式表达业务逻辑，大幅提升开发效率的同时，保证了系统的可维护性和扩展性。无论是简单的业务规则，还是复杂的审批流程，Solon Flow 都能优雅应对。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357211</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357211</guid>
      <pubDate>Sat, 10 May 2025 08:02:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>Anthropic 未经许可使用书籍训练 AI 模型属于「合理使用」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美国旧金山联邦法官威廉・阿尔苏普（William Alsup）&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Flegal%2Flitigation%2Fanthropic-wins-key-ruling-ai-authors-copyright-lawsuit-2025-06-24%2F" target="_blank"&gt;裁定&lt;/a&gt;&lt;/u&gt;，&lt;strong&gt;Anthropic 在未经作者许可的情况下使用已出版书籍训练其 AI 模型属于「合理使用 (fair use)」&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0625/153420_i6T1_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这标志着法院首次认可 AI 公司的主张，即当 AI 公司使用受版权保护的材料训练大型语言模型（LLM）时，合理使用原则可使其免于承担责任。&lt;/p&gt; 
&lt;p&gt;法官指出，AI 模型对作品的训练类似于读者阅读并从中汲取灵感以创作新内容，而非复制或取代原作。然而，判决也指出，Anthropic 在 2021 年至 2022 年期间从 Books3、Library Genesis 和 Pirate Library Mirror 等来源下载的超过 700 万本盗版电子书不属于合理使用，这部分内容将面临陪审团审判。Anthropic 曾花费数百万美元购买并扫描大量印刷书籍，将其转换为数字格式用于内部研究。&lt;/p&gt; 
&lt;p&gt;这一裁决被认为是 AI 行业在版权合理使用方面的一个重要里程碑。同时对作者、艺术家和出版商是一个打击，他们已对 OpenAI、Meta、Midjourney、Google 等公司提起数十起诉讼。尽管这一裁决并不能保证其他法官会效仿阿尔苏普法官的做法，但它为支持科技公司而非创作者的先例奠定了基础。&lt;/p&gt; 
&lt;p&gt;这些诉讼通常取决于法官如何解释合理使用原则，这是版权法中一个出了名难以界定的例外条款，该条款自 1976 年以来就未更新过 —— 那时互联网尚未出现，更不用说生成式 AI 训练数据集的概念了。&lt;/p&gt; 
&lt;p&gt;合理使用裁决会考虑作品的使用目的（模仿和教育用途可能是可行的）、是否为商业利益而复制（你可以写《星球大战》同人小说，但不能出售），以及衍生作品与原作相比的转换性程度。&lt;/p&gt; 
&lt;p&gt;像 Meta 这样的公司在为使用受版权保护的作品进行训练辩护时也提出了类似的合理使用论点，不过在本周的裁决之前，法院会如何裁决还不太明确。&lt;/p&gt; 
&lt;p&gt;在这起具体的 Bartz 诉 Anthropic 案中，原告作者团体还对 Anthropic 获取和存储他们作品的方式提出了质疑。根据诉讼称，Anthropic 试图创建一个 「中央图书馆」，收录 「世界上所有的书籍」 并 「永久」 保存。但这些受版权保护的数百万本书籍是从盗版网站免费下载的，这显然是非法的。&lt;/p&gt; 
&lt;p&gt;尽管法官承认 Anthropic 对这些材料的训练属于合理使用，但法院将对 「中央图书馆」 的性质进行审判。&lt;/p&gt; 
&lt;p&gt;「我们将对用于创建 Anthropic 中央图书馆的盗版副本及其造成的损害进行审判」， 阿尔苏普法官在裁决中写道，「Anthropic 后来购买了一本之前从互联网上窃取的书，并不能免除其盗窃责任，但可能会影响法定损害赔偿的程度。」&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相关阅读：&lt;a href="https://www.oschina.net/news/353744" target="news"&gt;Reddit&amp;nbsp;起诉 Anthropic 未经许可使用其数据训练 AI 模型&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357201</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357201</guid>
      <pubDate>Sat, 10 May 2025 07:34:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>WinRAR「压缩包」再度开售，价格和 5 份 WinRAR 正版授权相当</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;WinRAR 官方手提包周边于 2025 年 2 月首次由 WinRAR 与制造商 Tern 联动推出，当时迅速售罄。近日，Tern &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Ftern_et%2Fstatus%2F1935705139429470405" target="_blank"&gt;宣布这款「压缩包」再次开售&lt;/a&gt;，并将于 9 月开始发货。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1052" src="https://static.oschina.net/uploads/space/2025/0625/150540_IMgE_2720166.png" width="1300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="858" src="https://static.oschina.net/uploads/space/2025/0625/150922_XENV_2720166.png" width="1146" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下是具体信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;价格&lt;/strong&gt; ：定价 150 美元，按现汇率约合 1077 元人民币，相当于购买五份正版 WinRAR 软件的费用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;设计&lt;/strong&gt; ：尺寸为 21.4×14×7 厘米，外形参考 WinRAR 的图标设计，呈现出经典的粉、蓝、绿三色书本被皮带捆扎的设计，此次版本的肩带改为可拆卸式，使用夹子固定，方便用户根据需要调整。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;购买方式及发货时间&lt;/strong&gt; ：在 Tern 官网售卖，支持全球 DHL 邮寄，将于 2025 年 9 月发货。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;购买地址：https://in.tern.et/products/winrar-archive-messenger-bag-prod&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357195/winrar-archive-messenger-bag</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357195/winrar-archive-messenger-bag</guid>
      <pubDate>Sat, 10 May 2025 07:10:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>投资 140 亿却成竞争对手，微软遭遇 ChatGPT 企业市场</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;彭博社最新报道称，微软正面临一个尴尬局面：尽管该公司努力向企业推销 Copilot AI 助手，但越来越多的员工却更青睐其合作伙伴 OpenAI 的 ChatGPT，这一现象正在企业市场引发激烈竞争。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;知名药企安进公司的经历完美诠释了这一市场变化。去年春天，安进宣布为旗下 2 万名员工购买微软 Copilot，成为微软在生成式 AI 领域的重要客户案例。然而，仅仅 13 个月后，安进员工却纷纷转向使用 OpenAI 的 ChatGPT。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;安进高级副总裁肖恩·布鲁伊希表示："OpenAI 成功的秘诀在于，他们把产品做得极具趣味性。"他指出，ChatGPT 在研究和科学文献总结等任务中表现尤为出色，而 Copilot 更多是在配合微软自家软件使用时才显现优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;这种现象让微软与 OpenAI 之间的关系变得更加微妙。作为 OpenAI 的最大投资方，微软已累计投资近 140 亿美元，但现在却发现自己在企业市场与被投资方直接竞争。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="333" src="https://oscimg.oschina.net/oscnet/up-4e4e30f181b826c01ebfb42865d828ee27e.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;微软销售团队反映，在推广 Copilot 时经常措手不及，而公司又迫切希望快速扩大客户基础。与此同时，OpenAI 也在积极扩张企业业务，近期更是收购了 AI 代码助手 Windsurf，直接对标微软的 GitHub Copilot。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;尽管两款产品都基于 OpenAI 的大语言模型，但用户体验存在显著差异。许多企业发现，员工普遍更偏爱 ChatGPT，主要原因包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;更新速度&lt;/strong&gt;：OpenAI 的模型更新在微软软件中往往延迟数周才能落地&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;用户熟悉度&lt;/strong&gt;：很多职场人士早已在个人场景中体验过 ChatGPT&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;功能体验&lt;/strong&gt;：ChatGPT 在某些专业任务中表现更优&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;微软解释称，延迟更新是因为需要进行企业级安全测试和用户体验验证。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;面对这一竞争态势，不同企业采取了不同策略。纽约人寿保险公司决定在 12000 名员工中同时推广 ChatGPT 和 Copilot，根据使用反馈决定最终选择。金融科技公司 Finastra 选择微软 Copilot，看重其与微软办公软件的深度整合优势。贝恩咨询公司则向 16000 名员工部署 ChatGPT，绝大多数员工日常使用，而仅有约 2000 名员工使用 Copilot 且主要搭配 Excel。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 表示已拥有 300 万付费企业用户，短短几个月内增长 50%。微软则回应称 Copilot 已覆盖 70% 的财富 500 强企业，付费用户数量比去年同期增加两倍。在定价方面，微软 Copilot 每用户每月 30 美元，相比 ChatGPT 企业版的 60 美元更具价格优势，但 OpenAI 也推出了按使用量收费的灵活方案。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Gartner 分析师杰森·王认为，目前许多公司仍在小范围测试阶段，市场竞争格局尚未完全确定，但这无疑是"OpenAI 与微软之间的正面对决"。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357193</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357193</guid>
      <pubDate>Sat, 10 May 2025 07:10:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>支付宝为 AI 开发者提供国内首个「AI 打赏」服务</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;支付宝宣布为 AI 开发者提供国内首个「AI 打赏」服务，并首发上线蚂蚁百宝箱平台、阿里云百炼，为开发者提供便捷收款能力，进一步推动 AI 技术的商业化应用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;据介绍，「AI 打赏」服务旨在满足 AI 智能体内收取赞赏、小费等需求，为开发者提供一种轻量化的收款解决方案。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;个人开发者只需登录蚂蚁百宝箱平台或阿里云百炼，选择开通「AI 打赏」功能并给智能体挂载该服务，即可快速启用打赏功能。开通后，用户打赏的金额将直接转入开发者账户。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="546" src="https://oscimg.oschina.net/oscnet/up-d77d6a355574699398813e0bde3af584ec9.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;值得一提的是，今年 4 月，支付宝曾推出国内首个支付 MCP，助力 AI 开发者具备支付收款能力，实现服务订阅、付费解锁等商业化功能。而此次推出的「AI 打赏」服务，则更侧重于让用户主动表达赞赏和感谢，两者结合将形成基础付费与灵活激励并存的多元服务模式。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357178</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357178</guid>
      <pubDate>Sat, 10 May 2025 06:09:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 编辑器 Void 发布 Beta，可作为 Cursor 开源替代方案</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Void 是一款开源 AI 编辑器，可作为 Cursor 的替代品。Void&amp;nbsp;支持跟 Cursor 一样的功能，比如 Tab 补全代码，Ctrl + K 编辑选中内容，支持用 AI 搜索代码库，支持编辑和查看底层提示。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-a9e2f51d6bea16cac1680764e79150155e1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvoideditor%2Fvoid%2Freleases%2Ftag%2Fbeta" target="_blank"&gt;Void 最近发布了 Beta 版本&lt;/a&gt;，其作为 VS Code 的分支，旨在解决私有 AI 辅助编程工具的安全隐私和费用问题。闭源编辑器可能需要通过后端发送私有代码数据，这会带来隐私问题，另一个问题是持续的订阅费用。&lt;/p&gt; 
&lt;p&gt;Void 提供了多种选项，确保开发者能控制自己的数据。它能利用多种大模型，可以使用任何本地的 LLM 驱动，也可以使用 Claude、GPT 或 Gemini 的 API，不会留存你的数据，避开了第三方中间人。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357154/void-editor-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357154/void-editor-beta</guid>
      <pubDate>Sat, 10 May 2025 03:56:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>ElevenLabs 发布移动端 AI 语音工具 APP</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;ElevenLabs 是一家专注于开发人工智能语音模型和工具的 AI 公司，近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Felevenlabs.io%2Fblog%2Fintroducing-the-elevenlabs-app" target="_blank"&gt;宣布&lt;/a&gt;推出官方 ElevenLabs 移动应用，为用户提供最强大的 AI 语音工具，支持 iOS 和 Android 用户随时随地将文本转成语音片段。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e444a0db29602ba48998df1adbdf75133fd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，&lt;span&gt;ElevenLabs 的免费套餐为用户提供大约 10 分钟的音频生成时间。网页版与移动版应用之间共享信用额度，用户可以根据自身需求选择不同的模型，在成本与音质之间进行平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;应用还接入了 ElevenLabs 最新的 v3 alpha 文本转语音模型，该模型允许用户通过标签控制语音的情感表达。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-0bd8cefff977a3158c5aa87f0aa53985792.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相关阅读：&lt;a href="https://www.oschina.net/news/353936/eleven-v3-alpha" target="_blank"&gt;ElevenLabs 发布文本转语音模型 Eleven v3（Alpha 版）&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357151/elevenlabs-app</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357151/elevenlabs-app</guid>
      <pubDate>Sat, 10 May 2025 03:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>加州法院裁定使用版权内容训练 AI 合规</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;美国加州北区地方法院&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstorage.courtlistener.com%2Frecap%2Fgov.uscourts.cand.434709%2Fgov.uscourts.cand.434709.231.0_2.pdf" target="_blank"&gt;裁定&lt;/a&gt;&lt;span style="color:#000000"&gt;，Anthropic 公司在未经作者许可的情况下，使用已出版的书籍训练其 AI 模型是合法的。这标志着法院首次认可 AI 公司的说法，即合理使用原则可以免除 AI 公司在使用受版权保护的材料训练大语言模型（LLM）时的过错。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="373" src="https://oscimg.oschina.net/oscnet/up-882fd79bf13f9f7781721a1a048d0fa9333.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;根据科技媒体 AppleInsider 的报道，许多创作者和艺术家长期以来都在为人工智能公司未经许可抓取其作品而苦恼。这些公司利用抓取的数据来训练大型语言模型（LLM），并将其商业化，然而内容的原创者却未能得到应有的补偿。对此，Andrea Bartz、Charles Graeber 和 Kirk Wallace Johnson 于 2024 年向法院提起诉讼，指控 Anthropic 公司侵犯其版权，使用了盗版材料。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;法官 William Alsup 在裁决中支持了双方的部分请求，但最终认为用于训练特定大语言模型的副本属于合理使用。这一裁定意味着 AI 公司在训练其模型时可以合法使用受版权保护的内容，而这也让众多艺术家、音乐家和作家感到失望。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;对于这些创作者来说，这项决定可能会使他们面临更大的商业风险，AI 模型的生成能力有可能进一步侵蚀他们的作品价值。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Alsup 法官&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#242424"&gt;在判决书中明确表示:"我们将就 Anthropic 公司用于创建中央图书馆的盗版书籍及其造成的损失进行审理。Anthropic 公司后来购买了之前从网上盗取的书籍，这并不能免除其盗窃责任，但这可能会影响法定赔偿的数额。"&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357149</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357149</guid>
      <pubDate>Sat, 10 May 2025 03:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Redis 是单线程模型？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用过 Redis 的同学肯定都了解过一个说法，说 Redis 是单线程模型，那么实际情况是怎样的呢？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其实，我们常说 Redis 是单线程模型，&lt;strong&gt;是指 Redis 采用单线程的事件驱动模型，只有并且只会在一个主线程中执行 Redis 命令操作&lt;/strong&gt;，这意味着它在处理请求时不使用复杂的上下文切换或锁机制。尽管只是单线程的架构，但 Redis 通过非阻塞的 I/O 操作和高效的事件循环来处理大量的并发连接，性能仍然非常高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;然而在 Redis4.0 开始也引入了一些后台线程执行异步淘汰、异步删除过期 key、异步执行大 key 删除等任务，然后，在 Redis6.0 中引入了多线程 IO 特性，将 Redis 单节点访问请求从 10W 提升到 20W。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;而在去年 Valkey 社区发布的 Valkey8.0 版本，在 I/O 线程系统上进行了重大升级，特别是异步 I/O 线程的引入，使主线程和 I/O 线程能够并行工作，可实现最大化服务吞吐量并减少瓶颈，使得 Valkey 单节点访问请求可以提升到 100W。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;那么在 Redis6.0 和 Valkey8.0 中多线程 IO 是怎么回事呢？是否改变了 Redis 原有单线程模型？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;2024 年，Redis 商业支持公司 Redis Labs 宣布 Redis 核心代码的许可证从 BSD 变更为 RSALv2，明确禁止云厂商提供 Redis 托管服务，这一决定直接导致社区分裂。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;为维护开源自由，Linux 基金会联合多家科技公司（包括 AWS、Google、Cloud、Oracle 等）宣布支持 Valkey，作为 Redis 的替代分支。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Valkey8.0 系 Valkey 社区发布的首个主要大版本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;最新消息，在 Redis 项目创始人 antirez 今年加入 Redis 商业公司 5 个月后，Redis 宣传从 Redis8 开始，Redis 项目重新开源。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;本篇文章主要介绍 Redis6.0 多线程 IO 特性。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、Redis6.0 多线程 IO 概述&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多线程 IO，但多线程部分只是用来处理网络数据的读写和协议解析，&lt;strong&gt;执行命令仍然是单线程。默认是不开启的&lt;/strong&gt;，需要进程启动前开启配置，并且在运行期间无法通过&lt;strong&gt;&amp;nbsp;config set&amp;nbsp;&lt;/strong&gt;命令动态修改。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;参数与配置&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;多线程 IO 涉及下面两个配置参数：&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;# io-threads 4 &amp;nbsp;IO 线程数量
# io-threads-do-reads no &amp;nbsp;读数据及数据解析是否也用 IO 线程&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;表示 IO 线程数量，&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;设置为 1 时（代码中默认值），表示只使用主线程，不开启多线程 IO。因此，若要配置开启多线程 IO，需要设置&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;大于 1，但不可以超过最大值 128。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;但在默认情况下，Redis 只将多线程 IO 用于向客户端写数据，因为作者认为通常使用多线程执行读数据的操作帮助不是很大。如果需要使用多线程用于读数据和解析数据，则需要将参数&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;设置为&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;此两项配置&lt;strong&gt;参数在 Redis 运行期间无法通过&amp;nbsp;config set&amp;nbsp;命令修改，并且开启 SSL 时，不支持多线程 IO 特性。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;若机器 CPU 将至少超过 4 核时，则建议开启，并且至少保留一个备用 CPU 核，使用超过 8 个线程可能并不会有多少帮助。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;执行流程概述&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多线程 IO 后，读写数据执行流程如下所示：&lt;/span&gt;&lt;/p&gt; 
&lt;div style="text-align:left"&gt; 
 &lt;img src="https://static001.geekbang.org/infoq/f1/f1751e15cbe5116df1883b0155195ec5.png" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;流程简述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程，也会分配给主线程自己。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程先读取分配给自己的客户端数据，然后阻塞等待其他 IO 线程读取 socket 完毕。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 线程将请求数据读取并解析完成（这里只是读数据和解析、并不执行）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程通过单线程的方式执行请求命令。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程通过 RR（Round Robin）将回写客户端事件分配给这些 IO 线程，也会分配给主线程自己。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程同样执行部分写数据到客户端，然后阻塞等待 IO 线程将数据回写 socket 完毕。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;设计特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;IO 线程要么同时在读 socket，要么同时在写，不会同时读和写。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 线程只负责读写 socket 解析命令，不负责命令执行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程也会参与数据的读写。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;三、源码分析&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;多线程 IO 相关源代码都在源文件 networking.c 中最下面。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;初始化&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;主线程在 main 函数中调用 InitServerLast 函数，InitServerLast 函数中调用&lt;strong&gt;initThreadedIO 函数&lt;/strong&gt;，在 initThreadedIO 函数中根据配置文件中的线程数量，创建对应数量的 IO 工作线程数量。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;/* Initialize the data structures needed for threaded I/O. */
void&amp;nbsp;initThreadedIO(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; io_threads_active =&amp;nbsp;0;&amp;nbsp;/* We start with threads not active. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Don't spawn any thread if the user selected a single thread:
&amp;nbsp; &amp;nbsp; &amp;nbsp;* we'll handle I/O directly from the main thread. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1)&amp;nbsp;return;
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num &amp;gt; IO_THREADS_MAX_NUM) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverLog(LL_WARNING,"Fatal: too many I/O threads configured. "
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"The maximum number is %d.", IO_THREADS_MAX_NUM);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;exit(1);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Spawn and initialize the I/O threads. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i =&amp;nbsp;0; i &amp;lt; server.io_threads_num; i++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Things we do for all the threads including the main thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_list[i] =&amp;nbsp;listCreate();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(i ==&amp;nbsp;0)&amp;nbsp;continue;&amp;nbsp;/* Thread 0 is the main thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Things we do only for the additional threads. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_t&amp;nbsp;tid;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_init(&amp;amp;io_threads_mutex[i],NULL);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[i] =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[i]);&amp;nbsp;/* Thread will be stopped. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pthread_create(&amp;amp;tid,NULL,IOThreadMain,(void*)(long)i) !=&amp;nbsp;0) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverLog(LL_WARNING,"Fatal: Can't initialize IO thread.");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;exit(1);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads[i] = tid;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如果&lt;strong&gt;&amp;nbsp;io_threads_num&amp;nbsp;&lt;/strong&gt;的数量为 1，则只运行主线程，&lt;strong&gt;&amp;nbsp;io_threads_num&amp;nbsp;&lt;/strong&gt;的 IO 线程数量不允许超过 128。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;序号为 0 的线程是主线程，因此实际的工作线程数目是 io-threads - 1。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;初始化流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;为包括主线程在内的每个线程分配 list 列表，用于后续保存待处理的客户端。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;为主线程以外的其他 IO 线程初始化互斥对象 mutex，但是立即调用 pthread_mutex_lock 占有互斥量，将 io_threads_pending[i]设置为 0，接着创建对应的 IO 工作线程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;占用互斥量是为了创建 IO 工作线程后，可暂时等待后续启动 IO 线程的工作，因为 IOThreadMain 函数在 io_threads_pending[id] == 0 时也调用了获取 mutex，所以此时无法继续向下运行，等待启动。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在 startThreadedIO 函数中会释放 mutex 来启动 IO 线程工作。何时调用 startThreadedIO 打开多线程 IO，具体见下文的「多线程 IO 动态暂停与开启」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;IO 线程主函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;IO 线程主函数代码如下所示：&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;*IOThreadMain(void&amp;nbsp;*myid)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* The ID is the thread number (from 0 to server.iothreads_num-1), and is
&amp;nbsp; &amp;nbsp; &amp;nbsp;* used by the thread to just manipulate a single sub-array of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;long&amp;nbsp;id = (unsigned&amp;nbsp;long)myid;
&amp;nbsp; &amp;nbsp;&amp;nbsp;char&amp;nbsp;thdname[16];
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;snprintf(thdname,&amp;nbsp;sizeof(thdname),&amp;nbsp;"io_thd_%ld", id);
&amp;nbsp; &amp;nbsp;&amp;nbsp;redis_set_thread_title(thdname);
&amp;nbsp; &amp;nbsp;&amp;nbsp;redisSetCpuAffinity(server.server_cpulist);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for start */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;0; j &amp;lt;&amp;nbsp;1000000; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_pending[id] !=&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the main thread a chance to stop this thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_pending[id] ==&amp;nbsp;0) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_unlock(&amp;amp;io_threads_mutex[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(io_threads_pending[id] !=&amp;nbsp;0);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("[%ld] %d to handle\n", id, (int)listLength(io_threads_list[id]));
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Process: note that the main thread will never touch our list
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* before we drop the pending count to 0. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[id],&amp;amp;li);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_op == IO_THREADS_OP_WRITE) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;writeToClient(c,0);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;if&amp;nbsp;(io_threads_op == IO_THREADS_OP_READ) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;readQueryFromClient(c-&amp;gt;conn);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverPanic("io_threads_op value is unknown");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[id] =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("[%ld] Done\n", id);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;从 IO 线程主函数逻辑可以看到：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如果 IO 线程等待处理任务数量为 0，则 IO 线程一直在空循环，因此后面主线程给 IO 线程分发任务后，需要设置 IO 线程待处理任务数&lt;strong&gt;&amp;nbsp;io_threads_pending[id]&amp;nbsp;&lt;/strong&gt;，才会触发 IO 线程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果 IO 线程等待处理任务数量为 0，并且未获取到 mutex 锁，则会等待获取锁，暂停运行，由于主线程在创建 IO 线程之前先获取了锁，因此 IO 线程刚启动时是暂停运行状态，需要等待主线程释放锁，启动 IO 线程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 线程待处理任务数为 0 时，获取到锁并再次释放锁，是为了让主线程可以暂停 IO 线程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;只有 io_threads_pending[id]不为 0 时，则继续向下执行操作，根据 io_threads_op 决定是读客户端还是写客户端，从这里也可以看出 IO 线程要么&lt;strong&gt;同时读&lt;/strong&gt;，要么&lt;strong&gt;同时写&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;读数据流程&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;主线程将待读数据客户端加入队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;当客户端连接有读事件时，会触发调用 readQueryFromClient 函数，在该函数中会调用 postponeClientRead。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;readQueryFromClient(connection *conn) {
&amp;nbsp; &amp;nbsp; client *c = connGetPrivateData(conn);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;nread, readlen;
&amp;nbsp; &amp;nbsp; size_t qblen;
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Check if we want to read from the client later when exiting from
&amp;nbsp; &amp;nbsp; &amp;nbsp;* the event loop. This is the case if threaded I/O is enabled. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(postponeClientRead(c))&amp;nbsp;return;
&amp;nbsp; &amp;nbsp; ......以下省略
}


/* Return 1 if we want to handle the client read later using threaded I/O.
&amp;nbsp;* This is called by the readable handler of the event loop.
&amp;nbsp;* As a side effect of calling this function the client is put in the
&amp;nbsp;* pending read clients and flagged as such. */
int&amp;nbsp;postponeClientRead(client *c) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_active &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; server.io_threads_do_reads &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !ProcessingEventsWhileBlocked &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !(c-&amp;gt;flags &amp;amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_READ;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listAddNodeHead(server.clients_pending_read,c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;如果开启多线程，并且开启多线程读（io_threads_do_reads 为 yes），则将客户端标记为 CLIENT_PENDING_READ，并且加入 clients_pending_read 列表。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;然后 readQueryFromClient 函数中就立即返回，主线程没有执行从客户端连接中读取的数据相关逻辑，读取了客户端数据行为等待后续各个 IO 线程执行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;主线程分发并阻塞等待&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;主线程在 beforeSleep 函数中会调用 handleClientsWithPendingReadsUsingThreads 函数。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;/* When threaded I/O is also enabled for the reading + parsing side, the
&amp;nbsp;* readable handler will just put normal clients into a queue of clients to
&amp;nbsp;* process (instead of serving them synchronously). This function runs
&amp;nbsp;* the queue using the I/O threads, and process them in order to accumulate
&amp;nbsp;* the reads in the buffers, and also parse the first command available
&amp;nbsp;* rendering it in the client structures. */
int&amp;nbsp;handleClientsWithPendingReadsUsingThreads(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!io_threads_active || !server.io_threads_do_reads)&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;processed =&amp;nbsp;listLength(server.clients_pending_read);
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processed ==&amp;nbsp;0)&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("%d TOTAL READ pending clients\n", processed);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Distribute the clients across N different lists. */
&amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_read,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;item_id =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;target_id = item_id % server.io_threads_num;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeTail(io_threads_list[target_id],c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; item_id++;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the start condition to the waiting threads, by setting the
&amp;nbsp; &amp;nbsp; &amp;nbsp;* start condition atomic var. */
&amp;nbsp; &amp;nbsp; io_threads_op = IO_THREADS_OP_READ;
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;count =&amp;nbsp;listLength(io_threads_list[j]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[j] = count;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Also use the main thread to process a slice of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[0],&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;readQueryFromClient(c-&amp;gt;conn);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[0]);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for all the other threads to end their work. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;unsigned&amp;nbsp;long&amp;nbsp;pending =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending += io_threads_pending[j];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending ==&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("I/O READ All threads finshed\n");
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Run the list of clients again to process the new buffers. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(listLength(server.clients_pending_read)) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ln =&amp;nbsp;listFirst(server.clients_pending_read);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_READ;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listDelNode(server.clients_pending_read,ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_COMMAND) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_COMMAND;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processCommandAndResetClient(c) == C_ERR) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* If the client is no longer valid, we avoid
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* processing the client later. So we just go
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* to the next. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;processInputBuffer(c);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;processed;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;先检查是否开启多线程，以及是否开启多线程读数据（io_threads_do_reads），未开启直接返回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;检查队列 clients_pending_read 长度，为 0 直接返回，说明没有待读事件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;遍历 clients_pending_read 队列，通过 RR 算法，将队列中的客户端循环分配给各个 IO 线程，包括主线程本身。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;设置 io_threads_op = IO_THREADS_OP_READ，并且将 io_threads_pending 数组中各个位置值设置为对应各个 IO 线程分配到的客户端数量，如上面介绍，目的是为了使 IO 线程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程开始读取客户端数据，因为主线程也分配了任务。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程阻塞等待，直到所有的 IO 线程都完成读数据工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程执行命令。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;IO 线程读数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 IO 线程主函数中，如果&lt;strong&gt;&amp;nbsp;io_threads_op == IO_THREADS_OP_READ&amp;nbsp;，&lt;/strong&gt;则调用 readQueryFromClient 从网络中读取数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;IO 线程读取数据后，不会执行命令。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 readQueryFromClient 函数中，最后会执行 processInputBuffer 函数，在 processInputBuffe 函数中，如 IO 线程检查到客户端设置了 CLIENT_PENDING_READ 标志，则不执行命令，直接返回。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ......省略
/* If we are in the context of an I/O thread, we can't really
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* execute the command here. All we can do is to flag the client
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* as one that needs to process the command. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(c-&amp;gt;flags &amp;amp;&amp;nbsp;CLIENT_PENDING_READ) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_COMMAND;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ...... 省略&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;写数据流程&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;命令处理完成后，依次调用：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;addReply--&amp;gt;prepareClientToWrite--&amp;gt;clientInstallWriteHandler，将待写客户端加入队列 clients_pending_write。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;clientInstallWriteHandler(client *c) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Schedule the client to write the output buffers to the socket only
&amp;nbsp; &amp;nbsp; &amp;nbsp;* if not already done and, for slaves, if the slave can actually receive
&amp;nbsp; &amp;nbsp; &amp;nbsp;* writes at this stage. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!(c-&amp;gt;flags &amp;amp;&amp;nbsp;CLIENT_PENDING_WRITE) &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (c-&amp;gt;replstate ==&amp;nbsp;REPL_STATE_NONE&amp;nbsp;||
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;(c-&amp;gt;replstate ==&amp;nbsp;SLAVE_STATE_ONLINE&amp;nbsp;&amp;amp;&amp;amp; !c-&amp;gt;repl_put_online_on_ack)))
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Here instead of installing the write handler, we just flag the
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* client and put it into a list of clients that have something
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* to write to the socket. This way before re-entering the event
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* loop, we can try to directly write to the client sockets avoiding
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* a system call. We'll only really install the write handler if
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* we'll not be able to write the whole reply at once. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_WRITE;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeHead(server.clients_pending_write,c);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 beforeSleep 函数中调用 handleClientsWithPendingWritesUsingThreads。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;int&amp;nbsp;handleClientsWithPendingWritesUsingThreads(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;processed =&amp;nbsp;listLength(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processed ==&amp;nbsp;0)&amp;nbsp;return&amp;nbsp;0;&amp;nbsp;/* Return ASAP if there are no clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* If I/O threads are disabled or we have few clients to serve, don't
&amp;nbsp; &amp;nbsp; &amp;nbsp;* use I/O threads, but thejboring synchronous code. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1&amp;nbsp;||&amp;nbsp;stopThreadedIOIfNeeded()) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;handleClientsWithPendingWrites();
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Start threads if needed. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!io_threads_active)&amp;nbsp;startThreadedIO();
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("%d TOTAL WRITE pending clients\n", processed);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Distribute the clients across N different lists. */
&amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_write,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;item_id =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_WRITE;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;target_id = item_id % server.io_threads_num;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeTail(io_threads_list[target_id],c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; item_id++;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the start condition to the waiting threads, by setting the
&amp;nbsp; &amp;nbsp; &amp;nbsp;* start condition atomic var. */
&amp;nbsp; &amp;nbsp; io_threads_op = IO_THREADS_OP_WRITE;
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;count =&amp;nbsp;listLength(io_threads_list[j]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[j] = count;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Also use the main thread to process a slice of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[0],&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;writeToClient(c,0);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[0]);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for all the other threads to end their work. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;unsigned&amp;nbsp;long&amp;nbsp;pending =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending += io_threads_pending[j];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending ==&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("I/O WRITE All threads finshed\n");
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Run the list of clients again to install the write handler where
&amp;nbsp; &amp;nbsp; &amp;nbsp;* needed. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_write,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Install the write handler if there are pending writes in some
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* of the clients. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(clientHasPendingReplies(c) &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;connSetWriteHandler(c-&amp;gt;conn, sendReplyToClient) == AE_ERR)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;freeClientAsync(c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;processed;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;判断 clients_pending_write 队列的长度，如果为 0 则直接返回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;判断是否开启了多线程，若只有很少的客户端需要写，则不使用多线程 IO，直接在主线程完成写操作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果使用多线程 IO 来完成写数据，则需要判断是否先开启多线程 IO（因为会动态开启与暂停）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;遍历 clients_pending_write 队列，通过 RR 算法，循环将所有客户端分配给各个 IO 线程，包括主线程自身。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;设置 io_threads_op = IO_THREADS_OP_WRITE，并且将 io_threads_pending 数组中各个位置值设置为对应的各个 IO 线程分配到的客户端数量，目的是为了使 IO 线程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主线程开始写客户端数据，因为主线程也分配了任务，写完清空任务队列。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;阻塞等待，直到所有 IO 线程完成写数据工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;再次遍历所有客户端，如果有需要，为客户端在事件循环上安装写句柄函数，等待事件回调。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;多线程 IO 动态暂停与开启&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;从上面的写数据的流程中可以看到，在 Redis 运行过程中多线程 IO 是会动态暂停与开启的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在上面的写数据流程中，先调用 stopThreadedIOIfNeeded 函数判断是否需要暂停多线程 IO，&lt;strong&gt;当等待写的客户端数量低于线程数的 2 倍时，会暂停多线程 IO，&lt;/strong&gt;否则就会打开多线程。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;int&amp;nbsp;stopThreadedIOIfNeeded(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;pending = listLength(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Return ASAP if IO threads are disabled (single threaded mode). */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1)&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending &amp;lt; (server.io_threads_num*2)) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_active) stopThreadedIO();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在写数据流程 handleClientsWithPendingWritesUsingThreads 函数中，stopThreadedIOIfNeeded 返回 0 的话，就会执行下面的 startThreadedIO 函数，开启多线程 IO。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;startThreadedIO(void) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(server.io_threads_active&amp;nbsp;==&amp;nbsp;0);
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_unlock(&amp;amp;io_threads_mutex[j]);
&amp;nbsp; &amp;nbsp; server.io_threads_active&amp;nbsp;=&amp;nbsp;1;
}


void&amp;nbsp;stopThreadedIO(void) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* We may have still clients with pending reads when this function
&amp;nbsp; &amp;nbsp; &amp;nbsp;* is called: handle them before stopping the threads. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;handleClientsWithPendingReadsUsingThreads();
&amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(server.io_threads_active&amp;nbsp;==&amp;nbsp;1);
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[j]);
&amp;nbsp; &amp;nbsp; server.io_threads_active&amp;nbsp;=&amp;nbsp;0;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;从上面的代码中可以看出：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;开启多线程 IO 是通过释放 mutex 锁来让 IO 线程开始执行读数据或者写数据动作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;暂停多线程 IO 则是通过加锁来让 IO 线程暂时不执行读数据或者写数据动作，此处加锁后，IO 线程主函数由于无法获取到锁，因此会暂时阻塞。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_10"&gt;&lt;/span&gt; 
&lt;h1&gt;四、性能对比&lt;/h1&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;测试环境&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;两台物理机配置：CentOS Linux release 7.3.1611(Core) ，12 核 CPU1.5GHz，256G 内存（free 128G）。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;Redis 版本&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用 Redis6.0.6，多线程 IO 模式使用线程数量为 4，即&lt;strong&gt;&amp;nbsp;io-threads 4&amp;nbsp;&lt;/strong&gt;，参数&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;分别设置为&lt;strong&gt;&amp;nbsp;no&amp;nbsp;&lt;/strong&gt;和&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;，进行对比测试。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;压测命令&lt;/span&gt;&lt;/h2&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;redis-benchmark -h 172.xx.xx.xx -t set,get -n 1000000 -r 100000000 --threads ${threadsize} -d ${datasize} -c ${clientsize}


单线程 threadsize 为 1，多线程 threadsize 为 4
datasize 为 value 大小，分别设置为 128/512/1024
clientsize 为客户端数量，分别设置为 256/2000
如：./redis-benchmark -h 172.xx.xx.xx -t set,get -n 1000000 -r 100000000 --threads 4 -d 1024 -c 256&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;统计结果&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;当&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;为&lt;strong&gt;&amp;nbsp;no&amp;nbsp;&lt;/strong&gt;时，统计图表如下所示（c 2000 表示客户端数量为 2000）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet/up-604470825e1668f75a0927b74d09cdd58e1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;当&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;为&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;时，统计图表如下所示（c 256 表示客户端数量为 256）。&lt;/span&gt;&lt;/p&gt; 
&lt;div style="text-align:left"&gt; 
 &lt;img height="303" src="https://oscimg.oschina.net/oscnet/up-c53c725b46c9562ff0702a925aec3b10067.png" width="500" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;结论&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用 redis-benchmark 做 Redis6 单线程和多线程简单 SET/GET 命令性能测试：&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;从上面可以看到 GET/SET 命令在设置 4 个 IO 线程时，QPS 相比于大部分情况下的单线程，性能几乎是翻倍了。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;连接数越多，多线程优势越明显。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;value 值越小，多线程优势越明显。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用多线程读命令比写命令优势更加明显，当 value 越大，写命令越发没有明显的优势。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;参数&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;为 yes，性能有微弱的优势，不是很明显。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;总体来说，以上结果基本符合预期，结果仅作参考。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_16"&gt;&lt;/span&gt; 
&lt;h1&gt;五、6.0 多线程 IO 不足&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;尽管引入多线程 IO 大幅提升了 Redis 性能，但是 Redis6.0 的多线程 IO 仍然存在一些不足：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;CPU 核心利用率不足：当前主线程仍负责大部分的 IO 相关任务，并且当主线程处理客户端的命令时，IO 线程会空闲相当长的时间，同时值得注意的是，主线程在执行 IO 相关任务期间，性能受到最慢 IO 线程速度的限制。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 线程执行的任务有限：目前，由于主线程同步等待 IO 线程，线程仅执行读取解析和写入操作。如果线程可以异步工作，我们可以将更多工作卸载到 IO 线程上，从而减少主线程的负载。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;不支持带有 TLS 的 IO 线程。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;最新的 Valkey8.0 版本中，通过引入异步 IO 线程，将更多的工作转移到 IO 线程执行，同时通过&lt;strong&gt;批量预读取内存数据&lt;/strong&gt;减少内存访问延迟，大幅提高 Valkey 单节点访问 QPS，单个实例每秒可处理 100 万个请求。我们后续再详细介绍 Valkey8.0 异步 IO 特性。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;六、总结&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多线程 IO，但多线程部分只是用来处理网络数据的读写和协议解析，&lt;strong&gt;执行命令仍然是单线程&lt;/strong&gt;。通过开启多线程 IO，并设置合适的 CPU 数量，可以提升访问请求一倍以上。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 多线程 IO 仍然存在一些不足，没有充分利用 CPU 核心，在最新的 Valkey8.0 版本中，引入异步 IO 将进一步大幅提升 Valkey 性能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;往期回顾&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;得物社区活动：组件化的演进与实践&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;从 CPU 冒烟到丝滑体验：算法 SRE 性能优化实战全揭秘｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;CSS 闯关指南：从手写地狱到「类」积木之旅｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以细节诠释专业，用成长定义价值——对话@孟同学 ｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;大语言模型的训练后量化算法综述 | 得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 竹径&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18628004</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18628004</guid>
      <pubDate>Sat, 10 May 2025 03:15:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Ubuntu 默认主题的「回收站」应用图标将更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Ubuntu 贡献者&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fubuntu%2Fyaru%2Fissues%2F1170" target="_blank"&gt;目前正在构思&lt;/a&gt;一个新的垃圾桶图标，该图标最早可能在 10 月份 Ubuntu 25.10 发布时出现在 Dock 栏中。&lt;/p&gt; 
&lt;p&gt;关于 Ubuntu 垃圾桶图标外观的讨论在 2019 年持续进行，直到同年 3 月结束。今年 5 月，该讨论再次重启，并定期更新图标建议。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5b02880cb80a289c29cbfec182c0689f9b6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;现有垃圾桶图标的主要缺陷在于，没有回收图标，它看起来更像一个信箱，而不是一个垃圾桶。当垃圾桶里有文件时，里面的文件看起来相当整齐，就像信件一样，这更让人觉得它是一个邮箱，而不是垃圾桶。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-cd86113e7df0a39fd3981f4d372b785a065.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;垃圾桶图标位于左侧 Dock 底部，看起来像一个信箱&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;目前建议的设计方案是顶部完全打开，以便更清楚地显示它是一个垃圾桶；当里面有文件时，会显示皱巴巴的纸张。设计师 ochi12 发布了多个图标版本，并将它们设置为不同的尺寸，以测试在不同用例下的效果。最新版本的图标在缩小尺寸后似乎依然能够正常显示。&lt;/p&gt; 
&lt;p&gt;目前，设计师仍在听取其他贡献者的反馈，因此，即使最终达成一致，目前做出的修改也不太可能最终在 Ubuntu 中实现。这一点也很重要，因为这些修改可能永远不会被达成一致，我们也就可能永远看不到它们真正实现。&lt;/p&gt; 
&lt;p&gt;值得注意的是，一些评论者表示他们喜欢现有的垃圾桶图标，希望它不要改变，这体现了垃圾桶图标本身的主观性。希望我们能够就设计达成共识，以便 Ubuntu 用户在升级到即将发布的 Ubuntu 版本时能够获得更新鲜的体验。&lt;/p&gt; 
&lt;p&gt;距离 10 月份 Ubuntu 25.10 发布还有很长一段时间，所以我们到那时就可以看到新的图标，但如果没有，也许我们会在 Ubuntu 26.04 LTS 中看到它。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357137</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357137</guid>
      <pubDate>Sat, 10 May 2025 02:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源 AI 助手平台 Cherry Studio 企业版开启公测</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cherry Studio &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFHtJqZlULDhRw7fT1ALagA" target="_blank"&gt;宣布&lt;/a&gt;其企业版已开始公测，这是专为企业打造的私有化 AI 生产力平台。&lt;/p&gt; 
&lt;p style="color:#1f2329; margin-left:0; margin-right:0; text-align:start"&gt;&lt;span style="color:#1f2329"&gt;&lt;span&gt;下表展示了两个版本之间的定位与功能差异：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-tap-highlight-color:transparent; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-color:#dee0e3; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:&amp;quot;PingFang SC&amp;quot;,system-ui,-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei UI&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,Arial,sans-serif; font-size:15px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:626px !important; min-width:297px; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:626px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对比维度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;社区版 （Community）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;企业版 （Enterprise）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目标用户&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人开发者、AI 爱好者&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中小型企业、大型企业内部团队、对数据安全有高要求的组织&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;✅ Github 开源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;⭕️ 针对伙伴客户端源码开放&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;商业模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人免费 / 商用授权&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;买断+可选服务费&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心差异&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;专注于个人生产力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;企业集中管理能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;部署方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;客户端应用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;客户端 + 服务端私有化部署&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心价值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;强大的个人 AI 辅助工具&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;安全、可控、高效的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cherry-ai.com%2Fenterprise" target="_blank"&gt;https://www.cherry-ai.com/enterprise&lt;/a&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;点击查看企业版体验手册：&lt;/p&gt; 
 &lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;https://doc.weixin.qq.com/doc/w3_ASIAPQaBALgCNdQv1pcxUTJGhXLsX?scode=APkA7AeJABIVWchL1vASIAPQaBALg&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;Cherry Studio 是一款支持多个大语言模型（LLM）服务商的开源桌面客户端，兼容 Windows、Mac 和 Linux 系统。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-23dab8c50bfcc8126ab84229b00dbc2115c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357134</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357134</guid>
      <pubDate>Sat, 10 May 2025 02:22:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
