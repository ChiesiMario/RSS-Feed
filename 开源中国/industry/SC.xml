<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://rsshub.app/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Tue, 28 May 2024 14:43:56 GMT</lastBuildDate>
        <ttl>180</ttl>
        <item>
            <title>开源日报 | Istio 七周岁；倪光南果然有远见；AI 搜索的诸神之战；「龙芯+鸿蒙」桌面 PC；马斯克激情对线；SaaS 的 PLG 模式</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2024.5.28&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要点&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/294636/happy-7th-birthday-istio&quot; target=&quot;_blank&quot;&gt;Istio 七周岁&lt;/a&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-aa0939d5f63acbd3a6b331f3a3a2c4e81a5.jpg&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 是一个由谷歌、IBM 和 Lyft 的团队于 2016 年开始合作开发的开源项目，在 2017 年正式推出；它是一个大型微服务系统管理工具，旨在提供一种统一化的微服务连接、安全保障、管理与监控方式；基于 Lyft 的 Envoy 项目构建。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8Zx0IAFwWpp&quot; target=&quot;_blank&quot;&gt;国产开源 Sora 上新：全面支持国产 AI 算力，可用 ReVideo 视频编辑&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;北大-兔展联合发起的 Sora 开源复现计划 Open-Sora-Plan，今起可以生成最长约 21 秒的视频了！该说不说，版本迭代速度还挺快——上个月，Open-Sora-Plan 就在开源社区上新过一波。当时能支持单镜头 16 秒的视频生成，分辨率最高 720p，能满足的生成需求也比较多样。&lt;/p&gt; 
&lt;p&gt;这次版本更新，背后主要是两个方面有了进步：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;采用了更高质量视觉数据与 caption&lt;/li&gt; 
 &lt;li&gt;优化了 CausalVideoVAE 的结构&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;团队还表示，Open-Sora-Plan 已经支持使用国产 AI 计算系统（华为升腾，期待更多国产算力芯片）进行完整的训练和推理。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F782033819_121400326&quot; target=&quot;_blank&quot;&gt;浪潮信息发布「源 2.0-M32」开源大模型&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;浪潮信息发布了「源 2.0-M32」 开源大模型。该模型在源 2.0 系列大模型基础上，采用了「基于注意力机制的门控网络」技术，构建包含 32 个专家的混合专家模型（MoE），并大幅提升模型算力效率。M32 凭借特别优化设计的模型架构，在仅激活 37 亿参数的情况下，取得了和 700 亿参数 LLaMA3 相当的性能水平，所消耗算力仅为 LLaMA3 的 1/19。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日观察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800286621157390695%26wfr%3Dspider%26for%3Dpc&quot; target=&quot;_blank&quot;&gt;比尔盖茨说得很对！中国芯迎重大突破，倪光南果然有远见&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;美国修改芯片规则限制华为等中企发展，中国芯片产业需突破尖端光刻机设备。芯片架构作为关键，X86 和 ARM 架构主导市场但面临被美控制风险。中国聚焦 RISC-V 架构研发，取得显著成果打破技术垄断，预示中国芯片产业将迎来辉煌未来。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;百家晓科技&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2795277930410887&quot; target=&quot;_blank&quot;&gt;马斯克 xAI 估值 240 亿美元，LeCun 隔空开怼，竟上升到人身攻击&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;这两天，AI 圈的瓜全被马斯克 LeCun 承包了。不论是在 AI 安全监管，还是 xAI 使命上，两人已经开启了激烈的隔空骂战。&lt;/p&gt; 
  &lt;p&gt;昨日，AI 领域两位重量级人物 Yann LeCun 和 Elon Musk 就人工智能的安全性和监管问题在社交媒体上「隔空交锋」。&lt;/p&gt; 
  &lt;p&gt;人工智能先驱 LeCun 在 X 上表达了他对正在进行的人工智能监管的看法。LeCun 认为，现在担心人工智能带来「生存风险」还为时过早，更别说对其进行监管了。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;新智元&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F782034856_114819&quot; target=&quot;_blank&quot;&gt;详解 SaaS 的 PLG 模式&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;这时的基础设施已经成为可以根据需要进行扩展的弹性实用程序，开发者可以从 API、模块化的工具中更快捷地编写软件，软件数量爆发式增长，新软件试用/使用的门槛逐渐走低。&lt;/p&gt; 
  &lt;p&gt;这一时期主要是 PLG，产品主导增长，决策权进一步下放到软件的真正使用者，他们的采购标准通常是——个人生产力，即该软件是否真的能帮助到我的日常工作？&lt;/p&gt; 
  &lt;p&gt;与此同时，一个新的线索衡量指标——PQL（Product Qualified Leads，产品合格线索）出现。MQL 通常依赖产品之外的公开课、白皮书、线下会议等方式获取，而 PQL 是用户真正体验产品后达到某些数据维度要求后的线索。有数据表明 PQL 的转化率通常为 15%～30%，远高于 MQL。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;人人都是产品经理&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1704750133%2FOgo1F2H4n%3Frefer_flag%3D1001030103_&quot; target=&quot;_blank&quot;&gt;NAS 开源的导航页&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;Heimdall，模块化设计，可以根据需要添加或删除模块。支持 Plex、Jellyfin、Nextcloud、Emby 等。可自定义主题和布局，支持多用户登录。&lt;/p&gt; 
  &lt;p&gt;Dashy，可定制性比较高，界面友好，可以拖拽操作。支持书签管理、应用快捷方式、服务状态监控等功能，非常适合 NAS 环境下的资源管理和快速访问。&lt;/p&gt; 
  &lt;p&gt;Organizr，支持用户权限管理，可以为不同用户分配不同的访问权限，模块丰富，比如 Sonarr、Radarr、Plex，插件也很丰富。&lt;/p&gt; 
  &lt;p&gt;SUI，极简风格，支持 JSON 文件快速配置，占用资源极少，适合在资源有限的 NAS 设备上运行。&lt;/p&gt; 
  &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9fe92adf9c6bea2b77c4dede62ac2f4c374.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;你的档案&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.doit.com.cn%2Fp%2F513146.html&quot; target=&quot;_blank&quot;&gt;《全球软件供应链发展报告》发布：JFrog 引导软件供应链安全市场&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;在通过开源生态系统引入漏洞方面，并非所有的软件技术都表现一样。虽然 Debian 和 RPM 的漏洞最多，但 NPM 和 PyPI 的严重 CVE 漏洞占比最大，其次是 Maven。大多数的 Debian 和 Alpine 代码库都是 C/C++代码和 Linux。由于二者都是 Linux 系统，用户很可能会在这两种软件包类型中发现相同的漏洞，Debian 的漏洞更多，因为它的应用更为广泛，贡献的软件包也更多。&lt;/p&gt; 
 &lt;p&gt;但是，存在 CVE 并不一定意味着该软件包不能使用，更要紧的是监控和防止恶意软件包进入软件供应链，因为即使只是下载这些软件包也可能使企业遭受攻击。攻击者也意识到，开源软件包和使用这些软件包的开发人员是安全漏洞的「黄金通行证」。他们的攻击方式往往是利用 CVE 带来的缺陷（通常是使用开源软件包的开发人员无意中造成），或者引入他们自己的恶意软件包，伪装成安全的开源组件。&lt;/p&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- DOIT&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.huxiu.com%2Farticle%2F3075895.html&quot; target=&quot;_blank&quot;&gt;AI 搜索的诸神之战&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;有人搜索如何让番茄酱粘在 Pizza 上，答案是用 1/8 杯无毒胶水。后来人们发现这是来自社区 Reddit 上 11 年前有人开玩笑的回答。谷歌自去年开始上线生成式 AI 搜索后，它总结出来的答案不时出错，这次全面推出的 Overview 功能，立刻翻车了。&lt;/p&gt; 
 &lt;p&gt;是不是推理不够，就用搜索来凑？这也是大模型幻觉的老问题，只是因为谷歌搜索的量太大了，问题会更加突出。还有一个把 Reddit 上的玩笑当科学的回答：猫舔你的手，是想先尝下你能否被消费。&lt;/p&gt; 
 &lt;p&gt;人们搜索到的东西越来越丰富，也越来越智能，但也令它们有了浮夸之感。&lt;/p&gt; 
 &lt;p&gt;人们开始怀念十多年前的谷歌，那时第一页上只出现十个蓝色的链接，并附有每个结果的页面标题和简短的文本片段。这种只有大约 10 个网页链接的简约设计，在第一页被称为「十个蓝色链接」格式。那时没有那么多的 Shit。&lt;/p&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ffffff; color:#2b2b2b&quot;&gt;未尽研究&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcio.zhiding.cn%2Fcio%2F2024%2F0528%2F3158096.shtml&quot; target=&quot;_blank&quot;&gt;CIO 指南：采用开源生成式 AI 需要注意的十件事&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;开源生成式 AI 模型是可以免费下载的、大规模使用而无需增加 API 调用成本的，并且可以在企业防火墙后面安全运行。但你不要放松警惕，风险仍然存在，有些风险不仅被放大了，而且针对生成式 AI 的新风险正在出现。&lt;/p&gt; 
  &lt;p&gt;企业应该知道该怎么做才能确保他们使用的是经过适当许可的代码，如何检查漏洞，如何保持所有内容都已经修补并保持最新状态。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 至顶网&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2794264329137796&quot; target=&quot;_blank&quot;&gt;OpenAI 悄悄招募了 Altman 投资的安全团队，但与超级对齐无关&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;Indent 成立于 2018 年，从事数据安全相关业务，它所提供的服务也很简单——自动化处理访问权限的审批流程。&lt;/p&gt; 
  &lt;p&gt;比如，当工程师需要查看生产服务器日志或客户支持需要敏感系统的管理员权限时，他们可以使用 Indent 的应用程序请求访问权限，而无需 IT 部门的帮助。审阅者可以通过 Slack 收到消息并直接从那里批准，然后一旦时间到期，访问权限就会自动撤销。&lt;/p&gt; 
  &lt;p&gt;Indent 为公司中的每个人提供按需访问控制，让他们可以在需要时访问自己需要的内容。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 甲子光年&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2794201924873859&quot; target=&quot;_blank&quot;&gt;马斯克 xAI 获 60 亿美元融资，要造一个「超级算力工厂」&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;xAI 新获得的 B 轮融资，在一定程度上帮助其解决了财务负担。但马斯克自己也曾承认，如果要在 AI 赛道拥有竞争力，那么每年至少要花几十亿美元。&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;无论是给人脑植入微芯片的 Neuralink ，做类人机器人的 Optimus， 还是智能的 Grok AI 助手，马斯克这些积极推进的项目都隐约指向一个终极目标：通用人工智能（AGI）。&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;xAI 还有很长的路要走，并且在努力成为规则改变者。不过，现在看来，英伟达可能才是目前最大的赢家。&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 爱范儿&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8Zx0IAFwWpq&quot; target=&quot;_blank&quot;&gt;多模态 CoT 思维链架构来了，现已开源｜来自厦大&amp;amp;腾讯优图&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;厦门大学&amp;amp;腾讯优图团队提出一种名为「领唱员（Cantor）」的决策感知多模态思维链架构，无需额外训练，性能大幅提升。&lt;/p&gt; 
  &lt;p&gt;在 ScienceQA 上，基于 GPT-3.5 的 Cantor 准确率达到了 82.39%，相比基于 GPT-3.5 的思维链方法提升了 4.08%。&lt;/p&gt; 
  &lt;p&gt;在更具挑战性的 MathVista 上，基于 Gemini 的 Cantor 准确率比原始 Gemini 提高了 5.9%。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 量子位&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;开源项目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fskylot%2Fjadx&quot; target=&quot;_blank&quot;&gt;skylot/jadx&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;324&quot; src=&quot;https://static.oschina.net/uploads/space/2022/0620/104307_gSwa_5430600.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fskylot%2Fjadx&quot; target=&quot;_blank&quot;&gt;https://github.com/skylot/jadx&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;JADX 是一个&amp;nbsp;Dex 到 Java 的反编译器，&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#24292f&quot;&gt;用于从 Android Dex 和 Apk 文件生成 Java 源代码。&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;JADX 有命令行和 GUI 两个版本。&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://my.oschina.net/u/5783135/blog/11194314&quot; target=&quot;_blank&quot;&gt;Bookie 存储架构源码剖析&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;Pulsar 作为新一代 MQ 中间件，在底层架构设计上充分贯彻了存算分离的思想，broker 与 Bookeeper 两个组件独立部署，前者负责流量的调度、聚合、计算，后者负责数据的存储，这也契合了云原生下 k8s 大行其道的时代背景。Bookeeper 又名 Bookie ，是一个单独的存储引擎。在组件关系上，broker 深度依赖 Bookie，内部集成了 Bookie 的 client 端，broker 和 Bookie 之间基于 TCP 通信，使用 protobuf。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;330&quot; src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7ae3724a6738446d9eaa24a3989b2304~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=KN6gea6ImIlHS7pxV%2BTu63QB%2B%2Bs%3D&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;div&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;事件点评&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FkNMJX3WEghxkOF81o_4ctw&quot; target=&quot;_blank&quot;&gt;龙芯自主龙架构 2024 年已适配 318 款产品、有望推出「龙芯+鸿蒙」桌面 PC&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;龙芯中科每个月都会公布 LoongArch 龙架构的生态适配进展，2024 年 4 月又新增了 110 款，加上此前 3 月的 101 款、1-2 月的 107 款，今年以来已达 318 款。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这些适配产品面向网络安全、数据安全、日常办公、智慧教学、人工智能、医疗健康等诸多领域。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;334&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0f07ad4a6460ea9f69e093282f112f8f5a1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;点评&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;龙芯与鸿蒙操作系统的结合，预示着国产软硬件强强联合的新局面。这种结合不仅能够推动国产操作系统的发展，还能促进国产处理器的市场竞争力。龙芯 3A6000 性能达到英特尔 10 代酷睿 i3 的水平，显示了国产处理器在性能上的显著提升。同时，二进制翻译技术的发展将有助于提高软件兼容性，进一步拓宽应用场景。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;LoongArch 龙架构在 2024 年已适配 318 款产品，这表明龙芯正在快速扩大其软件生态，这对于吸引更多开发者和企业使用龙芯平台至关重要。龙芯 3A6000 的成功不仅对处理器市场有积极影响，还将推动上下游产业链的发展，包括操作系统开发商、软件开发商和硬件制造商等。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;在全球半导体产业格局中，龙芯的发展也可能促进国际合作，同时在某些领域形成竞争，这对于全球技术进步和产业生态都是有益的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;虽然龙芯 3A6000 展现出良好的性能和自主化程度，但面对国际知名品牌的竞争，如何在市场中脱颖而出，仍是一个挑战。需要通过持续的技术创新、市场推广和用户体验优化来实现。&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
&lt;/ol&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294625&quot; target=&quot;_blank&quot;&gt;马斯克和 「AI 教父」 激情对线&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;起因是马斯克转发了一条为自己 xAI 公司招人的&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;推文&lt;/a&gt;。&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;没成想被有 「AI 教父」 之称的杨立昆当场拆台，言语间尽是嘲讽。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;342&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-42deaf887656eb50e3b3a7d15076d52d3b4.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;点评&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;马斯克和 LeCun 之间的争论不仅是两位科技领袖之间的观点碰撞，也反映了 AI 领域当前面临的一些关键问题和挑战。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;马斯克和 LeCun 分别代表了业界和学术界对于 AI 技术的不同立场。马斯克关于 AI 可能带来的风险和挑战的言论，引发了公众对于人工智能安全性和伦理问题的关注。这种担忧在一定程度上推动了对 AI 监管和伦理准则的讨论。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;争论触及了技术发展与伦理考量之间的平衡问题。如何在推动技术创新的同时确保伦理和社会责任，是 AI 领域亟待解决的问题。这场公开争论可能会影响未来的 AI 政策和法规制定。政策制定者可能会更加重视来自不同领域的意见和建议。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;争论中提出的观点和问题可能会激发 AI 研究者对现有技术和方法的反思，促进更深入的研究和创新。尽管存在分歧，但这样的公开讨论也可能促进不同背景的专家之间的合作，共同推动 AI 技术的发展和应用。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294691&quot; target=&quot;_blank&quot;&gt;百度沈抖回应大模型价格战：希望大家别再天天拉表格比价格&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;「其实我们决定免费的原因特别朴素，就是希望大家别再天天拉表格比价格了，有这个时间，不如去卷场景、卷应用。现在成本更低了，大家创新的胆子可以更大一些、步子可以更快一些，把相关的场景都试一遍，快速验证。跑成功了，就快速复制。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;258&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9e74eeb2b39092d87ea08dcc53d2999cd27.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;点评&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度沈抖的发言不仅是对当前 AI 大模型价格战的回应，也是对整个行业发展方向的一次重要引导。沈抖的发言体现了百度希望推动行业从价格竞争转向创新竞争的愿景。他鼓励业界不要过分关注价格比较，而是应该投入更多精力于探索应用场景和加速创新。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖的发言暗示了百度对未来 AI 应用的乐观态度，预计随着成本的降低和技术的成熟，AI 将在更多行业中发挥关键作用。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度的这一策略可能会改变 AI 大模型市场的竞争格局，促使其他企业也更加注重技术创新和服务优化，而非单纯的价格竞争。也可能对行业标准产生影响，促使业界思考如何制定更加健康、可持续的发展模式。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;开源之声&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.yoojia.com%2Farticle%2F8982063525401688813.html&quot; target=&quot;_blank&quot;&gt;从降价到免费，大模型的「进」与「退」&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;当前大模型在各行各业的应用落地处于初级阶段。除了价格，能否解决客户业务痛点并创造价值，是大模型发展的关键。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;- &lt;strong&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;中国证券报&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800209461494388621&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#2980b9&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;AI 出大招，苹果要出奇制胜&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;苹果在 AI 时代姗姗来迟，固然有等技术成熟的考量，但也付出了销量下滑的代价，如今面对同行竞争，苹果在 AI 上能否出奇制胜是市场关注重点，在专家看来，苹果在 AI 上预计也不会太激进，还是以巩固自身生态为第一目标。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;strong&gt;北京商报&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.21jingji.com%2Farticle%2F20240527%2Fherald%2F5f7b347c2787de4bf776584f95950075.html&quot; target=&quot;_blank&quot;&gt;美国大模型出口限制法案再进一步，「套壳」大模型危？&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#292934&quot;&gt;中国大模型市场要警惕「加拉帕戈斯隐忧」——加拉帕戈斯是太平洋上的一个群岛，它比喻的是在一个孤立的环境中，独自自我进化，逐步放弃对外交换。一旦再次面对外部适应性、生存能力更高的品种，最终会陷入被淘汰的危险。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&amp;nbsp;&lt;/span&gt;&lt;strong&gt;21 世纪经济报道&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800247492453152257&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#2980b9&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;「拼价格」推动大模型产业迈入新阶段&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;价格机制是市场机制的核心运行机制，价格竞争是市场竞争的集中体现。因为有价格竞争，企业才能感受到市场压力，从而努力提高生产效率、提升产品质量、强化产品差异化程度、用心服务客户，以保持性价比优势。价格竞争是一个产业从小到大、从弱到强的必经阶段，不可或缺。正是一轮轮价格竞争筛选出了一批批优质企业，让产业呈现出螺旋式上升的发展特征。因此，要做强产业，必然要经过价格竞争的洗礼，大模型产业也不例外。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;- &lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;中国经济网&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIa-OODj7x8PhkzQ2Sat6wQ&quot; target=&quot;_blank&quot;&gt;最适合写代码的等宽字体 Cascadia Code&lt;span&gt;——&lt;/span&gt;三年来首次大版本更新：由微软开源、新增两款 Nerd 字体&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：英文还是 JetBrain Mono，中文就改成落霞孤鹜了，这样写中文注释就像古文一样，coding 的时候特别有感觉&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：还是 Fira Code 和 JetBrain Mono 用在 IDE 里舒服一些，Cascadia Code 更适合终端&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：中英文全部包含的等宽只有，更纱黑体，github 搜 Sarasa Gothic，如果写代码不考虑中文等宽，github 搜 hack font 也不错&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 4：consolas yyds&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 5：手动尝试了一百多款字体，只有 mononoki 一款算得上是漂亮的字体&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 6：原汁原味最好了。连字体这种特性，屏蔽了其原始状态，个人认为不适合学习&lt;/span&gt; 
   &lt;ul&gt; 
    &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 7：那你可能没有遇到过终端需要显示图标的。&lt;/span&gt;&lt;/li&gt; 
   &lt;/ul&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 8：连字体真的是一项很变态的发明…严重降低了代码的可读性。对于新手，很多情况下，只能靠先把连字符号脑补为非连字的版本。而且经常需要仔细观察连字的宽度，来判断它到底是什么符号。真的是非常变态…即使对于常用者，你也很难熟记每一个符号的含义。冷不丁遇到一个不认识的符号，还得查它到底是什么。真的很烦。除了装，我想不到它到底有什么实用性。&lt;/span&gt; 
   &lt;ul&gt; 
    &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 9：常用的连字符就那么几种情况，基本上都是望文生义的，如果这都能对你编程造成影响，那我只能劝你多写代码了。而且这个也不是强制使用的，你完全可以不用，但是随意贬低可不是个好品质&lt;/span&gt;&lt;/li&gt; 
   &lt;/ul&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 10：个人认为最适合写代码的字体还得是 Hack。&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 11：Courier New&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 12：ubuntu mono 才是最好的&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 13：啥字体无所谓，我只求：1.g 不是这种花式写法，看了头疼；2.小 l 和 1 能区分开。如果不满足条件 1，我宁可用 Courier New 这种违背条件 2 的&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 14：一直在用这款字体，建议把 font weight 设置成 300，效果更加&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FkNMJX3WEghxkOF81o_4ctw&quot; target=&quot;_blank&quot;&gt;龙芯自主龙架构 2024 年已适配 318 款产品、有望推出「龙芯+鸿蒙」桌面 PC&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：龙芯加鸿蒙，那可以整一个来玩玩&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：草台班子套餐&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：只要有进步就应该支持、谁又不是从啥也不是开始的呢？&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 4：如果便宜点，倒可以整个来玩玩，&lt;img alt=&quot;[微笑]&quot; src=&quot;https://res.wx.qq.com/mpres/zh_CN/htmledition/comm_htmledition/images/pic/common/pic_blank.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;太贵可玩不起，&lt;img alt=&quot;[憨笑]&quot; src=&quot;https://res.wx.qq.com/mpres/zh_CN/htmledition/comm_htmledition/images/pic/common/pic_blank.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;穷鬼一枚&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 5：赶紧多卖点，把售价做下来&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 6：在？搞几台抽个奖&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_MYBiooOBtC5u7-m-JmC2A&quot; target=&quot;_blank&quot;&gt;原来东子的「兄弟」是用 let 定义的「兄弟」&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点:1：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;很好的文章，令我的前端知识增长&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;知识以一种奇怪的方式流进了我的脑&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：&lt;/span&gt; &lt;pre&gt;&lt;code&gt;let temp=(workingStatus===100%）?&quot;xiong di&quot;:「xiong die」;
doSomething(temp);&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 4：&lt;/span&gt; &lt;pre&gt;&lt;code&gt;if（剥削价值&amp;lt;30000/月）
      is_Bro = false&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 5：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;东哥的兄弟是未被 final 修饰的变量定义，可以随时在运行中重新赋值&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 6：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;本来就是这样，来混日子的，你能认他兄弟吗&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 7：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;所以说员工就是员工，不要拿兄弟这种词来套近乎&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 8：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;不能给企业带来利益谁跟你兄弟🤣 「兄弟」就是忽悠骡子干活的胡萝卜🥕，甚至还不如胡萝卜，胡萝卜还能拿来吃呢，「兄弟」能干什么？满足你跟大企业家「称兄道弟」的虚荣心吗？ 不过现在确实越来越难过了，钱越来越难赚，对于没资本的人而言就只能拼命干拼命干，也没啥别的路子能走。只能卷呗，不然谁给发钱啊？&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 9：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;起码人家加钱了&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 10：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;有价值才是兄弟&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 11：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;是 list 对象，随时可以 clear&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 12：&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;起码涨薪之后才说的，而且说的也没啥问题&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294608/tklog-released&quot; target=&quot;_blank&quot;&gt;Rust 的高效易用日志库 — tklog&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点:1：很好，支持自动分割！&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：示例写的真丑&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;最后，欢迎扫码下载「开源中国 APP」，阅读海量技术报告、程序员极客分享！&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d27cc3636c021c266537f4729dc0f84fdc3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294724</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294724</guid>
            <pubDate>Tue, 28 May 2024 12:32:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>「2024 亚太人工智能与机器人产业峰会暨 GOTC 全球开源技术峰会」即将召开！全球议题征集中</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span&gt;全球开源技术峰会（&lt;/span&gt;Global Open-source Technology Conference&lt;span&gt;，简称&lt;/span&gt; GOTC&lt;span&gt;）始于&lt;/span&gt; 2021 &lt;span&gt;年，是面向全球开发者的开源技术盛会。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1118&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0528/200945_gzDC_3820517.png&quot; width=&quot;1460&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;今年，中国人工智能学会与开源中国共同举办&lt;span style=&quot;color:#16a085&quot;&gt;「&lt;strong&gt;2024 亚太人工智能与机器人产业峰会暨 GOTC 全球开源技术峰会」&lt;/strong&gt;&lt;/span&gt;，将于&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;7 月 13-14 日&lt;/strong&gt;&lt;/span&gt;在&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;杭州&lt;/strong&gt;&lt;/span&gt;隆重举行。&lt;/p&gt; 
&lt;p&gt;本次峰会将汇聚全球顶尖的专家、学者、企业领袖及开源技术代表，深入探讨机器人技术、软件开发、开源技术和&lt;span&gt;AI&lt;/span&gt;大模型等前沿领域。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;会议将重点展示机器人在制造、医疗、物流和服务等行业的最新应用，探讨智能算法和自主学习能力如何提升机器人性能，并分享开源技术在推动技术创新与协作中的关键作用。此外，峰会还将关注&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;大模型的最新研究进展及其在实际应用中的挑战与机遇。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;通过主题演讲、圆桌讨论、技术展示和互动工作坊，与会者将有机会交流实践经验，探索前沿技术，促进跨领域合作，共同推动人工智能与机器人技术的发展。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;700&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0528/201022_qMk1_3820517.png&quot; width=&quot;2148&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;GOTC 2024 &lt;/strong&gt;&lt;span&gt;&lt;strong&gt;技术论坛&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;GOTC 2024 &lt;/span&gt;设置了涵盖不同主题的「技术论坛」，将深入探讨机器人技术、软件开发、开源技术和&lt;span&gt;AI&lt;/span&gt;大模型等前沿领域。通过主题演讲、圆桌讨论、技术展示和互动工作坊，与会者将有机会交流实践经验，探索前沿技术，促进跨领域合作，共同推动人工智能与机器人技术的发展。&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#f39c12&quot;&gt;&lt;strong&gt;议题征集等合作积极开展中，诚邀全球各技术领域开源爱好者共襄盛举。&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#f39c12&quot;&gt;提交议题：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgotc-2023.mikecrm.com%2FxNQWOFg&quot; target=&quot;_blank&quot;&gt;GOTC 2024 议题征集&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;204&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0528/201049_cWO3_3820517.png&quot; width=&quot;200&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛一：LLMOps 最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span&gt;LLMOps &lt;/span&gt;专门用于使用工具和方法来管理和自动化&lt;span&gt; LLM &lt;/span&gt;的生命周期，从微调到维护。通过特定于模型的操作，数据科学家、工程师和&lt;span&gt; IT &lt;/span&gt;团队可以高效地部署、监控和维护大型语言模型。&lt;/p&gt; 
&lt;p&gt;此论坛带领开发者探索和分享&lt;span&gt; LLMOps &lt;/span&gt;的最新实践、技术和工具。在这个论坛中，我们将深入讨论如何高效、可靠地管理和运维大规模语言模型，确保它们在生产环境中的最佳性能。议题内容涵盖：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;LLMOps &lt;/span&gt;概览：对&lt;span&gt; LLMOps &lt;/span&gt;的介绍，以及它在当前&lt;span&gt; LLM &lt;/span&gt;技术与应用中的位置与优势，以及挑战。&lt;/li&gt; 
 &lt;li&gt;效率提升：如何通过&lt;span&gt; LLMOps &lt;/span&gt;实现更快的模型开发、更高质量的模型交付以及更迅速的生产部署。&lt;/li&gt; 
 &lt;li&gt;可扩展性与自动化：&lt;span&gt;LLMOps &lt;/span&gt;如何支持大规模模型的监督、控制、管理和监控，以及如何实现持续集成、持续交付和持续部署。&lt;/li&gt; 
 &lt;li&gt;风险管理：&lt;span&gt;LLMOps &lt;/span&gt;如何提高透明度，快速响应监管审查请求，并确保更好地遵守组织或行业的政策。&lt;/li&gt; 
 &lt;li&gt;最佳实践案例：通过实际案例分析，学习如何应用&lt;span&gt; LLMOps &lt;/span&gt;的最佳实践，包括探索性数据分析（&lt;span&gt;EDA&lt;/span&gt;）、数据准备、提示工程、模型微调和模型审查。&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;技术工具与平台：当前流行的&lt;/span&gt; LLMOps &lt;span&gt;开源项目与平台，如&lt;/span&gt; Hugging Face Transformers&lt;span&gt;、&lt;/span&gt;LangChain&lt;span&gt;、&lt;/span&gt;Dify &lt;span&gt;等。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛二：开源数据库与 AI 协同创新&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;在当今数字化时代，&lt;span&gt;AI &lt;/span&gt;正以前所未有的速度重塑各行各业。而数据库，作为信息管理的核心，其与&lt;span&gt; AI &lt;/span&gt;的结合不仅为数据库领域带来革命性的变革，同时也为&lt;span&gt; AI &lt;/span&gt;自身的创新和发展提供了强大的数据支撑和应用场景。&lt;/p&gt; 
&lt;p&gt;当数据库遇上&lt;span&gt; AI&lt;/span&gt;，两者的结合能否激发出新的创新火花？数据库的高效索引技术，能否为&lt;span&gt; AI &lt;/span&gt;提供更精准的数据检索，从而提升其学习和决策能力？数据库的优化存储解决方案，是否能够支持&lt;span&gt; AI &lt;/span&gt;处理更大规模的数据集，推动其算法的进一步发展？数据库的自动化运维技术，又能否为&lt;span&gt; AI &lt;/span&gt;的持续学习和自我优化提供稳定可靠的运行环境？&lt;/p&gt; 
&lt;p&gt;此论坛将探讨智能索引优化、数据压缩革新、自动化运维进阶、业务决策智能化、&lt;span&gt;AI &lt;/span&gt;与数据库的融合未来、实战案例剖析等方面，探索&lt;span&gt; AI &lt;/span&gt;与数据库领域的结合能够为行业带来怎样革命性的变革。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛三：云原生与微服务架构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;此论坛专注于云原生技术与微服务架构深度融合，我们精心策划了一系列技术深度分享，涵盖从容器化、服务网格到持续集成与持续部署（&lt;span&gt;CI/CD&lt;/span&gt;）的全方位技术细节。参与者将有机会深入了解&lt;span&gt; Kubernetes &lt;/span&gt;在云原生环境中的最佳实践，以及如何利用微服务架构来提高系统的可扩展性和弹性。&lt;/p&gt; 
&lt;p&gt;此外，我们将深入探讨微服务架构中的服务发现、配置管理、分布式追踪等关键技术问题，并分享如何通过云原生技术实现微服务的自动化部署和管理，以及就微服务架构下的安全性、监控和日志管理等议题进行深入解析。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛四：全球开源人才及教育论坛&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;开源技术以其卓越的创新能力和协作精神在全球范围内迅速发展。开源人才是一个组织在全球化竞争中脱颖而出的关键。在&lt;span&gt;Linux &lt;/span&gt;基金会发布的《&lt;span&gt;2024 &lt;/span&gt;年度技术人才报告》指出，虽然我们从新闻中看到很多裁员的信息，但事实上，只有不到三分之一的组织正在减少技术人员数量，因此，投资现有员工是各个组织非常重要的任务，其中差不多&lt;span&gt;50%&lt;/span&gt;的组织在&lt;span&gt;2024&lt;/span&gt;年优先考虑提高现有员工的技能和交叉技能。云（&lt;span&gt; 55%&lt;/span&gt;）、&lt;span&gt;DevOps&lt;/span&gt;（&lt;span&gt;51%&lt;/span&gt;）、网络安全（&lt;span&gt;49%&lt;/span&gt;）和&lt;span&gt; AI/ML&lt;/span&gt;（&lt;span&gt;43%&lt;/span&gt;）等四个领域脱颖而出，成为人员配置优先考虑的关键技术领域。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;GOTC&lt;/span&gt;大会的全球开源人才及教育论坛，将由&lt;span&gt;LF&lt;/span&gt;开源软件学园全力支持。本次峰会中，来自不同领域的开源专家将讨论和分享现时最关键开源技术的发展趋势，开源教育及人才发展面临的挑战、开源用例和最佳实践，帮助行业培养更多的开源人才，帮助开发者了解参与开源的方式，开启开源职业生涯。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛五：多模态大模型的应用与实践&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;在这个专注于多模态大模型在各个领域应用与实践的论坛中，我们将探索如何结合文本、图像、声音等多种数据类型，利用多模态大模型推动人工智能的边界。&lt;/p&gt; 
&lt;p&gt;论坛将介绍多模态学习的理论基础，探讨如何通过整合不同模态的数据来提升模型的理解和生成能力。我们还将分享当前跨模态融合技术的最新进展，包括视觉&lt;span&gt;-&lt;/span&gt;语言模型、音频&lt;span&gt;-&lt;/span&gt;视觉模型等，并讨论在处理和分析多模态数据时所面临的挑战以及如何有效利用这些数据来训练和优化模型。&lt;/p&gt; 
&lt;p&gt;此外，论坛将深入探讨多模态大模型的设计和架构，包括注意力机制、&lt;span&gt;Transformer &lt;/span&gt;模型等在多模态任务中的应用。通过具体案例，我们将展示多模态大模型在医疗、教育、娱乐、自动驾驶等行业的应用，并分析如何构建交互式&lt;span&gt; AI &lt;/span&gt;系统，利用多模态输入提供更自然、更丰富的用户体验。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;论坛六：硬核 AI 技术创新与实践&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;这是极客开发者的盛会，我们相信，真正的技术创新不仅需要理论的深度，更需要实践的广度，以及极客式的探索。&lt;/p&gt; 
&lt;p&gt;本论坛汇聚开发者圈中的技术极客，分享他们在大&lt;span&gt; AI &lt;/span&gt;浪潮中的创新实践与经验。让你体会在老旧手机上搭建个人&lt;span&gt; AI &lt;/span&gt;知识库、利用开源工具和库，架构自己的大模型搜索引擎、为嵌入式设备定制轻量级的神经网络、手写一个&lt;span&gt; RAG &lt;/span&gt;系统等的挑战与乐趣，并从中学到硬核技能。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;AI WorkShop，大模型开发者实操营&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;大模型开发者实操营将提供一个实践空间，让参会者亲自动手，深入体验和探索&lt;span&gt; LLM &lt;/span&gt;的技术细节与应用潜力，并有&lt;span&gt; AI &lt;/span&gt;专家演示与交流。通过实际操作，让开发者们深入理解&lt;span&gt; LLM &lt;/span&gt;的工作原理和应用场景，鼓励开发者探索&lt;span&gt; LLM &lt;/span&gt;的新用途与新功能。&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#f39c12&quot;&gt;&lt;strong&gt;议题征集等合作积极开展中，诚邀全球各技术领域开源爱好者共襄盛举。&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#f39c12&quot;&gt;提交议题：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fgotc-2023.mikecrm.com%2FxNQWOFg&quot; target=&quot;_blank&quot;&gt;GOTC 2024 议题征集&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;204&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0528/201049_cWO3_3820517.png&quot; width=&quot;200&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#f39c12&quot;&gt;&lt;strong&gt;了解更多信息，请访问官网：&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://gotc.oschina.net/&quot;&gt;https://gotc.oschina.net&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;此次活动，开源中国联合中国人工智能学会共同宣发，开源行业品牌效应最大化，触达&lt;span&gt;500&lt;/span&gt;万开发者，&lt;span&gt;1500+&lt;/span&gt;国内外顶尖企业，覆盖所有开源中国注册会员&lt;span&gt; + Gitee &lt;/span&gt;个人用户&lt;span&gt;&amp;amp;&lt;/span&gt;企业用户&lt;span&gt; + &lt;/span&gt;中国人工智能学会会员&lt;span&gt; + LF &lt;/span&gt;会员单位&lt;span&gt;&amp;amp;&lt;/span&gt;社区，最大程度覆盖中国开源爱好者，同时在国际上发出中国开源之声。线上线下同步开启，届时将有&lt;span&gt; 100+ &lt;/span&gt;家国内外媒体进行报道，预估参会开发者人数&lt;span&gt; 2000+&lt;/span&gt;，全网观看人次&lt;span&gt; 5000000+&lt;/span&gt;，国际媒体曝光量达到&lt;span&gt; 50 &lt;/span&gt;万&lt;span&gt;+&lt;/span&gt;。&lt;/p&gt; 
&lt;h1&gt;&lt;span&gt;&lt;strong&gt;主办单位简介&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;中国人工智能学会&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;中国人工智能学会（&lt;span&gt;Chinese Association for Artificial Intelligence&lt;/span&gt;，&lt;span&gt;CAAI&lt;/span&gt;）成立于&lt;span&gt;1981&lt;/span&gt;年，是经国家民政部正式注册的我国智能科学技术领域唯一的国家级学会，是全国性&lt;span&gt;4A&lt;/span&gt;级社会组织，挂靠单位为北京邮电大学；是中国科学技术协会的正式团体会员，具有推荐&lt;span&gt;「&lt;/span&gt;两院院士&lt;span&gt;」&lt;/span&gt;的资格。&lt;/p&gt; 
&lt;p&gt;目前拥有&lt;span&gt;61&lt;/span&gt;个分支机构，包括&lt;span&gt;52&lt;/span&gt;个专业委员会和&lt;span&gt;9&lt;/span&gt;个工作委员会，覆盖了智能科学与技术领域。学会活动的学术领域是智能科学技术，活动地域是中华人民共和国全境，基本任务是团结全国智能科学技术工作者和积极分子通过学术研究、国内外学术交流、科学普及、学术教育、科技会展、学术出版、人才推荐、学术评价、学术咨询、技术评审与奖励等活动促进我国智能科学技术的发展，为国家的经济发展、社会进步、文明提升、安全保障提供智能化的科学技术服务。&lt;/p&gt; 
&lt;p&gt;中国人工智能学会最高荣誉&lt;span&gt;CAAI Fellow——&lt;/span&gt;包括&lt;span&gt;22&lt;/span&gt;位院士在内的&lt;span&gt;53&lt;/span&gt;位人工智能领域的工作者和人工智能产业领军人物，成为了首批&lt;span&gt;CAAI Fellow&lt;/span&gt;。其中包括图灵奖唯一华人得主姚期智、四院院士谭铁牛、中国工程院院士李德毅、香港科技大学教授杨强、南京大学教授周志华，清华大学教授马少平等一批知名专家学者均入选其中。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开源中国&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;开源中国成立于&lt;span&gt;2008&lt;/span&gt;年&lt;span&gt;8&lt;/span&gt;月，社区建立了相当完善的开源软件分类数据库，收录全球知名开源项目近&lt;span&gt; 10 &lt;/span&gt;万款，涉及不同技术和应用领域的数百个分类。围绕这些开源项目，&lt;span&gt;OSCHINA &lt;/span&gt;为中国开发者提供了最新开源资讯、开源知识普及、软件更新资讯、技术分享和交流的技术平台，不遗余力地推动国内开源软件的应用和发展，为本土开源技术能力的提高、开源生态环境的优化提供长期的推动力。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/&quot;&gt;https://www.oschina.net&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2013 &lt;/span&gt;年，开源中国建立了代码托管与&lt;span&gt; DevOps &lt;/span&gt;平台&lt;span&gt;「&lt;/span&gt;码云&lt;span&gt; Gitee」。&lt;/span&gt;&lt;span&gt;Gitee &lt;/span&gt;为开发者提供团队协作、源代码托管、代码质量分析、代码审查、测试、&lt;span&gt;CI/CD &lt;/span&gt;和代码演示等功能。现已有超&lt;span&gt; 1200 &lt;/span&gt;万注册开发者、超过&lt;span&gt; 2800 &lt;/span&gt;万个托管项目、&lt;span&gt;300,000 &lt;/span&gt;家企业客户和&lt;span&gt; 2000 &lt;/span&gt;所大学注册，是全球第二大代码托管平台。&lt;/p&gt; 
&lt;p&gt;经过&lt;span&gt; 16 &lt;/span&gt;年的发展和积累，开源中国不仅创立了开源技术社区&lt;span&gt; OSCHINA &lt;/span&gt;与代码托管与协作平台&lt;span&gt; Gitee&lt;/span&gt;，同时也研发了&lt;span&gt; Gitee &lt;/span&gt;私有化系列研发运营平台，专注服务金融、军工和央企等国民经济领域，助力政府和企业数字化转型，已经构建了中国开源产业的基础设施，并成为助力企业数字化转型的工业软件公司。&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://gitee.com/&quot;&gt;https://gitee.com&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;2023 &lt;/span&gt;年，开源中国推出&lt;span&gt; Gitee AI &lt;/span&gt;平台，&lt;span&gt;Gitee AI &lt;/span&gt;是基于&lt;span&gt; Git &lt;/span&gt;代码托管技术开发的针对&lt;span&gt; AI &lt;/span&gt;应用场景的开源平台，基于&lt;span&gt; Gitee &lt;/span&gt;多年在&lt;span&gt; Git &lt;/span&gt;代码和&lt;span&gt; LFS &lt;/span&gt;大文件托管方面的技术积累，为用户提供了快速、稳定的模型托管服务，让开发者轻松地分享和下载开源模型、数据集和&lt;span&gt; AI &lt;/span&gt;应用。在此基础上平台构建了三个核心功能：模型引擎、训练引擎、应用引擎，提供一站式的&lt;span&gt; AI &lt;/span&gt;应用开发服务。&lt;span&gt;Gitee AI &lt;/span&gt;汇聚了最新最热的&lt;span&gt; AI &lt;/span&gt;模型，提供模型体验、推理、微调、部署和应用的一站式服务，提供了丰富的算力选择，希望帮助企业和开发者更容易地开发&lt;span&gt; AI &lt;/span&gt;应用。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://ai.gitee.com/&quot;&gt;https://ai.gitee.com&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294721/gotc-2024-cfp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294721/gotc-2024-cfp</guid>
            <pubDate>Tue, 28 May 2024 12:16:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>大学四年级（1990 年）就会写的程序，现在的计算机系同学反而写不出</title>
            <description>同济大学的一名老师感叹称，他在大学四年级（1990 年）就会写的程序——表达式分析，现在的计算机系同学反而写不出。而且当时还没互联网，所以完全是裸写。 他还说道：「没有这个功底，我也不...</description>
            <link>http://osc.cool/9tJSU6sD</link>
            <guid isPermaLink="false">http://osc.cool/9tJSU6sD</guid>
            <pubDate>Tue, 28 May 2024 10:43:00 GMT</pubDate>
        </item>
        <item>
            <title>百度沈抖回应大模型价格战：希望大家别再天天拉表格比价格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 2024 智能经济论坛上，百度集团执行副总裁、百度智能云事业群总裁沈抖介绍了文心系列主力大模型免费背后的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「其实我们决定免费的原因特别朴素，就是希望大家别再天天拉表格比价格了，有这个时间，不如去卷场景、卷应用。现在成本更低了，大家创新的胆子可以更大一些、步子可以更快一些，把相关的场景都试一遍，快速验证。跑成功了，就快速复制。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;258&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9e74eeb2b39092d87ea08dcc53d2999cd27.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖表示，模型免费以及降价，主要是依托于技术能力，尤其是 AI 异构算力管理平台和「一云多芯」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「大家非常关注自主可控。在芯片层，我们有自研的芯片昆仑芯，正在逐步推向市场；当然，如果有其它厂商的芯片，百舸计算平台也能很好地管理起来。在框架层，我们有自研的深度学习框架飞桨，已经成为国内最受欢迎的开源框架。在模型层，我们会保障模型的内容安全可控。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖表示，目前，百度文心大模型已经拥有中国最大的产业落地规模，超过半数的央企正在使用百度智能云。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294691</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294691</guid>
            <pubDate>Tue, 28 May 2024 09:18:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>JavaScript、Python 和 Java 为何一直是开发者的首选</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Azul 公司的副首席技术官 Simon Ritter &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoworld.com%2Farticle%2F3715288%2Fwhy-enterprises-rely-on-javascript-python-and-java.html&quot; target=&quot;_blank&quot;&gt;撰文探讨了&lt;/a&gt; JavaScript、Python 和 Java 三种编程语言经久不衰的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;他在文中指出，尽管云计算、移动开发和 AI 取得了长足进步，但全球企业的日常业务仍依赖于上世纪 90 年代问世的三种编程语言。在几乎所有的排名系统中，JavaScript、Python 和 Java 都位居最流行语言的前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;譬如自 2014 年以来，三巨头在 GitHub 的年度「Octoverse 状态」报告中每年都占据了前四名中的三席。「&lt;strong&gt;为什么这些编程语言巨头在近 30 年的时间里一直是开发人员的首选，没有任何迹象表明它们会被淘汰出局？&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;281&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2282290f1d81552159a064111841b56f170.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;具体分析如下：&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;JavaScript（580 万用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;正如后端由 Java 驱动，前端则由 JavaScript 驱动。网页上的所有交互活动都是由 JavaScript 编写和控制的，十年来，JavaScript 在 GitHub 编程语言排名中一直稳居第一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;JavaScript 及其服务器端配套语言 Node.js 于 1995 年首次亮相后不久便因其简洁性和多功能性而大受欢迎。通过与用于构建网页的 HTML 语言无缝协作，JavaScript 成为了 Web 开发的标准，甚至在移动应用开发兴起之时也是如此。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;从谷歌、YouTube 到 Facebook，你都能找到 JavaScript 的身影。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Python（520 万用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Python 于 1991 年首次亮相，是三大语言中最古老的语言。作为一种脚本语言，Python 的主要优势在于进行查询、自动执行任务和分析数据。目前，该编程语言在现代大数据和分析应用程序中越来越受欢迎。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;亚马逊、Netflix、Spotify 和 Instagram 上的应用程序都是用 Python 编写的。它在 2019 年的 GitHub 报告中超越 Java，位居第二，甚至在 2022 年的受欢迎程度增长了 22.5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;尽管 Python 在 one-off、general-purpose tasks 方面表现出色，但它最大的缺点在于速度。它在支持实时任务或毫秒级金融交易方面无法与 Java 匹敌。尽管如此，它仍然是软件开发人员的首选 ，也是雇主最看重的技能之一。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Java（320 万用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Java 为大多数企业应用程序提供了底层编程架构。Azul 的 Java 现状调查和报告发现，绝大多数（98%）的企业继续在其软件应用程序或基础架构中使用 Java，其中 57% 的组织表示 Java 是其大多数（60% 或更多）应用程序的支柱。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用 Java 构建应用程序既快速又简单，同时用 Java 构建的应用程序越多，开发过程也就越简单、越快。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;应用程序很少是从零开始开发的；大多是使用各种技术组合而成的。而 Java 的真正优势在于无数的框架、库和开源材料，使得开发人员可以非常快速地创建应用程序；并且知道这种组合都已经过了实战检验，行之有效。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，Java 之所以能名列前茅，不仅仅是因为它的历史实力。Java 每六个月就会进行一次重要的功能和性能更新，每季度还会发布一些小的改进、错误修复和安全更新。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;它还具有适应新技术的灵活性。Java 22 可能将用于管理大语言模型和生成式 AI 在企业应用中的应用。&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Simon Ritter 还引用了 Gartner 副总裁兼研究总监 Linda Ivy-Rosser 的观点，即：「企业软件......历来被视为一种支持功能，缺乏创新，需要很长时间才能从精心设计的应用战略中获益。面对熟练开发人员的短缺和 IT 预算的紧缩，企业规避风险，通常不急于改变任何没有坏掉的东西，这是可以理解的。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;与此同时，还没有其他编程语言能以如此强劲的势头和实力取代 Java、Python 和 JavaScript，成为软件开发的基本组成部分。这三种语言已成为当今数字业务运行方式的基本要素，并将在多年后继续发挥重要作用。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294654/javascript-python-and-java-enterprises</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294654/javascript-python-and-java-enterprises</guid>
            <pubDate>Tue, 28 May 2024 07:15:09 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>武汉 LUG 活动回顾 | 4 大技术分享！干货满满，热闹非凡！</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;383&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-74b0116b6fb4ba3cd6e962be5942d9a776e.jpg&quot; width=&quot;900&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;内容来源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2F2024-05-whlug%2F&quot; target=&quot;_blank&quot;&gt;deepin（深度）社区&lt;/a&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span&gt;2024 年 5 月 25 日下午，由 deepin（深度）社区与&lt;/span&gt;华中科技大学开放原子开源俱乐部联合&lt;span&gt;举办的武汉 Linux 爱好者线下沙龙活动（WHLUG）在华中科技大学成功举办。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span&gt;本次活动聚集了近 40 名来自武汉地区的 Linuxer 线下参与，共同探讨技术话题，分享技术经验和见解，现场气氛热烈。让我们一起回顾本次活动的精彩瞬间吧！&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;752&quot; src=&quot;https://storage.deepin.org/thread/202405280613017359_20240527135900.jpg&quot; width=&quot;1003&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;活动伊始，来自&lt;strong&gt;华中科技大学网络空间安全学院的宋静怡&lt;/strong&gt;同学为大家带来了《自动化生成漏洞复现环境与大规模高精确度的漏洞信息获取》的主题分享。&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;753&quot; src=&quot;https://storage.deepin.org/thread/202405280620524629_20240527160622.jpg&quot; width=&quot;1005&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;华中科技大学网络空间安全学院&amp;nbsp; / 宋静怡&lt;/em&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;据宋静怡介绍，漏洞复现是缓解漏洞的关键步骤，也是确定漏洞存在的最准确方式，然而这一过程不仅要求深厚的专业知识储备，同时也需要投入大量的人力。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;考虑到 Docker 是目前最便捷的漏洞复现方式，能够很好地解决环境配置问题，Vulhub 作为一个面向大众的开源漏洞靶场，是一个基于 Docker 和 Docker-compose 的漏洞环境集合，只需进入对应目录并执行一条语句，即可启动一个全新的漏洞环境。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;所以俱乐部系统设计了 S2VulHub 工具，用于自动化生成复现漏洞所需的 Dockerfile。通过 S2VulHub，大家可以方便地复现与调试漏洞，并进一步获取精确的漏洞软件版本信息，从而进一步提升开源漏洞数据库质量。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;S2VulHub：&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhust-open-atom-club%2FS2VulnHub&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;em&gt;https://github.com/hust-open-atom-club/S2VulnHub&lt;/em&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;接下来，&lt;strong&gt;deepin（深度）社区的研发工程师 asterwyx&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;详细介绍了 dde-shell 项目，深入探讨了其基本架构、开发运行依赖关系和分进程插件机制，并与大家分享了 dde-shell 的未来规划发展。&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;752&quot; src=&quot;https://storage.deepin.org/thread/202405280620264951_20240527140429.jpg&quot; width=&quot;1003&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;deepin（深度）社区的研发工程师 / asterwyx&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;据 asterwyx 介绍，dde-shell 作为 deepin 新一代的桌面环境，会逐渐取代以往 DDE 的各个系统组件，新一代 dde-shell 基于 QML 开发，具有更灵活的开发模式。&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;目前，dde-shell 包含「Applet、Containment、Panel」三个层级、在同一个 dde-shell 进程中，组件加载呈现树形结构，dde-shell 负责加载所有的 Panel，并会递归地加载从属于对应 Panel 的 Applet。此外，Applet 与 Panel 存在父子关系，可以通过配置文件静态指定，其中同一个 Applet 可以被不同的 Panel 加载。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;dde-shell：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Fdde-shell&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/linuxdeepin/dde-shell&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  紧着着，
  &lt;strong&gt;deepin（深度）社区的研发工程师 rewine&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;为大家带来了《为 Treeland 实现平铺式布局逻辑》主题分享。
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;749&quot; src=&quot;https://storage.deepin.org/thread/202405280622512710_20240527140120.jpg&quot; width=&quot;999&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;deepin（深度）社区的研发工程师 / rewine&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;rewine 提到，平铺式窗管是以不重叠画面的方式组织屏幕画面，相比堆叠布局，平铺式布局在纯键盘情景下操作更为高效。而 Treeland 作为 deepin 的下一代 Wayland 窗口管理器，基于 wlroots 开发，目前已实现了 layer-shell 等常用的 Wayland 协议，在设计上可以同时支持堆叠式和平铺式两种布局。&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;Qt 作为跨平台的 C++应用程序开发框架，目前被广泛用于 GUI 程序开发。QtQuick 的声明式方法使得用户界面的定义和实现更加简单直观，与传统的命令式 GUI 编程相比更具优势。于是我们通过 waylib 项目，将 wlroots 和 QtQuick 深度结合，极大简化了窗管的开发难度，仅需掌握 QML 即可参与其中。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;Treeland：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Ftreeland&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/linuxdeepin/treeland&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;waylib：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvioken%2Fwaylib&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/vioken/waylib&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  最后，来自
  &lt;strong&gt;华中科技大学网络空间安全学院的丁鹏宇&lt;/strong&gt;同学为大家介绍了 pwn.hust.college 平台。据介绍，pwn.hust.college 是由华中科技大学网络空间安全学院白帽黑客团队所创建的基于神奇宝贝动画设计的趣味教育学习平台，坚持「未知攻，焉知防」与「实践出真知」的设计理念，致力于让学生或其他感兴趣的团体学习和动手实践核心网络空间安全的概念。
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;749&quot; src=&quot;https://storage.deepin.org/thread/20240528062415174_20240527140038.jpg&quot; width=&quot;999&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;华中科技大学网络空间安全学院&amp;nbsp; &amp;nbsp;/ 丁鹏宇&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;进入首页后，同学们即可化身成为神奇宝贝训练家，在神奇宝贝道馆时间理论课堂中探索软件安全的核心攻防技术。从入门篇、初级篇、中级篇，一直到高级篇的多个关卡，涵盖了平台食用指南、Pwntools 使用、缓冲区溢出、Shellcode 注入等内容。通过完成这些挑战，便可以获得相应的道馆徽章，并最终成为技娴熟的白帽黑客。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;Dojo：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhust-open-atom-club%2Fdojo&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/hust-open-atom-club/dojo&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;h1&gt;&lt;span&gt;&lt;strong&gt;关于 WHLUG&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;WHLUG （武汉 Linux 用户组）由 deepin（深度）社区于 1997 年发起创立，创建的初衷是为武汉地区的 Linux 爱好者们提供一个不受外界干扰的技术讨论氛围，让每一个技术爱好者回归技术本质，构建武汉最纯粹的 Linux 技术讨论圈子，持续推动武汉本地开源社区文化的发展。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;217&quot; src=&quot;https://storage.deepin.org/thread/202401220823526444_%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17059114451088.png&quot; width=&quot;807&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;WHLUG 聚会基本形式&lt;/em&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;我们诚挚地欢迎武汉地区的&lt;strong&gt;学生/开源爱好者&lt;/strong&gt;加入，共同参与到 WHLUG 活动的策划和组织中，同时，热忱欢迎&lt;strong&gt;各高校社团&lt;/strong&gt;与我们携手，为构建武汉最纯粹的 Linux 技术圈和推动本地开源发展贡献力量。&lt;/p&gt; 
   &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;若您对参与活动共建感兴趣，请&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwj.qq.com%2Fs2%2F13816139%2F8b53%2F&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;点击「此处」&lt;/strong&gt;&lt;/a&gt;或&lt;strong&gt;扫码&lt;/strong&gt;填写报名表，我们的工作人员将会与您取得联系，期待与您一同开启这段激动人心的开源之旅！&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;235&quot; src=&quot;https://storage.deepin.org/thread/202403250931175203_WHLUG%E5%85%B1%E5%BB%BA%E6%8A%A5%E5%90%8D.png&quot; width=&quot;235&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span&gt;&lt;strong&gt;deepin 镜像下载地址：&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fdownload%2F&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;www.deepin.org/download/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;strong&gt;deepin 历史版本镜像获取（V20 前）：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Findex.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;https://distrowatch.com/index.php?distribution=deepin&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294652</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294652</guid>
            <pubDate>Tue, 28 May 2024 06:50:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Istio 七周岁</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2Fblog%2F2024%2F05%2F24%2Fhappy-7th-birthday-istio%2F&quot; target=&quot;_blank&quot;&gt;发文&lt;/a&gt;庆祝七岁生日，并总结了自项目诞生以来所取得的一些成果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-aa0939d5f63acbd3a6b331f3a3a2c4e81a5.jpg&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 是一个由谷歌、IBM 和 Lyft 的团队于 2016 年开始合作开发的开源项目，在 2017 年正式推出；它是一个大型微服务系统管理工具，旨在提供一种统一化的微服务连接、安全保障、管理与监控方式；基于 Lyft 的 Envoy 项目构建。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2022 年 4 月，谷歌和 Istio 指导委员会宣布将 Istio 项目捐赠给 CNCF；同年 9 月，CNCF 技术监督委员会 (TOC) 投票决定接受 Istio 作为 CNCF 孵化项目。2023 年 7 月，Istio 正式从 CNCF 毕业；同时，微软 Open Service Mesh 团队成为 Istio 项目维护者。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，Istio 的控制面板和边车代理分别是 Docker Hub 上下载量排名第三和第四的镜像，各自超过 100 亿次下载。过去一年里，社区的贡献公司数量和贡献者人数均实现了巨大增长，超过了 1700 名。其中，&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2FSolo.io&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;Solo.io&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;、Google 和 DaoCloud 是贡献度最高的三家公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;205&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-1303068e017b0358fca5ac12f74dfac9189.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「我们坚信多样性驱动创新。最令我们惊叹的是 Istio 社区持续不断的创新，从简化升级过程，到采用 Kubernetes Gateway API，再到新增无需边车的环境数据平面模式，以及努力使 Istio 易于使用并尽可能透明。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 的环境模式于 2022 年 9 月推出，旨在简化操作、增强应用程序兼容性，并降低基础设施成本。随着 Istio 1.22 版本的发布，环境模式已进入测试阶段，用户可以在采取一定预防措施的情况下，在生产环境中无边车运行 Istio。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/193192/google-istio-cncf&quot; target=&quot;_blank&quot;&gt;谷歌向 CNCF 捐赠 Istio&lt;/a&gt;&lt;/li&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/212312/istio-sails-into-cncf&quot; target=&quot;_blank&quot;&gt;Istio 成为 CNCF 孵化项目&lt;/a&gt;&lt;/li&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/249167/istio-graduates-cncf&quot; target=&quot;_blank&quot;&gt;Istio 从 CNCF 毕业，微软加入项目社区&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294636/happy-7th-birthday-istio</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294636/happy-7th-birthday-istio</guid>
            <pubDate>Tue, 28 May 2024 06:00:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>马斯克和「AI 教父」激情对线</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;起因是马斯克转发了一条为自己 xAI 公司招人的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;推文&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1646&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-acedb0fcdff381e79f9fbda1bf622a701af.png&quot; width=&quot;1284&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;没成想被有「AI 教父」之称的杨立昆当场拆台，言语间尽是嘲讽。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;杨立昆（法语：Yann Le Cun）是一名法国计算机科学家。他在机器学习、计算机视觉、移动机器人和计算神经科学等领域都有很多贡献。他最著名的工作是在光学字符识别和计算机视觉上使用卷积神经网络，他也被称为卷积网络之父。他共同创建了 DjVu 图像压缩技术，以及联合开发 Lush 语言。2019 年，他同约书亚·本希奥、杰弗里·辛顿共同获得计算机学界最高奖项——图灵奖。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;杨立昆解释了他评论这些内容的原因——「&lt;strong&gt;不喜欢马斯克的报复性政治手段、阴谋论和炒作&lt;/strong&gt;」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;880&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-42deaf887656eb50e3b3a7d15076d52d3b4.png&quot; width=&quot;1286&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;下面是大佬的互喷现场：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;2337&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b27ea3061e6803707fc5bce1d91b0e8a472.jpg&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;机翻效果&lt;/p&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-47f8e8355e7ca675222a031eef7eed7aff8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;来源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;https://x.com/elonmusk/status/1794981927125987683&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294625</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294625</guid>
            <pubDate>Tue, 28 May 2024 04:33:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>龙芯自主龙架构 2024 年已适配 318 款产品、有望推出「龙芯+鸿蒙」桌面 PC</title>
            <description>龙芯中科每个月都会公布 LoongArch 龙架构的生态适配进展，2024 年 4 月又新增了 110 款，加上此前 3 月的 101 款、1-2 月的 107 款，今年以来已达 318 款。这些适配产品面向网络安全、数据安全、日常办公、智...</description>
            <link>http://osc.cool/99Ar188B</link>
            <guid isPermaLink="false">http://osc.cool/99Ar188B</guid>
            <pubDate>Tue, 28 May 2024 03:34:48 GMT</pubDate>
        </item>
        <item>
            <title>Bookie 存储架构源码剖析｜得物技术</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                            
                                                                                            &lt;p style=&quot;color:#222222; margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;一、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Pulsar 存储架构简析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 作为新一代 MQ 中间件，在底层架构设计上充分贯彻了存算分离的思想，broker 与 Bookeeper 两个组件独立部署，前者负责流量的调度、聚合、计算，后者负责数据的存储，这也契合了云原生下 k8s 大行其道的时代背景。Bookeeper 又名 Bookie ，是一个单独的存储引擎。在组件关系上，broker 深度依赖 Bookie，内部集成了 Bookie 的 client 端，broker 和 Bookie 之间基于 TCP 通信，使用 protobuf。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7ae3724a6738446d9eaa24a3989b2304~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=KN6gea6ImIlHS7pxV%2BTu63QB%2B%2Bs%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 整体架构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;消息流从 client 端发送到 broker，经过 broker 的计算、转化、路由后再次被分发到具体的 Bookie 节点，一条消息被存储几份是可配置的。数据的高可用由 broker 来保障而非 Bookie，Bookie 只是一个简单的单机存储引擎。一般而言数据多副本有两种主要的分发方式：一种是基于主从模式，主节点在收到数据写入后，将数据二次分发到从节点，从节点的数据流源头只有主节点，可以存在多个从节点，这种架构典型实现有 rocketMQ ，MySQL 等；另一种方式是并行多份写入多份相同的数据，在接收到 SDK 侧数据后进行多路分发。两种方式各有优劣，前者实现简单，但是延迟较高，在开启同步复制（异步复制可能丢数据）的情况下延迟为：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;master 写入延迟+slave 写入延迟&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;；后者实现复杂，需要处理单节点分发失败补偿的问题，但是延迟较低，实际的写入延迟为&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Max(shard1 写入延迟，shard2 写入延迟，.....)&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。Pulsar 的数据分发模式为后者。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ac570f7e482d475ba47d23ab53de14ce~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Y3CoV7%2Bloep6waHMMRk36Ritb4M%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 数据流架构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;一个 topic 在时间序列上被分为多个 Ledger，使用 LedgerId 标识，在一个物理集群中，LedgerId 不会重复，采用全局分配模式，对於单个 topic（分区 topic）而言同一时刻只会有一个 Ledger 在写入，关闭的 Ledger 不可以写入，以 topicA-partition1 的 Ledgers[ledger1, ledger3, ledger7, ...., ledgerN]为例，可写入的 Ledger 只有 N，小于 N 的 Ledger 均不可写入，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;单个 Ledger 默认可以存储 5W 条消息&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，当 broker 以 （3,2,2）模式写入数据时，具体架构如下图所示。3,2,2 可以解释为当前 topic 可以写入的节点有 3 个，每次数据写入 2 份，并且收到 2 个数据写入成功的 ACK 后才会返回响应 client 端。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/74f43b7ff2f141a7aa0c23cc869cde2c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=a5pq528voyeoqg9fUPKGI5M9cVc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 分段机制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;二、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的架构设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;对 Pulsar 的架构有了大致的了解后，我们重点剖析下 Bookie 这个核心的存储引擎。消息系统为了追求最大写入吞吐，一般都采用顺序写的方式来压榨磁盘的 IO 性能。Bookie 也是一样，默认情况下 Bookie 的数据会写入 journal 日志文件，这个日志类似于 MySQL 中的 binlog 文件或者 rocketMQ 中的 commitlog 文件，采用乱序追加写的方式，存在多个 topic 的数据写入同一个文件的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;为了更好的 IO 隔离，官方建议 journal 单独挂一块盘。为了充分发挥磁盘 IO 性能，journal 目录可以有多个，即同时存在多个并行写入的 journal 日志，每个 journal 日志会绑定一个写入线程，写入请求提交后会被归一化到某个具体线程，实现无锁化，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;单个消息写入是按照 LedgerId 对目录数量取模，决定当前数据落到哪个 journal 目录&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。journal 日志落盘策略是可配置的，当配置同步落盘时，数据实时落盘后才会返回写入成功。journal 日志数据写入后会确认返回写入成功，而 entrylog 的数据是否落盘并不影响请求的立即返回。journal 和 entrylog 均可以配置为异步刷盘，这种情况下落盘的时序上并没有先后之分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/21791c6012b74868a0d27ae2d86cf5be~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=M4HQB%2Ffr0RPxXWKRr7kOf9sHhA0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 数据存储架构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal 日志的主要作用是保证数据不丢失，同时提供足够快的性能，因此采用了混合落盘的模式。实际业务消费时，针对单个 topic 的数据在时间序列上是顺序消费，如果实际的数据从 journal 文件中读取则会出现大量的随机 IO，性能较差。Bookie 通过将数据进行二次转写的方式实现数据的局部有序从而提升读取性能，默认情况下一份数据在磁盘上会存两份：一份在 journal 日志中，一份在 entry 日志中。entry 日志中的数据具备局部有序的特性，在一批数据刷盘时，会针对这批数据按照 LedgerId，entryId 进行排序后落盘。这样消费侧在消费数据时能够实现一定程度上的顺序 IO，以提升性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryIndex 的作用是保存（LedgerId+entryId）到 offset 的映射关系，这里的 offset 是指 entry data 文件中的 offset。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;这样的一组映射关系很容易想到其在内存中的组织形式，一个 map。实际的存储&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 选择 rocksDB 来存储这样的 KV 关系&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，但 Bookie 本身也有自己的 KV 存储实现；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;通过对 Bookie 架构的上分析，我们发现针对读写场景 Bookie 做了两件事来支撑：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;混合 Ledger 顺序写的 journal 日志支撑高吞吐低延迟的写入场景；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;局部有序的 entry data 支撑消费场景下的 Ledger 级别的顺序读。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;三、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的数据写入流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;对于 Bookie 的写入流程大致如下图所示。Bookie 收到数据后会同时写入 journal 日志和 memtable，memtable 是一个内存 buffer。memtable 再次分发到 entry logger 以及 entry index，数据在 journal 中 append 完后会立即返回写入成功。entry data 和 entry index 的构建可以理解都是异步操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c79f614980394a84a49a384d5f951992~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=JstCsfZnMznBP%2BppNtSBd%2B4oRCI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 数据写入流程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;client 端源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 中 broker 组件，使用 low level API 与 Bookie 进行通信。下文结合具体代码进行分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ClientConfiguration conf = &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; ClientConfiguration();
conf.setThrottleValue(bkthrottle);
conf.setMetadataServiceUri(&lt;span style=&quot;color:#00753b&quot;&gt;&quot;zk://&quot;&lt;/span&gt; + zkservers + &lt;span style=&quot;color:#00753b&quot;&gt;&quot;/ledgers&quot;&lt;/span&gt;);
BookKeeper bkc = &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; BookKeeper(conf);


&lt;span style=&quot;color:#114ba6&quot;&gt;final&lt;/span&gt; LedgerHandle ledger = bkc.createLedger(&lt;span style=&quot;color:#a82e2e&quot;&gt;3&lt;/span&gt;, &lt;span style=&quot;color:#a82e2e&quot;&gt;2&lt;/span&gt;, &lt;span style=&quot;color:#a82e2e&quot;&gt;2&lt;/span&gt;, DigestType.CRC32, &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;byte&lt;/span&gt;[]{&lt;span style=&quot;color:#00753b&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span style=&quot;color:#00753b&quot;&gt;&#39;b&#39;&lt;/span&gt;});
&lt;span style=&quot;color:#114ba6&quot;&gt;final&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;long&lt;/span&gt; entryId = ledger.addEntry(&lt;span style=&quot;color:#00753b&quot;&gt;&quot;ABC&quot;&lt;/span&gt;.getBytes(UTF_8));&lt;/code&gt;&lt;/pre&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;使用 low level api 时，借助于 LedgerHandle 添加 entry 对象。在 Pulsar 中 entryId 为一个递增的序列，在 broker 中 Bookie 的源码调用顺序如下所示，其中 LedgerHandle，OpAddEntry，LedgerHandle class 对象为 Bookeeper 模块提供。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ManagedLedgerImpl#asyncAddEntry() 方法（参数省略，下同）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ManagedLedgerImpl#internalAsyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#asyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpAddEntry#initiate() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#doAsyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieClient#addEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/88388e7af5994decbf99cfd54e384999~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=bu4o%2BHDLkFQZHX2OnvvyuVwPQ4Q%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#doAsyncAddEntry 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 doAsyncAddEntry 中的 729 行，发现 entryId 其实是由 lastAddPushed 递增得到，并且这段代码也被加上了重量级锁。PendingAddOp 对象构建完成后会进入一个 pendingAddOps 队列，该队列与当前 Ledger 绑定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b9a99e6e9a594516b6392abb8b7a969c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=dTaLtkmTrxg3ICa5uVm19p2V0cc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;PendingAddOp#initiate 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;这里的 PendingAddOp 对象代表着一个写数据的请求，在 initiate 进一步加锁，结合写入节点的数量分别向不同的 Bookie 存储节点发送写请求，sendWriteRequest 方法内容比较简单，直接调用 addEntry 方法即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b475269c59d84386b1f629498bd7a0fd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=orN95MLTacsV4IqPggMkHouN%2FZE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;PendingAddOp#sendWriteRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/932135a1d2484b0995347a57afabaf45~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=UPNm6lwbiAgaH%2BMcgKhxdWCrM4U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieClient#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 方法的实现依然有很多方法包装的细节，但最终通过网络调用 server 端的相关接口，这里篇幅有限，不过度展开。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;请求路由组件：BookieRequestProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;直接跳转 bookeeper 的 server 端的核心处理方法上，BookieRequestHandler 为 server 端的处理类，其继承了 Netty 的&lt;br&gt; ChannelInboundHandlerAdapter，是最外层与 netty 组合工作的 handler。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/97e4e19a3fc743f3961e48a80c467cdd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=jukxvEBhULNwRoLB%2BNt1%2Ba9z9L8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestHandler&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 channelRead 方法中触发了 requestProcessor 的处理逻辑，这里的 processor 实际为 BookieRequestProcessor，具体的相关代码在 BookieServer 类的构造函数中，BookieServer 是整个 bookeeper server 端的启动类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest 方法为数据流的核心指令分发器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8203741ab2834eb8a9cc60dc6b5dc7c7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=mcTGqjmTIhX5wJdK%2FB3nkF5t%2B8U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;这里围绕&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;processAddRequestV3&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;方法展开分析；Bookie 中有个很有意思的设定，将请求处理线程池分为普通线程池和高优线程池；两者执行逻辑相同。在下图的 452 行将写操作请求放入了线程池，需要说明的是这个线程池是经过改良的，多了一个 orderingKey 参数，在内部会将根据该参数进行 hash 运算，映射具体的线程上，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;其内部由多个单线程的线程池组成。这样做的好处是可以大幅度减少投递任务时的队列头部竞争&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，相比传统线程池有一定的性能优势。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d180b1e466854521828ddf3da3adcf03~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=kEtNUv1uTetdiM7WVW981I9wdAk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;processAddRequestV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;核心线程池任务：WriteEntryProcessorV3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;显然，核心的处理逻辑在 write.run 方法内，继续开扒。run 方法中核心逻辑封装在 getAddResponse()。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a76943db2d4e424587ab0bfa9882d989~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=G6pIG01xu52Svzq9wZdgvyNk7XI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;getAddResponse 方法内会对当前请求的标记，判断后分别调用 recoveryAddEntry 和 addEntry 这两个方法。前者的使用场景顾名思义是在异常恢复流程中被触发，一般是节点启动，宕机后重启等过程中恢复数据。addEntry 方法位于 Bookie 内，Bookie 是个接口，只有一个实现类 BookieImpl。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c685d087a3064314bac57469a2bfcb61~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=sJh8FeBd9svGGiaQyEiOhCNHZoA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3#getAddResponse&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;存储引擎接口抽象：Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;继续来看 BookieImpl#addEntry 方法，在 1067 这一行加上了 synchronized 锁，锁的对象为 handle，具体为 LedgerDescriptor 类型，这表示在单个 Ledger 内部的数据在写入时通过加锁的方式实现串行化写入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;1073 行的 addEntryInternal 方法内部是核心的写入逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3371b182268d43878ee60f58fc34fea0~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=T7OTWrcllN%2B7PPEne1yYhMHd4TI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 的管理者：LedgerDescriptor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;getLedgerForEntry 方法基于传入的参数 LedgerId 查找到对应的 LedgerDescriptor，该类是一个抽象类，有两个实现类，分别是 LedgerDescriptorImpl 和&lt;br&gt; LedgerDescriptorReadOnlyImpl，顾名思义，二者分别提供读写功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7912608a28174239a11c372652a4e2de~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Zhw0S0JiGqdHMFlR2HquYMtw0d8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#getLedgerForEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/06009ac4c70c490b89f80908bf9ecd38~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=W4xjO7zokrOJUvOk0bKiEMv1F9U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptor 的两个实现类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;handles 是 HandleFactory 类型接口，从其定义的接口来看主要作用就是实现 LedgerDescriptor 的读写分离，且只有一个实现 HandleFactoryImpl，在 HandleFactoryImpl 中保存了 2 个 Map 类型的 MAP。分别服务于两个接口的调用，getHandle 方法就是从 map 中获取可以写入的 LedgerDescriptor。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a3cdaca4e7a346eda7ac8f816cc23a20~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=oYEQ%2BrrDqV8kLizqGmoiYVepisM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;HandleFactory&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;事实上&lt;br&gt; LedgerDescriptorReadOnlyImpl 的实现很简单，继承了 LedgerDescriptorImpl 后将该类涉及到写入的方法全部重写为抛出异常！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6e5fd10fcf564dd8a8de0f66eb5e9ee7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=z%2F1VahLYeW1DKkF6ei3hQmbU70w%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptorReadOnlyImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;获取到对应的 LedgerDescriptor 后，就需要进行写入操作，下面分析 BookieImpl#addEntryInternal 方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;从逻辑上来讲，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 先是被写入 Ledger storage（930 行），其次才被写入 journal 日志，同时 journal 日志的写入是可选的，默认情况下开启&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;；journal 关闭后将不存在数据落盘的逻辑，这意味着将无法依靠 journal 日志进行数据恢复。但考虑到消息写入时一般是多份，不考虑写入的多个节点同时宕机的情况，数据某种程度上依然是可靠的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dbd30b41001f4df183460f355bb7a1b7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Ei9JpTtfTltmKU24FEEbe9HUrjg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#addEntryInternal&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 级的接口抽象：LedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;LedgerDescriptorImpl 中持有一个 ledgerStorage 类型，该组件负责最终的 entry 对象写入，存在多个实现类，分别是：DbLedgerStorage,&lt;br&gt; SingleDirectoryDbLedgerStorage,InterleavedLedgerStorage,SortedLedgerStorage。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5bae520c5df94113b3099dda57b0a902~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=pClQIg4ztO2TkJtXqpVQE1zCGVE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptorImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a29b426a93cd4fcf90c46843f1074054~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=4lRhalqMykCHg2Qumz0gmTydT4g%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerStorage 实现类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 默认使用 SortedLedgerStorage，但 Pulsar 中使用 DbLedgerStorage 进行管理。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;实际可配置的实现只有三个选项，下面依次对每个实现类进行分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d00d1ebd4b034ea0bbf67f3d1ba45254~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=3NScdxoCgX46ar07w4oHs6xOePg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage-&amp;gt;SingleDirectoryDbLedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 写入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage 主要特点是使用了 rocksDB 保存[ledgerId+entryId --&amp;gt; location]的映射关系；内部又存在了一层套娃。addEntry 方法中先获取到 LedgerId， 再根据 LedgerId 获取 ledgerStorage，也就是说 LedgerId 和实际的 LedgerStorage 存在映射关系；&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;DbLedgerStorage 内部又继续封装了&lt;br&gt; SingleDirectoryDbLedgerStorage 类来支撑数据写入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;，具体是一个 ListledgerStrageList；字段。经过 hash 后获得真实的&lt;br&gt; SingleDirectoryDbLedgerStorage 对象进行实际的 addEntry 操作；下文首先对该实现进行分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ec2d1e4c52734a918e9a0f8be39484c6~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=iXY5xBOhQGqk2xDUe9hUNmqI3gk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d468e2b3d69442289f4d3d5ac6b16745~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=a4QY3kYbtpu6zytJv8It0s5HYwc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#getLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a762f3034dd740c888bbd427c0a2ba16~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=MdJkJqkDCUjY6QZceVgQfjMx6cE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage 的成员变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;在&lt;br&gt; SingleDirectoryDbLedgerStorage 的源码中，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;待写入的 entry 仅仅是被放入 writeCache 中，put 成功后更新 LAC 并通知相关监听者，同时触发写入成功事件，貌似没有任何写盘的操作出现！！！&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;进一步分析 497 行，如果 put 失败会触发 flush 操作并尝试再次 addEntry，这里的 flush 有点眼熟，有必要展开分析一波。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;不难发现这里的写入操作和刷盘操作其实是线程隔离的，默认情况下，类比于 RMQ，大部分存储组件的刷盘操作和实际写入动作切分为两个线程在执行，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;刷盘线程会不断地巡检是否需要刷盘，主要基于当前未刷盘的数据量以及距离上次刷盘的时间间隔&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，如果开启同步刷盘，一般写入线程会被挂起在 req 请求上，当刷盘进度已经 cover 写入请求的 offset 时，被挂起的请求上的线程会被唤醒继续执行，这是一种非常典型的存储引擎设计模式。这里 writeCache 就是个 buffer，既可以充当写入缓冲也可以充当读取缓冲，在 tail read 场景下会有非常好的性能收益。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3587e1b0b3a54909b1d5c47d2fd1a8ff~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=d42iQEouPgouNbzRQZNOo8Ft3y8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 背后的 flush&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;triggerFlushAndAddEntry 的逻辑并不复杂，在超时时间到来之前会不断的检查当前的刷盘标记位，如果没有正在刷盘以及刷盘逻辑没有被触发，会尝试刷盘，同时尝试继续向 writeCache 中 put 数据，因为刷盘成功后会在 cache 中清理出一部分空间，用于 put 新的的数据，一旦 put 成功立即返回，跟外层的 addEntry 方法类似，只是多了个刷盘逻辑的处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d2c1c8b218db40c28954b9fceb401c7e~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QlfSvym40gR%2B%2Fb3s%2BrMxS8kZXZQ%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#triggerFlushAndAddEntry 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 方法其实是个空壳，核心逻辑在 checkpoint() 方法内，该方法的主要逻辑为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;交换 writeCache，避免刷盘过程中数据无法写入，导致写入抖动；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;对 writeCache 内的数据进行排序，实现局部有序；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;分别调用 entryLog 的 add 方法和 entryIndex 的 add 方法；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;调用 entrylog 的 flush 和 entryIndex 的 flush 进行刷盘。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8ab1e6f90d694c6596135dd70dc62a9a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=8wlbtIHF0H3Yepkkz5pIclmzL5w%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/36a2951089214868800e9fcc0574b55b~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=zlk0OAltR4DP6u5POMPZMkzEy1Y%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#checkpoint&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;源码中的 writeCacheBeingFlushed 实际上和 writeCache 一体两面，上一次刷盘结束后 writeCacheBeingFlushed 会被 clear，再次刷盘时会交换两者；保证写入的稳定性；如果实际查询数据时要利用这部分 cache，需要查询两次，先查 writeCache 如果不存在 ，再查 writeCacheBeingFlushed。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/e8d83bc5e6d943fa9c0db5316aa16dc9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=EDFEak82%2BOJcH%2BPy91usveH88J4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCacheBeingFlushed 的注释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5941113e1baf446e95b1d9e6aac710d9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=inUzrEgEyf8goulcaU9kCC71ntg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;br&gt; &lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;entryLocationIndex.addLocation(batch, ledgerId, entryId, location);方法底层依赖 rocksDB 建立了[ledgerId, entryId]--&amp;gt;location 的映射关系，Batch 在这里代表着，一个 RocksDBBatch，location 可以理解为实际磁盘文件上的 offset。rocksDB 引擎超出本文范畴，这里不做分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryLogger 代表着存储实际数据的组件抽象，调用 addEntry(ledgerId, entry) 方法完成数据写入。进一步对 addEntry 方法展开分析，发现 EntryLogger 是一个接口，有 2 个直接实现类，分别是 DefaultEntryLogger 和 DirectEntryLogger，默认使用 DefaultEntryLogger 参见源码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/216dfb199cfc4ad69e8ba3182c08e41c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=MCldx0IppN8uCtqLaHrPtu08mW4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#initialize -part1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5fd3a3d565344ba2aa56f188131ab79a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=V%2F8hYUsNK78oboTOxDnQNv3T3Mk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#initialize -part2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;最终的调用来到了 EntryLogManagerBase#addEntry 方法，首先获取到待写入的数据，然后调用 BufferedLogChannel#write 将其写入，可以看到实际的数据长度为：entry.readableBytes() + 4，4 个字节用于记录长度，先写入长度值，再写入 entry 的二进制数据；addEntry 方法返回值为 location，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;方法的最后一行表明 location 由 2 部分组成，分别是 logId 和 pos，各暂用高位和低位的 4 个字节&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。很容易想到随着时间的推移 EntryLogger 中的文件不止一个，因此需要一个 logId 来标识不同文件，具体到文件上又需要一个偏移量来定位具体的一条数据，4 个字节的 pos 也表明了单个 entryLog 文件理论大小值不能超过 4 个 G，实际默认值为 1G。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9b5507e160064b8f8f0f4103b24df52a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=iwh5fXHc%2BARHsJ0N5WYOmdEydNg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogManagerBase#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;进一步分析 BufferedLogChannel#write 方法，发现 BufferedLogChannel 继承置之 BufferedChannel ，在 BufferedChannel 中有一个 writeBuffer ，write 方法只是将数据写入到这个 writeBuffer 中，至于是否刷盘则不一定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;只在满足下列两种情况时数据才会刷盘：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当前 writeBuffer 已经写满，writeBuffer 默认值 64KB；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration 中配置了 FLUSH_ENTRYLOG_INTERVAL_BYTES 参数，且值大于 0，默认值为 0。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/02ad5b5bfdbe41ee9c9805681513b3fa~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=wSW%2FumdRKHAxLmh0QabQOBZrdRI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedLogChannel#write&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 方法内容很简单，调用底层的 fileChannel 将 writeBuffer 中的数据写入底层的文件系统，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;但是 flush 并不保证一定落盘&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，而是最后一行代码 forceWrite 方法保证。forceWrite 会调用 fileChannel.force(forceMetadata) 将数据同步到磁盘上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/bab28e93323f43a69119a417a3534b10~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=uHaBzjMDBKkVe%2Fr6tfMisW1SXvo%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;为了保证数据的务必落盘，在&lt;br&gt; SingleDirectoryDbLedgerStorage#checkpoint 方法中，addEntry 方法之后，又单独调用了 entryLogger.flush();和 ledgerIndex.flush();对 entryLogger.flush() 进一步拆分，发现底层调用了 EntryLogManagerBase#flush 方法，二者两个方法在 base 类中是 abstract 类型，具体实现又落到了&lt;span&gt;&amp;nbsp;&lt;/span&gt;EntryLogManagerForSingleEntryLog 中，最终任务还是落在了 BufferedChannel#flushAndForceWrite 上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6cea0ca2ad7047a282eb4fa9613f2085~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=rTylKLwhNZgJz4%2B9F4SNFIvzXu8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel#flushAndForceWrite&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage-&amp;gt;InterleavedLedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 SortedLedgerStorage 类中，持有了 InterleavedLedgerStorage 类型，大部分的接口实现都委托给了 InterleavedLedgerStorage 的相关方法调用，SortedLedgerStorage 的最大特点是，每次数据写入时都会进行排序，其内部使用了跳表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/834f9975acfa4c4c82ee2aa64827e7ec~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=6tf7mSryYkTcjsm5O32kYhTRVw0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable 写入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 方法的逻辑非常简单，将数据 add 到 memtTable 后，更新下 LAC 即结束；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/fc4c7efc1902441e957d7e27f368b855~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QvBttu0pq1qzzehR%2BStyJjgRT3k%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;继续研究 EntryMemTable 的 addEntry 方法之前先了解下 EntryMemTable 的结构，这个组件是一个纯内存的数据保存结构，kvmap 和 snapshot 负责实际数据保存，二者类型皆是 EntrySkipList ，这个类简单封装了 ConcurrentSkipListMap，实际使用时 KV 值相同，因为需要保证有序，所以重写了排序规则，主要比较 LedgerId 和 entryId。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;kvmap 和 snapshot 工作机制是，当写满 kvmap 时，会将数据交换给 snapshot，kvmap 重新构建一个新的指定大小的结构，后台线程负责将 snpshot 中的数据刷盘保存，因此只要后台刷盘的速度不是特别垮，可以提供持续不间断的写入。单个 kvmap 有大小限制，默认 64M 大小，结合前面的 swap 机制，最多可以兜住 128M 的写入缓存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/edc551f2d71f40bc81912e0851e69358~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=NserGlryB9Y7eCWS3mxiJs2UGe4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 写入之前先获取读锁，（没错，写入用的是读锁！！！）然后将数据 put 进入 kvmap 结构中，internalAdd 方法内容很简单，就是一个对 kvmap 的 putIfAbsent 调用，看到这里可以理解为什么用的是读锁了。因为这里 kvmap 的并发安全控制根本不依赖这个读写锁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/66a2f015f9374d449f9867fa0152ace1~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=j%2FZDwDsPx%2FwuLjG%2FthrPEnWmHe0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable 刷盘&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;读写锁的主要作用是，在 swap kvmap 和 snapshot 瞬间加上写锁控制以及读取数据时加上读锁控制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5d5a1e67ca7d4c64bcdadc4a97337f3f~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=yeCcxPi4xYP5u8ILgPyHsgMh%2FP4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReentrantReadWriteLock 使用场景&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;每次刷盘之前会先创建个一个 snapshot 快照，用以保证此快照之前的数据在此次的刷盘范围内；创建 snapshot 时，会交换 kvmap 与 snapshot 两个字段，因为快照的创建是刷盘行为触发的，而刷盘动作一般都是有个单独的线程在执行，所以这里需要控制并发逻辑，保证在 swap 的瞬间，不能有 addEntry 操作，同样的在刷盘结束后需要清理 snapshot 的数据，也加上了写锁来控制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f61bf224fdd341eab87c4c6ae22f7c0c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Y%2F5YBXMfO5oKRWz%2F9K1tdhmk5oc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#snapshot&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;会有一个后台的刷盘线程执行 flush 操作，首先会先将 snapshot 数据 flush，然后尝试创建新的 snapshot，如果创建成功说明，仍然有可刷数据，再次执行 flushSnapshot 的动作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f0abb2747eb749d09a134f94ee984430~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=CjBVLq3JVqinJCl2vXiUT%2Fu1y%2Bg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 flushSnapshot 方法中，会调用 flusher 的 process 方法，这里的 flusher 其实就是 SortedLedgerStorage，在 process 方法内的实际调用了 InterleavedLedgerStorage 的 processEntry 方法，这个方法并不能保证数据一定会落到磁盘文件上，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;因此 EntryMemTable 所谓的 flush 操作只是将其内存数据刷新到 InterleavedLedgerStorage 组件中。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4ab10f21ee634d1bb258701a81a50e88~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=OJBC7IxMh96rV5F4jTzhyQkq6k4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#flushSnapshot&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1eae5ca472ea49b1b7c8a77851ba8015~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=TtYa60tW0AhPsOMp8Ye9HVDyqNQ%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage#process&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;继续来看 InterleavedLedgerStorage 的处理逻辑，添加 Entry 后将对应的 KV 索引写入 LedgerCache 缓存后返回。查看 InterleavedLedgerStorage 的 entryLogger 字段发现，与上文的&lt;br&gt; SingleDirectoryDbLedgerStorage 相同，写入 entry 依然用的是 DefaultEntryLogger。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/44cf91ffafd74f32a2651ead373a797c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=aE%2Ft51FwvU2yePle928gF3%2F32yM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#processEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dc96f3eed91542e78eebfcf38ecf3c18~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=LgYrRg0qXW3sQC%2Fnax34QU2TC8Y%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#entryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryIndex&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上文提到默认情况下 Pulsar 使用 DbLedgerStorage 来存储数据和索引信息，而索引信息默认情况下使用 rocksDB 来存储，rocksDB 作为顶级 KV 引擎其性能和稳定性毋庸置疑。但是在实际的使用过程中，某些时候会选择 LedgerStorage 的另一个实现类：SortedLedgerStorage。SortedLedgerStorage 的主要特点是是在每次写入数据的时候都会进行内部排序，内部维护一个跳表，同时其存储 leggerId+entryId 到 location 的映射关系是使用 Java 的引擎实现。下面对这个 Java 实现的 KV 引擎做详细分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ad73e6db79e24496b43d7c54c42241d7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=7q%2FLLBe8Xq8vwsKvhiZgRSeGH5A%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration 关于 ledgerStorageClass 的配置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;仍然是先从 entryLog 的写入作为突破口，SortedLedgerStorage 内部套了一个 InterleavedLedgerStorage 对象，前者复用了后者的 addEntry 方法，核心方法在 InterleavedLedgerStorage#processEntry 中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;long pos = entryLogger.addEntry(ledgerId, entry, rollLog);方法添加完 entry 对象后返回对象在文件的 offset，内部的 add 逻辑与上文分析的&lt;br&gt; SingleDirectoryDbLedgerStorage 一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/cd18ebe87ae54838b240b8aa9e4bf315~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=0XIhwoiE%2Biah75zqryOjU7TqeEM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9eb9cec086e54899931f62bb942339cd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=wFuSzSJDFQPUiS7u7wpBSjb1%2BBo%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#processEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerCache 是一个接口，具体的实现只有一个 LedgerCacheImpl 类，后者内部有两个支撑组件，IndexInMemPageMgr 和 IndexPersistenceMgr，从名称可以看出前者负责数据在内存中的保持，后者负责实际的存储。按照之前的分析的源码，很容易联想到数据大概率先落入 memoryPage 再落盘，pageSize 默认 8K，entriesPerPage 默认为 pageSize/8= 1K。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3b1ca181eea2430ab38d42dafdce9d77~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=5QPxZqx1NwbBXKEoH1hQ3gMWgk4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerCacheImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;putEntryOffset 方法首先通过 entryId 模以单个 page 页的 entry 数量得到当前 entryId 在具体的 page 页中的偏移量，这里的 page 不是 OS 中的 page 页，是 Bookeeper 单独抽象出来的 page 概念，需要区分开。在 getLedgerEntryPage 方法中，首先会尝试从内存中获取 LedgerEntryPage 对象，如果没有则调用 grabLedgerEntryPage 方法从磁盘上加载，内存中缓存的对象结构为 InMemPageCollection，内部是一个 LRU 缓存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;写入算法分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerEntryPage 是对单个页的抽象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;int offsetInPage = entry % entriesPerPage;计算出当前的 entryId 在单个 LedgerEntryPage 的逻辑偏移量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;long pageEntry = entry - offsetInPage; 计算出当前 LedgerEntryPage 中初始 entryId；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;基于 LedgerId 和初始 entryId 查找定位到 LedgerEntryPage，如果缓存中不存在，则从文件中加载；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;按照 offsetInPage 计算当前的 offset 需要写入的真实位置，这里的 offset 即是 entryLogger 中 entry location 值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;由于写入的数据为 offset 是个 long 类型，需要 8 个二进制为，实际的写入的位点为逻辑上的 offsetInPage*8。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4526e58486324a869c1028c747552b90~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=hNrBsydTwx83%2BUxi9rH38ge%2BIZY%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;IndexInMemPageMgr#putEntryOffset&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上述的算法自然也是可逆的，读取的时候同样基于 LedgerId 和 entryId 定位到具体的 LedgerEntryPage。然后在计算出实际的物理偏移量，在特定位置读取到 location 参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;顺序写入的 WAL 日志：Journal&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;分析完 writeCache 的写入及其背后的逻辑，我们继续分析 journal 日志的写入流程；上文提到 journal 为混合写入模式，可能存在多个 LedgerId 的数据混编。在 addEntryInternal 方法的最后一行中通过 LedgerId 获取到真实的 journal，获取的逻辑依然是个 hash 算法，用来保证相同 LedgerId 始终落到一个 journal 上进行处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;logAddEntry 干了三件事：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry.retain() 调整 entry 的引用计数值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journalStats 给内部的 queueSize +1；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;memoryLimitController 内存使用限速器，如果超限时，当前线程会被置为等待状态；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;queue.put(.......), 将待写入的数据放进队列。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;结合 logAddEntry 源码发现又是熟悉的味道，写入方法只是将请求放入队列，那么必然存在从队列获取数据并进行刷盘的逻辑。既然有 put 操作，必然有 take 操作，我们发现 takeAll 和 pollAll 方法 ，都位于 journal#run 方法中，run 方法这个名字如此敏感，以至于不跟 Thread 扯上点关系都说不过去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3482bc4d63f54742a8eebdeeddfbb8b8~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Z9aO0NuZROmBmKSmpCtOrT9%2BheM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#logAddEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6c0f62f4b9804d40991c50d269072324~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=%2BHZSzvVFyJhrA1ir%2BwamXRkO0I8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;queue 的调用点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span style=&quot;color:#114ba6&quot;&gt;public&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:#114ba6&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;Journal&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;extends&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;BookieCriticalThread&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;implements&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;CheckpointSource&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;查看 journal 的 class 签名，发现其不出所料的实现了 Thread 的 run 方法，journal 既是顺序写入日志逻辑的抽象也是后台的刷盘线程的抽象；&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;run 方法的实现较为复杂，其注释表明这是一个专门负责持久化的线程方法，同时负责 journal 文件的滚动，当 journal 文件被写满时，会使用当前时间戳创建一个新的 journal 文件，老的文件会被定期回收。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 queue 字段旁边有一个 forceWriteRequests 字段，这个字段在实际的刷盘逻辑中起到了重要作用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a12fa115e8d247e9b29937ddaca709ab~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=HOkuAdbF4xXsNNfMjGb1S8hFCQM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal 部分成员变量释义：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;maxGroupWaitInNanos 组提交间隔，一般超过这个时间需要刷盘；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flushWhenQueueEmpty 开关表示当 queue 为空时是否刷盘；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bufferedEntriesThreshold 表示暂存在 toFlush 中的对象数量的阈值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bufferedWritesThreshold 表示待刷盘的字节数阈值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journalPageCacheFlushIntervalMSec 真实刷盘的时间间隔。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 方法成员变量释义：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntries 是一个复用的定长数组；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntriesIdx 是这个定长数组中当前处理的元素索引编号，从 0 开始；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntriesLen 代表每次从 queue 队列中获取的对象数量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;toFlush 队列是个可复用的 ArrayList，可以认为是个对象池；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;numEntriesToFlush 是个待刷盘对象数量的计数器，与 toFlush 配合使用；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;lastFlushPosition 为上次刷盘位点记录值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;lastFlushTimeMs 为上次刷盘时间点（毫秒单位）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;JournalChannel 是单个 journal 文件的抽象，journal 代表单个目录下的多文件抽象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel 代表一个写入缓冲区，来自于 JournalChannel；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;qe 为 QueueEntry 类型的临时变量。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 的主要逻辑如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;启动 forceWriteThread 线程，这是一个真正意义上的刷盘线程；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 线程只是将 queue 中的 QueueEntry 对象写入相关的 FileChannel 的 buffer 中，并不保证一定落盘；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;实际的刷盘行为由 forceWriteThread 负责。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;不断的从 queue 中获取一组 QueueEntry 对象，并逐一将其写入 BufferedChannel 缓冲区；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;从 queue 中获取的 QE 对象放入 localQueueEntries 数组中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 需要符合一定的条件才会被写入二进制数据流（主要 entryId 和版本的识别）；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;写入调用的是 BufferedChannel#write 方法，只是将数据写入内部的 writeBuffer 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;写入缓冲区后，将 QE 对象添加进入 toFlush 队列，同时调整 numEntriesToFlush（+1）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;继续处理 localQueueEntries 中的下一个元素。当 localQueueEntriesIdx == localQueueEntriesLen 时，表示 localQueueEntries 元素全部处理完成，此时临时变量 qe(QueueEntry) 置为 null。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在处理 qe 对象的过程中，会综合多方面条件判断是否需要刷盘，使用临时变量 shouldFlush 表示；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当 numEntriesToFlush&amp;gt;0 且符合以下条件时会触发「刷盘」逻辑；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当临时变量 qe 为空，或者当前的 qe 处理的时间超过 maxGroupWaitInNanos；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当临时变量 qe 为空并且开启 flushWhenQueueEmpty 配置时刷盘；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当临时变量 qe 不为空，符合下面两个条件时刷盘；&lt;/span&gt;&lt;/span&gt; 
      &lt;ol&gt; 
       &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;且 toFlush 中暂存的对象数量超过 bufferedEntriesThreshold；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;或距离上次刷盘的位点间隔超过 bufferedWritesThreshold。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
      &lt;/ol&gt; &lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果满足刷盘条件，调用 BufferedChannel#flush 操作；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 操作会将之前攒批的 writeBuffer 中的数据写入 OS 的文件系统；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;底层作为 FileChannel#write 方法的入参；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;将 toFlush 相关索引为置空，同时调整 numEntriesToFlush；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;触发 entry 写入的相关回调逻辑执行；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;更新 lastFlushPosition。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 操作完成后将进一步判断是否需要向 forceWriteThread 提交真实的刷盘请求；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;提交时会将 toFlush 列表中全部对象连同其他参数封装成一个请求对象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;一旦提交后将更新 lastFlushTimeMs；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;符合提交条件的情况有：&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;开启 syncData ，journal 级别的开启同步刷盘的开关；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当前需要滚动创建新的 journal 文件；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;距离上次真实刷盘时间超过阈值 journalPageCacheFlushIntervalMSec。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p6-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/640cbca1dece48129b53f44fc9e98493~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QZIgme%2FnjT7qc1fnMbNcRmT5Ee8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;当真实刷盘请求被提交到 forceWriteThread 线程后，有必要进一步分析该线程的执行逻辑，相比之下 ForceWriteThread#run 方法的逻辑简单很多，解包收到的请求，然后调用 syncJournal 进行强制刷盘，同时做一些清理回收的动作，以及最后的一些回调方法的触发和统计操作。这里的 localRequests 也是一个可复用的临时数组。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4d236b2798084a4bbe3bef3b5a5c4d93~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=DF0IT5x2H541SqZIbXdPcoTa8Go%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ForceWriteThread#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#syncJournal 方法调用了 request 对象的 flushFileToDisk 方法，该方法内部调用了 logFile.forceWrite(false); 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;logFile 就是之前提到的单个 journal 文件的抽象，即 JournalChannel，其内部封装了 BufferedChannel，实际的类型为 DefaultEntryLogger，与 EntryLogger 所使用的底层实现如出一辙。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/785a9fc0bc63440a9a36c1152bc9fef5~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=gogSeuWPDADx7vpgQZybhrFavQA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#syncJournal&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a9329b4989e64ace98a13c62afa0cf6f~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=e%2ByW88RzPT0fEbYm0Ya4RhRiBnc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;JournalChannel 类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;再论 Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上文提到 BookieImpl 中的 addEntry 逻辑似乎很简单，数据写入交由 LedgerHander 和 journal 组件，自身则是简单的封装。实则不然，查看 BooikeImpl 的实现，发现其中存在一个 SyncThread 对象，该对象是一个同步线程，其逻辑为转写 journal 日志的数据到 entryLog 和 entryIndex。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/942f531f025742f6b4b24a777c3a2ea0~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=ghQVAaYtdbNnyClref1AzzE1vTM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/75475b9530b3443a85dfaca54221de1d~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=W5pPJh0ICMdvmDJDTdCcaBLKlsY%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;启动 checkpoint 定期检查&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;doCheckpoint 在底层最终调用了 LedgerStorage#checkpoint 方法，与上文提到的 writeCache 背后的 flush 殊途同归。这里存在另外一个问题：SyncThread 线程是否会与 triggerFlushAndAddEntry 中的 flush 线程并发执行，以及是否存在并发刷盘带来的数据错乱问题。答案是不会，具体来看 checkpoint 方法内部存在一个 flushMutex 锁，同时在进入锁之前，首先会对当前的 checkpoint 做判断，如果传入的 checkpoint 水位线低于当前&lt;br&gt; SingleDirectoryDbLedgerStorage 对象持有的 lastCheckpoint 水位线，则不执行实际的 checkpoint 动作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4b4d31c75d7241848b19c00f2efd333c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=tJmenSrpXdhS%2FwRbyjw%2BCcmjwvs%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SyncThread#doCheckpoint&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端分析总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookeeper 的 server 端的架构较为复杂，分为多级写入的架构，收据流向为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;数据首先进入 writeCache，有后台线程定期将 cache 数据同步到 entryLog 和 entryIndex；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 底层采用 swap 机制，保证写入延迟的稳定性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;调用 entryLog 和 entryIndex 分别写入业务数据和索引数据；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryIndex 使用 rocksDB 作为 KV 索引保存 LedgerId+ entryId 到 offset 的映射关系。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#flush 操作和 EntryLogger#flush 操作不同；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;前者只是将数据同步到 entryLog 和 entryIndex 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;后者真实调用底层的文件系统进行刷盘。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 日志的写入时可配置的，默认开启，journal 日志同样存在后台的刷盘线程；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 线程一直重复在干两件事；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;将 QueueEntry 转化为二进制写入 bufferChannel 的 writebuffer；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;综合判断各种条件，定期向 forceWriteThread 线程，提交真实的刷盘任务。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;四、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的数据读取流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;请求路由&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;回到 BookieRequestProcessor#processRequest 的源码截图，读取流程围绕 READ_ENTRY 这一 opCode 展开，同样在最新版本的 Bookie 代码中，read processor 升级到了 V3 版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/da4e75686f194581bbf94fb8b2b21463~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=LCrKjnO6fkI5%2BkidaSVtNnqMvho%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;和写入一样，在读取的 processReadRequestV3 方法中，依然有高优先级线程池和普通线程池，不同的是还多了一个长轮询线程池，在投递任务时又出现了熟悉的操作，跟 LedgerId 选择线程池中具体的线程执行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0fc61e4f097147b0a21e3f02ad87f205~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Nzj0BbwF0wmRlpTULiMqUv5vwvk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processReadRequestV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;直接跳转 ReadEntryProcessorV3#run 方法。发现是个空壳，逻辑封装 executeOp 方法中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7466b4971a42470b994d89c48ea6d744~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=gKyaBt7ov3UFD%2B9cB1ydqTZ42SA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#readEntry&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;最终的读取逻辑在 BookieImpl#readEntry 中，该方法只是简单的封装，根据 LedgerId 获取到 LedgerDescriptor 后，读取逻辑顺利委托给了 LedgerDescriptor，在 LedgerDescriptor#readEntry 方法内进一步套娃，又将请求转移给了 LedgerStorage#getEntry，前文提到 LedgerStorage 是个接口，真正干活的是&lt;br&gt; SingleDirectoryDbLedgerStorage 中的 doGetEntry 方法，这个类在写入请求的分析过程中同样出场过。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9bc7bcac6a4d45cc951c98251327b4ae~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=eqAtbeQDRooXg74sEdqiRNWAD0k%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#readEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;doGetEntry 方法的逻辑整体较为简单，主要分为以下几步：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果传入的 entryId 为-1 ，表示读取 LAC ，先从 Ledger 中获取实际的 LAC 的 entryId，在进行读取；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;默认先从 writeCache 中读取，如果读取不到则去 writeCacheBeingFlushed 中读取，命中则直接返回；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果 2 级缓存中均不存在，则去 readCache 中据需读取；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果 readCache 也不存在，那么就要触发磁盘读，先去 entryLocationIndex 获取 entryLogger 中的物理偏移量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;随后调用 entry = entryLogger.readEntry(ledgerId, entryId, entryLocation); 获取真实数据；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;数据获取到后会放入 readCache 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在方法结束时，会触发一次预读，读取紧挨着当前 entry 的下一个 entry 并放入 readCache 中。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/10592c6aa7c94ae29fe520eceddab116~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=g%2FW4QtAWEb74plNFKiGh5E595kE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#doGetEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger 如何读取 entry&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 的读取在上图的 640 行，最终调用方法为 DefaultEntryLogger#internalReadEntry 方法。逻辑如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;将 location 参数转化为 buffer 中的 position 位点；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;获取到 FileChannel(856 行)；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;从 pos-4 位置开始读取 20 个字节并解析，sizeBuf 值为 entry 的整体长度（4+8+8）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;然后分配一个 sizeBuf 大小的 buffer 用于装载即将要读取的 entry。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/74790b9260fa433e8d4dc129b2b01ad8~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=H8nBbAidGdUZINxkbdT2nVMg0T8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#internalReadEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/63ab3d9ab38941398572f7c8f65cf212~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=htCn2q%2FPiIgazf1m5lg4o13eS%2FA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#readEntrySize&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在存量数据足够的情况下 readFromLogChannel 方法会尽可能将入参中的 buffer 填满，在 BufferedReadChannel 中存在一个 readBuffer，默认大小 512 字节，read 方法仍然有可能命中该缓存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/587ac986509346858d84935a2dd2b0f5~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=7Js6rbpsWGie%2BDNIVYkDCLnaD7E%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#readFromLogChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端分析总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;数据的查询内容比较简单，从大的架构上来看整个读取过程存在三级缓存，都不命中的话才会读取磁盘。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;实际上在上层的 broker 组件里还有一层缓存存在。消息获取流程如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c6212093d3de46b798d79bfad5a9752a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=OgISxwJXrCICgKNz0DApy60MStE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;五、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;读写调用链分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;组件模块分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;其派生关系如下图所示，还有一个 SlowBufferedChannel 继承 BufferedChannel 类，但是该类为测试使用。BufferedReadChannel 是读场景下的主要支撑类，内部有 512 字节的读缓冲。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/054a5088d16042c0a86ba4c414d4e2e4~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=k8OXmKeAdDsoA5iOtIUoNTLJ3vM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;默认使用 DefaultEntryLogger，主要用于存储实际的 entry 对象数据，DefaultEntryLogger 和 DirectEntryLogger 的区别在于一个使用 JDK 的 RandomAccessFile ，另一个直接使用 DIO（单独依赖特定 C 库）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f18b0dccc7a2478590e83816b4e5f7b9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=0s8B1zDWga5xBnXRdLEDrlKR4k0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b0bc2c0d39d54a9cbf6a20b81e29272d~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=M2jOVDPB7Aj6weSYksweY8RYaFw%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DirectEntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;基于 EntryLogger 的上层抽象，主要实现有 InterleavedLedgerStorage 和&lt;br&gt; SingleDirectoryDbLedgerStorage， 还有一个 SortedLedgerStorage，内部封装了 InterleavedLedgerStorage，复用了大部分的 InterleavedLedgerStorage 的方法。SortedLedgerStorage 每次写入时对内部的数据进行排序，使用自带的 KV 引擎存储 LedgerId+entryId--&amp;gt;location 映射关系。SingleDirectoryDbLedgerStorage 每次刷盘时才会对缓存的数据进行排序，使用 rocksDB 存储 KV 关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ba4d06e591ef44daa9d61fd49797a38b~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Rwnng0zaWSyfAjLsLER%2FHFN5xuI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/009d3df275cb4b63894e7d56fb1d28eb~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=jfkJD6uhdy1kASljF9FJZd%2BJHjc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;包装类，大部分逻辑委托给 ledgerStorage 实现。内部持有 ledgerId，每个 ledgerId 对应一个 LedgerDescriptor 对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 节点级存储抽象，内部封装了多个 journal 抽象组成的 journalList，ledgerStorage，syncThread 线程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;syncThread 线程主要负责将 journal 中的 appendLog 转写为 entryLog 和 enrtyIndex，checkpoint 之前的数据在执行 GC（数据清理工作，非 JVM 中的 GC）时可被回收删除。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3，WriteEntryProcessorV3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;负责读写指令的路由和转化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;写入流程调用时序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt; Bookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerDescriptor&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;EntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;BufferedLogChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1c735733cd674ce3918d9859602f7050~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=63qO9iUg3pIXQ5J1aZeiutQE6uE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;读取流程调用时序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt; Bookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerDescriptor&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;EntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;BufferedReadChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7366bcc7df3f4d5ab2bcd2562b260d18~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=dZL%2BVkBi5st0Z%2FYaAm3N5aZ3o6M%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;六、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;架构总结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 的存储架构主要分为三大块，首先是代表 WAL 日志的 journal 文件写入，以顺序混写的方式提升写入性能，保证低延迟，通常以独立盘隔离挂载，典型的消息场景下 journal 日志写完后即可返回。由于是不同 topic 的混合写入，journal 日志无法很好的支撑单个 topic 的消息的顺序读，回溯等场景，会存在读放大问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;由此就衍生出了 entryLog 的二次转储，为了尽可能利用顺序读，单个 entryLog 内部的数据在写入时会根据 ledgerId+entryId 排序，这样同一个 ledgerId 的数据会紧密的收敛在局部，能够一定程度上提升读性能；entryLog 写入后会获取到消息实际存储的位点信息 offset，由于该 offset 不可被自定义，很难表述出这条消息在 topic 写入序列上为第几条信息，这一点很重要，因为消费的时候是基于这样的序列来消费的，同时在消费位点管理时也需要这样的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryId 的作为一个传入参数，其作用恰恰如此，是一个面向用户的更易于管理的唯一 Id。当用户基于 ledgerId+entryId 来查找数据时，显然并不知道这个这条数据实际存储 offset 信息。这就诞生了一个额外的 KV 结构，用来保存 ledgerId+entryId 到 offset 的映射关系。Bookie 内嵌了 rocksDB 的 KV 引擎，同时也自行实现了一套，Pulsar 默认使用 rocksDB 方式保存 KV 关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bookie 在整个写入和读取过程中利用了大量的用户态缓存机制，相比于 mmap 的 pageCache 机制更为灵活可控，同时也很大程度上降低了读写的抖动，尤其是在容器环境下不同 POD 互相干扰的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;*&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;文/&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;簌语&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;本文属得物技术原创，更多精彩文章请看：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;得物技术&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;未经得物技术许可严禁转载，否则依法追究法律责任！&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/5783135/blog/11194314</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/11194314</guid>
            <pubDate>Tue, 28 May 2024 02:08:00 GMT</pubDate>
            <author>得物技术</author>
        </item>
        <item>
            <title>昆仑万维：天工 AI 每日活跃用户超 100 万</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;昆仑万维宣布，天工 AI 每日活跃用户（DAU）已超过 100 万。并表示，在初步验证大模型能力之后，天工 AI 将继续聚焦产品市场匹配度（PMF, Product Market Fit）。&lt;/p&gt; 
&lt;p&gt;国内商业智能数据服务商 QuestMobile 数据显示，早在 2024 年 3 月，昆仑万维天工 AI APP 的月活跃用户已达近千万，仅次于豆包与文心一言，成为国内 AIGC APP 月活跃用户第三。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;309&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-545cde53bfd86762ad17eee2e934e789562.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此外，天工 AI 智能体平台目前已拥有近百万个 UGC 智能体。&lt;/p&gt; 
&lt;p&gt;天工 AI 最新上线的 AI PPT 则是近期最受用户欢迎的 AI 智能体之一。用户只需要输入 PPT 内容需求，天工 AI 即可立即在线生成一份完整、可编辑的 PPT 大纲及各页内容文本，并实现智能检索图片、智能匹配模板，一键生成内容完整、逻辑清晰、布局优美的 PPT 文档，用户可在线或下载到本地进行编辑与分享。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;328&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b6a2df6071f19c4eca764da6ceb56111c3c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;昆仑万维方面表示，下一步将全力推动人工智能技术应用落地，不断优化天工 AI 的模型技术研发与产品用户体验，打造用户首选的人工智能内容创作平台，赋能用户生成高质量的文字、声音、图像、音乐、视频等 AI UGC 内容，让人工智能技术走入千家万户，为我国人工智能产业发展贡献积极力量。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294578</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294578</guid>
            <pubDate>Tue, 28 May 2024 02:04:49 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>原来东子的「兄弟」是用 let 定义的「兄弟」</title>
            <description>媒体报道称，刘强东近日在高管会上直言：「凡是长期业绩不好，从来不拼搏的人，不是我的兄弟。」</description>
            <link>https://mp.weixin.qq.com/s/_MYBiooOBtC5u7-m-JmC2A</link>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s/_MYBiooOBtC5u7-m-JmC2A</guid>
            <pubDate>Mon, 27 May 2024 14:10:00 GMT</pubDate>
        </item>
        <item>
            <title>微软对开源字体 Cascadia Code 进行重大更新</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Cascadia Code 2404.23 版本已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fcommandline%2Fcascadia-code-2404-23%2F&quot; target=&quot;_blank&quot;&gt;发布&lt;/a&gt;。Cascadia Code 是微软开源的一套等宽字体，这是该字体自三年前发布 2111.01 版本以来的第一次重大版本更新。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2404.03 版本中为 Cascadia Code 添加了对象限、六分仪、八分仪、大型字体、更多传统计算符号和 Nerd 字体的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;285&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-26f734452da97140646a771c76f8167c980.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;356&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-19736901ec49a109baf16d78ec836d36a29.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;311&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-76c6dc1f24cbbfcf90338aec83762a1a404.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;451&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-657504c9b33faf48aa5491b4121d1529bb5.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;244&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-830dad5725018c339e6d639be1febe23587.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告称，项目团队正在将「Cascadia Code NF」和「Cascadia Mono NF」添加到 Cascadia Code 字体系列中。Cascadia Code NF 和 Cascadia Mono NF 是 Cascadia Code 的原生「&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nerdfonts.com%2F&quot; target=&quot;_blank&quot;&gt;Nerd Font&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;」变体，包含截至 2024 年 4 月的最新 Nerd Font 字形。且每个字形都与 Cascadia Code 的其余部分兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;329&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-61dc965e58e3e7d16af123a6e9b737344fc.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户可以将 Cascadia Code 的 Nerd 字体变体与 Oh My Posh 相结合，进行自定义。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;324&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-dedb91d874502190a5f1c6e59b473f5751d.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多详情可&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fcommandline%2Fcascadia-code-2404-23%2F&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294449/cascadia-code-2404-23</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294449/cascadia-code-2404-23</guid>
            <pubDate>Mon, 27 May 2024 06:45:14 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>黑客利用扫雷游戏 Python 克隆隐藏恶意脚本，攻击欧洲和美国金融机构</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;近期，乌克兰的国家计算机紧急响应小组（CSIRT-NBU）和乌克兰计算机紧急响应小组（CERT-UA）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fhackers-phish-finance-orgs-using-trojanized-minesweeper-clone%2F&quot; target=&quot;_blank&quot;&gt;揭露了一起黑客攻击事件&lt;/a&gt;。攻击者利用微软经典扫雷游戏的 Python 克隆代码，隐藏针对欧洲和美国金融机构的恶意脚本。&lt;/p&gt; 
&lt;h3&gt;攻击背景与执行者&lt;/h3&gt; 
&lt;p&gt;本次攻击被追踪到一个代号为「UAC-0188」的威胁行为者。该黑客组织通过使用合法代码，成功地隐藏并下载安装了 SuperOps RMM 的 Python 脚本。&lt;/p&gt; 
&lt;p&gt;SuperOps RMM 是一款合法的远程管理软件，但被攻击者用来直接访问被入侵的系统。CERT-UA 的报告指出，自攻击被发现以来，已经有至少五起涉及欧洲和美国金融及保险机构的潜在相同文件的违规行为。&lt;/p&gt; 
&lt;h3&gt;攻击细节&lt;/h3&gt; 
&lt;p&gt;攻击从一封伪装成医疗中心的电子邮件开始，发件地址为「support@patient-docs-mail.com」，邮件主题为「个人医疗文档的网络档案」。受害者被诱导从提供的 Dropbox 链接下载一个 33MB 的.SCR 文件。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1126&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0527/142132_Kt16_3820517.png&quot; width=&quot;1688&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;该文件包含了一个无害的 Python 克隆扫雷游戏代码，但同时也隐藏了从远程源（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanotepad.com&quot; target=&quot;_blank&quot;&gt;anotepad.com&lt;/a&gt;）下载额外脚本的恶意 Python 代码。扫雷代码中包含一个名为「create_license_ver」的函数，该函数被重新用于解码和执行隐藏的恶意代码。黑客利用这种方法试图让安全软件误认为该文件是无害的。&lt;/p&gt; 
&lt;p&gt;恶意代码通过 base64 编码的字符串隐藏在文件中，该字符串解码后会组装一个包含 SuperOps RMM 的 MSI 安装程序的 ZIP 文件。安装程序最终被提取并使用静态密码执行，授予攻击者对受害者计算机的未授权访问。&lt;/p&gt; 
&lt;h3&gt;安全建议&lt;/h3&gt; 
&lt;p&gt;CERT-UA 建议不使用 SuperOps RMM 产品的组织，将任何与该产品相关的网络活动，如对「&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsuperops.com&quot; target=&quot;_blank&quot;&gt;superops.com&lt;/a&gt;」或「&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsuperops.ai&quot; target=&quot;_blank&quot;&gt;superops.ai&lt;/a&gt;」域的调用，视为黑客入侵的迹象。报告底部还分享了与此次攻击相关的其他入侵指标（IoCs），供安全团队参考。&lt;/p&gt; 
&lt;p&gt;这起攻击事件提醒我们，黑客正在不断寻找创新的方法来绕过安全防护，企业和个人用户都应时刻保持警惕，及时更新安全软件，避免下载和执行来历不明的文件。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294442/hackers-phish-finance-orgs-using-trojanized-minesweeper-clone</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294442/hackers-phish-finance-orgs-using-trojanized-minesweeper-clone</guid>
            <pubDate>Mon, 27 May 2024 06:23:14 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>华为发布 2024 年奥林帕斯难题悬红——200 万元、解决 AI 与数据存储难题</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;近日，华为在 2024 年全球数据存储教授论坛上，宣布了&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fe.huawei.com%2Fcn%2Ftopic%2Fstorage%2Folympus-mons-awards&quot; target=&quot;_blank&quot;&gt;2024 年奥林帕斯难题悬红&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;今年的奥林帕斯难题包括两个方向：&lt;strong&gt;一是每比特极致性价比的存储技术，二是面向 AI 时代的新型数据底座&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;奥林帕斯难题百万悬红设立两个奥林帕斯奖，每个难题方向各一个，如果某个难题方向大奖空缺，增设 1-2 个奥林帕斯先锋奖。&lt;strong&gt;奥林帕斯奖奖金为 100 万元人民币/个，奥林帕斯先锋奖奖金 50 万元人民币/个&lt;/strong&gt;，旨在吸引全球顶尖科研人才共同探索数据存储领域的前沿技术。&lt;/p&gt; 
&lt;p&gt;据了解，自 2019 年起，华为每年发布奥林帕斯难题百万悬红，旨在牵引全球数据存储领域基础理论研究方向，突破关键技术难题，加速科研成果产业化，实现产学研合作共赢。目前，「奥林帕斯悬红」已发布四期，共吸引来自全球 49 所高校的 240 多名学者积极参与。&lt;/p&gt; 
&lt;p&gt;去年，苏黎世联邦理工学院 Torsten Hoefler 教授团队以及上海交通大学过敏意教授团队荣获 2023 年奥林帕斯奖。来自新加坡国立大学尤洋教授团队、韩国科学技术院 John Kim 教授团队、北京大学杨仝老师团队、中国科学院计算技术研究所王颖老师团队获得 2023 年奥林帕斯先锋奖。&lt;/p&gt; 
&lt;p&gt;华为数据存储产品线总裁周跃峰表示，具备极致性能、数据韧性、全新数据范式、高扩展性、绿色节能、数据编织能力的数据存储是 AI 时代存储演进的必由之路，需要各界的共同参与。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;近日发布的《全国数据资源调查报告（2023 年）》显示，2023 年，全国数据生产总量达 32.85ZB（泽字节），同比增长 22.44%。&lt;/p&gt; 
&lt;p&gt;在数据存储方面，2023 年我国累计数据存储总量为 1.73ZB（泽字节），存储空间利用率为 59%，其中政府和行业重点企业存储空间利用率均为 70% 左右。在上述存储数据中，数据云存储占比超过 40%。&lt;/p&gt; 
&lt;p&gt;在算力方面，至 2023 年底，全国 2200 多个算力中心的算力规模同比增长约为 30%。大模型训练算力需求高涨，科学、政务、金融、工业等行业算力需求增加。&lt;/p&gt; 
&lt;p&gt;报告还指出，我国数据资源管理和利用整体处于起步阶段，目前还存在数据有效供给不足、算力还需适度超前布局、数据多元流通模式待完善、数据价值有待进一步释放等挑战。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294439/huawei-olympus-mons-awards-2024</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294439/huawei-olympus-mons-awards-2024</guid>
            <pubDate>Mon, 27 May 2024 06:19:14 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>苹果重新设计其开发者论坛</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;苹果&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fnews%2F%3Fid%3Dhufhlpow&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;已针对 WWDC24 重新设计其开发者论坛，以便于开发者与 Apple 专家、工程师以及彼此联系，寻找答案并获取建议。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「Apple 开发者关系部和 Apple 工程部门将联手解答您的问题，并努力解决您的技术问题。您将可以访问扩展的知识库并享受快速响应时间 - 这样您就可以重新开始创建和改进您的应用或游戏。此外，Apple 开发者计划成员现在可以优先访问论坛上的专家建议。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;259&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5c7ab78dc1b4fbff123235c53f00bcd74d4.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;论坛现在按照一些主题划分了十几个大分类，以帮助用户精确导航查找。具体包括：Accessibility &amp;amp; Inclusion、App &amp;amp; System Services、App Store&amp;nbsp;分发和营销、商业与教育、代码签名、社区、开发人员工具和服务等等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;其中，每个大分类还包含了一些更具体的子主题。在特定问题旁边可能会出现「Apple 推荐」图标，表示 Apple 工程师已经回答了该问题；或者出现「已解决」图标，表示该问题有一个社区认可的答案。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;除了按主题浏览外，还有一个 &lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fforums%2Flatest&quot; target=&quot;_blank&quot;&gt;Latest &lt;/a&gt;栏目&lt;span style=&quot;color:#000000&quot;&gt;，其中显示了所有主题的所有最新内容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;详情可查看：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fforums%2F&quot; target=&quot;_blank&quot;&gt;https://developer.apple.com/forums/&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294436/apple-redesigns-developer-forums</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294436/apple-redesigns-developer-forums</guid>
            <pubDate>Mon, 27 May 2024 06:08:14 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>行业内首次实现国产 GPU 从 0 到 1 的端到端 AI 大模型实训</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;摩尔线程、无问芯穹今天联合宣布，双方已经正式完成基于国产全功能 GPU 千卡集群的 3B 规模大模型「MT-infini-3B」实训，&lt;strong&gt;该模型基于摩尔线程国产全功能 GPU MTT S4000 组成的千卡集群&lt;/strong&gt;，以及无问芯穹的 AIStudio PaaS 平台打造。&lt;/p&gt; 
&lt;p&gt;据悉，这次的 MT-infini-3B 模型训练总共用时 13.2 天，全程稳定无中断，集群训练稳定性达到 100％，千卡训练和单机相比扩展效率超过 90％，号称「充分验证了夸娥千卡智算集群在大模型训练场景下的可靠性，同时也在行业内率先开启了国产大语言模型与国产 GPU 千卡智算集群深度合作的新范式」。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;本次实训充分验证了夸娥千卡智算集群在大模型训练场景下的可靠性，同时也在行业内率先开启了国产大语言模型与国产 GPU 千卡智算集群深度合作的新范式。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前，实训出来的 MT-infini-3B 性能在同规模模型中跻身前列，相比在国际主流硬件上训练而成的其他模型，在 C-Eval，MMLU，CMMLU 等 3 个测试集上均实现性能领先。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-006f2e3d0fd10bdbe8a116c276fc8e377b4.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;MT-infini-3B 性能表现&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;无问芯穹联合创始人兼 CEO 夏立雪表示：「国内大模型与国产芯片的软硬件协同发展，最终目标是构建一个成熟的生态系统。无问芯穹正在打造‘M 种模型’和‘N 种芯片’间的‘M×N’中间层产品，实现多种大模型算法在多元芯片上的高效、统一部署。摩尔线程是第一家接入无问芯穹并进行千卡级别大模型训练的国产 GPU 公司，而‘MT-infini-3B’的训练是行业内首次实现基于国产 GPU 芯片从 0 到 1 的端到端大模型实训案例。」&lt;/p&gt; 
&lt;p&gt;摩尔线程创始人兼 CEO 张建中表示：「无问芯穹在夸娥千卡智算集群上实现的从零开始的大模型训练，不仅是对摩尔线程技术实力的有力认证，更是实现了国内大模型训练的国产化闭环。摩尔线程夸娥千卡智算集群以全功能 GPU 为底座，提供软硬一体化的全栈解决方案，具备高兼容性、高稳定性、高扩展性等综合优势，我们致力于成为 AGI 时代大模型训练坚实可靠的先进基础设施。」&lt;/p&gt; 
&lt;p&gt;此前，摩尔线程与无问芯穹已达成深度战略合作。无问芯穹大模型开发与服务平台「无穹 Infini-AI」和摩尔线程大模型智算千卡集群夸娥已完成系统级融合适配，该平台可以灵活调用夸娥的集群能力以完成大模型的训练、微调与推理任务。未来，双方还将开展更多适配与测试，推动国产大模型技术的快速发展与应用普及，为中国人工智能产业的蓬勃发展贡献力量。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;▼&lt;/strong&gt;&amp;nbsp; 关于无问芯穹&lt;/p&gt; 
&lt;p&gt;无问芯穹（Infinigence AI）依托行业领先且经过验证的 AI 计算优化能力与算力解决方案，追求大模型落地的极致能效。打造「M 种模型」和「N 种芯片」间的「M×N」中间层产品，实现多种大模型算法在多元芯片上的高效、统一部署。链接上下游，共建 AGI 时代大模型基础设施，加速 AGI 落地千行百业。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;▼&lt;/strong&gt;&amp;nbsp; 关于摩尔线程&lt;/p&gt; 
&lt;p&gt;摩尔线程是一家以全功能 GPU 芯片设计为主的集成电路高科技公司，能够为广泛的科技生态合作伙伴提供强大的计算加速能力，致力于打造为下一代互联网提供多元算力的元计算平台。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294431</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294431</guid>
            <pubDate>Mon, 27 May 2024 05:52:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>我的 CEO 觉得任何技术经理都是多余的</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                            
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;原文 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcharity.wtf%2F2024%2F01%2F05%2Fquestionable-advice-my-boss-says-we-dont-need-any-engineering-managers-is-he-right%2F&quot; target=&quot;_blank&quot;&gt;QUESTIONABLE ADVICE: 「MY BOSS SAYS WE DON’T NEED ANY ENGINEERING MANAGERS. IS HE RIGHT?」&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ae1abd6d4c75f3c03c8a571fbf995b47e5c.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;我最近加入了一家初创公司，负责管理一个约 40 名工程师的团队，担任技术副总裁。然而，我与 CEO（之前是工程师）在是否需要雇佣专职技术经理的问题上产生了很大的冲突。目前，工程师们被分成了 3-4 人的小团队，每个团队有一个工程师头头，负责领导团队，但他们的主要职责仍然是编写代码和交付产品。&lt;/p&gt; 
&lt;p&gt;我有 HC 在未来一年雇佣更多的工程师，但没有经理的 HC。老板认为我们是初创公司，负担不起这种奢侈品。在我看来，我们显然需要技术经理，但在他看来，经理只是多余的开销，在我们的阶段所有人都应该全力编写代码。&lt;/p&gt; 
&lt;p&gt;我不知道该如何论证。在我看来这很显然，但实际上我很难用言语表达为什么我们需要技术经理。你能帮帮我吗？&lt;/p&gt; 
&lt;p&gt;—— 真的是多余的开销吗 (？！)&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;这里有很多问题需要解答。&lt;/p&gt; 
&lt;p&gt;你的首席执行官不理解为什么需要经理，这并不奇怪，因为他似乎不明白为什么需要组织结构。🙈 他为什么要对你如何组织团队或你可以雇佣哪些角色进行微管理？他雇用了你来做这份工作，却不让你完成。他甚至不能解释为什么不让你做。这不是个好兆头。&lt;/p&gt; 
&lt;p&gt;但这个问题确实值得思考。我们假设他不是故意要刁难你。😒&lt;/p&gt; 
&lt;p&gt;我能想到两种论证雇用技术经理的方式：一种是相当复杂的，从第一性原理 (First Principle) 出发，另一种非常简单，但可能不太令人满意。&lt;/p&gt; 
&lt;p&gt;我个人对权威有一种强烈的反感；我讨厌被告知该做什么。直到最近，我才通过系统理论的视角，找到了一种对层级制度既健康又实用的理解。&lt;/p&gt; 
&lt;h2&gt;为什么组织中存在层级制度？&lt;/h2&gt; 
&lt;p&gt;层级制度确实带有很多负面包袱。我们许多人都有过在层级制度下与经理或整个组织打交道的不幸经历。在这些地方，层级制度被用作压迫的工具，人们通过垄断信息和玩弄权力游戏来提升地位，决策则是通过权力压制来做出。&lt;/p&gt; 
&lt;p&gt;在那种地方工作真的是一种折磨。谁愿意将自己的创造力和生命力投入到一个感觉像《呆伯特》漫画的地方，明知道自己的价值被极少认可或回报，而且这些价值会慢慢地但确实被压制掉？&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6d2e37d41170abca4035827e64d6dfa12f6.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;但层级制度本质上并非是专制的。层级制度并不是人类为控制和支配彼此而发明的一种政治结构，它实际上是自组织系统的一种属性，是为了子系统的有效运作而出现的。事实上，层级制度对复杂系统的适应性、弹性和可扩展性至关重要。&lt;/p&gt; 
&lt;p&gt;让我们从一些关于系统的基本事实开始，为可能不熟悉的人介绍一下。&lt;/p&gt; 
&lt;h2&gt;层级是自组织系统的一种属性&lt;/h2&gt; 
&lt;p&gt;一个系统是「由相互依赖的组件组成的网络，这些组件共同工作以实现一个共同目标」（W. Edward Deming）。一堆沙子不是一个系统，但一辆车是一个系统；如果你把油箱取下来，车就无法运作。&lt;/p&gt; 
&lt;p&gt;子系统是一个在更大系统内有较小目标的元素集合。在一个系统中可以有很多层次的子系统，它们相互依存地运行。子系统总是为了支持更大系统的需求而工作；如果子系统只为自己的最佳利益优化，整个系统可能会挂掉（这就是「次优」(suboptimal) 这个术语的由来 😄）。&lt;/p&gt; 
&lt;p&gt;如果一个系统能够通过多样化、适应和改进自身使自己变得更加复杂，那么它就是自组织的。随着系统自组织并增加其复杂性，它们往往会生成层级 —— 即系统和子系统的排列。在一个稳定、有弹性和高效的系统中，子系统在很大程度上可以自我管理、自我调节，并为更大系统的需求服务，而更大系统则负责协调子系统之间的关系并帮助它们更好地发挥作用。&lt;/p&gt; 
&lt;p&gt;层级最小化了协调成本，减少了系统中任何部分需要跟踪的信息量，防止信息过载。子系统内部的信息传递和关系比子系统之间的信息传递或关系要密集得多，延迟也少得多。&lt;/p&gt; 
&lt;p&gt;（对于任何软件工程师来说，这些应该都很熟悉。模块化，对吧？😍）&lt;/p&gt; 
&lt;p&gt;按照这个定义，我们可以说，经理的工作就是在团队之间进行协调并帮助他们的团队表现得更好。&lt;/p&gt; 
&lt;h2&gt;对社会技术系统的二分是伪命题&lt;/h2&gt; 
&lt;p&gt;你可能听过这个谬论：「工程师搞技术，经理搞人。」我讨厌这种说法。😊 我认为这完全误解了社会技术系统的本质。社会技术系统中的「社会」和「技术」并不是截然分开的，而是相互交织、相互依存的。事实上，很少有纯粹的技术工作或纯粹的人际工作；有大量涉及两种技能的粘合工作。&lt;/p&gt; 
&lt;p&gt;看看任何一个有效运作的工程组织除了编写代码之外还要做的一部分任务：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;招聘、建立人脉、面试、培训面试官、汇总反馈、撰写职位描述和职业发展路径&lt;/li&gt; 
 &lt;li&gt;每个项目或承诺的项目管理、优先级排序、管理利益相关者和解决冲突、估算规模和范围、进行回顾会议&lt;/li&gt; 
 &lt;li&gt;召开团队会议、进行一对一交流、提供持续的成长反馈、撰写评审、代表团队的需求，架构设计、代码审查、重构；捕获 DORA 和生产力指标、管理警报量以防止倦怠&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;许多工作可以由工程师完成，而且通常也是如此。每家公司对这些任务的分配方式有所不同。这是一件好事！你不希望这些工作仅由经理来做。你希望个人贡献者共同创造组织，并参与其运行方式。几乎所有这些工作由有工程背景的人完成会更有效。&lt;/p&gt; 
&lt;p&gt;所以，你可以理解为什么有人会犹豫是否要把宝贵的人员编制花在技术经理上。为什么不希望技术部门的每个人的主要工作都是编写和交付代码呢？这不是从定义上说最大化生产力的最佳方式吗？&lt;/p&gt; 
&lt;p&gt;额……😉&lt;/p&gt; 
&lt;h2&gt;技术经理是一层有用的抽象&lt;/h2&gt; 
&lt;p&gt;理论上，你可以列出所有需要完成的协调任务，并让不同的人来负责每一项。但实际上，这是不切实际的，因为这样每个人都需要了解所有事情。记住，层级制度的主要好处之一是减少信息过载。团队内部的沟通应该是高效和快速的，而团队之间的沟通则可以少一些。&lt;/p&gt; 
&lt;p&gt;随着公司的扩展，你不能期望每个人都认识其他所有人；我们需要抽象的概念才能运作。经理是他们团队的联络点和代表，充当重要信息的路由器。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0574899d959a544f15c5ae6ff19d2228584.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;有时我把经理想象成公司的神经系统，将信息从一个部门传递到另一个部门，以协调行动。将许多或大部分功能集中到一个人身上，可以利用专业化的优势，因为经理会不断建立关系和背景知识，并在他们的角色中不断改进，这大大减少了其他人的上下文切换。&lt;/p&gt; 
&lt;h2&gt;管理者 (Manager) 日程与创造者 (Maker) 日程&lt;/h2&gt; 
&lt;p&gt;技术工作需要集中和专注。上下文切换的成本很高，过多的中断是挺要命的。而管理工作则是每小时左右进行一次上下文切换，并且一整天都要应对各种打断。这是两种完全不同的工作模式、思维方式和日程安排，无法很好地共存。&lt;/p&gt; 
&lt;p&gt;通常，你希望团队成员能够把大部分时间花在直接为他们负责的成果做出贡献的事情上。工程师只能做有限的粘合工作，否则他们的日程安排就会变得支离破碎，从而无法履行他们的承诺。而管理者的日程安排本身已经是支离破碎的，因此让他们承担更多的粘合工作通常不会带来太大干扰。&lt;/p&gt; 
&lt;p&gt;虽然并不是所有粘合工作都应该由管理者来完成，但管理者的职责是确保所有工作都能完成。管理者的职责是尽量让每个工程师都能从事有趣且具有挑战性的工作，但不能让他们感到过于负担重，还要确保不愉快的工作能公平分配。管理者还要确保，如果我们要求某人完成一项工作，就必须为其配备成功完成这项工作所需的资源，包括专注的时间。&lt;/p&gt; 
&lt;h2&gt;管理是问责的工具&lt;/h2&gt; 
&lt;p&gt;当你是工程师时，你对自己开发、部署和维护的软件负责。而作为经理，你则对团队和整个组织负责。&lt;/p&gt; 
&lt;p&gt;管理是一种让人们对特定结果（如构建具备正确技能、关系和流程的团队，以做出正确的决策并为公司创造价值）负责的方式，并为他们提供实现这些结果所需的资源（预算、工具和人员编制）。如果你不把组织建设作为某人的首要任务，那么这就不会成为任何人的首要任务，这意味着它可能不会得到很好地执行。那么，这该由谁负责呢，CEO 先生？&lt;/p&gt; 
&lt;p&gt;你对技术负责人、工程师或任何负责交付软件的人在「业余时间」能完成的任务有一个合理的上限。如果你试图让技术负责人负责构建健康的工程团队、工具和流程，那么你就是在要求他们在同一个日历里做两份时间不兼容的工作。最可能的情况是，他们会专注于自己觉得舒适的成果（技术成果），而在后台堆积组织债务。&lt;/p&gt; 
&lt;p&gt;在自然层级中，我们向上看是为了目标，向下看是为了功能。简而言之，这就是我们需要技术经理的复杂原因。&lt;/p&gt; 
&lt;h2&gt;选择无趣的技术文化&lt;/h2&gt; 
&lt;p&gt;更简单的论点是：大多数工程组织都有技术经理。这是默认设置。多年来，许多比你或我更聪明的人花了大量时间思考和调整组织结构，这就是我们得到的结果。&lt;/p&gt; 
&lt;p&gt;正如丹-麦金利（Dan McKinley）的名言，我们应该「选择无趣的技术」。无趣并不意味着不好，而是意味着它的能力和失败条件是众所周知的。你只能获得少数的创新点数，因此你应该明智地将这些点数用在能够成就或毁掉你业务的核心差异点上。文化也是如此。你真的想把你的点数用在组织结构上吗？为什么？&lt;/p&gt; 
&lt;p&gt;无论好坏，层级组织结构是众所周知的。市场上有很多人擅长管理或与管理者合作，你可以雇佣他们。你可以接受培训、指导，或者阅读大量的自助书籍。有各种各样的管理哲学可以围绕它们来凝聚团队或用来排除其他人。另一方面，我所知道的无经理实验（例如 Medium 和 GitHub 的全员自治，或 Linden Lab 的「选择你的工作」）都被悄然放弃或被颠覆了。在我的经验中，这并不是因为领导者疯狂追求权力，而是由于混乱、缺乏重点和执行不力。&lt;/p&gt; 
&lt;p&gt;当没有明确的结构或层级时，结果不是自由和平等，而是「非正式的、不被承认的和不负责任的领导」，正如《无结构的暴政》中详细描述的那样。事实上，这些团队往往是混乱、脆弱和令人沮丧的。我知道！我也很生气！😭&lt;/p&gt; 
&lt;p&gt;这个论点并不一定能证明你的 CEO 是错的，但我认为他的证明标准比你的要高得多。「我不想让我的任何工程师停止写代码」并不是一个有效的论点。但我也觉得我还没有完全解决生产力的核心问题，所以我们再来讨论一下这个问题。&lt;/p&gt; 
&lt;h2&gt;更多代码行数 ≠ 更高生产力&lt;/h2&gt; 
&lt;p&gt;简要回顾一下：我们在讨论一个有约 40 名工程师的组织，分成 10 个小组，每组有 3-4 名工程师，每组都有一个技术负责人。你的 CEO 认为，如果有人停止全职编程，这个减速将是你们无法承受的。&lt;/p&gt; 
&lt;p&gt;也许吧。但根据我的经验，由经验丰富的技术经理领导的几个较大团队，将远远优于这些小团队。这差距很明显。而且，他们可以以更高效、可持续和人性化的方式完成工作，而不是这种拼命的死命赶工。&lt;/p&gt; 
&lt;p&gt;系统思维告诉我们原因！更少的团队，但规模更大，你会有更少的整体管理开销，且大大减少了团队内慢且昂贵的协调。你可以在团队内部实现丰富、密集的知识传递，从而实现更大面积的共享。每组有 7-9 名工程师，你可以建立一个真正的值班轮换，这意味着更少的英雄主义和更少的倦怠。你需要进行的协调可以更具战略性，减少战术性，更具前瞻性。&lt;/p&gt; 
&lt;p&gt;五个大团队是否能比十个小团队编写更多的代码行数，即使有五名工程师成为经理并停止编写代码？可能会，但谁在乎呢？你的客户根本不关心你写了多少代码行数。他们关心的是你是否在构建正确的东西，是否在解决对他们重要的问题。关键是推动业务前进，而不是单纯地编写代码。不要忘记，单纯地编写代码会产生额外的成本和负面效应。&lt;/p&gt; 
&lt;p&gt;决定你速度的是你是否把时间花在了正确的事情上。学会正确决定构建什么是每个组织都必须自己解决的问题，而且这是一项持续不断的工作。技术经理不会做所有的工作或做出所有的决策，但根据我的经验，他们对于确保工作顺利进行并且做得很好，绝对至关重要。正如我在上篇文章中写到的，技术经理是系统用来学习和改进的反馈循环的载体。&lt;/p&gt; 
&lt;h2&gt;管理人员是否会成为不必要的开销？&lt;/h2&gt; 
&lt;p&gt;当然有可能。管理的核心是协调团队之间的工作并提升团队的运作效率，所以任何减少协调需求的方式也会减少对管理的需求。如果你是一家小公司，或者你的团队成员都是非常资深且习惯合作的，那么你就不需要太多的协调。另一个重要因素是变化的速度；如果你的公司在快速增长或者人员流动频繁，或者面临很多时间压力或频繁的战略调整，你对管理人员的需求就会增加。但也有许多较小的组织在没有太多正式管理的情况下运作得很好。&lt;/p&gt; 
&lt;p&gt;我不喜欢「开销」这个词，因为 a) 这有点粗鲁，b) 称管理人员为「开销」的人通常是不尊重或不重视管理这门技艺的人。&lt;/p&gt; 
&lt;p&gt;但管理实际上确实是开销😅。许多其他的粘合工作也是如此！这些工作很重要，但它们本身并不能推动业务向前发展；我们应该尽量只做那些绝对必要的工作。粘合工作的天然属性使得它很容易扩散，吞噬所有可用的时间和资源（甚至更多）。&lt;/p&gt; 
&lt;p&gt;限制是好的。感觉资源不足是好的，这应该成为常态。管理很容易变得臃肿，管理人员可能非常不愿意承认这一点，因为他们从来没有感到压力或紧张减少。（事实上，情况可能恰恰相反；臃肿的管理层可能会为管理人员带来更多工作，而精简的组织结构可能会让他们反而感到压力更小。官僚主义往往会自我发育。特别是当管理层过于关注晋升和自我时。这也是确保管理不应仅为升职或统治的又一个充分理由）&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;管理也很像运营工作，当它做得好的时候，是看不见的。评估管理人员的工作可能非常困难，尤其是在短期内，而决定何时创建或偿还组织债务是一个完全不同的复杂问题，远远超出了这篇文章的讨论范围。&lt;/p&gt; 
&lt;p&gt;但是，是的，管理人员绝对可以成为不必要的开销。&lt;/p&gt; 
&lt;p&gt;然而，如果你有 40 个工程师都向一个副总裁汇报，而没有其他人专门负责人员、团队和组织相关的工作，那么我可以相当肯定地说，这对你来说目前不是一个问题。&lt;/p&gt; 
&lt;p&gt;&amp;lt;3&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;💡 更多资讯，请关注 Bytebase 公号：Bytebase&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/6148470/blog/11192713</link>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/11192713</guid>
            <pubDate>Mon, 27 May 2024 05:50:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>GNOME 与资助方 STF 之间出现问题，或影响项目发展</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上月，德国主权技术基金 Sovereign Tech Fund (STF) 曾&lt;a href=&quot;https://www.oschina.net/news/289626/sovereign-tech-fund-php-gnome&quot;&gt;宣布&lt;/a&gt;继续向 GNOME 进行投资。得益于 STF 的资助，GNOME 项目在最近几个月里也取得了许多显著的进步。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但其最近一周的状态更新内容&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthisweek.gnome.org%2Fposts%2F2024%2F05%2Ftwig-149%2F&quot; target=&quot;_blank&quot;&gt;指出&lt;/a&gt;，STF 与 GNOME 基金会之间出现了一些问题，具体未说明是什么，但很可能会影响项目后续的发展。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;作为 GNOME STF 计划的一部分，许多社区成员都在从事与基础架构相关的项目。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我们目前正面临着来自 GNOME 基金会方面的一个重大问题。我们希望它能在影响 STF 项目的协调之前得到解决，但如果不能解决，该项目部分内容的未来将充满不确定性。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;289&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-522a2bc8f2e308557345455cfe1544d95e3.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，STF 的资助已经为 GNOME 项目在一系列可访问性改进、门户网站增强等方面提供了助力。同时还推进了 GNOME 操作系统创建新安装程序的工作进展，名为「Setup」的新安装程序已经开始整合，但仍处于开发初期。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多详情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthisweek.gnome.org%2Fposts%2F2024%2F05%2Ftwig-149%2F&quot; target=&quot;_blank&quot;&gt; GNOME 查看官方公告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294405/gnome-stf</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294405/gnome-stf</guid>
            <pubDate>Mon, 27 May 2024 03:29:35 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>原来东子的「兄弟」是用 let 定义的「兄弟」</title>
            <description>媒体报道称，刘强东近日在高管会上直言：「凡是长期业绩不好，从来不拼搏的人，不是我的兄弟。」</description>
            <link>http://osc.cool/6SfbGh37</link>
            <guid isPermaLink="false">http://osc.cool/6SfbGh37</guid>
            <pubDate>Sun, 26 May 2024 14:10:00 GMT</pubDate>
        </item>
    </channel>
</rss>