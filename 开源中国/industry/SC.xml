<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Wed, 08 Jan 2025 02:37:24 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>完全由正则表达式驱动的国际象棋引擎</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Nicholas Carlini 这篇文章介绍了自己如何使用 84,688 个正则表达式构建了一个双层 MiniMax 国际象棋引擎。&lt;/p&gt; 
&lt;p&gt;具体而言，作者是先用正则表达式写了个 CPU 模拟器，然后在这个 cpu 模拟器上写了个编译器，然后用编译器写了个国际象棋引擎。引擎名为 &quot;Regex Chess&quot;，可以根据输入的棋盘状态走出一手合理（且不完全糟糕）的棋步。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnicholas.carlini.com%2Fwriting%2F2025%2Fregex-chess.html&quot; target=&quot;_blank&quot;&gt;https://nicholas.carlini.com/writing/2025/regex-chess.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9a32777032617fdf0bf1e64422c5901a970.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;一些技术细节：&lt;br&gt; &lt;strong&gt;1. 基于正则表达式的 CPU 模拟器：&lt;/strong&gt;&lt;br&gt; *作者首先设计了一个基于正则表达式的 CPU，它是一种无分支、条件执行、单指令多数据（SIMD）的架构。&lt;br&gt; *该 CPU 的状态由一个字符串表示，包含程序「栈」和所有变量。&lt;br&gt; *基本指令包括 push（入栈）、pop（出栈）、lookup（变量查找）和 assign_pop（变量赋值）等。&lt;br&gt; *条件执行通过修改状态字符串的开头（%%）来实现，从而控制哪些指令生效。&lt;br&gt; *SIMD 特性通过正则表达式的全局替换功能实现，可以同时处理多个棋盘状态。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. 编译器（宏汇编器）：&lt;/strong&gt;&lt;br&gt; *作者没有构建传统的编译器，而是采用了一种基于符号执行的方法，将 Python 风格的代码转换为正则表达式指令序列。&lt;br&gt; *符号执行通过跟踪变量操作来记录执行轨迹，而不是实际执行它们。&lt;br&gt; *条件语句通过创建分支并在后续合并来实现，每个分支对应一个条件路径。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3. 国际象棋引擎的实现：&lt;/strong&gt;&lt;br&gt; *引擎使用 FEN 字符串表示棋盘状态。&lt;br&gt; *通过并行处理，可以同时生成所有棋子的合法走法。例如，pawn_moves 函数可以并行计算所有兵的可能走法。&lt;br&gt; *利用并行处理，引擎可以模拟 MiniMax 算法，通过生成所有可能的走法并评估其分数来实现。&lt;br&gt; *引擎通过生成伪合法走法（可能会导致王被将军）然后排除这些走法来实现，这本质上是一种双层 MiniMax 搜索。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2194035935%2FP8tKfeMKp&quot; target=&quot;_blank&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;蚁工厂&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328754</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328754</guid>
            <pubDate>Wed, 08 Jan 2025 02:20:20 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>使用大模型编程的一些经验</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;David Crawshaw（Tailscale 公司的创始人）介绍了他用大型语言模型编程的一些经验。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c5bb1c26a8332e6fff1b52b9bcd76bcd007.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcrawshaw.io%2Fblog%2Fprogramming-with-llms&quot; target=&quot;_blank&quot;&gt;https://crawshaw.io/blog/programming-with-llms&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;作者在过去的一年里积极探索并使用大型语言模型进行编程，发现这种技术可以显著提高工作效率。他在编程中使用 LLMs 的方式主要有三种：自动补全、搜索和基于聊天的编程。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ef0b25363e5c6eb39d077d6becb7efdfb9b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;作者强调，LLMs 在编程中的应用不仅仅是提供代码片段，更是一种新的编程范式，需要程序员学习如何与之合作。他还提到，LLMs 在处理复杂的编程任务时，尤其是在编写测试和处理编译器错误方面，可以提供宝贵的帮助。&lt;/p&gt; 
&lt;p&gt;此外，作者还分享了他在使用 LLMs 时的一些具体实践，例如如何编写一个用于计算浮点数四分位数的保留样本器，并展示了如何通过 LLMs 生成和改进测试代码。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2194035935%2FP8rwvEeha&quot; target=&quot;_blank&quot;&gt;——蚁工厂&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328753</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328753</guid>
            <pubDate>Wed, 08 Jan 2025 02:17:20 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>中国信通院发布 MaaS 六大标准</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:left&quot;&gt;据中国信通院 CAICT 官方公众号&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2vFUJjfCmzJQwVX8SNKqig&quot; target=&quot;_blank&quot;&gt;消息&lt;/a&gt;，为解决 MaaS 平台服务质量参差不齐、选型困难等问题，信通院推出了 MaaS（Model as a service，模型即服务）系列标准。&lt;/p&gt; 
&lt;div style=&quot;text-align:left&quot;&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;中国信息通信研究院紧跟 MaaS 领域最新发展趋势，依托中国人工智能产业发展联盟于 2023 年成立 MaaS 工作组，联合产学研各界专家共同启动 MaaS 系列标准编制，经过一年多的持续努力，现正式发布 MaaS 系列标准。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;本系列标准围绕 MaaS 落地中遇到的问题，聚焦大模型定制调优、大模型服务部署和推理加速、模型管理、大模型应用开发等维度，提出能力要求，为大模型服务商和平台供应商提供能力建设参考，为应用方提供技术选型依据。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a03b7c6c1c4a08173f5e6ab9c76e63bfc79.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328750</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328750</guid>
            <pubDate>Wed, 08 Jan 2025 02:12:20 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Star 突破 10000 大关，稳定性和高性能是重中之重</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;background-color:#f6f6f6; color:#333333&quot;&gt;欢迎来到 2025 年！你的 2024 年终总结都写好了吗？记得发博客，私信【&lt;/span&gt;&lt;a href=&quot;https://my.oschina.net/u/3859945&quot;&gt;开源中国编辑肖滢&lt;/a&gt;&lt;span style=&quot;background-color:#f6f6f6; color:#333333&quot;&gt;】哦！&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#f6f6f6; color:#333333&quot;&gt;想看大家的年终总结？请看专栏：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/news/column?columnId=28&quot;&gt;【拜拜，2024！】&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0d512f08ec8739e46a7a7e0e33b19b3cbbb.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在图数据库的宇宙中，NebulaGraph 社区如同从星辰启航的探索者，我们的旅程贯穿了数据的银河。2024 年，我们从星出发，不断拓展技术的边界，连接了全球范围内对图数据库技术充满热情的开发者。新年在即，来一起回顾 NebulaGraph 社区 2024 年的探索之旅。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、内核特性&lt;/h1&gt; 
&lt;p&gt;一直以来，稳定性和高性能在 NebulaGraph 的产品规划中都是重中之重。2024 年的 NebulaGraph v3.8.0 在性能、稳定性、易用性等方面进行了优化，提升了整体的用户体验。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. 功能：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;现已支持 SINGLE SHORTEST PATH 功能。#5664&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;已实现 INNER JOIN 功能。#5664&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;ROUND() 函数现已支持舍入模式。#5680&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;2. 增强：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;性能：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;SHORTEST PATH 现已支持 LIMIT 下推，以提升性能。#5657&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化了部分逻辑，以避免 follower 宕机后对写性能的影响。#5673&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化了 meta service 对 session 的管理，以减少高并发场景下的延迟。#5762&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化了 LIMIT 下推规则以提升性能。#5883&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;易用性：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化了删除 graph space 的过程，减少了阻塞时间。#5754&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;稳定性：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化了 LEADER BALANCE 算法，以实现更均衡的负载分配。#5670&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;增加了对最大语句条数的限制，以增强系统的保护机制。#5790&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;3. 缺陷修复：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;DQL：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了多次执行 LOOKUP 语句时，结果不一致的问题。#5662&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 UNION ALL 报语法错误的问题。#5674&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在 SHORTEST PATH、ALL PATH、NOLOOP PATH 场景下 LIMIT 结果错误、崩溃等问题。#5679、#5699、#5787、#5789&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在设置 memory tracker 的情况下，多次重复执行 SHORTEST PATH 导致的崩溃问题。#5720&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 Filter 错误，避免 Graph Service 崩溃。#5740&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了多变量场景下执行失败的问题。#5734&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 MATCH SHORTEST PATH 不支持自环检测的问题。#5738&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在过滤条件永远不成立时，部分场景下的崩溃问题。#5740&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 ROUND 函数的崩溃问题。#5773&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 FIND PATH WITH PROP 在一跳查询时，结果错误的问题。#5759&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在执行 USE SPACE + 查询时，性能变慢的问题。#5793&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了 FIND NOLOOP PATH 未排除自环的问题。#5805&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;其他：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在执行 CLONE SPACE 时的错误。#3005、#5781&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在存在索引时，num_vertices_inserted 监控指标无数据的问题。#5756&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;修复了在进行查询和 Schema 的变更同时进行时可能出现崩溃的问题。#5855&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;‍二、周边工具&lt;/h1&gt; 
&lt;p&gt;周边工具的不断进步和创新为整个 &lt;strong&gt;NebulaGraph 生态系统带来了显著的提升&lt;/strong&gt;。以下是一些关键的更新和改进，它们不仅增强了 NebulaGraph 的功能，也为用户提供了更加灵活和强大的数据处理能力：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;数据导入支持了对源数据的过滤&lt;/p&gt; &lt;p&gt;具体 PR 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula-exchange%2Fpull%2F195&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula-exchange/pull/195&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;客户端数据扫描支持了 auth 验证&lt;/p&gt; &lt;p&gt;具体 PR 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula-java%2Fpull%2F586&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula-java/pull/586&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;客户端数据扫描支持了 docker 容器部署的 storaged 服务，允许配置容器内外地址的映射&lt;/p&gt; &lt;p&gt;具体 PR 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula-java%2Fpull%2F604&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula-java/pull/604&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;spark connector 中支持了 ngql 查询 path&lt;/p&gt; &lt;p&gt;具体 PR 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula-spark-connector%2Fpull%2F133&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula-spark-connector/pull/133&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h1_3&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、社区活动&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;线下活动&lt;/h2&gt; 
&lt;p&gt;共参与 PyCon&amp;nbsp;China、&amp;nbsp;GOGC、COSC&#39;Con &lt;strong&gt;3&amp;nbsp;场开发者峰会&lt;/strong&gt;，以开源集市/议题分享的形式与开发者们面对面交流，并与 AdventureX, CAMEL AI 共同举办 &lt;strong&gt;2 场 &amp;nbsp;Hackathon&lt;/strong&gt;, 举办 &lt;strong&gt;4 场线下 nMeetup&lt;/strong&gt;.（🔍点击图片可查看活动详情）‍‍‍‍&lt;/p&gt; 
&lt;p&gt;首发站选择厦门，与陪伴 NebulaGraph 走过多个版本迭代，积极承担社区布道责任的 committer——大叶老师双向奔赴，以「图数据库+AI」为主题，与大家分享了 AI 的最新实践与 GraphRAG 的创新解决方案，并为大叶老师颁发「厦门城市站站长」聘书。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247511756%26idx%3D1%26sn%3D9d618dabfe0c56c8efb4c891a802de43%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e1aa5d39e43cfce2406c541fe049a29a66f.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;北京站 6 个，以 GraphRAG 为主题的 topic + 1 个 NebulaGraph 的落地实践，成功吸引了与 140 多位行业伙伴们参与，共同探讨 GraphRAG &amp;amp; AI 的最新发展和应用实践，让大家看到了 GraphRAG 与人工智能技术融合的巨大潜力。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247512664%26idx%3D1%26sn%3D097d4eed55eeae7d3b4d875ec1954106%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ffdb2f1299402b5a96cb31fbab85126d1d9.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;上海站与携程集团联合主办，携程集团云原生技术总监周昕毅先生充分肯定了 NebulaGraph 在携程集团的高效应用。「高校开发者如何参与开源」的圆桌会议，吸引了众多高校开发者前往，更有来自上海理工大学附属中学高二学生现场分享自己的开源经验。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247513743%26idx%3D1%26sn%3D463e3073cd2b28c401a6fbc6f693c5d3%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f143bd30ab96a8f6c1f6a49f84475b7933e.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;收官站与 NebulaGraph 最早用户之一的奇富科技联动，奇富科技风控平台技术负责人李权老师分享了四年来选择 NebulaGraph 作为金融风控体系图数据库解决方案的实践与收益。精彩的议题分享、引发大家热烈讨论的「AI 如何影响对开发者和开源社区」圆桌，为 NebulaGraph 2024 之行画下完美句号。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247514629%26idx%3D1%26sn%3Db24f9b7adcbb4ed15a03600ee914cce2%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-482bec0f6f53e96e44a364c66ced9c98138.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;开源之夏&lt;/h2&gt; 
&lt;p&gt;NebulaGraph 一直重视高校开发者的培养，期待与更多高校开发者同行。在 2024 年开源之夏中，&lt;strong&gt;NebulaGraph 社区提交了 5 个项目&lt;/strong&gt;供来自全球的高校开发者进行选择，&lt;strong&gt;顺利结项 4 个，1 名学生获得「最快进步奖」。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1. 复旦大学博士生张志杰，使 LOOKUP 语法支持 UPDATE&lt;/p&gt; 
&lt;p&gt;具体 pr 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula%2Fpull%2F5953&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula/pull/5953&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;2. 华中科技大学研究生陈昱辰，重写 NebulaGraph 客户端，为 OpenDAL 支持 NebulaGraph，具体 pr 参见：&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnebula-contrib%2Frust-nebula&quot; target=&quot;_blank&quot;&gt;https://github.com/nebula-contrib/rust-nebula&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;‍‍‍https://github.com/apache/opendal/pull/5116 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fopendal%2Fpull%2F5147&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/opendal/pull/5147&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;3. 东南大学硕士徐明辉，使 NebulaGraph 支持 List/Set 数据类型的类型创建以及增删改查和其他相关 GQL 语句的适配&lt;/p&gt; 
&lt;p&gt;具体 pr 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula%2Fpull%2F5914&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula/pull/5914&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;4. 郑州航空工业管理学院刘晓阳，基于 NgBatis, 实现从实体对象出发完成数据直查，并荣获「最快进步奖」&lt;/p&gt; 
&lt;p&gt;具体 pr 参见：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnebula-contrib%2Fngbatis%2Fpull%2F319&quot; target=&quot;_blank&quot;&gt;https://github.com/nebula-contrib/ngbatis/pull/319&lt;/a&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;精彩活动&lt;/h2&gt; 
&lt;p&gt;除上述所提，我们还精心策划了一系列社区活动，丰富大家的开源之旅。（🔍点击图片可查看活动详情）&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247510083%26idx%3D1%26sn%3De9213f0ac60ec92624b1a0b7121d495b%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0ec20e0f766fbe9d2a6860e5af5244dc32e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247510884%26idx%3D1%26sn%3D18b634782dc560f29a22efdf644ef898%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a87f6d3cb4a103d5cfbf268a5d53bec52b9.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247511607%26idx%3D1%26sn%3D9c51012e5e74e2a5c8cfe6661c805837%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bd0b64a2bcbb8679075440e39b2679578fc.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247511717%26idx%3D1%26sn%3Da556d4c3cc67265281d07c87ee2fba64%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7c99b883b53403c231cdbb8a016e5640df5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247511842%26idx%3D1%26sn%3D2f80d27b57225ddc3858af3dcf52e926%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-66fd505a9795de748632977cdccfe1c7a80.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247513162%26idx%3D1%26sn%3D15ba5536bf6a0d9dbfbf09626a5c9f08%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ced2d9e242b11867de3b8ef5c0558c0dd57.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg4OTg0MzY0Mw%3D%3D%26mid%3D2247514743%26idx%3D1%26sn%3Dc7f175cfb5a7599268f8539591519f24%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-181e6149d683c7695fd0094f2dfa3006a8d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;在这一年里，有许多难忘的瞬间。&lt;/p&gt; 
&lt;p&gt;我们共同见证了 NebulaGraph star 数量的飞跃，突破了具有里程碑意义的 &lt;strong&gt;10,000&lt;/strong&gt; 大关 (即将突破 11000)，也迎来了 &lt;strong&gt;NebulaGraph 开源五周年&lt;/strong&gt;，还通过 nMeetup 与许多开发者第一次线下会面，与一直活跃在社区中的大叶老师、秋梵、阿旺、周伟诚等朋友们面对面交流……这些温暖的瞬间让社区的联系更加紧密。&lt;/p&gt; 
&lt;p&gt;2024 年，感谢每一位社区成员的辛勤付出和热情参与，让 NebulaGraph 社区充满活力，充满可能。2025 年，让我们共同期待，共同创造，让 NebulaGraph 的开源之旅，因每一个「你」而更加精彩！&lt;/p&gt; 
&lt;p&gt;✦&lt;/p&gt; 
&lt;p&gt;如果你觉得 NebulaGraph 能帮到你，或者你只是单纯支持开源精神，可以在 GitHub 上为 NebulaGraph 点个 Star！每一个 Star 都是对我们的支持和鼓励✨&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvesoft-inc%2Fnebula&quot; target=&quot;_blank&quot;&gt;https://github.com/vesoft-inc/nebula&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;✦&lt;/p&gt; 
&lt;p&gt;✦&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4169309/blog/17101384</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4169309/blog/17101384</guid>
            <pubDate>Mon, 06 Jan 2025 11:08:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>开源日报 | TIOBE 年度编程语言公布；零一万物辟谣「被阿里收购」；由正则表达式驱动的国际象棋引擎；算力基础设施建设将加快</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2025.1.7&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要闻&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#245bdb&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/328650/tiobe-index-202501&quot;&gt;TIOBE 2024 年度编程语言：Python&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;TIOBE 宣布 2024 年度编程语言花落 Python，该语言在 2024 年的涨幅高达了 9.3%；远远领先于其竞争对手：Java +2.3%、JavaScript +1.4% 和 Go +1.2%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;TIOBE CEO&amp;nbsp;Paul Jansen&amp;nbsp;点评道，「如今 Python 无处不在，它是许多领域无可争议的默认语言。它甚至可能成为 TIOBE 指数中排名最高的语言。Python 唯一的严重缺点（因此为竞争留下了空间）是性能不足，并且大多数错误发生在运行时。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c41c40277d73f062e002a0c9c5590716123.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/328590&quot;&gt;零一万物辟谣「被阿里收购」传闻&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对网传 「阿里收购零一万物」 一事，零一万物发文辟谣称 「相关传闻不实」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FensXY3qh9tVHtdyDxQ1AQQ&quot; target=&quot;_blank&quot;&gt;公告&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;指出，零一万物与阿里云于 1 月 2 日联合宣布启动 「产业大模型实验室」。进入新的一年，双方的深度合作框架顺利落地，正积极推进相关的实施方案。 针对传言零一万物将被收购、经营问题等不实言论属于恶性中伤，公司予以否认。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;李开复在朋友圈辟谣称：「2024 年，零一万物的确认收入一个多亿 (订单更多)，2025 年会数倍增长。不知为什么会有这样的谣言散播。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;348&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c56b259e2ea9503577784d2dd24efad4a3a.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#245bdb&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/328679&quot;&gt;智元机器人完成 1000 台通用具身机器人下线&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;智元机器人官宣，其量产的第 1000 台通用具身机器人于 2025 年 1 月 6 日正式下线，其中双足人形机器人远征 A2 / 灵犀 X1 为 731 套，轮式通用机器人远征 A2-/A2-W 为 269 套。目前，这些机器人正在陆续交付客户中。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据介绍，智元机器人 2023 年 2 月成立，同年 8 月打造出人形机器人原型机；2024 年 8 月，针对交互服务、柔性制造、科研教育等多元场景，推出 5 款通用机器人，并在 12 月开源了全球首个百万真机数据集。&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/328595&quot;&gt;腾讯回应被列入美国防部名单：是个错误&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;1 月 7 日早间，针对美国国防部将腾讯公司列入中国军工公司名单（根据美国法律正式规定为 「第 1260H 条清单」），腾讯回应称，&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;strong&gt;「腾讯被列入这份名单显然是一个错误，我们并不是军工企业或军工供应商。不同于出口管制或其他，这份清单对我们的业务没有影响。尽管如此，我们仍将同美国相关部门共同解决误会。」&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;美国国防部在当地时间周一表示，已将包括腾讯、宁德时代在内的中国科技巨头列入名单。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0107/103945_a56e_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2vFUJjfCmzJQwVX8SNKqig&quot; target=&quot;_blank&quot;&gt;中国信通院发布 MaaS 六大标准&lt;/a&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;p&gt;据中国信通院 CAICT 官方公众号消息，为解决 MaaS 平台服务质量参差不齐、选型困难等问题，信通院推出了 MaaS（Model as a service，模型即服务）系列标准。&lt;/p&gt; 
  &lt;p&gt;中国信息通信研究院紧跟 MaaS 领域最新发展趋势，依托中国人工智能产业发展联盟于 2023 年成立 MaaS 工作组，联合产学研各界专家共同启动 MaaS 系列标准编制，经过一年多的持续努力，现正式发布 MaaS 系列标准。本系列标准围绕 MaaS 落地中遇到的问题，聚焦大模型定制调优、大模型服务部署和推理加速、模型管理、大模型应用开发等维度，提出能力要求，为大模型服务商和平台供应商提供能力建设参考，为应用方提供技术选型依据。&lt;/p&gt; 
  &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a03b7c6c1c4a08173f5e6ab9c76e63bfc79.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日观察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2169039837%2FP8tbbpfWA&quot; target=&quot;_blank&quot;&gt;老黄刚刚把牙膏剂爆了！出了个 128G 内存的桌面计算机 NVIDIA DIGITS&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;老黄刚刚把牙膏剂爆了！出了个 128G 内存的桌面计算机 NVIDIA DIGITS！没错，可以拿在手上的超级 AI 计算机。大模型可以玩到爽了！甚至是不是可以自己炼大模型了！&lt;/p&gt; 
  &lt;p&gt;但是，朋友们但是来了哦，注意内存下面的小字，这是 LPDDR5X，不是 GDDR6，更不是 HBM2，跟苹果用的内存其实是一样的。虽然高达 128G，但是根据 NVIDIA Grace CPU 的 datasheet，Grace CPU 的内存带宽只有 512GB/s...... 所以跟 Apple MacBook Pro M4 Max 差不多... （70b-4bit 大模型大概 13token/s 的速度）&lt;/p&gt; 
  &lt;p&gt;虽然现在 NVIDIA 还没有放出 DIGITS 的具体数据，还是希望内存带宽能高一些....&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- 微博&lt;strong&gt; karminski-牙医&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2194035935%2FP8rwvEeha&quot; target=&quot;_blank&quot;&gt;使用大模型编程的一些经验&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt;
    David Crawshaw（Tailscale 公司的创始人）介绍了他用大型语言模型编程的一些经验
    &lt;br&gt; crawshaw.io/blog/programming-with-llms
   &lt;/div&gt; 
   &lt;div&gt;
    &lt;br&gt; 作者在过去的一年里积极探索并使用大型语言模型进行编程，发现这种技术可以显著提高工作效率。他在编程中使用 LLMs 的方式主要有三种：自动补全、搜索和基于聊天的编程。
   &lt;/div&gt; 
   &lt;div&gt;
    &amp;nbsp;
   &lt;/div&gt; 
   &lt;div&gt;
    作者强调，LLMs 在编程中的应用不仅仅是提供代码片段，更是一种新的编程范式，需要程序员学习如何与之合作。他还提到，LLMs 在处理复杂的编程任务时，尤其是在编写测试和处理编译器错误方面，可以提供宝贵的帮助。此外，作者还分享了他在使用 LLMs 时的一些具体实践，例如如何编写一个用于计算浮点数四分位数的保留样本器，并展示了如何通过 LLMs 生成和改进测试代码。
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;div style=&quot;text-align:right&quot;&gt;
    &lt;span style=&quot;color:#000000&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;蚁工厂&lt;/strong&gt;&lt;/span&gt;
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6105753431%2FP8keGhi3y&quot; target=&quot;_blank&quot;&gt;RAG 基础知识到高级实现的开源指南&lt;/a&gt;&lt;/h4&gt; 
   &lt;p&gt;指南名为 bRAG-langchain，它能帮你从基础到进阶，一步步搭建 Retrieval-Augmented Generation（RAG，检索增强生成）系统。&lt;/p&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;p&gt;该教程是一个系列，里面不仅有实战例子，还涉及了很多前沿技术，比如 CRAG 和多向量检索，特别适合那些想深入了解 RAG 的开发者。&lt;/p&gt; 
     &lt;p&gt;而且啊，教程还是用 Jupyter Notebook 实现的，每个部分都有详细的讲解和代码示例，从环境配置、数据加载，到向量存储和检索优化，基本上能覆盖你想要实现的各种功能。&lt;/p&gt; 
     &lt;p&gt;最重要的是，它还提供了一个可自定义的聊天机器人模板，让你可以轻松创建属于自己的 RAG 应用。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- 微博&lt;strong&gt; 量子位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
   &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2194035935%2FP8tKfeMKp&quot; target=&quot;_blank&quot;&gt;完全由正则表达式驱动的国际象棋引擎&lt;/a&gt;&lt;/h4&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;p&gt;Nicholas Carlini 这篇文章介绍了自己如何使用 84,688 个正则表达式构建了一个双层 MiniMax 国际象棋引擎。具体而言，作者是先用正则表达式写了个 CPU 模拟器，然后在这个 cpu 模拟器上写了个编译器，然后用编译器写了个国际象棋引擎。引擎名为 &quot;Regex Chess&quot;，可以根据输入的棋盘状态走出一手合理（且不完全糟糕）的棋步。&lt;/p&gt; 
      &lt;p&gt;nicholas.carlini.com/writing/2025/regex-chess.html&lt;/p&gt; 
     &lt;/div&gt; 
     &lt;div&gt;
      &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9a32777032617fdf0bf1e64422c5901a970.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;蚁工厂&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观察&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gov.cn%2Fzhengce%2F202501%2Fcontent_6996612.htm&quot; target=&quot;_blank&quot;&gt;新一轮数字基础设施布局开启&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;国家发展改革委、国家数据局、工业和信息化部三部门近日联合印发《国家数据基础设施建设指引》（以下简称《指引》），提出到 2029 年，国家数据基础设施建设和运营体制机制基本建立。这标志着中国开启新一轮以数据为中心的数字基础设施布局。&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;人民日报海外版&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.ce.cn%2Fcysc%2Ftech%2Fgd2012%2F202501%2F07%2Ft20250107_39258519.shtml&quot; target=&quot;_blank&quot;&gt;「人工智能+」应当怎么加&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;把握「人工智能+」带来的机遇，需要相关部门在战略规划、科研投资、人才培养等方面更加重视前瞻布局，而成效则主要体现在领军企业、新兴企业是否能够发挥主导作用。同时，确保人工智能安全、可靠、可控，有利于人类文明进步，是人工智能发展必须解决的重要课题。因此，必须始终坚持以人为本、科技向善，把人机协调贯穿始终，促进人类智能、离身智能、具身智能相互协调。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;经济日报&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1820482074629154184%26wfr%3Dspider%26for%3Dpc&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#2980b9&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;车企驶入「人形机器人」赛道的背后&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;细细想来，从汽车到机器人，有着不少共通之处。业界曾用「轮子上的机器人」形容不断进阶的汽车。不论是无人驾驶，还是座舱内智能互动，今天，搭载着人工智能、视觉传感、大模型等技术的汽车，越来越像陪伴人类出行的智能机器人。同样，在人形机器人的研制中，高性能电池、轻量化材料，以及目标识别、路径规划等算法，诸多软硬件都可以从智能网联汽车中得到借鉴。车企造机器人既有着技术迁移的可能性，机器人进入汽车工厂「实训」，也便于降低研发成本、加快应用示范。&lt;/span&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt;&amp;nbsp;新华社&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Funion.china.com.cn%2Fcmdt%2Ftxt%2F2025-01%2F07%2Fcontent_43006031.html&quot; target=&quot;_blank&quot;&gt;算力基础设施建设将加快&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#333333&quot;&gt;杜广达表示，我国将加快推进人工智能与互联网融合发展，引导互联网企业结合自身优势，挖掘算力、算法、数据潜力，融入并壮大人工智能产业，培育发展新质生产力，为新型工业化提供有力支撑。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt; 中国证券报&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxueqiu.com%2F3305476551%2F319597628&quot; target=&quot;_blank&quot;&gt;美股新财路！争先恐后和英伟达搞合作，股价立即腾飞！微软 800 亿美元搞 AI&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#262626&quot;&gt;这给我们提供了一种新的思路——关注那些和科技巨头如英伟达有深度合作的公司。它们通过技术合作，不仅在行业中获得了技术和市场的双重加持，还能够大幅提升未来的成长潜力。从这些公司身上，我们看到了技术创新对股价的直接推动，也看到了资本市场对未来增长的强烈预期。&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;/span&gt;&lt;span style=&quot;color:#252525&quot;&gt;&lt;strong&gt;美股大数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1820549822122170148%26wfr%3Dspider%26for%3Dpc&quot; target=&quot;_blank&quot;&gt;粉丝几千万的雷军，为什么从来不翻车？&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt;
    在这个自媒体蓬勃发展的时代，应该说，雷军给其他企业家树立了一个好榜样。企业家的职能，就是为消费者提供好的产品，随意跨出这一职能，恐怕将来都是要翻车的。
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt;&amp;nbsp;功夫财经&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;开源项目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkamiyaa%2Fjoshuto&quot; target=&quot;_blank&quot;&gt;kamiyaa/joshuto&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;275&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0315/103323_Sf0W_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fkamiyaa%2Fjoshuto&quot; target=&quot;_blank&quot;&gt;https://github.com/kamiyaa/joshuto&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;joshuto 是一个用 Rust 编写的类似 ranger 的终端文件管理器。&lt;/p&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://my.oschina.net/meituantech/blog/17091011&quot; target=&quot;_blank&quot;&gt;鸿蒙应用签名实操及机制探究&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;本文对鸿蒙公开资料进行了深入分析和解读，梳理了鸿蒙单框架应用的签名机制，拆解每一步的实操过程和背后的实现原理，并对源码分析整理签名的校验机制。从中管中窥豹，探究鸿蒙系统的安全设计思路，希望能给从事鸿蒙研发的同学提供一些借鉴。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;210&quot; src=&quot;https://oscimg.oschina.net/oscnet//7d5802721dcd02ceddbe94f6656f99c8.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;开源之声&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FCfPQTrzaUsD3qxPsi0dc3g&quot; target=&quot;_blank&quot;&gt;Nodejs 的竞争者 Bun 又整活了，Bun.s3 预告&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：不实用，明天来个 s4，这种应用级别的东西交给库，框架来做就好，没必要内置&lt;/span&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：热知识：s3&amp;nbsp;=&amp;nbsp;Simple&amp;nbsp;Storage&amp;nbsp;Service&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：我觉得作为一个框架，它不应该去内置这个东西，取而代之的应该是做@bun/s3 这样的插件，你无法预知 oss 供应商会做出什么决定，好像 bun 还是别的框架之前想要内置 npm 镜像地址，没有人知道什么时候镜像会被 ban 掉，徒增维护成本&lt;/span&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 4：应该是作为一个运行时，但是 deno 也这么干了，人家也得恰饭不是吗&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 5：PHP 才是最好的语言&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 6：通过 bun 读写对象存储跟挂载到本地是一个概念吗&lt;img alt=&quot;[疑问]&quot; src=&quot;https://res.wx.qq.com/mpres/zh_CN/htmledition/comm_htmledition/images/pic/common/pic_blank.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;？本地还是 rclone 比较方便&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 7：10 点半还在加班？你的工作时长应该排在最后面&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 8：技术是层出不群，越来越多，企业还要求你样样精通&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 9：Pai&amp;nbsp;Yellow&amp;nbsp;Pian 是世界上最好的语言，不过最好还是不要内置这种东西，一旦供应商上调整某个接口，那就完犊子了&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 10：加进去不难，以后想删掉才难&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 11：说实话，bun&amp;nbsp;已经脱离当初的初衷了，当初说有了&amp;nbsp;bun.lockb&amp;nbsp;可以删除&amp;nbsp;node&amp;nbsp;modules&amp;nbsp;，但是我删除后跑了&amp;nbsp;vite&amp;nbsp;项目直接报&amp;nbsp;vite&amp;nbsp;command&amp;nbsp;not&amp;nbsp;found&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-xOV7aB8cMrxZ4YShbOWlQ&quot; target=&quot;_blank&quot;&gt;Deepseek 团队核心成员揭秘&lt;span&gt;——&lt;/span&gt;清北应届生撑起一片天&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：本地部署使用了，效果一般&lt;/span&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：你哪儿来的 352 块 GPU 本地部署？&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：我用的在线的，感觉还是挺强的&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 4：这种大模型没库还不训练的话本地部署都不怎么好吧&lt;/span&gt; 
      &lt;ul&gt; 
       &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 5：隔壁 qwen2.5&amp;nbsp;70b 就很好&lt;/span&gt;&lt;/li&gt; 
      &lt;/ul&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 6：数学证明写的跟 4o&amp;nbsp;mini&amp;nbsp;差不多水平，没啥推理能力&lt;/span&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 7：逻辑推理能力还可以，我用了一道逻辑推理题，gpt4o，三次答案都是错的。deepseek 都是对的，虽然推理过程比较繁琐。&lt;/span&gt; 
      &lt;ul&gt; 
       &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 8：一道题没有统计意义，我做开发大量用 deepseek 和 gpt 还是 claude，国产垫底，但在国内也是矮子里面拔将军&lt;/span&gt;&lt;/li&gt; 
      &lt;/ul&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2024/0912/150800_DfGR_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328692</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328692</guid>
            <pubDate>Mon, 06 Jan 2025 10:53:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>5000 Star，10w 下载量，这是我交出的开源答卷</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;欢迎来到 2025 年！你的 2024 年终总结都写好了吗？记得发博客，私信【&lt;a href=&quot;https://my.oschina.net/u/3859945&quot;&gt;开源中国编辑肖滢&lt;/a&gt;】哦！&lt;br&gt; 想看大家的年终总结？请看专栏：&lt;a href=&quot;https://www.oschina.net/news/column?columnId=28&quot;&gt;【拜拜，2024！】&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;你好，我是 Kagol，个人公众号：&lt;/span&gt;&lt;code&gt;&lt;span&gt;前端开源星球&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;2024 年，我做前端开发工作满&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521209%26idx%3D1%26sn%3D2a22f392854fa1543304713c4ef579e6%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;10 年&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;啦！&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;这 10 年我一直在开发前线，做过电商项目、广告平台、项目管理系统等业务，目前主要专注于前端组件库建设和开源社区运营，OpenTiny 开源社区运营，Fluent Editor 和 Vue DevUI 作者，前端开源星球公众号运营者，热爱开源和写作，活跃于掘金、知乎、B 站等社区，发表 100 多篇技术文章，有 4 个 Star 超千的开源项目。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;我的 GitHub 主页（欢迎 Follow）：https://github.com/kagol&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1706&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-390448a5d68b34734b97ea2e3a69f88276f.webp&quot; width=&quot;2594&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;2024 年的三个关键字：&lt;/span&gt;&lt;code&gt;&lt;span&gt;开源运营&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;创作分享&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;健康生活&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;关键字 1：开源运营&lt;/span&gt;&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;我在 2014 年就开始在 GitHub 创建开源项目，从早期的使用开源、做一些玩具项目，到后面的参与开源，给开源项目提交 Issue、提交 PR，真正做开源运营是在 2020 年，到现在也有 5 年的经验了，先后运营过 10 多个开源项目，其中有 4 个 Star 数超过 1000。也做过多次开源社区运营的分享，写过几篇开源运营的经验文章。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;从 2023 年开始负责 OpenTiny 开源社区运营，打造了 TinyVue、TinyEngine 两款明星项目，其中 TinyEngine Star 数超过 2000，TinyVue 的下载量超过 8W，吸引了 100 多位社区共建者。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;截止到 2024 年 12 月 29 日，&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;OpenTiny&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;开源社区累计 Star 数突破&amp;nbsp;&lt;/span&gt;&lt;code&gt;&lt;span&gt;5000&lt;/span&gt;&lt;/code&gt;&lt;span&gt;🎉，陆续孵化了&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyVue&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyEngine&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyPro&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyCharts&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;Fluent Editor&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;等多个开源项目。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1164&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e5b1d5c2005c9e04cfca99b536a6e9cf779.webp&quot; width=&quot;1774&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyCharts&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;是今年新开源的图表组件库，除了支持 ECharts 基础图表，还增加了&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;关系图引擎&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，实现了跨框架节点、父子节点展开、拓扑布局、局部刷新等丰富的特性。关系图引擎主要用于实现复杂的关系图表，比如：思维导图、网格图、环形图、弧线图等。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;Fluent Editor&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;是今年新开源的富文本编辑器，基于 Quill 2.0，在 Quill 基础上扩展了表格、图片、文件上传、@提醒等丰富的模块和格式，功能强大、开箱即用。除了富文本常用功能之外，我们还支持截屏、可编辑公式、标题列表等 Fluent Editor 特有但实用的特性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1152&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3b164872cd6136e81b547ae11a0b63cb297.webp&quot; width=&quot;2458&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;除了新开源项目，我们也对 OpenTiny 的其他项目进行了大量的更新。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyVue&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;组件库提供了一套更符合现代审美的 UI 设计规范，并增加了 MindMap、FluentEditor、Sticky、Statistic、TreeSelect、VirtualScrollBox 等多个新组件，对文档也做了升级优化。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyEngine&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;低代码引擎发布 v2.0 版本，优化开发体验的包引入与 CLI 工具，开创性的「洛书架构」，提供灵活的布局、画布切换，支持第三方组件库和任意语言出码等丰富的特性。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;TinyPro Vue&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;后台管理模板发布 v1.1.0 版本，增加页签模式、多级菜单、NestJS 后端、细粒度权限管理和 Webpack/Vite/Rspack/Farm 多种构建工具支持等丰富的特性。由于增加了系统管理功能，之前配置路由和菜单需要修改代码，现在只需要在页面上点点点就能创建，非常便捷。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;除了 OpenTiny 自身项目的持续更新和打磨，我们还与&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;common-intellisense&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;合作，通过 VSCode 插件方式扩展了 TinyVue 组件库的组件 API 提示功能，大大提升了 TinyVue 组件的使用体验，降低了小白用户的上手成本。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521537%26idx%3D1%26sn%3D6a824c2adfe4d355bd4cd3f34aee57bc%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;优化永不止步：TinyVue v3.20.0 正式发布，更美观的官网 UI，更友好的文档搜索&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODA3OTY5Ng%3D%3D%26mid%3D2247498089%26idx%3D1%26sn%3Dae9bb60ccf28d0946c20aa2acf6a91ee%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;TinyEngine 低代码引擎 2.0 新特性介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521333%26idx%3D1%26sn%3Df699935c1a3a684f5129bc559db31046%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;OpenTiny HUICharts 正式开源发布，一个简单、易上手的图表组件库&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521363%26idx%3D1%26sn%3D1d9ac1d8fd757848553e6d6a628a4696%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Fluent Editor：一个基于 Quill 2.0 的富文本编辑器，功能强大、开箱即用！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521514%26idx%3D1%26sn%3Da9d7979a369f8e940a17b4f2a2248f6e%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;TinyPro Vue v1.1.0 正式发布：增加细粒度权限管理、页签模式、多级菜单&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521286%26idx%3D1%26sn%3D951866d9d782a92e7de73a134d30edd9%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;common-intellisense：让你的 TinyVue 组件书写体验如德芙般丝滑！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;开源数据（截止到 2024 年 12 月 29 日）：&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing=&quot;0&quot; style=&quot;-webkit-tap-highlight-color:transparent; border-collapse:collapse; border-color:inherit; border-spacing:0px; border-style:solid; border-width:0px; box-sizing:border-box; display:table; margin:0px 0px 10px; max-width:100%; outline:0px; overflow-wrap:break-word !important; padding:0px; text-indent:0px; width:661px&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;指标&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;TinyVue&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;TinyEngine&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;TinyCharts&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;FluentEditor&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;PV/UV&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;6768 / 1079&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;5808 / 659&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;348 / 67&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;2747 / 456&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Star&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt;&lt;code&gt;&lt;span&gt;1784&lt;/span&gt;&lt;/code&gt;&lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt;&lt;code&gt;&lt;span&gt;2099&lt;/span&gt;&lt;/code&gt;&lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;73&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;187&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Fork&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;273&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;318&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;24&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;29&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Clone&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;207 / 44&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;154 / 27&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;5 / 5&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;205 / 46&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Download&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt;&lt;code&gt;&lt;span&gt;87277&lt;/span&gt;&lt;/code&gt;&lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;984&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;3682&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt;&lt;code&gt;&lt;span&gt;19875&lt;/span&gt;&lt;/code&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Issue&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;165 / 388&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;55 / 194&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;2 / 0&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;20 / 39&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;PR&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;13 / 2121&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;36 / 600&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;1 / 104&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;3 / 111&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;Contributor&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;79&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;32&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;11&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style=&quot;border-color:#dfdfdf; border-style:solid; border-width:1px; text-align:left; vertical-align:top&quot;&gt; &lt;p&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;关键字 2：创作分享&lt;/span&gt;&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;做开源项目和在公司开发项目有很多不同，其中有一个很大的区别就是在公司开发项目，我们是不用操心运营的事情的，项目开发出来就行，有没有人用，谁在用，我们是不用关注的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;做开源项目，我们不仅要负责项目开发，还需要考虑开源项目的运营推广，毕竟如果只是我们自己用，就没必要开源了，开源还是希望有更多人用起来，有更多人参与进来一起共建的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;为了把 OpenTiny 的开源项目推广出去，今年我也参加了不少大会，认识了开源大佬，自己也做了一些演讲分享和直播，写了一些文章、录了几个视频教程。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;印象最深的就是和 TinyVue 的小伙伴一起参加 VueConf 大会，见到了偶像尤大，还拍了合影、一起参加了晚宴。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;另外就是参加体验技术大会，我自己做了一次线下分享：《创新引领，设计赋能，焕然一新的 TinyVue 组件库》，和小夕、狼叔等多位大佬面基和交流。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2000&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7e8291406fe2242a04b20d433c54ea3d114.webp&quot; width=&quot;3000&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;并且还在 HDC 大会、OpenTiny 茶话会跟我们 OpenTiny 的贡献者、用户朋友们一起面基和交流，了解大家在使用和参与 OpenTiny 过程中的痛点，吸纳大家给我们提的建议，这不仅增进了我们之间的友谊，我为后续进一步的合作打下坚实的基础，也希望后续有更多机会与大家面对面交流和碰撞。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;要把开源项目推广出去，一个最简单有效的方式就是写篇文章介绍下你的项目，它是做什么的，有什么优势，怎么快速使用等，今年一共发布了 30 篇技术和推广文章，主要发布在掘金和公众号，掘金大概有 6.5W 阅读，公众号大概 4.8W 阅读。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;866&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-755ed5e090f8182ce67ef1345e5ae0081a1.webp&quot; width=&quot;3102&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;除了文章，今年也尝试录了几个视频，发布到&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;B 站&lt;/span&gt;&lt;/span&gt;&lt;span&gt;了，欢迎大家关注，后续也会持续更新的。目前主要还是录制一些开源项目的使用教程，方便大家快速上手，后续大家有其他想看的技术内容，也可以在评论区留言。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;450&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-12b6ec03e72ce13f1e85a51dc9e119c36f6.webp&quot; width=&quot;1488&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;演讲分享和直播：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;趣谈前端专访：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU2Mzk1NzkwOA%3D%3D%26mid%3D2247497995%26idx%3D1%26sn%3D547af370c4db59c0413a98d3f33b7eb3%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;专访华为 OpenTiny 开源项目负责人 Kagol&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;CSDN 直播：&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzkyNjY0MDY1Ng%3D%3D%26mid%3D2247485126%26idx%3D1%26sn%3D37e2429c63071078e333758160183d4e%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;《我的开源社区运营经验》&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;Vue ShenZhen Meetup：&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;《OpenTiny 跨框架组件库实现原理解析》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;三层部门体验改进分享：《组件设计的艺术：易用和灵活的平衡》&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;体验技术大会线下分享：《创新引领，设计赋能，焕然一新的 TinyVue 组件库》&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;CCF 开源创新大赛直播&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;文章：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;12k🔖123👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521186%26idx%3D1%26sn%3De1cec32edc7de006921ef9663d236a13%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;重回铁王座！时隔 5 年！Quill 2.0 终于发布啦&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;8k🔖166👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521209%26idx%3D1%26sn%3D2a22f392854fa1543304713c4ef579e6%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;我可以写代码写到退休吗？记录我的 10 年前端技术之旅&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;手把手带你开发一个易用又灵活的 Carousel 组件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;4.6k🔖36👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521318%26idx%3D1%26sn%3Df324954ad007b5fda53adab1014edb1c%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Vue Vine：带给你全新的 Vue 书写体验！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;6.8k🔖103👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521379%26idx%3D1%26sn%3Dec3a5546f724d8fc39f02447b9772175%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Monorepo：让你的项目脱胎换骨，既能代码复用，又能独立部署！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;3.2k🔖35👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521363%26idx%3D1%26sn%3D1d9ac1d8fd757848553e6d6a628a4696%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Fluent Editor：一个基于 Quill 2.0 的富文本编辑器，功能强大、开箱即用！&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;深入浅出 Quill 富文本系列文章：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之使用篇 1：Quill 基本使用和配置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之使用篇 2：通过 Quill API 实现对编辑器内容的完全控制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之原理篇 1：现代富文本编辑器 Quill 的模块化机制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之原理篇 2：现代富文本编辑器 Quill 的内容渲染机制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之实践篇 1：如何将龙插入到编辑器中？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之实践篇 2：整个贪吃蛇游戏到编辑器里玩儿吧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;深入浅出 Quill 系列之选型篇：Quill 富文本编辑器的实践&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;视频：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;2.5k🔖35👍&lt;/span&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI2MDE3MTM4MA%3D%3D%26mid%3D2701521514%26idx%3D1%26sn%3Da9d7979a369f8e940a17b4f2a2248f6e%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;TinyPro Vue：一行命令创建一个美观大气的中后台系统，项目初始化和前后端启动指南&lt;/a&gt;：https://www.bilibili.com/video/BV1SUBRYGECg&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;Fluent Editor：一个基于 Quill 2.0 的富文本编辑器，功能强大，开箱即用！：https://www.bilibili.com/video/BV1HUWMe1ECA&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#576b95&quot;&gt;&lt;span&gt;common-intellisense：拥有这款 VSCode 插件，让你的 TinyVue 组件书写体验更丝滑！：https://www.bilibili.com/video/BV1sDvDeeE3m/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;关键字 3：健康生活&lt;/span&gt;&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;大家都追求幸福美好的生活，其中很关键的一点是保持身心健康，距离得新冠已经过了 2 年了，我依然记得当时卧床不起，啥事也做不了的情形，感叹疾病对人的影响。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;早睡早起，坚持锻炼，保持健康的生活方式，提升免疫力，尽可能远离疾病，这才是长远之计。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;去年主要是跑步，锻炼心肺能力，今年开始在健身房撸铁，锻炼核心和下肢力量。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;另外还和小伙伴们一起参加了深圳鲲鹏径 200KM 徒步活动，一共 20 段，目前已经完成了 14 段，并拿到了奖牌。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1374&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0730b510f181496989c5693b3461a6b787e.webp&quot; width=&quot;2036&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;除了锻炼，今年还读了几本书，书籍凝聚了大量前人和专业人士的经验，不仅能拓宽我们的视野，也能促进我们反思自我，让我们少走一些弯路。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;我觉得不一定要从头到尾把书看完，也不一定看完就一定要记住书里的全部内容，书中有一部分观点对自己有触动，让自己有收获就行。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;《福格行为模型》这本书里面讲了很多内容，我就记住了行为发生一个要素，就是要有提醒，最好是自然的提醒，比如我每次中午热饭的时候，就会想到要去锻炼 5-10 分钟，不需要人、不需要闹钟提醒，热饭这种动作本身就是最好的提醒。这个观点对我很有触动，我照着这个去实践，终于养成了每天健身的习惯。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;近期我们正在招募贡献者，欢迎你参与到 OpenTiny 开源项目的贡献中来👏感兴趣可以添加 OpenTiny 小助手微信：opentiny-official（备注：共建）。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;a href=&quot;https://my.oschina.net/u/4863191/blog/16561787&quot;&gt;让我们一起来建设 Fluent Editor 开源富文本编辑器吧！👏&lt;/a&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;联系我们&lt;/span&gt;&lt;/h2&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;GitHub：https://github.com/opentiny/tiny-vue（欢迎 Star⭐和参与共建👏）&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;官网：https://opentiny.design/tiny-vue&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;B 站：https://space.bilibili.com/15284299&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;个人博客：https://kagol.github.io/blogs&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;小助手微信：opentiny-official&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:hsl(var(--foreground)); margin-left:8px; margin-right:8px; text-align:justify&quot;&gt;&lt;span&gt;公众号：OpenTiny&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4863191/blog/17092278</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4863191/blog/17092278</guid>
            <pubDate>Mon, 06 Jan 2025 10:46:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>Pigsty@2024：今年没啥财运，但事儿整的还不赖</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;欢迎来到 2025 年！你的 2024 年终总结都写好了吗？记得发博客，私信【&lt;a href=&quot;https://my.oschina.net/u/3859945&quot; rel=&quot;nofollow&quot;&gt;开源中国编辑肖滢&lt;/a&gt;】哦！&lt;br&gt; 想看大家的年终总结？请看专栏：&lt;a href=&quot;https://www.oschina.net/news/column?columnId=28&quot; rel=&quot;nofollow&quot;&gt;【拜拜，2024！】&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;em&gt;本文作者：冯若航，微信公众号「非法加冯」主理人&lt;/em&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;去年有大师给我算了一卦曰：&lt;strong&gt;明年你没财运&lt;/strong&gt;&lt;strong&gt;，后年的财运一般&lt;/strong&gt;，然后连着十年就起飞了。起飞不起飞我不知道，反正今年确实算的很准 —— 确实没啥财运。好在 —— 今年的事儿整的还不赖，哈哈。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;617&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f41607395151aecc38e9dd0ac0cb037bb90.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;开源&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;GitHub 是全球一亿开发者的精神家园，全球最大的♂同性交友网站。&lt;/span&gt;与去年相比，今年我在 GitHub 上挣到了大概&amp;nbsp;3700&amp;nbsp;颗 Star，在全球 Star Ranking 上的排名从 &lt;strong&gt;483&lt;/strong&gt; 提升 26 名至 &lt;strong&gt;457&lt;/strong&gt; 位。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;507&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-886ddac0b71a4a8948cccbc541d66fd399f.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;同时，在劳模活跃榜上，今年我以 2868 个提交成为中国地区活跃度第 16 的用户，以及 3058 个 Contribution 成为国区榜 20 的用户。年底还拿了个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;「开源中国 2024 年度突出贡献专家」荣誉称号。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;img height=&quot;1181&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-64db0dda59588aaecb253e0fcc4a0d0803a.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;当然，这些贡献基本都围绕着 PostgreSQL 生态。主要是关于我的&lt;span style=&quot;color:#3f3f3f&quot;&gt;开箱即用的 PostgreSQL 数据库发行版 ——&amp;nbsp;&amp;nbsp;Pigsty 展开的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;项目&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;在 2024 年，Pigsty 发布了 9 个版本，特别是 v3 的发布，基本标志着这个项目已经进入了非常成熟稳定的阶段。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;693&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bff3669be96dbbcc4a11c0c2244b086cd4a.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span&gt;这一年里，Pigsty 明确了自己的定位，要站在数据库（PostgreSQL 吞噬数据库世界）与&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;云计&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;算（下云&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;）与&lt;/span&gt;&lt;span&gt;&lt;span&gt;两个核心趋势的交汇点上。抢占本地优先开源 RDS PG 标准（非 K8S）的&lt;/span&gt;&lt;span&gt;生态位&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;img height=&quot;540&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-217a7ea0371f413e1cb307e530db8b89af3.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;Pigsty&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;提出了六条核心价值主&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;张，其中首当其冲的就是，可扩展的 PostgreSQL。&lt;/span&gt;在年初我发表的 《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247487055%26idx%3D1%26sn%3D9d7bd8b6d9b07478dba7f87d0a663535%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;PostgreSQL 正在吞噬数据库世界&lt;/a&gt;》一文中，我提出了扩展插件是 PG 成功的秘诀，得到了全球社区的广泛认可。而&lt;span style=&quot;color:#3f3f3f&quot;&gt;知行合一的表现就是，既然我认为扩展至关重要，是发行版的核心价值主张。&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;那就应该去解决这个问题。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;在这一点上，我还是可以比较骄傲的说，我对 PG 扩展生态做了相当显著的贡献。&lt;/span&gt;在过去一年里，我在编译打包维护了 PG 生态中 150 个扩展插件，超过了官方仓库维护的 100 个。并且&lt;span style=&quot;color:#3f3f3f&quot;&gt;修复&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;了无数扩展问题，&lt;/span&gt;让 PG 生态开箱即用的扩展总数达到了惊人的 340 个，目前在整个 PG 生态中，没有能望其项背的竞争对手。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;img height=&quot;1081&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-506b0542c33281fcfdc60ca9526046dab84.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;目前来看，我觉得 PG 生态很有可能在 OLAP 大数据/实时数仓领域再次出现一个类似 PGVECTOR 向量插件这样的爆款。&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247485589%26idx%3D1%26sn%3D931f2d794e9b8486f623f746db9f00cd%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;但不同于上次 PGVECTOR 冒头时我只能求助&amp;nbsp;PGDG Devrim 放入 PG&amp;nbsp;仓库&lt;/a&gt;，现在的 Pigsty 已经成了这些扩展插件分发的一个重要渠道了。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;目前我已经说动了两家友商 AutoBase 和 Omnigres 使用 Pigsty 的扩展仓库作为上游，目前还在游说其他几家，总的来说我觉得问题不大，只要保持目前的态势，不难打造出一个&amp;nbsp;PG&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247488830%26idx%3D1%26sn%3D5657d698692bbea315c552e0bd2c3ca5%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;扩展分发事实标准&lt;/a&gt;来&lt;span style=&quot;color:#3f3f3f&quot;&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;除了扩展，Pigsty 还在另一个方向上， Pigsty 开始围绕 PostgreSQL 摊大饼，那就是 Fork 内核。Pigsty 目前支持了 Oracle 兼容的 &lt;/span&gt;&lt;span&gt;IvorySQL&lt;/span&gt;&lt;span&gt;，SQL Server 兼容的 WiltonDB，国产数据库 PolarDB （PG / Oracle），以及开源 Firebase，出海创业当红炸子鸡 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;Supabase&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span&gt;马上 &lt;/span&gt;&lt;span&gt;Neon&lt;/span&gt;&lt;span&gt; 和 OrioleDB 也要加入进来 —— Pigsty 能为这些 PG 分支/衍生内核提供完善的高可用，备份，连接池，扩展插件。将简单的 RPM 改造成一个开箱即用的云数据库服务。这意味着只要你是 PostgreSQL&amp;nbsp;生态的内核公司（没有瞎魔改），那么你就能从 Pigsty 的工作中享受到免费红利。从而打造一个互惠共赢的生态。&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;指标与数据&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;从运营指标上看，Pigsty 从年初的 2200 Star 到年底的 3645，虽然比不了去年的 3 倍增长，但也有可观的 50% 增长，收获了 1400&amp;nbsp;多 Star。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1864&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ccbcfcac823226c3880f1630987eba09101.png&quot; width=&quot;2384&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;当然 Star 是一方面，主要是在全球 PostgreSQL 生态也开始有了知名度，目前在 OSS Rank 上 PG 生态开源项目排行榜中从去年的第 37 位提升到了 23 位，挤进第一页指日可待。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1095&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-56368cca2bc6eee39b58eef24b072a56ec1.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;从 Google Analytics 上来看，今年 Pigsty 网站的总访问用户达到 10 万+ （pigsty.cc 加 pigsty.io ）&amp;nbsp;，相比去年的&amp;nbsp;5 万 UV 翻倍。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1062&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2a9d672d0304c5d5a59b886d6c67d99a805.png&quot; width=&quot;1826&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;这个尖刺来自&lt;span style=&quot;color:#3f3f3f&quot;&gt;《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247487055%26idx%3D1%26sn%3D9d7bd8b6d9b07478dba7f87d0a663535%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;PostgreSQL 正在吞噬数据库世界&lt;/a&gt;》，英文版引爆了 PG 社区，带来了大量的流量。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;而且&lt;span style=&quot;color:#3f3f3f&quot;&gt;来自海外的关注度与&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;流量出现显著增长，去年海外用户占比大约&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;占 20%，&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;而今年则几乎翻倍来到了 40%&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1040&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8c412419896dbda0e31f47de6ba7b3cdd9e.png&quot; width=&quot;1624&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;商业化&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;今年下半年，我开始进行了一些商业化方向的尝试。老实说，这不是我喜欢干的事情。我喜欢搞纯粹的研发，产品设计，写文章营销也还行，但销售真是要了血命。所以，我的商业化策略很简单：&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;—— &lt;span&gt;&lt;strong&gt;没有销售&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;在网站上放个页面，你要想买直接找我来买就好了。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1124&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-70e3cf809f51803233c289b95e75595afee.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;虽然没有销售，也没有吆喝，但就这样还是卖出了几单，基本上也就挣了个工资钱。但是知足常乐，反正我干的是自己喜欢的事，挣了钱的目标不就是为了干自己喜欢干的事么？&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;当然比起客户，用户侧的发展就要繁荣多了。这一年里，有许多新增的用户案例，比较知名的有&amp;nbsp;B 站，影视飓风，还有一些奇绩校友企业，一些科研院所军工部队单位都有用例，制造业，化工，新能源，各行各业基本都覆盖到了，毕竟数据库这东西太基础太万能，哪里都能用得上。特别是最近两年对，向量 pgvector 的需求激增，这带动了 PG 和 Pigsty 的显著增长。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;总的来说，适当的商业化确实能解决一些现金流上的问题，有了现金流也就不用在乎融不融资了，可以开心长久地干自己喜欢的事情。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;自媒体副业&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;今年，自媒体算是一个副业。写公众号纯粹是为了传达自己的理念，另外就是 —— 这个时代吧，任何公司组织，都必须想办法搞流量 —— 要么去买，要么自己上，那我就只能自己上了。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;关注用户数量从年初的一万八正好翻倍来到了三万六。两个专栏《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247488417%26idx%3D1%26sn%3D11ac37347fd159a1949da015b2cf57c7%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;strong&gt;数据库老司机&lt;/strong&gt;&lt;/a&gt;》 和 《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247488410%26idx%3D1%26sn%3De44705fce4221458244e7705258ca254%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;strong&gt;云计算泥石流&lt;/strong&gt;&lt;/a&gt;》都有了一些口碑，&lt;span style=&quot;color:#3f3f3f&quot;&gt;在&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;数据库领域的关注量大概是做到 Top1 了。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1250&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-4832797493463240619f5b8a23f17bd3046.png&quot; width=&quot;2266&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;今年虽然有很多软文生意找上门，但&lt;span style=&quot;color:#3f3f3f&quot;&gt;我&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;还&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;是保持住了节操 —— 我可以骄傲的宣称本号不接软文，所以我写文章的时候可以肆无忌惮地输出自己的观点，完全不顾及数据库厂商/社区和云厂商的脸面，哈哈，嘴炮很过瘾，没少得罪人，但也有了许多老铁读者与铁杆支持者。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;3630&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-81026832af29eb4b06a00f40c629e0040b1.png&quot; width=&quot;3736&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;总的来说，搞的还不错，海外平台上 Medium 有了几百个订阅，&lt;/span&gt;&lt;span style=&quot;color:#3f3f3f&quot;&gt;X 上关注破了一万一，接近千万展现，佛系运营，也算还行吧。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;1984&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-eb208f95130ada6f61033a08517e6b2e6c1.png&quot; width=&quot;1716&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;总的来说，2024 年，全职创业的第三年。一人公司，没啥功耗，时间自由，可以做自己喜欢的事情（这里要再次感谢媳妇的大力支持），基本上是一个比较满意的状态。明年，大师说我也没啥财运，宜广结善缘，则后年腾飞矣。俺希望大师没有骗我，总之，努力干吧。&lt;/p&gt; 
&lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;去年总结：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU5ODAyNTM5Ng%3D%3D%26mid%3D2247486732%26idx%3D1%26sn%3De3de398e70c49cf4765b87f720e60782%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;2023 总结：三十而立&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/3859945/blog/17101038</link>
            <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/17101038</guid>
            <pubDate>Mon, 06 Jan 2025 10:43:00 GMT</pubDate>
            <author>肖滢</author>
        </item>
        <item>
            <title>智元机器人完成 1000 台通用具身机器人下线</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;智元机器人官宣，其量产的第 1000 台通用具身机器人于 2025 年 1 月 6 日正式下线，其中双足人形机器人远征 A2/灵犀 X1 为 731 套，轮式通用机器人远征 A2-/A2-W 为 269 套。目前，这些机器人正在陆续交付客户中。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据介绍，智元机器人 2023 年 2 月成立，同年 8 月打造出人形机器人原型机；2024 年 8 月，针对交互服务、柔性制造、科研教育等多元场景，推出 5 款通用机器人，并在 12 月开源了全球首个百万真机数据集。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;667&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f68577d40d25a07b011d9f8efd763adb54c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328679</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328679</guid>
            <pubDate>Mon, 06 Jan 2025 09:43:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>雷军宣布 1000 万元重奖工程师</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;小米集团创始人、董事长兼 CEO 雷军&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1749127163%2FP8slrBSNU%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;，小米公司最高技术荣誉重磅升级为「千万技术大奖」，奖金投入增加至 1000 万元，以更大的诚意持续重奖工程师。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1344&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0107/172325_OZuT_2720166.png&quot; width=&quot;1240&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;经过激烈评比，「小米超级电机 V8s」技术凭借在创新性、领先性和影响力三个维度的突出表现，荣获 2024 年小米「千万技术大奖」最高奖项。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328674</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328674</guid>
            <pubDate>Mon, 06 Jan 2025 09:24:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>使用 MoonBit 在 Golem Cloud 上开发应用程序</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;blockquote&gt; 
  &lt;div&gt;
   副标题：MoonBit: First Look at New Language Through Building WASM Back End
  &lt;/div&gt; 
 &lt;/blockquote&gt; 
 &lt;div&gt;
  发布于：2025 年 1 月 3 日
 &lt;/div&gt; 
 &lt;div&gt;
  作者：Daniel Vigovszky
 &lt;/div&gt; 
 &lt;div&gt;
  原文链接：https://blog.vigoo.dev/posts/moonbit-with-golem/
 &lt;/div&gt; 
 &lt;h2&gt;介绍&lt;/h2&gt; 
 &lt;div&gt;
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.com%2F&quot; target=&quot;_blank&quot;&gt;MoonBit&lt;/a&gt; 是一门新的编程语言，几周前刚刚开源 —— 请参见
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.com%2Fblog%2Fcompiler-opensource&quot; target=&quot;_blank&quot;&gt;这篇博客文章&lt;/a&gt;。MoonBit 是一门令人兴奋的现代编程语言，原生支持 WebAssembly，包括组件模型，这使得它非常适合为 Golem Cloud 编写应用程序。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  在这篇文章中，我将探讨 MoonBit 的当前状态，以及它是否已准备好编写 Golem 组件，通过实现一个比简单的 &quot;Hello World&quot; 示例更复杂的应用程序来进行验证。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  要实现的应用程序是一个简单的协作列表编辑器 —— 在 
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyoutu.be%2F11Cig1iH6S0&quot; target=&quot;_blank&quot;&gt;Golem 1.0 发布事件&lt;/a&gt;上，我使用三种不同的编程语言（TypeScript、Rust 和 Go）为其实现了三个主要模块。在这篇文章中，我将使用 MoonBit 实现这三个模块，包括由于时间限制而从现场演示中省略的邮件发送功能。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  该应用程序可以处理任意数量的同时打开的列表。每个列表由一组字符串项组成。多个用户可以同时添加、插入和删除这些项；当前的列表状态可以随时查询，以及活跃连接（可以进行编辑操作的用户）。只有已连接的编辑者才能进行修改，并且提供一个轮询功能，返回自上次轮询以来的新更改。列表可以归档，这样它们将不再可编辑，其内容将保存在单独的列表归档中。然后，列表本身可以被删除，其最后的状态会永远保存在归档中。另一个附加功能是，如果列表未归档且在某段时间内没有更改，则所有连接的编辑者将通过发送电子邮件的方式收到通知。
 &lt;/div&gt; 
 &lt;h2&gt;Golem 架构&lt;/h2&gt; 
 &lt;div&gt;
  在 Golem 中，运行此应用程序的良好架构是拥有三个不同的 Golem 组件：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    列表
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    归档
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    邮件通知
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  这些都是编译后的 WebAssembly 组件，每个组件导出一组独特的函数。Golem 提供 API 用于从外部世界调用这些函数（例如将它们映射到 HTTP API），并且还允许工作者（这些组件的实例）相互调用。一个组件可以有任意数量的实例，每个工作者通过唯一的名称进行标识。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们可以利用这一特性来实现一个非常简单直接的列表编辑器 —— 每个文档（可编辑列表）将映射到其自己的工作者，通过列表的标识符来标识。这样，我们的列表组件只需处理一个单一的列表；将其扩展到处理多个（甚至数百万个）列表，Golem 会自动完成。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  对于归档列表，我们希望将每个归档的列表存储在一个地方 —— 所以我们将只拥有一个归档组件的实例，所有归档的列表信息都将发送到该实例。这一单例工作者可以根据需要将归档的列表存储在数据库中 —— 但因为 Golem 的持久执行保证，直接将它们存储在内存中就足够了（一个重要的例外是如果我们希望存储大量的归档列表，无法在单个工作者的内存中存储）。Golem 保证无论何时发生故障或重新扩展事件，工作者的状态都会恢复，因此归档组件可以保持非常简单。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  最后，由于 Golem 工作者是单线程的，并且目前不支持与调用重叠的异步调用，我们需要第三个组件来实现延迟发送电子邮件的功能。每个列表工作者将对应一个邮件发送工作者，该工作者将暂停一段时间（我们希望在发送邮件之前等待的时间）。同样，由于 Golem 的持久执行功能，我们可以在此组件中「休眠」任意长的时间，且无需担心在此长时间期间执行环境可能发生的变化。
 &lt;/div&gt; 
 &lt;h2&gt;初步 MoonBit 实现&lt;/h2&gt; 
 &lt;div&gt;
  在深入了解如何使用 MoonBit 开发 Golem 组件之前，让我们尝试用这门新语言实现上述描述的组件，而不涉及任何 Golem 或 WebAssembly 的特定内容。
 &lt;/div&gt; 
 &lt;div&gt;
  首先，我们使用 
  &lt;code&gt;moon new&lt;/code&gt; 创建一个新的 lib 项目。这将创建一个包含单个包的新项目。为了匹配我们的架构，我们将开始创建多个包，每个包对应一个要开发的组件（列表、归档、邮件）。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们为每个包创建一个文件夹，在每个文件夹中添加一个 
  &lt;code&gt;moon.pkg.json&lt;/code&gt; 文件：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-JSON&quot;&gt;{&quot;import&quot;: []}&lt;/code&gt;&lt;/pre&gt; 
 &lt;h3&gt;列表模型&lt;/h3&gt; 
 &lt;div&gt;
  让我们从建模我们的列表开始。被编辑的「文档」本身只是一个字符串数组：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-Rust&quot;&gt;struct Document { mut items: Array[String] }&lt;/code&gt;&lt;/pre&gt; 
 &lt;div&gt;
  我们可以为 
  &lt;code&gt;Document&lt;/code&gt; 实现方法，支持我们希望的文档编辑操作。在此级别，我们不关心协作编辑或连接的用户，只需将文档建模为纯数据结构：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code&gt;///| 创建一个空的文档
pub fn Document::new() -&amp;gt; Document {
  { items: [] }
}

///| 向文档添加一个新项
pub fn add(self : Document, item : String) -&amp;gt; Unit {if self.items.search(item).is_empty() {self.items.push(item)
  }
}

///| 从文档中删除一个项
pub fn delete(self : Document, item : String) -&amp;gt; Unit {self.items = self.items.filter(fn(i) { item != i })
}

///| 向文档中插入一个项，如果 after 不在文档中，则新项插入到末尾。
pub fn insert(self : Document, after~ : String, value~ : String) -&amp;gt; Unit {let index = self.items.search(after)match index {Some(index) =&amp;gt; self.items.insert(index + 1, value)None =&amp;gt; self.add(value)
  }
}

///| 获取文档的项视图
pub fn get(self : Document) -&amp;gt; ArrayView[String] {self.items[:]
}

///| 遍历文档中的项
pub fn iter(self : Document) -&amp;gt; Iter[String] {self.items.iter()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们还可以使用 MoonBit 内建的测试功能为此编写单元测试。以下测试包含一个断言，验证初始文档为空：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;test &quot;new document is empty&quot; {let empty = Document::new()assert_eq!(empty.items, []) }
&lt;/pre&gt; 
 &lt;div&gt;
  使用 
  &lt;code&gt;inspect&lt;/code&gt; 函数，测试可以使用快照值来进行比较。
  &lt;code&gt;moon CLI&lt;/code&gt; 工具和 IDE 集成提供了在需要时自动更新这些测试函数中的快照值（
  &lt;code&gt;content=&lt;/code&gt; 部分）的方法：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;test &quot;basic document operations&quot; {let doc = Document::new()
    ..add(&quot;x&quot;)
    ..add(&quot;y&quot;)
    ..add(&quot;z&quot;)
    ..insert(after=&quot;y&quot;, value=&quot;w&quot;)
    ..insert(after=&quot;a&quot;, value=&quot;b&quot;)
    ..delete(&quot;z&quot;)
    ..delete(&quot;f&quot;)
  inspect!(
    doc.get(),
    content=
      #|[&quot;x&quot;, &quot;y&quot;, &quot;w&quot;, &quot;b&quot;]
    ,
  )
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;列表编辑器状态&lt;/h3&gt; 
 &lt;div&gt;
  接下来的步骤是实现基于 
  &lt;code&gt;Document&lt;/code&gt; 类型的编辑器状态管理。提醒一下，我们决定每个列表组件的实例（Golem 工作者）只负责编辑一个单一的列表。因此，我们不需要关心存储和索引列表，或将连接路由到对应的节点，Golem 会自动管理这一切。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们需要做的，是编写有状态的代码来处理连接和断开用户（「编辑者」），在文档编辑 API 上添加一些验证，以确保只有连接的编辑者能够进行修改，并收集变更事件以供轮询 API 使用。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们可以从定义一个新的数据类型来持有我们的文档编辑状态开始：
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 文档状态 struct State {
  document : Document
  connected : Map[ConnectionId, EditorState]mut last_connection_id : ConnectionIdmut archived : Boolmut email_deadline : @datetime.DateTimemut email_recipients : Array[EmailAddress]
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  除了实际的文档，我们将存储以下内容：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    连接的编辑者的映射，以及与每个编辑者相关的状态
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    用于生成新连接 ID 的上一个连接 ID
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    文档是否已归档
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    何时发送电子邮件通知，发送给哪些收件人
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  到目前为止，我们只定义了 
  &lt;code&gt;Document&lt;/code&gt; 类型，因此让我们继续定义 
  &lt;code&gt;State&lt;/code&gt; 字段中使用的其他类型。
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;code&gt;ConnectionId&lt;/code&gt; 将是一个包装整数的新类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 连接的编辑者的标识符 type ConnectionId Int derive(Eq, Hash)

///| 生成下一个唯一的连接 IDfn next(self : ConnectionId) -&amp;gt; ConnectionId {ConnectionId(self._ + 1)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  我们希望将此类型作为 
  &lt;code&gt;Map&lt;/code&gt; 的键，因此我们需要为它实现 
  &lt;code&gt;Eq&lt;/code&gt; 和 
  &lt;code&gt;Hash&lt;/code&gt; 类型类。MoonBit 可以自动为新类型派生这些类型类。除此之外，我们还定义了一个名为 
  &lt;code&gt;next&lt;/code&gt; 的方法，用于生成一个递增的连接 ID。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;code&gt;EditorState&lt;/code&gt; 结构存储每个连接的编辑者的信息。为了简化起见，我们只存储编辑者的电子邮件地址和自上次轮询以来的更改事件缓冲区。
 &lt;/div&gt; 
 &lt;div&gt;
  电子邮件地址是一个新的 
  &lt;code&gt;String&lt;/code&gt; 类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;em&gt;///| 连接编辑者的电子邮件地址&lt;/em&gt;type EmailAddress String
&lt;/pre&gt; 
 &lt;div&gt;
  &lt;code&gt;Change&lt;/code&gt; 枚举描述了对文档所做的可能更改：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;em&gt;///| 编辑文档时的可观察更改&lt;/em&gt;enum Change {Added(String)Deleted(String)Inserted(after~ : String, value~ : String) } derive(Show)
&lt;/pre&gt; 
 &lt;div&gt;
  通过派生 
  &lt;code&gt;Show&lt;/code&gt;（或手动实现），可以使用 
  &lt;code&gt;inspect&lt;/code&gt; 测试函数比较更改数组的字符串快照与 
  &lt;code&gt;poll&lt;/code&gt; 函数的结果。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  接下来，我们使用这两个新类型定义 
  &lt;code&gt;EditorState&lt;/code&gt;：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;em&gt;///| 每个连接的编辑者的状态&lt;/em&gt;struct EditorState { email : EmailAddressmut events : Array[Change] }
&lt;/pre&gt; 
 &lt;div&gt;
  &lt;code&gt;email&lt;/code&gt; 字段在连接的编辑者中始终不变，但 
  &lt;code&gt;events&lt;/code&gt; 数组会随着每次调用 
  &lt;code&gt;poll&lt;/code&gt; 被重置，以便下次轮询时仅返回新的更改。为了实现这一点，我们必须将其标记为可变（
  &lt;code&gt;mut&lt;/code&gt;）。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们需要为 
  &lt;code&gt;State&lt;/code&gt; 引入的最后一个新类型是表示时间点的东西。MoonBit 的核心标准库目前没有这个功能，但已经有一个名为 
  &lt;code&gt;mooncakes&lt;/code&gt; 的包数据库，里面发布了 MoonBit 的包。在这里我们可以找到一个叫 
  &lt;code&gt;datetime&lt;/code&gt; 的包。通过使用 moon CLI 可以将其添加到项目中：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;moon add suiyunonghen/datetime
&lt;/pre&gt; 
 &lt;div&gt;
  然后通过修改 
  &lt;code&gt;moon.pkg.json&lt;/code&gt; 将其导入：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;{&quot;import&quot;: [&quot;suiyunonghen/datetime&quot;]}
&lt;/pre&gt; 
 &lt;div&gt;
  通过这样，我们就可以使用 
  &lt;code&gt;@datetime.DateTime&lt;/code&gt; 引用该包中的 
  &lt;code&gt;DateTime&lt;/code&gt; 类型。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  在开始实现 
  &lt;code&gt;State&lt;/code&gt; 的方法之前，我们还需要考虑错误处理——
  &lt;code&gt;State&lt;/code&gt; 上的某些操作可能会失败，例如如果使用了错误的连接 ID，或者如果文档已归档时仍进行编辑操作。MoonBit 内建了错误处理支持，首先通过以下方式定义我们自己的错误类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 编辑器状态操作的错误类型
type! EditorError {///| 当使用无效的连接 ID 时返回的错误 InvalidConnection(ConnectionId)///| 尝试修改已归档的文档时的错误
  AlreadyArchived
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  有了这些，我们就准备好实现协作列表编辑器了！我在这篇文章中不会列出 
  &lt;code&gt;State&lt;/code&gt; 的所有方法，但完整的源代码可以在 
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvigoo%2Fgolem-moonbit-example&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; 上找到。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;code&gt;connect&lt;/code&gt; 方法将新的连接 ID 与连接的用户关联，并返回当前文档状态。这对于使用 
  &lt;code&gt;poll&lt;/code&gt; 的结果非常重要——返回的更改列表必须精确应用到客户端上的该文档状态。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 连接一个新的编辑者 pub fn connect(self : State,
  email : EmailAddress
) -&amp;gt; (ConnectionId, ArrayView[String]) {let connection_id = self.last_connection_id.next()self.last_connection_id = connection_idself.connected.set(connection_id, EditorState::new(email))
  (connection_id, self.document.get())
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  编辑操作更为有趣。它们构建在我们已经为 
  &lt;code&gt;Document&lt;/code&gt; 定义的编辑操作的基础上，但除了这些，它们还执行以下任务：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    验证连接 ID
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    验证文档是否尚未归档
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    向每个连接编辑者的状态添加一个 
    &lt;code&gt;Change&lt;/code&gt; 事件
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    更新 
    &lt;code&gt;email_deadline&lt;/code&gt; 和 
    &lt;code&gt;email_recipients&lt;/code&gt; 字段，因为每次编辑操作都会重置发送电子邮件的超时时间
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  我们逐步处理这些步骤。为了进行验证，我们定义了两个辅助方法，以便在所有编辑方法中重复使用：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 如果文档已归档则失败 fn ensure_not_archived(self : State) -&amp;gt; Unit!EditorError {
  guard not(self.archived) else { raise AlreadyArchived }
}

///| 如果给定的 connection_id 不在连接映射中，则失败 fn ensure_is_connected(self : State,
  connection_id : ConnectionId
) -&amp;gt; Unit!EditorError {
  guard self.connected.contains(connection_id) else {
    raise InvalidConnection(connection_id)
  }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;code&gt;Unit!EditorError&lt;/code&gt; 返回类型表示这些方法可能会失败，并返回 
  &lt;code&gt;EditorError&lt;/code&gt;。
 &lt;/div&gt; 
 &lt;div&gt;
  我们还可以为向每个连接编辑者的状态添加一个更改事件定义一个辅助方法：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 向每个连接编辑者的状态添加更改事件 fn add_event(self : State, change : Change) -&amp;gt; Unit {for editor_state in self.connected.values() {
    editor_state.events.push(change)
  }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  最后，为了重置电子邮件发送截止时间和收件人列表，我们定义一个辅助方法：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 在更新后更新 email_deadline 和 email_recipients 字段 fn update_email_properties(self : State) -&amp;gt; Unit {let now = @datetime.DateTime::from_unix_mseconds(0) // TODOlet send_at = now.inc_hour(12)let email_list = self.connected_editors()self.email_deadline = send_atself.email_recipients = email_list
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  请注意，我们导入的 
  &lt;code&gt;datetime&lt;/code&gt; 库没有获取当前日期和时间的功能，我们需要这个功能来使此函数正常工作。我们将在针对 WebAssembly（和 Golem）时解决这个问题，因为获取当前系统时间依赖于目标平台。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  通过这些辅助函数，实现编辑器函数，例如 
  &lt;code&gt;add&lt;/code&gt;，是直截了当的：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 作为连接的编辑者向文档添加新元素 pub fn add(self : State,
  connection_id : ConnectionId,
  value : String
) -&amp;gt; Unit!EditorError {self.ensure_not_archived!()self.ensure_is_connected!(connection_id)self.document.add(value)self.add_event(Change::Added(value))self.update_email_properties()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  实现 
  &lt;code&gt;poll&lt;/code&gt; 也很简单，因为我们已经为每个连接维护了更改列表，我们只需要在每次调用后重置它：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 返回自上次调用 poll 以来发生的更改列表 pub fn poll(self : State,
  connection_id : ConnectionId
) -&amp;gt; Array[Change]!EditorError {match self.connected.get(connection_id) {Some(editor_state) =&amp;gt; {let events = editor_state.events
      editor_state.events = []
      events
    }None =&amp;gt; raise InvalidConnection(connection_id)
  }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;列表归档&lt;/h3&gt; 
 &lt;div&gt;
  如在介绍中提到的，我们将有一个单例 Golem 工作器来存储已归档的列表。目前，我们仍未涉及任何 Golem 或 WebAssembly 特定的内容，如 RPC 调用，因此我们先以最简单的方式实现列表归档存储。正如我之前所写，我们可以简单地将已归档的列表存储在内存中，而 Golem 会负责持久化。
 &lt;/div&gt; 
 &lt;div&gt;
  我们不希望重用相同的 
  &lt;code&gt;Document&lt;/code&gt; 类型，因为它表示的是一个可编辑的文档。相反，我们在归档包中定义了一些新类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 文档的唯一名称 type DocumentName String derive(Eq, Hash)

///| DocumentName 的 Show 实现 impl Show for DocumentName with output(self, logger) { self._.output(logger) }

///| 一个单一的已归档不可变文档，封装了文档的名称及其项 struct ArchivedDocument {
  name : DocumentName
  items : Array[String]
} derive(Show)

///| 归档是一个已归档文档的列表 struct Archive {
  documents : Map[DocumentName, ArchivedDocument]
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  我们只需要一个 
  &lt;code&gt;insert&lt;/code&gt; 方法和一个迭代所有已归档文档的方法：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 归档一个命名文档 pub fn insert(self : Archive,
  name : DocumentName,
  items : Array[String]
) -&amp;gt; Unit {self.documents.set(name, { name, items })
}

///| 迭代所有已归档文档 pub fn iter(self : Archive) -&amp;gt; Iter[ArchivedDocument] {self.documents.values()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  完成这部分后，我们首先使用简单的方法调用在列表包中实现列表归档。稍后，我们将用 Golem 的 Worker-to-Worker 通信替换它。
 &lt;/div&gt; 
 &lt;div&gt;
  由于会有一个单例归档工作器，我们可以通过在归档包中创建一个顶层的 
  &lt;code&gt;Archive&lt;/code&gt; 实例来模拟这一点：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;pub let archive: Archive = Archive::new()&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  并在 
  &lt;code&gt;State::archive&lt;/code&gt; 方法中调用它：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;pub fn archive(self : State) -&amp;gt; Unit {self.archived = truelet name = @archive.DocumentName(&quot;TODO&quot;)
  @archive.archive.insert(name, self.document.iter().to_array())
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  请注意，到目前为止，我们在 
  &lt;code&gt;State&lt;/code&gt; 中没有存储文档的名称——我们并没有把它存储在任何地方。这是故意的，正如我们之前讨论的那样，工人的名称将作为文档的唯一标识符。一旦我们进入 Golem 特定的实现阶段，获取工人的名称将以 Golem 特有的方式完成。
 &lt;/div&gt; 
 &lt;h3&gt;发送一封电子邮件&lt;/h3&gt; 
 &lt;div&gt;
  我们已经在 
  &lt;code&gt;State&lt;/code&gt; 类型中准备好了部分电子邮件发送逻辑：它有一个截止日期和一份收件人名单。我们的想法是，当创建一个新的列表时，我们会启动一个电子邮件发送工人，并让它与我们的编辑会话并行运行，形成一个循环。在这个循环中，首先查询列表编辑状态中的截止日期和收件人名单，然后它会一直休眠直到指定的截止日期。当它醒来时（12 小时后），它再次查询列表，如果已经过了截止日期，说明在此期间没有进一步的编辑操作。然后，它会向收件人列表发送通知邮件。
 &lt;/div&gt; 
 &lt;div&gt;
  目前，
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmooncakes.io%2F&quot; target=&quot;_blank&quot;&gt;mooncakes&lt;/a&gt; 上还没有用于发送电子邮件或发起 HTTP 请求的库，因此这部分功能我们需要自己实现。此外，创建工人并使其并行运行是 Golem 特有的功能，因此在目前阶段我们不会为电子邮件包实现任何东西。一旦其余的应用程序已作为 Golem 组件编译完成，我们会再回到这部分实现。
 &lt;/div&gt; 
 &lt;h3&gt;编译为 Golem 组件&lt;/h3&gt; 
 &lt;div&gt;
  现在是时候尝试将我们的代码编译为 Golem 组件了——这些是 WebAssembly 组件（使用
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcomponent-model.bytecodealliance.org%2F&quot; target=&quot;_blank&quot;&gt;组件模型&lt;/a&gt;），并通过 Wasm 接口类型（WIT）语言描述的 API 导出。
 &lt;/div&gt; 
 &lt;h3&gt;绑定&lt;/h3&gt; 
 &lt;div&gt;
  在当前的 WASM 组件模型中，组件是按照规范优先的方式定义的——首先编写描述类型和导出接口的 WIT 文件，然后使用绑定生成器从中生成特定语言的连接代码。幸运的是，
  &lt;code&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytecodealliance%2Fwit-bindgen&quot; target=&quot;_blank&quot;&gt;wit-bindgen 工具&lt;/a&gt;&lt;/code&gt;已经支持 MoonBit，因此我们可以首先安装最新版本：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;cargo install wit-bindgen-cli
&lt;/pre&gt; 
 &lt;div&gt;
  请注意，Golem 的文档推荐使用一个较旧的特定版本的 
  &lt;code&gt;wit-bindgen&lt;/code&gt;，但该版本还不支持 MoonBit。新版本应该可以很好地工作，但 Golem 的示例代码并没有在这个版本上进行过测试。
 &lt;/div&gt; 
 &lt;div&gt;
  我们将重用为 Golem 1.0 演示所创建的 WIT 定义。
 &lt;/div&gt; 
 &lt;div&gt;
  对于列表组件，它如下所示：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;package demo:lst;
interface api {
  record connection {
    id: u64
  }
  record insert-params {
    after: string,
    value: string
  }
  variant change {added(string),deleted(string),inserted(insert-params)
  }
  add: func(c: connection, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;;
  delete: func(c: connection, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;;
  insert: func(c: connection, after: string, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;;
  get: func() -&amp;gt; list&amp;lt;string&amp;gt;;
  poll: func(c: connection) -&amp;gt; result&amp;lt;list&amp;lt;change&amp;gt;, string&amp;gt;;
  connect: func(email: string) -&amp;gt; tuple&amp;lt;connection, list&amp;lt;string&amp;gt;&amp;gt;;
  disconnect: func(c: connection) -&amp;gt; result&amp;lt;_, string&amp;gt;;
  connected-editors: func() -&amp;gt; list&amp;lt;string&amp;gt;;
  archive: func();
  is-archived: func() -&amp;gt; bool;
}
interface email-query {
  deadline: func() -&amp;gt; option&amp;lt;u64&amp;gt;;
  recipients: func() -&amp;gt; list&amp;lt;string&amp;gt;;
}
world lst  {// .. imports to be explained later ..
  export api;
  export email-query;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  这个接口定义导出了两个 API——一个是我们的列表编辑器的公共 API，非常类似于我们已经为 
  &lt;code&gt;State&lt;/code&gt; 类型实现的方法。另一个是一个内部 API，用于电子邮件组件查询截止日期和收件人，如前所述。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  为了简化，我们在公共 API 中使用字符串作为错误类型。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  对于归档组件，我们定义了一个更简单的接口：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;package demo:archive;
interface api {
  record archived-list {
    name: string,
    items: list&amp;lt;string&amp;gt;
  }
  store: func(name: string, items: list&amp;lt;string&amp;gt;);
  get-all: func() -&amp;gt; list&amp;lt;archived-list&amp;gt;;
}
world archive {// .. 导入稍后会解释 ..

  export api;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  最后，对于电子邮件组件：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;package demo:email;
interface api {use golem:rpc/types@0.1.0.{uri};
  send-email: func(list-uri: uri);
}
world email {// .. 导入稍后会解释 ..

  export api;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  这里我们使用了 Golem 特有的类型：
  &lt;code&gt;uri&lt;/code&gt;。这是必要的，因为电子邮件工人需要调用它所从中生成的特定列表工人。具体细节稍后会解释。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  这些 WIT 定义需要放在每个包的 
  &lt;code&gt;wit&lt;/code&gt; 目录中，依赖项放在 
  &lt;code&gt;wit/deps&lt;/code&gt; 的子目录中。可以参考
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvigoo%2Fgolem-moonbit-example&quot; target=&quot;_blank&quot;&gt;仓库&lt;/a&gt;中的示例。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们从定义一个单一的 MoonBit 模块开始（通过根目录中的 
  &lt;code&gt;moon.mod.json&lt;/code&gt; 标识），并仅将 
  &lt;code&gt;list&lt;/code&gt;、
  &lt;code&gt;email&lt;/code&gt; 和 
  &lt;code&gt;archive&lt;/code&gt; 创建为内部包。此时，我们需要做一些更改，因为我们需要为每个我们想要编译成独立 Golem 组件的代码块创建一个单独的模块。通过在每个子目录中运行 
  &lt;code&gt;wit-bindgen&lt;/code&gt;（如下所示），它实际上会为我们生成模块定义。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们稍微重组一下目录结构，将 
  &lt;code&gt;src/archive&lt;/code&gt; 移到 
  &lt;code&gt;archive&lt;/code&gt; 等，并将之前编写的源代码移到 
  &lt;code&gt;archive/src&lt;/code&gt;。这样生成的绑定和我们手写的实现将并排放置。我们还可以删除顶级模块定义的 JSON 文件。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  现在，在所有三个目录中，我们可以生成绑定：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;wit-bindgen moonbit wit&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  请注意，一旦我们开始修改生成的 
  &lt;code&gt;stub.wit&lt;/code&gt; 文件，再次运行此命令将会覆盖我们的更改。为避免这种情况，可以使用以下方式运行：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;wit-bindgen moonbit wit --ignore-stub&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  完成此步骤后，运行以下命令：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;moon build --target wasm&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  将为我们编译一个位于 
  &lt;code&gt;./target/wasm/release/build/gen/gen.wasm&lt;/code&gt; 的 WASM 模块。这还不是一个 WASM 组件——因此不能直接在 Golem 中使用。为了实现这一点，我们需要使用另一个命令行工具 
  &lt;code&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytecodealliance%2Fwasm-tools&quot; target=&quot;_blank&quot;&gt;wasm-tools&lt;/a&gt;&lt;/code&gt;，将该模块转换为一个自描述其高级导出接口的组件。
 &lt;/div&gt; 
 &lt;h3&gt;WIT 依赖项&lt;/h3&gt; 
 &lt;div&gt;
  我们将需要依赖一些 WIT 包，其中一些来自 WASI（WebAssembly 系统接口），用于访问环境变量和当前的日期/时间，另一些来自 Golem，供实现工人之间的通信。
 &lt;/div&gt; 
 &lt;div&gt;
  获取 Golem 提供的所有依赖项的适当版本的最简单方法是使用 Golem 的 &quot;all&quot; 打包接口和 
  &lt;code&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytecodealliance%2Fwit-deps&quot; target=&quot;_blank&quot;&gt;wit-deps&lt;/a&gt;&lt;/code&gt; 工具。
 &lt;/div&gt; 
 &lt;div&gt;
  首先，我们安装 
  &lt;code&gt;wit-deps&lt;/code&gt;：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;cargo install wit-deps-cli
&lt;/pre&gt; 
 &lt;div&gt;
  然后，在我们创建的每个 
  &lt;code&gt;wit&lt;/code&gt; 目录中创建一个 
  &lt;code&gt;deps.toml&lt;/code&gt; 文件，内容如下：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;all = &quot;https://github.com/golemcloud/golem-wit/archive/main.tar.gz&quot;
&lt;/pre&gt; 
 &lt;div&gt;
  最后，我们运行以下命令来填充 
  &lt;code&gt;wit/deps&lt;/code&gt; 目录：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;wit-deps update
&lt;/pre&gt; 
 &lt;h3&gt;实现导出功能&lt;/h3&gt; 
 &lt;div&gt;
  在设置这个编译链之前，让我们看看如何将生成的绑定与我们现有的代码连接起来。我们从归档组件开始，因为它是最简单的。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  绑定生成器在 
  &lt;code&gt;archive/gen/interface/demo/archive/api/stub.mbt&lt;/code&gt; 位置生成了一个 
  &lt;code&gt;stub.mbt&lt;/code&gt; 文件，其中包含两个需要实现的导出函数。我们在使用代码生成器时通常会遇到一个问题：我们在 WIT 中定义了 
  &lt;code&gt;archived-list&lt;/code&gt;，并且绑定生成器根据它生成了以下 MoonBit 定义：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-Rust&quot;&gt;&lt;em&gt;// Generated by &lt;/em&gt;&lt;em&gt;&lt;code&gt;wit-bindgen&lt;/code&gt;&lt;/em&gt;&lt;em&gt; 0.36.0. DO NOT EDIT!&lt;/em&gt;pub struct ArchivedList { name : String; items : Array[String] } derive()&lt;/code&gt;&lt;/pre&gt; 
 &lt;div&gt;
  但我们已经定义了一个非常相似的结构体，叫做 
  &lt;code&gt;ArchivedDocument&lt;/code&gt;！唯一的区别是使用了 
  &lt;code&gt;DocumentName&lt;/code&gt; 新类型，并且我们的版本派生了一个 
  &lt;code&gt;Show&lt;/code&gt; 实例。我们可以决定放弃使用这个新类型，并在我们的业务逻辑中使用生成的类型，或者我们可以保持生成的类型与我们的实际代码分离。（这其实并不特定于 MoonBit 或 WASM 工具链，在任何基于代码生成器的方法中都会遇到这个问题。）
 &lt;/div&gt; 
 &lt;div&gt;
  在本文中，我将保持生成的代码与我们已经编写的业务逻辑分离，并展示如何实现必要的转换来实现 
  &lt;code&gt;stub.mbt&lt;/code&gt; 文件。
 &lt;/div&gt; 
 &lt;div&gt;
  第一个需要实现的导出函数是 
  &lt;code&gt;store&lt;/code&gt;。我们可以通过调用 
  &lt;code&gt;insert&lt;/code&gt; 在我们的单例顶级 
  &lt;code&gt;Archive&lt;/code&gt; 中实现它，就像我们之前直接将归档包连接到列表包时做的那样：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;pub fn store(name : String, items : Array[String]) -&amp;gt; Unit { @src.archive.insert(@src.DocumentName(name), items) }
&lt;/pre&gt; 
 &lt;div&gt;
  请注意，我们需要在 
  &lt;code&gt;stub&lt;/code&gt; 包的 JSON 中导入我们的主归档源：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;{&quot;import&quot;: [{ &quot;path&quot; : &quot;demo/archive/ffi&quot;, &quot;alias&quot; : &quot;ffi&quot; },{ &quot;path&quot; : &quot;demo/archive/src&quot;, &quot;alias&quot; : &quot;src&quot; }]}
&lt;/pre&gt; 
 &lt;div&gt;
  第二个需要实现的函数需要在两种归档文档表示之间进行转换：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;code class=&quot;language-Rust&quot;&gt;pub fn get_all() -&amp;gt; Array[ArchivedList] { @src.archive .iter() .map(fn(archived) { { name: archived.name._, items: archived.items } }) .to_array() }&lt;/code&gt;
&lt;/pre&gt; 
 &lt;div&gt;
  请注意，为了使其工作，我们还必须将之前定义的 
  &lt;code&gt;ArchivedDocument&lt;/code&gt; 结构体设置为 
  &lt;code&gt;pub&lt;/code&gt;，否则我们无法从 
  &lt;code&gt;stub&lt;/code&gt; 包访问它的 
  &lt;code&gt;name&lt;/code&gt; 和 
  &lt;code&gt;items&lt;/code&gt; 字段。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  （注：在撰写本文时，
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytecodealliance%2Fwit-bindgen%2Fpull%2F1100&quot; target=&quot;_blank&quot;&gt;https://github.com/bytecodealliance/wit-bindgen/pull/1100&lt;/a&gt; 尚未合并，而这个补丁对于绑定生成器生成能够与 Golem 的 wasm-rpc 正常工作的代码是必需的；在它合并之前，可以编译这个分支并直接使用。）
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我们可以以同样的方式在列表模块中实现两个生成的存根（在 
  &lt;code&gt;list/gen/interface/demo/lst/api/stub.mbt&lt;/code&gt; 和 
  &lt;code&gt;list/gen/interface/demo/lst/emailQuery/stub.mbt&lt;/code&gt; 中），使用我们现有的 
  &lt;code&gt;State&lt;/code&gt; 实现。
 &lt;/div&gt; 
 &lt;div&gt;
  一个有趣的细节是如何将 
  &lt;code&gt;EditorError&lt;/code&gt; 的失败映射到 WIT 定义中使用的字符串错误。首先我们为 
  &lt;code&gt;EditorError&lt;/code&gt; 定义一个 
  &lt;code&gt;to_string&lt;/code&gt; 方法：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;pub fn to_string(self : EditorError) -&amp;gt; String {match self {InvalidConnection(id) =&amp;gt; &quot;Invalid connection ID: \{id._}&quot;, AlreadyArchived =&amp;gt; &quot;Document is already archived&quot; } }
&lt;/pre&gt; 
 &lt;div&gt;
  然后在存根中使用 
  &lt;code&gt;?&lt;/code&gt; 和 
  &lt;code&gt;map_err&lt;/code&gt;：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;pub fn add(c : Connection, value : String) -&amp;gt; Result[Unit, String] { @src.state .add?(to_connection_id(c), value) .map_err(fn(err) { err.to_string() }) }&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;h3&gt;使用宿主函数&lt;/h3&gt; 
 &lt;div&gt;
  当我们之前实现 
  &lt;code&gt;update_email_properties&lt;/code&gt; 函数时，我们无法正确查询当前时间来计算适当的截止日期。现在我们正在面向 Golem，我们可以使用 WebAssembly 系统接口（WASI）来访问诸如系统时间之类的功能。一种方法是使用已发布的 
  &lt;code&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmooncakes.io%2Fdocs%2F%23%2Fyamajik%2Fwasi-bindings%2F&quot; target=&quot;_blank&quot;&gt;wasi-bindings 包&lt;/a&gt;&lt;/code&gt;，但既然我们已经从 WIT 生成绑定，我们可以直接使用我们自己生成的绑定来导入宿主函数。
 &lt;/div&gt; 
 &lt;div&gt;
  首先，我们需要将 WASI 的墙时钟接口导入到我们的 WIT 世界中：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;world lst { export api; export email-query; import wasi:clocks/wall-clock@0.2.0; }
&lt;/pre&gt; 
 &lt;div&gt;
  然后我们重新生成绑定（确保使用 
  &lt;code&gt;--ignore-stub&lt;/code&gt;，以避免覆盖我们的存根实现！），并将其导入到我们的主包（
  &lt;code&gt;src&lt;/code&gt;）中：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;{&quot;import&quot;: [&quot;suiyunonghen/datetime&quot;,{ &quot;path&quot; : &quot;demo/lst/interface/wasi/clocks/wallClock&quot;, &quot;alias&quot; : &quot;wallClock&quot; }]}
&lt;/pre&gt; 
 &lt;div&gt;
  有了这些，我们就可以调用 WASI 的 
  &lt;code&gt;now&lt;/code&gt; 函数来查询当前的系统时间，并将其转换为我们之前使用的 
  &lt;code&gt;datetime&lt;/code&gt; 模块的 
  &lt;code&gt;DateTime&lt;/code&gt; 类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| Queries the WASI wall clock and returns it as a @datetime.DateTime////// Note that DateTime has only millisecond precisionfn now() -&amp;gt; @datetime.DateTime {let wasi_now = @wallClock.now()let base_ms =  wasi_now.seconds.reinterpret_as_int64() * 1000;let nano_ms = (wasi_now.nanoseconds.reinterpret_as_int() / 1000000).to_int64();
  @datetime.DateTime::from_unix_mseconds(base_ms + nano_ms)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h2&gt;Golem 应用清单&lt;/h2&gt; 
 &lt;div&gt;
  在我们实现的下一步中，我们需要将现有的两个组件——列表和归档连接起来，使得列表能够进行远程过程调用（RPC）到归档。使用相同的技术，我们还可以实现第三个组件——电子邮件组件，它既需要被列表调用（启动时），也需要回调（获取截止日期和收件人时）。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  Golem 提供了支持这种功能的工具，但在尝试使用之前，让我们将项目转换为由应用清单描述的 Golem 应用。这将使我们能够使用 
  &lt;code&gt;golem-cli&lt;/code&gt; 生成必要的文件来进行工作者之间的通信，并且也更容易将编译后的组件部署到 Golem。
 &lt;/div&gt; 
 &lt;h3&gt;构建步骤&lt;/h3&gt; 
 &lt;div&gt;
  要将单个 MoonBit 模块构建为一个 Golem 组件，而不涉及任何工作者间通信，我们需要执行以下步骤：
 &lt;/div&gt; 
 &lt;ol&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    （可选）使用 
    &lt;code&gt;wit-bindgen ... --ignore-stub&lt;/code&gt; 重新生成 WIT 绑定。
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    使用 
    &lt;code&gt;moon build --target wasm&lt;/code&gt; 将 MoonBit 源代码编译为 WASM 模块。
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    使用 
    &lt;code&gt;wasm-tools component embed&lt;/code&gt; 将 WIT 规范嵌入到自定义的 WASM 部分中。
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    使用 
    &lt;code&gt;wasm-tools component new&lt;/code&gt; 将 WASM 模块转换为 WASM 组件。
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;div&gt;
  当我们开始使用工作者间通信时，这将需要更多的步骤，因为我们将生成存根 WIT 接口，并编译和链接多个 WASM 组件。这个过程的早期版本已在去年的
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.vigoo.dev%2Fposts%2Fw2w-communication-golem%2F&quot; target=&quot;_blank&quot;&gt;《Golem 中的工作者间通信》&lt;/a&gt;博客文章中描述过。
 &lt;/div&gt; 
 &lt;div&gt;
  随着 Golem 1.1 的发布，Golem 应用清单和相应的 CLI 工具可以为我们自动化所有这些步骤。
 &lt;/div&gt; 
 &lt;h3&gt;清单模板&lt;/h3&gt; 
 &lt;div&gt;
  我们首先在项目的根目录中创建一个根应用清单文件 
  &lt;code&gt;golem.yaml&lt;/code&gt;。接下来，我们设置一个临时目录和一个共享目录，用于存放我们之前通过 
  &lt;code&gt;wit-deps&lt;/code&gt; 获取的 WIT 依赖：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;# IDEA 的架构：
# $schema: https://schema.golem.cloud/app/golem/1.1.0/golem.schema.json
# vscode-yaml 的架构
# yaml-language-server: $schema=https://schema.golem.cloud/app/golem/1.1.0/golem.schema.json

tempDir: target/golem-temp
witDeps:
 - common-wit/deps&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  通过将我们之前的 
  &lt;code&gt;deps.toml&lt;/code&gt; 移动到 
  &lt;code&gt;common-wit&lt;/code&gt; 目录，并在根目录执行 
  &lt;code&gt;wit-deps update&lt;/code&gt;，我们可以将所有需要的 WASI 和 Golem API 填充到这个依赖目录中。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  接下来，我们定义一个用于通过 Golem CLI 构建 MoonBit 组件的模板。在模板中，我们将定义两个配置：一个用于发布构建，另一个用于调试构建。本文中仅展示发布构建的配置。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  它首先指定了一些目录名称，并指定最终的 WASM 文件将放置在哪里：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;templates:moonbit:profiles:release:sourceWit: witgeneratedWit: wit-generatedcomponentWasm: ../target/release/{{ componentName }}.wasmlinkedWasm: ../target/release/{{ componentName }}-linked.wasm&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  这些目录是相对于各个组件子目录（例如归档组件）的，因此我们在这里所说的是，一旦所有组件构建完成，它们都会放置在根目录的 
  &lt;code&gt;target/release&lt;/code&gt; 目录下。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  然后，我们指定构建步骤，步骤与之前部分中描述的相同：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;build:- command: wit-bindgen moonbit wit-generated --ignore-stub --derive-error --derive-showsources:- wit-generatedtargets:- ffi- interface- world- command: moon build --target wasm- command: wasm-tools component embed wit-generated target/wasm/release/build/gen/gen.wasm -o ../target/release/{{ componentName }}.module.wasm --encoding utf16mkdirs:- ../target/release- command: wasm-tools component new ../target/release/{{ componentName }}.module.wasm -o ../target/release/{{ componentName }}.wasm&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  最后，我们可以定义额外的目录，这些目录将在 
  &lt;code&gt;golem app clean&lt;/code&gt; 命令中被清理，还可以定义自定义命令供 
  &lt;code&gt;golem app xxx&lt;/code&gt; 执行：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;clean:- target- wit-generatedcustomCommands:update-deps:- command: wit-deps updatedir: ..regenerate-stubs:- command: wit-bindgen moonbit wit-generated&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  完成这些配置后，我们可以通过在其目录中创建一个 
  &lt;code&gt;golem.yaml&lt;/code&gt; 来将新的 MoonBit 模块添加到这个 Golem 项目中——比如 
  &lt;code&gt;archive/golem.yaml&lt;/code&gt; 和 
  &lt;code&gt;list/golem.yaml&lt;/code&gt;。
 &lt;/div&gt; 
 &lt;div&gt;
  在这些子清单中，我们可以使用上述定义的模板，告诉 Golem 这是一个 MoonBit 模块。在一个应用中，我们可以混合使用不同语言编写的 Golem 组件。
 &lt;/div&gt; 
 &lt;div&gt;
  例如，归档组件的清单将如下所示：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;# IDEA 的架构：
# $schema: https://schema.golem.cloud/app/golem/1.1.0/golem.schema.json
# vscode-yaml 的架构
# yaml-language-server: $schema=https://schema.golem.cloud/app/golem/1.1.0/golem.schema.json

components:
  archive:
    template: moonbit&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;构建组件&lt;/h3&gt; 
 &lt;div&gt;
  通过这一配置，整个应用程序（包括两个已经编写的组件）可以通过简单地执行以下命令进行编译：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;golem app build
&lt;/pre&gt; 
 &lt;div&gt;
  在此之前，我们需要做一些组织工作，因为 
  &lt;code&gt;golem app build&lt;/code&gt; 会对 WIT 定义进行一些转换。这意味着我们之前编写的存根文件位置已经不正确。修复这个问题最简单的方法是删除所有由 
  &lt;code&gt;wit-bindgen&lt;/code&gt; 生成的目录（但首先要备份手写的存根文件！），然后将存根文件复制回新创建的目录中。我们在这里不会进一步讨论这个问题。本文的博客会逐步介绍如何使用 MoonBit 构建 Golem 应用，并且在后期介绍应用清单，但推荐的方法是从一开始就使用应用清单，这样就无需做这些修复了。
 &lt;/div&gt; 
 &lt;h3&gt;初次尝试&lt;/h3&gt; 
 &lt;div&gt;
  运行构建命令后，生成的两个 WASM 文件已经可以与 Golem 一起使用了！尽管它们尚未能够相互通信（因此归档功能还不可用），但我们已经可以使用 Golem 进行尝试了。
 &lt;/div&gt; 
 &lt;div&gt;
  为此，我们可以通过下载最新版本的
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fgolemcloud%2Fgolem%2Freleases%2Ftag%2Fv1.1.0&quot; target=&quot;_blank&quot;&gt;单一可执行文件 Golem&lt;/a&gt; 或使用我们的托管 Golem Cloud 本地启动 Golem 服务。使用 Golem 二进制文件，我们只需使用以下命令在本地启动服务：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;golem start -vv
&lt;/pre&gt; 
 &lt;div&gt;
  然后，从我们项目的根目录，可以使用相同的命令上传这两个编译后的组件：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;$ golem component add --component-name archive
Added new component archive
Component URN:     urn:component:bde2da89-75a8-4adf-953f-33b360c978d0
Component name:    archive
Component version: 0
Component size:    9.35 KiB
Created at:        2025-01-03 15:09:05.166785 UTC
Exports:
  demo:archive-interface/api.{get-all}() -&amp;gt; list&amp;lt;record { name: string, items: list&amp;lt;string&amp;gt; }&amp;gt;
  demo:archive-interface/api.{store}(name: string, items: list&amp;lt;string&amp;gt;)&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  以及
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;$ golem component add --component-name list
Added new component list
Component URN:     urn:component:b6420554-62b5-4902-8994-89c692a937f7
Component name:    list
Component version: 0
Component size:    28.46 KiB
Created at:        2025-01-03 15:09:09.743733 UTC
Exports:
  demo:lst-interface/api.{add}(c: record { id: u64 }, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;
  demo:lst-interface/api.{archive}()
  demo:lst-interface/api.{connect}(email: string) -&amp;gt; tuple&amp;lt;record { id: u64 }, list&amp;lt;string&amp;gt;&amp;gt;
  demo:lst-interface/api.{connected-editors}() -&amp;gt; list&amp;lt;string&amp;gt;
  demo:lst-interface/api.{delete}(c: record { id: u64 }, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;
  demo:lst-interface/api.{disconnect}(c: record { id: u64 }) -&amp;gt; result&amp;lt;_, string&amp;gt;
  demo:lst-interface/api.{get}() -&amp;gt; list&amp;lt;string&amp;gt;
  demo:lst-interface/api.{insert}(c: record { id: u64 }, after: string, value: string) -&amp;gt; result&amp;lt;_, string&amp;gt;
  demo:lst-interface/api.{is-archived}() -&amp;gt; bool
  demo:lst-interface/api.{poll}(c: record { id: u64 }) -&amp;gt; result&amp;lt;list&amp;lt;variant { added(string), deleted(string), inserted(record { after: string, value: string }) }&amp;gt;, string&amp;gt;
  demo:lst-interface/email-query.{deadline}() -&amp;gt; option&amp;lt;u64&amp;gt;
  demo:lst-interface/email-query.{recipients}() -&amp;gt; list&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  我们可以通过首先调用 
  &lt;code&gt;store&lt;/code&gt; 函数，然后调用 
  &lt;code&gt;get-all&lt;/code&gt; 函数，使用 CLI 的 
  &lt;code&gt;worker invoke-and-await&lt;/code&gt; 命令来尝试归档组件：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    $ golem worker invoke-and-await --worker urn:worker:bde2da89-75a8-4adf-953f-33b360c978d0/archive --function &#39;demo:archive-interface/api.{store}&#39; --arg &#39;&quot;list1&quot;&#39; --arg &#39;[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]&#39; Empty result.
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    $ golem worker invoke-and-await --worker urn:worker:bde2da89-75a8-4adf-953f-33b360c978d0/archive --function &#39;demo:archive-interface/api.{get-all}&#39; Invocation results in WAVE format: &#39;[{name: &quot;list1&quot;, items: [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]}]&#39;
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  我们可以通过首先调用 
  &lt;code&gt;store&lt;/code&gt; 函数，然后调用 
  &lt;code&gt;get-all&lt;/code&gt; 函数，使用 CLI 的 
  &lt;code&gt;worker invoke-and-await&lt;/code&gt; 命令来尝试归档组件：
 &lt;/div&gt; 
 &lt;div&gt;
  同样，我们也可以尝试列表组件，记住工作者的名称就是列表的名称：
 &lt;/div&gt; 
 &lt;div&gt;
  当我们尝试运行列表时，出现了错误（如果我们使用调试配置文件 - 使用 
  &lt;code&gt;--build-profile debug&lt;/code&gt;，我们还会看到一个漂亮的调用栈）：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;Failed to create worker b6420554-62b5-4902-8994-89c692a937f7/list6: Failed to instantiate worker -1/b6420554-62b5-4902-8994-89c692a937f7/list6: error while executing at wasm backtrace:
    0: 0x19526 - wit-component:shim!indirect-wasi:clocks/wall-clock@0.2.0-now
    1: 0x414b - &amp;lt;unknown&amp;gt;!demo/lst/interface/wasi/clocks/wallClock.wasmImportNow
    2: 0x4165 - &amp;lt;unknown&amp;gt;!demo/lst/interface/wasi/clocks/wallClock.now
    3: 0x42c1 - &amp;lt;unknown&amp;gt;!demo/lst/src.now
    4: 0x433d - &amp;lt;unknown&amp;gt;!@demo/lst/src.State::update_email_properties
    5: 0x440e - &amp;lt;unknown&amp;gt;!@demo/lst/src.State::new
    6: 0x5d81 - &amp;lt;unknown&amp;gt;!*init*/38&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  问题出在我们正在创建一个全局变量 
  &lt;code&gt;State&lt;/code&gt;，并且在它的构造函数中尝试调用一个 WASI 函数（获取当前的日期和时间）。这个时机太早了；所以我们需要修改 
  &lt;code&gt;State::new&lt;/code&gt; 方法，避免在初始化时调用任何宿主函数：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 创建一个新的空文档编辑状态 pub fn State::new() -&amp;gt; State {let state = {
    document: Document::new(),
    connected: Map::new(),
    last_connection_id: ConnectionId(0),
    archived: false,
    email_deadline: @datetime.DateTime::from_unix_mseconds(0), // 注意：不能在这里使用 now()，因为它会在初始化时运行（由于全局 state 变量）
    email_recipients: [],
  }
  state
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  这样就解决了问题！现在我们可以创建并使用我们可以共同编辑的列表了：
 &lt;/div&gt; 
 &lt;div&gt;
  $ golem worker start --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list7
 &lt;/div&gt; 
 &lt;div&gt;
  Added worker list7
 &lt;/div&gt; 
 &lt;div&gt;
  Worker URN: urn:worker:b6420554-62b5-4902-8994-89c692a937f7/list7
 &lt;/div&gt; 
 &lt;div&gt;
  Component URN: urn:component:b6420554-62b5-4902-8994-89c692a937f7
 &lt;/div&gt; 
 &lt;div&gt;
  Worker name: list7
 &lt;/div&gt; 
 &lt;div&gt;
  $ golem worker invoke-and-await --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list7 --function &#39;demo:lst-interface/api.{connect}&#39; --arg &#39;&quot;demo@vigoo.dev&quot;&#39;
 &lt;/div&gt; 
 &lt;div&gt;
  Invocation results in WAVE format:
 &lt;/div&gt; 
 &lt;div&gt;
  &#39;({id: 1}, [])&#39;
 &lt;/div&gt; 
 &lt;div&gt;
  $ golem worker invoke-and-await --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list7 --function &#39;demo:lst-interface/api.{add}&#39; --arg &#39;{ id: 1}&#39; --arg &#39;&quot;a&quot;&#39; Invocation results in WAVE format:
 &lt;/div&gt; 
 &lt;div&gt;
  ok
 &lt;/div&gt; 
 &lt;div&gt;
  $ golem worker invoke-and-await --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list7 --function &#39;demo:lst-interface/api.{add}&#39; --arg &#39;{ id: 1}&#39; --arg &#39;&quot;b&quot;&#39;
 &lt;/div&gt; 
 &lt;div&gt;
  Invocation results in WAVE format:
 &lt;/div&gt; 
 &lt;div&gt;
  ok
 &lt;/div&gt; 
 &lt;div&gt;
  $ golem worker invoke-and-await --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list7 --function &#39;demo:lst-interface/api.{connect}&#39; --arg &#39;&quot;demo2@vigoo.dev&quot;&#39;
 &lt;/div&gt; 
 &lt;div&gt;
  Invocation results in WAVE format: &#39;({id: 2}, [&quot;a&quot;, &quot;b&quot;])&#39;
 &lt;/div&gt; 
 &lt;h3&gt;Worker 到 Worker 通信&lt;/h3&gt; 
 &lt;h4&gt;列表调用归档&lt;/h4&gt; 
 &lt;div&gt;
  我们首先要设置的 worker 到 worker 通信是列表组件调用归档组件——基本上，当我们在列表中调用 
  &lt;code&gt;archive()&lt;/code&gt; 时，它需要在一个单例的归档 worker 中调用 
  &lt;code&gt;store&lt;/code&gt; 函数，并将数据发送过去。
 &lt;/div&gt; 
 &lt;div&gt;
  第一步是简单地在列表的应用清单中声明这个依赖关系：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;components:list:template: moonbitdependencies:list:- type: wasm-rpctarget: archive
&lt;/pre&gt; 
 &lt;div&gt;
  在此之后运行 
  &lt;code&gt;golem app build&lt;/code&gt; 会进行许多新的构建步骤——包括生成和编译一些 Rust 源代码，这些代码在 Golem 的下一个版本中将不再需要。
 &lt;/div&gt; 
 &lt;div&gt;
  我们不会在本文中详细讨论为 worker 到 worker 通信生成的内容——重要的是，在做出这个修改并运行一次构建后，我们可以在列表组件的 MoonBit 包中导入我们归档组件生成的 stub：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;code class=&quot;language-JSON&quot;&gt;{&quot;import&quot;: [&quot;suiyunonghen/datetime&quot;,{ &quot;path&quot; : &quot;demo/lst/interface/wasi/clocks/wallClock&quot;, &quot;alias&quot; : &quot;wallClock&quot; },{ &quot;path&quot; : &quot;demo/lst/interface/demo/archive_stub/stubArchive&quot;, &quot;alias&quot;: &quot;stubArchive&quot; },{ &quot;path&quot; : &quot;demo/lst/interface/golem/rpc/types&quot;, &quot;alias&quot;: &quot;rpcTypes&quot; }]}&lt;/code&gt;
&lt;/pre&gt; 
 &lt;div&gt;
  然后，我们可以将以下代码添加到我们的归档函数中，用来调用远程 worker：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;&lt;code class=&quot;language-Rust&quot;&gt;let archive_component_id = &quot;bde2da89-75a8-4adf-953f-33b360c978d0&quot;; &lt;em&gt;// TODO&lt;/em&gt;let archive = @stubArchive.Api::api({ value: &quot;urn:worker:\{archive_component_id}/archive&quot;});let name = &quot;TODO&quot;; &lt;em&gt;// TODO&lt;/em&gt; 
archive.blocking_store(name, self.document.iter().to_array());&lt;/code&gt;
&lt;/pre&gt; 
 &lt;div&gt;
  在第 2 行，我们通过使用组件 ID 和 worker 名称来构建远程接口（在 Golem 的下一个版本中，使用组件名称将使这个过程更加简化）。在第 5 行，我们调用远程的 
  &lt;code&gt;store&lt;/code&gt; 函数。
 &lt;/div&gt; 
 &lt;div&gt;
  但是，缺少两件事：
 &lt;/div&gt; 
 &lt;ol&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    我们不应该硬编码归档组件的 ID，因为它是在组件首次上传到 Golem 时自动生成的；
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    我们需要知道我们自己的 worker 名称，它将作为列表的名称。
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;div&gt;
  这两者的解决方法是使用环境变量——Golem 会自动将 
  &lt;code&gt;GOLEM_WORKER_NAME&lt;/code&gt; 环境变量设置为 worker 的名称，我们也可以通过自定义环境变量手动提供值给 worker。这使得我们可以从外部注入组件 ID（直到 Golem 1.2 版本添加了更复杂的配置功能）。
 &lt;/div&gt; 
 &lt;div&gt;
  我们已经看到如何使用 WASI 查询当前的日期/时间；我们可以使用另一个 WASI 接口来获取环境变量。因此，我们再次将一个导入添加到我们的 WIT 文件：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;import wasi:cli/environment@0.2.0;
&lt;/pre&gt; 
 &lt;div&gt;
  然后运行 
  &lt;code&gt;golem app build&lt;/code&gt; 以重新生成绑定，并在 
  &lt;code&gt;list/src&lt;/code&gt; 的 MoonBit 包中导入它：
 &lt;/div&gt; 
 &lt;pre&gt;&amp;nbsp;{ &quot;path&quot; : &quot;demo/lst/interface/wasi/cli/environment&quot;, &quot;alias&quot;: &quot;environment&quot; }
&lt;/pre&gt; 
 &lt;div&gt;
  接着，我们实现一个帮助函数来获取特定的环境变量：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 使用 WASI 获取环境变量 fn get_env(key : String) -&amp;gt; String? {
  @environment.get_environment()
  .iter()
  .find_first(fn(pair) {
    pair.0 == key
  })
  .map(fn(pair) {
    pair.1
  })
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  我们可以用这个函数来获取 worker 的名称和归档组件 ID：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;let archive_component_id = get_env(&quot;ARCHIVE_COMPONENT_ID&quot;).or(&quot;unknown&quot;);
// ...let name = get_env(&quot;GOLEM_WORKER_NAME&quot;).or(&quot;unknown&quot;);&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  当启动列表 worker 时，我们必须显式指定 
  &lt;code&gt;ARCHIVE_COMPONENT_ID&lt;/code&gt;：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;golem worker start --component urn:component:b6420554-62b5-4902-8994-89c692a937f7 --worker-name list10 --env &quot;ARCHIVE_COMPONENT_ID=bde2da89-75a8-4adf-953f-33b360c978d0&quot;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  这样我们就可以尝试连接到列表，添加一些项目，然后调用归档，并最终在归档 worker 上调用 
  &lt;code&gt;get-all&lt;/code&gt;——我们可以看到远程过程调用是有效的！
 &lt;/div&gt; 
 &lt;h3&gt;列表与电子邮件组件通信&lt;/h3&gt; 
 &lt;div&gt;
  在本示例中，我们要实现的第三个组件是负责在某个截止日期后发送电子邮件的组件。设置组件和 worker-to-worker 通信与前面演示的方式完全相同。应用清单支持循环依赖，所以我们可以指定列表依赖于电子邮件（通过 
  &lt;code&gt;wasm-rpc&lt;/code&gt;），同时电子邮件也依赖于列表（同样通过 
  &lt;code&gt;wasm-rpc&lt;/code&gt;）。我们需要在两个方向上进行通信。
 &lt;/div&gt; 
 &lt;div&gt;
  为了等待截止日期，我们将使用 WASI 单调时钟接口的 
  &lt;code&gt;subscribe-instant&lt;/code&gt; 函数。
 &lt;/div&gt; 
 &lt;div&gt;
  下面是 
  &lt;code&gt;send-email&lt;/code&gt; 函数的 MoonBit 实现（我们已在 
  &lt;code&gt;email.wit&lt;/code&gt; 文件中定义该函数）：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 存储电子邮件发送者的配置信息 pub(all) struct Email {
  list_worker_urn : String
}

///| 执行发送电子邮件的循环 pub fn run(self : Email) -&amp;gt; Unit {while true {match self.get_deadline() {Some(epoch_ms) =&amp;gt; {let now = @wallClock.now()let now_ms = now.seconds * 1000 +
          (now.nanoseconds.reinterpret_as_int() / 1000000).to_uint64()let duration_ms = epoch_ms.reinterpret_as_int64() -
          now_ms.reinterpret_as_int64()if duration_ms &amp;gt; 0 {sleep(duration_ms.reinterpret_as_uint64())
        } else {send_emails(self.get_recipients())
        }continue
      }None =&amp;gt; break
    }
  }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  我们再次使用 
  &lt;code&gt;wallClock&lt;/code&gt; 接口来查询当前时间，并根据从相关列表 worker 获取的截止日期计算等待的时长。
  &lt;code&gt;get_deadline&lt;/code&gt; 和 
  &lt;code&gt;get_recipients&lt;/code&gt; 方法则是利用 Golem 的 worker-to-worker 通信进行的。
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 获取与列表 worker 关联的当前截止日期 fn get_deadline(self : Email) -&amp;gt; UInt64? {let api = @stubLst.EmailQuery::email_query({ value: self.list_worker_urn })
  api.blocking_deadline()
}

///| 获取与列表 worker 关联的当前收件人列表 fn get_recipients(self : Email) -&amp;gt; Array[String] {let api = @stubLst.EmailQuery::email_query({ value: self.list_worker_urn })
  api.blocking_recipients()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  接下来是休眠与发送电子邮件的部分：
 &lt;/div&gt; 
 &lt;h3&gt;1. &lt;strong&gt;休眠功能&lt;/strong&gt;&lt;/h3&gt; 
 &lt;div&gt;
  我们可以通过调用 
  &lt;code&gt;subscribe-duration&lt;/code&gt; 函数来获取一个可轮询对象，并在该对象上进行轮询，从而实现休眠。由于我们只传递了一个单一的轮询对象给列表，它将在目标截止日期到达时返回：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 休眠指定的毫秒数 fn sleep(ms : UInt64) -&amp;gt; Unit {let ns = ms * 1000000let pollable = @monotonicClock.subscribe_duration(ns)let _ = @poll.poll([pollable])
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;2. &lt;strong&gt;列表中的非阻塞调用&lt;/strong&gt;&lt;/h3&gt; 
 &lt;div&gt;
  在列表的一方，我们不希望阻塞，直到电子邮件发送循环运行完成，因为这会阻止列表接收新的请求。为此，生成的 RPC 存根支持这一点，我们只需使用非阻塞版本的 API 类型：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;if not(self.email_worker_started) {let email_component_id = get_env(&quot;EMAIL_COMPONENT_ID&quot;).or(&quot;unknown&quot;);let name = get_env(&quot;GOLEM_WORKER_NAME&quot;).or(&quot;unknown&quot;)let self_component_id = get_env(&quot;GOLEM_COMPONENT_ID&quot;).or(&quot;unknown&quot;)let api = @stubEmail.Api::api({ value: &quot;urn:worker:\{email_component_id}:\{name}&quot;} )
  api.send_email({ value: &quot;urn:worker:\{self_component_id}:\{name}&quot;} )self.email_worker_started = true;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h2&gt;发送电子邮件&lt;/h2&gt; 
 &lt;div&gt;
  发送实际电子邮件稍微复杂一些，因为 MoonBit 生态系统中目前没有 HTTP 客户端库。但 Golem 实现了 WASI HTTP 接口，因此我们可以通过 WIT 导入 WASI HTTP，生成绑定，然后使用这些绑定从 MoonBit 代码中向第三方提供商发送电子邮件。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  在本示例中，我们将使用 
  &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsendgrid.com%2Fen-us&quot; target=&quot;_blank&quot;&gt;SendGrid&lt;/a&gt; 作为电子邮件服务提供商，这意味着我们需要向 
  &lt;code&gt;https://api.sendgrid.com/v3/mail/send&lt;/code&gt; 发送一个 HTTP POST 请求，并附上已配置的授权头和描述电子邮件发送请求的 JSON 正文。
 &lt;/div&gt; 
 &lt;div&gt;
  首先，我们定义一些常量和函数，用于组装请求的各个部分：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;const AUTHORITY : String = &quot;api.sendgrid.com&quot;const PATH : String = &quot;/v3/mail/send&quot;
type! HttpClientError String&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  邮件正文采用 JSON 格式，可以使用 MoonBit 内建的 JSON 字面量功能构建。然而，在 WASI HTTP 接口中，我们必须将其写出为字节数组。MoonBit 字符串是 UTF-16 编码的，而 SendGrid 需要 UTF-8 编码的负载。因此我们编写了一个简单的函数，当字符串中包含非 ASCII 字符时，抛出错误：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 如果字符串中包含非 ASCII 字符，则将其转换为 ASCII 字节数组，否则失败 fn string_to_ascii(
  what : String,
  value : String
) -&amp;gt; FixedArray[Byte]!HttpClientError {let result = FixedArray::makei(value.length(), fn(_) { b&#39; &#39; })for i, ch in value {if ch.to_int() &amp;lt; 256 {
      result[i] = ch.to_int().to_byte()
    } else {
      raise HttpClientError(&quot;The \{what} contains non-ASCII characters&quot;)
    }
  }
  result
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  有了这个，我们可以构建请求负载，并从环境变量中读取 SendGrid API 密钥：
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;///| 构建 SendGrid 发送邮件的 JSON 正文，并将其转换为 ASCII 字节数组 fn payload(recipients : Array[String]) -&amp;gt; FixedArray[Byte]!HttpClientError {let email_addresses = recipients
    .iter()
    .map(fn(email) { { &quot;email&quot;: email, &quot;name&quot;: email } })
    .to_array()
    .to_json()let from : Json = { &quot;email&quot;: &quot;demo@vigoo.dev&quot;, &quot;name&quot;: &quot;Daniel Vigovszky&quot; }let json : Json = {&quot;personalizations&quot;: [{ &quot;to&quot;: email_addresses, &quot;cc&quot;: [], &quot;bcc&quot;: [] }],&quot;from&quot;: from,&quot;subject&quot;: &quot;Collaborative list editor warning&quot;,&quot;content&quot;: [
      {&quot;type&quot;: &quot;text/html&quot;,&quot;value&quot;: &quot;&amp;lt;p&amp;gt;The list opened for editing has not been changed in the last 12 hours&amp;lt;/p&amp;gt;&quot;,
      },
    ],
  }let json_str = json.to_string()
  string_to_ascii!(&quot;constructed JSON body&quot;, json_str)
}

///| 获取 SENDGRID_API_KEY 环境变量的值，并转换为 ASCII 字节数组 fn authorization_header() -&amp;gt; FixedArray[Byte]!HttpClientError {let key_str = @environment.get_environment()
    .iter()
    .find_first(fn(pair) { pair.0 == &quot;SENDGRID_API_KEY&quot; })
    .map(fn(pair) { pair.1 })
    .unwrap()
  string_to_ascii!(&quot;provided authorization header via SENDGRID_API_KEY&quot;, key_str,
  )
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  这样就可以构建完整的电子邮件请求，并向 SendGrid 发送邮件了！
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  下一步是创建用于发送 HTTP 请求的数据结构。在 WASI HTTP 中，出站请求被建模为 WIT 资源，这意味着我们必须通过构造函数构建它们，并调用各种方法来设置请求的属性。所有这些方法都有一个 
  &lt;code&gt;Result&lt;/code&gt; 类型的返回值，因此我们的代码将会比较冗长：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;let headers = @httpTypes.Fields::fields()
headers
  .append(&quot;Authorization&quot;, authorization_header!())
  .map_err(fn(error) {HttpClientError(&quot;设置 Authorization 头部失败: \{error}&quot;)
  })
  .unwrap_or_error!()

let request = @httpTypes.OutgoingRequest::outgoing_request(headers)
request
  .set_authority(Some(AUTHORITY))
  .map_err(fn(_) { HttpClientError(&quot;设置请求 authority 失败&quot;) })
  .unwrap_or_error!()
request
  .set_method(@httpTypes.Method::Post)
  .map_err(fn(_) { HttpClientError(&quot;设置请求方法失败&quot;) })
  .unwrap_or_error!()
request
  .set_path_with_query(Some(PATH))
  .map_err(fn(_) { HttpClientError(&quot;设置请求路径失败&quot;) })
  .unwrap_or_error!()
request
  .set_scheme(Some(@httpTypes.Scheme::Https))
  .map_err(fn(_) { HttpClientError(&quot;设置请求协议失败&quot;) })
  .unwrap_or_error!()

let outgoing_body = request
  .body()
  .map_err(fn(_) { HttpClientError(&quot;获取请求体失败&quot;) })
  .unwrap_or_error!()

let stream = outgoing_body
  .write()
  .map_err(fn(_) {HttpClientError(&quot;打开请求体流失败&quot;)
  })
  .unwrap_or_error!()

let _ = stream
  .blocking_write_and_flush(payload!(recipients))
  .map_err(fn(error) {HttpClientError(&quot;写入请求体失败: \{error}&quot;)
  })
  .unwrap_or_error!()

let _ = outgoing_body
  .finish(None)
  .map_err(fn(_) { HttpClientError(&quot;关闭请求体失败&quot;) })
  .unwrap_or_error!()&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  此时，我们已经初始化了 
  &lt;code&gt;request&lt;/code&gt; 变量，包含了发送 HTTP 请求所需的所有内容，接下来我们可以调用 
  &lt;code&gt;handle&lt;/code&gt; 函数来发起 HTTP 请求：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;let future_incoming_response = @outgoingHandler.handle(request, None)
  .map_err(fn(error) { HttpClientError(&quot;发送请求失败: \{error}&quot;) })
  .unwrap_or_error!()&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  发送请求是一个异步操作，所得到的结果只是一个处理未来值的句柄，我们需要以某种方式等待这个结果。在这个示例中，由于我们不需要并行执行其他任务，所以我们编写了一个循环，等待结果并检查错误：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;while true {match future_incoming_response.get() {Some(Ok(Ok(response))) =&amp;gt; {let status = response.status()if status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300 {break
      } else {
        raise HttpClientError(&quot;HTTP 请求返回状态码 \{status}&quot;)
      }
    }Some(Ok(Err(code))) =&amp;gt;
      raise HttpClientError(&quot;HTTP 请求失败，错误代码: \{code}&quot;)Some(Err(_)) =&amp;gt; raise HttpClientError(&quot;HTTP 请求失败&quot;)None =&amp;gt; {let pollable = future_incoming_response.subscribe()let _ = @poll.poll([pollable])
    }
  }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  在这个例子中我们忽略了响应体，但在其他应用中，可以使用响应来打开一个输入流并从中读取数据块。
 &lt;/div&gt; 
 &lt;div&gt;
  至此，我们已经实现了使用 Golem 提供的 WASI HTTP 最简单的方式调用 SendGrid API 发送电子邮件。
 &lt;/div&gt; 
 &lt;h2&gt;调试&lt;/h2&gt; 
 &lt;div&gt;
  当以调试模式编译时（使用 
  &lt;code&gt;golem app build --build-profile debug&lt;/code&gt;），Golem 会在 MoonBit 组件出现问题时显示详细的堆栈追踪。另一种观察 worker 的有用方法是，在其中写入日志，可以通过 
  &lt;code&gt;golem worker connect&lt;/code&gt; 或 Golem 控制枱实时查看（或稍后查询）。
 &lt;/div&gt; 
 &lt;div&gt;
  在 MoonBit 中编写日志的最佳方式是使用 WASI 日志接口。我们可以像往常一样在 WIT 文件中导入它：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-JSON&quot;&gt;import wasi:logging/logging;&lt;/code&gt;&lt;/pre&gt; 
 &lt;div&gt;
  然后将其添加到我们的 MoonBit 包：
 &lt;/div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-JSON&quot;&gt;&quot;demo/archive/interface/wasi/logging/logging&quot;&lt;/code&gt;&lt;/pre&gt; 
 &lt;div&gt;
  接下来可以在应用逻辑中写出不同级别的日志消息：
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;code&gt;let recipients = self.get_recipients();
@logging.log(@logging.Level::INFO, &quot;&quot;, &quot;发送电子邮件到以下收件人: \{recipients}&quot;)
match send_emails?(recipients) {Ok(_) =&amp;gt; @logging.log(@logging.Level::INFO, &quot;&quot;, &quot;发送电子邮件成功&quot;)Err(error) =&amp;gt; @logging.log(@logging.Level::ERROR, &quot;&quot;, &quot;发送电子邮件失败: \{error}&quot;)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
 &lt;h2&gt;结论&lt;/h2&gt; 
 &lt;div&gt;
  MoonBit 是一种非常强大且富有表现力的新语言，看起来非常适合用于为 Golem 开发应用程序。生成的 WASM 二进制文件非常小——这个应用程序只有几十 KB（仅仅增加了生成的 Rust 存根代码，但这些很快就会消失）。虽然语言中有一些地方感觉有些不便——但可能只是个人口味问题——主要是描述 MoonBit 包的 JSON 文件、匿名函数语法和内置格式化器的组织方式。我相信这些，特别是工具链，未来会有很大改进。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  对于 WASM 和组件模型的支持仍处于初期阶段——但已经可以工作。它需要很多手动步骤，但幸运的是，Golem 的应用清单功能可以为我们自动化大部分工作。尽管如此，
  &lt;code&gt;wit-bindgen moonbit&lt;/code&gt; 生成的目录结构刚开始时确实让人感到有些压倒性。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  我希望 MoonBit 生态系统能在不久的将来得到一些有用的库，例如方便的 WASI 和 WASI HTTP 封装（以及 Golem 特定的封装）、字符串编码工具等。由于目前库还不多，因此很容易找到一些有用的工作内容。
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328673</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328673</guid>
            <pubDate>Mon, 06 Jan 2025 09:18:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>鸿蒙应用签名实操及机制探究</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;本文对鸿蒙公开资料进行了深入分析和解读，梳理了鸿蒙单框架应用的签名机制，拆解每一步的实操过程和背后的实现原理，并对源码分析整理签名的校验机制。从中管中窥豹，探究鸿蒙系统的安全设计思路，希望能给从事鸿蒙研发的同学提供一些借鉴。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-9dae4d31030042e93a3f1823ccaa012e35f.jpg&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;背景&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;华为鸿蒙单框架操作系统 HarmonyOS NEXT 已于 2024 年 10 月 23 日正式发布 Release 版。HarmonyOS NEXT 仅支持鸿蒙原生应用，不再兼容安卓。本文对鸿蒙公开资料进行了深入分析和解读，梳理了鸿蒙单框架应用的签名机制，拆解每一步的实操过程和背后的实现原理，并对源码分析整理签名的校验机制。从中管中窥豹，探究鸿蒙系统的安全设计思路，希望能给从事鸿蒙研发的同学提供一些借鉴。&lt;/p&gt; 
&lt;p&gt;成文过程中特别参考 OpenHarmony 5.0.0-Release 版的文档和源码，详见&lt;a href=&quot;https://gitee.com/openharmony/docs/blob/OpenHarmony-5.0.0-Release/zh-cn/release-notes/OpenHarmony-v5.0.0-release.md&quot;&gt;openharmony&lt;/a&gt;。&lt;/p&gt; 
&lt;ol start=&quot;2&quot;&gt; 
 &lt;li&gt;签名机制&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;签名相关的代码在&lt;a href=&quot;https://gitee.com/openharmony/developtools_hapsigner/tree/OpenHarmony-v5.0.0-Release/&quot;&gt;developtools_hapsigner&lt;/a&gt;仓库里，签名流程梳理如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//c754ee84ef4d59dd6e6c798ad1eeab70.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;签名步骤可按如下分组：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;生成开发者签名证书，包括①、②、③。&lt;/li&gt; 
 &lt;li&gt;生成 Profile 文件，包括④、⑤。&lt;/li&gt; 
 &lt;li&gt;生成签名的 App，包括⑥、⑦。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h3&gt;2.1 生成开发者签名证书&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;① 生成开发者公私钥&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过华为的 DevEco-Studio 工具可以直接生成包含开发者公私钥的 p12 文件（详见&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fharmonyos-guides-V5%2Fide-signing-V5%23section462703710326&quot; target=&quot;_blank&quot;&gt;具体操作步骤&lt;/a&gt;。）&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//628a4e678f50e8fe26d177c0f26c81aa.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;笔者示例生成的 p12 文件（保存为 my.p12）是标准的 PKCS#12 格式（定义在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc7292&quot; target=&quot;_blank&quot;&gt;RFC 7292&lt;/a&gt;），用来存储一组或多组公钥证书（里面包含公钥）和其对应的私钥（用 localKeyID 字段进行匹配公私钥的匹配），使用 ASN.1 来定义其数据结构，并采用 DER 编码规则将这些结构编码为二进制形式。&lt;/p&gt; 
&lt;p&gt;可以通过 openssl 命令解析其结构，或者直接查看公钥证书和私钥信息：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl asn1parse -in my.p12 -inform DER  //解码 DER 和解析 ASN.1
openssl pkcs12 -info -in my.p12  //查看公钥证书和私钥信息
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;笔者用于示例生成的 p12 文件里包含的公钥证书如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-----BEGIN CERTIFICATE-----
MIIBqTCCAU+gAwIBAgIIKG2ih6j2GSswCgYIKoZIzj0EAwIwSTEJMAcGA1UEBhMA
MQkwBwYDVQQIEwAxCTAHBgNVBAcTADEJMAcGA1UEChMAMQkwBwYDVQQLEwAxEDAO
BgNVBAMTB3Rlc3RzY3IwHhcNMjQwOTIzMTI1NjM3WhcNNDkwOTE3MTI1NjM3WjBJ
MQkwBwYDVQQGEwAxCTAHBgNVBAgTADEJMAcGA1UEBxMAMQkwBwYDVQQKEwAxCTAH
BgNVBAsTADEQMA4GA1UEAxMHdGVzdHNjcjBZMBMGByqGSM49AgEGCCqGSM49AwEH
A0IABD28s78rF8+X1JWgkQcfHB2Gy20MCT51Oue6eG5ZbPsUKlZrPx0aRX0einL2
E5WsE3st0zI4yvj0KzhdEwksCWCjITAfMB0GA1UdDgQWBBRtCEWMjEr+bnXoAqSC
fjmk1btJQDAKBggqhkjOPQQDAgNIADBFAiAAiMtQXgCMUxrKtaPKvGqllswi1FRU
h1brCAbJ1t81FgIhAMXbzmeJlA7/zxZDULLRW0rCY6CU3KMDHr8N38EmuDug
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;公钥证书的表示是遵循 Privacy Enhanced Mail（PEM）协议（定义在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc7468&quot; target=&quot;_blank&quot;&gt;RFC 7468&lt;/a&gt;）的文本文件，其格式如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a0407cdc320220baae7aabddef8d8452.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;PEM 文件的 label 用于指示文件的内容类型。以下是一些常见的 PEM header 和 footer（后面会陆续见到）：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4b7af5d1667ba2163cae43780d05c23a.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;解析具体公钥证书信息可以采用如下命令（将公钥证书以文本的形式保存为 my.pem 文件）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl x509 -in my.pem -text -noout
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;解析得到如下输出（重要部分加了注释）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Certificate:
    Data:
        Version: 3 (0x2) //证书的版本号
        Serial Number: 2913163237517564203 (0x286da287a8f6192b) //证书的序列号，用于唯一标识证书
        Signature Algorithm: ecdsa-with-SHA256
        Issuer: C = , ST = , L = , O = , OU = , CN = testscr //证书颁发者的信息
        Validity
            Not Before: Sep 23 12:56:37 2024 GMT //证书的开始有效期
            Not After : Sep 17 12:56:37 2049 GMT //证书的结束有效期
        Subject: C = , ST = , L = , O = , OU = , CN = testscr //证书持有者的信息
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey //公钥算法，这里是椭圆曲线
                Public-Key: (256 bit) //公钥的位数，这里是 256
                pub:// 证书持有者的公钥值，以十六进制表示
                    04:3d:bc:b3:bf:2b:17:cf:97:d4:95:a0:91:07:1f:
                    1c:1d:86:cb:6d:0c:09:3e:75:3a:e7:ba:78:6e:59:
                    6c:fb:14:2a:56:6b:3f:1d:1a:45:7d:1e:8a:72:f6:
                    13:95:ac:13:7b:2d:d3:32:38:ca:f8:f4:2b:38:5d:
                    13:09:2c:09:60
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Subject Key Identifier: //证书持有者的标识
                6D:08:45:8C:8C:4A:FE:6E:75:E8:02:A4:82:7E:39:A4:D5:BB:49:40
    Signature Algorithm: ecdsa-with-SHA256
    Signature Value: //证书的数字签名值
        30:45:02:20:00:88:cb:50:5e:00:8c:53:1a:ca:b5:a3:ca:bc:
        6a:a5:96:cc:22:d4:54:54:87:56:eb:08:06:c9:d6:df:35:16:
        02:21:00:c5:db:ce:67:89:94:0e:ff:cf:16:43:50:b2:d1:5b:
        4a:c2:63:a0:94:dc:a3:03:1e:bf:0d:df:c1:26:b8:3b:a0
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;公钥信息（包括公钥算法、公钥位数、公钥值等）属于结构化数据并且较长，不利于识别和比较，所以需要用一个简短的字符串来标识公钥唯一性。常用做法是使用公钥指纹（Public Key Pin，也叫公钥 Pin），计算方式是对 DER 编码的公钥进行 SHA-256 计算并进行 Base64 编码。&lt;/p&gt; 
&lt;p&gt;这里需要注意的是，在 X509 扩展字段里包括了 Subject Key Identifier（SKID）字段，也是证书持有者的标识。那标识公钥的唯一性为什么不直接使用证书里自带的 SKID，还要自己算一遍呢，根据&lt;a href=&quot;https://my.oschina.net/meituantech/blog/hihu.com/org/mei-tuan-dian-ping-ji-shu-tuan-dui/activities&quot;&gt;RFC 3280-4.2.1.2&lt;/a&gt;章节中对 SKID 的定义：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;For CA certificates, subject key identifiers SHOULD be derived from the public key or a method that generates unique values. Two common methods for generating key identifiers from the public key are: (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bits). (2) The keyIdentifier is composed of a four bit type field with the value 0100 followed by the least significant 60 bits of the SHA-1 hash of the value of the BIT STRING subjectPublicKey (excluding the tag, length, and number of unused bit string bits).&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;SKID 的计算可以通过公钥得到，但计算方式并不唯一，也可以通过任意的算法得到，只要保证唯一性就可以了。定义里推荐了两种基于 SHA-1 的算法，openssl 采用的算法（详见&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenssl%2Fopenssl%2Fblob%2Fmaster%2Fcrypto%2Fx509%2Fv3_skid.c&quot; target=&quot;_blank&quot;&gt;v3_skid.c 的 ossl_x509_pubkey_hash&lt;/a&gt;函数）是对 DER 编码的公钥进行 SHA-1 计算。&lt;/p&gt; 
&lt;p&gt;如果采用 SKID 来进行公钥的唯一性校验，那么攻击者可以伪造一个证书，里面的 SKID 和你的一样（SHA-1 碰撞，或者直接照抄一下也行），这样的证书也是合法的，就可以轻易绕过对公钥的校验。所以 SKID 一般只用于在证书链中寻找父子关系，并不用于公钥的唯一性标识。另外，还有 Authority Key Identifier（AKID）字段用于标识证书的颁发者。当验证一个证书链时，验证程序会检查每个证书的 AKID 和上一个证书的 SKID 是否匹配，确保它们形成一个连续的信任链。&lt;/p&gt; 
&lt;p&gt;使用如下命令可以从 PEM 协议的公钥证书中提取 PEM 协议的公钥：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl x509 -in my.pem -pubkey -noout
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;输出如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-----BEGIN PUBLIC KEY----- //公钥标头
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE95zFs5cFHauzIYEuuw3g2R75a1ir
qEW0JWP9qAKkyVCizN0nnzcn/Fo5oeSZR1iPUnJvjlnpNvZL9BcQbLqa7g==
-----END PUBLIC KEY-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;使用如下命令可以继续转换成 DER 编码并计算 SHA-256 和 Base64 编码：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;所以结合使用如下命令可以直接从符合 PEM 协议的公钥证书文件中得到对应的公钥指纹：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl x509 -in my.pem -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;最终笔者示例的公钥证书计算得到的公钥指纹为：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fzyRjPvTPElBAj0VlYlVA74M3RMtUh5ljKbOYf1NDA0=
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;② 生成证书签名请求&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;同样通过 DevEco-Studio 可以直接生成证书签名请求 Certificate Signing Request（CSR）文件（详见&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fharmonyos-guides-V5%2Fide-signing-V5%23section462703710326&quot; target=&quot;_blank&quot;&gt;具体操作步骤&lt;/a&gt;）。得到的 CSR 内容示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-----BEGIN NEW CERTIFICATE REQUEST----- //CSR 标头
MIIBMzCB2wIBADBJMQkwBwYDVQQGEwAxCTAHBgNVBAgTADEJMAcGA1UEBxMAMQkw
BwYDVQQKEwAxCTAHBgNVBAsTADEQMA4GA1UEAxMHdGVzdHNjcjBZMBMGByqGSM49
AgEGCCqGSM49AwEHA0IABD28s78rF8+X1JWgkQcfHB2Gy20MCT51Oue6eG5ZbPsU
KlZrPx0aRX0einL2E5WsE3st0zI4yvj0KzhdEwksCWCgMDAuBgkqhkiG9w0BCQ4x
ITAfMB0GA1UdDgQWBBRtCEWMjEr+bnXoAqSCfjmk1btJQDAKBggqhkjOPQQDAgNH
ADBEAiAlzkRf0AHKh59/deFGo/4JHQRSbw6P+Q7qsiiMMWHT7wIgGugWrCm7tFLh
mRjEEyJNOpen9kfhyOanSRrwtBlEFc0=
-----END NEW CERTIFICATE REQUEST-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;生成的 CSR 文件是标准的 PKCS#10 格式（定义在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc2986&quot; target=&quot;_blank&quot;&gt;RFC 2986&lt;/a&gt;），用于向证书颁发机构（CA）请求签发数字证书的文件，包含申请者的公钥和一些身份信息，这些信息将包含在颁发的证书中。可以看到 CSR 文件也是遵循 PEM 协议的，可以如下命令解析 CSR 文件的内容（保存为 my.csr 文件）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl req -text -noout -verify -in my.csr
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;输出示例（重要部分加了注释）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Certificate request self-signature verify OK //表明 CSR 的自签名已成功验证
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: C = , ST = , L = , O = , OU = , CN = testscr //证书申请者的信息
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub: //证书申请者的公钥值，和上面 my.pem 里的公钥值相同
                    04:3d:bc:b3:bf:2b:17:cf:97:d4:95:a0:91:07:1f:
                    1c:1d:86:cb:6d:0c:09:3e:75:3a:e7:ba:78:6e:59:
                    6c:fb:14:2a:56:6b:3f:1d:1a:45:7d:1e:8a:72:f6:
                    13:95:ac:13:7b:2d:d3:32:38:ca:f8:f4:2b:38:5d:
                    13:09:2c:09:60
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        Attributes:
            Requested Extensions:
                X509v3 Subject Key Identifier: //证书申请者的标识
                    6D:08:45:8C:8C:4A:FE:6E:75:E8:02:A4:82:7E:39:A4:D5:BB:49:40
    Signature Algorithm: ecdsa-with-SHA256
    Signature Value:
        30:44:02:20:25:ce:44:5f:d0:01:ca:87:9f:7f:75:e1:46:a3:
        fe:09:1d:04:52:6f:0e:8f:f9:0e:ea:b2:28:8c:31:61:d3:ef:
        02:20:1a:e8:16:ac:29:bb:b4:52:e1:99:18:c4:13:22:4d:3a:
        97:a7:f6:47:e1:c8:e6:a7:49:1a:f0:b4:19:44:15:cd
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意到其中证书申请者的公钥值和上面 p12 文件中的公钥值是一样的，说明 CSR 中包含了我们的公钥信息。使用如下命令也可以直接从 CSR 文件中得到公钥指纹：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl req -in my.csr -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -base64
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;示例生成的 CSR 计算得到的公钥指纹为：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fzyRjPvTPElBAj0VlYlVA74M3RMtUh5ljKbOYf1NDA0=
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;和通过公钥证书计算得到的公钥指纹相同。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;③ 生成开发者签名叶子证书&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;证书的作用可以抽象概括为：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;颁发者（Issuer）说：持有者（Subject）的公钥是某某某。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;证书一般分为三级：根证书（Root Certificate）、中间证书（Intermediate Certificate）、叶子证书（Leaf Certificate）。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;叶子证书由中间证书颁发（即叶子证书的 Issuer+AKID 和中间证书的 Subject+SKID 相同）&lt;/li&gt; 
 &lt;li&gt;中间证书由根证书颁发（即中间证书的 Issuer+AKID 和根证书的 Subject+SKID 相同）&lt;/li&gt; 
 &lt;li&gt;根证书由自己颁发（也就是自签名，根证书的 Issuer 和 Subject 相同）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7d5802721dcd02ceddbe94f6656f99c8.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;我们需要的是用于给我们 App 签名的开发者签名叶子证书，这需要华为的开发者签名中间证书来帮我们颁发。叶子证书分为调试证书和发布证书，我们以发布证书为例（详见具体&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fapp%2Fagc-help-add-releasecert-0000001946273961&quot; target=&quot;_blank&quot;&gt;操作步骤&lt;/a&gt;）：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//8a40b139fb614034312d6e9678c2e52a.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;需要上传我们的 CSR 文件，得到的证书文件内容示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-----BEGIN CERTIFICATE-----
MIICGjCCAaGgAwIBAgIIShhpn519jNAwCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE
AwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDMxNjAzMDQzOVoXDTQ5MDMx
NjAzMDQzOVowUzELMAkGA1UEBhMCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE
CwwKSHVhd2VpIENCRzEeMBwGA1UEAwwVSHVhd2VpIENCRyBSb290IENBIEcyMHYw
EAYHKoZIzj0CAQYFK4EEACIDYgAEWidkGnDSOw3/HE2y2GHl+fpWBIa5S+IlnNrs
GUvwC1I2QWvtqCHWmwFlFK95zKXiM8s9yV3VVXh7ivN8ZJO3SC5N1TCrvB2lpHMB
wcz4DA0kgHCMm/wDec6kOHx1xvCRo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0T
AQH/BAUwAwEB/zAdBgNVHQ4EFgQUo45a9Vq8cYwqaiVyfkiS4pLcIAAwCgYIKoZI
zj0EAwMDZwAwZAIwMypeB7P0IbY7c6gpWcClhRznOJFj8uavrNu2PIoz9KIqr3jn
BlBHJs0myI7ntYpEAjBbm8eDMZY5zq5iMZUC6H7UzYSix4Uy1YlsLVV738PtKP9h
FTjgDHctXJlC5L7+ZDY=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDATCCAoigAwIBAgIIXmuDXbWpOB8wCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE
AwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDcwOTAyMDQyNFoXDTMwMDcw
NzAyMDQyNFowYjELMAkGA1UEBgwCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE
CwwKSHVhd2VpIENCRzEtMCsGA1UEAwwkSHVhd2VpIENCRyBEZXZlbG9wZXIgUmVs
YXRpb25zIENBIEcyMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE65LdoIZh1hlpZ2gP
bJ6gPhHsvYSRe22KETgdqeVeYnrbRHI9wsPT6RGYS+pU4mPl6wxzgDMqN6SY/BoZ
luhkE1PzaHoPoNIWIq0O33hpyKyyYwAacIUEjYurkw1E9r9no4IBGDCCARQwHwYD
VR0jBBgwFoAUo45a9Vq8cYwqaiVyfkiS4pLcIAAwHQYDVR0OBBYEFNtek7Ij6NDk
/nF6Zumkc0dbf/NeMEYGA1UdIAQ/MD0wOwYEVR0gADAzMDEGCCsGAQUFBwIBFiVo
dHRwOi8vY3BraS1jYXdlYi5odWF3ZWkuY29tL2Nwa2kvY3BzMBIGA1UdEwEB/wQI
MAYBAf8CAQAwDgYDVR0PAQH/BAQDAgEGMGYGA1UdHwRfMF0wW6BZoFeGVWh0dHA6
Ly9jcGtpLWNhd2ViLmh1YXdlaS5jb20vY3BraS9zZXJ2bGV0L2NybEZpbGVEb3du
LmNybD9jZXJ0eXBlPTEwJi9yb290X2cyX2NybC5jcmwwCgYIKoZIzj0EAwMDZwAw
ZAIwWO1X5q2MdfpR1Q237GpUHGbL1C13rGyFg2p3AYo44FpZ2/A9ss0wOHKM4KDl
ZPqdAjBLkf8NPZy7KVog98+iCTLq35DJ2ZVxkCxknA9YhiHVyXf4HPm4JlT7rW7o
Q+FzM3c=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICujCCAkGgAwIBAgIOY8ui/vvwxqFf+kFokYUwCgYIKoZIzj0EAwMwYjELMAkG
A1UEBgwCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEt
MCsGA1UEAwwkSHVhd2VpIENCRyBEZXZlbG9wZXIgUmVsYXRpb25zIENBIEcyMB4X
DTI0MDkyMzEyNTgwNFoXDTI3MDkyMzEyNTgwNFowazELMAkGA1UEBhMCQ04xDzAN
BgNVBAoMBuW8oOaZqDEcMBoGA1UECwwTMTI4OTY3Njc4NjA2NTQ5NDk3NzEtMCsG
A1UEAwwk5byg5pmoKDEyODk2NzY3ODYwNjU0OTQ5NzcpXCxSZWxlYXNlMFkwEwYH
KoZIzj0CAQYIKoZIzj0DAQcDQgAEPbyzvysXz5fUlaCRBx8cHYbLbQwJPnU657p4
blls+xQqVms/HRpFfR6KcvYTlawTey3TMjjK+PQrOF0TCSwJYKOB0TCBzjAMBgNV
HRMBAf8EAjAAMFkGA1UdHwRSMFAwTqBMoEqGSGh0dHA6Ly9oNWhvc3RpbmctZHJj
bi5kYmFua2Nkbi5jbi9jY2g1L2NybC9oZHJjYWcyL0h1YXdlaUNCR0hEUkcyY3Js
LmNybDAfBgNVHSMEGDAWgBTbXpOyI+jQ5P5xembppHNHW3/zXjAdBgNVHQ4EFgQU
bQhFjIxK/m516AKkgn45pNW7SUAwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoG
CCsGAQUFBwMDMAoGCCqGSM49BAMDA2cAMGQCMFzNlsafNs7ad5xelZOzCebdRofE
VaQZJW0o5QAdTX0t9Ij1o/zUm0bXIf8ZZTJLYgIwKuuZu+LeLCLZJFEM7tYKDhIK
TegCiesP1THuMgiZhZYOYl1kIZBPVrEB8O1wtxEm
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到叶子证书文件里也包括了中间证书和根证书，分别解析证书信息如下：&lt;/p&gt; 
&lt;p&gt;根证书：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 5339133492510690512 (0x4a18699f9d7d8cd0)
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
        Validity
            Not Before: Mar 16 03:04:39 2020 GMT
            Not After : Mar 16 03:04:39 2049 GMT
        Subject: C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    04:5a:27:64:1a:70:d2:3b:0d:ff:1c:4d:b2:d8:61:
                    e5:f9:fa:56:04:86:b9:4b:e2:25:9c:da:ec:19:4b:
                    f0:0b:52:36:41:6b:ed:a8:21:d6:9b:01:65:14:af:
                    79:cc:a5:e2:33:cb:3d:c9:5d:d5:55:78:7b:8a:f3:
                    7c:64:93:b7:48:2e:4d:d5:30:ab:bc:1d:a5:a4:73:
                    01:c1:cc:f8:0c:0d:24:80:70:8c:9b:fc:03:79:ce:
                    a4:38:7c:75:c6:f0:91
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        X509v3 extensions:
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 Basic Constraints: critical
                CA:TRUE
            X509v3 Subject Key Identifier: 
                A3:8E:5A:F5:5A:BC:71:8C:2A:6A:25:72:7E:48:92:E2:92:DC:20:00
    Signature Algorithm: ecdsa-with-SHA384
    Signature Value:
        30:64:02:30:33:2a:5e:07:b3:f4:21:b6:3b:73:a8:29:59:c0:
        a5:85:1c:e7:38:91:63:f2:e6:af:ac:db:b6:3c:8a:33:f4:a2:
        2a:af:78:e7:06:50:47:26:cd:26:c8:8e:e7:b5:8a:44:02:30:
        5b:9b:c7:83:31:96:39:ce:ae:62:31:95:02:e8:7e:d4:cd:84:
        a2:c7:85:32:d5:89:6c:2d:55:7b:df:c3:ed:28:ff:61:15:38:
        e0:0c:77:2d:5c:99:42:e4:be:fe:64:36
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;中间证书：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 6803676100576229407 (0x5e6b835db5a9381f)
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
        Validity
            Not Before: Jul  9 02:04:24 2020 GMT
            Not After : Jul  7 02:04:24 2030 GMT
        Subject: C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Developer Relations CA G2
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    04:eb:92:dd:a0:86:61:d6:19:69:67:68:0f:6c:9e:
                    a0:3e:11:ec:bd:84:91:7b:6d:8a:11:38:1d:a9:e5:
                    5e:62:7a:db:44:72:3d:c2:c3:d3:e9:11:98:4b:ea:
                    54:e2:63:e5:eb:0c:73:80:33:2a:37:a4:98:fc:1a:
                    19:96:e8:64:13:53:f3:68:7a:0f:a0:d2:16:22:ad:
                    0e:df:78:69:c8:ac:b2:63:00:1a:70:85:04:8d:8b:
                    ab:93:0d:44:f6:bf:67
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        X509v3 extensions:
            X509v3 Authority Key Identifier: 
                A3:8E:5A:F5:5A:BC:71:8C:2A:6A:25:72:7E:48:92:E2:92:DC:20:00
            X509v3 Subject Key Identifier: 
                DB:5E:93:B2:23:E8:D0:E4:FE:71:7A:66:E9:A4:73:47:5B:7F:F3:5E
            X509v3 Certificate Policies: 
                Policy: X509v3 Any Policy
                  CPS: http://cpki-caweb.huawei.com/cpki/cps
            X509v3 Basic Constraints: critical
                CA:TRUE, pathlen:0
            X509v3 Key Usage: critical
                Certificate Sign, CRL Sign
            X509v3 CRL Distribution Points: 
                Full Name:
                  URI:http://cpki-caweb.huawei.com/cpki/servlet/crlFileDown.crl?certype=10&amp;amp;/root_g2_crl.crl
    Signature Algorithm: ecdsa-with-SHA384
    Signature Value:
        30:64:02:30:58:ed:57:e6:ad:8c:75:fa:51:d5:0d:b7:ec:6a:
        54:1c:66:cb:d4:2d:77:ac:6c:85:83:6a:77:01:8a:38:e0:5a:
        59:db:f0:3d:b2:cd:30:38:72:8c:e0:a0:e5:64:fa:9d:02:30:
        4b:91:ff:0d:3d:9c:bb:29:5a:20:f7:cf:a2:09:32:ea:df:90:
        c9:d9:95:71:90:2c:64:9c:0f:58:86:21:d5:c9:77:f8:1c:f9:
        b8:26:54:fb:ad:6e:e8:43:e1:73:33:77
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;叶子证书：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            63:cb:a2:fe:fb:f0:c6:a1:5f:fa:41:68:91:85
        Signature Algorithm: ecdsa-with-SHA384
        Issuer: C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Developer Relations CA G2
        Validity
            Not Before: Sep 23 12:58:04 2024 GMT
            Not After : Sep 23 12:58:04 2027 GMT
        Subject: C = CN, O = \E5\BC\A0\E6\99\A8, OU = 1289676786065494977, CN = &quot;\E5\BC\A0\E6\99\A8(1289676786065494977)\\,Release&quot;
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (256 bit)
                pub:
                    04:3d:bc:b3:bf:2b:17:cf:97:d4:95:a0:91:07:1f:
                    1c:1d:86:cb:6d:0c:09:3e:75:3a:e7:ba:78:6e:59:
                    6c:fb:14:2a:56:6b:3f:1d:1a:45:7d:1e:8a:72:f6:
                    13:95:ac:13:7b:2d:d3:32:38:ca:f8:f4:2b:38:5d:
                    13:09:2c:09:60
                ASN1 OID: prime256v1
                NIST CURVE: P-256
        X509v3 extensions:
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 CRL Distribution Points: 
                Full Name:
                  URI:http://h5hosting-drcn.dbankcdn.cn/cch5/crl/hdrcag2/HuaweiCBGHDRG2crl.crl
            X509v3 Authority Key Identifier: 
                DB:5E:93:B2:23:E8:D0:E4:FE:71:7A:66:E9:A4:73:47:5B:7F:F3:5E
            X509v3 Subject Key Identifier: 
                6D:08:45:8C:8C:4A:FE:6E:75:E8:02:A4:82:7E:39:A4:D5:BB:49:40
            X509v3 Key Usage: critical
                Digital Signature
            X509v3 Extended Key Usage: 
                Code Signing
    Signature Algorithm: ecdsa-with-SHA384
    Signature Value:
        30:64:02:30:5c:cd:96:c6:9f:36:ce:da:77:9c:5e:95:93:b3:
        09:e6:dd:46:87:c4:55:a4:19:25:6d:28:e5:00:1d:4d:7d:2d:
        f4:88:f5:a3:fc:d4:9b:46:d7:21:ff:19:65:32:4b:62:02:30:
        2a:eb:99:bb:e2:de:2c:22:d9:24:51:0c:ee:d6:0a:0e:12:0a:
        4d:e8:02:89:eb:0f:d5:31:ee:32:08:99:85:96:0e:62:5d:64:
        21:90:4f:56:b1:01:f0:ed:70:b7:11:26
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意到，颁发下来的叶子证书里 Subject 和我们申请时所使用的 CSR 里的 Subject 不同，叶子证书里是：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Subject: C = CN, O = \E5\BC\A0\E6\99\A8, OU = 1289676786065494977, CN = &quot;\E5\BC\A0\E6\99\A8(1289676786065494977)\,Release&quot;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;CSR 里是：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Subject: C = , ST = , L = , O = , OU = , CN = testscr&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;说明华为在颁发叶子证书的时候，并没有使用我们 CSR 里的 Subject，而是根据我们在开发者平台网站上登陆的账号信息，对 Subject 进行了填充。其中 OU 字段跟账号信息有关（类似 iOS 的 Team ID，但在华为开发者网站上没有找到直接查看的地方）。叶子证书里的公钥信息还是和 CSR 保持一致，计算得到的公钥指纹也一样。&lt;/p&gt; 
&lt;p&gt;另外，华为目前给叶子证书的有效期是 3 年，3 年以后需要续期成新证书。当然，如果续期新证书的时候使用的 CSR 不变，那么新证书的公钥指纹也依然会保持不变。&lt;/p&gt; 
&lt;h3&gt;2.2 生成 Profile 文件&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;④ 登记 App 信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这里主要是在华为开发者平台上登记一下 App 的各项信息，跟着&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fapp%2Fagc-help-harmonyos-releaseapp-0000001914554900&quot; target=&quot;_blank&quot;&gt;操作步骤&lt;/a&gt;来即可：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5fcf2a267acd92ba136fec98857c4df4.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;需要注意的是，包名填写的时候，平台会在线检查一下是否和已经存在的包名有重复（包括其他人申请的包名）。申请成功以后，会分配一个唯一的 APP ID：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//0e6902a65225b3b4c8158e50798b9cee.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;这个 APP ID 用来在网站上标识 APP 的唯一性。后面文章中会出现类似的名称，为了消除歧义，相似的字段用括号内容区分，这里称为 APP ID（网站）。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑤ 生成 Profile 文件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Profile 文件是描述 App 的包名、签名、申请的权限列表、安装包类型、可安装设备等信息的文件（类似 iOS 的 Provisioning Profile），签名后保存为 Cryptographic Message Syntax 格式（CMS，扩展的 PKCS#7/格式，CMS 定义在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc5652&quot; target=&quot;_blank&quot;&gt;RFC 5652&lt;/a&gt;，PKCS#7 定义在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc2315&quot; target=&quot;_blank&quot;&gt;RFC 2315&lt;/a&gt;。）&lt;/p&gt; 
&lt;p&gt;跟着&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fapp%2Fagc-help-add-releaseprofile-0000001914714796&quot; target=&quot;_blank&quot;&gt;操作步骤&lt;/a&gt;，选择之前的 APP ID（网站）和证书，可以得到对应的 Profile 文件：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//9763955ef0380603c3356e3ba971f374.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Profile 也分为发布和调试两种，发布只能选择发布证书，调试只能选择调试证书。这里继续以发布类型为例，生成的 Profile 文件（保存为 my.p7b）被华为签名后， 通过如下命令可以查看里面的所有信息：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl pkcs7 -in my.p7b -print -inform DER
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;主要包括配置信息和签名信息两部分，也可以通过如下命令分别查看配置信息和签名信息：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;openssl smime -verify -in my.p7b -inform DER -noverify //查看配置信息
openssl pkcs7 -in my.p7b -print_certs  -inform DER //查看证书信息
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;得到的示例配置信息如下（*为手动打码）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    &quot;version-name&quot;: &quot;2.0.0&quot;,
    &quot;version-code&quot;: 2,
    &quot;app-distribution-type&quot;: &quot;app_gallery&quot;,
    &quot;uuid&quot;: &quot;234e1d73-****-****-****-f81e2598d0ff&quot;,
    &quot;validity&quot;: {
        &quot;not-before&quot;: 1727096284,
        &quot;not-after&quot;: 1821704284
    },
    &quot;type&quot;: &quot;release&quot;,
    &quot;bundle-info&quot;: {
        &quot;developer-id&quot;: &quot;300**********7916&quot;,
        &quot;distribution-certificate&quot;: &quot;-----BEGIN CERTIFICATE-----\nMIICujCCAkGgAwIBAgIOY8ui/vvwxqFf+kFokYUwCgYIKoZIzj0EAwMwYjELMAkG\nA1UEBgwCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEt\nMCsGA1UEAwwkSHVhd2VpIENCRyBEZXZlbG9wZXIgUmVsYXRpb25zIENBIEcyMB4X\nDTI0MDkyMzEyNTgwNFoXDTI3MDkyMzEyNTgwNFowazELMAkGA1UEBhMCQ04xDzAN\nBgNVBAoMBuW8oOaZqDEcMBoGA1UECwwTMTI4OTY3Njc4NjA2NTQ5NDk3NzEtMCsG\nA1UEAwwk5byg5pmoKDEyODk2NzY3ODYwNjU0OTQ5NzcpXCxSZWxlYXNlMFkwEwYH\nKoZIzj0CAQYIKoZIzj0DAQcDQgAEPbyzvysXz5fUlaCRBx8cHYbLbQwJPnU657p4\nblls+xQqVms/HRpFfR6KcvYTlawTey3TMjjK+PQrOF0TCSwJYKOB0TCBzjAMBgNV\nHRMBAf8EAjAAMFkGA1UdHwRSMFAwTqBMoEqGSGh0dHA6Ly9oNWhvc3RpbmctZHJj\nbi5kYmFua2Nkbi5jbi9jY2g1L2NybC9oZHJjYWcyL0h1YXdlaUNCR0hEUkcyY3Js\nLmNybDAfBgNVHSMEGDAWgBTbXpOyI+jQ5P5xembppHNHW3/zXjAdBgNVHQ4EFgQU\nbQhFjIxK/m516AKkgn45pNW7SUAwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoG\nCCsGAQUFBwMDMAoGCCqGSM49BAMDA2cAMGQCMFzNlsafNs7ad5xelZOzCebdRofE\nVaQZJW0o5QAdTX0t9Ij1o/zUm0bXIf8ZZTJLYgIwKuuZu+LeLCLZJFEM7tYKDhIK\nTegCiesP1THuMgiZhZYOYl1kIZBPVrEB8O1wtxEm\n-----END CERTIFICATE-----\n&quot;,
        &quot;bundle-name&quot;: &quot;com.***.test&quot;,
        &quot;apl&quot;: &quot;normal&quot;,
        &quot;app-feature&quot;: &quot;hos_normal_app&quot;,
        &quot;app-identifier&quot;: &quot;576************2509&quot;
    },
    &quot;baseapp-info&quot;: {},
    &quot;permissions&quot;: {},
    &quot;acls&quot;: {},
    &quot;issuer&quot;: &quot;app_gallery&quot;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体每个字段的含义可以参考&lt;a href=&quot;https://gitee.com/openharmony/docs/blob/OpenHarmony-v5.0.0-Release/zh-cn/application-dev/security/app-provision-structure.md&quot;&gt;官方文档&lt;/a&gt;和&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/provision/provision_verify.cpp&quot;&gt;源码中的定义&lt;/a&gt;，其中重点字段解析如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//598b77f33308dbb7bb8f4df8d4011765.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;得到的示例证书内容如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;subject=C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
issuer=C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
-----BEGIN CERTIFICATE-----
MIICGjCCAaGgAwIBAgIIShhpn519jNAwCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE
AwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDMxNjAzMDQzOVoXDTQ5MDMx
NjAzMDQzOVowUzELMAkGA1UEBhMCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE
CwwKSHVhd2VpIENCRzEeMBwGA1UEAwwVSHVhd2VpIENCRyBSb290IENBIEcyMHYw
EAYHKoZIzj0CAQYFK4EEACIDYgAEWidkGnDSOw3/HE2y2GHl+fpWBIa5S+IlnNrs
GUvwC1I2QWvtqCHWmwFlFK95zKXiM8s9yV3VVXh7ivN8ZJO3SC5N1TCrvB2lpHMB
wcz4DA0kgHCMm/wDec6kOHx1xvCRo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0T
AQH/BAUwAwEB/zAdBgNVHQ4EFgQUo45a9Vq8cYwqaiVyfkiS4pLcIAAwCgYIKoZI
zj0EAwMDZwAwZAIwMypeB7P0IbY7c6gpWcClhRznOJFj8uavrNu2PIoz9KIqr3jn
BlBHJs0myI7ntYpEAjBbm8eDMZY5zq5iMZUC6H7UzYSix4Uy1YlsLVV738PtKP9h
FTjgDHctXJlC5L7+ZDY=
-----END CERTIFICATE-----

subject=C = CN, O = Huawei, OU = HOS AppGallery, CN = HOS Profile Management
issuer=C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Software Signing Service CA
-----BEGIN CERTIFICATE-----
MIIC7TCCAnOgAwIBAgIIV5nKqt2oGmwwCgYIKoZIzj0EAwMwZDELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEvMC0GA1UE
AwwmSHVhd2VpIENCRyBTb2Z0d2FyZSBTaWduaW5nIFNlcnZpY2UgQ0EwHhcNMjMw
NDI0MDYyNjMxWhcNMjgwNDI0MDYyNjMxWjBYMQswCQYDVQQGDAJDTjEPMA0GA1UE
CgwGSHVhd2VpMRcwFQYDVQQLDA5IT1MgQXBwR2FsbGVyeTEfMB0GA1UEAwwWSE9T
IFByb2ZpbGUgTWFuYWdlbWVudDBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDdY
3RoPqb6WD8UpXJiavZLN48iamektKUKZHFl9xwr1Siu77z3lI86cREa3Flw50uKc
xkMNKM4FWBRMd3CDhI+jggEZMIIBFTAfBgNVHSMEGDAWgBT69fe+IFZdXdTabfEU
FTwdCduyNDAdBgNVHQ4EFgQU0a99kztpYeCetotz0YIduJ2I2VcwRgYDVR0gBD8w
PTA7BgRVHSAAMDMwMQYIKwYBBQUHAgEWJWh0dHA6Ly9wa2kuY29uc3VtZXIuaHVh
d2VpLmNvbS9jYS9jcHMwDgYDVR0PAQH/BAQDAgeAMEwGA1UdHwRFMEMwQaA/oD2G
O2h0dHA6Ly9wa2kuY29uc3VtZXIuaHVhd2VpLmNvbS9jYS9jcmwvc29mdF9zaWdu
X3Nydl9jcmwuY3JsMBMGA1UdJQQMMAoGCCsGAQUFBwMDMBgGDCsGAQQBj1sCgngB
AwQIMAYCAQEKAQEwCgYIKoZIzj0EAwMDaAAwZQIwRYOlQ6Qq2SF8LHQ78xpNYh47
zMemerx5oG4F6Uq/3ARPfowvdrEu5Ss+njPMG0FFAjEA0s7YhO7Ktm60mkuHuxQS
46fqIHh/PAPJ2ozg1yDSD771bAGn7mDeGjaAFXEtKzU5
-----END CERTIFICATE-----

subject=C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Software Signing Service CA
issuer=C = CN, O = Huawei, OU = Huawei CBG, CN = Huawei CBG Root CA G2
-----BEGIN CERTIFICATE-----
MIIDADCCAoegAwIBAgIIJGDixWQS3MkwCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE
AwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDMxNjEyMzIzOVoXDTQwMDMx
NjEyMzIzOVowZDELMAkGA1UEBhMCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE
CwwKSHVhd2VpIENCRzEvMC0GA1UEAwwmSHVhd2VpIENCRyBTb2Z0d2FyZSBTaWdu
aW5nIFNlcnZpY2UgQ0EwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASsEz7cwYkzFh9b
xIwKfXx5qHGjl5WITy0teGnNWqv+jYCceeixHqErvK7YRn2hVPIqhRqKWeANHZUK
G0qxi+NIpmSmQS8/63CLz1QAcxfv2Xl3/V82dF0v9lm16ehMsN+jggEVMIIBETAf
BgNVHSMEGDAWgBSjjlr1WrxxjCpqJXJ+SJLiktwgADAdBgNVHQ4EFgQU+vX3viBW
XV3U2m3xFBU8HQnbsjQwDwYDVR0TAQH/BAUwAwEB/zBGBgNVHSAEPzA9MDsGBFUd
IAAwMzAxBggrBgEFBQcCARYlaHR0cDovL2Nwa2ktY2F3ZWIuaHVhd2VpLmNvbS9j
cGtpL2NwczAOBgNVHQ8BAf8EBAMCAQYwZgYDVR0fBF8wXTBboFmgV4ZVaHR0cDov
L2Nwa2ktY2F3ZWIuaHVhd2VpLmNvbS9jcGtpL3NlcnZsZXQvY3JsRmlsZURvd24u
Y3JsP2NlcnR5cGU9MTAmL3Jvb3RfZzJfY3JsLmNybDAKBggqhkjOPQQDAwNnADBk
AjBrAQQxUlNgqhYkcEm5eksnPxDkPJSY/qNd2BDgbvEydiLwPSvB7Z9lipxz8ikZ
EeUCMGppWcaV//SIG1y5tEwthLwWeEaF613vUILWQLir8+CA3RZGsRBqtE8xSqfz
yafLYQ==
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这里依然是完整的三级证书链，注意，根证书和之前申请到的开发者签名证书的根证书一样，但中间证书和叶子证书均不一样，比较如下（红色底色表示内容相同）：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b41cd1ab606666496f8ff83a595e998b.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;2.3 生成签名的 App&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;⑥ 得到签名的 App 包&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将生成的 Profile 文件、叶子证书文件等配置到项目的 signingConfigs 里，使用华为的 IDE 可以直接得到签名后的 App 包：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2db7cfa19566412e3aaa5b144e344d4c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;或者&lt;a href=&quot;https://gitee.com/openharmony/developtools_hapsigner#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E&quot;&gt;参考命令&lt;/a&gt;手动给未签名的 App 包进行签名。&lt;/p&gt; 
&lt;p&gt;得到的签名的 App 包只是用于提供给华为商店进行审核和后续的拆包，并不能直接安装到手机上运行。App 包实际上就是标准的 ZIP 格式，可以修改后缀为.zip 进行解压：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a4ea6ad900851a83f36f3e8c649b574e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到里面包括了.hap 包和描述 App 一些信息的 pack.info 文件。&lt;/p&gt; 
&lt;p&gt;那么对 App 包进行签名的内容以及 Profile 文件在哪里呢？根据对源码里&lt;a href=&quot;https://gitee.com/openharmony/developtools_hapsigner/blob/OpenHarmony-v5.0.0-Release/hapsigntool/hap_sign_tool_lib/src/main/java/com/ohos/hapsigntool/hap/verify/VerifyHap.java&quot;&gt;VerifyHap.java 类的 verifyHap&lt;/a&gt;函数进行分析，发现鸿蒙上的签名机制类似 Android V3，签名信息和 Profile 文件存储在自定义的 HapSigningBlock 区，放到了 ZIP 格式 Central Directory 区的前面，其结构如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6c5cab294c9a3f72d9f10b72e57a8d70.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;HapSigningBlock 区的魔数（转成 string 也就是）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    /**
     * The value of lower 8 bytes of magic word
     */
    public static final long HAP_SIG_BLOCK_MAGIC_LO_V3 = 0x676973207061683cL;

    /**
     * The value of higher 8 bytes of magic word
     */
    public static final long HAP_SIG_BLOCK_MAGIC_HI_V3 = 0x3e6b636f6c62206eL;

    /**
     * Size of hap signature block header
     */
    public static final int HAP_SIG_BLOCK_HEADER_SIZE = 32;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;通过 hex 工具直接打开 App 包也可以在 Central Directory 区前面找到：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//324d4730066ba6997ca5fc01c40c0f91.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其中 SignatureSchemeBlock 区存放了 CMS 格式的 Hap 包签名信息，而 Profile 文件就存储在 SigningBlock 区，Type 是 0x20000002：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    /**
     * ID of profile block
     */
    public static final int HAP_PROFILE_BLOCK_ID = 0x20000002;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;通过如下&lt;a href=&quot;https://gitee.com/openharmony/developtools_hapsigner/tree/OpenHarmony-v5.0.0-Release/dist&quot;&gt;hap-sign-tool.jar&lt;/a&gt;的命令可以导出存储在 App 包或 Hap 包里的签名证书和 Profile 文件：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -jar hap-sign-tool.jar verify-app -inFile my-signed.app -outCertChain my-signed.cer -outProfile my-signed.p7b
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;⑦ 签名校验、拆包、重签名&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;提供给华为应用市场审核的 App 包在经过签名校验，确认是开发者的应用以及应用的完整性以后，华为会取出 App 包 SigningBlock 区的 Profile 文件，解压出 Hap 包，把 Profile 文件或 Profile 文件内的配置（下一章节展开描述区别）重新放到 Hap 包的 SigningBlock 区里，并用 Hap 的签名叶子证书对 Hap 包进行重新签名，签名方式和给 App 包签名一样。最终真正&lt;strong&gt;通过应用市场下发到手机上的是经过重签名的 Hap 包（类似 iOS 的双层签名机制）&lt;/strong&gt;。解析出签名证书如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CN=HOS AppGallery Application Release, OU=HOS AppGallery, O=Huawei, C=CN
-----BEGIN CERTIFICATE-----
MIIC+TCCAn+gAwIBAgIIWXsBFAJOQzIwCgYIKoZIzj0EAwMwZDELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEvMC0GA1UE
AwwmSHVhd2VpIENCRyBTb2Z0d2FyZSBTaWduaW5nIFNlcnZpY2UgQ0EwHhcNMjMw
NDI0MDYyMjA1WhcNMjgwNDI0MDYyMjA1WjBkMQswCQYDVQQGDAJDTjEPMA0GA1UE
CgwGSHVhd2VpMRcwFQYDVQQLDA5IT1MgQXBwR2FsbGVyeTErMCkGA1UEAwwiSE9T
IEFwcEdhbGxlcnkgQXBwbGljYXRpb24gUmVsZWFzZTBZMBMGByqGSM49AgEGCCqG
SM49AwEHA0IABIokjn9tVRpgEC6b1AR9chiiejUGBiF83Lzm1giyZX9XKVzTPkHq
RRuML+zhRtT1JESEMOUggPyJbe9+rt3k9CijggEZMIIBFTAfBgNVHSMEGDAWgBT6
9fe+IFZdXdTabfEUFTwdCduyNDAdBgNVHQ4EFgQUFzRtDLYZ7zX/idRsHYmJZ734
vwgwRgYDVR0gBD8wPTA7BgRVHSAAMDMwMQYIKwYBBQUHAgEWJWh0dHA6Ly9wa2ku
Y29uc3VtZXIuaHVhd2VpLmNvbS9jYS9jcHMwDgYDVR0PAQH/BAQDAgeAMEwGA1Ud
HwRFMEMwQaA/oD2GO2h0dHA6Ly9wa2kuY29uc3VtZXIuaHVhd2VpLmNvbS9jYS9j
cmwvc29mdF9zaWduX3Nydl9jcmwuY3JsMBMGA1UdJQQMMAoGCCsGAQUFBwMDMBgG
DCsGAQQBj1sCgngBAwQIMAYCAQEKAQAwCgYIKoZIzj0EAwMDaAAwZQIxAJofyGQW
4ZVDW64qTeiVQVn5w7iRhejP6YFqYX9h/5mNXKMQ8ZuQCFT7EaqhVblWlQIwWIPB
xC+YhPz6JmDMSZDynZINnXi0T3k9UvbcCybbd2k2PWHYvYqQdKAuYGcNc2Ho
-----END CERTIFICATE-----
CN=Huawei CBG Software Signing Service CA, OU=Huawei CBG, O=Huawei, C=CN
-----BEGIN CERTIFICATE-----
MIIDADCCAoegAwIBAgIIJGDixWQS3MkwCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC
Q04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE
AwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDMxNjEyMzIzOVoXDTQwMDMx
NjEyMzIzOVowZDELMAkGA1UEBhMCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE
CwwKSHVhd2VpIENCRzEvMC0GA1UEAwwmSHVhd2VpIENCRyBTb2Z0d2FyZSBTaWdu
aW5nIFNlcnZpY2UgQ0EwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASsEz7cwYkzFh9b
xIwKfXx5qHGjl5WITy0teGnNWqv+jYCceeixHqErvK7YRn2hVPIqhRqKWeANHZUK
G0qxi+NIpmSmQS8/63CLz1QAcxfv2Xl3/V82dF0v9lm16ehMsN+jggEVMIIBETAf
BgNVHSMEGDAWgBSjjlr1WrxxjCpqJXJ+SJLiktwgADAdBgNVHQ4EFgQU+vX3viBW
XV3U2m3xFBU8HQnbsjQwDwYDVR0TAQH/BAUwAwEB/zBGBgNVHSAEPzA9MDsGBFUd
IAAwMzAxBggrBgEFBQcCARYlaHR0cDovL2Nwa2ktY2F3ZWIuaHVhd2VpLmNvbS9j
cGtpL2NwczAOBgNVHQ8BAf8EBAMCAQYwZgYDVR0fBF8wXTBboFmgV4ZVaHR0cDov
L2Nwa2ktY2F3ZWIuaHVhd2VpLmNvbS9jcGtpL3NlcnZsZXQvY3JsRmlsZURvd24u
Y3JsP2NlcnR5cGU9MTAmL3Jvb3RfZzJfY3JsLmNybDAKBggqhkjOPQQDAwNnADBk
AjBrAQQxUlNgqhYkcEm5eksnPxDkPJSY/qNd2BDgbvEydiLwPSvB7Z9lipxz8ikZ
EeUCMGppWcaV//SIG1y5tEwthLwWeEaF613vUILWQLir8+CA3RZGsRBqtE8xSqfz
yafLYQ==
-----END CERTIFICATE-----
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意这里给&lt;strong&gt;Hap 的签名证书和我们之前申请的开发者签名证书不一样&lt;/strong&gt;，Hap 签名证书和对应的私钥都是华为的，跟我们的应用没有关系，而且签名证书链里不包含根证书的信息。&lt;/p&gt; 
&lt;p&gt;这里再和之前的证书对比一下（红色和黄色底色表示内容分别相同）：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2aa7e197035b4347374c50de33ae6ed6.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;三者的根证书都一样，Profile 签名证书和 Hap 签名证书的中间证书一样，三者的叶子证书均不一样。&lt;/p&gt; 
&lt;p&gt;另外，如果在上架应用市场的时候，勾选了加密：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7817e3f2b3f2a7c916e28a470cf42ffc.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;根据《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fguidebook%2Fharmonyecoappsecurity-guidebook-0000001808819033&quot; target=&quot;_blank&quot;&gt;鸿蒙生态应用安全技术白皮书&lt;/a&gt;》描述，只是对 Hap 包里的代码做加密，然后重新签名，所以证书和 Profile 文件的解析均不受影响。&lt;/p&gt; 
&lt;ol start=&quot;3&quot;&gt; 
 &lt;li&gt;校验机制&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;签名相关的代码在&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/tree/OpenHarmony-v5.0.0-Release/&quot;&gt;security_appverify&lt;/a&gt;仓库里，签名校验流程梳理如下（图上所有判断条件在失败情况下均会导致签名校验失败，为了直观不画出此流程）：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//95a1bf6fe87cc540ac760f4abb65047c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;签名校验步骤可以分成三组，分别是：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;SignatureSchemeBlock 区校验。&lt;/li&gt; 
 &lt;li&gt;Profile 校验和解析。&lt;/li&gt; 
 &lt;li&gt;Hap 包完整性校验。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h3&gt;3.1 SignatureSchemeBlock 区校验&lt;/h3&gt; 
&lt;p&gt;校验 Hap 包时首先在 ZIP 的 Central Directory 区前 32 个字节寻找是否有 HapSigningBlock 区的 Header，找到以后定位到 SignatureSchemeBlock 区，解析其 CMS 格式，并校验 SignatureSchemeBlock 区证书链的完整性。证书链完整性校验流程如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7cd918bbfb9bed79a5973b6fbd58faee.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;校验叶子证书时，需要按证书指定算法重新计算证书的 hash，并使用上一级证书（中间证书）的公钥对叶子证书里的证书签名进行解密，与重新计算的 hash 比对是否相同，相同则认为证书可信。中间证书继续通过根证书的公钥校验自己的证书签名。根证书用自己的公钥校验自己。&lt;/p&gt; 
&lt;p&gt;上一章说到，SignatureSchemeBlock 区的证书链不包括根证书，所以这一步需要使用到根证书其实是内置在鸿蒙系统里的，存放地址是：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/system/etc/security/trusted_root_ca.json
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体内容如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    &quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Root CA G2&quot;:&quot;-----BEGIN CERTIFICATE-----\nMIICGjCCAaGgAwIBAgIIShhpn519jNAwCgYIKoZIzj0EAwMwUzELMAkGA1UEBhMC\nQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UECwwKSHVhd2VpIENCRzEeMBwGA1UE\nAwwVSHVhd2VpIENCRyBSb290IENBIEcyMB4XDTIwMDMxNjAzMDQzOVoXDTQ5MDMx\nNjAzMDQzOVowUzELMAkGA1UEBhMCQ04xDzANBgNVBAoMBkh1YXdlaTETMBEGA1UE\nCwwKSHVhd2VpIENCRzEeMBwGA1UEAwwVSHVhd2VpIENCRyBSb290IENBIEcyMHYw\nEAYHKoZIzj0CAQYFK4EEACIDYgAEWidkGnDSOw3/HE2y2GHl+fpWBIa5S+IlnNrs\nGUvwC1I2QWvtqCHWmwFlFK95zKXiM8s9yV3VVXh7ivN8ZJO3SC5N1TCrvB2lpHMB\nwcz4DA0kgHCMm/wDec6kOHx1xvCRo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0T\nAQH/BAUwAwEB/zAdBgNVHQ4EFgQUo45a9Vq8cYwqaiVyfkiS4pLcIAAwCgYIKoZI\nzj0EAwMDZwAwZAIwMypeB7P0IbY7c6gpWcClhRznOJFj8uavrNu2PIoz9KIqr3jn\nBlBHJs0myI7ntYpEAjBbm8eDMZY5zq5iMZUC6H7UzYSix4Uy1YlsLVV738PtKP9h\nFTjgDHctXJlC5L7+ZDY=\n-----END CERTIFICATE-----\n&quot;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到这个根证书就是上一章解析出来的根证书，所以这里可以校验通过。&lt;/p&gt; 
&lt;p&gt;在确认证书链可信以后，根据叶子证书的 Subject 判断 Hap 包的安装来源，具体代码在&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/init/trusted_source_manager.cpp&quot;&gt;trusted_source_manager.cpp 的 MatchTrustedSource 函数里&lt;/a&gt;，也就是和内置的 Hap 签名证书列表进行比较，看匹配到哪一个。内置的 Hap 签名证书列表存放地址是：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/system/etc/security/trusted_apps_sources.json
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体内容如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    &quot;version&quot;: &quot;1.0.1&quot;,
    &quot;release-time&quot;:&quot;2021-06-03 10:06:00&quot;,
    &quot;trust-app-source&quot;:[
        {
            &quot;name&quot;:&quot;huawei app gallery&quot;,
            &quot;app-signing-cert&quot;:&quot;C=CN, O=Huawei, OU=HOS AppGallery, CN=HOS AppGallery Application Release&quot;,
            &quot;profile-signing-certificate&quot;:&quot;C=CN, O=Huawei, OU=HOS AppGallery, CN=HOS Profile Management&quot;,
            &quot;profile-debug-signing-certificate&quot;:&quot;C=CN, O=Huawei, OU=HOS AppGallery, CN=HOS Profile Management Debug&quot;,
            &quot;issuer-ca&quot;:&quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Software Signing Service CA&quot;,
            &quot;root-ca&quot;: &quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Root CA G2&quot;,
            &quot;max-certs-path&quot;:3,
            &quot;critialcal-cert-extension&quot;:[&quot;keyusage&quot;,&quot;huawei-signing-capability&quot;]
        },
        {
            &quot;name&quot;:&quot;huawei system apps&quot;,
            &quot;app-signing-cert&quot;:&quot;C=CN, O=Huawei CBG, OU=HOS Development Team, CN=HOS Application Provision Release&quot;,
            &quot;profile-signing-certificate&quot;:&quot;C=CN, O=Huawei CBG, OU=HOS Development Team, CN=HOS Application Provision Profile Release&quot;,
            &quot;profile-debug-signing-certificate&quot;:&quot;C=CN, O=Huawei CBG, OU=HOS Development Team, CN=HOS Application Provision Profile Release_Debug&quot;,
            &quot;issuer-ca&quot;:&quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Software Signing Service CA&quot;,
            &quot;root-ca&quot;: &quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Root CA G2&quot;,
            &quot;max-certs-path&quot;:3,
            &quot;critialcal-cert-extension&quot;:[&quot;keyusage&quot;,&quot;huawei-signing-capability&quot;]
        },
        {
            &quot;name&quot;:&quot;third_party app preload&quot;,
            &quot;app-signing-cert&quot;:&quot;C=CN, O=Huawei, OU=HOS Open Platform, CN=HOS Preload Service&quot;,
            &quot;profile-signing-certificate&quot;:&quot;&quot;,
            &quot;profile-debug-signing-certificate&quot;:&quot;&quot;,
            &quot;issuer-ca&quot;:&quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Software Signing Service CA&quot;,
            &quot;root-ca&quot;: &quot;C=CN, O=Huawei, OU=Huawei CBG, CN=Huawei CBG Root CA G2&quot;,
            &quot;max-certs-path&quot;:3,
            &quot;critialcal-cert-extension&quot;:[&quot;keyusage&quot;,&quot;huawei-signing-capability&quot;]
        }
   ]
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这里有 Huawei App Gallery（应用市场）、Huawei System Apps（系统应用）、Third_party App Preload（三方预装）三组。每一组包括对应的 Hap 签名证书 Subject、Profile 签名证书 Subject 等信息。&lt;/p&gt; 
&lt;p&gt;我们走应用市场分发的 Hap 包会匹配到 Huawei App Gallery 这个证书。&lt;/p&gt; 
&lt;h3&gt;3.2 Profile 解析和校验&lt;/h3&gt; 
&lt;p&gt;接下来在 SigningBlock 区寻找 Profile，这里注意到&lt;strong&gt;不同 Hap 包签名方式会影响 Profile 的存储格式&lt;/strong&gt;。对于走应用市场分发的 Hap 包，Profile 是直接把其配置以字符串的格式保存，而对于其他情况，则是用 CMS 的格式保存。那么应用市场分发的 Hap 包也就不需要 Profile 的文件签名校验了。&lt;/p&gt; 
&lt;p&gt;对于其他情况，首先会使用 Profile 里保存的叶子证书公钥校验 Profile 的文件签名，然后会校验叶子证书 Subject 是否和匹配的同组内 Profile 签名证书 Subject 相同。&lt;/p&gt; 
&lt;p&gt;校验通过后解析 Profile 里的配置信息，根据 type 不同走不同的校验逻辑：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;发布，会校验是否为允许的安装来源，根据&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/verify/hap_verify_v2.cpp&quot;&gt;hap_verify_v2.cpp 的 IsAppDistributedTypeAllowInstall 函数&lt;/a&gt;，允许的来源包括企业签名、MDM、众包测试等分发场景。&lt;/li&gt; 
 &lt;li&gt;调试，会校验待安装的设备 UDID 是否在 Profile 的 device-ids 列表中。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;都校验通过后，再继续看 Profile 文件签名证书和 Hap 的签名正式是否相同，并继续对 Profile 配置的字段规则合法性进行检测。走完这一步，就可以认为 Profile 是可信的。&lt;/p&gt; 
&lt;p&gt;随后会生成 App ID（公钥）和 Fingerprint 两个新的字段和验证结果一并返回。其中 APP ID（公钥）是根据 Profile 配置里开发者签名证书公钥生成的（详见&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/verify/hap_verify_v2.cpp&quot;&gt;GenerateAppId 函数&lt;/a&gt;），fingerprint 是根据 Profile 配置里开发者签名证书直接计算整个证书的指纹（注意不是上一章的公钥指纹，详见&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/verify/hap_verify_v2.cpp&quot;&gt;GenerateFingerprint&lt;/a&gt;函数）。至此完成 Profile 的解析和校验。&lt;/p&gt; 
&lt;p&gt;另外，在鸿蒙&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fharmonyos-references-V5%2Fjs-apis-bundlemanager-bundleinfo-V5%23signatureinfo&quot; target=&quot;_blank&quot;&gt;SignatureInfo API&lt;/a&gt;中，会返回三个参数：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//9197952964f5adf39c968ddf49ee3724.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其中 API 返回的 appId 为了消除歧义，这里称为 APP ID（接口）。&lt;/p&gt; 
&lt;p&gt;根据包管理子系统&lt;a href=&quot;https://gitee.com/openharmony/bundlemanager_bundle_framework/blob/OpenHarmony-v5.0.0-Release/services/bundlemgr/src/bundle_install_checker.cpp&quot;&gt;bundle_install_checker.cpp 的 ParseHapFiles 函数&lt;/a&gt;、&lt;a href=&quot;https://gitee.com/openharmony/bundlemanager_bundle_framework/blob/OpenHarmony-v5.0.0-Release/services/bundlemgr/include/inner_bundle_info.h&quot;&gt;inner_bundle_info.h 的 SetProvisionId 函数&lt;/a&gt;和&lt;a href=&quot;https://gitee.com/openharmony/bundlemanager_bundle_framework/pulls/52/files&quot;&gt;这个 PR&lt;/a&gt;来看：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// bundle_install_checker.cpp
    newInfo.SetProvisionId(provisionInfo.appId);

// inner_bundle_info.h
    void SetProvisionId(const std::string &amp;amp;provisionId)
    {
        baseBundleInfo_-&amp;gt;appId = baseBundleInfo_-&amp;gt;name + Constants::FILE_UNDERLINE + provisionId;
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;APP ID（接口）的值实际上是 APP ID（公钥）加上了{bundleName}_的前缀。&lt;/p&gt; 
&lt;h3&gt;3.3 Hap 包完整性校验&lt;/h3&gt; 
&lt;p&gt;这一步的过程和 Hap 包签名类似，将 ZIP 包中数据和 HapSigningBlock 区里非 SignatureSchemeBlock 的部分拼接，重新计算 hash，与使用 Hap 签名叶子证书公钥解密 SignatureSchemeBlock 区签名后的 hash 比较，相同则认为 Hap 包未被篡改。具体可以参考&lt;a href=&quot;https://gitee.com/openharmony/security_appverify/blob/OpenHarmony-v5.0.0-Release/interfaces/innerkits/appverify/src/util/hap_signing_block_utils.cpp&quot;&gt;hap_signing_block_utils.cpp 的 VerifyHapIntegrity 函数&lt;/a&gt;，这里就不展开了。&lt;/p&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p&gt;从鸿蒙单框架应用的签名和校验机制的种种细节中可以看出，HarmonyOS NEXT 的安全设计非常务实，融合了 Anroid 和 iOS 双端的特性，有借鉴 Android 成熟的部分（签名格式），但更多的是参考了 iOS 的设计思路（双层签名机制），甚至更加严格。期待 HarmonyOS NEXT 给我们带来一个新的未来。&lt;/p&gt; 
&lt;p&gt;在这里，特别感谢华为同学对本文的大力支持。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;|&lt;/strong&gt; 关注「美团技术团队」微信公众号，在公众号菜单栏对话框回复【2023 年货】、【2022 年货】、【2021 年货】、【2020 年货】、【2019 年货】、【2018 年货】、【2017 年货】等关键词，可查看美团技术团队历年技术文章合集。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2b3edf48cf269da7c14fd5b5b148aa68.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;| 本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明&quot;内容转载自美团技术团队&quot;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=mailto%3A%E3%80%82%E6%9C%AC%E6%96%87%E6%9C%AA%E7%BB%8F%E8%AE%B8%E5%8F%AF%EF%BC%8C%E4%B8%8D%E5%BE%97%E8%BF%9B%E8%A1%8C%E5%95%86%E4%B8%9A%E6%80%A7%E8%BD%AC%E8%BD%BD%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E3%80%82%E4%BB%BB%E4%BD%95%E5%95%86%E7%94%A8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E8%AF%B7%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E8%87%B3tech%40meituan.com%E7%94%B3%E8%AF%B7%E6%8E%88%E6%9D%83%E3%80%82&quot; target=&quot;_blank&quot;&gt;。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至 tech@meituan.com 申请授权。&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/meituantech/blog/17091011</link>
            <guid isPermaLink="false">https://my.oschina.net/meituantech/blog/17091011</guid>
            <pubDate>Mon, 06 Jan 2025 09:11:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>MySQL 如何赶上 PostgreSQL 的势头？</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.percona.com%2Fblog%2Fhow-can-mysql-catch-up-with-postgresqls-momentum%2F&quot; target=&quot;_blank&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;我与 MySQL 社区的前辈交谈时，经常遇到这个问题：「为什么 MySQL 这么棒，而且（至少根据 DB-Engines 的计算）仍然比 PostgreSQL 更流行；但它的地位在下降，PostgreSQL 却势不可挡地越来越受欢迎？」MySQL 生态能做些什么来挽回局势吗？我们来探讨一下！&lt;/p&gt; 
&lt;p&gt;图片&lt;/p&gt; 
&lt;p&gt;来看看为什么 PostgreSQL 发展如此强劲，而 MySQL 却在走下坡路。我认为这归结于所有权和治理、许可证、社区、架构和开源产品的发展势头。&lt;/p&gt; 
&lt;h2&gt;所有权和治理&lt;/h2&gt; 
&lt;p&gt;MySQL 从未像 PostgreSQL 那样受到「社区驱动」。然而，当 MySQL 由瑞典小公司 MySQL AB 和 BDFL（仁慈的终身独裁者 -- Benevolent Dictator for Life，一个非正式称号，常用于幽默地称呼开源开发社区项目的发起人）Michael「Monty」Widenious 掌管时，它获得了很多社区的信任。更重要的是，它没有被大公司视为特别的威胁。&lt;/p&gt; 
&lt;p&gt;现在，情况不同了 -- 甲骨文拥有 MySQL，业内许多大公司，尤其云计算厂商，都将其视为对手。当然没有理由为对手贡献代码和营销，创造价值。此外，对于 MySQL，拥有 MySQL 商标的甲骨文公司总是有额外的优先权。&lt;/p&gt; 
&lt;p&gt;相比之下，PostgreSQL 由社区运行、其所有供应商都立足于一个商业前提：比起 PostgreSQL 生态中的小公司，EDB 这样的公司没有优先权。&lt;/p&gt; 
&lt;p&gt;这意味着大公司更愿意推荐 PostgreSQL 作为首选，因为这不会为它们的竞争对手创造价值，而且它们对 PostgreSQL 项目的方向有更大的影响力；而数以百计的小公司则通过本地「草根」社区的开发者和市场营销努力，使 PostgreSQL 在全球无处不在。&lt;/p&gt; 
&lt;h3&gt;MySQL 社区能做什么？&lt;/h3&gt; 
&lt;p&gt;社区能做的不多 -- 完全取决于甲骨文公司。我在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.percona.com%2Fblog%2Fcan-oracle-save-mysql%2F&quot; target=&quot;_blank&quot;&gt;《甲骨文能拯救 MySQL 吗》&lt;/a&gt;中也写到，给 MySQL 一个中立的基础（如跟 Linux 或 Kubernetes 合作），它才有和 PostgreSQL 竞争的机会。我并不乐观，因为我认为，甲骨文目前更感兴趣的是「硬」货币化（译者注：直接通过现有的产品和服务产生营收），而不是增加用户量。&lt;/p&gt; 
&lt;h2&gt;许可&lt;/h2&gt; 
&lt;p&gt;MySQL 拥有双重许可 -- GPLv2 和可以从甲骨文购买到的商业许可；而 PostgreSQL 只有宽松的 PostgreSQL 许可。&lt;/p&gt; 
&lt;p&gt;事实上，这意味着很容易创建&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.postgresql.org%2Fwiki%2FPostgreSQL_derived_databases&quot; target=&quot;_blank&quot;&gt;有商业许可的 PostgreSQL 衍生分支&lt;/a&gt;，或将其嵌入获得商业许可的项目中，不需要任何「变通方式」。当然，开发此类产品的人也在支持和推广 PostgreSQL。 MySQL 确实允许云计算厂商创建自己的商业分支，与 MySQL 兼容的亚马逊 Aurora 就是最著名、最成功的此类分支，但在软件发行时却不允许。&lt;/p&gt; 
&lt;h3&gt;MySQL 社区能做什么？&lt;/h3&gt; 
&lt;p&gt;还是那句话，能做的不多 -- 只有甲骨文公司能根据许可重新授权 MySQL，而我很难相信他们会减少对 MySQL 的控制，尽管采用「开放核心」和「仅限云」模式的软件，通常与采用宽松式许可「核心」的软件可以结合得很好（原文：even though「open core」and「cloud only」editions often play well with permissively licensed「core」software）。&lt;/p&gt; 
&lt;h2&gt;社区&lt;/h2&gt; 
&lt;p&gt;我认为，当我们考虑开源社区时，最好考虑&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpeterzaitsev.com%2Fthere-are-three-open-source-communities-not-just-one%2F&quot; target=&quot;_blank&quot;&gt;三个而不是一个社区&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;说到&lt;strong&gt;用户社区&lt;/strong&gt;，MySQL 的表现仍然相当出色，尽管 PostgreSQL 越来越多地成为新应用程序的首选。不过，用户社区往往是其他社区工作的成果。&lt;/p&gt; 
&lt;p&gt;PostgreSQL 中，&lt;strong&gt;贡献者社区&lt;/strong&gt;更强大，这是由许多组织推动的。我们举办了针对贡献者的活动，还编写了关于如何为 PostgreSQL 作出贡献的书籍。PostgreSQL 的扩展架构也有助于轻松扩展 PostgreSQL，并公开分享工作成果。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;供应商社区&lt;/strong&gt; -- 这才是主要问题，没那么多公司有兴趣推广 MySQL，因为这样只是在为甲骨文公司创造价值。 那么，这不会鼓励所有甲骨文「合作伙伴」去推广 MySQL 吗？ 有可能，全球范围内也确实有一些由合作伙伴支持的 MySQL 活动，但这些无法与供应商对 PostgreSQL 的支持相提并论，因为 PostgreSQL 是「他们的项目」。&lt;/p&gt; 
&lt;h3&gt;MySQL 社区能做什么？&lt;/h3&gt; 
&lt;p&gt;这次我不会说社区已经无能为力。其他领域的现状使工作更困难，回报也更少，但社区仍然可以做很多事情。 如果你关心 MySQL 的未来，请组织并参与各种活动，尤其是在 MySQL 社区之外。你可以写文章、录视频、写书，在社交媒体上推广，并将它们提交给 Hacker News。&lt;/p&gt; 
&lt;p&gt;尤其不要错过 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.mysqlandfriends.eu%2F&quot; target=&quot;_blank&quot;&gt;FOSDEM 2025 MySQL Devroom 的征集活动&lt;/a&gt;！&lt;/p&gt; 
&lt;p&gt;甲骨文公司也可以在不减少盈利的情况下参与。与潜在贡献者接触 -- 发起外部贡献者可以参与的活动，与他们分享计划，支持他们的贡献，至少在他们与 MySQL 社区蓝图相一致的情况下。&lt;/p&gt; 
&lt;h2&gt;架构&lt;/h2&gt; 
&lt;p&gt;一些 PostgreSQL 用户把 PostgreSQL 的发展势头归因于其更好的架构和更简洁的代码库。我认为这不是主要原因，但值得讨论。&lt;/p&gt; 
&lt;p&gt;PostgreSQL 的设计实现了大量功能强大的扩展，而 MySQL 只有有限的扩展可能性。最大的例外是存储引擎接口，MySQL 支持多种存储引擎，而 PostgreSQL 只支持一种（尽管 Neon 或 OrioleDB 这样的分支可以通过打补丁来改变）。&lt;/p&gt; 
&lt;p&gt;这种可扩展性使 PostgreSQL 易于创新（尤其在拥有更强大的贡献者社区的情况下），且无需纳入核心代码。&lt;/p&gt; 
&lt;h3&gt;MySQL 社区能做什么？&lt;/h3&gt; 
&lt;p&gt;即使 MySQL 的可扩展性有限，利用其已有的各种插件 (&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Fextending-mysql%2F8.0%2Fen%2Fplugin-types.html&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/doc/extending-mysql/8.0/en/plugin-types.html&lt;/a&gt;) 和组件 (&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.4%2Fen%2Fcomponents.html&quot; target=&quot;_blank&quot;&gt;https://dev.mysql.com/doc/refman/8.4/en/components.html&lt;/a&gt;)，也还是可以做很多事情的。&lt;/p&gt; 
&lt;p&gt;首先需要针对 MySQL 插件的社区市场，这将鼓励开发者构建更多插件，且容易关注。 我们还需要甲骨文的支持 -- 承诺扩展 MySQL 插件架构，支持开发者构建插件，即使它们会与甲骨文的产品竞争。 例如，如果 MySQL 拥有创建自定义数据类型和可插拔索引的插件，也许就已经有用于 MySQL 的 PNG 向量替代方案。&lt;/p&gt; 
&lt;h2&gt;开源产品的发展势头&lt;/h2&gt; 
&lt;p&gt;选择数据库是一个长期的赌注，因为更换并不容易。问问那些几十年前选择甲骨文，现在又被它困住的人就知道了。这就意味着，选择数据库时需要考虑未来：不仅希望所选的数据库十年后还会存在，而且要考虑它是否会随着时间推移而发展，以满足未来的技术需求。&lt;/p&gt; 
&lt;p&gt;正如我在文章《甲骨文最终会杀死 MySQL 吗》（见 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpercona.com%2Fblog%2Fis-oracle-finally-killing-mysql%2F%EF%BC%89%E4%B8%AD%E6%89%80%E5%86%99%EF%BC%8C%E7%94%B2%E9%AA%A8%E6%96%87%E5%B7%B2%E5%B0%86%E5%A4%A7%E9%87%8F%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E9%87%8D%E5%BF%83%E8%BD%AC%E7%A7%BB%E5%88%B0%E4%B8%93%E6%9C%89%E5%92%8C&quot; target=&quot;_blank&quot;&gt;https://percona.com/blog/is-oracle-finally-killing-mysql/）中所写，甲骨文已将大量开发者的重心转移到专有和&lt;/a&gt; Cloud-only MySQL 版本上，MySQL Community 几乎已废弃。MySQL 在今天许多应用中仍非常出色，但它的确落后了，MySQL 社区中许多人质疑它是否适合未来的发展。&lt;/p&gt; 
&lt;h3&gt;MySQL 社区能做什么？&lt;/h3&gt; 
&lt;p&gt;再次强调，MySQL 的发展主要取决于甲骨文公司，因为是他们一手推进了 MySQL 的官方路线。至于 Percona Server for MySQL？我们确实提供了甲骨文 MySQL 的领先开源替代方案，但必须注意所作的改变，以免破坏完全兼容性或使上游合并成本过高。MariaDB 则作出了不同的权衡；不受限制的创新使其与 MySQL 的兼容性越来越差，而且每个版本的差异也越来越大。&lt;/p&gt; 
&lt;h2&gt;MariaDB&lt;/h2&gt; 
&lt;p&gt;MariaDB 由 MariaDB 基金会管理，不是已经尽可能地解决了所有这些问题吗？ 别急！我认为，MariaDB 是一个&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.percona.com%2Fblog%2Fopen-source-and-flawed-foundations%2F&quot; target=&quot;_blank&quot;&gt;有缺陷的基金会&lt;/a&gt;，它并不拥有所有的知识产权，尤其是商标，无法为所有供应商提供公平的竞争环境。它仍然存在商标垄断问题，因为只有一家公司能提供 MariaDB 的所有东西。&lt;/p&gt; 
&lt;p&gt;不过，MariaDB 可能有机会；MariaDB（公司）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fk1.com%2Fk1-acquires-mariadb%2F&quot; target=&quot;_blank&quot;&gt;刚被 K1 收购&lt;/a&gt;，管理和商标所有权有机会发生变化，更接近 PostgreSQL 的情况。只是私募股权公司不擅长减少对商标知识产权的控制，所以希望不大。&lt;/p&gt; 
&lt;p&gt;MariaDB 基金会可以将其更名为 &lt;em&gt;SomethingElse&lt;/em&gt;DB，从而获得对该项目的完全商标控制权，但这意味着 MariaDB 将失去其所有的知名度；这种情况不太可能发生。&lt;/p&gt; 
&lt;p&gt;MariaDB 与 MySQL 也有很大区别，协调两者之间的差异需要多年的努力。但只要有足够的资源和社区意愿，这是可以解决的。&lt;/p&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p&gt;如你所见，由于 MySQL 的所有权和管理方式，社区的活动受到了限制。长远来看，MySQL 社区与 PostgreSQL 竞争的唯一途径是所有重要的参与者联合起来（就像 Valkey(&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvalkey.io&quot; target=&quot;_blank&quot;&gt;https://valkey.io&lt;/a&gt;) 那样），在不同的品牌下创建一个 MySQL 替代方案 -- 这可以解决上面提到的大多数问题。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;💡 更多资讯，请关注 Bytebase 公号：Bytebase&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/6148470/blog/17103668</link>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/17103668</guid>
            <pubDate>Mon, 06 Jan 2025 07:52:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>TIOBE 2024 年度编程语言：Python</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;TIOBE 宣布 2024 年度编程语言花落 Python，该语言在 2024 年的涨幅高达了 9.3%；远远领先于其竞争对手：Java +2.3%、JavaScript +1.4% 和 Go +1.2%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;TIOBE CEO&amp;nbsp;Paul Jansen&amp;nbsp;点评道，「如今 Python 无处不在，它是许多领域无可争议的默认语言。它甚至可能成为 TIOBE 指数中排名最高的语言。Python 唯一的严重缺点（因此为竞争留下了空间）是性能不足，并且大多数错误发生在运行时。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;75&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d22928e75006563e2a3fb192b5d76501174.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;纵观&amp;nbsp;2024 年的 TIOBE 指数榜单，前 10 名中还发生了两件值得注意的变动：包括 C 语言被 C++ 和 Java 超越，主要原因是 C 在许多嵌入式软件系统中被 C++ 取代；以及 PHP 最终跌出 top 10，被 Go 所取代。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rust 和 Kotlin 是两种备受关注的语言。Rust 在 2024 年变得越来越流行，但与之相反，Kotlin 在榜单中并没有取得突破，「甚至在 2024 年（可能永远）失去了前 20 名的位置」。不过 Paul Jansen 也指出，尽管 Rust 发展速度惊人，但其陡峭的学习曲线永远不会使其成为普通程序员的通用语言。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;除此之外，还出现了两种有前途的新兴语言 Zig 和&amp;nbsp;Mojo；在 2024 年分别从第 149 位跃升至第 61 位，以及从第 194 位跃升至第 68 位。「尤其是 Mojo，它在两年前才首次发布，却恰好满足了编程领域的需求。我对它在 2025 年跻身前 20 名寄予厚望。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong style=&quot;color:#333333&quot;&gt;TIOBE 1 月 TOP 20 编程语言&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;406&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c41c40277d73f062e002a0c9c5590716123.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong style=&quot;color:#333333&quot;&gt;TOP 10 编程语言 TIOBE 指数走势（2002-2024）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;228&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0ba2298b4e04a1189e2487f7037c98b2794.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong style=&quot;color:#333333&quot;&gt;第 21-50 名编程语言排行&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;413&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-17a0369414679a38ada970e8b374e57fdd6.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;第 51-100 名如下，由于它们之间的数值差异较小，仅以文本形式列出（按字母排序）：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;ABC, ActionScript, Algol, Apex, APL, CFML, CHILL, Clipper, CLIPS, Clojure, Curl, Elm, Erlang, F#, Forth, Groovy, Hack, Icon, Inform, Io, J#, JScript, LabVIEW, Ladder Logic, Modula-2, Mojo, MQL5, NATURAL, Nim, OCaml, Occam, OpenCL, OpenEdge ABL, PL/I, PostScript, Q, Ring, S, Scheme, Simulink, Smalltalk, SPARK, SPSS, Stata, SystemVerilog, Tcl, Vala/Genie, VHDL, Wolfram, Zig&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;TIOBE 编程社区指数（The TIOBE Programming Community index）是一个衡量编程语言受欢迎程度的指标，该指数每月更新一次。评判的依据来自世界范围内的工程师、课程和第三方供应商，包括流行的搜索引擎，如 Google、必应、雅虎、维基百科、亚马逊、YouTube 和百度都被用于指数计算。值得注意的是，TIOBE 指数并不代表编程语言的好坏或编写代码的多少。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;该指数可以用来检查你的编程技能是否还能跟上时代的步伐，或者在开始建立一个新的软件系统时，基于指数对采用何种编程语言做出决策。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2Fprogramminglanguages_definition%2F&quot; target=&quot;_blank&quot;&gt;TIOBE 指数&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;的定义方式，以及详细榜单信息&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F&quot; target=&quot;_blank&quot;&gt;均可查看官网&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/296488/tiobe-index-202406&quot; target=&quot;news&quot;&gt;TIOBE 6 月榜单：C++ 史上首次超越 C，跃至榜二&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/311117/tiobe-index-202409&quot; target=&quot;news&quot;&gt;TIOBE 9 月榜单：Java 上位，C 语言跌至历史最低&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328650/tiobe-index-202501</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328650/tiobe-index-202501</guid>
            <pubDate>Mon, 06 Jan 2025 07:50:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>夜莺监控突破一万 star，聊聊四年感悟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p style=&quot;color:#3f3f3f; margin-left:10px; margin-right:10px; text-align:left&quot;&gt;欢迎来到 2025 年！你的 2024 年终总结都写好了吗？记得发博客，私信【&lt;a href=&quot;https://my.oschina.net/u/3859945&quot;&gt;开源中国编辑肖滢&lt;/a&gt;】哦！&lt;br&gt; 想看大家的年终总结？请看专栏：&lt;a href=&quot;https://www.oschina.net/news/column?columnId=28&quot;&gt;【拜拜，2024！】&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;夜莺监控项目在上周突破了一万 star，算是一个小小的里程碑。在开源领域，通常把 star 数量看作项目的繁荣指标，star 数量越多，说明愿意关注你的人越多。这个数字的背后，是一群人对你的鼓励、认可和支持，当然，还有鞭策。夜莺项目最早发起于 2020 年初，发展到现在接近四年时间，本文想借此机会聊聊我们做开源的初心，这四年的感悟，以及多方共赢的商业模式设计。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;项目简介&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;&lt;img alt=&quot;夜莺项目&quot; src=&quot;https://download.flashcat.cloud/ulric/20241230091039.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;夜莺项目最初是我们在滴滴的时候开源的，后来捐赠给中国计算机学会开源发展委员会进行托管，以基金会的方式运作。其 github 地址是&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fccfos%2Fnightingale&quot; target=&quot;_blank&quot;&gt;https://github.com/ccfos/nightingale&lt;/a&gt;，其中 ccfos 就是 CCF OpenSource，即中国计算机学会开源项目的统一地址。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;项目至今，有 130 位 contributor 参与，共提交了 2600 多次 commit，发版了 170 多次，fork 数 1400，docker pull 228k，虽说我们还有很多不足，但这些数字让我们看到了持续进步的汗水。如果一个开源项目可以坚持投入 4 年，甚至 10 年，20 年，我们坚信它的社会价值会越来越大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;项目发起初心&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;如果聊到项目开源的初心，那得追溯到 10 年前我们开源 open-falcon 那会了，当时确实啥都不懂，就是凭一腔热血为爱发电，当时觉得吧，我们搞了一个自认为还不错的项目，独乐乐不如众乐乐，放出来大家一起完善，项目会越发牛逼。当时的我们，也没有想过什么商业模式，只是想把这个项目做好，让更多人用，让更多人参与。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;实际遇到了如下一些问题，如果你也做过开源项目，估计会很有同感：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;维护者的心理压力大 
  &lt;ul&gt; 
   &lt;li&gt;经常碰到不看文档的小白用户，问各种基础问题。就像一个二年级的小学生经常被问 1+1 等于多少，时间久了，会很厌倦&lt;/li&gt; 
   &lt;li&gt;偶尔会碰到颐指气使的人，用了你的项目，觉得你欠他的的一样，但凡遇到问题，不管是不是自己的问题就恶语相向&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;&lt;img alt=&quot;开源项目维护者秒懂的痛苦&quot; src=&quot;https://download.flashcat.cloud/ulric/20241230100240.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;维护者时间精力有限 
  &lt;ul&gt; 
   &lt;li&gt;大部分开源项目都是维护者兼职在搞，时间精力有限，毕竟养家糊口才是第一位的，搞开源是上层精神层面的追求了&lt;/li&gt; 
   &lt;li&gt;这会导致有些问题处理不够及时，显然，这会导致用户不满。周末照顾家人时收到陌生人提问那也是家常便饭，我不开心，用户也不开心&lt;/li&gt; 
   &lt;li&gt;当维护者调岗跳槽之后，基本就不会继续参与了，这对项目而言是致命的&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;项目功能发展设计其实还是靠你自己 
  &lt;ul&gt; 
   &lt;li&gt;会有水平很高且愿意和你探讨项目设计发展的人，但确实数量不多，毕竟大部分开源项目影响力有限&lt;/li&gt; 
   &lt;li&gt;也会有参与者，通常是小修小改，偶尔还会碰到巨型 PR，是要改你的命名规范，因为他觉得现有的命名规范不符合他的审美&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;后来发起夜莺项目，我们就在思考如下这个关键问题：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style=&quot;color:#333333&quot;&gt;如何才能让一些人才持续全情投入？只要有人持续投入，项目一定会越来越好，不管是功能层面、性能层面，还是文档、社区支持，只要有人持续参与，一切都会越来越好。但是人家得养家糊口啊，除非给人发工资。工资从哪里来？靠项目自身去赚不就行了。于是，，，我们创业了，做了一家公司叫快猫星云。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;但是，事情远没有这么简单。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;开源和商业的天然悖论&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;我们想到的第一个模式是靠技术 Support，因为 RedHat 就是这么干的。普通用户提供社区支持，商业用户提供商业支持，如果客户在生产环境部署了你的软件，为了防止紧急生产故障，买个 Support 以防万一，这理所当然，看起来是个好模式。但也仅仅是看起来，实操中会发现如下问题：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;监控、可观测性系统，我们觉得是 P0 级服务，但是很多客户觉得不影响核心系统所以没关系，重视程度不高，如果是核心 DB 或 OS，那就不一样了&lt;/li&gt; 
 &lt;li&gt;开源做的越好，比如功能越稳定、丰富，文档越完备，用户遇到的问题越少，越不需要 Support，如果开源做的不好，用户量起不来，也不会有商业用户&lt;/li&gt; 
 &lt;li&gt;边界不好界定。如果只是夜莺软件本身出问题我们来提供支持理所当然，那客户问这个 promql 怎么写？达梦数据库怎么监控？这些问题就很难界定了&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;所以，技术 Support 根本没有大规模商业化的底层逻辑支撑。如果你只是个人项目，养活自己就行，或者只是想赚点外快，这个模式或许还行，如果只是想养活几个人，这个模式我都觉得很难。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;另外，开源监控、可观测性项目，可选择的项目还比较多，你如果收费，别家免费，即便你做的更好，也很难有人买单。你有养家糊口的压力，但是其他有些项目的研发人员人家已经财务自由了，人家就是可以全职不拿钱做开源，你怎么办？&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;多方共赢的商业模式设计&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;其他领域不敢讲，监控、可观测性这个领域，如何设计一个多方共赢的商业模式？我的个人观点（注意，只是个人观点）如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;开源的部分，需要是功能闭环的，即，不依赖商业功能也能用的起来。而且这部分功能要足够好，让用户觉得用的很爽，这样才能吸引用户。这部分承接了我们的精神层面的诉求以及商业营销层面的诉求。这部分功能，我们可以把它叫做社区版。我们要在社区版这块投入全职人力，给他们发工资做开源。&lt;/li&gt; 
 &lt;li&gt;没有预算的开源用户，可以免费使用社区版，有社区提供的技术支持，虽然响应速度没有商业版快，总还会有人响应，比那些动不动就撂挑子的开源项目会强很多。&lt;/li&gt; 
 &lt;li&gt;有预算的用户，可以购买商业版，商业版的功能要比社区版更强大，技术支持也更及时。比如开源版会重点做告警引擎功能，而商业版会做大一统的可观测性平台。其定位不能相同，定位相同了就没法取舍，比如一个功能是放社区版还是商业版，就很难界定了。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;其他一些 ToB 商业公司同行可能会觉得我们这种做法就是毒瘤。因为我们开源的部分抢了他们的生意，但实际上，我们开源的是基础监控告警能力，即便没有我们，还是会有 Prometheus，会有 Zabbix 这些前辈在，如果 ToB 公司的生意能够被开源项目抢走，说明你的产品能力可能还需要加强。而社区版也承载了我们的精神层面的诉求，我们希望为社会提供一个好用的监控系统，让更多人受益，这是初心，我们不可能放弃。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;活下去是责任，留下点什么才是关键价值&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;有些创业导师说，如果你只是为了钱，那不应该创业。实际上，创业的原因哪能是单一的。肯定是既要又要还要啊。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;既要赚到钱，养家糊口，发得起工资，这是责任&lt;/li&gt; 
 &lt;li&gt;又要部分员工可以全职做开源，满足一下精神层面的需求&lt;/li&gt; 
 &lt;li&gt;还要让飞轮转起来，越做越好越做越大，让各方受益&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; text-align:left&quot;&gt;如果，我是说如果，我们站在生命的尽头，回首往事，什么会相对更有价值？我想，可能是过程中一起经历的风雨，以及我们生命留下的痕迹，我们在开源项目上的付出，可能会是我这碌碌无为的一生中最深的那个痕迹了吧。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/morflameblog/blog/16975194</link>
            <guid isPermaLink="false">https://my.oschina.net/morflameblog/blog/16975194</guid>
            <pubDate>Mon, 06 Jan 2025 06:59:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>报告老板！2024 年度总结请查收</title>
            <description></description>
            <link>https://www.oschina.net/news/column?columnId=28</link>
            <guid isPermaLink="false">https://www.oschina.net/news/column?columnId=28</guid>
            <pubDate>Mon, 06 Jan 2025 06:55:00 GMT</pubDate>
        </item>
        <item>
            <title>商汤科技回应被列入美国防部名单：毫无事实依据</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对美国国防部于当地时间 2025 年 1 月 6 日将商汤加入「中国军事企业清单」一事，商汤科技发布声明称：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;我们认为此举毫无事实依据，对此我们表示强烈反对。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;该清单的主要影响是名单上实体公司不能成为美国国防部的供应商，对商汤业务没有实质影响。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商汤将尽快就此事与各方积极沟通，以确保获得公正的对待，并最大限度保护公司和股东的利益。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;256&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2e4341484e469f44bc6fcbcfc0ec99ce81a.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/328595&quot; target=&quot;news&quot;&gt;腾讯回应被列入美国防部名单：是个错误&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328602</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328602</guid>
            <pubDate>Mon, 06 Jan 2025 03:17:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Cursor 的开源替代来了：Roo-Cline</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Cursor 的开源替代这么快就来了！&lt;/p&gt; 
&lt;p&gt;Roo-Cline，不但拥有 Cursor 原本的功能，甚至可以命令行交互，以及打开浏览器做基于 AI 的交互测试！&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2088&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0107/110015_NNOo_2720166.png&quot; width=&quot;2508&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;使用任何 API 和模型&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-761c6d2eb24db3b9931b2ee252f1d69aca7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Cline 支持 OpenRouter、Anthropic、OpenAI、Google Gemini、AWS Bedrock、Azure 和 GCP Vertex 等 API 提供商。还可以配置任何与 OpenAI 兼容的 API，或通过 LM Studio/Ollama 使用本地模型。如果使用 OpenRouter，扩展程序会获取其最新的模型列表，可以尽快使用最新模型。&lt;/p&gt; 
&lt;p&gt;该扩展还会跟踪整个任务循环和各个请求的总令牌和 API 使用成本，随时了解每一步的支出情况。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;在终端中运行命令&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-fa2727c03b27632312f2f47b35edc4f00f6.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;得益于 VSCode v1.93 中的新 shell 集成更新，Cline 可以直接在终端中执行命令并接收输出。这使他能够执行各种任务，从安装软件包和运行构建脚本到部署应用程序、管理数据库和执行测试，同时适应你的开发环境和工具链以正确完成工作。&lt;/p&gt; 
&lt;p&gt;对于开发服务器等长时间运行的进程，请使用「运行期间继续」按钮让 Cline 在命令在后台运行时继续执行任务。在 Cline 工作期间，他会收到有关任何新终端输出的通知，让他对可能出现的问题做出反应，例如编辑文件时出现的编译时错误。&lt;/p&gt; 
&lt;p&gt;更多内容详见： &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FRooVetGit%2FRoo-Cline&quot; target=&quot;_blank&quot;&gt;https://github.com/RooVetGit/Roo-Cline&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328600</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328600</guid>
            <pubDate>Mon, 06 Jan 2025 03:01:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>2025：智能世界的 50 个潜在可能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;2025 年的总体特征，可以用 「确定性海啸、多领域临界点、AI 自身范式转变、万物智能体、极化有反身性、亟需群体智能」 这 6 点来概括。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;今天发表我经过持续预研所做出的新年预判：「2025 年的 50 个可能」，分别从生态、业态、技术、产品、企业等五个角度展开。均为对可能发生之事的预判，不是对已发生之事的罗列。仅供参考。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;非常确定 2025 年大模型应用进入大幅增长期，更重要的是：「确定性」 本身进入临界点。2024 年基本面的一个重要变化是，主要各方完成了对 AI2.0 的确认，对 AI 原理演进、技术能力、产业价值、发展路径、应用加速、商业闭环的确认 - 确信 - 确定。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;确定不是泡沫豪赌，确定必然捧得 AGI 圣杯，确定算力和能源其实可持续，确定千行百业数十亿人必然广泛使用，确定 AI2.0 会从文本数据走向现实世界，确定产业飞轮可以闭环，确定这是一个亿万价值的万亿产业…… 本来就已经冲击力十足的 AI2.0 风暴，经过确认之后，各方更是加速 All In，加之应用已到可用和高可用区间，市场加速成长。AI 2.0 的能量迸发因此必然而然。从此潮流滚滚。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;如果说 30 年前在中国发轫的互联网是技术大潮，2025 年的 AI2.0 是扑面而来的科技海啸。其速度力度广度远超当初培育十多年才开始走上正轨的互联网。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;生态面：全方位生态竞争，全球数字基础设施，比拼长创新、后程与内外活力&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;1. 人工智能从 10 个层面进入全方位生态竞争，新 IT 端边云网感算数智 8 要素成为全球化基础设施，以及全球化 4.0 秩序的重要基石。新 IT G8 企业首当其冲。参见我专文《六位两体的再全球化》和《新 IT-G8》。&lt;/p&gt; 
&lt;p&gt;2.超级智能与超级平台合体，竞争门槛向百亿美金抬高，生态位优势与智能优势相互增强，促使智能力量快速极化，头部与长尾差别远大于互联网，企业与国家、社会及地缘政治关系发生改变，科技中心主义引起警觉。&lt;/p&gt; 
&lt;p&gt;3.后程乏力现象、长创新内力不足问题可能浮现，信心增强同时 2025 须关注可持续性，AI 发展实质来自生态能力、生态现象而非单点突破。以生态创新为创新观进入视野。参见我专文《根问题-源认知-6 基点：AI 中国如何可持续发展》和《从一心炼丹到全生态竞争》。&lt;/p&gt; 
&lt;p&gt;4. 经济景气、一级市场投资萎缩向产业深度传导，科创领域需警惕生态断层、负循环可能，资本金融闭环亟待打通，资本闭环是商业闭环不可或缺部分。&lt;/p&gt; 
&lt;p&gt;5. 遍布二十多个领域的 AI 创作者经济全面崛起，与环境底色形成明显反差，成为搅动中国经济的活力热泉。参见我专文《创作者经济崛起：智客搅热中国经济，AI 催生发展新活力》。&lt;/p&gt; 
&lt;p&gt;6. 就业冲击转瞬逼近，AI 确定是史上多次科技革命以来第一次造成的失业大于创造的就业的科技革命，软件业与程序员的痛苦，快速向其他人群逼近。冲击之下是否会出现生态失衡需要密切关注。参见我专文《智能革命快社会转型慢：人类智慧不能输给时间鸿沟》。&lt;/p&gt; 
&lt;p&gt;7. AI、机器人、汽车成为新一轮中国威胁论的三个靶点，同时也是送料焦点，围绕这三个领域的地缘角力最为胶着，高算力汽车 SoC 供应可能受限。&lt;/p&gt; 
&lt;p&gt;8.美对中可能从断点脱钩转向生态抑制，通过改变供应链与供求关系，使得产业链、科技生态无法形成良性的正向循环，以此限制中国科技产业升维发展能力。进口之外芯片出口可能承压。双体系成型，产业市场正向循环的临界点与大分流的分岔点同时到来。&lt;/p&gt; 
&lt;p&gt;9.并非基本政策取向发生改变，鼓励发展的同时，从税务、反内卷、反不正当竞争、反对滥用生态支配地位以及数据隐私等传统角度，治理可能加杠杆，规范产业市场规训企业行为，reset 行业与其它行业各重关系。参见我专文《内卷真相：为什么平台热衷价格战以至于走向仅退款，商家却困在了流量里》、《比亚迪意欲何为》。此外，黑盒 AI 不是一个好的用户体验，从监管角度看，白盒 AI 是共同取向之一。&lt;/p&gt; 
&lt;p&gt;10.智能重塑出海，AI2.0 赋能新出海，不仅提升科技含量与创新活力，且有助于告别资源成本价格外卷的传统扩张范式，重新定位出海新力量在全球产业链分工与供应链位置，但思维观念与文化精神重塑相对滞后，走出去的在地化生存发展之道仍需探索磨合。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;业态面：AI 向实从移动端爆发，Scaling Law 持续」，超级」背后是极化&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;11.各方完成对 AI2.0 信心确认，大模型在多类场景实现可用高可用，投资与应用市场均进入加速扩增临界点。放缓论、瓶颈论、泡沫论比以往任何时候都要大的时候， 头部企业信心、决心和力度比以往任何时候都要大。参见我专文《非常确定 2025 年大模型应用进入大幅增长期》、《大模型争议中的 6 点共识和趋向》。&lt;/p&gt; 
&lt;p&gt;12.移动端后发先至，实时语音自然交互体验成熟力促手机越过 PC 率先起飞，亿万用户高频使用，DAU-时长-UP 值变化显著。&lt;/p&gt; 
&lt;p&gt;13.AI 向实，To B 角度微调、结合 RAG 与知识库等对开源模型效果改善显著，幻觉程度明显减轻，行业垂直场景付诸规模实用。&lt;/p&gt; 
&lt;p&gt;14.部分闭源大模型企业也会推出开源模型，开源模型的开源力度阶梯化，高阶模型开源力度收缩，To B 市场、PC 及移动端成为开源力量倍增器，开源活力不减。&lt;/p&gt; 
&lt;p&gt;15. 算力军备竞赛企稳但不会明显放缓，国际头部企业算力基础设施投资金额在百亿美金以上。十万卡走向数十万卡，甚至百万卡架构也在准备中。国产算力成为国内采购主体，算力结构性过剩与不足同时存在，算力的总体利用率有待提高。&lt;/p&gt; 
&lt;p&gt;16.Scaling Law 既未失效，也未放缓。LLM 单位训练单位推理的算力消耗与成本均显著持续下降，但是多模态、视觉理解、空间智能的训练与推理，思维连长思考等深度推理对数据与算力的需求在急剧增长，基于现实感知的万物智能将导致算力与数据的指数级增长。数据枯竭从来都是伪命题，抛开合成数据，感知会打开数据新世界。参见我专文《不，Scaling Law 不仅长期有效，而且世界才刚刚打开》、《AI 革命是否失去动力，算力开始过剩了吗》。&lt;/p&gt; 
&lt;p&gt;17.市场集中度快速提高，全球市场主要向 Google、OpenAI、Meta、Anthropic、xAI、五家集中，Apple 会加速自有端云模型研发迭代；中国市场集中过程相对缓和，百度、字节、腾讯、阿里优势保持，华为会提速，月之暗面、智谱、幻方、科大讯飞、MiniMax、面壁、零一万物等可能寻求差异化发展，部分企业可能寻求生态联盟或重组合作，百川等继续转向垂直领域专业模型。小米、理想、荣耀等可能成为变局新势力。CV 背景 AI1.0 企业切入 AI2.0 的，生态影响与能见度不高。&lt;/p&gt; 
&lt;p&gt;18.超级入口成型的同时，苹果税也重新引起注视。跨国公司穿透国家市场壁垒的全球化利器，可能因为生态内 Apps 与开发者等合作伙伴对超级入口的抗拒而变钝，通过 Store 抽税模式的移动生态基石可能动摇。应用场景面向超级入口全程贯通之际，平台与 Apps 可能开始构思动态实时的创新结算关系。但 2025 年这个时机略早。参见我专文《超级入口开始浮现》、《美 WDC 法官裁定 Google 违背反垄断法律，不是终局》。&lt;/p&gt; 
&lt;p&gt;19.固态电池、智能驾驶 SoC 等相关问题会让各方意识到，中国新能源与智能汽车产业没有护城河问题可能浮现。参见我专文《中国电动车不是没有核心技术而是没有护城河》。未来产业市场领导力主要来自能源、智能、形态、生态四要素。四要素都还在迭代过程中。如果不能快速升维就会被降维打击。几年后采用磷酸铁锂、三元锂电池以及没有高阶智驾系统装车的二手新能源车继续大幅贬值，会是这个问题的注脚。汽车市场三个转换加速进行：消费力/性价比转换（消费在支出降级中需求升级），产品形态/产品力转换（能源跨越形态跨越级别跨越），品牌心态转换（造车新势力和国产车认可度上升）。也关注智能体与座舱的场景化反。国产车态势总体乐观。&lt;/p&gt; 
&lt;p&gt;20.数智人算力基点从 1000TOPS 向 10000TOS 长期演进，目前达到 1000TOPS 的只是极少数人，但个人智能设备生态与未来的算力关系已经隐约可见。参见我专文《一个人的算力未来能有多？》。每个人都会有自己的 IC 也就是智脑，智脑又会是每个人自己的 CP。手机、电脑、智能体、AI 助手等，都是智脑的一部分。智脑是人成为智慧人的基础，也是每个人成为超体个体的标配。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;技术面：原理产生原力，AI 范式转移，AGI 分无数次到来，2025 年没有一个 AI Agent 是真正的智能体&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;21.大模型底层原理升维成为头部核心玩家着力重点，模型成本效率提高是跟跑型企业的着力重点。模型素能提升是线性观察角度，模型原理变化背后是智能与世界关系的不断重构，以及智能本身的范式转移，原理产生原力。从长期演进角度看，LLM 大语言模型是基座模型的第 1 范式，多模态基础模型 MFM 是第 2 范式，物理世界与科学模型是第 3 范式，融合现实模型是第 4 范式，自主智能模型是第 5 范式，真正的世界模型是第 6 范式，越往 4、5、6 越遥远。参见我专文《Ilya 似乎困在了 LLM 里》、《原理之变：脉冲神经网络是方向吗》、《原力来自原理：AI 图像原理之变的 6 个特征》、《模型原理是「AI 的第一性原理」》。&lt;/p&gt; 
&lt;p&gt;22.进取型的和有实力的中国大模型提供商，会密切关注跟进 KAN、SNN、Mamba、TTT、Lory、CLLM、LANISTR、RL4VLM、VLA、LCM、MLLMs、LWM 等原理不同层面和技术架构不同方面的变化，而不是以量化、蒸馏等带来的算力与成本降低作为突破亮点，参见我专文《智能发展四象限》、《内场和外场，内卷和外卷》。&lt;/p&gt; 
&lt;p&gt;23.这一年引领型的前沿突破，将来自 LWM 之于空间智能、VLA 之于智能驾驶、视觉理解之于具身智能、融合感知之于 SICAS 智能体的早期探索。感知理解、智能交互与行为能力是智能进化方向。参见我专文《从问答智能到行为智能，Pool 是生发未来的新角度》、《现实感知来了，空间智能有了原生传感基础》。&lt;/p&gt; 
&lt;p&gt;24.站在每个最终用户角度响应需求、统合进程、达成任务的 AI Agent 在 2025 年必然大热，精调微调、模块化、个性定制、可自然交互的 AI Agent 是 AI2.0 所有产品服务的最后一米，也是每个用户辐射全网的智能半径，更是深度整合其它应用尤其是互联网服务并且 OTT 竞争对手形成超级入口的关键。从中长期看，AI Agent 处于数字与现实交汇点这一战略要地。主要平台 2025 年在 AI Agent 方面必然重兵投入，快速演进产品，强力挤占市场。&lt;/p&gt; 
&lt;p&gt;25.但是 2025 年你不会看到哪怕一个真正的智能体，尽管从一开始智能体、AI Agent 就经常被混为一谈，且几乎所有 AI Agent 都被视为智能体。智能体在当下是个有名无实的伪概念，产品包装和营销鼓惑意味远大于实际能力本身，但未来智能体不是概念，而是最赫赫然的智能形态的主流存在。智能体将是包括 AI Agent、数字机器人、实体机器人乃至万物智能场景下几乎所有智能设备的完整形态，甚至是终极形态。万物智能，实际指向万物智能体。当下几乎所有 AI Agent 都不符合智能体的基本特征和 SICAS 的行为能力模型。&lt;/p&gt; 
&lt;p&gt;26.无限代理是 AI Agent 与智能体的桥接，以通用基础模型中作为脑能力底座，以对物理世界和数字世界的理解为基础，以每个用户的个性化场景和需求为基础，进行持续交互、完成任务。但无限代理在实时感知、场景底层统合两个部分的缺陷，使其与成为数字智能体的目标依然有相当距离。&lt;/p&gt; 
&lt;p&gt;27.尽管不断有强烈冲击舆论视听的「新动作」，但是机器人 2.0 其实依然处于突破前夜，具身智能的基础要件与能力尚在形成过程当中，尤其人形机器人 2025 年销量见长但总量有限。四肢发达与小脑能力进步显著，但大脑能力依然有待深度进化，LLM 局部高可用和视觉理解会带来短期增益，而具身智能的长期突破来自于智能体 SICAS 行为能力模型驱动下尤其在实时感知、智能交互这两个部分的进步。&lt;/p&gt; 
&lt;p&gt;28.实际上不会有一个统一的、时间刻度清晰的 AGI 时刻，AGI 是分无数次到来的，有无数个 AGI 时刻。参见我专文《AGI 过程》。不同能力、角度、模态、任务、学科、行业、智能体的 AGI 时刻是不同的。等待一个时间唯一目标唯一通用智能大模型唯一的 AGI 时刻，无异于守株待兔、刻舟求剑。2025 年从不同应用所能达到的可用水准角度，非已知的新颖任务的测评得分在 95 分以上以及超过人类在该领域表现的，都可以称之为这个领域的 AGI 时刻。数学、编程最先可能达成这一目标。&lt;/p&gt; 
&lt;p&gt;29.专业模型、科学模型方面 2025 年将取得显著进展，金融、医疗、教育、法律等领域以及 AI4S 不同模型的纵深拓展，是卓有成效的一年。参见我专文《科学的范式转移正在真真切切发生》。相比人工智能，生物计算、脑机接口、量子计算不断有新的亮点，但整体进展其实比较缓慢。&lt;/p&gt; 
&lt;p&gt;30.能源角度，美国重启核能的同时发展小型核能供电站，中国局部考虑结构性过剩的风能、太阳能电力资源的合理配置和就地消纳，但储能调峰的成本效率问题一时难解。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;产品面：脑能力驱动汽车等机器走向智能体，手机走向超级入口，人走向超级个体，AI Glass 等新硬件涌现，网络连接驱动场景之变，Web3.0 组织结缔&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;31. 中国市场新能源上市新车中 L2 及以上智能辅助驾驶系统装配率可能达到 80%，新车中纯电-增程-混动等新能源车总占比年度峰值可能达到 60%-70%，但 L3 能力成为年度发展重点，以及用户购车重点考虑因素，AEB 响应范围和成功率不够高的短板问题亟待解决，与智驾系统深度整合势在必然；所有 AEB 实际达不到车规级标准的 L3 都是伪 L3。参见我专文《用户和车企需要认知对齐》。&lt;/p&gt; 
&lt;p&gt;32.AI Glass2025 年会火，百镜大战端倪初现，销量达到智能手表早期水平。带简单非 AR 显示的 AI Glass 价格低销量占比高，有 AR 显示的 AI+AR 的 AIR Glass 价格高数量少销量占比低。Apple Atlas、Meta Orion 等高成本 AIR Glass 难以正常面市。2025 年看到的绝大部分产品会有过渡形态的感觉，但对形成一个可售卖可用产品来说已经基本够了。添加简单显示的 Ray-Ban 改款和基于 M4 或 M5 芯片的 AVP 改款，体验会有明显改善。参见我专文《2025 年 AIR Glass 的 20 个信号》和《AIR Glass 才是智能眼镜的主力方向》、《AIxAR=AIR》。&lt;/p&gt; 
&lt;p&gt;33. 手机这个传统物种的用户体验与获得感的改变，2025 年反倒可能是比较显著的一年。从高通、荣耀、华为、Vivo、联发科、小米包括 ARM 等企业的最新动作及苹果相关传闻来看，2025 年会是智能手机大年，且有多场热战。AI 显而易见是第一战场，超级入口又是 AI 的第一战场，而语音自然交互的「嘴控」又是超级入口的第一战场，目前大多只是类似新 Siri 而不是充分贯通了 Apps 的至少 OpenAI 的 AVM 水准的初体验，豆包这方面体验较好。AI 操作系统，端侧智能，NPU 或者多元异构意义上的 AI 算力，是基础，SoC 走向 PC 级。强智能在 C 端的引爆从手机等移动设备开始。手机 AI 之争，从拼 AI 核心能力开始，未来以拼生态能力决胜。但明年这场热战，不只战 AI，影像、跨屏、场景、折叠屏尤其三折叠也是焦点。个人认为没有多张合成图片 Raw，没有 15+视频动态范围，没有 Log 或视频 Raw，没有到位的专业模式，没有高画质 4K120P，没有相当于 10 倍光学变焦的远摄，不能算是影像真旗舰。手机形态逐步变化，会变到用户对手机甚至会有新物种一般的「焕新」感觉。&lt;/p&gt; 
&lt;p&gt;34.AI2.0 智能场景的极大拓展，来自手机无需改装直连衞星上网，2025 年是手机衞星互联网元年（不是衞星互联网元年）。参见我专文《手机衞星互联网元年来了》、《衞星互联网全球提速，中国进展到了哪一步》、《黑科技》书中衞星互联网篇章。从衞星短讯、衞星电话到衞星上网，手机上星三年三级跳。不止 Starlink 一家对此有布局，但华为等中国企业还在测试或测试准备阶段，初步达到组网标准的需要比萨天线的衞星上网。手机衞星互联网星座组网势在必行。智能终端与衞星之间的应用场景爆破，衞星导航、衞星短讯、衞星电话做不到，而智能手机直连衞星上网可以。&lt;/p&gt; 
&lt;p&gt;35.智能汽车 SoC 算力走向 2000-3000TOPS，1000TOPS 只是端到端走向 VLA 之际真正可用的 L3 的算力起跳点。汽车算力复用给个人和家庭作为算力基地，将与其移动能源中心功能一样重要。参见我专文《机器人四重奏：Musk-Tesla-市场-生态在四个节奏上》。PC 盒子化、盒子 Mini 化的尽头是算力颗粒化。移动 SoC 算力已在走向口袋级 PC。口袋里的 AI CP（不是 AI PC）不断逼近现实。但用户不会揣个盒子满世界跑，Mini 还是桌面场景，且相对而言只是中等性能产品。个人计算的未来形态会是「算力移动便携+算力复用网络+云端算力」，在个人算力网、家庭算力网基础上，智驾汽车的上千 TOPS 级别的 SoC 成为个人-家庭可用算力。&lt;/p&gt; 
&lt;p&gt;36.OS 的 AI 化与 AI 向 OS 进化，成为 AI OS 相向而行的两条路径。AI OS 驱动的手机和 PC 带来前所未有的体验。这方面个人重点关注荣耀和 iPhone，后者目前水准体验 50 多分，到 2025 年底提升到六七十分有可能。参见我专文《值得为 Apple Intelligence 上手 iPhone16 吗》、《Apple Intelligence 的 6 个确定和 6 个不确定》。&lt;/p&gt; 
&lt;p&gt;37.200B 也就是两千亿参数以上大模型在消费级单台 AI PC 实现可运行（量化程度过大的不算），但 2025 年可能仅限于顶配的 M4 Ultra 芯片的 Mac Studio 能做到这一点。参见我专文《100B 以内开源大模型个人可用了》、《1230 亿参数大模型上身》。&lt;/p&gt; 
&lt;p&gt;38.ASIC 架构芯片在推理市场主流地位进一步确认，AI2.0 得到信心确认 AI 应用急速扩增拉动推理算力需求相关投资显著增长是一方面原因，需求规模大增显著摊薄 ASIC 芯片迭代成本是另一方面原因，后者使得研发换代成本与算力效率一样高的短板不再成为制约因素。这是博通等 ASIC 架构服务商受到关注的根本原因。有 AI 算力中心、云计算平台、数据中心等业务的头部企业，都自研或委托研发设计了自己的 ASIC 芯片，TPU、MTIA、Maia、Inferentia2 等，没有的也正在准备的路上。&lt;/p&gt; 
&lt;p&gt;39.Web3.0 的发展会成为 AI2.0 的共生现象，可以理解为智能世界的要素网络、生产关系和组织结缔，区块链是基础设施里的基础协议，未来是合约型社会。参见我专文《比特币站上 10 万美元见证历史，6 点看法》。如果数字加密货币角度的局部流动接口不可能，可能需要对 Web3.0 或者数字金融角度的某种特区或者实验区进行早期思路探索。这方面不是大方向毫无必要，而是专割韭菜的老鼠屎太多了。&lt;/p&gt; 
&lt;p&gt;40.大模型演进的标杆方向，2025 年可能主要还是要看 o3、LCM 和 LWM。尤其是比 o1 的思维链长思考又更进一步的 o3 的深度推理，虽然需要消耗数十倍的算力，也需要更长的等待时间。o1 Pro 的等待时间已达到几分钟之久。参见我专文《草莓意味：当 AI 开始思考》。o3 在 ARC-AGI 测试中的水准大幅跃升，可能来自三个方面的进步：一是建立了比思维链更具整体感和动态调适能力的理解力（反过来支持和强化思维链），二是为每一项任务生成任务程序并且动态调适的能力（而不仅仅是思维链），三是思考与监督思考的能力，且机制和过程都更为复杂（而不是 Mike Knoop 所谓搜索）。三项能力叠加，解决未曾学习过的新问题的能力有了明显进步，不过依然远不足以达到解决传统问题所能达到的阈值，但开启的架构方向，其意义和潜力是当年 AlexNet 级别的。对此，平面思维会认为是思维链的进化，立体思维会认为是出现了比思维链更高维的整体思考能力。具象一点比喻大模型基座的脑能力进化，是一个「点线面体」逐步形成的过程。点是 Token 预测等，线是思维链等，面是皮层计算等，体是整体思维。而脑中的元，从 Token 置换为 Patch 或其它表征，是 DiT-ViT-LCM-LWM 们正在干的事，其实质是走出 LLM，走出语言符号知识系统这个框，走出人类知识-经验-方法-思维-感知的限制，对世界的感知理解回到现实本身。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;企业面：透过新原理新形态新思维新问题，从底层逻辑看清这个世界到底在比拼什么以及需要什么&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;41. 新原理范式：年度关注企业，首先是李飞飞的 World Labs 及其 LWM 大世界模型。虽然不是真正的世界模型，但她又一次引领了「让未来发生」意义上的前沿探索，和辛顿在不同层面。World Labs 对空间智能的探索不应只是被理解为 3D 视频生成，而是走出基座模型的第二范式，探索第 3 范式在理解物理世界角度的早期雏形。理解世界从视觉理解、时空智能开始。相比传统物理引擎，走向无形之形，才可能极大拓展泛化边界，并且长期而言反倒比目前图形工作站物理引擎建模、粒子渲染之类的做法更高效甚至也更节省算力。理解 4D 时空世界方面 DiT、ViT 比纯 Transformer 的 LLM 走得更远，Veo 比 Sora 走得更远，LWM 比 MLLMs 走得更远。如此不断迭代，走出语言符号知识系统，深感物理世界，融合虚拟与现实，才可能涌现不是物理引擎的物理引擎。如果人类可解释可方程可计算可建模然后 AI 才能够如法炮制，便失去了智能涌现的意义，也失去了涌现的可能。先有世界后有感知与数据然后有理解，且有底律也是基于理解反向发现一些底律，这也是 AI4S 科学新范式的重要特征。参见我专文《突破预设进入发现与创造新范式是 AI 的实质意义》、《世界模拟器才是 AGI 终局，12 态势预测》。&lt;/p&gt; 
&lt;p&gt;42.关注 Google，最有可能 2025 年在某个重要领域超越 OpenAI 的企业，实际上 Veo2 已经超越了 Sora。但搜索将是 2025 年受到 AI 最大冲击的业务，搜索巨头会不会被翻盘有悬念。&lt;/p&gt; 
&lt;p&gt;43.关注微软，因为超级智能与超级平台合体最有可能在 2025 年进一步引起平台滥用支配地位、垄断角度问题的企业。&lt;/p&gt; 
&lt;p&gt;44.关注字节，AI、算法、流量生态而不是 TikTok 角度，字节或许是 2025 年最有可能同时面临较大内部外部压力的企业，豆包能不能从移动端颠覆竞争对手的市场地位也值得持续观察。&lt;/p&gt; 
&lt;p&gt;45.关注宇树，全网刷屏的四足四轮机器狗产品 B2-W 已经可以飞檐走壁了，但我们更想了解其大脑能做到什么水准。我即将参加的 CES2025，大概率人型、四足、家庭、服务、物流机器人最吸睛，不过翻跟头、拿东西之类的动作表演，已经不应该是今年的亮点了，脑能力、空间能力、视觉理解等才是重点。参见专文《CES2025 我重点关注这 8 类产品技术》、《走向第二曲线：未来渐次发生，为何依然需要重新想像》。&lt;/p&gt; 
&lt;p&gt;46.关注理想、小鹏、蔚来和华为，在向端到端、大模型上车过程中，谁的智能驾驶系统会表现出更高素能，谁率先做出真正的 L3+，谁又会吹牛说自己率先实现了 L4，谁能将大模型的水准提升到现实理解而不仅仅是行车视觉理解的维度。对于类似 Transformer+BEV 的 FSD V13 的架构来说，L3 甚至 L3+已经触手可及，努努力大家都能做到。参见我专文《L3 熟了，就在今年，但 12 个信号之外可能还有意外》。所以这个阶段忽然出现一个情况，大家都有机会，并不是非得用华为不可。但是到 L4 可能就不好说了，一是场景可能性无限放大，法规与社会对安全系数的严苛度必然比 L3 高出不少，合格的系统和过不了关的系统，安全系数可能零点几的差别。不过到 L4 不仅技术还远，公共政策距离也不近。2025 年，公共道路对自动驾驶的开放幅度必然有限。参见我专文《Waymo 加速进入「奇点」，自动驾驶的中国节奏不可滞后》。汽车的智能这个部分，会垂直统合还是横向产业分层，目前实质上处在这样一个十字路口。最终可能还是术业有专攻，一个企业做不了也做不好全部。&lt;/p&gt; 
&lt;p&gt;47.关注敢于做产品形态新物种的企业，关注奇瑞劲云、起亚 PV5、小鹏陆地航母这些新物种。不过低空经济雷声大雨点小，阻力比决心大，想法比办法多，尤其新能源载人飞行器可能会面临入市不畅局面。&lt;/p&gt; 
&lt;p&gt;48.关注阿里云及其千问而不是幻方 DeepSeek。包括 Mistral 和 llama 在内，个人一直逢开源大模型必赞，但 DeepSeek 成本效率就像机器人的四肢发达一样不是个人重点关注方向，用已有模型反刍的数据投喂自己的模型，水准不可能超越已有模型。更深层原因我做过专文分析，大模型现在是两条曲线交织的双螺旋进化。向上走的曲线，追求整理感知理解行为能力的通用智能，拼整体理解意义上的脑能力，思考和监督思考，视觉在内的整体理解，空间智能等现实模型，物理等科学模型，多模态更不在话下。思维链、皮层计算、不同模型原理探索是当下前沿探索的核心。向下走的曲线，提升数据质量，训练意义上的量效比，算力能效比，大幅降低推理成本。这个领域有捷径但没有弯道超车，有后发成本优势但没有后发领先优势，AGI 路线更是只能取巧没有投机。向上曲线的模型思考长度速度整体度、多模态、感知思考与行为能力合一等方向，只可能将算力需求拉升到新高度。向下曲线对成本效率有改变，但对捧得 AGI 圣杯的贡献可以忽略。参见《为什么 DeepSeek-V3 的火爆不宜过高评价》、《我提出了一个「量效比」的概念》、《大模型发展四定律之下：闭源和开源模型未来谁会更领先》。此处不再赘述。开源大模型接下来也考验生态内力、后程发力。希望国产开源大模型，接下来在多模态、语音交互、视觉理解、空间智能等方面也能持续跟上。&lt;/p&gt; 
&lt;p&gt;49.关注 xAI，希望有后来巨上的奇迹，能够以开源同时改变开源和闭源竞争格局，尽管概率貌似不大。关注英伟达，AI 设计 AI 芯片的阶段都到来了，英伟达的挑战者还是没有出现？AMD、博通只是不同角度的平替，挑战不了地位，更挑战不了英伟达从硬件到软件从训练推理到智能汽车和机器人等全线 SoC 布局。但 AI 芯片的投资热度还在持续，Groq 挑战英伟达没戏，不影响十几个 Cerebras 迎面而来。参见我专文《世界需要下下下一个英伟达》、《越来越有挑战者出现的意味，只是还不够清晰》、《长创新：英伟达登顶的底层逻辑，让我们看清什么》。&lt;/p&gt; 
&lt;p&gt;50.关注 Meta 和 Apple，希望 llama4 能有惊喜，Orion 能有公开市场销售版而不是只提供给极少数开发者，希望 Apple Atlas 远比 AVP 惊艳，当然 AVP 赶快更新一下也好。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0107/105313_Etty_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2Fttarticle%2Fp%2Fshow%3Fid%3D2309405119047225442510%26mark_id%3D999_reallog_mark_ad%253A999%257CWeiboADNatural&quot; target=&quot;_blank&quot;&gt;微博&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;胡延平 EarthRambler&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328599</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328599</guid>
            <pubDate>Mon, 06 Jan 2025 02:53:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Rust 中调用 Drop 的时机</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;code&gt;Drop&lt;/code&gt; trait 在好些地方都有所提及, 但是它们的重点不太一样, 比如前文有介绍 Drop trait 的基本用法, 以及所有权转移.&lt;/p&gt; 
&lt;p&gt;在这一节中, 我们重点介绍 &lt;code&gt;Drop&lt;/code&gt; trait 被调用的时机.&lt;/p&gt; 
&lt;h2&gt;谁负责调用 Drop trait&lt;/h2&gt; 
&lt;p&gt;编译器, 确且地说是编译器自动生成的汇编代码, 帮我们自动管理对像的释放, 通过调用 &lt;code&gt;Drop&lt;/code&gt; trait. 就像在 C++ 语言中, 编译器会自动调用对象的析构函数.&lt;/p&gt; 
&lt;p&gt;但是, 跟 C++ 相比, Rust 管理对象的释放过程要复杂得多, 后者的对象会有 &lt;code&gt;未初始化 uninit&lt;/code&gt; 的状态, 如果处于这个状态, 那么编译器就不会调用该对象的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;h2&gt;静态释放 static drop&lt;/h2&gt; 
&lt;p&gt;表达式比较简单, 可以在编译期间确定变量的值是否需要被释放.&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    // x 初始始化
    let mut x = Box::new(42_i32);
    // 创建可变更引用
    let y = &amp;amp;mut x;
    // x 被重新赋值, 旧的值自动被 drop
    *y = Box::new(41);

    // x 的作用域到此结束, drop 它
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们使用命令 &lt;code&gt;rustc --emit asm static-drop.rs&lt;/code&gt; 生成对应的汇编代码, 下面展示了核心部分的代码, 并加上了几行注释:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;.section.text._ZN11static_drop4main17h68890bb49a778ebaE,&quot;ax&quot;,@progbits
.p2align4, 0x90
.type_ZN11static_drop4main17h68890bb49a778ebaE,@function
_ZN11static_drop4main17h68890bb49a778ebaE:
.Lfunc_begin2:
.cfi_startproc
.cfi_personality 155, DW.ref.rust_eh_personality
.cfi_lsda 27, .Lexception2
subq$104, %rsp
.cfi_def_cfa_offset 112
.Ltmp6:
; malloc(4)
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17h73c35ae157034338E
.Ltmp7:
movq%rax, 40(%rsp)
jmp.LBB18_2
.LBB18_1:
.Ltmp8:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 88(%rsp)
movl%eax, 96(%rsp)
movq88(%rsp), %rax
movq%rax, 32(%rsp)
jmp.LBB18_13
.LBB18_2:
; x.ptr = malloc(4)
; *(x.ptr) = 42
movq40(%rsp), %rax
movl$42, (%rax)
movq%rax, 48(%rsp)
.Ltmp9:
; malloc(4)
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17h73c35ae157034338E
.Ltmp10:
; (x2.ptr) = malloc(4)
movq%rax, 24(%rsp)
jmp.LBB18_4
.LBB18_3:
.Ltmp11:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 72(%rsp)
movl%eax, 80(%rsp)
movq72(%rsp), %rax
movq%rax, 8(%rsp)
movl80(%rsp), %eax
movl%eax, 20(%rsp)
jmp.LBB18_6
.LBB18_4:
movq24(%rsp), %rax
; *(x2.ptr) = 41
movl$41, (%rax)
jmp.LBB18_7
.LBB18_5:
.Ltmp15:
leaq48(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17hac96f08cecbb6861E
.Ltmp16:
jmp.LBB18_12
.LBB18_6:
movl20(%rsp), %eax
movq8(%rsp), %rcx
movq%rcx, 56(%rsp)
movl%eax, 64(%rsp)
jmp.LBB18_5
.LBB18_7:
.Ltmp12:
; drop(x)
leaq48(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17hac96f08cecbb6861E
.Ltmp13:
jmp.LBB18_10
.LBB18_8:
movq24(%rsp), %rax
movq%rax, 48(%rsp)
jmp.LBB18_5
.LBB18_9:
.Ltmp14:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 56(%rsp)
movl%eax, 64(%rsp)
jmp.LBB18_8
.LBB18_10:
; x = x2
movq24(%rsp), %rax
movq%rax, 48(%rsp)
leaq48(%rsp), %rdi
; drop(x)
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17hac96f08cecbb6861E
addq$104, %rsp
.cfi_def_cfa_offset 8
retq
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;阅读汇编代码时, 最好对比着 Rust 代码, 方便理解.&lt;/p&gt; 
&lt;p&gt;但是汇编代码有上百行, 我们把汇编代码转译成 C 代码, 大概如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;

int main(void) {
  // let mut x = Box::new(42);
  int32_t* x = (int32_t*) malloc(sizeof(int32_t));
  *x = 42;

  // let y = &amp;amp;mut x;
  int32_t** y = &amp;amp;x;

  // *y = Box::new(41);
  int32_t* x2 = (int32_t*)malloc(sizeof(int32_t));
  *x2 = 41;
  free(x);
  x = x2;

  free(x);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这个过程就比较清晰了吧, 编译上面的 C 代码, 并且用 &lt;code&gt;valgrind&lt;/code&gt; 或者 &lt;code&gt;sanitizers&lt;/code&gt; 等工具检测, 可以发现它进行了两次堆内存分配, 两次内存回收, 没有发现内存泄露的问题.&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-87b741768fce871b8c27a7c030717f0181c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;动态释放 dynamic drop&lt;/h2&gt; 
&lt;p&gt;表达式有比较复杂的分支或者分支条件在运行期间才能判定, 通过在栈内存上设置 &lt;code&gt;Drop Flag&lt;/code&gt; 来完成. 程序运行期间, 修改 drop-flag 标记, 来确定是否要调用该对象的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;p&gt;先看一个示例程序:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    if timestamp.as_millis() % 2 == 0 {
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到, 只有在程序运行时, 才能根据当前的时间标签决定要不要初始化变量 x, 这种情况就要用到 &lt;code&gt;Drop Flag&lt;/code&gt; 了.&lt;/p&gt; 
&lt;p&gt;上面的 Rust 代码生成的汇编代码如下, 我们加入了一些注释:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;.section.text._ZN12dynamic_drop4main17h353a883be865ee26E,&quot;ax&quot;,@progbits
.p2align4, 0x90
.type_ZN12dynamic_drop4main17h353a883be865ee26E,@function
_ZN12dynamic_drop4main17h353a883be865ee26E:
.Lfunc_begin3:
.cfi_startproc
.cfi_personality 155, DW.ref.rust_eh_personality
.cfi_lsda 27, .Lexception3
subq$248, %rsp
.cfi_def_cfa_offset 256
    ; 设置 x.drop-flag = 0
movb$0, 199(%rsp)
    ; let now = SystemTime::now();
movq_ZN3std4time10SystemTime3now17h4779e0425deae935E@GOTPCREL(%rip), %rax
callq*%rax
    // now.seconds =
movq%rax, 48(%rsp)
    // now.nano-seconds =
movl%edx, 56(%rsp)
    ; let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default()
movq_ZN3std4time10SystemTime14duration_since17h0f40caf46c5e1553E@GOTPCREL(%rip), %rax
xorl%ecx, %ecx
movl%ecx, %edx
leaq80(%rsp), %rdi
movq%rdi, 32(%rsp)
leaq48(%rsp), %rsi
callq*%rax
movq32(%rsp), %rdi
callq_ZN4core6result19Result$LT$T$C$E$GT$17unwrap_or_default17h8fe62a20db70e668E
    ; timestamp has value
    // timestamp.seconds =
movq%rax, 64(%rsp)
    // timestamp.nano-seconds =
movl%edx, 72(%rsp)
.Ltmp9:
    ; timestamp.as_millis()
leaq64(%rsp), %rdi
callq_ZN4core4time8Duration9as_millis17h3157e191997c534eE
.Ltmp10:
movq%rax, 40(%rsp)
jmp.LBB23_4
.LBB23_1:
testb$1, 199(%rsp)
jne.LBB23_17
jmp.LBB23_16
.LBB23_2:
.Ltmp18:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 16(%rsp)
movl%eax, 28(%rsp)
jmp.LBB23_3
.LBB23_3:
movq16(%rsp), %rcx
movl28(%rsp), %eax
movq%rcx, 200(%rsp)
movl%eax, 208(%rsp)
jmp.LBB23_1
.LBB23_4:
jmp.LBB23_5
.LBB23_5:
    ; 判定 millis % 2 是否为 0
movq40(%rsp), %rax
    ; test-bit(millis) == 1
testb$1, %al
jne.LBB23_9
jmp.LBB23_6
.LBB23_6:
    ; millis % 2 == 0 进入这个代码块
.Ltmp11:
    ; x = Box::new(42);
    ; malloc(4);
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17hbc6d664071ad5e2fE
.Ltmp12:
    ; x.ptr = xxx
movq%rax, 8(%rsp)
jmp.LBB23_8
.LBB23_7:
.Ltmp13:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 232(%rsp)
movl%eax, 240(%rsp)
movq232(%rsp), %rcx
movl240(%rsp), %eax
movq%rcx, 16(%rsp)
movl%eax, 28(%rsp)
jmp.LBB23_3
.LBB23_8:
movq8(%rsp), %rax
    ; 设置堆内存上的值
    ; *(x.ptr) = 42;
movl$42, (%rax)
jmp.LBB23_10
.LBB23_9:
    ; millis % 2 == 1, 才进入这个分支
    ; 判断 x.drop_flag == 1
    ; 如果是 1, 就说明它初始化了, 需要被 drop
    ; 如果是 0, 就说明 x 是 uninit, 什么都不用做
testb$1, 199(%rsp)
jne.LBB23_15
jmp.LBB23_14
.LBB23_10:
movq8(%rsp), %rax
    ; x.drop-flag = 1
movb$1, 199(%rsp)
    ; println!(&quot;x: {x}&quot;);
movq%rax, 104(%rsp)
leaq104(%rsp), %rax
movq%rax, 216(%rsp)
leaq_ZN69_$LT$alloc..boxed..Box$LT$T$C$A$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17h5ad2dd804fe02f48E(%rip), %rax
movq%rax, 224(%rsp)
movq216(%rsp), %rax
movq%rax, 176(%rsp)
movq224(%rsp), %rax
movq%rax, 184(%rsp)
movups176(%rsp), %xmm0
movaps%xmm0, 160(%rsp)
.Ltmp14:
leaq.L__unnamed_9(%rip), %rsi
leaq112(%rsp), %rdi
movl$2, %edx
leaq160(%rsp), %rcx
movl$1, %r8d
callq_ZN4core3fmt9Arguments6new_v117hd2ff9f250d646380E
.Ltmp15:
jmp.LBB23_12
.LBB23_12:
.Ltmp16:
movq_ZN3std2io5stdio6_print17h8f9e07feda690a3dE@GOTPCREL(%rip), %rax
leaq112(%rsp), %rdi
callq*%rax
.Ltmp17:
jmp.LBB23_13
.LBB23_13:
    ; if millis % 2 == 0 { ... } 代码块运行完成
    ; 进入最后的清理阶段
jmp.LBB23_9
.LBB23_14:
    ; return 0
movb$0, 199(%rsp)
addq$248, %rsp
.cfi_def_cfa_offset 8
retq
.LBB23_15:
.cfi_def_cfa_offset 256
    ; 这个是正常的工作流调用的
    ; drop(x);
leaq104(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17ha5010c067d13d768E
jmp.LBB23_14
.LBB23_16:
movq200(%rsp), %rdi
callq_Unwind_Resume@PLT
.LBB23_17:
.Ltmp19:
    ; 这个是处理 unwind 异常时调用的
    ; drop(x);
leaq104(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17ha5010c067d13d768E
.Ltmp20:
jmp.LBB23_16
.LBB23_18:
.Ltmp21:
movq_ZN4core9panicking16panic_in_cleanup17hd62aa59d1fda1c9fE@GOTPCREL(%rip), %rax
callq*%rax
.Lfunc_end23:
.size_ZN12dynamic_drop4main17h353a883be865ee26E, .Lfunc_end23-_ZN12dynamic_drop4main17h353a883be865ee26E
.cfi_endproc
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其行为如下:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;栈空间初始化完成后, 就设置变量 x 的 &lt;code&gt;drop-flag = 0&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;然后计算当前的时间标签, 判断是否为偶数 
  &lt;ul&gt; 
   &lt;li&gt;如果为偶数, 继续&lt;/li&gt; 
   &lt;li&gt;如果为奇数, 跳转到第 4 步&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;分配堆内存, 并设置内存里的值为 &lt;code&gt;42&lt;/code&gt;; 初始化 x, 并设置 &lt;code&gt;x.drop-flag = 1&lt;/code&gt; 
  &lt;ul&gt; 
   &lt;li&gt;组装参数, 调用 &lt;code&gt;print()&lt;/code&gt; 打印字符串&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;判断 &lt;code&gt;x.drop-flag == 1&lt;/code&gt;, 如果是 &lt;code&gt;1&lt;/code&gt;, 就调用 &lt;code&gt;Box::drop(&amp;amp;mut x)&lt;/code&gt; 来释放它&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;我们将汇编代码的行为, 作为注释加入到原先的 Rust 代码中, 更方便阅读:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // 设置 x 的 Drop Flag
    // x.drop-flag = 0;
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    if timestamp.as_millis() % 2 == 0 {
        // 设置 x.drop-flag = 1
        // 为 x 分配堆内存, 并设置其值为 42
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        // 设置 x.drop-flag = 0
        // 调用 core::mem::drop(x);
        drop(x);
    }

    // 判断 x.drop-flag
    // if x.drop-flag == 1 {
    //     core::ptr::drop_in_place(*x as *mut i32);
    // }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们甚至可以将上面的汇编代码转译成对应的 C 代码:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;
#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

int main(void) {
  bool x_drop_flag = false;
  int32_t* x;

  struct timespec now;
  if (clock_gettime(CLOCK_REALTIME, &amp;amp;now) == -1) {
    // Ignored
  }

  int64_t millis = now.tv_sec * 1000 + now.tv_nsec / 1000000;
  if (millis % 2 == 0) {
    x = (int32_t*) malloc(sizeof(int32_t));
    *x = 42;
    x_drop_flag = true;
    printf(&quot;x: %d\n&quot;, *x);
  }

  if (x_drop_flag) {
    free(x);
  }

  return 0;
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;更有趣的是, 我们可以用 gdb/lldb 来手动修改 &lt;code&gt;x.drop-flag&lt;/code&gt;, 如果把它设置为 &lt;code&gt;1&lt;/code&gt;, 并且 &lt;code&gt;x&lt;/code&gt; 未初始化的话, 在进程结束时, 就可能会产生段错误 segfault.&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-gdb&quot;&gt;dynamic-drop`dynamic_drop::main::h5787b1b14685d565:
    0x5555555696e0 &amp;lt;+0&amp;gt;:  subq   $0x118, %rsp              ; imm = 0x118
    0x5555555696e7 &amp;lt;+7&amp;gt;:  movb   $0x0, 0xcf(%rsp)
-&amp;gt;  0x5555555696ef &amp;lt;+15&amp;gt;: movq   0x4165a(%rip), %rax
    0x5555555696f6 &amp;lt;+22&amp;gt;: callq  *%rax
    0x5555555696f8 &amp;lt;+24&amp;gt;: movq   %rax, 0x30(%rsp)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面展示的是 main() 函数初始化时的代码, 它调整完栈顶后, 立即重置了 &lt;code&gt;x.drop-flag = 0&lt;/code&gt;. 在后面的代码运行前, 我们可以使用命令 &lt;code&gt;p *(char*)($rsp + 0xcf) = 1&lt;/code&gt; 将 &lt;code&gt;x.drop-flag&lt;/code&gt; 设置为&lt;code&gt;1&lt;/code&gt;. 等进程结束时, &lt;code&gt;x&lt;/code&gt; 超出了作用域, 就要检查 &lt;code&gt;x.drop-flag&lt;/code&gt; 的值. 如果&lt;code&gt;x&lt;/code&gt; 未初始化的话, 它内部的，指针可能指向任意的地址, 所以就产生了段错误.&lt;/p&gt; 
&lt;p&gt;我们再看一下段错误时的函数的调用栈:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-gdb&quot;&gt;* thread #1, name = &#39;dynamic-drop&#39;, stop reason = signal SIGSEGV: invalid address (fault address: 0xe8)
    frame #0: 0x00007ffff7e0a6aa libc.so.6`__GI___libc_free(mem=0x00000000000000f0) at malloc.c:3375:7
(lldb) bt
* thread #1, name = &#39;dynamic-drop&#39;, stop reason = signal SIGSEGV: invalid address (fault address: 0xe8)
  * frame #0: 0x00007ffff7e0a6aa libc.so.6`__GI___libc_free(mem=0x00000000000000f0) at malloc.c:3375:7
    frame #1: 0x000055555556a000 dynamic-drop`_$LT$alloc..alloc..Global$u20$as$u20$core..alloc..Allocator$GT$::deallocate::hfe4b1fe0680a312e at alloc.rs:119:14
    frame #2: 0x0000555555569fcd dynamic-drop`_$LT$alloc..alloc..Global$u20$as$u20$core..alloc..Allocator$GT$::deallocate::hfe4b1fe0680a312e(self=0x00007fffffff
dd00, ptr=(pointer = &quot;&quot;), layout=Layout @ 0x00007fffffffdb88) at alloc.rs:256:22
    frame #3: 0x0000555555569b89 dynamic-drop`_$LT$alloc..boxed..Box$LT$T$C$A$GT$$u20$as$u20$core..ops..drop..Drop$GT$::drop::hea3c2fa5449fa588(self=0x00007ffff
fffdcf8) at boxed.rs:1247:17
    frame #4: 0x0000555555569ae8 dynamic-drop`core::ptr::drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$::h4bec233740204caa((null)=0x00007fffffffdcf8) at mod.
rs:514:1
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;手动调用 &lt;code&gt;drop()&lt;/code&gt; 函数&lt;/h3&gt; 
&lt;p&gt;上面的代码演示了 &lt;code&gt;Drop Flag&lt;/code&gt; 是如何工作的, 接下来, 我们看一下手动调用 &lt;code&gt;drop()&lt;/code&gt; 函数释放了对象后, 它的行为是怎么样的?&lt;/p&gt; 
&lt;p&gt;先看示例代码:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    if timestamp.as_millis() % 2 == 0 {
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        drop(x);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;将上面的代码生成汇编代码, 我们还加上了几条注释:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;.section.text._ZN11manual_drop4main17h6a90a7c6667c6acfE,&quot;ax&quot;,@progbits
.p2align4, 0x90
.type_ZN11manual_drop4main17h6a90a7c6667c6acfE,@function
_ZN11manual_drop4main17h6a90a7c6667c6acfE:
.Lfunc_begin3:
.cfi_startproc
.cfi_personality 155, DW.ref.rust_eh_personality
.cfi_lsda 27, .Lexception3
subq$248, %rsp
.cfi_def_cfa_offset 256
movb$0, 199(%rsp)
movq_ZN3std4time10SystemTime3now17h4779e0425deae935E@GOTPCREL(%rip), %rax
callq*%rax
movq%rax, 48(%rsp)
movl%edx, 56(%rsp)
movq_ZN3std4time10SystemTime14duration_since17h0f40caf46c5e1553E@GOTPCREL(%rip), %rax
xorl%ecx, %ecx
movl%ecx, %edx
leaq80(%rsp), %rdi
movq%rdi, 32(%rsp)
leaq48(%rsp), %rsi
callq*%rax
movq32(%rsp), %rdi
callq_ZN4core6result19Result$LT$T$C$E$GT$17unwrap_or_default17h28c150cee05a8583E
movq%rax, 64(%rsp)
movl%edx, 72(%rsp)
.Ltmp9:
leaq64(%rsp), %rdi
callq_ZN4core4time8Duration9as_millis17hd86e02e1e172ae4fE
.Ltmp10:
movq%rax, 40(%rsp)
jmp.LBB24_4
.LBB24_1:
    ; 检查 x.drop-flag == 1
testb$1, 199(%rsp)
jne.LBB24_16
jmp.LBB24_15
.LBB24_2:
.Ltmp20:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 16(%rsp)
movl%eax, 28(%rsp)
jmp.LBB24_3
.LBB24_3:
movq16(%rsp), %rcx
movl28(%rsp), %eax
movq%rcx, 200(%rsp)
movl%eax, 208(%rsp)
jmp.LBB24_1
.LBB24_4:
jmp.LBB24_5
.LBB24_5:
movq40(%rsp), %rax
testb$1, %al
jne.LBB24_9
jmp.LBB24_6
.LBB24_6:
.Ltmp11:
    ; 进入 millis % 2 == 1 的分支
    ; malloc(4)
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17h48568ba0c1cf90faE
.Ltmp12:
movq%rax, 8(%rsp)
jmp.LBB24_8
.LBB24_7:
.Ltmp13:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 232(%rsp)
movl%eax, 240(%rsp)
movq232(%rsp), %rcx
movl240(%rsp), %eax
movq%rcx, 16(%rsp)
movl%eax, 28(%rsp)
jmp.LBB24_3
.LBB24_8:
    ; x.ptr = malloc(4);
movq8(%rsp), %rax
    ; *(x.ptr) = 42
movl$42, (%rax)
jmp.LBB24_10
.LBB24_9:
movb$0, 199(%rsp)
addq$248, %rsp
.cfi_def_cfa_offset 8
retq
.LBB24_10:
.cfi_def_cfa_offset 256
movq8(%rsp), %rax
; x.drop-flag = 1
movb$1, 199(%rsp)
movq%rax, 104(%rsp)
leaq104(%rsp), %rax
movq%rax, 216(%rsp)
leaq_ZN69_$LT$alloc..boxed..Box$LT$T$C$A$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17h2b03e6eb572a9ffaE(%rip), %rax
movq%rax, 224(%rsp)
movq216(%rsp), %rax
movq%rax, 176(%rsp)
movq224(%rsp), %rax
movq%rax, 184(%rsp)
movups176(%rsp), %xmm0
movaps%xmm0, 160(%rsp)
.Ltmp14:
leaq.L__unnamed_9(%rip), %rsi
leaq112(%rsp), %rdi
movl$2, %edx
leaq160(%rsp), %rcx
movl$1, %r8d
callq_ZN4core3fmt9Arguments6new_v117h86651149b4254342E
.Ltmp15:
jmp.LBB24_12
.LBB24_12:
.Ltmp16:
movq_ZN3std2io5stdio6_print17h8f9e07feda690a3dE@GOTPCREL(%rip), %rax
leaq112(%rsp), %rdi
callq*%rax
.Ltmp17:
jmp.LBB24_13
.LBB24_13:
; x.drop-flag = 0
movb$0, 199(%rsp)
; drop(x)
movq104(%rsp), %rdi
.Ltmp18:
callq_ZN4core3mem4drop17hf19ef99eb1293173E
.Ltmp19:
jmp.LBB24_14
.LBB24_14:
jmp.LBB24_9
.LBB24_15:
movq200(%rsp), %rdi
callq_Unwind_Resume@PLT
.LBB24_16:
.Ltmp21:
leaq104(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17h668a38bfbe5d4573E
.Ltmp22:
jmp.LBB24_15
.LBB24_17:
.Ltmp23:
movq_ZN4core9panicking16panic_in_cleanup17hd62aa59d1fda1c9fE@GOTPCREL(%rip), %rax
callq*%rax
.Lfunc_end24:
.size_ZN11manual_drop4main17h6a90a7c6667c6acfE, .Lfunc_end24-_ZN11manual_drop4main17h6a90a7c6667c6acfE
.cfi_endproc
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到, 当执行到 &lt;code&gt;drop(x);&lt;/code&gt; 时, 编译器:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;先重置 &lt;code&gt;x.drop-flag = 0&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;接着调用 &lt;code&gt;core::mem::drop(x);&lt;/code&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;而编译器自动释放对象 &lt;code&gt;x&lt;/code&gt; 时, 会调用另一个函数 &lt;code&gt;core::ptr::drop_in_place(*x as *mut i32)&lt;/code&gt;.&lt;/p&gt; 
&lt;p&gt;将上面的汇编代码合并到之前的 Rust 代码, 大致如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // 设置 x 的 Drop Flag
    // x.drop-flag = 0;
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    if timestamp.as_millis() % 2 == 0 {
        // 设置 x.drop-flag = 1
        // 为 x 分配堆内存, 并设置其值为 42
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        // 设置 x.drop-flag = 0
        // 调用 core::mem::drop(x);
        drop(x);
    }

    // 判断 x.drop-flag
    // if x.drop-flag == 1 {
    //     core::ptr::drop_in_place(*x as *mut i32);
    // }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;Drop 是零成本抽像吗?&lt;/h2&gt; 
&lt;p&gt;我们分析了上面的 Rust 程序, 可以明显地发现, 编译器生成的代码在支持动态 drop 时, 需要反复地判断 drop-flag 是不是被设置, 如果被设置成 1, 就要调用该类型的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;p&gt;这种行为, 跟我们在 C 代码中手动判断指针是否为 NULL 是一样的, 每次给变量分配新的堆内存之前, 就要先判定一下它的当前是否为空指针:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;int* x;

if (x != NULL) {
  free(x);
}
x = malloc(4);
...
if (x != NULL) {
  free(x);
}
x = malloc(4);
...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;但这些条件判断代码, Rust 编译器自动帮我们生成了, 而且可以保证没有泄露.&lt;/p&gt; 
&lt;h2&gt;不要自动 Drop&lt;/h2&gt; 
&lt;p&gt;到这里, 就要进入内存管理的深水区了, 上面提到了 Rust 会帮我们自动管理内存, 在合适的时机自动调用，对象的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;p&gt;但与此同是, Rust 标准库中提供了一些手段, 可以让我们绕过这个机制, 但好在它们大都是 &lt;code&gt;unsafe&lt;/code&gt; 的.&lt;/p&gt; 
&lt;p&gt;遇到这些代码, 要打起精神, 因为 Rustc 编译器可能帮不上你了.&lt;/p&gt; 
&lt;h3&gt;ManuallyDrop&lt;/h3&gt; 
&lt;p&gt;ManuallyDrop 做了什么? 对于栈上的对象, 不需要调用该对象的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;p&gt;先看一个 ManuallyDrop 的一个例子:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::mem::ManuallyDrop;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    let millis = timestamp.as_millis();

    if millis % 2 == 0 {
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        let _x_no_dropping = ManuallyDrop::new(x);
    } else if millis % 3 == 0 {
        x = Box::new(41);
        println!(&quot;x: {x}&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面的代码, 如果 &lt;code&gt;millis&lt;/code&gt; 是偶数的话, x 会被标记为 &lt;code&gt;ManuallyDrop&lt;/code&gt;, 这样的话编译器将不再自动，调用它的 &lt;code&gt;Drop&lt;/code&gt; trait, 这里就是一个内存泄露点.&lt;/p&gt; 
&lt;p&gt;我们来看一下生成的汇编代码:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;.section.text._ZN13manually_drop4main17hc0c2c79e8eb75025E,&quot;ax&quot;,@progbits
.p2align4, 0x90
.type_ZN13manually_drop4main17hc0c2c79e8eb75025E,@function
_ZN13manually_drop4main17hc0c2c79e8eb75025E:
.Lfunc_begin3:
.cfi_startproc
.cfi_personality 155, DW.ref.rust_eh_personality
.cfi_lsda 27, .Lexception3
subq$408, %rsp
.cfi_def_cfa_offset 416
; x.drop-flag = 0
movb$0, 319(%rsp)
movq_ZN3std4time10SystemTime3now17h4779e0425deae935E@GOTPCREL(%rip), %rax
callq*%rax
movq%rax, 80(%rsp)
movl%edx, 88(%rsp)
movq_ZN3std4time10SystemTime14duration_since17h0f40caf46c5e1553E@GOTPCREL(%rip), %rax
xorl%ecx, %ecx
movl%ecx, %edx
leaq112(%rsp), %rdi
movq%rdi, 56(%rsp)
leaq80(%rsp), %rsi
callq*%rax
movq56(%rsp), %rdi
callq_ZN4core6result19Result$LT$T$C$E$GT$17unwrap_or_default17hb4028d84d22833d3E
movq%rax, 96(%rsp)
movl%edx, 104(%rsp)
.Ltmp9:
leaq96(%rsp), %rdi
callq_ZN4core4time8Duration9as_millis17h1c5ed4310d34772cE
.Ltmp10:
movq%rdx, 64(%rsp)
movq%rax, 72(%rsp)
jmp.LBB23_5
.LBB23_1:
; x.drop-flag == 1
testb$1, 319(%rsp)
jne.LBB23_28
jmp.LBB23_27
.LBB23_2:
.Ltmp25:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 40(%rsp)
movl%eax, 52(%rsp)
jmp.LBB23_3
.LBB23_3:
movq40(%rsp), %rcx
movl52(%rsp), %eax
movq%rcx, 24(%rsp)
movl%eax, 36(%rsp)
jmp.LBB23_4
.LBB23_4:
movq24(%rsp), %rcx
movl36(%rsp), %eax
movq%rcx, 320(%rsp)
movl%eax, 328(%rsp)
jmp.LBB23_1
.LBB23_5:
jmp.LBB23_6
.LBB23_6:
; millis % 2 == 0
movq72(%rsp), %rax
testb$1, %al
jne.LBB23_10
jmp.LBB23_7
.LBB23_7:
.Ltmp18:
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17he729bf437884de0dE
.Ltmp19:
movq%rax, 16(%rsp)
jmp.LBB23_9
.LBB23_8:
.Ltmp20:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 392(%rsp)
movl%eax, 400(%rsp)
movq392(%rsp), %rcx
movl400(%rsp), %eax
movq%rcx, 40(%rsp)
movl%eax, 52(%rsp)
jmp.LBB23_3
.LBB23_9:
movq16(%rsp), %rax
; *(x.ptr) = 42
movl$42, (%rax)
jmp.LBB23_11
.LBB23_10:
jmp.LBB23_17
.LBB23_11:
movq16(%rsp), %rax
; x.drop-flag = 1
movb$1, 319(%rsp)
movq%rax, 136(%rsp)
leaq136(%rsp), %rax
movq%rax, 352(%rsp)
leaq_ZN69_$LT$alloc..boxed..Box$LT$T$C$A$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17h2d3ff932e53a7b07E(%rip), %rax
movq%rax, 360(%rsp)
movq352(%rsp), %rax
movq%rax, 208(%rsp)
movq360(%rsp), %rax
movq%rax, 216(%rsp)
movups208(%rsp), %xmm0
movaps%xmm0, 192(%rsp)
.Ltmp21:
leaq.L__unnamed_9(%rip), %rsi
leaq144(%rsp), %rdi
movl$2, %edx
leaq192(%rsp), %rcx
movl$1, %r8d
callq_ZN4core3fmt9Arguments6new_v117hd27b08a38d223f7cE
.Ltmp22:
jmp.LBB23_13
.LBB23_13:
.Ltmp23:
movq_ZN3std2io5stdio6_print17h8f9e07feda690a3dE@GOTPCREL(%rip), %rax
leaq144(%rsp), %rdi
callq*%rax
.Ltmp24:
jmp.LBB23_14
.LBB23_14:
; x.drop-flag = 0
; let _x_no_dropping = ManuallyDrop::new(x)
movb$0, 319(%rsp)
movq136(%rsp), %rax
movq%rax, 368(%rsp)
jmp.LBB23_16
.LBB23_16:
testb$1, 319(%rsp)
jne.LBB23_26
jmp.LBB23_25
.LBB23_17:
movq72(%rsp), %rax
movabsq$-6148914691236517206, %rcx
movq%rax, %rdi
imulq%rcx, %rdi
movabsq$-6148914691236517205, %rcx
movq%rcx, 8(%rsp)
mulq%rcx
movq%rax, %rsi
movq64(%rsp), %rax
movq%rdx, %rcx
movq8(%rsp), %rdx
addq%rdi, %rcx
imulq%rdx, %rax
addq%rax, %rcx
movabsq$6148914691236517205, %rax
movq%rax, %rdx
subq%rsi, %rdx
sbbq%rcx, %rax
jb.LBB23_16
jmp.LBB23_18
.LBB23_18:
.Ltmp11:
movl$4, %esi
movq%rsi, %rdi
callq_ZN5alloc5alloc15exchange_malloc17he729bf437884de0dE
.Ltmp12:
movq%rax, (%rsp)
jmp.LBB23_20
.LBB23_19:
.Ltmp13:
movq%rax, %rcx
movl%edx, %eax
movq%rcx, 376(%rsp)
movl%eax, 384(%rsp)
movq376(%rsp), %rcx
movl384(%rsp), %eax
movq%rcx, 24(%rsp)
movl%eax, 36(%rsp)
jmp.LBB23_4
.LBB23_20:
movq(%rsp), %rax
; *(x.ptr) = 41;
movl$41, (%rax)
movq(%rsp), %rax
; x.drop-flag = 1
movb$1, 319(%rsp)
movq%rax, 136(%rsp)
leaq136(%rsp), %rax
movq%rax, 336(%rsp)
leaq_ZN69_$LT$alloc..boxed..Box$LT$T$C$A$GT$$u20$as$u20$core..fmt..Display$GT$3fmt17h2d3ff932e53a7b07E(%rip), %rax
movq%rax, 344(%rsp)
movq336(%rsp), %rax
movq%rax, 296(%rsp)
movq344(%rsp), %rax
movq%rax, 304(%rsp)
movups296(%rsp), %xmm0
movaps%xmm0, 272(%rsp)
.Ltmp14:
leaq.L__unnamed_9(%rip), %rsi
leaq224(%rsp), %rdi
movl$2, %edx
leaq272(%rsp), %rcx
movl$1, %r8d
callq_ZN4core3fmt9Arguments6new_v117hd27b08a38d223f7cE
.Ltmp15:
jmp.LBB23_23
.LBB23_23:
.Ltmp16:
movq_ZN3std2io5stdio6_print17h8f9e07feda690a3dE@GOTPCREL(%rip), %rax
leaq224(%rsp), %rdi
callq*%rax
.Ltmp17:
jmp.LBB23_24
.LBB23_24:
jmp.LBB23_16
.LBB23_25:
movb$0, 319(%rsp)
addq$408, %rsp
.cfi_def_cfa_offset 8
retq
.LBB23_26:
.cfi_def_cfa_offset 416
; core::ptr::drop_in_place(x)
leaq136(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17h52d911587572c48aE
jmp.LBB23_25
.LBB23_27:
movq320(%rsp), %rdi
callq_Unwind_Resume@PLT
.LBB23_28:
.Ltmp26:
; drop(x);
leaq136(%rsp), %rdi
callq_ZN4core3ptr49drop_in_place$LT$alloc..boxed..Box$LT$i32$GT$$GT$17h52d911587572c48aE
.Ltmp27:
jmp.LBB23_27
.LBB23_29:
.Ltmp28:
movq_ZN4core9panicking16panic_in_cleanup17hd62aa59d1fda1c9fE@GOTPCREL(%rip), %rax
callq*%rax
.Lfunc_end23:
.size_ZN13manually_drop4main17hc0c2c79e8eb75025E, .Lfunc_end23-_ZN13manually_drop4main17hc0c2c79e8eb75025E
.cfi_endproc

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面的汇编代码比较长, 将它的行为作为注释加到原先的 Rust 代码中, 更容易阅读:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::mem::ManuallyDrop;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // 重置 x 的 Drop Flag:
    // x.drop-flag = 0
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    let millis = timestamp.as_millis();

    if millis % 2 == 0 {
        // 设置 x 的 Drop Flag:
        // x.drop-flag = 1
        // 为 x 分配堆内存, 并设置它的值为 42
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        // 这里, ManuallyDrop 会重置 x 的 Drop Flag:
        // x.drop-flag = 0
        let _x_no_dropping = ManuallyDrop::new(x);
    } else if millis % 3 == 0 {
        // 设置 x 的 Drop Flag:
        // x.drop-flag = 1
        // 为 x 分配堆内存, 并设置它的值为 41
        x = Box::new(41);
        println!(&quot;x: {x}&quot;);
    }

    // x 的值超出作用域, 判断要不要 drop 它:
    // if x.drop-flag == 1 {
    //     core::ptr::drop_in_place(x);
    // }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;Box::leak&lt;/h3&gt; 
&lt;p&gt;另一个例子是 &lt;code&gt;Box::leak()&lt;/code&gt; 它也会抑制编译器自动调用对象的 &lt;code&gt;Drop&lt;/code&gt; trait. 看下面的例子, 也会产生内存泄露:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    let now = SystemTime::now();
    let timestamp = now.duration_since(UNIX_EPOCH).unwrap_or_default();
    let x: Box::&amp;lt;i32&amp;gt;;

    let millis = timestamp.as_millis();
    if millis % 2 == 0 {
        x = Box::new(42);
        println!(&quot;x: {x}&quot;);
        let _x_ptr = Box::leak(x);
    } else if millis % 3 == 0 {
        x = Box::new(41);
        println!(&quot;x: {x}&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们追踪 &lt;code&gt;Box::leak()&lt;/code&gt; 的源代码可以发现, 它的内部也是调用了 &lt;code&gt;ManuallyDrop::new()&lt;/code&gt; 的:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl Box {
    #[inline]
    pub fn leak&amp;lt;&#39;a&amp;gt;(b: Self) -&amp;gt; &amp;amp;&#39;a mut T
    where
        A: &#39;a,
    {
        unsafe { &amp;amp;mut *Box::into_raw(b) }
    }

    #[inline]
    pub fn into_raw(b: Self) -&amp;gt; *mut T {
        // Make sure Miri realizes that we transition from a noalias pointer to a raw pointer here.
        unsafe { addr_of_mut!(*&amp;amp;mut *Self::into_raw_with_allocator(b).0) }
    }

    pub fn into_raw_with_allocator(b: Self) -&amp;gt; (*mut T, A) {
        let mut b = mem::ManuallyDrop::new(b);
        // We carefully get the raw pointer out in a way that Miri&#39;s aliasing model understands what
        // is happening: using the primitive &quot;deref&quot; of `Box`. In case `A` is *not* `Global`, we
        // want *no* aliasing requirements here!
        // In case `A` *is* `Global`, this does not quite have the right behavior; `into_raw`
        // works around that.
        let ptr = addr_of_mut!(**b);
        let alloc = unsafe { ptr::read(&amp;amp;b.1) };
        (ptr, alloc)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;ptr 模块&lt;/h3&gt; 
&lt;p&gt;最后一个要介绍的是 &lt;code&gt;ptr&lt;/code&gt; 模块中的几个函数:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;write()&lt;/li&gt; 
 &lt;li&gt;copy()&lt;/li&gt; 
 &lt;li&gt;copy_nonoverlapping()&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;它们也会抑制编译器自动调用对象的 &lt;code&gt;Drop&lt;/code&gt; trait.&lt;/p&gt; 
&lt;p&gt;我们不再举例了, 而是直接看一下 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的源代码, 看它是怎么实现插入元素和弹出元素的;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::ptr;

impl&amp;lt;T&amp;gt; Vec&amp;lt;T&amp;gt; {
    #[inline]
    pub fn push(&amp;amp;mut self, value: T) {
        // Inform codegen that the length does not change across grow_one().
        let len = self.len;
        // This will panic or abort if we would allocate &amp;gt; isize::MAX bytes
        // or if the length increment would overflow for zero-sized types.
        if len == self.buf.capacity() {
            self.buf.grow_one();
        }
        unsafe {
            let end = self.as_mut_ptr().add(len);
            ptr::write(end, value);
            self.len = len + 1;
        }
    }

    #[inline]
    pub fn pop(&amp;amp;mut self) -&amp;gt; Option&amp;lt;T&amp;gt; {
        if self.len == 0 {
            None
        } else {
            unsafe {
                self.len -= 1;
                core::hint::assert_unchecked(self.len &amp;lt; self.capacity());
                Some(ptr::read(self.as_ptr().add(self.len())))
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;版权&lt;/h2&gt; 
&lt;p&gt;本文节选自 &amp;lt;Rust 编程入门 Introduction to Rust&amp;gt;在线电子书, 转载请注明出处.&lt;/p&gt; 
&lt;h2&gt;参考&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frust.biofan.org&quot; target=&quot;_blank&quot;&gt;Rust 编程入门 Introduction to Rust&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fnomicon%2Fdrop-flags.html&quot; target=&quot;_blank&quot;&gt;Drop Flags&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.rust-lang.org%2Fnomicon%2Funchecked-uninit.html&quot; target=&quot;_blank&quot;&gt;Unchecked Uninitialized Memory&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/shaohua2024/blog/15680818</link>
            <guid isPermaLink="false">https://my.oschina.net/shaohua2024/blog/15680818</guid>
            <pubDate>Mon, 06 Jan 2025 02:43:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>腾讯回应被列入美国防部名单：是个错误</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;1 月 7 日早间，针对美国国防部将腾讯公司列入中国军工公司名单（根据美国法律正式规定为「第 1260H 条清单」），腾讯回应称，&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;「腾讯被列入这份名单显然是一个错误，我们并不是军工企业或军工供应商。不同于出口管制或其他，这份清单对我们的业务没有影响。尽管如此，我们仍将同美国相关部门共同解决误会。」&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;美国国防部在当地时间周一表示，已将包括腾讯、宁德时代在内的中国科技巨头列入名单。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1658&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0107/103642_Pwoj_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0107/103945_a56e_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;据悉，美国 2021 财年《国防授权法案》第 1260H 条，美国国防部每年更新并公布一份与中国军方有联系的实体清单。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/328595</link>
            <guid isPermaLink="false">https://www.oschina.net/news/328595</guid>
            <pubDate>Mon, 06 Jan 2025 02:40:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>