<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Thu, 24 Apr 2025 07:35:54 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>Full GC 频率优化实战</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：vivo 互联网服务器团队- Li Gang&lt;/p&gt; 
&lt;p&gt;本文介绍了游戏业务使用 MAT 和 GC 日志等工具对 Full GC 频率进行优化的过程。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//c341f95428b3ab0136fe82b131ed498d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//93d307a1697bd5e5ed13a82bf4d45ab5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;游戏业务面对用户端的某个工程，每天 Full GC 频率达到 120 次，业务高峰期每 7 分钟就会有一次 Full GC。为了避免情况持续变差，最大程度减少对系统响应时间的负面影响，需要对该工程的 Full GC 频率进行优化。&lt;/p&gt; 
&lt;p&gt;该项目 JDK 版本为 1.8，老年代使用 CMS 作为垃圾回收器，优化前的部分启动参数如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-Xms4608M -Xmx4608M -Xmn2048M -XX:MetaspaceSize=320M -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、工具介绍&lt;/h1&gt; 
&lt;p&gt;在本次优化过程中，我们主要使用了 MAT 和 GC 日志作为排查工具。MAT 是一个功能强大的内存分析工具，而 GC 日志则用于记录 Java 虚拟机中的垃圾回收行为和内存情况。这两者结合起来，能够帮助开发人员深入分析程序的内存使用情况，并进行相应的优化。下文将详细的介绍这两种工具的使用方法，以及对应的优化案例。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.1 MAT（Memory Analyzer Tool）&lt;/h2&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//54a70be170b0944508c621604a927f93.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Eclipse Memory Analyzer Tool（MAT）是一个开源的 Java 堆转储分析工具。它旨在帮助开发人员识别和消除 Java 堆中的内存泄漏和优化内存使用。MAT 允许用户分析 Java 堆转储文件，识别对象的内存占用情况，查找潜在的内存泄漏和冗余对象，以便执行一些内存优化。&lt;/p&gt; 
&lt;p&gt;使用 MAT 打开 dump 文件后，首先进入的是上图页面，此页面会显示 dump 包的缩略概览信息，包括堆大小，类数量，对象数量等信息。其中的 Biggest Objects By Retained Size 和 Leak Suspects 在问题明显时会比较有用，但对相对复杂的问题来说帮助不大。笔者比较常用的是下面这几个功能，下文将依次介绍：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//003bf1d805943c1ca72236688d9943db.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 Dominator Tree&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//305da051d1e325a48a6ffe437a162324.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;展示对象的支配关系。对象 A 支配对象 B 代表从 GC Root（也不一定是 GC ROOT，也可以是 unreachable 的起点）达到对象 B 的所有路径都必须经过对象 A，这也意味着对象 A 被垃圾回收后，对象 B 也会被回收。&lt;/p&gt; 
&lt;p&gt;这个功能相较于下面的 Histogram 更强调对象的引用关系，此外还可以通过 Group By Class/Group By Package/Group By ClassLoader 来进一步的聚合对象。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//57d33fe765c080eaee0982650c74e0a8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;MAT 的各种图标中会频繁的出现 Shallow Heap Size 和 Retained Heap Size 这两个名词，其含义如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Shallow Heap Size&lt;/strong&gt;：这个对象自身在堆中的大小&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Retained Heap Size&lt;/strong&gt;：这个对象被垃圾回收后会释放的堆内存大小&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//ab51af06b1b11e22461c2c4df735896c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上图中，情况 1 里对象 A 的 Retained Heap Size = A 的 Shallow Heap Size + B 的 Shallow Heap Size +C 的 Shallow Heap Size，情况 2 里对象 A 的 Retained Heap Size = A 的 Shallow Heap Size + B 的 Shallow Heap Size。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）使用方法&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;①上图为 Group By Class 的 dominator tree。刚打开 dominator tree 时默认是不进行 group 的，此时可以排查单个大对象，排查完单个大对象后，需要将对象 Group 一下才能进行下一步的排查。&lt;/p&gt; 
&lt;p&gt;② 从上图可以看出，这个堆内的对象内存占用比较分散，说明导致问题的原因可能不止一个，这种情况下只能结合自身业务逐个排查内存占用排在前面的对象。&lt;/p&gt; 
&lt;p&gt;③ 对这些可疑的对象，右键类，选择 List objects → with outgoing references 展开对象列表，查看这类对象具体存了什么，判断这些对象的值是否可以再分类。&lt;/p&gt; 
&lt;p&gt;④ 根据对象的值，判断对象的业务含义，确定是哪段代码创建的对象。&lt;/p&gt; 
&lt;p&gt;⑤ 结合代码，思考这类对象是在新生代还是老年代，如果能确定都在新生代，那这些对象一般不会导致老年代快速增长。&lt;/p&gt; 
&lt;p&gt;⑥如果在老年代，需要确定其是怎么从新生代晋升的，内存占用是否有上限，上限是多少，一般多长时间能达到上限，再确定有没有问题。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 Histogram&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//0aa288e4d9f5bd726b7241f51f1c2093.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;histogram 可以显示出各类对象的 Shallow Heap Size 和 Retained Heap Size，Retained Heap Size 默认不展示，需要点击菜单栏的 Calculate Retained Size 进行计算，堆较大时计算耗时较长。&lt;/p&gt; 
&lt;p&gt;这张表一般和 Dominator Tree 结合使用，我们能看到 char[]占用了较大的内存，但由于 Dominator Tree 里聚合好的 char[]都是顶层支配者，上层不会再有引用，有时无法直接确定这些对象曾经被谁持有过，这时可以通过 Histogram 查看同类对象，找到相似的并且 reachable 的对象来确定这类对象是谁创建的。但是这一步其实可以通过 oql 解决，所以这张表在排查过程中的使用率其实没有 Histogram 高。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.3 OQL&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MAT 提供的一种类似 SQL 的查询语句，可以对对象进行过滤。这篇官方文章里给了很多查询语句样例：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.eclipse.org%2FMemoryAnalyzer%2FOQL&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://wiki.eclipse.org/MemoryAnalyzer/OQL&lt;/a&gt;，这里就简单列一些笔者排查过程中用过的语句，不再赘述：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 字符串模糊匹配
SELECT * FROM char[] b where toString(b) LIKE &quot;.*traceId.*&quot;
// 查找地址&amp;gt;0x700000000 的对象
SELECT * FROM java.lang.Object t WHERE  toHex(t.@objectAddress) &amp;gt;= &quot;0x700000000&quot;
// 查找长度等于 73 并且 retained heap size&amp;gt;1000B 的对象
SELECT * FROM java.lang.Object[] a where a.@length=73 and a.@retainedHeapSize&amp;gt;1000
// 查找长度等于 65536 并且上层有引用的对象
SELECT * FROM char[] a where a.@length=65536 and (inbounds(a).size()&amp;gt;0)
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id=&quot;OSC_h2_7&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.2 GC 日志&lt;/h2&gt; 
&lt;p&gt;GC 日志是记录 Java 虚拟机中垃圾回收活动的日志文件。在 GC 日志中，可以看到包括垃圾回收的时间、类型（如新生代 GC、老年代 GC 等）、回收周期、回收停顿时间、回收前后堆的使用情况等信息。GC 日志打印的信息可以通过以下启动项控制：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//685da0f1c5cfed7523dec9f23a230009.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_8&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、 案例介绍&lt;/h1&gt; 
&lt;p&gt;在这篇文章中，我们将聚焦于一些具体的案例，涉及到大量被 Dubbo 的 FutureAdapter 引用的对象、Jackson 的 BufferRecycler 导致的大量 char[65536]以及对象晋升年龄阈值过小等问题。通过这些案例，我们将探讨这些具体问题的引起原因以及解决方案。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 大量被 Dubbo 的 FutureAdapter 引用的对象&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）分析过程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//b48a8f39c0e7a54137b99320491667e1.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;从上图中，我们可以看到 dubbo FutureAdapter 占用了 230M 左右的内存，前面的 PSWMS 对象虽然也占用了 230M 左右的内存，但这是业务使用的本地缓存相关对象，其内存占用是在预期范围内的，因此优先分析 FutureAdapter。先右键 List objects→with outgoing references 展开对象列表。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//2ed8971570359b6d3d10934510d23c5b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;发现其中有大量大小几乎一致的 FutureAdapter，一个占用内存 328KB 左右，大小和内容几乎一致的对象约有 550 多个，总共占用内存 200M 左右。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//071edf8accd8f32df486ee3b9abdc1fe.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;FutureAdapter 被用来执行 Dubbo 的异步调用，项目使用的 dubbo 版本为 2.7.18。dubbo 的同步调用本质上是一个异步转同步的过程，发起异步调用将 CompletableFuture 对象放到 ThreadLocal 的 FutureContext 里，然后立刻调用 CompletableFuture.get 方法阻塞获取返回值，获取到返回值后，dubbo 不会主动清理 FutureContext，因此该线程的 ThreadLocal 里会有一条 FutureContext→ FutureAdapter→Result 的引用，如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//de0f093c22f3ec69a7f34d73d135eeb3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;然而，那 550 多个 FutureAdapter 均为不可达对象，意味着其不被 ThreadLocal 引用，在下次 GC 时会被回收，不过我们无法直接确定这些对象是在老年代还是新生代，有可能这些对象都在新生代，下次 young gc 时就会被回收，不会晋升到老年代，更不会导致老年代增长。&lt;/p&gt; 
&lt;p&gt;但由于这个列表里的数据有明确的业务含义，可以找到对应的业务接口，此接口单机峰值 qps 约为 2，响应时间约 100ms，每被调用一次，就会创建一个该对象列表，此时该机器的 young gc 频率约为 10s 一次。假设这些对象都在新生代没有晋升老年代，那么这些对象在新生代最大的存活数量约为 ((接口响应时间 + 两次 young gc 间隔) * 对象创建速度) = (0.1s + 10s) * 2 ≈ 20，而堆里有 550 多个，如果这些对象没有晋升到老年代的话数量上对不上，所以可以推测出这些对象在老年代里，需要等下次 Full GC 时才会被回收。&lt;/p&gt; 
&lt;p&gt;那么这些不可达的 FutureAdapter 为什么会在老年代？每次执行 dubbo 调用，dubbo 都会用这次调用的 FutureAdapter 替换掉上次调用时存在 FutureContext 里的 FutureAdapter，上次调用的 FutureAdapter 不再被 GC Root 引用，在下次 GC 时被回收。当一个线程相对频繁的执行 dubbo 调用时，FutureAdapter 会被 young gc 回收，不会晋升到老年代。但在本例中，该 dubbo 调用被放到了 corePoolSize=150，maxPoolSize=500 的业务通用线程池中执行，该线程池会执行其他不需要调用 dubbo 服务的任务，并且该线程池的使用率并不高，这就意味着一个线程调用完 dubbo 服务后可能要过一段时间才能执行下一次 dubbo 调用。&lt;/p&gt; 
&lt;p&gt;由于这个原因导致 FutureAdapter 被放入 ThreadLocal 后，在新生代停留过长时间，最终晋升到老年代，这个&quot;过长时间&quot;对于此项目来说是 6 次 young gc 的间隔时长，这个时长的获取方法会在后续说明。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;对于此业务来说，这个 dubbo 调用可以改为查询本地缓存，直接解决了问题。除此之外还有其他解决方案，需要结合自身业务选择合适的方案。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;直接使用 dubbo 的异步调用，而不是在上层再创建一个线程池来进行调用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;合理设置线程池的大小，提高线程的利用率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;写一个 Dubbo Filter，每次同步调用完后清理 FutureContext（影响面可能较大，需自行评估风险）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h2_10&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.2. Jackson 的 BufferRecycler 导致的大量 char[65536]&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）分析过程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;从 dominator tree 中我们能看到 char[]也占用了相当大的一部分内存，展开 char[]，发现其中包含大量的 char[65536]，使用 oql 统计得知不被 gc root 引用的有 1600 个，占用内存 200M 左右，被 gc root 引用的有 500 个，这种 char[65536]里存储的数据均为 http 接口返回值反序列化后的字符。其被 gc root 引用时的链路如下，均被 ThreadLocal 里的 BufferRecycler 引用：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//c7c0700fe985adc40f2087ce8cd6a49e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在 Jackson 库中，BufferRecycler 的主要作用是管理缓冲区的重用，可以减少频繁的内存分配和释放，从而降低垃圾回收的负担，提高性能。但从堆上看，这些 char 数组里不可达的数量远大于可达的数量（1600:500），说明其复用率并不高，与其设计的目标不符，需要查看源码才能搞清原因。&lt;/p&gt; 
&lt;p&gt;项目使用 jackson 的 ObjectMapper.&lt;/p&gt; 
&lt;p&gt;writeValueAsString() 方法对 http 接口返回值进行了反序列化，使用的 Jackson 版本为 2.10，该方法完整的执行流程如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//62746e30c7bca82d5152bb3866beba57.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;简单来说，jackson 在反序列化时，会将反序列化的结果存储在多段 char[]里，每当最后一个 char[]空间不够存放结果时，就新建一个 char[]，大小为最后使用的 char[]的 1.5 倍，但不超过 65536，反序列化结束后将 char[]列表拼接起来就得到了结果，然后线程会将最后使用的那个 char[]存放到 ThreadLocal。此线程下次反序列化时，会从 ThreadLocal 取出这个 char[]进行复用。这样的一个复用逻辑会有一个问题，参考下图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//eb96347e6b14c8ab36c19ee341feb2b2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图中，_segements 是当前反序列化使用过的 char[]列表，currentSegement 是当前正在使用的 char[]。一个 char[]的大小最大为 65536。在第二次反序列化大对象时至少会创建一个新的大小为 65536 的 char[]（上一次的 char[]是 65536，再创建一个新 char[]其大小仍不能超过 65536）。可以看到在第一次反序列化结束后和第二次反序列化结束后，虽然 ThreadLocal 里存放的 char[]大小都是 65536，但其实它们已经不是同一个对象了。这样的一个替换是没有必要的，完全可以一直复用同一个 char[]。&lt;/p&gt; 
&lt;p&gt;当业务所有 http 接口的返回值都大且流量也大时，每次保存在 ThreadLocal 里的 char[65536]虽然会在下次反序列化结束时被替换导致其失去引用，但由于其在新生代只存活了一次接口请求的时间，所以不会晋升到老年代，可以被 young gc 回收。但是我们项目用来处理 http 请求的线程池都是同一个，这些接口的返回值只有一部分超过了 65536，在小于的时候 ThreadLocal 里的 char[]不会被替换，当这个 char[]在 ThreadLocal 里停留一段时间后，就会晋升到老年代，从而导致老年代内存增长。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;关闭 Jackson 的 USE_THREAD_LOCAL_&lt;/p&gt; &lt;p&gt;FOR_BUFFER_RECYCLING，关闭该开关会在每次反序列化时创建一个 BufferRecycler，而不是复用 ThreadLocal 里的 BufferRecycler，这样可能导致 young gc 频率提高。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;升级 Jackson 版本，请参考此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFasterXML%2Fjackson-core%2Fissues%2F1186&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;issue&lt;/a&gt;，2.17 版本的 jackson 在调用 releaseByteBuffer 时会避免较小或者相同大小的 char 数组替换原有数组。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;由于项目使用的 jackson 版本是 2.10，直接升级到 2.17 的版本跨度较大，可能带来不必要的风险，因此采用了方案 1，上线后，young gc 频率没有明显增加。方案 2 的 issue 里有提到使用 2.16 版本引入的 RecyclerPool 代替基于 ThreadLocal 的实现，这也是解决方案之一。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_11&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.3 对象晋升年龄阈值过小&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）背景知识&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;java 对象从新生代晋升到老年代有多种原因，在本项目中，对象的主要晋升原因是在新生代长期存活，这个长期具体是多久有以下两个判断条件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;对象晋升年龄阈值&lt;/strong&gt;：&lt;/p&gt; &lt;p&gt;可通过-XX:MaxTenuringThreshold 启动项进行配置，对于 CMS，默认值是 6。此参数定义了对象在年轻代存活的最大年龄，如果一个对象在年轻代经过 N 次 GC 后依然存活，它将会被晋升到老年代。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;动态年龄判定&lt;/strong&gt;：&lt;/p&gt; &lt;p&gt;在 survivor 区中小于或等于某年龄的的所有对象大小的总和大于 survivor 空间的一定比例时，大于或等于该年龄的对象就直接进入老年代，这个比例可以通过-XX:TargetSurvivorRatio 启动项控制，默认值为 50，代表 50%。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;一个对象的年龄满足上述两个条件之一时，就会晋升到老年代，具体的晋升年龄可以通过在启动项里添加-XX:+PrintTenuringDistribution 获取，添加该参数后的 gc 日志如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//95469f548179176146627eff82e243f8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其中区域 2 的 (max 6) 代表-XX:MaxTenuringThreshold 启动项配置的值，也就是说对象到达这个年龄一定会晋升，而 new threshold 6 代表对象实际晋升的年龄，上图代表这次 young gc 因对象到达年龄阈值会导致 9946864 bytes 的对象晋升。&lt;/p&gt; 
&lt;p&gt;区域 1 代表动态年龄判定所需的空间大小，也就是 (survivor 空间大小 x targetSurvivotRatio)。此项目堆的单个 survivor 空间为 200M，所以只要在 survivor 区中小于或等于某年龄的所有对象大小的总和大于 200Mx50%，大于或等于该年龄的对象就会晋升，。&lt;/p&gt; 
&lt;p&gt;而下图的对象是因为动态年龄判定才晋升的，这次 young gc 因动态年龄判定会导致 38660424 bytes 的对象晋升：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//870184931e6dce04cd75cc983f8e6b50.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）分析过程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化前+调参前：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在进行 dubbo 和 jackson 以及其他业务代码上的优化前，我们保存了当时的 gc 日志，可以看到大部分对象都是因为年龄到达 6 晋升的，每次 young gc 约有 10M~16M 左右的对象晋升，显然对象的晋升年龄阈值太小，需要调大。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//f3a1011e66fe04d2d69d6c1b3668989b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;优化后+调参前：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在调整 JVM 参数之前，我们决定先着手进行业务上的优化。因为直接进行参数调整可能会治标不治本，无法消除潜在的隐患。在完成业务代码上的优化后，可以看到此时由于年龄达到 6 这一阈值晋升的对象大小从最开始的 10M~16M 降为了 4M 以下，意味着在新生代长期存活的对象数量明显减少了，但仍然有优化空间。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//437d430248171225f9fc734e950ddba2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（3）解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在完成业务代码上的优化后，我们对 JVM 参数进行了调整。将-XX:MaxTenuringThreshold 参数改为 15，-XX:TargetSurvivorRatio 改为 75%（实际上，通过调参后的 gc 日志我们能确定对于这个项目来说，50% 也已经够用，因为年龄 1 到 15 的对象占用的总内存只有 38M 左右，远远小於单个 survivor 空间的 50%），以延长对象在新生代的存活时间。我们可以观察到，尽管会有一些对象存活到年龄 15 的阈值才晋升，但是这部分对象的总大小变小了，大部分情况下都是小于 2M。这部分对象通过添加监控的方式判断大概率是被移除（大小不足被淘汰，过期等原因）的 caffeine 本地缓存。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//af093a3fbad11a7dcb722a15773c467c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在经过上述一系列优化措施以及一些其他问题的修复后，该工程的 Full GC 频率从最初的每天 120 次，总耗时 1 分钟到 1.5 分钟，成功降低到每天约 30 次左右，总耗时控制在 15 秒到 25 秒之间。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;① GC 次数优化曲线&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//f4b9de14ba7bd218936f4d33e324bf12.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//62c975b43a026c51f7287973bb1cf2aa.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;② GC 总耗时优化曲线&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//a82564cdfade061afcdd2b06695054fe.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;图片&quot; src=&quot;https://oscimg.oschina.net/oscnet//05c620fbd4f4026dc4446999c7f92b83.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;总的来说，进行 GC 优化时，可以使用以下工具分析当前内存/GC 情况：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;先用 jamp 生成 dump 文件，再使用 MAT 进行分析，找到可能引发问题的对象。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用内存分配火焰图找到哪些代码在频繁的分配内存。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用 GC 日志分析 GC 情况，了解 GC 频率/触发 GC 的原因等信息。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;使用这些工具找到问题后，可以修改对应的业务代码或者调整 JVM 相关参数，以优化 Full GC 频率。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18231016</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18231016</guid>
            <pubDate>Thu, 24 Apr 2025 07:21:51 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>35 岁脑干出血程序员发声</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;近日，浙江杭州「35 岁程序员长期熬夜脑干出血」引发关注。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/151248_PWGU_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;根据这名当事人的社交平台账号资料进行汇总，大致信息如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;1、这位程序员姓吴，入行 8 年了。他去年 33 岁，35 岁应是虚岁。本来是想着趁年轻多挣点钱，让老婆和孩子的生活更好一点。&lt;br&gt; 2、吴哥上一份工作月薪 3 万，出事之前经常凌晨一两点睡，然后早上 7 点起。那段时间压力很大，睡得也很晚，很累。&lt;br&gt; 3、2024 年 7 月底出现脑干出血，多次出血量达到 5 ml，采用保守治疗，ICU 抢救 28 天，15 天昏迷，2 次病危。&lt;br&gt; 4、康复期间：从瘫到走用了 1 个月，从走到能走好再用了 1 个月。&lt;br&gt; 5、女儿 5 岁，幼儿园小班，现在压力都给到老婆了。&lt;br&gt; 6、吴哥说会考虑去摆摊，尽可能把生命活厚一点。&lt;br&gt; 7、根据他最近发的视频，他自称：身体情况基本上能像生病前的状态。每天坚持做运动，自己也变得比以前更自信了。&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;1145&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/151917_dpNh_2720166.png&quot; width=&quot;828&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;4 月 23 日晚，当事人&lt;em&gt;&lt;strong&gt;@脑干出血的程序员&lt;/strong&gt;&lt;/em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6210742110%2FPoIRp8i8j%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;发长文&lt;/a&gt;&lt;/u&gt;讲述发病经过以及现状。他表示，自己在 ICU 一共待了 28 天，后来又去康复医院待了 70 多天，回家之后也一直在康复和锻炼，现在已经恢复了大约 70%，但可能没有办法完全康复了。之前在一家创业型公司工作，当面临裁员时，精神压力比较大。生病之后，基本上没了收入，家庭经济压力也比较大，女儿现在还小，自己也在想方设法考虑如何回归社会去挣钱，现在选择做自媒体也是一个尝试。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「现在的我看待生活，觉得让自己开心很重要，活得自由一点。之前想着我要挣钱，会在很多方面压制自己，现在的话我觉得更多的可能要去好好体验生活，让自己过得快乐。也希望大家如果觉得累了，就歇一歇，我是前车之鉴。&lt;/p&gt; 
 &lt;p&gt;如果能见到以前的自己，我想对他说：「好好爱自己。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;原文如下：&lt;/p&gt; 
&lt;p&gt;我是新闻中脑干出血的程序员。&lt;/p&gt; 
&lt;p&gt;我是去年 7 月底手麻脚麻已经有几天了，当时以为是颈椎病，所以没在意。等到 8 月 1 号的时候，晚上我下班回家，去打扫了一下衞生，突然就要呕吐，趴在床上缓解不了，就一直想吐，然后我就开车去了医院，是的，那时候我还能开车。到了医院拍了个 CT，诊断出脑干出血。6 天之后我就出院了，那时候情况还挺好的，只有手麻脚麻，没有其他症状。结果去了康复医院之后发现再次出血了，没办法就去了上海的大医院。&lt;/p&gt; 
&lt;p&gt;当时我就一直在发烧，而且咳嗽，24 小时地咳，根本没法睡觉，说话已经大舌头了，手脚都不利索。医生说我这个情况做不了康复，专家会诊完就把我送进了 ICU。我最后只记得抽血检查，然后就昏过去了。后来才知道，我脑干部位长了一个血管瘤，可能是因为我压力太大、过度劳累，那个血管瘤破了。&lt;/p&gt; 
&lt;p&gt;昏迷了大概 15 天吧，等再醒过来的时候，我发现自己手和脚都动不了，连声音都发不出来，非常难受，就像被鬼压床一样，被封印在床上，既没办法克服，也没办法求助，这种状况持续了大约一两周。家人进来探视，我也只能瞪着眼睛盯着他们看，什么也说不了也做不了。当时我只知道自己体温和心率都很高，梦里都在想怎么把体温和心率降下来。&lt;/p&gt; 
&lt;p&gt;我前后在 ICU 一共待了 28 天，后来又去康复医院待了 70 多天，回家之后也一直在康复和锻炼。因为我在床上躺了将近两个月了，肌肉已经萎缩，一开始我连坐都坐不起来，得两个人一起才能把我从床上拖到轮椅上。最艰难的就是「接受我自己」，接受自己的现状，接受现在的我与过去健康的我之间的差别。后来我的康复进展很快，一天比一天好。后来我才知道，不管是康复治疗师还是我的主治医生，都没想到我能恢复成现在这个样子，在他们看来我的病情挺严重，大概率是会瘫痪的。&lt;/p&gt; 
&lt;p&gt;现在我已经恢复了大约 70%，全身还会觉得麻木，尤其是左侧的肢体麻木比较严重，左手的部分触觉其实是丢失的，比如说我去摸被子，我是摸不出来那个被子和一张纸巾有什么区别的，所以我左手基本上拿不住东西。舌头还是歪的，说话有点大舌头，脊椎也不太行。其实我也知道，我可能没有办法完全康复了，而且这辈子就得一直做康复。&lt;/p&gt; 
&lt;p&gt;我之前在一家创业型公司工作，人少活儿多，给我分配的工作也确实很多。后来公司内部出了一些问题，我倒是稍微闲了一点，但处于被边缘化的状态，面临裁员压力，那时候精神压力就特别大。前前后后大约一年半的时间吧，我几乎就是晚上 12 点以后睡，早上 6、7 点就得醒。我生病之后，公司也算是按规章来的，也来看望过，工资也是按我们当地最低标准给我发了。至于工伤，我也去咨询过，因为脑干出血不属于特殊疾病，也不能算职业病，所以没法认定工伤。&lt;/p&gt; 
&lt;p&gt;我生病的时候，5 岁女儿刚开始上幼儿园小班，所以我老婆在家带小孩，我在 ICU 那边一直是我爸妈和我舅舅照顾。从一开始 ICU 治疗到后来去做康复，我前前后后已经花了 40 多万了，钱的方面压力很大。家里现在还有多少积蓄，我一直不好意思问，只知道家人之前借了一些债。&lt;/p&gt; 
&lt;p&gt;以前家里主要靠我挣钱，月薪有 3 万，现在我已经断收了，更多的压力给我妻子，她一边要赚钱，一边还要照顾小孩。我现在这个身体状况是挣不到钱的，所以也在想办法去破这个局，怎么才能回归社会去挣钱，减少家里的开支，其实这也是很多脑出血的病人面临的一个困局。&lt;/p&gt; 
&lt;p&gt;其实我们群体很多人从患病之后心里会变得很悲观，甚至会抑郁，所以我就想去开导鼓励他们，让他们更积极一点。我也联系了一些康复的病友，希望大家一起努力，让社会上更多人看到我们知道我们。得了这种病之后，尤其是年轻人，后来的日子很难过的，我希望社会能够帮助我们。&lt;/p&gt; 
&lt;p&gt;所以我做自媒体，拍视频，有的时候还开直播，其实也在一个尝试，如果我能做好了，那我的很多病友们也能看到他们自己成功的希望。但是做自媒体挑战确实很大，我以前是做技术的程序员，每天更多是面对电脑，话也很少，是很内向的一个人，现在不得不去试着变得外向。直播带货的话，现在还说不好，以后看情况应该会，我觉得这个没有什么好拒绝的。&lt;/p&gt; 
&lt;p&gt;可能大家看到了我的短视频账号，上面有很多我康复训练的过程。其实一开始我也没打算做短视频，是家里人很关心我的情况，我妈才录下来发给他们看。而我的心态也因为这次生病有了变化，我也不知道自己能活多久，发现我的手机相册里根本就没有我的照片或者视频。女儿还小，我不知道他长大之后我还在不在，万一哪天女儿想知道爸爸是什么样子，我可以有个地方记录一下，可以让她看到爸爸的样子。后来就有一些病友开始私信我，说我的状态让他们看到了康复的希望，希望我继续做下去，而且联系我的病友和家属越来越多，这个时候我就觉得这个账号我要一直做下去。&lt;/p&gt; 
&lt;p&gt;现在的我看待生活，觉得让自己开心很重要，活得自由一点。之前想着我要挣钱，会在很多方面压制自己，现在的话我觉得更多的可能要去好好体验生活，让自己过得快乐。也希望大家如果觉得累了，就歇一歇，我是前车之鉴。&lt;/p&gt; 
&lt;p&gt;如果能见到以前的自己，我想对他说：「好好爱自己。」&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;最后推荐两份指南：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/p/howtolivelonger&quot; target=&quot;_blank&quot;&gt;程序员延寿指南&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/p/humansystemoptimization&quot; target=&quot;_blank&quot;&gt;人体系统调优指南&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346354</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346354</guid>
            <pubDate>Thu, 24 Apr 2025 07:16:51 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Perplexity 为 iOS 版应用添加 AI 语音助手功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Perplexity 今天对 iOS 应用进行&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fperplexity_ai%2Fstatus%2F1915064472391336071&quot; target=&quot;_blank&quot;&gt;更新&lt;/a&gt;，为其添加了 &lt;strong&gt;AI 语音助手功能 (Perplexity iOS Voice Assistant)&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/150420_FsMt_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;现在，苹果用户可以在应用中激活该助手，并让它执行诸如撰写电子邮件、设置提醒和预订晚餐等任务 —— 某种程度上实现近似苹果第一方 Siri 助手的使用体验。&lt;/p&gt; 
&lt;p&gt;您甚至可以离开该应用并继续与 Perplexity 对话，尽管它目前还不支持像 Android 那样的屏幕共享。与此同时，苹果承诺为 Apple Intelligence 驱动的 Siri 提供的一些对话式 AI 功能可能还需要一年多的时间才能实现。与 Apple Intelligence 不同的是，Perplexity 的助手可以在旧设备（例如我的 iPhone 13 mini）上执行这些操作。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1090&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/150645_H3Rh_2720166.png&quot; width=&quot;824&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;当 Android 版本于 1 月份推出时，Perplexity 的发言人表示，一旦「苹果给予我们足够的权限」，该版本就会登陆 iPhone 和 iPad，显然这个目标已经实现。&lt;/p&gt; 
&lt;p&gt;Perplexity 的语音助手在 iOS 上还有其他限制，它并不能像 ChatGPT 和 Grok 等其他 AI 助手那样让它访问设备相机并「查看」你所看到的内容以了解具体情况。但仍然可以使用标准的基于文本的聊天机器人来询问有关图片的问题，也不能让它为你设置 iPhone 的定时闹钟——这些看似基本的功能仍然需要 Siri 来实现。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346353/perplexity-ios-voice-assistant</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346353/perplexity-ios-voice-assistant</guid>
            <pubDate>Thu, 24 Apr 2025 07:07:51 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>一季度末广东人工智能核心产业规模超 2200 亿元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;4 月 24 日，广东省工业和信息化厅举行一季度新闻发布会。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;会上透露，一季度，全省先进制造业、高技术制造业增加值分别同比增长 5.9%、5.3%，均高于全省规上工业增加值增速，占全省规上工业比重分别达到 55.3%、32.4%，产业结构和质量持续优化。其中，高技术产品产量快速增长，新能源汽车、储能用锂离子电池、民用无人机产量分别增长 29.9%、83.5%、48.2%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在人工智能产业发展方面，截至今年一季度末，全省人工智能核心产业规模超 2200 亿元，稳居全国第一方阵。人工智能核心企业超 1500 家，其中：独角兽企业 24 家，上市企业达 92 家，国家专精特新「小巨人」企业达到 147 家，数量位居全国第一；全省已发布 63 个大模型，位居全国前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;291&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-60272d80dd5a346ed3cc39fabd06440e891.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;机器人产业发展方面，广东已成为国内机器人产业的主要集聚区之一，形成以广州、深圳、佛山、东莞为核心，珠三角协同发展的机器人产业格局。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2019—2024 年，全省工业机器人产量从 4.47 万台（套）增长到 24.68 万台（套），2024 年工业机器人产量占全国 44%，连续五年全国第一。今年一季度，广东工业机器人累计产量 6.32 万套、服务机器人 194 万套，累计增长 31.1% 和 10.8%，延续了良好的增长态势。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346351</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346351</guid>
            <pubDate>Thu, 24 Apr 2025 06:48:51 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Google I/O 2025 聚焦四大领域：Android、AI、Web 和云</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;谷歌一年一度的开发者大会 Google I/O 2025 将于 5 月 20 日至 21 日举行，目前谷歌已经提前公布了部分会议议程。&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/143335_Y1X9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fio.google%2F2025%2Fexplore&quot; target=&quot;_blank&quot;&gt;https://io.google/2025/explore&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;在本次大会中，Android 系统依旧是重头戏之一。谷歌表示将举办一场关于安卓「进阶版」用户体验设计 Material 3 Expressive 的展示活动。谷歌解释称，&lt;strong&gt;此次会议将重点介绍其「全新情感设计」&lt;/strong&gt;。同时，谷歌还将为开发者提供相关的设计文件和 alpha 代码，以便他们能够提前为适配这一新的设计理念做准备。&lt;/p&gt; 
&lt;p&gt;此外，&lt;strong&gt;谷歌还将重点讨论 Android 系统的「桌面窗口化」和「手写笔支持」功能&lt;/strong&gt;。桌面窗口化功能旨在帮助用户更高效地管理多任务操作，提升生产力；而 Ink API 的引入则将进一步优化 Android 设备对手写笔的支持，为用户在绘画、笔记记录等场景中提供更出色的体验。&lt;/p&gt; 
&lt;p&gt;在扩展现实（XR）领域，谷歌也准备了重大消息。大会期间，谷歌将详细介绍 Android XR 的最新进展，包括其 SDK 开发者预览版即将升级为 Beta 版本的消息。此外，谷歌似乎计划在今年晚些时候正式发布 Android XR。此前谷歌在 TED 2025 上展示了支持 Android XR 的智能眼镜，内置了 Gemini AI 的「记忆」功能。&lt;/p&gt; 
&lt;p&gt;除了 Android 和 XR，谷歌的 AI 技术也将在 I/O 2025 上大放异彩。谷歌将展示其最新的 Gemini 模型进展，并探讨未来 AI 软件的发展方向。此外，谷歌还将介绍即将集成到 Chrome 浏览器中的新 AI API，这些 API 将能够帮助用户更高效地进行内容总结和创作。&lt;/p&gt; 
&lt;p&gt;本次大会的议程还包括对谷歌云服务、Web 技术等领域的深入探讨，旨在为开发者和用户提供更多前沿技术和解决方案。&lt;/p&gt; 
&lt;p&gt;Google I/O 2025 将通过主题演讲、会议、演示、社交活动和工作坊等多种形式，为参与者带来丰富的内容和交流机会。&lt;/p&gt; 
&lt;p&gt;值得一提的是，谷歌在 2025 年世界移动通信大会（MWC）上已经确认，Android 16 将在今年第二季度&lt;a href=&quot;https://www.oschina.net/news/337398/android-16-is-on-track-for-june&quot;&gt;提前发布&lt;/a&gt;。目前谷歌正在积极开发测试版，以确保该系统在 6 月正式推出时能够满足用户的需求。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;阅读更多：&lt;a href=&quot;https://www.oschina.net/news/333679/google-io-2025-kicks-off-on-may-20&quot; target=&quot;_blank&quot;&gt;Google I/O 2025 已定档，议程涵盖 Android 系统优化、Gemini AI 模型&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346347/google-io-2025-explore</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346347/google-io-2025-explore</guid>
            <pubDate>Thu, 24 Apr 2025 06:36:51 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>360 旗下纳米 AI 发布「MCP 万能工具箱」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;360 旗下纳米 AI 已正式发布「MCP 万能工具箱」，并于 4 月 23 日下午开始内测。首批受邀用户为部分 AI 博主、媒体和普通用户，目前，只有拿到邀请码，才能开始体验。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;360 集团创始人周鸿祎介绍，万能工具箱基于 MCP 而生，已接入超过 110 款工具，覆盖办公协作、学术、生活服务、搜索引擎、金融、媒体娱乐、数据抓取等多种场景，且工具免费、可一键安装、安全可信。目前，用户可在纳米 AI 客户端直接调用各类工具，还能用工具创建属于自己的智能体，提升工作效率，方便自身生活。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;306&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-fff7e9da989b5de475223200a722e6cbf27.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;纳米 AI 产品负责人梁志辉介绍，MCP 让大模型可调用工具，大家熟悉的 Deepseek 大模型过去只能做文本理解、内容生成的事情，但现在在纳米 AI 客户端里给 DeepSeek 加上 MCP 工具，DeepSeek 能帮你作图、编辑视频，或者调用其他工具来帮你办到过去大模型办不到事，最终解决「AI 可用」的问题。当工具调用变得像呼吸一样自然，AI 才能突破今天「只是个聊天机器人」的尴尬，才能进化成真正的「数字员工」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;梁志辉透露，纳米 AI 这次上线的 MCP 万能工具箱，是本着打造「AI 应用基础设施」的目标在反复打磨。360 的考量是，工具对 AI 应用意义重大，在人类历史中，人类的脑容量水平并未发生根本改变，但人类世界在发生天翻地覆的变化，原因在于，人类创造工具利用工具的能力在无限加强，是工具改变了世界。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据介绍，除了「开箱即用」等特点纳米 AI 在其万能工具箱的开发过程中专门为所有工具做了安全检测，能够解决行业普遍面临的 MCP 服务安全和信任等问题，确保用户能在安心、安全的环境下使用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「对比市场同类产品，纳米 AI 本身集成了国内 16 家大模型厂商的 50 多款大模型，Deep Seek- R1 和阿里通义千问都在其中，用户能选择不同的大模型基座驱动工具乃至智能体。」梁志辉称，纳米 AI 还精心打磨了知识库产品，可以让 AI 更懂企业和个人，「纳米 AI 万能工具箱、知识库、多模型，这些功能的组合，可以让纳米 AI 为用户提供更好更实用的体验。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346344</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346344</guid>
            <pubDate>Mon, 14 Apr 2025 06:23:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>特朗普签署行政令，推动 AI 进入课堂</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;美国总统特朗普近日签署了一项行政命令，旨在将人工智能纳入&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;（AI）&lt;/span&gt;美国的课堂。&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;虽然该行政令的具体文本尚未公布，但《华盛顿邮报》获得的草案副本显示，该行政令要求开展学生 AI 应用能力培训，并推动学校与企业合作实施相关教学计划。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;334&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bbbdec57534b4d20825a088011eae4027b1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;该命令将指示教育部长琳达·麦克马洪优先使用联邦资金，培训教师和管理人员如何应用 AI，并将其纳入所有学科教学。&lt;/span&gt;此外，&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;美国政府还计划成立一个人工智能教育工作组，鼓励联邦机构与私营部门合作，目标是教授学生「基本的人工智能素养和批判性思维技能」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346341</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346341</guid>
            <pubDate>Mon, 14 Apr 2025 06:13:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 预测 2029 年收入激增至 1250 亿美元，2030 年达 30 亿月活用户</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 近期发布了一项关于未来收入的预测，预计到 2029 年，其总收入将达到 1250 亿美元。其中，AI 代理业务和渠道收入将成为主要驱动力。根据预测，AI 代理业务将占总收入的近四分之一，预计收入将达到 290 亿美元，而渠道收入则预计达到 250 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;222&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bad840387250fc1bdbfdc3a7d49fba94372.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;随着 ChatGPT 的成功，OpenAI 的收入在 2023 年达到了 37 亿美元，较前一年增长近四倍。当前，该公司的周活跃用户已超过 5 亿，相比去年底的 3 亿，显著增长。值得注意的是，OpenAI 预计到 2029 年，其 AI 代理的销售额将超越 ChatGPT 的收入，这表明 AI 代理市场的快速扩张。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 的 AI 代理产品价格不一，面向高收入知识工作者的每月订阅费用为 2000 美元，而针对博士级研究的产品则可高达每月 20000 美元。这使得 OpenAI 的销售额与行业巨头英伟达和 Meta 相媲美。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;除了 AI 代理，OpenAI 还在探索多元化的收入来源。虽然 CEO Sam Altman 对传统广告持谨慎态度，但他提到可能会通过用户在 ChatGPT 或 AI 代理上发起的销售收取推广费。此外，OpenAI 预计到 2029 年，通过免费用户和其他产品的收入将达到 250 亿美元，约占总收入的五分之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;在控制成本方面，OpenAI 预计未来四年将消耗约 460 亿美元的现金用于模型训练和运营成本。然而，预计到 2029 年，公司将实现现金流转正，并在该年度产生近 120 亿美元的现金。推理成本的增长将在未来五年逐渐放缓，这将有助于提升公司的利润率，毛利润比例预计将从去年的 40% 提升至接近 70%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 预计用户数量将大幅增长，到 2030 年将达到 30 亿月活用户、20 亿周活用户和 9 亿日活用户。这些预测使得软银等投资者愿意以 2600 亿美元的估值向 OpenAI 注入 400 亿美元的新资本。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346316</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346316</guid>
            <pubDate>Mon, 14 Apr 2025 03:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 正在打造「最强」开源模型，计划今年初夏发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;今年 3 月下旬，OpenAI 宣布将在年内推出自 GPT-2 以来的首个&quot;开源&quot;语言模型。随着该公司与 AI 开发者社区的交流持续推进，关于这款模型的更多细节也逐步浮出水面。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F04%2F23%2Fopenai-seeks-to-make-its-upcoming-open-ai-model-best-in-class%2F&quot; target=&quot;_blank&quot;&gt;据 TechCrunch 报道&lt;/a&gt;，知情人士透露，OpenAI 研究副总裁艾丹·克拉克（Aidan Clark）正主导这项开发工作，目前仍处于初期阶段。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/111938_NBnV_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;OpenAI 计划在今年初夏发布该模型，目标是打造一个在开源推理模型中达到顶尖水平的产品。这款模型定位为推理能力模型，类似于 OpenAI 现有的 o 系列产品。&lt;/p&gt; 
&lt;p&gt;知情人士称，OpenAI 正考虑为该模型采用一种高度宽松的开源许可协议，几乎不设使用或商业限制。这与 Meta 的 Llama、谷歌的 Gemma 等开源模型形成对比，后者因使用条款过于繁琐而受到批评。OpenAI 显然希望避免步其后尘。&lt;/p&gt; 
&lt;p&gt;目前，OpenAI 面临来自包括中国 AI 实验室 DeepSeek 在内的开源策略竞争者的挑战。这些&quot;开源&quot;竞争者将模型提供给 AI 社区用于实验，在某些情况下还允许商业化使用，与 OpenAI 此前更为封闭的做法形成鲜明对照。&lt;/p&gt; 
&lt;p&gt;这种开放策略已被证明对部分企业极其成功。Meta 在 3 月初宣布，Llama 系列模型的累计下载量已突破 10 亿次。而 DeepSeek 也迅速积累了大量用户，并获得本土投资者的关注。&lt;/p&gt; 
&lt;p&gt;据悉，OpenAI 此次推出的开源模型将支持纯文本输入输出，可在高端消费级硬件上运行。开发者还可能可以选择是否启用「推理模式」——推理功能虽能提升准确性，但会以增加延迟为代价，这与 Anthropic 等公司近期发布的推理模型相似。&lt;/p&gt; 
&lt;p&gt;如果此次发布反响积极，OpenAI 还计划后续推出更多开源模型，可能包括更小规模的模型版本。&lt;/p&gt; 
&lt;p&gt;OpenAI 首席执行官山姆·奥特曼（Sam Altman）此前曾公开表示，公司在技术开源方面「站在了历史的错误面」，并呼吁重新审视开源战略。&lt;/p&gt; 
&lt;p&gt;奥特曼在今年 1 月参加问答活动时指出：「我个人认为，我们需要制定一种新的开源策略。尽管并非所有 OpenAI 员工都认同这一观点，目前这也不是我们的首要任务，但今后我们会推出更好的模型，不过领先优势可能不像以往那样显著。」&lt;/p&gt; 
&lt;p&gt;他还表示，这款即将发布的模型将经历严格的「红队测试」和安全评估流程。知情人士透露，OpenAI 将为该模型发布「模型卡片」（Model Card），即一份全面的技术文档，详尽展示模型在内部与外部基准测试、安全性评估等方面的结果。&lt;/p&gt; 
&lt;p&gt;奥特曼上月发文称：「我们会在发布前，依据‘模型准备度框架’对其进行全面评估，并在已知该模型发布后可能被修改的前提下，做更多的安全准备工作。」&lt;/p&gt; 
&lt;p&gt;尽管如此，OpenAI 近年来也因对部分新模型仓促推进安全测试、未及时发布模型卡等问题，受到人工智能伦理学者的批评。奥特曼本人也曾在 2023 年 11 月被短暂罢免前，在模型安全审查方面误导高管。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/342166/openai-open-model&quot; target=&quot;news&quot;&gt;OpenAI 宣布将开源推理模型&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340236&quot; target=&quot;news&quot;&gt;OpenAI CEO 奥特曼 ：DeepSeek 教训了我们，GPT-5 将免费开放&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334567&quot; target=&quot;news&quot;&gt;OpenAI 即将开源新模型，CEO 发起投票公开征求意见&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346315/open-ai-model-best-opensource-coming-soon</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346315/open-ai-model-best-opensource-coming-soon</guid>
            <pubDate>Mon, 14 Apr 2025 03:20:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌 AI 聊天机器人 Gemini 全球每月活跃用户 3.5 亿</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;根据谷歌正在进行的反垄断诉讼中披露的内部数据，截至 3 月份，谷歌 AI 聊天机器人 Gemini 在全球每月拥有 3.5 亿活跃用户。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-61ea9a0e05eb37744a7bdaa96a39bff52f5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;《The Information》首先报道了这一统计数据，称谷歌人工智能产品的使用量在去年呈爆炸式增长。&lt;/p&gt; 
&lt;p&gt;根据谷歌的数据，Gemini 在 2024 年 10 月的日活跃用户仅为 900 万，但上个月，该公司的日活跃用户已达 3500 万。然而，Gemini 仍然落后于业界最受欢迎的人工智能工具。&lt;/p&gt; 
&lt;p&gt;谷歌在法庭上展示的数据显示，该公司估计 ChatGPT 在 3 月份的月活跃用户约为 6 亿。这使得 ChatGPT 的用户群与 Meta AI 相当。Meta AI 首席执行官马克·扎克伯格在 9 月份表示，其月活跃用户已接近 5 亿。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346312/google-gemini-has-350m-monthly-users-reveals-court-hearing</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346312/google-gemini-has-350m-monthly-users-reveals-court-hearing</guid>
            <pubDate>Mon, 14 Apr 2025 03:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>循序渐进搭建复杂 B 端系统整洁架构</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：京东零售，赵嘉铎&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;：信息时代技术更迭和传播速度不断加快，技术变得泛娱乐化，大数据、云计算、区块链、元宇宙、大模型，一代代技术热点在社会舆论的裹挟之下不断地吸引着资本的眼球，技术人员为了不被时代所淘汰也不得不时刻追赶潮流。在这样一个时代背景下，软件工程作为一门不起眼到有些枯燥的古老学科，似乎早已被开发者们遗忘在角落。作为一名技术人员我们自然应该时刻保持对前沿技术的追踪，然而，当发生线上问题我们却面对着成片的屎山代码毫无头绪时；当业务方提出个性化需求我们却因为不敢对系统做出修改而强迫对方做出妥协时；当一次请求处理流程中出现多达数万次重复地数据库操作而影响到整个系统的稳定性时，大家都应该沉下心来思考一下，我们是不是忘记了作为一名程序员的初心和对代码的极致追求。 还记的当年我抱着朝圣的心态从传统行业踏入京东职场时的兴奋与期待，然而这份期待很快就被四处可见的屎山代码给浇灭了，后来从朋友口中了解到其他头部互联网厂商的业务系统其实也是半斤八两。这似乎是软件行业中的一个电车难题，一边是无尽的业务需求和倒排的工期，一边是补丁摞补丁的糟糕代码，是继续泡在酱缸中缝缝补补还是向屎山代码说不，开发人员被困在中间不知该如何抉择。然而事实上，追求整洁架构与提升研发效率之间从来就不是一个悖论。正如 Robert C.Martin 在其著作《Clean Architecture》中所说：「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不管你多敬业、加多少班，（在面对烂系统时）你仍然会寸步难行，因为你大部分的精力是在应对混乱（而不是在开发需求）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。」造成我们整日加班赶需求和疲于应对线上问题的根本原因，恰是那些不被我们重视的糟糕代码。业务天然就是复杂的，这决定了软件系统的本质复杂度（Essential Complexity），这种复杂度是无法通过软件架构去消除的。那么解决上述问题的关键就是找到某种架构去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引导开发者对复杂业务进行问题拆解，分而治之，在这个基础上再通过标准规约和工具约束及辅助开发者写出可理解、易拓展、好维护的代码，以此来对抗软件系统本身的偶然复杂度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;（Accidental Complexity，Frederick P.Brooks,Jr, 《The Mythical Man-Month》）。 为了找到这样的一种架构，我们从 19 年就开始对各类架构思想和实践案例进行了深入地学习和探索，并在接下来的 3 年时间里通过局部架构演进的方式进行了大量的实践验证，在这个过程中我们对这些架构思想的理解也从早期的懵懂教条式执行逐渐做到了如今的融汇贯通，并最终在 22 年底形成了一套成体系的框架及方法论，并在京东广告投放平台重构工作中进行了实战应用。本文也将以广告投放平台架构升级作为背景案例，从设计思想到落地框架，循序渐进地为您介绍这套新架构的诞生始末，而这套架构思想的演进历程则在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxingyun.jd.com%2Fshendeng%2Farticle%2Fdetail%2F25548%3FforumId%3D43%26jdme_router%3Djdme%253A%252F%252Fweb%252F202206081297%253Furl%253Dhttp%253A%252F%252Fsd.jd.com%252Farticle%252F25548&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《改进我们的架构》&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;一文中有详细的阐述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一、架构升级背景&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;与高并发请求给 C 端系统带来的系统高性能、高可用能力挑战相比，B 端系统所面临的挑战则是如何在海量多维度、多模块、多场景融合的复杂业务需求中保持系统健康、稳定、快速地迭代。京东广告投放平台就是一个典型的复杂 B 端业务系统，它承担着集成广告业务体系中各个垂直业务模块，构建、维护和分发广告物料的重要职责。经过多年迭代，京东广告投放系统目前已集成 40 余个垂直业务系统，支撑 7 条核心产品线，先后赋能 10 余个独立投放平台，维护着一个拥有 200 余个业务实体的庞大数据模型，每天都需要处理海量长事务、多系统交互的复杂业务请求。同时作为整个广告业务链路上的首发环节和功能门面，广告投放系统每年都要承接 400 余个来自不同业务方的差异化需求、执行 1000 余次代码合并及 600 余次功能发布。在极高的需求密度之下，作为撬动广告主预算的重要战场，投放系统在为广告主提供优秀投放体验的同时，还需要每天向广告业务链路稳定输送 PB 级的物料数据，这对系统的性能、稳定性以及团队的研发效能提出了极高的要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//410eb3a6f0c1a4c961386a9242184754.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;广告投放平台是一个典型的多平台、多模块集成的复杂 B 端系统&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;二、传统架构的研发痛点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;近年来随着技术和业务的飞速发展，新的广告业务形态和投放组件层出不穷，广告物料结构愈发复杂。与此同时，为了提高广告主留存和撬动预算，业界各大平台都在向着极简版、智能化和集成化的方向发展。这些新的业态发展方向一方面给广告主带来了更加便捷和流畅的投放体验，另一方面也让投放系统内部业务流程愈发复杂，如何用有限的研发人力快速支撑越来越多的多场景复杂业务需求成为各大广告投放平台必须要解决的关键问题。然而传统的「三层架构+面向数据库编程」的研发模式由于过于简单的封装及粗暴的设计思想在面对这些高复杂度业务需求时变得愈发吃力，逐渐成为阻塞研发效能提升的罪魁祸首。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;客观：传统架构面对高复杂度的业务时毫无应对之法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作为一个典型的 Web 应用，广告投放系统长期以来采用的都是传统的三层架构，这种没有架构的架构极其简单、易上手，因此一直以来都是业界的主流。但是由于它缺少统一明确的逻辑拆分与封装工具，业务的复杂度会等比渗透到代码实现中，进而导致系统的代码复杂度飙升，模块之间随意耦合，逻辑纠结缠绕，经过几轮迭代之后就成了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;看不懂、动不了、不敢动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的酱缸代码。这些看似基础的编码问题实际上却是阻碍我们研发效能提升的罪魁祸首：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需求交付提速困难&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：不同平台、产品线及业务场景逻辑交织，晦涩难懂，导致系统功能迭代时梳理及设计耗时漫长，同时在测试阶段需投入大量精力进行联动功能回归；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;对新业态的接受度低、响应能力差&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：系统拓展性差，且模块间深度耦合，在面对新业态时我们却为了控制影响范围而不得让业务选择让步，结果错失商机。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题评估和排查效率低下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;缺少明确统一的逻辑归属与封装准则，逻辑四处复写与逃逸，导致问题定位时间长，难以快速评估影响范围和修复方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;4.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接口性能与稳定性下降：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;混乱的封装与复用导致一次接口请求就会产生导致大量重复的 IO 操作，严重影响接口性能，每临大促都需要花费大量人力进行性能优化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;主观：「面向数据库编程」的设计思维让系统加速腐化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们的业务本质就是获取、处理、存储及传输数据，在传统架构中业务逻辑通常以事务脚本（Transaction Script）的形式实现：业务规则直接在开发者的大脑中转化为数据库的增删改查操作（这也是很多程序员调侃自己是 CRUD 工程师的原因），然后被写到代码里。这种模式在场景单一、需求简单的业务发展早期阶段可以快速实现功能，但是随着业务复杂度的提升，这种过于粗糙的设计思维所带来的问题就会逐渐显现出来：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;难以建立对整个数据模型的全景认知&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：完整的数据模型信息被拆分到不同的业务接口实现中，往往需要对整个工程代码进行逐行 review 才能梳理出完整的数据模型，当工程代码量和数据模型膨胀到一定程度后，模型梳理成本急剧飙升。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模型野蛮膨胀、存在大量相似或重复的实体，增加系统运维成本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：数据模型全景认知的缺失导致开发者难以进行统一的顶层设计，数据模型泛化表达能力弱，在多需求并行开发过程中极易形成信息孤岛，无法实现模型合并与共享，系统中存在大量相似的业务实体与库表结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码对业务语义表达能力弱、业务知识传承效率低下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：代码经过开发者的转译失去了对业务语义的直接表达，导致系统中存在大量只有开发者本人才能理解的魔法逻辑，系统维护与人员更迭成本过高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要想解决上述问题，就亟需一种面向未来的架构思想来指导我们对系统进行全面地升级。在此背景下，业界众多平台纷纷进行了领域驱动设计思想的探索和尝试，经典的案例有阿里的星环与 COLA、快手的 Baldr 等，京东也推出了藏经阁平台与 Matrix 框架。这些实践案例和架构迭代路线给了我们很多启发，本着脚踏实地、事实就是的基本原则，在经过充分调研和长期验证之后，我们立足于京东广告业务的本质特征推出了一套可复用的复杂 B 端业务支撑框架，其核心内容可以分为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PICASO 能力编排框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;与&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合及资源库机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;两部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;网络上能够找到很多介绍领域驱动设计思想的文章，但是大多都聚焦在对领域驱动设计中众多术语和概念的介绍上，对领域驱动设计思想的落地实践却浅尝辄止。再加上中英文语境的差异和国内外软件开发生态的不同，都在很大程度上将领域驱动设计思想「妖魔化」了，让很多同学望而却步或者不得其要义。然而我们在摸索实践的过程中逐渐意识到，领域驱动设计作为一种软件架构设计的指导思想其实并没有创造什么新的东西，而是对基本的软件设计思想进行的系统化总结和升华。但正是这种系统性的归纳将各类技巧、准则和思想凝练成体系化的方法论，并且在行业内形成了被所有开发者所公认的行为准则，这才是领域驱动设计思想强大生产力的源泉和魅力所在。 与传统的三层架构相比领域驱动设计思想其实并没有复杂多少，其要义就在于保持业务、模型与代码三者的统一，只要掌握了这一点，领域驱动设计思想中的各种理念都将是水到渠成的事情。初读《领域驱动设计》时书中众多晦涩的术语也曾让我十分困惑，但其中的很多内容其实已经是很多优秀架构师的工作日常了。随着对领域驱动设计思想理解的逐渐深入，我不时会产生「咳，这说的不就是 xxx 么」的感慨。这也是没有办法事，谁让国外那些提前入局的大佬们牢牢掌握着专业领域的命名权呢。也正因为如此，在本文中我们不会去介绍、甚至会尽量避免引用领域驱动设计理论中的术语，避免大家一开始就陷入到那些晦涩难懂的概念里而无法自拔。希望大家能将更多的精力放在框架内各个模块的设计动机与运行机制上，这才是我们最应该思考和关注的内容。至于领域驱动设计思想在新架构演进过程中的指导作用我们将会在《领域驱动设计与 PICASO 框架》一文中进行详细地介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_5&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三、升级措施&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（一）PICASO 框架：从混乱到有序，构建图书馆式的代码架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;图灵奖得主 Frederick 在其著作《The Mythical Man-Month》中将软件系统的复杂度划分为本质复杂度（Essential Complexity）和偶然复杂度（Accidental Complexity），其中本质复杂度是问题本身所具有的复杂度，与求解方法无关，而偶然复杂度是求解方法引入的复杂度。本质复杂度无法避免，但是我们可以通过优化求解方法来尽可能降低系统的偶然复杂度。这给了我们很大的启发，业务天然就是复杂的，这是一个客观事实，架构设计的目标&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不是消除业务上的本质复杂度，而是应该引导和辅助开发者更好的拆解和分析业务带来的复杂度（是 handle 而不是 eliminate）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;同时，软件架构应该提供足够灵活的标准规约与框架工具，让所有开发者都能够按照统一的思想写出可理解、易拓展和好维护的代码，减少甚至是消除由于没有封装或封装不统一带来的偶然复杂度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。在这一思想的指导之下，经过两年多的打磨，我们推出了 PICASO 框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 概述&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 是一套以领域驱动设计（Domain-Driven Design, DDD）作为思想内核，专门为集成式复杂业务系统设计的通用基础框架。它的命名来自「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ICASO &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;s a &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;C&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ontextual &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;A&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;bility &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;S&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;eparate and &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;O&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;rchestrate Framework（PICASO 是一种基于上下文的能力分解与编排框架）」的首字母缩写。有趣的是这个缩略词的发音恰好与西班牙现代派绘画大师毕加索（Picasso）的姓名读音相同，毕加索在画作中经常对人体部位进行解构和重组，在接下来的介绍中我们将发现这一点与 PICASO 框架所强调的能力拆分与编排思想有异曲同工之妙，而这也是我们最终采纳这个命名的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的命名启发自笔者比较喜爱的一个开源项目——WINE，其功能是通过内核适配器在 Linux 环境中运行 Windows 应用程序，其命名也是这种藏头诗的风格：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;W&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;INE &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;s &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;N&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;ot &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;E&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;umlator（WINE 不是模拟器）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架的职责是引导开发者将复杂业务流程正交分解为多个简单子问题，然后将这些简单子问题的处理逻辑封装为边界明确的标准可执行实体，在 PICASO 框架中这些可执行实体被称为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。完成能力拆解之后，开发者可以通过 PICASO 提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力编排框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;将不同的领域能力的组合成一个完整的请求处理流程，这个处理流程所在的可执行实体就是一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。领域服务会为每次请求生成一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对象，通过这个上下文对象可以在不同领域能力以及领域能力与领域服务之间进行数据传递与共享，进而避免重复及碎片化的 IO 操作。PICASO 框架还提供了开箱即用的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通用可执行实体发现与路由组件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，开发者可以通过该组件按功能域对领域能力及领域服务进行分组和聚合，每个分组对外暴露统一的请求路由门面，从而向上层调用实体屏蔽分组内部的场景复杂度，进而实现复杂度降维。如果在领域能力或领域服务的路由维度之外还存在其他维度的细微逻辑差异，开发者可以通过 PICASO 提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拓展点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;机制进一步实现差异点分离。同样的，拓展点依然可以接入通用可执行实体发现及路由组件，向上层实体屏蔽拓展点所在功能域内的场景复杂度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上文对 PICASO 框架的整体架构进行了整体地介绍，接下来我们将从软件系统复杂度根源分析开始，循序渐进地详细阐述 PICASO 各个模块的设计动机及运行机制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//4b633e93ce342520a42a00636c7d38fd.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;PICASO 框架整体架构&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_8&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;复杂度的根源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;软件设计的本质就是持续对抗软件本身产生的复杂度，早在最开始进行新架构探索的时候我们就意识到，构建整洁架构的前提是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#ff4d4f&quot;&gt;厘清系统复杂度的根源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_9&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本质复杂度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过对复杂业务系统发展历程的分析，我们发现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;业务复杂度一般来自水平方向上的多维度拓展和垂直方向上的多模块集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;业务发展的早期往往都是单一场景，随着业务的发展，产品形态开始变得丰富多样，服务的用户及业务方也越来越多，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;业务架构从原来的单点结构逐渐演变为复杂的树状结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，树的每一层都代表一个业务维度，业务的发展让系统在水平方向上呈现出多维度增长的特征。以广告投放系统为例，最初的投放系统只有合约展示包段一种业务形态，随着程序化广告和智能广告的兴起，广告投放及播放形式层出不穷，业务树中开始出现「产品线」的维度；而为了服务不同业务方，我们在系统中增加了「投放平台」的维度；对不同投放标的物的支持又在系统中引入了「计划类型」的维度......就这样广告投放系统的业务架构也逐渐演变成了如下图所示的复杂树状结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6b86ee6915b53b63cf4d611d4d061243.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;多维度、多模块、多场景的广告投放业务&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而在垂直方向上，早期的业务流程一般比较简短，只有少数几个业务环节。随着业务的发展，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;系统功能越来越丰富，业务流程也变得愈发冗长，开始呈现出鲜明的模块化特征&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。同样以广告投放系统为例，早期的广告物料只有时段、预算、出价、创意几个基础模块，随着业务的发展陆续新增了智能出价、人群定向、地域定向、商品定向、智能创意、智能选品等业务模块，物料创编流程也越来越冗长。除此之外，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;单个模块内部也开始出现多场景分化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如广告投放系统中的智能出价模块内部就存在 tCPA、tROI、eCPC、MC 等不同的智能出价模型，其数据模型及业务规则也不尽相同，这进一步增加了业务的复杂度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本小节从业务架构演进历程的视角分析了业务复杂度的来源，这构成了系统的本质复杂度。而对这些复杂业务规则的实现方案（好的、或者是坏的）就成了系统偶然复杂度的来源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_10&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;偶然复杂度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;业务在多个维度上向着熵增的方向不断发展，但是我们的代码始终只有一套，不同维度的业务场景可能对同一个业务环节提出不同的个性化需求，造成不同维度的业务逻辑互相耦合，代码中开始出现大量层层嵌套的 if-else 分支，圈复杂度不断飙升，系统开始出现腐化迹象。此时一些工程师可能会意识到这个问题并开始着手优化，但是由于缺少统一的逻辑封装与拓展工具，再加上开发者的水平与技法也不尽相同，导致优化方案五花八门，这种方案上的不一致反而进一步增加了代码的复杂度。除此之外，随着系统集成的业务模块越来越多，业务流程愈发冗长，与外部子系统的交互逻辑越来越复杂，开发者不得不去处理超时、重试、幂等、长事务、分布式事务及跨系统的数据一致性等问题，这些技术方案的引入对系统来说也是复杂度的来源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对架构设计的启发&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从上面的论述中可以看出，系统偶然复杂度的高低在很大程度上取决于开发者能否分析处理好业务的本质复杂度，另外在多人协作开发场景中，软件架构的标准性和解决方案的一致性也是决定系统偶然复杂度的重要因素，这就是我们推出 PICASO 框架的根本原因。我们希望 PICASO 能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引导开发者对复杂业务流程进行模块化拆解，采用分治思想逐一击破，并通过标准的逻辑封装规约与框架来实现多维度逻辑拓展&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，让团队中每一位开发者都能够以统一的思想写出清晰、简洁、有序、可检索的代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;到这里相信有些读者可能会产生一些疑问，既然软件系统的偶然复杂度是技术方案本身的复杂度，那么引入 PICASO 框架是否也在增加系统的偶然复杂度呢？答案是肯定的，新框架的引入的确会增加系统的偶然复杂度。PICASO 框架由于采用了全新的设计思想，在推行早期曾经历过痛苦的磨合期，也出现过不少由于开发者不理解新架构的运行机制而导致的设计缺陷或线上问题。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;任何架构迭代之路都是螺旋上升的，新技术带来的系统复杂度毕竟是静态的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，随着开发人员对新架构运行机制及使用技巧的逐渐掌握，系统便开始趋于稳定，新技术带来的优化收益也会逐渐显现出来。但是如果我们不对现有的架构做出升级，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;那么系统将随着源源不断的业务需求向着不可控熵增的方向不断发展，由此带来的系统复杂度将是动态且持续增加的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的复杂度应对之道&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分析完系统的复杂度来源之后，接下来我们将详细介绍 PICASO 如何协助开发者对抗软件系统的复杂度。IEEE 对软件架构的定义为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;架构是由系统之间的组织、组件及组件之间的关系、以及对设计与演进的指导原则组成的，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其中前两者是具体的实体框架，后者是指导思想。而软件架构的指导思想往往决定着前两者的实现，对指导思想的理解与掌握程度也直接决定了开发者能否在实际业务中用好架构。以 Spring 框架为例，Spring 的指导思想为：控制反转（IoC）、依赖注入（DI）及面向切面编程（AOP），这三大核心思想一方面直接决定了 Spring 框架核心模块的实现，另一方面也是开发者要想用好 Spring 则必须掌握的内容。而对 PICASO 来说，其指导思想可以概括为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力拆分、拓展点抽象及能力编排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//967fe48ec6941c59ba38e12ebbeb95a3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;软件架构的构成&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_13&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域能力拆分与路由助力多模块集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;神经认知学家乔治·米勒在他的论文《神奇的数字 7》中指出人脑能够同时处理的信息容量是有限的，人脑的短时记忆容量为 7（7 个数字、6 个字母或 5 个单词），后来的研究更是将这个数字降到了 4 个左右。所以当冗长的业务流程叠加上多维度的个性化诉求，系统的业务复杂度将飙升为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;，这显然超出了我们大脑的瞬时处理容量，此时就需要利用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注点分离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;思想对复杂问题进行求解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;关注点分离&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;（Separation of concerns，SOC）就是把复杂问题正交分解为多个互不相关的最小子问题，聚焦整体问题的局部复杂性，逐步进行求解&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我们在《复杂度的根源》章节中指出，复杂的业务系统往往会呈现出鲜明的模块化特征，因此我们可以自然而然地根据业务模块的功能边界对冗长的业务流程进行拆分，然后聚焦单个模块进行设计与抽象，避免陷入多模块、多场景互相耦合的思维泥沼。PICASO 框架为此引入了领域能力及领域服务的概念，其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;用来承接单个业务模块内部的逻辑细节，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域服务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;则负责通过组合不同的领域能力实现一个完整的业务流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如下图所示，以单元新建流程为例，我们可以把单元新建流程划分为：单元基础信息构造、优化目标设置、出价设置、人群设置、地域定向设置和商品定向设置多个子模块，我们可以将这些模块内部逻辑封装成领域能力，然后通过这些能力的组合构建一个完整的单元信息领域服务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//0da69c0b57d00ace6c80601fdbe11a3e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;一个完整的业务流程可以拆分为多个原子业务模块，每个原子业务模块还可以按照其内部的业务模式进行进一步细分&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架中的领域服务与 DDD 思想中的领域服务是同一个概念，其职责和定位都是承接无法在单个实体与值对象内部直接实现的业务逻辑（事实上，B 端系统对外提供的大部分服务都无法在单个聚合内直接实现）。而领域能力的概念则经常出现在一些企业级中台化框架中，如阿里的星环、京东的 Matrix 等。尽管当年如火如荼的中台化战略如今已经偃旗息鼓，但是我们还是将这个命名引入到了 PICASO 中，因为我们确实没有找到一个比它更合适的命名，可以如此形象地描述一个足够内聚、自治且能够被复用和拓展的原子实体。当然 PICASO 中的领域能力与那些企业级中台化框架中的领域能力相比要轻量和易用的多，不需要繁琐的身份申请，也不存在跨工程热加载的问题，毕竟中台化的重心在管理域平台及前中台团队的协作上，而 PICASO 则始终聚焦在代码本身的复杂度控制上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;其实中台化也好，组件化也罢，系统的复杂度就摆在那里，不管用什么由头，要想提升团队整体的研发效能，它都是我们必须要去解决的一个问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt; 在本小节的论述中，领域能力似乎就是根据业务模块的边界简单划分出来的。但是在实际开发中的能力划分要复杂的多，需要综合考虑能力的应用场景、会被哪些领域服务使用、以及能力之间的依赖关系等诸多因素进行反复地推导和调整。本文对能力划分方法论只是简单地做了问题引入，更加具体的内容我们将在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳实践——能力识别与划分&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中进行详细介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域能力的拆解除了能够降低业务流程分析的复杂度之外，也提高了代码复用和拓展的灵活性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;领域能力就像积木一样，可以被组装到不同的领域服务中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如人群设置能力可以同时被单元新建服务、单元编辑服务、人群快捷修改等领域服务复用。而能力拆解带来的拓展灵活性性是相对于朴素模版设计模式而言的。在传统架构中模板类可能是我们使用最多的设计模式，它的确能够简单有效地实现复用共性流程、分离差异的目标。但是由于复杂业务流程中不同业务节点的差异化维度往往是不同的，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;直接将业务主流程抽象成一个模板类，将各个节点作为模板中的抽象方法，那么该模板类子类的继承关系复杂度将是各个业务节点内部场景复杂度的叉乘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。再加上传统架构并没有积极引导开发者落实面向对象编程的思想，导致我们基本上还在以面向过程的方式开发我们的系统，通常会将同一个产品线中不同的业务方法实现到同一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Service&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Manager&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;类中，这将进一步加重模板抽象及子类继承关系的复杂度。而 PICASO 框架通过领域能力拆解将不同的业务环节拆分到了单独的原子业务实体中，将模板中的抽象方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算子化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;由于不同的原子业务模块之间互相正交、互不干扰，因此能够让这些业务算子独立迭代，在各自的业务维度上灵活地进行继承和拓展&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;只是把业务流程按照功能边界拆分成不同的模块通常是不够的，因为单个模块内部往往还存在细分的业务模式，如上图中的出价设置模块，其内部还存在手动、MC、tCPA、eCPC 等不同的出价模型，这个时候就需要根据分类思想进行进一步拆解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;分类思想&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;是关注点分离思想进一步的延伸，它在分离的同时还注重元素之间的共性特征&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。当模块内部出现场景分化时，PICASO 框架建议开发者对模块进行进一步细分，将模块内不同场景的业务规则封装为不同的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这些能力实例之间尽管存在逻辑差异，但是毕竟属于同一个原子业务模块，在数据模型、接口协议乃至业务流程上都存在很大的相似度。因此 PICASO 会将同模块下不同业务场景对应的领域能力实例聚合到一起，这样的一组能力被称为一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。同一个能力节点下的各个能力实例使用相同的接口参数及上下文定义，每个能力节点下会额外定义一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力门面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能力门面通常不承载具体的业务规则，它仅负责定义当前能力节点对外的接口协议以及从请求参数中提取业务场景标识的逻辑，它是能力节点下所有能力实例对外提供服务的统一入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。上层的领域服务组合领域能力时，引用的不是具体的领域能力实例，而是各个能力节点下的能力门面。PICASO 框架内置的可执行实体发现与路由机制会在应用启动时扫描出系统中所有的能力门面，并建立好能力门面与各个能力实例的路由表。当请求到来时，领域服务不必关注本次请求应该使用哪个具体的能力实例，而是直接调用能力门面的统一入口，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;PICASO 框架会通过内置的可执行实体发现与路由机制提取请求中的场景标识，然后将请求路由到对应的领域能力实例上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，从而实现模块内部的场景复杂度与领域服务模块集成复杂度之间的解耦。以出价模块为例，出价模块内部会根据不同的出价类型细分为 tCPA、MC、eCPC 等智能出价能力实例，但是单元新建领域服务并不会直接操作这些具体的能力实例，它引用是出价设置能力门面。当请求到来时，PICASO 框架会根据请求中的出价类型自动将请求路由到相应的能力实例上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可执行实体发现与路由机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是 PICASO 框架内置的一个底层通用组件，是能力编排、拓展点机制等顶层功能的基础。其本质上就是一个增强型的门面+策略模式，我们通过一些实现技巧将其做成了一个可以适配任意可执行实体的通用组件。如下图所示，单元新建业务流程涉及标的物设置、出价设置及人群设置等业务环节，这些业务环节内部都有各自的细分场景。在代码实现中，这些业务环节被抽象为 3 个能力节点，节点内部的细分场景被隔离到不同的能力实例中，在构建领域服务时就不需要考虑当前各个能力节点下的细分逻辑，只需要专注于业务流程本身，实现各个能力门面的组装逻辑即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6fc68de875eec1a26e3e8417cabcd5dc.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;能力门面与能力实例的抽象实现了能力编排复杂度的降维&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;分层&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;则是分类思想在领域服务、拓展点等其他实体粒度上的延伸&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如快车、互动、推荐三条产品线的单元新建服务会被划分到同一个服务分组下，对外暴露一个单元新建服务门面。这样做目的是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;下层实体对上层实体暴露统一的门面接口，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自下而上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;地逐层屏蔽下层实体的内部复杂度，实现维度间复杂度解耦，进而将代码的整体复杂度由&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;降维到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span&gt;&lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;。下图展示了 PICASO 框架中各个业务实体的层级结构，最下层是各个领域能力实例执行器，它们承载了具体的业务规则；相同功能子域的领域能力实例会对上层的领域服务实例暴露一个统一的领域能力门面执行器，领域服务实例执行器会通过组合领域能力门面定义具体的业务流程；而相同的功能子域的领域服务实例又会对领域服务统一入口（Domain Service Faced）暴露一个领域服务门面执行器，屏蔽模块内领域服务实例之间的细分规则；领域服务统一入口将不同的领域服务门面集成到一起，对上层不同的流量来源暴露统一的请求入口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;这种分层结构让开发者逐层解构业务复杂度的同时，实际上也构造了一个索引结构，为实现可检索的代码架构打下基础。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//f13cba0ebb1ba5e6a7309d9ef247b2db.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;自下而上逐层屏蔽层级内部的业务场景复杂度&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分层架构中，除了可以通过通用可执行实体路由机制自下而上地屏蔽下层实体的内部场景复杂度之外，有时我们还要反过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;来自上而下地进行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;复杂度合并&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我们用一个例子来说明这种设计技巧：在广告投放业务中有一个经典的出价计算器模块，它会根据广告物料上的基础出价、人群溢价、关键词出价、流量包溢价、时段溢价等信息预估广告物料最终的出价值范围。计算逻辑只有一个，但是由于计算逻辑关联了众多底层模块，物料新建、修改以及关联模块的快捷修改、还有对物料进行修改过程中实时出价预估回显（此时最新的修改并未落库）等接口都会调用出价计算器模块，但是这些使用场景对出价预估参数的填充程度是不同的，需要模块针对不同的使用场景执行不同的参数补充查询逻辑。这是一个典型的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;上层模块的调用场景复杂度渗透到底层模块实现复杂度中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的例子。在分层架构中，越是底层的模块在设计上需要考虑的场景应该越少，而且要避免与上层模块的使用场景耦合。因为上层模块的使用场景是动态增加的，不知道什么时候就会有新的使用场景出现，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;底层模块的真正需要处理的内部场景应该比顶层使用该模块的场景要少且稳定的多。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以解决这个问题的措施就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;底层模块面向自己内部的业务模式在参数中定义一个隐式的标识属性，让调用方根据自己的使用场景和业务诉求隐式地设置该参数，底层模块则直接根据参数中的这个标识属性执行相应的分支逻辑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。回到出价计算器的案例中，该模块的使用场景有：单元新建后事件触发、单元整体修改后事件触发、单元新增关键词后事件触发、单元新建中临时触发、单元修改中临时触发、单元添加关键词中临时触发等多种使用场景，未来也不确定会出现什么新的使用场景。但是对出价计算器模块的内部计算逻辑来说，其实只有需要补充查询单元下关键词信息和不补充查询这两种场景。为此我们在出价计算器能力参数中增加一个布尔类型的参数，能力内部直接根据该参数判断是否需要执行关键词的查询操作，出价计算器模块的调用方则分别根据自己的使用场景判断该如何设置这个参数，从而起到自上而下的合并上层调用场景复杂度、保持底层模块稳定的作用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;有些读者或许会觉得这种机制与上文介绍的能力路由机制是互相矛盾的，然而他们实际上并不冲突。因为对那些能够自下而上屏蔽内部场景复杂度的模块而言，它们通常显式地定义了内部不同业务模式的标识属性，如出价模块的出价类型、人群定向模块的人群类型等，用户在请求参数中也会显式地设置请本次请求对应的业务标识，因此框架能够直接对这些模块应用通用可执行实体路由机制。但是实际业务中也存在一些模块，它们内部没有定义明确的业务模式标识，而是根据请求来源、调用场景等动态条件执行不同的业务逻辑。此时我们可以先暂时忘掉这些模块的调用场景，而是聚焦模块内部的业务分支提炼出隐藏其中的业务模式，然后让上层模块将动态调用场景转化为底层模块定义的隐式业务模式标识参数，接下来就能继续应用通用可执行实体路由机制了。因此，分层思想中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;自下而上屏蔽的是模块内部的固有场景复杂度，而自上而下合并的则是模块外部的使用场景复杂度，二者其实是互补的关系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_14&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展点机制协助走出多维度泥潭&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务与领域能力的路由机制能够较好的应对系统多模块集成带来的复杂度，但是领域能力及领域服务必须严格遵守框架规约，继承标准业务执行器模版（后续章节会有详细讲解），定义出明确的数据交换协议及上下文对象，这些都是相对较重的操作。因此能力或服务路由的维度必须抓住最核心的业务差异，而不是把所有存在业务差异的维度都纳入到路由规则中，否则就会造成沙粒化拆分，反而增加系统的维护成本。因此我们还需要一种机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能够以更加轻量的方式承载除了领域服务或能力路由维度之外其他业务维度上的细微差异&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;拓展点机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要解决的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;拓展点机制&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;是通用可执行实体发现与路由机制在更细粒度上的延伸应用，本质上就是将存在差异化逻辑的环节抽象为一个接口从主流程中分离出去，然后将不同场景的差异化逻辑隔离在不同的拓展点接口实现中，这其实就是依赖倒转原则（Dependence Inversion Principle, DIP）的应用&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。与领域服务和领域能力相比，拓展点的定义和实现成本都要低很多，框架对拓展点接口内的方法及方法参数都不会做过多的约束，定义一个拓展点仅需要继承框架提供的标准接口并指定路由标识的提取逻辑，而实现一个拓展点接口时也仅需要在实现拓展逻辑之外额外指定当前拓展点实例能适配哪些路由标识。拓展点可以嵌入到领域服务、领域能力以及资源库（Repository，下文中会详细阐述）中任何一处存在差异化逻辑的流程中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展点机制作为能力与服务拆分路由机制的补充，支持任意维度上的差异化逻辑隔离。以下图为例，在广告投放系统中，底层的人群设置能力节点已经按照其核心属性人群类型进行了能力实例的划分。由于系统还赋能了多个投放平台，不同的投放平台对可绑定的人群上限有着不同的限制，此时就可以将各个能力实例中人群绑定数量校验环节抽象为一个拓展点接口，以投放平台类型作为路由 KEY 为各个投放平台提供不同的接口实现，从而自上而下地解决多维度拓展的难题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;这里说的「自上而下」是一种形象的描述，可以理解为父层级业务维度内不同的业务场景在子层级模块上产生的差异化逻辑。但实际上拓展点机制并不限制逻辑的维度拓展方向，如下图的例子中，右侧触点新建服务领域服务实例所属的服务门面定义的服务路由维度是产品线，但是不同的计划类型的单元新建流程之间依然存在细微的逻辑差异，此时尽管计划类型是产品线的子维度，但是依然可以通过拓展点来承载这些细微的逻辑差异。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//701162304b0dcc5acf2dcd3734071b08.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;拓展点机制的核心作用是作为能力及服务路由维度的补充，进一步实现差异点的分离&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_15&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排框架确保架构思想切实落地&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前面几个小节一直在论述如何对复杂逻辑进行拆解和分离，但是系统要想对外提供可用的功能，就必须再次把这些分离出来的能力及拓展点组合起来，构成一个完整的领域服务。最简单的组合方式就是直接硬编码依次调用各个能力门面的功能入口，手动实现前置方法调用结果与后置方法入参的属性映射和转换，但是这种组合方式会在业务主流程中插入大量的胶水代码，稀释代码的信息密度，将流程关键节点掩盖在大量繁琐无趣的`setter`、`gettter`方法调用中。为了解决这个问题，同时确保新架构设计思想能够精准落地，让规范和标准框架化，PICASO 自建了能力编排框架，它为前文所述的各类思想落地提供了框架基础，将前文提到的各种实体、组件与设计思想有机结合到一起，自动实现模块串联，让开发者专注于业务逻辑本身，实现填空式开发，最终构建出一个完整的工程应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前业界有很多流程编排引擎，有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;老牌厂商的 Netflix Conductor、AWS Step Function 等，也有开源的 Apache Activiti、Zeebe&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等。我们在早期架构探索阶段对这些解决方案也进行了调研和试用，但是发现它们都无法满足我们的诉求：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以轻量级的方式实现模块组合，提高模块与组件的复用性，同时凸出呈现核心业务流程，辅助开发者快速抓住业务主线并建立对业务的全景认知&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这很大程度上是由于上述开源组件的定位大都是接口级别的服务编排或者是审批流之类的流程引擎，因此其实现方案或执行成本往往较重，很多流程编排框架过分强调通过 UI 框架拖拽式实构建业务流程，导致开发者需要先在代码工程中实现业务组件，再到 UI 界面中构建串联流程，适用的场景有限且造成强烈的割裂感不说，开发者依然需要手动配置组件之间的参数映射与数据传递逻辑，而脱离了开发工具的代码提示与补全功能，这些逻辑的实现成本反而增大了。与这些问题相比，拖拽式的 UI 界面虽然炫酷，但并不是我们的核心诉求。还有一些编排框架采用了中心化的部署方式，流程串联与组件服务分离部部署，通过 RPC 实现组件调用，这种方式会付出巨大的网络开销及中间结果存储成本。这种设计让它们在批处理任务场景中有较好的应用，但是在交互式服务应用场景中则会造成严重的性能问题并付出巨大的运行成本。因此，在经过一次次尝试之后我们最终决定举起自研大旗，开发一套与 PICASO 架构基本思想相适配的能力编排框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//14e6e125dc26e81dd70da55f5962aa61.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要想满足我们在上文中提出的能力编排相关的诉求，能力编排框架需要提供两个基本功能：分别是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在编码阶段通过简洁、直观、易用的 API 辅助开发者定义业务流程，以及在请求处理阶段根据开发者制定的执行图串联各个业务组件完成请求处理流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。为了实现这两个基本功能，PICASO 框架采取了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;制定标准化业务执行模版&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;内嵌标准上下文机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;自建能力编排框架三项举措&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;标准业务执行器模版&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;标准业务执行器模版&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;立足于软件系统的内在本质定义了适用任何业务场景的基本处理流程&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，就像&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对象在 JDK 中的作用一样，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;标准业务执行器模版并不复杂，但它却是 PICASO 框架中所有组件功能得以实现的基础&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。从本质上看，所有的软件系统都在做三件事：数据的获取、处理与存储（或传输）；从业务视角看，数据的处理又可细分为输入数据的合法性校验以及数据的计算与转换，而数据的合法性校验又可细分为对输入数据直接进行的校验以及需要结合系统内外部详情数据进行的校验。基于上述论述，PICASO 框架定义的业务处理的基本流程为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参数预校验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：直接对请求入参进行的校验，这些校验逻辑通常都是简单的内存计算，不依赖任何外部数据，如参数完整性校验、参数值范围校验、数据长度校验等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上下文初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基于校验后的入参查询数据详情并填充到上下文中，如根据入参中的单元 ID 查询单元详情、根据 userId 获取账户详情等，这些数据将会在后续流程中使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基于上下文的业务校验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：执行需要结合上下文中详情数据才能进行的业务校验，如根据单元状态判断是否可以执行物料的修改操作、判断标的物类型与物料计划类型是否匹配等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;4.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务逻辑处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基于参数及上下文中的详情数据执行领域模型（下一章节介绍）的构造和修改，注意对于一些查询类的服务，这个步骤可能不是必须的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;5.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据持久化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：将新建或修改后的领域模型保存到数据库中或者调用外部服务 API 完成数据传递，这同样是一个可选的标准步骤，另外有些服务在业务逻辑处理环节就已经完成了数据传递。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;6.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;发布领域事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：一些修改类的领域服务在完成请求处理之后可能需要通知其他领域内的业务实体做一些相关的后置操作，PICASO 框架是通过领域事件机制来实现这个功能的（后续章节中进行详细介绍）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;7.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;构造处理结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：业务流程执行完成后构建返回给调用方的响应数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;标准业务执行器模版本质上就是一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模板类，上述基本业务流程也就是该模板类中主要的模板方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在 PICASO 框架中，领域服务和领域能力都要继承标准业务执行器模板类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这样做的目的是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引导和约束开发者对领域服务和领域能力的具体实现逻辑按照标准业务执行流程进行二次拆分，从而可以让框架对代码进行精细化地调用控制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。标准业务执行模版是对所有业务处理流程进行的最顶层抽象，模版类中各个标准业务执行步骤 API 的制定让把不同业务模块的串联执行职责从开发者手中转义到框架手中成为可能，开发者不必手动实现不同模块和方法的串联调用，而是专注于业务逻辑，实现填空式开发，从而减少系统中的胶水代码，提高信息密度，这本质上就是依赖倒转原则（Dependency Inversion Principle, DI）的应用。下面的代码片段给出了标准业务执行器模版的定义，出于突出呈现 PICASO 框架设计思想的目的，示例代码去除了框架功能的具体实现逻辑，仅保留了核心要素及模版方法的定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/**
 * 标准业务执行器模板基类，定义了基本的业务处理流程，所有领域服务和领域能力执行器都必须继承该类。 
 *
 * @param &amp;lt;C&amp;gt;   业务执行器对应的参数类型，所有的执行器参数都应该继承自标准参数基类 Command 对象
 * @param &amp;lt;T&amp;gt;   业务执行器最终返回的执行结果类型
 * @param &amp;lt;CTX&amp;gt; 业务执行器使用的上下文对象类型，所有执行器的上下文对象都应该继承标准上下文基类，
 *              请求的入参和产生的中间结果都会保存在上下文对象中
 */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CommandExecutor&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;C extends Command, T, CTX extends ExecutorContext&amp;lt;C, T&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 参数预校验，该步骤应该只进行纯内存计算操作
     * @param context 上下文，此时的上下文中只有参数对象
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPreValidate&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 执行上下文初始化，根据参数执底层情数据的拓展查询，并将查询结果填充到 context 对象中
     * @param context 上下文，调用该方法时的上下文中只有参数对象，调用完成后上下文将被填充
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doInitContext&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 结合上下文中的底层数据执行业务校验
     * @param context 上下文，此时的上下文中已经完成了依赖的业务详情数据的填充
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doContextualValidate&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 结合上下文中的底层数据执行业务逻辑的处理，对已有实体的变更及生成的新业务实体都会填充回上下文对象中
     * @param context 上下文，业务逻辑执行过程中的中间结果也可以暂存到到该上下文中
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doProcessBizLogic&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 保存业务流程执行过程中新建或者被修改过的业务实体，调用该方法时，这些数据已经被写入到了上下文对象中
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPersistAggregates&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 构造本次业务请求流程中需要对外发布的领域事件
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;Collection&amp;lt;RetryableEvent&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPublishAppEvent&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 构造请求的返回值
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doAssembleResponse&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到这里有些读者可能还没有意识到「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;把不同业务模块的串联调用职责从开发者手中转移到框架手中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」的价值，这项措施其实并没有直接解决我们在本文第二章提出任何一个痛点问题，要想理解这一措施我们必须用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;辩证法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;重新审视前文介绍的各项复杂度应对措施。根据前面几个小节的论述，我们为了应对业务复杂度而对请求处理流程进行了各种粒度和场景的拆分，拆分出来的各类实体再叠加上实体内部标准执行步骤的二次拆解，必然会增加后续逻辑串联和组装的复杂度。如果此时还要求开发者手动硬编码实现逻辑组装，那么势必会带来极高的开发负担和出错概率，而且硬编码组装带来的大量胶水代码还会稀释和掩盖代码中的关键信息，后续再进行迭代时就容易产生改动点遗漏和影响评估不全等问题。PICASO 框架解决这些问题的措施就是由框架代替开发者实现合个模块的串联组装，这也我们要定义标准业务执行器模版的根本原因：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;统一标准的调用入口是让框架实现流程串联的前提，进而才可能实现将胶水代码隐藏在框架内部、提高业务层代码信息密度、降低开发者编码负担的设计目标&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。PICASO 框架内模块串联的详细逻辑我们将在本章后三个小节中进行阐述，在那之前我们先继续介绍标准业务模版中的其他核心要素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上下文机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从标准业务执行模版的示例代码中我们可以看到，除了各个标准步骤的方法声明之外，标准业务执行模版还通过泛型变量定义了执行器接收的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;请求参数类型、返回值类型以及上下文对象类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，其中「上下文」是标准业务执行器模版中的核心要素，业务数据就是通过它在各个标准步骤之间流转的。所谓的上下文本质上就是一个 POJO（Plain Old Java Object），其内部定义了业务流程执行所需要的各种详情数据。在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxingyun.jd.com%2Fshendeng%2Farticle%2Fdetail%2F25548%3FforumId%3D43%26jdme_router%3Djdme%253A%252F%252Fweb%252F202206081297%253Furl%253Dhttp%253A%252F%252Fsd.jd.com%252Farticle%252F25548&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;改进我们的架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中我们已经对上下文机制进行了详细的阐述，在这里我们简单回顾一下它的作用。如下图所示，在传统架构中开发者往往直接面向数据库编程，业务逻辑与数据库操作互相交织，容易造成重复或碎片化的数据库读写操作。而采用上下文机制之后，业务流程中的各个子模块都不再封装数据的读写操作，而是在请求一开始先将后续流程所需要的数据集中初始化到上下文对象中，后续各个业务模块统一从上下文中获取所需的详情数据，并把产生的中间结果写入到上下文对象中，最后在所有子模块业务逻辑执行完成之后，集中将上下文中新增或发生变化的业务实体持久化到存储介质中。这种设计&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;一方面能够避免子模块划分导致的重复及碎片化的数据读写操作，另一方面，集中的数据操作可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;启发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;开发者采用批量、异步和并行等措施进行极致地性能优化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//246d9ed0041739f4881c0a5099b7db03.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;上下文机制与传统架构业务处理流程对比&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架对上下文机制做了进一步升级和深度集成，上下文作为核心要素被直接定义到标准业务执行器模版中，领域服务和领域能力执行器都要通过泛型参数来声明自己所需的上下文对象类型。需要说明的是，尽管领域能力执行器中也定义了「上下文初始化」标准步骤，但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架依然建议开发者尽量在领域服务执行器的上下文初始化步骤中就将各个领域能力所依赖的业务实体或外部数据集中批量查询好，然后填充到领域服务上下文中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。后续各个领域能力会优先从领域服务上下文中获取所需的详情数据，领域能力的上下文初始化步骤仅做依赖数据的非空校验或者做为从领域服务上下文中获取不到所需数据时的托底补充查询措施，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;这是由于领域服务作为整个业务流程的全局把控者，拥有最全的数据视角，可以对代价昂贵的 IO 操作进行极致地调优，而领域能力则聚焦于业务流程的局部细节，在能力内部封装的数据读写操作很容易随着能力的组合或循环复用而被碎片化或重复地执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;需要注意的是上文中「领域能力优先使用领域服务上下文中的数据」并不意味着领域能力会直接访问外层领域服务的上下文对象，这是由于同一个领域能力可能会被不同的领域服务所复用，因此领域能力不可能与其中任何一个领域服务的上下文耦合到一起。为了解决这个问题，PICASO 框架要求每个领域能力都要定义自己专有的上下文对象。在调用领域能力之前先将领域服务上下文中的数据传递到领域能力的上下文中，领域能力中的业务逻辑直接访问的依然是领域能力自己的上下文对象，在能力执行过程中构建的新实体或者对已有实体的修改也会直接保存到领域能力上下文中。而在完成能力调用之后，PICASO 会将领域能力上下文中新生成或者发生变更的属性传递回领域服务上下文中，从而在保持领域能力与领域服务解耦的前提下实现领域服务与领域能力上下文数据的共享。因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在 PICASO 框架中上下文机制除了起到避免碎片化及重复读写数据的作用之外，还负责在不同领域能力以及领域服务与领域能力之间进行数据的传递和共享。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们可以用一个例子来详细描述上述机制，如下图所示，领域服务内编排了三个领域能力：A、B、C，其中能力 A 和 C 分别依赖业务实体 1 和实体 4，能力 B 依赖能力 A 生成的数据实体 2，完成业务逻辑处理后框架需要把能力 B 和 C 构建的业务实体 3 和 5 以及能力 C 对实体 4 的修改保存到数据库中。当请求到来时 PICASO 框架会首先调用领域服务的上下文初始化标准步骤（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;initContext&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）完成实体 1 与实体 4 的查询，在调用能力 A 之前会将实体 1 从领域服务上下文拷贝到能力 A 上下文中，完成能力 A 的调用后会将其构建的实体 2 从能力 A 的上下文中拷贝回领域服务上下文，然后将领域服务的上下文作为两个能力之间数据共享和交换的通道，在调用能力 B 之前将实体 2 拷贝到能力 B 的上下文中......以此类推用相同的方式完成能力 B 和能力 C 的调用，最后 PICASO 框架会调用领域服务的聚合根持久化标准步骤（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;persistAggregate&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;），集中将新生成的实体 3 和 5 以及由能力 C 修改后的实体 4 持久化到数据库中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//de54d7e00f38a8de83b31dbd2d9221d2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;领域服务与领域能力上下文之间的数据传递关系&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上下文机制作为 PICASO 框架的基础组件，其内部除了用户自定义的业务属性之外还承载着大量框架内部运行所需的状态数据以及大量为开发者提供的工具 API。在本文中我们仅对其基本运行机制进行了介绍，关于上下文的使用技巧及其基类中各种工具 API 的使用方法，我们将在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳实践——上下文机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中进行详细的阐述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;标准业务模版执行引擎&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在上一小节的最后我们通过一个架空的例子论述了 PICASO 框架内部的数据传递流程，这些数据传递规则并不需要开发者手动实现，而是通过 PICASO 框架内置的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;标准业务模版执行引擎&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;自动触发的。接下来我们就将详细阐述标准业务模版执行引擎是如何将领域服务及领域能力各个标准步骤串联到一起的。但是在此之前，我们有必要必再次明确领域服务和领域能力执行器的职责，这对理解标准业务模版执行引擎的设计动机十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在 PICASO 框架中，系统对外提供的服务都是由领域服务执行器承载的，作为整个业务流程的全局把控者，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;领域服务执行器的基本职责就是定义业务流程（编排组装领域能力）以及管理业务数据（上下文的初始化及持久化），而领域能力执行器则聚焦在完整业务流程中的某个特定模块，负责实现该模块内部具体的业务规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如前文所述，领域服务是通过领域能力组合编排而成的，并且它们都继承了标准业务执行器模版，因此不难推导出领域服步骤其实就是通过各个领域能力的相应标准步骤组合而成的。但是这并不意味着业务流程中所有的业务逻辑都会下沉到领域能力中，比如领域服务上下文初始化操作就必须在领域服务执行器中直接定义。此外，考虑到领域能力聚焦于局部业务细节，无法独立对外提供服务，为了明确组件职责，避免给开发者带来困惑，领域能力执行器对标准业务执行器模版进行了二次拓展，隐藏了完整请求流程处理维度才需要的聚合根持久化（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;persisteAggregates&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、构建并发布领域事件（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;publishAppEvent&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）以及组装请求响应数据（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;assembleResponse&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）标准步骤，因此这三个模版方法对应的业务逻辑也需要直接在领域服务执行器中定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务及领域能力执行器的职责划分决定了二者之间的数据传递时机及其标准步骤之间的组合关系，标准业务模版执行引擎的模块串联规则就是基于此制定的。其核心设计就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;对业务流程中各个领域能力标准步骤的重组执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。在 PICASO 框架的早期摸索阶段，我们曾倾向于将同一个业务模块的参数校验与业务处理逻辑划分到两个不同的领域能力中。这种能力划分方式固然也能实现业务功能，甚至也能起到复杂度分离的作用，但是这种划分方式会造成业务逻辑的沙粒化分解，产生大量琐碎的小能力，这反而会增加系统的开发及维护成本。另外，由于同一个模块的参数校验及业务处理逻辑往往会依赖相同的底层数据，沙砾化的能力划分会急剧增加能力间数据传递和共享的负担，稍有不慎就会造成数据的碎片化读写，进而对系统性能产生影响。因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;我们最终选择回归业务本质，以最小原子业务边界作为能力划分的准则，将同一模块内关联紧密的参数校验、上下文初始化、上下文校验及业务处理逻辑封装到同一个领域能力执行器中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是这种封装规则却带来了新的问题：领域服务由领域能力组合而成，如果我们直接依次串行调用每个领域能力内的各个标准步骤，将无法实现领域能力与领域服务标准步骤之间的协调执行，另外由于调用后置能力时前置能力所有标准步骤都已执行完毕，如果后置能力的参数校验失败而前置能力在业务逻辑处理步骤已经与外部系统产生了数据交互，此时就会产生脏数据等问题。然而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;标准业务执行模版的抽象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;则为我们带来了该问题的解决方案：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;将领域能力执行器中的各个标准步骤拆散到领域服务执行器相应的标准步骤中重组执行，而不是依次触发每个领域能力的全部标准步骤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如下图所示，在领域服务的参数预校验标准步骤中会按照能力执行图依次触发各个领域能力的参数预校验步骤，而在领域服务的上下文初始化步骤中则会依次触发各个领域能力执行器中的上下文初始化步骤。这种重组执行机制确保了服务请求流程能够整体按照参数预校验、上下文初始化、上下文校验、业务逻辑处理、聚合根持久化、发布领域事件、构造返回值的标准流程执行下去，实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;fail-fast&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;特性，避免由于后置操作校验失败而前置操作已执行导致的 IO 资源浪费及脏数据问题，另外这种运行机制带来的额外收益是让我们能够利用现有服务快速实现请求预校验接口，这一点我们在本文第四章的 PICASO 框架开发流程示例中将有专门的呈现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上述过程也是辩证法的生动诠释，事物之间存在普遍联系，在对立统一中不断发展。PICASO 框架中也是在一次次提出方案、引发新问题、解决新问题的过程逐渐成型的，框架中各个组件互相支撑，互为因果，共同实现整洁架构的最终目标。我们也希望各位读者在阅读本文时能够始终将本文介绍的各项组件联系到一起来理解框架的指导思想和设计动机，这对未来我们能否在实际业务用好 PICASO 框架来说十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//9b99cf23fdfa6085f3b31e200044c394.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;标准业务模版执行引擎的重组执行流程&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面我们将结合着上图所示的能力标准步骤重组执行流程图逐步解析标准业务流程模版执行引擎的运行机制：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 参数预校验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当请求到来时，PICASO 框架会首先通过领域服务门面定位到具体的领域服务执行器实例，然后调用其参数预校验标准步骤（preValidate），在该方法中会首先执行领域服务执行器直接定义的参数预校验逻辑（当然也可以根据开发者的设计意图调整为先触发各个领域能力的参数预校验逻辑），然后再触发领域能力执行图中各个领域能力的参数预校验逻辑，需要注意的是由于领域能力执行器有自己专属的参数及上下文对象，因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在调用各个能力参数预校验方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之前&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，PICASO 会自动将领域服务入参对象中的属性拷贝到领域能力入参对象中同名同类型的属性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（与 Spring 框架中 BeanUtils.copyProperties 的逻辑相同）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 上下文初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;完成参数预校验逻辑之后，PICASO 会开始执行领域服务的上下文初始化逻辑。我们鼓励开发者将各个领域能力所依赖的底层数据集中到领域服务的上下文初始化逻辑中批量查询好，因为领域服务作为整个业务流程的全局把控者，拥有最全面的数据视角，可以进行最彻底的性能优化。完成领域服务直接定义的上下文初始化逻辑之后，PICASO 将调用能力执行图中各个领域能力的上下文初始化步骤，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;但是在此之前&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，与领域服务与领域能力之间的参数传递逻辑类似，PICASO 框架会先将领域服务上下文对象中的属性拷贝到领域能力上下文对象中同名同类型的属性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有些读者可能会对本小节的论述有些疑惑，封装领域能力的目的之一是为了逻辑复用，然而我们却要将其依赖数据的初始化逻辑代理到领域服务中，那么当一个领域能力被不同的领域服务引用时，是否会造成重复编码呢？这个问题的答案是肯定的，但是绝大多数场景下领域能力依赖的底层实体通常不多，一方面我们可以通过接下来将要介绍的「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合与资源库&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;」机制简化这些底层实体的查询逻辑，与由此收获的性能提升收益相比，重复编码所付出的轻微代价是完全值得的。另一方面我们其实并不建议在领域能力内部实现依赖数据的初始化查询操作，因为能够被编排到同一个领域服务中的领域能力通常都会依赖相同的业务实体，如果要在每一个领域能力内都实现一遍实体查询逻辑同样会造成重复编码。因此我们建议还是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;统一由领域服务完成上下文的初始化，然后通过上下文传递机制拷贝到领域能力上下文中，领域能力仅在上下文校验标准步骤中做好上下文参数的非空校验，确保领域服务传递过来了正确的数据&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。更多关于领域服务及能力上下文数据传递方案设计的技巧请参考《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳实践——上下文机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 上下文校验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;完成领域服务及各个领域能力的上下文初始化逻辑之后，PICASO 会继续执行领域服务及各个领域能力的上下文校验逻辑。该标准步骤内执行的是需要结合上下文中的底层数据才能进行的校验逻辑，如调整预算时要求新预算与历史预算差值必须大于 5% 且必须大于当前消耗，该逻辑依赖历史预算及物料当前消耗详情，就可以在上下文初始化步骤完成这两部分底层数据的查询，然后在上下文校验步骤中直接从上下文中取出详情数据执行相关的校验规则。默认情况下领域服务与领域能力在上下文校验步骤不需要执行任何的参数或上下文传递操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 业务逻辑处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基于上下文的业务校验通过之后，PICASO 框架会继续触发领域服务及能力执行图中各个领域能力的业务处理逻辑。需要注意的是由于领域能力的业务逻辑处理过程中可能会对上下文中已有的实体进行了修改，也可能会构建出新的业务实体对象，这些变更最终都需要被持久化到存储介质或者外部系统中。因此在默认情况下，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 会在能每一个领域能力的业务逻辑处理标准步骤执行完成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之后&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;执行一次领域能力上下文到领域服务上下文的数据回传操作，将领域能力上下文中的属性拷贝到领域服务上下文中同名同类型的属性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这些数据将在领域服务的后续步骤中被持久化到存储介质中，或者被用于构造领域事件及请求响应结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 聚合根持久化、发布领域事件、构造响应结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于标准业务执行器中的剩余的几个标准步骤承载的都是请求维度的逻辑，领域能力执行器标准模版中对这几个方法也做了屏蔽，因此在这几个标准步骤的执行流程中就不需要再调用领域能力执行图了。需要特别说明的是，当执行到聚合根持久化标准步骤时，定义在领域服务及领域能力中的业务规则对实体的变更以及构建出的新业务实体都已经写入到了上下文中，开发者可以充分利用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;领域服务对数据操作全局把控&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的职责定位，积极采用批量、异步、并行等手段进行极致地性能优化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 定制化执行流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前五步内容介绍了领域服务及领域能力标准执行模版默认的串联执行逻辑，PICASO 框架也遵循&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;约定大于配置（convention over configuration）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基本原&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#232930&quot;&gt;则，如果默认的执行逻辑能够满足开发者的诉求，开发者不需要实现过多的流程控制，但是要更&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;灵活地适配各类业务场景，PICASO 框架也支持开发者对上述标准串联执行逻辑进行定制化的修改：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;•&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 允许开发者指定仅执行领域服务的部分标准步骤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如前台业务方期望能够在实际调用系统的单元创建接口之前先对其构造出来的请求参数进行校验提前发现问题，因此希望系统为其提供一个预校验接口（注意这里的「预校验」不是标准执行模版中的参数预校验步骤），该场景就可以直接复用物单元新建领域服务执行器，并且在触发领域服务执行器时指定间仅执行该领域服务的参数预校验、上下文初始化及上下文校验逻辑，领域服务完成前三个标准步骤的执行之后就会立即返回前三步的执行结果，从而快速实现业务方诉求，这其实也是标准业务执行模版抽象带来的额外收益。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;•&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其次，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架支持开发者对领域能力执行图内的参数及上下文传递的时机与具体映射逻辑、能力调用的失败与异常处理以及各个领域能力的触发时机等行为进行定制化的修改&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如出价设置能力与预算设置能力都依赖物料当前的消耗数据，除了在领域服务的上下文初始化步骤完成查询的常规设计之外，也可以让出价设置能力完成消耗数据查询，然后以领域服务上下文作为媒介，将物料消耗数据从出价设置能力传递到预算设置能力中。这个时候就可以指定 PICASO 框架在完成出价设置能力的上下文初始化步骤调用之后立即执行一次从能力到领域服务上下文的数据回传操作，而不必等到默认的业务逻辑处理步骤完成之后。而这些定制化的串联执行配置都可以通过接下来将要介绍的能力编排领域特定语言来实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排执行图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在前一小节中我们介绍了 PICASO 框架内部各个原子模块与标准步骤的串联执行流程，PICASO 框架通过内置的标准业务模版执行引擎将各个模块的串联执行职责从开发者手中转移到了框架内部，从而让开发者专注于业务规则设计，实现填空式开发。这里说的「业务规则」一方面是指领域服务与领域能力各个标准步骤内具体的业务逻辑，另一方面是要明确当前业务流程需要按照什么样的顺序执行哪些领域能力、能力执行的前置条件、对默认串联规则的定制化配置（包括参数传递规则、上下文传递规则、错误及异常处理逻辑等），这些信息将以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力执行图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的形式提供给 PICASO 框架，之后框架就可以按照开发者的意图完成对各个领域能力的串联调用，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力编排&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;指的就是构建领域能力执行图的过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 能力编排框架的核心职责有两个，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;首先是在编码阶段让开发者能够以易用、简洁、直白的方式快速定义出业务流程对应的领域能力执行图，其次是在请求处理阶段将能力执行图解析为可以被标准模版执行引擎理解的执行计划，让其能够根据开发者意图完成业务逻辑的处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我们可以通过下图所示的框架内部实体关系图对上述两项职责进行详细阐述，图中蓝色线条标记的是领域能力执行图的构建过程，红色线条标记的是请求到来时领域能力执行图的执行流程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//df47910cd08020dd4cd4f42e6e3f5069.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;PICASO 能力编排框架内部实体关系图&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上图其实不算是标准的实体关系图，它更像是实体关系图与流程图的结合，其中不同颜色的线表示不同执行流程。事实上我们认为这种呈现方式更加符合现实，实体之间的关系本就是复杂的，在不同的场景和流程下实体之间的关系和相互作用往往也是不同的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从图中我们可以看到，每一个领域服务执行器内部都集成了一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力编排器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，在编码阶段，开发者可以通过它提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域特定语言（Domain Specific Language, DSL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以直白的方式构建领域能力执行图。能力执行图由多个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力编排节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;构成，每一个领域能力编排节点内部都封装着一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力门面执行器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。当请求到来时，业务模版执行引擎会首先对能力编排执行图进行解析，根据本次请求的参数及上下文信息将执行图中各个能力编排节点解析为零到多个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力执行要素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，所谓的领域能力执行要素就是一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;[领域能力执行器、参数对象、上下文对象]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三元组，它是一个有状态的、会话级生命周期的实体，除了核心的能力执行三要素之外，其内部还维护着在请求处理过程中执行引擎产生的一些控制中间状态，如当前已执行到哪个标准步骤、调用过程中是否发生了异常、本次调用是否已经提前终止等。执行图中解析出来的所有领域能力执行要素将被构造成一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域能力执行要素链调用器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，它用来控制各个领域能力执行要素的触发行为，包括能力执行器各个标准步骤的逐步调用、能力编排节点的延迟解析、不同执行要素之间的并行调用、能力执行要器的提前终止等。在领域能力执行要素链调用器的控制之下，能力执行图中的各个能力门面执行器被依次触发，通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;标准可执行实体发现与路由机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;定位到当前请求应该使用的能力实例，调用其各个标准步骤完成业务逻辑处理。由于本文旨在介绍 PICASO 框架中各项组件的基本原理和运行机制，并没有对能力编排框架的实现细节做过多探讨，有关能力编排框架各项特性的详细介绍请参考《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳实践——能力编排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排领域特定语言&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在 PICASO 框架设计之初，我们也曾想直接引入一些开源的流程编排框架来实现领域能力之间的串联调用。但是正如本章节最开始论述的那样，现有的开源解决方案并没有满足我们的核心关切：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以直白、简洁、轻量、易用的方式实现能力组装，解决为了应对业务本质复杂度而采取的各项实体拆分与路由机制带来的编码繁琐、模块组装逻辑复杂等副作用，减少胶水代码和开发者的编码负担，提高关键业务信息密度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。图形化、配置化的流程编排框架虽然能够直观的呈现业务处理流程，但是也造成灵活度差、普适性低、开发流程割裂、业务知识分散、模块串联配置繁琐等问题，无法达成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;整体熵减&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的设计目标，而 PICASO 框架解决这些问题的方案则是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;自定义能力编排领域特定语言。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域特定语言（Domain Specific Language, DSL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#202122&quot;&gt;专门针对特定应用领域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的计算机语言，与 C++、Java 等通用计算机语言（General Purpose Language，GPL）相比，领域特定语言的功能及普适性十分有限，但是在特定领域之内它却具有强大的表达能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;领域特定语言的核心吸引力在于它提供了一种更清晰地传达系统各部分意图的方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，提高代码的可读性（虽然我们总是有意或者无意地低估了代码可读性对生产力的影响），降低开发者与领域专家（产品、测试甚至是用户）的沟通难度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;它能够让使用者轻松实现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;声明式编程（Declarative Program）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;，对业务层开发者来说，这意味着他们可以直接告诉框架他们想做什么，而不必编写要想达成目的而需要执行的具体操作步骤&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（Martin Fowler, Domain Specific Language, 2013），也正是这一点让 PICASO 框架能够将前文所述的各项业务复杂度应对措施带来的系统偶然复杂度屏蔽在框架内部，将 PICASO 框架内部的各个功能模块有机结合到一起，共同实现整体熵减的设计目标。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;软件工程领域的大师 Martin Fowler 将领域特定语言分为外部 DSL（External DSL）和内部 DSL（Internal DSL）两大类。外部 DSL 往往拥有自定义语法、需要宿主应用的代码执行文本解析，基于该类 DSL 编写的业务规则通常以脚本或配置的形式存在于系统代码之外，典型的案例是正则表达式。而内部 DSL 是通用编程语言的子集，它对外提供一组特定的 API，利用内部 DSL 编写的业务规则往往是一段合法的代码，典型的例子就是 JDK8 之后提供的 Java Stream API。与外部 DSL 相比，内部 DSL 不需要专门的语法解析器和开发平台，可以直接与宿主应用代码无缝衔接，也能直接复用普通 IDE 的代码提示与自动补全功能，也正因为此，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;为了向业务开发者提供集中、连贯的开发体验，我们最终选择为 PICASO 能力编排框架开发一套内部领域特定语言&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了尽可能灵活地适配所有的业务流程构建场景，我们在 PICASO 框架的能力编排 DSL 中定义了顺序、条件和循环三套能力编排逻辑，分别对应顺序执行、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;if...else&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;判断、循环三种流程控制方式。其中每一类能力编排节点的配置都遵循约定大于配置的原则，按照标准业务模版执行引擎的默认执行逻辑提供了全部缺省配置，同时开发者也可以通过能力编排 API 定制自定义的执行逻辑，如循环规则、分支判断条件、触发能力时的参数及上下文传递逻辑、失败及异常处理逻辑、能力节点解析步骤等。由于本文旨在介绍 PICASO 框架的设计思想和各模块的底层运行机制，因此我们不会对能力编排框架所有 DSL API 进行详细论述，这部分内容将在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳实践——能力编排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》一文进行详细论述。本文仅通过一个实际的能力执行图构建案例让大家对能力编排 DSL 有一个具象的感知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下图给出的是一个站外字节广告计划创建请求处理流程对应的领域能力执行图构建逻辑，可以看出&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力编排 DSL 仅用数十行代码以一种近乎白话文形式描述出了完整的计划构建过程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：首先对用户已创建计划数量进行上限检查（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignUpperLimitCheckAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；上限校验通过后会构造出一个空的计划对象并为其填充用户 ID、计划类型等基础信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignBaseInfoAssembleAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；然后判断本次计划创建请求是否在参数中设置了联合活动 ID，如果联合活动 ID 不为空则需要执行联合活动信息设置相关的业务逻辑（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignJointActivityAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；完成联合活动信息设置之后就要依次设置计划的投放周期（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignScheduleConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、计划名称（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignNameConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、营销目标（CampaignMarketTypeConfigAbility）、应用集（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;TrafficStrategyConfigAbiliy&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）等模块的相关属性，需要注意的是在上述几个能力的编排逻辑中，由于领域能力的参数或上下文对象中的属性名称与领域服务的参数及上下文中相应属性并不匹配，默认的参数及上下文数据传递机制将无法为这几个属性设值，因此开发者对营销目标设置能力的参数传递（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;cmdTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、上下文传递（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ctxTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、应用集设置能力的上下文传递（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ctxTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）逻辑进行了自定义拓展，手动实现了参数及上下文中特殊属性的数据映射逻辑；在完成这些业务模块的属性设置之后，如果请求参数中设置的标的物类型为「商品库」，那么接下来就要执行与站外 DPA 广告业务相关的特殊业务环节：推广 SKU 的校验（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;SkuValidateAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）以及 SKU 跟单信息的配置（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;TraceOrderSkuConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）逻辑......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6bdf37fcc66e00c800d58232f8b207c7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;顺序及条件能力编排 DSL 示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上图计划新建流程的能力编排逻辑中只用到了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;顺序和条件编&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;排这两种最常用的编排模式，但是在一些批量操作请求处理流程中通常还会用到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;循环编排模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，它允许标准业务模版执行引擎重复调用同一个能力门面实现批量请求的处理。下图通过批量创意绑定接口给出了循环能力编排模式的使用示例，在该流程的最后一个环节通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;registerFlatMapped&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排 API 注册了一个创意绑定能力（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CreativeBindAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）。该能力被设计为处理单个创意的绑定操作，而批量创意绑定领域服务却需要在一次请求中完成多个创意的绑定操作，因此我们通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;cmdFlatMap&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排 API 定义了将领域服务参数中的待绑定创意列表展开成多个单创意绑定能力参数的规则，标准业务模版执行引擎将据此遍历每一个单创意绑定参数并调用单创意绑定能力进而实现批量创意绑定。从示例中我们还可以看到，开发者在编排创意绑定能力时还通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;transferCtxBeforeStep&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排 API 指定在调用领域能力的上下文初始化和业务逻辑处理两个标准步骤前都执行一次领域服务到领域能力的上下文传递操作，而标准业务模版执行引擎的默认行为是仅在领域能力上下文初始化标准步骤调用前执行该操作。除此之外，开发者还通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;onFailure&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;onException&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力编排 API 定制了失败及异常处理措施，确保在循环过程中单个创意绑定失败或异常不会中断整个业务处理流程，而是在处理完所有待绑定创意之后，将绑定失败的创意信息及失败原因返回给调用方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//e9af39f00bc0a3480f86264aa9f8c4c1.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;循环能力编排 DSL 示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有些读者可能会疑惑为什么不把创意绑定能力设计为直接在能力粒度上就支持批量绑定逻辑，这是因为当前的设计是综合考虑能力划分原则、创意绑定业务实际与拆分规则收益等因素之后决定的。我们曾在前文中提到，领域能力封装的是最小原子业务模块，而批量处理实际上属于流程控制逻辑，因此从职责划分的角度考虑，领域能力沉淀单个创意绑定的具体业务规则、领域服务负责循环流程控制的设计更符合 PICASO 框架的底层设计逻辑；另外从业务实际来分析，由于不同创意类型对应的创意绑定逻辑也有差异，因此创意绑定能力会按照创意类型拆分为不同的能力实例，而且广告主有可能通过批量绑定接口一次性绑定类型不同的多个创意。在这样的业务背景下，单创意绑定的能力拆分逻辑可以让领域服务直接遍历每一个待绑定创意，然后通过能力门面将单个创意绑定请求路由到与待绑定创意类型相适配的能力实例上进行处理，而不需要执行按创意类型分组等预处理逻辑；最后从拆分收益上看，单个创意绑定的拆分逻辑能够给我们提供更多的编排灵活性，通过定制化的失败及异常处理逻辑，不同的领域服务可以灵活地支持快速失败或允许部分失败等异常处理规则。综上考虑我们最终采用了单创意绑定的能力拆分规则，而这个决策过程其实也是我们进行能力拆分的一般流程。从这个例子中我们可以发现，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能力拆分其实是一个主观性很强的行为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，尽管我们为其制定了一系列的指导准则，但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在实际需求中开发者依然需要充分发挥主观能动性，在充分理解新架构设计思想的前提下，紧贴业务实际，在系统性能、架构整洁程度以及实现成本之间找到最佳的平衡点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;截止到目前，PICASO 领域能力编排框架已经经历了两轮功能迭代，前文所述的顺序、条件及循环编排是第一代能力编排框架提供的特性，这一代能力编排框架仅支持领域能力之间编排串联，而领域服务各个标准步骤内的业务逻辑和能力执行图之间的串联依然需要手动硬编码实现。下图给出了一个使用第一代能力编排框架的领域服务案例，这个案例也清晰地呈现了领域能力执行图与领域服务各个标准步骤之间的关系。可以看到领域服务执行器提供了一个标准的领域能力编排入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;registerDomainAbilities&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，该模板方法通过参数提供了一个领域能力编排器（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainAbilityOrchestrator&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;），开发者可以通过该模板方法完成领域能力执行图的构建。然而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;当请求到来时，标准业务模版执行引擎并不会直接触发领域能力执行图的调用，它仅会按照标准业务执行流程依次调用领域服务执行器的各个标准步骤，而领域能力执行图的调用则必须由开发者硬编码到领域服务执行器的各个标准步骤中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。当然框架已经将领域能力执行图的触发逻辑封装成了相对易用的 API（详见下面截图中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;doPreValidate&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方法中被标注的代码片段），因此这种设计的实现成本不算太高。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;随着系统中领域服务执行器数量的增长，它也的确在系统中引入了大量重复的胶水代码，并且造成了领域服务中业务逻辑与领域能力值执行图之间的割裂，无法提供彻底的连贯开发体验&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//e5bb9d6bedaf7b16f2edd288ae4af1ff.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;第一代能力编排框架依然存在一些问题&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;近年来，为了给广告主提供简洁易用的投放体验，系统正越来越多地向着智能化和集成化的方向发展，让广告主少操作、少输入成为 UI 交互设计重要原则。在这样的业务背景下，我们收到了越来越多的跨层级接口合并需求，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;这让我们的业务在模块化的基础上又呈现出集成化特征&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，而且很多情况下，这种集成是「跨层级」的。如过去我们的广告物料一直遵循经典的计划、单元、创意三层结构，计划下可创建多个单元、单元下可绑定多个创，创建物料时需要依次调用三个接口。然而在近期全站推广、一页投放等需求都有一键创建全层级物料的诉求。但是由于子层级物料的创编流程都依赖父层级的物料对象创建完成，这与第一代能力编排框架中的重组执行机制底层逻辑相悖；另外，由于父层级物料对象与子层级物料对象之间都是一对多的关系，在一键创建全套物料的场景中，我们需要循环调用子层级物料的构建流程，然而第一代能力编排框架中循环能力编排特性仅支持循环调用单个领域能力，而不支持对多个领域能力执行链的重复触发。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;为了更好地适配业务发展趋势，同时解决上文提到的第一代能力编排框架中由于领域服务与领域能力执行图之间逻辑分离定义、需要手动硬编码完成串联造成的业务逻辑割裂、会引入大量重复的胶水代码等问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，我们在第一代能力编排框架的基础上进行了升级，引入了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;子流程编排机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。子流程编排最重要的升级是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;增加了分阶段集成的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这也与当下多接口集成的业务发展趋势相符，一个完整的请求处理流程可以被拆分为不同的执行阶段，后置阶段的执行逻辑可能依赖于前置阶段的执行结果。PICASO 框架允许开发者通过子流程编排 DSL 将一个完整的业务流程拆分定义为多个业务处理阶段，其中每一个业务处理阶段被称为一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;子流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;每一个子流程可以看做是一个小的领域服务，有各自专属的标准处理步骤及领域能力执行图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。除了可以像第一代能力编排框架那样为每一个子流程定义专属的领域能力执行图之外，第二代子流程编排框架还让开发者不需要再去重写领域服务执行器标准模板中的各个标准步骤，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;而是通过子流程编排 DSL 将每个子流程专属的参数预校验、上下文初始化、上下文校验及业务逻辑处理四个标准步骤与领域能力执行图一起直接定义到子流程执行图中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，从而彻底解决了第一代能力编排框架中领域服务维度的业务逻辑与能力执行图开发割裂的问题。也正因为如此我们在第二代子流程编排 DSL 中将第一代编排框架中的领域能力编排器（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainAbilityOrchestrator&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）升级成了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;领域服务构造器（&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainServiceBuilder&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下图给出了一个使用子流程编排 DSL 构建领域服务执行图的例子，可以看到，与第一代能力编排框架类似，第二代子流程编排 DSL 为开发者提供了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;顺序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;条件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;循环&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;捆绑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;包装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;五种子流程编排节点。其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;循环子流编排节点支持子流程维度的循环调用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，解决了第一代能力编排框架中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;FlatMap&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;编排节点仅支持对单个能力进行循环调用的问题，因此在一对多的子层级物料创编场景中有广泛的应用，如下面例子中的在单元下绑定关键词列表的场景：一个单元下可以绑定多个关键词，而单个关键词的绑定操作需要串联执行多个领域能力，此时我们可以将单个关键词的构建过程定义为一个基础顺序子流程，然后再通过循环子流程编排节点将这个基础子流程循环集成到单元创建领域服务执行图中，这样就可以实现在单元下批量绑定关键词的功能；而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;捆绑子流程的作用类似于通用编程语言中的‘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;’，它能够将多个子流程包装成一个逻辑子流程节点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这一特性让子流程编排能够支持任意不同子流程之间的组合及嵌套，进一步提升了编排框架对各类业务场景的普适性；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;包装子流程节点则是专门为已有领域服务执行器的组合复用而设计的，它可以将一个现有的领域服务执行器包装成一个子流程编排节点添加到子流程编排执行图中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这一特性在复用现有接口进行集成化改造或实现批量操作等需求中会为开发者提供极大的便利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//00576a00f7b24b4d8ed784904b7af260.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;第二代子流程及能力编排框架示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过上面的几个例子我们能感受到，领域能力编排 DSL 能够以极高的信息密度描述业务流程的关键信息，通过构建领域能力/子流程执行图的方式定义业务流程的措施不仅能够减少胶水代码、降低开发负担，还可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;协助开发者快速建立起对业务的全景认知，同时，领域能力/子流程执行图也能作为详细业务规则的目录或索引，在进行业务梳理或问题排查时让开发者可以按图索骥快速定位目标代码的大致位置，提升业务知识传承及问题定位的效率&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;尽管我们在 PICASO 框架中舍弃了图形化流程编排框架的设计，但是我们并没有否定它存在的意义，这种编排方式在低代码编程领域占有重要的地位。但是它更适合在一些节点类型有限或者流程相对稳定的业务场景下使用，比如审批流程，虽然审批流可能有很多，但是每个审批流程中的节点种类往往不多，可以用相对固定的模式进行串联；或者广告播放流程，尽管其业务流程同样节点众多、冗长复杂，但是流程数量相对固定，基本上可以分为展示、搜索、推荐、站外、合约这五大核心流程，很多变更是对流程的微调或节点内部的逻辑升级。与这些业务相比，广告投放系统则维护了近 300 个能力节点、400 多条请求处理流程，每次需求迭代都会涉及数十条业务流程的变更。在这样的业务特点下，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;简洁、灵活、集中、连贯的开发体验要比一个炫酷的 UI 交互界面重要的多&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。当然，我们依然十分认可图形化界面强大的呈现能力，事实上我们也在规划为 PICASO 框架开发内置的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代码元数据管理平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，其中一项重要的功能就是把代码中基于能力编排 DSL 构建出来的领域能力执行图解析为业务流程图回显到交互界面中，让开发者可以直观地查看所有领域服务的处理流程。但是该平台只做能力编排逻辑的图形化展示，领域能力执行图的构造依然是通过代码中的能力编排 API 实现的（当然该平台也可以提供各个能力编排节点配置属性的动态修改功能，但是这仅作为紧急情况下的应急处理措施）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h3_16&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的愿景：构建图书馆式代码架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至此我们已经完成了对 PICASO 框架全部核心模块的介绍，此刻让我们再次回首 PICASO 框架的设次初衷——竭尽所能地提升团队的研发效率，这也是一线业务开发团队的核心价值所在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提到研发效率，有很多同学认为少写代码就是研发效率高，也有同学认为支持了配置化、使用了拓展点就能实现研发效率的提升。然而事实上代码行数从来就是不是制约研发效率提升的核心要素，对业务问题的抽象和封装有时的确会导致我们多写一些代码，但是与多写几行代码花费的几十分钟相比，在实际工作中我们会把更多的时间和精力消耗在确定分工时与合作团队的扯皮上、需求设计时各团队方案对齐及历史业务逻辑的确认上、出现问题时原因的定位与影响范围的评估上、由于自己或者上下游系统的技术或架构限制而不得不进行的妥协方案开发上......解决这些问题所花费的时间才是阻碍研发效率提升和耗尽业务方对研发团队信任的根源。至于配置化和拓展点，不可否认的是它们的确是包括 PICASO 框架在内的很多效率提升解决方案中经常采用的措施，但是如果上述问题得不到解决，这些措施也只能是治标不治本。正如「鲍勃大叔」Robert C.Martin 在其著作《架构整洁之道》中所说：「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不管你多敬业、加多少班，在面对烂系统时你仍然会寸步难行，因为你大部分的精力是在应对混乱。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」而我们之所以要为分工扯皮、之所以不敢升级系统以适配新的业态、之所以无法快速梳理出业务规则，都是因为过去大泥团式的代码架构让我们&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;看不懂、不敢动、动不了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为了解决上述问题，PICASO 框架在设计之初就确立了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;框架即规范、代码即文档&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基本原则，从设计阶段就开始引导开发者以统一的思想和方法论对业务进行拆解分析，然后将业务规则淀到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;标准业务执行模版或拓展点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接口中，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;确保每一处业务规则都有可检索、可引用的实体边界&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;；接着通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力编排框架&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以近乎白话文的方式将这些原子业务实体组装起来，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以极高的信息密度清晰地描述完整的业务流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;；最后通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;通用可执行实体发现及路由机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对各层实体进行分类及分组，对上层实体暴露统一的调用门面，除了起到逐层向上屏蔽分组内部场景复杂度的作用之外，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;PICASO 框架维护的可执行实体路由表也可以作为业务细节逻辑的速查索引&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。有了这些措施，开发者进行业务逻辑梳理时就可以先通过领域服务维度的路由表定位到目标场景对应的领域服务实例，然后通过其领域能力执行图快速建立起对务流程的全景认知，接着选择执行图中感兴趣的业务节点，通过领域能力维度的路由表快速定位到具体的能力实例，最后到相应的的标准步骤中定位具体的实现细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;这种由粗及细、逐层按索引查找的过程类似于&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;图书馆的管理模式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：借阅图书时，我们需要大体推断目标书籍所属的类目，然后通过类目确定书籍所在的书架，在书架上找到目标书籍后再通过其目录快速概览全书，最后通过目录定位到感兴趣的内容，这就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;图书馆式代码架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的由来。我们希望这种代码架构能够让业务知识通过系统代码清晰、准确、完整地表达出来并能流畅地传承下去，进而让团队在面对业态更迭时能够更加从容地承接业务方提出的各项诉求；在进行多团队协作时能够拥有足够的底气承担更多的责任；在遇到线上问题时能够更加快速地定位问题并制定解决方案；在接手新系统时也能够快速梳理出业务主线并上手开发，最终实现团队整体研发效率的提升。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（二）聚合与资源库：拒绝魔法逻辑，让代码直接表达业务规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果说前文介绍的 PICASO 框架让新架构拥有了领域驱动设计之形，那么接下来将要介绍的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;聚合与资源库机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;将让新架构真正具备领域驱动设计的灵魂。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;长期以来，我们的开发行为中业务设计与代码设计是分离的。接到需求后研发人员会和产品及业务方进行大量的沟通，确认业务流程及各项细节规则，这是业务设计的过程。但是在编码阶段，开发人员又会对业务设计结果重新进行抽象，转化为代码实现方案。而此时传统的三层架构过于简单的层次划分很容易将开发者的大部分注意力引导到数据库设计上，代码设计就变成了对数据库增删改查操作的设计。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在这个过程中前期业务设计沉淀的大量领域知识往往会被丢弃，实现出来的代码也失去了对业务规则的直接表达。而缺乏基础模型设计的软件充其量也只是一种机械化的产品，虽能实现功能却无法解释这样操作的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;更严重的是，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;如果底层数据库存在表或字段的复用，那么业务规则被直接翻译成库表增删改查操作逻辑之后，代码甚至会表达出与业务规则完全不相符的含义出来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这些代码就成了只有开发者自己才能看懂的魔法逻辑，甚至经过一段时间之后开发者本人也会忘记这些代码背后真正的业务含义......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;如果整个程序设计或者其核心部分没有与领域模型相对应，那么该模型就是没有价值的，软件的正确性也值得怀疑。（Eric Evans, Domain-Driven Design: Trackling Complexity in the Heart of Software, 2003）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面向数据库编程的设计思维还容易引导我们最终以事务脚本（Transaction Script）的形式实现业务流程的处理，将业务规则与数据库表操作逻辑糅合到一起，业务实体之间的关系也因此分散和隐藏到了整个工程中不同的接口实现里，这会给数据模型全景认知的建立带来极大的障碍。领域驱动设计思想的祖师爷及布道者 Eric Evans 曾提到自己项目组的成员曾花费数月时间才梳理出一个完整的数据模型，而在我们自己的记忆里，似乎也没有哪位同学有底气敢宣称自己掌握了完整的数据模型（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;我们可能清楚数据库中有哪些库表，但是由于底层库表存在不同业务场景复用的情况，导致表中数据对应的业务含义并不统一。这种复用表结构的设计无可厚非，在很多情况下我们甚至都鼓励这种纵向拓展方式，但这也的确是造成我们对数据模型认识模糊和不完整的主要原因&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）。数据模型全景认知的缺失让开发者很难进行统一的模型顶层设计，在多需求并行推进的开发模式下很容易在不同项目组之间形成信息孤岛，无法实现模型复用与合并，导致数据模型野蛮膨胀，这反过来又进一步加剧了数据模型全景认知的构建难度，从而陷入到恶性循环中无法自拔。除此之外，业务流程中不同的业务环节可能会依赖相同的底层数据，事务脚本式的业务处理逻辑会将这些底层数据的读写操作分散到不同的接口或业务模块的实现中，除了会造成重复编码之外，还有可能在运行时造成重复和碎片化的数据读写操作，进而影响系统性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;聚合与资源库机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是专门为解决上述问题而生的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_18&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;聚合与资源库机制实现数据模型与业务逻辑分离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合（Aggregate）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是领域驱动设计思想中重要概念，它是一组相关对象的集合，这些对象之间关联密切，彼此之间已经按照对象之间的关系以父子属性的方式组装好。每个聚合都有明确的边界（boundary）和一个聚合根（root），其中边界定义了这个聚合中都有哪些对象，而聚合根则是这些对象中的一个特定实体。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合根&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是聚合内唯一个允许被外部对象引用的实体，也是聚合中的所有实体的最顶层父级对象，因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;通过聚合根可以访问到聚合内所有对象，这会给上层业务规则的实现带来了极大的便利&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是实际业务中聚合内的实体关系通常都十分复杂，常常存在多级嵌套关系。比如广告投放业务中计划聚合内就存在着「计划-&amp;gt;单元-&amp;gt;创意-&amp;gt;子创意-&amp;gt;子创意审核记录」这种多达 5 层的嵌套实体结构。如果每次使用聚合时都需要开发者手动实现聚合内实体的组装逻辑显然会带来大量的重复代码及编码负担，对系统未来的维护来说也将是一场灾难，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;资源库&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是为了解决这个问题而设计的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;资源库（Repository）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是系统中所有聚合根对象的逻辑集合，当然这并不意味着资源库对象会直接加载和维护系统中所有的聚合根实例，它只是逻辑上的集合。事实上在实现层面业务数据始终保存在数据库等存储介质中，资源库只是定义了针对聚合根或聚合根集合的增删改查操接口，并且维护了底层存储介质中的数据记录与聚合实体对象之间的映射关系以及聚合中各个实体之间的关联组合逻辑。因此开发者可以通过资源库定义的标准接口一键获取到一个组装好的聚合根对象，就好像是从一个集合中取出一个元素那样容易。如下图所示，与传统架构业务层代码在不同业务环节中直接访问数据库的实现方式相比，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;新架构在上层业务（领域服务）与底层数据库访问层中间插入了一层资源库，上层业务需要获取聚合数据时，不需要自己实现聚合中各个业务实体的查询、映射和组装逻辑，而是通过资源库提供的标准接口直接获取已经组装好的聚合根对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这种设计将聚合内各个实体的查询、映射及组装逻辑收口屏蔽在资源库内部，让上层业务聚焦在业务规则上，从而实现了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;数据模型与业务逻辑的分离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。这样不仅能够避免在业务逻辑中频繁穿插繁琐的数据查询和组装逻辑，防止在运行时出现重复及碎片化的数据读写操作，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;资源库集中维护的各个聚合实体的查询、映射和关联逻辑也是一份重要的业务知识，能够辅助开发者快速建立对完整数据模型的全景认知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//a38798e9cd68c415a9649b696bc8eb76.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;聚合与资源库的引入实现了数据模型与上层业务模型的分离&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六边形架构让代码从业务中来到业务中去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在上一个小节我们介绍了聚合和资源库的定义及实现准则，这其实有些本末倒置，因为聚合和资源库机制的关键不是如何实现聚合实体的查询或者持久化，而是如何设计一套有价值的聚合（当然，先了解聚合的实现准则对理解聚合的设计准则是有帮助的），而聚合的设计原则正是领域驱动设计思想核心理念的直接体现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;网络上很多介绍 DDD 思想的文章都是从统一语言、领域、界限上下文等术语和概念开始的，但是由于中英文语境的差异和国内外软件开发生态的不同，这些文章很容易让初学者陷入到各种概念的泥沼中无法自拔。然而那些概念只是领域驱动设计思想的外在表现形式，其背后的思想内核才是我们应该优先掌握的内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;领域驱动设计思想的核心理念就是保持业务、领域模型和代码三者之间的统一&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;六边形架构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是为了保障系统能够达成这一目标而设计的，它的核心逻辑在于保护领域模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六边形架构实际上是在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分层架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基础上升级而来。领域驱动设计思想作为一种设计的指导思想其实并不会限制使用某种特定的架构，在传统的分层架构上也可以实现领域驱动设计思想的落地。下图中最左侧给出了应用了领域驱动设计思想之后的分层架构，它看上去就是将传统三层架构中的业务层拆分为应用层与领域层。其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;领域层负责维护领域模型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，所谓的领域模型就是由当前领域内的全部聚合、资源库以及运行在这些聚合实体上领域能力和领域服务构成的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;应用层则从业务视角定义了系统应该对外提供多少服务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（也就是所谓用例（use case）和用户故事（user story），如果你特别执着于那些术语的话），这些服务接口最终都会调用领域层中的领域服务执行器来实现接口功能；应用层关注的是在系统应该对外提供哪些服务，但是并不关心这些服务的请求来源是 RPC 调用还是 MQ 通知，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;这是用户接口层的职责，它负责根据与调用方达成的约定将应用层接口暴露给不同的接口协议&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：Http、RPC、MQ、事件通知等等；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;基础设施层则负责维护系统中使用的众多中间件、工具以及底层存储介质的访问逻辑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//abe8b83e92d82c7cb82be66d2b1457a6.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;多层架构向六边形架构的演进历程&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过领域层和应用层的抽象，我们让分层架构具备了实施领域驱动设计思想的可能。但是分层架构天然会引导开发者自上而下地以数据流的视角审视系统。而人脑的天性使我们更容易关注流程的始末，而容易轻视流程的中间环节。因此分层架构容易让开发者更多的关注底层数据的存储逻辑，进而再次陷入面向数据库编程的思维，设计出与实际业务脱节的领域模型。当然，我们自然可以通过不断的宣贯和世界观输出来呼吁开发者紧贴业务实际设计代码实体，避免在需求伊始就陷入到底层库表结构中无法自拔，但我们还是希望找到一种&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能够在架构模式上就凸显领域模型的重要性，引导开发者从业务实际出发设计领域模型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的架构，这就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六边形架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;诞生的背景。在对六边形架构进行详细介绍之前，我们先回过头来再次审视分层架构中用户接口层和基础设施层的职责差异，这对理解六边形架构的本质十分重要：用户接口层将系统服务暴露成不同的协议接口，因此其内部的代码主要在执行接口参数转换和应用层接口调用的逻辑；在领域服务返回处理结果之后，用户接口层还需要将领域服务返回的响应结果包装成符合对外接口协议的响应对象。而基础设施层主要维护的是底层数据的访问逻辑，似乎与用户接口层的职责千差万别。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;如果我们把数据库看做是一个特殊的外部服务，基础设施层的代码执行逻辑就与用户接口层几乎一致了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基础设施层负责的就是聚合实体与底层存储 PO 对象之间的转换及存储介质数据传输协议的调用。我们不难发现用户接口层与基础设施层都在针对领域模型做防腐处理，从这个视角看，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;用户接口层与基础设施层在架构中的地位是相同的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。因此，如上图中间位置的架构图所示，在架构模式上我们尝试将用户接口层与基础设施层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「掰」&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到一个同一个层级中合为一体，于是我们就能得到一个&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六边形的对称架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（从上图的呈现方式上看，将用户接口层与基础设施层合并后可能还需要再旋转 45°才能呈现出与上图右侧一致的六边形架构）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六边形架构本质上还是一个分层架构，只是在呈现方式上（注意不是实现方式）将用户接口层与基础设施层合二为一，让他们共同作为防腐层保护位于架构中心的领域模型不被调用方的请求协议以及底层数据库的特殊设计所污染。而人脑天然具备的找中心的特性能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;让开发者将更多的注意力放到位于架构中心的领域模型上，暂时忘记底层数据库的存储规则，进而能够紧贴业务实际设计聚合中的各个实体及值对象，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;让代码直接表达业务规则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，最后通过资源库实现聚合实体与底层存储介质 PO 对象之间的转化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下图给出了一个广告投放业务中聚合实体与底层库表结构设计的例子，投放系统作为一个业务集成平台需要不断地对接各种垂直业务系统，在广告物料中也需要不断集成各类业务实体，这些数据也需要保存到底层的广告物料数据中。在设计单元聚合时，我们会紧贴业务实际为各类外部关联对象定义含义明确的聚合实体：商品库（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ProductCategory&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、抖音账号信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AweneAccount&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、展示锚点信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AnchorInfo&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、直播信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;LiveInfo&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）等，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;从而确保领域模型与实际业务的统一&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是在设计底层库表结构时为了避免库表结构膨胀以及表字段稀疏化，我们采用了通用化的存储结构：绑定到广告物料上的不同外部业务对象都保存到同一张外部关联对象表中，该表中的字段采用泛化设计，不与任何一种特定的外部业务对象相绑定，而是通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;字段确定本条记录对应的外部对象类型以及表中其他字段的实际业务含义，业务层对这些外部业务对象读写操作都要通过资源库集中维护的底层数据记录与领域层聚合实体之间的映射逻辑做转换。需要特别说明的是，在新架构中我们将 PICASO 框架中的拓展点机制延伸到了基础设施层，引入了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模型管理拓展点（Model Manage Extension, MME）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;来实现聚合组装主流程与底层数据对象转换逻辑的解耦。在本例中，我们将外部关联对象表对应的 PO 对象与领域层聚合实体之间的映射逻辑抽离成了一个模型管理拓展点，以外部关联对象类型作为路由键，通过 PICASO 框架的通用可执行实体发现与路由机制实现具体拓展点实现的自动定位。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;可以看出资源库的存在不仅让开发者可以聚焦业务实际设计领域模型，让代码直接反映业务实际，同时还让通用化的底层数据存储结构得到更加广泛的应&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：库表结构的通用化设计虽然能够解决数据库模型膨胀的问题，但是也的确降低了数据模型对业务的表达能力，而且如果让上层业务直接操作这些库表，势必会造成代码逻辑不明、编码繁琐的问题。然而资源库却通过收口底层数据对象与上层业务实体之间的转化逻辑很好地解决了这些问题，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;让我们在采纳这种通用化的数据存储结构设计时少了很多顾虑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//1d854f02de342eead602dfb8d6fdd3d0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;底层通用化存储结构（K-V 模式）在资源库中通过模型管理拓展点被映射为领域模型中业务含义明确的实体对象&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在框架实现层面六边形架构与分层架构其实并没有太多的差异，顶多就是在六边形中领域模型仅负责定义资源库接口，而将资源库的实现放到了基础设施层中。在使用了 Spring 等控制反转容器的项目中，一些宣称采用了分层架构的系统可能已经在无意间实现了六边形架构了。那么六边形架构的意义又是什么呢？我们在前文中曾引用了 IEEE 对「架构」的定义：组织、组件以及指导思想，然而很多时候我们都忽略了指导思想对软件开发行为的重要影响。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一个好的架构一定是包涵人性的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，架构思想直接决定了开发者分析业务的世界观和方法论。框架只是辅助工具，基于框架思想对业务进行抽象和设计而产出的代码才是一个软件系统的主要构成部分。即使采用相同的框架，在不同架构思想的引导之下，系统中的业务代码也可能会走向全然不同的迭代路线。而六边形架构与分层架构的差异正体现在二者对开发行为的指导思想上，六边形架构以领域模型为中心，引导开发者始终紧贴业务实际进行模型设计。它与 PICASO 框架相辅相成，让系统在应对高复杂度业务时依然能保持对业务规则的清晰表达。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_20&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;声明式数据操作既要规范又要灵活&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如前文所述，一个聚合会包含业务子域内的全部实体与值对象，资源库会维护这些业务实体的查询、映射及组装逻辑。但是并不是每一个领域服务都会用到聚合中的全部实体，如果每次获取聚合根时都将聚合内所有实体都查询出来，势必会造成极大性能损耗。然而资源库作为基础设施层中的底层组件，也不可能为每一个领域服务提供专用的聚合查询或者数据持久化接口。为了调和这两者之间的矛盾，我们在资源库实现上采用了声明式数据操作设计。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在《能力编排领域特定语言》章节中我们已经对声明式编程有了比较具象的体会，但声明式编程并不限定于领域特定语言这一种实现形式，在资源库的接口设计上我们采用了一种更加朴素的声明式编程实现方法。如下图所示，我们计划聚合的查询以及创意聚合的更新接口为例来阐述声明式数据操作的设计细节。当需要从资源库中获取聚合根对象时，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;默认情况下资源库库会自动查询聚合下所有子实体并完成组装，但是开发者可以再提供一个额外的辅助查询参数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，并通过该对象的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;addSubEntityQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;方法声明希望获取哪些特定的子实体&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。默认情况下资源库会根据聚合根对应的主表记录 ID 做子实体查询，如果开发者希望在子实体查询时使用额外的匹配条件，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;则可以通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;addSubEntityQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;方法同时声明希望获取的子实体类型以及执行该类型子实体查询时使用的额外匹配参数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，这一特性在与聚合根存在一对多的子实体查询场景中会发挥重要作用。上述声明式接口在资源库实现中并不复杂，只需要在执行每个子实体的查询或修改操作之前，判断一下上层调用方是否限定了仅对部分子实体进行操作，如果设置了则进一步判断当前子实体是否在上层调用方指定的子实体范围之内，如果当前子实体业务上允许调用方指定自定义的匹配逻辑，还需要尝试从辅助查询/修改参数中提取调用方为该子实体指定的自定义匹配逻辑。需要特别说明的是，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;我们不推荐在新架构内部各个模块之间采用任何形式的黑盒调用模式，不管是能力编排还是资源库调用，上层调用方都有责任和义务理清底层模块的内部执行逻辑，确保编排配置或调用参数设置正确&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//324f9467ff6988a231a7e8f8fc6ad173.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;基于资源库进行声明式聚合数据查询&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_21&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、新架构下的业务开发流程速览&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;span id=&quot;OSC_h2_22&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;业务建模&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新架构作为领域驱动设计思想的战术落地框架，能够让其发挥出最大价值的前提是对业务进行良好的领域建模，下图给出了广告投放平台中竞价及合约广告投放服务的业务架构。由于本文的主题聚焦在如何脚踏实地地实现一个基于领域驱动设计思想而设计的系统，因此关于 DDD 思想战略设计相关的内容本文将不做过多阐述，相关内容我们将在后续《领域驱动设计与 PICASO 框架》一文中进行详细阐述。需要说明的是，图中的聚合服务层、领域能力层及数据模型层共同构成了广告投放平台和核心领域模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//cdce0355a70e153d6d7759b82aa4f84b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;竞价及合约广告投放服务分层业务架构&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_23&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工程结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下图给出了新架构思想落地时工程结构的最佳实践案例，工程中各 module 的职责以及与上文中业务分层架构图中各层的对应关系依次为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-framework&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：框架包，承载架构标准规约及分层架构图中基础设施层中的各项基础组件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-module/rtbad-support-module&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：模型包，对应的是分层架构图中的模型层，承载领域模型中各个聚合及聚合实体对象的定义，另外用于实现底层存储介质中持久化数据与领域模型中实体对象映射逻辑的资源库也定义在此类 module 中。其中 support-module 定义的是支撑域中的实体对象，该 module 下会按照业务子域进一步进行子 module 划分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-event&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：事件包，属于特殊的数据模型层，承载这领域事件对象的定义，新架构底层融合了事件驱动架构（篇幅的关系我们会在其他文章中进行专门地介绍），因此事件体系建设也被纳入到统一建模的工作中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-composite/rtbad-support-compoaite&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：聚合服务包，对应分层架构中的领域能力及聚合服务层，承载领域能力及领域服务执行器的实现，其中 support-Composite 用于承载支撑域领域能力及领域服务执行器的实现，该 module 下会按照业务子域进一步进行子 module 划分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-app&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：部署层，内部分为不同的子 module，每一个子 module 对应一个部署应用，其实现逻辑就是根据应用职责组装底层各个子 module，进而实现不同应用下能力及模型共享。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-api&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：对外接口 SDK 包，承载了对外提供的 API 接口定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//293b49d270375f491db2ec28c2c6d461.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_24&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代码开发流程示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以下内容以一次计划新建请求为例，通过从流量入口到数据落库的完整请求流程展示使用新架构实现业务需求的全部过程，我们希望通过这个例子让大家建立对新架构的直观感受。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_25&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务统一入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务统一入口（Domain Service Faced）的作用是为 HTTP、RPC、MQ 等上层不同的请求流量暴露统一的服务入口。他将同一个业务子域内领域服务执行器集中到一起，便于流量介入层调用，同时也可以集中进行方法性能监控、调用量统计、请求日志记录等通用功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//d852396737c66f3b46df116a9366019e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_26&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务门面执行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务统一入口引用的是各个领域服务门面执行器，它负责从参数中提取业务标识并定位到具体的领域服务实例。如下图所示，所有具体的领域服务实例都继承自领域服务门面执行器，请求到来时领域服务门面先通过&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;generateRouteKey&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方法从当前参数中提取出本次请求的业务标识，然后与各个领域服务实例能够支持的业务标识做匹配，从而定位到应该处理本次请求的服务实例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//b72d14450dcf7d42a186a525c21b277c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_27&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域服务实例执行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力执行图的作用是定义业务执行流程，框架提供了丰富的 API 及大量的语法糖和默认规则，配合链式调用的风格，在支持灵活编排的同时减少了开发者的负担。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//48540f6a1eee1e5380df3a95b3861702.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_28&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域能力门面执行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;负责从参数中提取场景标识并定位具体的领域能力实例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//054a30e3192e2663263ac9768fe9572f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_29&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;领域能力实例执行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力内主要负责实现具体的业务规则，并对聚合根中相关属性进行设置/修改，一个领域服务编排的所有领域能力执行完成之后，就能获取一个完整的、全新的聚合根对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//135f836f9c6053353870b009efc3ba95.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_30&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展点的作用是作为任意维度的差异点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;补充分离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工具。需要注意的是在新架构中拓展点不是唯一的差异分离工具，在通用对象发现及路由机制下，领域服务、领域能力和拓展点都在不同维度上起着差异点分离的作用。相对与前两者拓展点更加灵活，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;通常用来承接领域服务及能力自身路由维度之外的逻辑差异&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。比如出价设置能力已经按照出价方式做了能力维度的差异分离，但是在相同的出价方式下，京准通与流量货币化还存在一些细微的逻辑差异，那么这个时候就可以在该能力实例中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;通过拓展点来补充实现平台维度的差异逻辑分离&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//da97e273087f8f10d775f90292607209.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面的例子是在计划名称设置能力中获取不同产品线计划名称长度上下限配置的拓展点，计划名称设置能力自身按照产品线类型进行业务模式路由，但是站内计划名称设置主要业务逻辑基本一致，仅在部分校验逻辑上不同产品线有各自的要求，此时就可以使用一个名称设置能力实例服务所有的站内产品线，定义名称设置主体业务规则，而把不同产品线的细微差异抽象成一个拓展点接口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_31&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;资源库&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上层业务通过声明式接口实现聚合实体读写操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//556b6d0d3fe119766a462ed65c36464e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//5c2f500826e1efb5546e9f51267fd22e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_32&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;五、结语&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;很多同学对业务开发一直存在一种偏见，认为业务开发很简单，甚至有业务开发同学自己也时常调侃自己是 CRUD 工程师，认为自己的工作没什么技术含量。但其实业务开发一点都不简单，只是过去我们一直把它做简单了。如今业务形态复杂多变，商机转瞬即逝，如何在快速变化着的复杂业务需求中维持系统健康、稳定、持续迭代，要做到这一点的难度其实一点都不比底层技术差。程序员应该是一门充满学术性与创造性的职业，我们唯有坚守初心，不断夯实自己的技术功底，沉淀提升抽象与建模能力，培养自己的系统化思维，不断学习精进，追求极致编码，这才是我们无法被 AI 替代的核心竞争力与价值所在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有同学可能会关注本文介绍 PICASO 框架未来是否可以对外共享，关于这个问题我们的答案是肯定的。在 PICASO 框架开发之初我们的野心就没有局限在京东广告投放平台这一个业务场景上，而是希望它可以走出广告部，甚至走出京东，接受全社会开发者的检验，成为一个被业界认可的复杂 B 端业务通用解决方案。然而作为一个一线业务团队，快速支持业务方需求是我们的首要职责。尽管我们在进行 PICASO 底层框架开发时尽力维持与具体业务分离的开发原则，但是在需求排期比较紧张的时候，为了快速支持业务需求的开发，还是存在将与广告投放业务相关的逻辑耦合到了 PICASO 框架底层源码中的情况。如果大家有兴趣阅读或者试玩 PICASO 的源码，请联系笔者为您开放一个示例版本的框架源码权限，该版本框架的功能与笔者负责的线上系统使用的框架功能完全相同，只是去除了广告投放业务相关的逻辑。您可以在该版本源码上执行任意的功能及性能测试，但是在我们对外发布正式的共享版本之前，我们并不建议您直接将该示例版本的源码应用到线上系统。目前框架功能已趋于稳定，我们也将 PICASO 框架的开源化改造提上日程，也欢迎感兴趣或者有开源社区维护经验的同学一起交流共建。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_33&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&amp;nbsp;&lt;/h1&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/18211828</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18211828</guid>
            <pubDate>Mon, 14 Apr 2025 03:05:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>JuiceFS v1.3-beta1：全面优化 SQL 数据库支持，十亿级元数据管理新选项</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;JuiceFS v1.3-beta 今天正式发布。在这个版本中，除了进行了大量使用体验优化和 bug 修复外，新增如下特性：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;新增 Python SDK&lt;/strong&gt;：这是一个从企业版移植过来的特性，旨在支持 FUSE 受限的场景，并优化某些高性能环境中的 I/O 性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Windows 客户端可用性大幅优化&lt;/strong&gt; ： 
  &lt;ul&gt; 
   &lt;li&gt;修复了 Windows 客户端在 Windows API 调用和用户身份管理等方面存在的多个兼容性问题。&lt;/li&gt; 
   &lt;li&gt;完善了工具支持，目前 debug、stat、info 等子命令已可在 Windows 平台下正常使用。&lt;/li&gt; 
   &lt;li&gt;新增了对 -d 参数的支持，使 JuiceFS 可以直接作为系统服务进行挂载，无需再借助第三方工具。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增二进制备份功能&lt;/strong&gt;：可在多种元数据引擎中实现高效的备份和导入。性能提升的同时，还显著降低了内存占用。在 TiKV 上备份亿级别的元数据时，所需时间仅为原 JSON 格式的十分之一。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;全面优化 SQL 支持&lt;/strong&gt;：涵盖事务处理、并发控制、连接管理和缓存优化等多个方面，显著提升 SQL 元数据的处理效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Apache Ranger&lt;/strong&gt;：引入了与 Apache Ranger 的集成，在大数据场景给用户提供更加灵活和细粒度的权限控制方案。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;除此之外，JuiceFS Gateway、sync 、元数据也有多项优化。本次版本更新，共有 xx 名贡献者参与，合入 xxx 次代码。感谢每位贡献者的付出！&lt;/p&gt; 
&lt;p&gt;在近期的博客中，我们将逐一为大家介绍这些特性的原理及应用。&lt;/p&gt; 
&lt;h2&gt;01 JuiceFS 元数据引擎简介&lt;/h2&gt; 
&lt;p&gt;元数据管理直接关系到文件系统的性能与稳定性，JuiceFS 提供对多种具备事务支持的引擎的兼容能力。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;文件型（如 SQLite） 适用於单机挂载的文件系统，适合百万级文件和以读取为主的场景。&lt;/li&gt; 
 &lt;li&gt;内存 KV 类型（如 Redis） 支持多点挂载，适合文件数在一亿以内的场景。&lt;/li&gt; 
 &lt;li&gt;SQL 数据库（如 MySQL、PostgreSQL） 支持多点挂载，适合文件总数在十亿以内的场景。&lt;/li&gt; 
 &lt;li&gt;分布式 KV（如 TiKV） 支持多点挂载，适合百亿级文件的场景。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其中，SQL 类数据库相较于其他类型的数据库，具备更强大的事务处理能力和一致性保障，且在企业核心应用中广泛使用，是 JuiceFS 的元数据存储的理想搭档。然而，由于 SQL 数据库的配置与调优相对复杂，使用者需具备一定的专业背景，这在一定程度上限制了其在社区中的普及。&lt;/p&gt; 
&lt;p&gt;JuiceFS 1.3 版本对 SQL 数据库的支持进行了全面的优化，涵盖事务处理、并发控制、连接管理和缓存优化等多个方面，显著提升 SQL 元数据的处理效率、系统稳定性和并发处理能力，使社区版在应对十亿级文件规模时表现更稳定高效。&lt;/p&gt; 
&lt;p&gt;接下来将围绕这些优化展开介绍，解析优化背后的设计思路与技术细节，并通过对比测试数据展示 JuiceFS 在 SQL 元数据模式下性能与稳定性的显著提升。&lt;/p&gt; 
&lt;h2&gt;02 简化事务请求，性能提升 20%+&lt;/h2&gt; 
&lt;h3&gt;事务处理机制优化 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5377&quot; target=&quot;_blank&quot;&gt;PR：#5377&lt;/a&gt; ）&lt;/h3&gt; 
&lt;p&gt;为了提升 SQL 元数据在高并发下的处理效率，我们首先对事务执行流程进行了详细梳理。JuiceFS 使用 ORM（Object-Relational Mapping）来操作数据库，以支持多种不同 SQL 元数据类型。在执行读写事务时，JuiceFS 要确保在同一事务内，重复执行同一个 SQL 查询时得到一致的结果，即数据库的事务隔离级别（简称 Isolation Level，要求 Repeatable Read），因此 JuiceFS 使用了事务模板来统一执行所有的 SQL 语句。一个事务模板通常会包含以下几个步骤（每一步都是一次命令交互，即一个网络来回）：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;从连接池取得数据连接或创建一个新连接&lt;/li&gt; 
 &lt;li&gt;设置事务隔离级别（通常是 set transaction_isolation 命令）&lt;/li&gt; 
 &lt;li&gt;开始事务（通常是 begin 或 start transaction 命令）&lt;/li&gt; 
 &lt;li&gt;执行第一个 SQL，并取得结果，进行相关处理&lt;/li&gt; 
 &lt;li&gt;执行第二个 SQL，并取得结果，进行相关处理&lt;/li&gt; 
 &lt;li&gt;事务提交（commit 命令）或事务回滚（rollback 命令）&lt;/li&gt; 
 &lt;li&gt;归还数据库连接到连接池&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;strong&gt;仔细梳理后，发现有较多的事务中包含单个 SQL 查询语句，这时其实不需要去设置事务隔离级别，也不需要执行开始事务命令、事务提交或回滚命令，以省去这些交互和网络来回&lt;/strong&gt;。基于此，我们为单个 SQL 增加了专门的处理模板，有效减少与 SQL 元数据的命令交互次数，减少网络来回，有利于提升文件系统访问性能，并有效减轻 SQL 元数据的压力。&lt;/p&gt; 
&lt;h3&gt;MySQL 事务机制优化（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5432&quot; target=&quot;_blank&quot;&gt;#5432&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;完成上一个优化后，我们发现不同的数据库对事务设置的实现存在差异。例如，要保证事务内同样的 SQL 查询返回同样的结果，将事务隔离级别设置为 Repeatable Read，PostgreSQL 中可以在开启事务的命令 (START TRANSACTION ISOLATION LEVEL REPEATABLE READ) 中指定当前事务隔离级别，无需额外的交互。&lt;/p&gt; 
&lt;p&gt;而 MySQL 则不能在开启事务的命令中指定，需要单独发送命令 (SET TRANSACTION_ISOLATION ...) ，进一步分析后，我们发现不需要在每个事务开始之前就指定事务隔离级别，只需要在连接建立后执行一次即可，从而避免了每次事务开始前重复设置隔离级别。此优化仅作用于 MySQL 元数据，进一步优化了事务处理机制的效率。&lt;/p&gt; 
&lt;p&gt;下面我们来简单验证一下效果，以 MySQL 元数据为例，我们通过查看名为 Questions 的全局统计指标（表示客户端收到网络交互请求次数）来评估性能。可以通过 show global status 命令来查询该指标，测试过程为：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;首次查询 MySQL 中当前的 Questions 统计值&lt;/li&gt; 
 &lt;li&gt;创建 10000 个文件，然后删除 10000 个文件&lt;/li&gt; 
 &lt;li&gt;再次查询 MySQL 中当前的 Questions 统计值，计算增量&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;测试脚本如下（仅供参考）：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

/usr/local/mysql/bin/mysql -u jfs -pjfs \
  -e &quot;show global status like &#39;question%&#39;&quot;

for f in {1..10000};
do
    touch testfile_${f}
done
rm -fr testfile_*

/usr/local/mysql/bin/mysql -u jfs -pjfs \
  -e &quot;show global status like &#39;question%&#39;&quot;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们通过比较 JuiceFS 1.23 和 1.3 版本下 Questions 指标增量值的差异，同样的业务逻辑及业务量的压测下，指标值下降表示有效地减少了网络交互。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6950168e2b95f9efc5154ca03a79628b1ea.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;从测试结果可以看出，Questions 指标减少了超过 50%，整体执行时间也缩短了约 30%。由于测试环境中 MySQL 与客户端部署在同一台机器，采用本地连接，网络交互优化的效果相对有限。&lt;strong&gt;如果在实际的网络环境中（即 MySQL 和客户端分别部署在不同主机），这一优化在执行时间上的提升将更加显著&lt;/strong&gt;。&lt;/p&gt; 
&lt;h2&gt;03 优化锁，10 倍提升单目录多并发性能&lt;/h2&gt; 
&lt;h3&gt;并发处理机制优化（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5460&quot; target=&quot;_blank&quot;&gt;#5460&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;在文件系统中，当创建或删除一个文件时，需要同时更新其所在目录的相关重要信息 (比如 NLINK 值)，并保证文件和目录操作的事务性。由于不同类型的元数据具有不同的事务并发能力，一些 Key-Value 类型的元数据的并发机制并不健壮，因此在 1.3 版本之前，系统统一在客户端进行目录级的并发控制，即操作一个文件时，同步锁定其所在目录，保证同一时间内同一目录只能有一个会话进行文件的创建或删除操作，这导致了大目录的并发能力比较弱。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;然而以 MySQL/PostgreSQL 为代表的 SQL 元数据有非常强的后端一致性保障能力，可以通过其原生的并发处理机制来提升大目录的并发性能&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;仍以目录的 NLINK 属性为例，在 Key-Value 中进行更新时，由于没有足够的后端保障，因此需要挂载点锁定目录，查询取得当前的 NLINK 值，然后加一或减一后再写回去。但当后端是 MySQL 或 PostgreSQL 时，可以使用 &quot;update ... set NLINK = NLINK + 1 where ...&quot; 这样的原子操作去维护 NLINK 属性，就不再需要提前锁定目录，从而可以极大地提升大目录的并发处理能力。&lt;/p&gt; 
&lt;p&gt;经过此优化后，1.3 版本的单目录并发能力可达之前版本的 10 倍以上。此优化仅对 MySQL 和 PostgreSQL 有效，其他非 SQL 类型的元数据依旧需要现有的客户端目录锁定保护机制。&lt;/p&gt; 
&lt;h3&gt;QUOTA 相关死锁优化 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5706&quot; target=&quot;_blank&quot;&gt;#5706&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;该问题由社区用户反馈，开启 QUOTA 限额功能时，系统会异步逐层向上统计各级目录的空间使用量，原先的逻辑未考虑到多个目录的更新顺序问题，在 1.3 版本中已经优化和完善逻辑，并且得到该用户的确认回复。&lt;/p&gt; 
&lt;p&gt;为了验证目录并发度的提升，下面我们使用 JuiceFS 客户端程序自带的 mdtest 工具来进行压测。测试中设置较小的目录深度，使用较高的并发和较大的单目录文件数。需要注意的是，此测试对 MySQL 的资源要求会比较高。压测命令如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./juicefs mdtest META_URL testdir1 --depth=1 --dirs=2 --files=5000 --threads 50 --write 8192
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;不同版本的测试结果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c6feb627003af889573b4d96e474e08c946.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到，1.3 相较于 1.23 版本有一倍以上的提升。由于是本地压测，并且使用了 50 个并发来测试三个目录，单目录的并发压力不算大，提升效果不算明显。如果是在网络环境中，并且使用更高的并发压测更少的目录，可以看到更明显的提升效果。&lt;/p&gt; 
&lt;p&gt;下面我们来测试 100 并发压测单个目录的情况，测试命令变更为：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./juicefs mdtest META_URL testdir1 --depth=0 --dirs=1 --files=1000 --threads 100 --write 8192
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-64ad094e470429805c826c08d647755b16d.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到提高并发减少目录后，1.3 相较于 1.23 的提升效果更明显。&lt;/p&gt; 
&lt;p&gt;接下来我们来测试元数据跨网络场景下的效果，测试结果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b687f93f5fa85427590f038845412ef0067.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到，在跨网络的场景下，1.3 版本中单目录高并发的吞吐是 1.23 版本的 5 倍左右，这时元数据所在机器的 8v CPU 被打满，如果提升资源规格，可以继续提升到 10 倍左右。欢迎广大社区用户在各自环境中多做压测并反馈测试结果。&lt;/p&gt; 
&lt;h2&gt;04 连接处理机制优化，灵活配置连接参数提升稳定性&lt;/h2&gt; 
&lt;h3&gt;数据库连接数控制 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5512&quot; target=&quot;_blank&quot;&gt;#5512&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;由于元数据需要事务支持，一个事务通常包含多个 SQL 请求，只有当所有 SQL 都处理完成后，数据库连接才能被归还到连接池。当客户端的文件操作并发比较高时，可能会创建非常多的数据库连接。&lt;strong&gt;大量连接和并发请求发送到数据库后端，可能对元数据服务的稳定性造成压力。考虑到一个文件系统可能有成百上千个客户端挂载点，数据库的连接总数可能会超出可以承受的极限&lt;/strong&gt;。因此，需要限制每个客户端的数据库连接数，并根据客户端数量合理配置数据库后端。为了应对这个挑战，JuiceFS 1.3 新增了 4 个 SQL Meta URL 选项，用来控制挂载点到数据库的连接行为：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;max-open-conns：限制到数据库的最大连接数&lt;/li&gt; 
 &lt;li&gt;max-idle-conns：最大的空闲连接数，超过将会主动断开一些连接&lt;/li&gt; 
 &lt;li&gt;max-idle-time：最长的连接空闲等待时间，如果一直和数据库无交互会主动断开连接&lt;/li&gt; 
 &lt;li&gt;max-life-time：连接生命周期，同一连接使用过久可能会有资源泄露，销毁可清理&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Go 语言的数据库交互 (database/sql) 模块提供了相关的 API 接口来设置这些特性，允许通过配置而不改动代码来控制数据库的连接行为。以 MySQL 元数据为例，我们在 Meta URL 中增加上述参数来控制挂载点到 MySQL 的最大连接数，这个示例中为 10：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mysql://jfs:jfs@(localhost:3306)/juicefs?max_open_conns=10
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这里的 Meta URL 格式就是数据库连接的 URL，更多的连接参数可以参考各数据库的 Go 驱动的实现文档，不同的数据库选项名称各不相同，Redis 和 TiKV 也有其特定的选项（可以查阅相关驱动的文档），可以用同样的方法来指定。&lt;/p&gt; 
&lt;h3&gt;优化 Dump 连接消耗（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5930&quot; target=&quot;_blank&quot;&gt;#5930&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;Dump 功能可用于在不同元数据引擎之间迁移数据，也是不同的文件系统之间迁移数据的重要手段。为了加快迁移效率，可以设定一个较大的并发线程数。此前，每个线程都会独占一个或多个数据库连接，容易导致线程数超出限制。1.3 版本对此进行了优化，使得在较少的数据库连接的情况下也能支持较大的并发操作。&lt;/p&gt; 
&lt;p&gt;下面我们使用前面的 mdtest 并发压测命令来测试连接数控制的效果。我们通过在 META_URL 中加入 max_open_conns 参数，验证连接数限制的实际效果。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-007c93a79eaf782a701c3058559208c5dfe.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;从上图可以看到，随着最大连接数从 5 提升到 20，系统吞吐能力稳步提升，文件创建性能也随之提高，说明合理配置数据库连接数有助于释放后端性能瓶颈，提升整体并发处理能力。&lt;/p&gt; 
&lt;h2&gt;05 缓存处理机制优化：减少元数据查询操作，提升整体性能 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5540&quot; target=&quot;_blank&quot;&gt;#5540&lt;/a&gt;）&lt;/h2&gt; 
&lt;p&gt;JuiceFS 支持客户端元数据缓存，可有效地减少对后端元数据的请求，特别是文件属性相关的缓存，简称 Attr Cache，当文件系统中文件数量非常多时，相关的请求量会激增，若缓存缺失或失效，都会给后端带来瞬间性能冲击。&lt;/p&gt; 
&lt;p&gt;在 1.3 版本中，我们优化了查找（ Lookup）和更新操作（SetAttr）流程，在进行这两项操作时，系统会主动用元数据中的最新版本去更新挂载点本地的 Attr Cache，使得后续 GetAttr 请求可以直接从 Attr Cache 命中，既有利于提升文件访问性能，又可减少数据库的查询请求次数，降低元数据的压力。此优化适用于所有元数据类型，不仅限于 SQL 数据库。&lt;/p&gt; 
&lt;p&gt;此外，1.3 版本还包含诸如错误重试等其他方面的优化，本文不再逐一展开。欢迎大家在实际场景中尝试使用 SQL 数据库作为 JuiceFS 的元数据引擎，体验这些优化带来的性能提升。&lt;/p&gt; 
&lt;p&gt;欢迎大家下载试用：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Freleases%2Ftag%2Fv1.3.0-beta1&quot; target=&quot;_blank&quot;&gt;https://github.com/juicedata/juicefs/releases/tag/v1.3.0-beta1&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;如果过程中有任何问题或建议，欢迎随时反馈。我们会持续改进！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/5389802/blog/18225885</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5389802/blog/18225885</guid>
            <pubDate>Mon, 14 Apr 2025 03:04:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>Skywork-R1V 2.0 版本再开源，最强高考数理解题利器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;继开源 Skywork-R1V 后，昆仑万维宣布再开源多模态推理模型的全新升级版本 —— Skywork-R1V 2.0（简称 R1V 2.0) 。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FbRiNf1Pseqw-2Ke89dzECg&quot; target=&quot;_blank&quot;&gt;公告&lt;/a&gt;称，Skywork-R1V 2.0 是当前最均衡兼顾视觉与文本推理能力的开源多模态模型，该多模态模型在高考理科难题的深度推理与通用任务场景中均表现优异，真正实现多模态大模型的「深度 + 广度」统一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;R1V 2.0 模型亮点&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;中文场景领跑：理科学科题目（数学/物理/化学）推理效果拔群，打造免费 AI 解题助手；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;开源巅峰：38B 权重 + 技术报告全面开源，推动多模态生态建设；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;技术创新标杆：多模态奖励模型（Skywork‑VL Reward） 与，混合偏好优化机制（MPO），全面提升模型泛化能力；选择性样本缓冲区机制（SSB），突破强化学习「优势消失」瓶颈。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;基准测试结果表明，R1V 2.0 相较于 R1V 1.0 在文本与视觉推理任务中均实现显著跃升。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 MMMU 上取得 73.6 分，刷新开源 SOTA 纪录；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 Olympiad Bench 上达到 62.6 分，显著领先其他开源模型；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 MathVision、MMMU-PRO 与 MathVista 等多项视觉推理榜单中均表现优异，多项能力已可媲美闭源商业模型，堪称当前开源多模态推理模型中的佼佼者。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在文本推理方面，在 AIME2024 和 LiveCodeBench 等挑战中，R1V 2.0 分别取得了 78.9 分和 63.6 分，展现出了人类专家级数学与代码理解能力。在与专用文本推理模型对比中，R1V2.0 同样展现出卓越的文本推理能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;283&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-19ec83a05eec133cf4d1f1ee9897c867194.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;268&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e8c7d47f1f723ff97ec34d4faa26ff841d6.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;279&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-4e7a8fda2f6aa075139d00fd84af2aaf444.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;R1V 2.0 引入了全新的「多模态奖励模型 Skywork-VL Reward」及「规则驱动的混合强化训练机制」。在显著增强推理能力的同时，进一步稳固了模型在多任务、多模态场景中的稳定表现与泛化能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Skywork-VL Reward 在多个权威评测榜单中表现优异：在视觉奖励模型评测榜单 VL-RewardBench 中取得了 73.1 的 SOTA 成绩，同时在纯文本奖励模型评测榜单 RewardBench 中也斩获了高达 90.1 的优异分数。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;259&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-186ca0a7f66bba76a2f6ff3cc4a3376554c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;254&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7ba89094b281dc63ef7700af2beb8c67b82.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，Skywork-VL Reward 也已完整开源。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，R1V 2.0 还引入了 MPO（Mixed Preference Optimization，混合偏好优化） 机制，并在偏好训练中充分发挥 Skywork-VL Reward 奖励模型的指导作用。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346297</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346297</guid>
            <pubDate>Mon, 14 Apr 2025 02:30:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>马斯克谈自动驾驶底层逻辑：不碰撞是第一要义</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;特斯拉公司副总裁陶琳日前在微博分享了一段特斯拉 CEO 马斯克谈论自动驾驶底层逻辑的视频。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;视频中马斯克表示，即便路上标识完全画错或者 UFO 突然降落在路上，汽车也不能撞上，并且要继续做正确的事。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「所以真正重要的，汽车自动驾驶的首要指令就是不能碰撞，这绝对优先于一切。所以不管标线怎么画，道路是怎么修的，自动驾驶系统需要做的事情就是最小化撞击的影响，同时便捷舒适地把你送到目的地。所以自动驾驶的绝对第一指令永远是，最小化对你自己、或路上其他行人和东西的伤害。所以它不能依赖道路标线正确与否之类的，而是无论发生什么，它都不会撞车」。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;386&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-966041b9b88f5f8cae9e577f93c4b8b6fc8.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346293</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346293</guid>
            <pubDate>Mon, 14 Apr 2025 02:23:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 发布全新图像模型 API：GPT-image-1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;OpenAI 今天&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAIDevs%2Fstatus%2F1915097067023900883&quot;&gt;发布&lt;/a&gt;了全新图像模型 API&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Findex%2Fimage-generation-api%2F&quot;&gt;GPT-image-1&lt;/a&gt;，已向全球开发者开放使用。&lt;/p&gt; 
&lt;p&gt;GPT-image-1 与 ChatGPT 版本有很大不同，可以控制生成图像的敏感度、生成效率、背景、输出格式、渲染质量、压缩质量等，并且支持全网爆火的吉卜力模式。目前，Adobe、Figma、HeyGen、Wix 等知名企业已经将该模型集成在产品中。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ce0e63bffbae1989752fc919881157be5af.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;GPT-image-1 模型亮点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;更精确、高保真图像&lt;/li&gt; 
 &lt;li&gt;多样化的视觉风格&lt;/li&gt; 
 &lt;li&gt;精确的图像编辑&lt;/li&gt; 
 &lt;li&gt;丰富的世界知识&lt;/li&gt; 
 &lt;li&gt;一致的文本渲染&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;价格方面，GPT-image-1 文本输入每百万 token 收费 5 美元。图像输入每百万 token 收费 10 美元，输出每百万 token 收费 40 美元。OpenAI 官方也给出了实际使用过程中产生的大致费用（一张方形图片）：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;低质量图像：约 0.02 美元&lt;/li&gt; 
 &lt;li&gt;中等质量图像：约 0.07 美元&lt;/li&gt; 
 &lt;li&gt;高质量图像：约 0.19 美元&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;需要注意的是，&lt;strong&gt;OpenAI&amp;nbsp;&lt;strong&gt;&lt;strong&gt;已经对新模型的&lt;/strong&gt;&lt;/strong&gt;API&lt;strong&gt;&lt;strong&gt;使用了全新身份验证。如果无法通过验证的小伙伴，可以使用微软的&amp;nbsp;&lt;/strong&gt;&lt;/strong&gt;Azure 云服务来体验&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;详细 API 指南：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fplatform.openai.com%2Fdocs%2Fguides%2Fimage-generation%3Fimage-generation-model%3DGPT-image-1&quot;&gt;https://platform.openai.com/docs/guides/image-generation?image-generation-model=GPT-image-1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346289/openai-image-generation-api</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346289/openai-image-generation-api</guid>
            <pubDate>Mon, 14 Apr 2025 02:18:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>机器人需要怎样的操作系统？</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在机器人技术飞速发展的今天，实时操作系统如何突破硬件碎片化与响应速度的桎梏？国产开源操作系统 RT-Thread 正以硬实时内核与模块化生态开辟新路径。本文专访嵌入式专家梁瑛健，揭秘其 3 微秒极速响应的技术内核，解析跨平台混合部署实战案例，并前瞻 AI 大模型与机器人深度融合背景下操作系统的进化方向，为开发者呈现智能时代机器人软件开发的破局之道。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本周六，梁瑛健也将出席【未来智造：机器⼈软件系统技术前沿】OSC 源创会·深圳站活动，并发表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;RT-Thread 为机器人软件系统赋能】主题演讲。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;议题简介：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;随着机器人应用场景的多样化与智能化，操作系统面临实时性不足、硬件碎片化、开发效率低下的问题。RT-Thread 作为国产开源实时性的操作系统，正通过「硬实时内核+模块化生态+全栈工具链」的独特优势，为机器人软件系统开发提供高效、灵活的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;报名入口：&lt;a href=&quot;https://www.oschina.net/event/8595590&quot;&gt;https://www.oschina.net/event/8595590&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：机器人场景对于操作系统有哪些特别的需求？RT-Thread 可以如何满足这些需求？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;机器人场景中，对于操作系统的需求最主要的是硬实时性、高模块化、跨平台兼容性和低功耗支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;比如硬实时性方面，其终端响应需要达到微秒级别。比如机器人在做一些高速运动时，或者是人形机器人在户外行走，传感器会采集很多数据，传感器数据采集后，就需要做大量运算，每毫秒进行多次判断决策，这就可能导致整体表现较慢。因此，整个的操作系统需依赖高算力及强实时&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;性，以便更快做出反应判断。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;像是路径规划场景中，若仅考虑从 A 点到 B 点的速度，而忽略其他因素，理论上运动速度可以很快。然而，现实场景中的路径规划需考虑更多步骤和因素。系统需检测是否存在障碍物，并根据障碍物情况做出反应和反馈，接着重新规划路径，以确保沿着最优路径行进。这就需要大量的运算。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;运算处理主要是机器人主控系统来处理。即便机器人配备了多种传感器，每个传感器都能快速传输数据，每毫秒可能产生多条传感采集数据，频率很高。但如果机器人的运算速度不够快，响应也会相应变慢，表现为整体动作迟缓。因此，机器人依赖主控系统的快速反馈，即接收数据、进行运算、得出结果并控制反馈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;RT-Thread 系统具有主控功能，其中断&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;响应时间可以达到 3 微秒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以内&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。相比之下，像 Linux 这样的大型系统，其中断响应时间可能是毫秒级别，甚至达到秒级。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;高模块化就是需要每个功能的单独模块或者组件可以任意裁剪、添加。RT-Thread 构建之初，就配备了较为丰富的中间件。其内核与组件是相互独立的，这是因为我们采用了标准的设备框架和统一的驱动外设。这样，每个功能都可以被单独划分为一个模块，根据需求进行裁剪和扩展，从而提高代码的复用性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;整体而言，RT-Thread 可以为机器人开发者提供国产开源、硬实时、模块化生态的操作系统，助力高效开发和灵活适配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：机器人硬件架构差异大，RT-Thread 是否可以实现跨平台兼容？能否举例说明某款机器人产品如何快速适配不同芯片？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;RT-Thread 通过模块化驱动框架和统一外设接口实现跨平台兼容，开发者无需过多关注底层芯片差异。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;比如某语音对话机器人原用 A 芯片，因缺货成本暴涨，快速切换至高性价比 B 芯片，业务代码几乎无需修改即可运行，依托 RT-Thread 的统一接口和模块化设计，大幅降低适配成本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：对比传统 ROS 或 FreeRTOS，RT-Thread 的优势在哪？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;简单易用：架构清晰，调试便捷，支持多种编译工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;跨平台支持：适配主流芯片，解决硬件碎片化问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;丰富中间件：提供多样化组件和软件包，减少重复开发。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;高可伸缩性：支持裁剪与扩展，提升代码复用性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本地化技术支持团队，项目上使用 RT-Thread 有任何问题，都可得到技术支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：能否分享一个 RT-Thread 在机器人领域的成功落地案例？以及目前 RT-Thread 应用比较多的是什么场景？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;某服务机器人项目需在多核处理器上混合部署 Linux 和 RT-Thread，以兼顾实时控制和复杂应用。我们通过采用 AMP 模式，Linux 运行原有应用，RT-Thread 负责高实时性运动控制，显著提升系统响应速度和稳定性，完美解决实时性瓶颈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们做过许多虚拟化混合部署的案例，即 Linux 系统与我们自主研发的 RT-Thread 相结合。这种混合部署方式允许运行原生的 Linux 应用，而 RT-Thread 系统则负责运动控制。因为将所有原有的应用迁移到 RT-Thread 并不现实，因此，虚拟化混合部署很好地解决了这个问题，通过多种系统协同工作。现在，高性能的 SoC 通常都是多核的，可以分配一些核心来运行原生的 Linux 应用，同时其他核心运行 RT-Thread 系统进行高性能的实时控制，这样显著提升了系统响应速度和稳定性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;具体到终端产品方面，我们主要做工业机械臂和服务机器人，比如教育行业的语音陪伴机器人，这类机器人不仅仅是一个教育工具，同时还具备运动控制功能，这使得它的实用性更强。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：随着 AI 与机器人深度融合，RT-Thread 未来是否会强化对 AI 框架或者大模型的支持？在智能化趋势下，操作系统需要哪些新能力？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;RT-Thread 已在强化 AI 支持，例如通过 LLVM 软件包简化 MCU 接入大模型的流程。比如我们控制一个机械臂，需要接入一个大模型。实际上，我们刚才提到的 RT-Thread 系统中有一个 LLVM&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;软件包，可以将这个软件包添加到机械臂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;控制系统中。这里需要实现的功能包括支持语音输入，即语音录入和播放功能。此外，机械臂的动作也需要根据交互指令来执行，例如通过语音控制直接抓取或移动到指定位置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;智能化趋势下，操作系统需提升：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;异构计算与 AI 加速：支持 AI 框架深度融合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;安全与隐私：强化数据保护机制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;多模态交互：支持语音、视觉等自然交互融合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：对于想尝试 RT-Thread 的机器人开发者，您建议从哪些功能模块入手？社区提供了哪些资源（如文档、开源项目）帮助他们快速上手？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;建议从 ROS 小车运动控制模块入手，简单易上手。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;社区资源：提供详细教程、API 文档、开源示例项目（如小车控制 demo），以及活跃的论坛和仓库，帮助开发者快速上手。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#2ea121&quot;&gt;问：您认为机器人行业需要怎样的操作系统生态？对开发者、芯片厂商和终端企业有何合作倡议？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;答：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;需要一个以技术创新为主，开放灵活、可持续的操作系统生态。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;合作倡议：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发者：勇于创新，驱动技术突破。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;芯片厂商：共建开放生态，统一标准。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:.0001pt; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;终端企业：以极致用户体验为目标，携手优化产品。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1604&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ddf62222d196dd18109835914dcfd21d4b7.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346287</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346287</guid>
            <pubDate>Mon, 14 Apr 2025 02:06:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Apache SeaTunnel MCP Server：让 AI 成为你的 ETL 助手</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#4183c4&quot;&gt;Apache SeaTunnel MCP Server&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#4183c4&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;🎯 如何使用&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#4183c4&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;🚀 如何配置&lt;/span&gt;&lt;span style=&quot;color:#4183c4&quot;&gt;前置条件&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#4183c4&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;❓帮助与支持&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;SeaTunnel MCP Server，可以将 SeaTunnel 的接口文档提供给 Cursor 等支持 AI 编程的 IDE，或其他支持 MCP 的 AI 工具。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;有了 SeaTunnel MCP Server，开发者就可以通过 AI 助手完成以下工作：根据跟用户交互实现 RESTful API V2 的接口调用，至于通过这个接口文档数据能让 AI 干什么更多更强大的活，请发挥你和你们团队的想象力😜&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span&gt;🎯 如何使用&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;完成配置后，SeaTunnel MCP Server 会自动获取 &lt;/span&gt;&lt;span&gt;&lt;code&gt;ST2.3.9&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 接口文档的数据并缓存在本地，AI 助手可以通过 MCP 读取接口文档数据。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你只要告诉 AI 你想要做什么即可，示例：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;查看当前 SeaTunnel 连接 URL &lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;更新 URL 为 http://127.0.0.1:8080&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我提交个作业,配置如下：格式是 hocon&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;span&gt;env {&lt;/span&gt;
&lt;span&gt;  job.mode = &quot;batch&quot;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt; &lt;/span&gt;
&lt;span&gt;source {&lt;/span&gt;
&lt;span&gt;  Jdbc {&lt;/span&gt;
&lt;span&gt;        url = &quot;jdbc:hive2://***:10000/default&quot;&lt;/span&gt;
&lt;span&gt;        user = &quot;***&quot;&lt;/span&gt;
&lt;span&gt;        password = &quot;***&quot;&lt;/span&gt;
&lt;span&gt;        driver = &quot;org.apache.hive.jdbc.HiveDriver&quot;&lt;/span&gt;
&lt;span&gt;        connection_check_timeout_sec = 100&lt;/span&gt;
&lt;span&gt;        query = &quot;select * from table1 limit 100&quot;&lt;/span&gt;
&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;transform {&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;sink {&lt;/span&gt;
&lt;span&gt;    Jdbc {&lt;/span&gt;
&lt;span&gt;        url = &quot;jdbc:mysql://***:23306/?rewriteBatchedStatements=true&quot;&lt;/span&gt;
&lt;span&gt;        driver = &quot;com.mysql.cj.jdbc.Driver&quot;&lt;/span&gt;
&lt;span&gt;        user = &quot;root&quot;&lt;/span&gt;
&lt;span&gt;        password = &quot;root&quot;&lt;/span&gt;
&lt;span&gt;        &lt;/span&gt;
&lt;span&gt;        database = &quot;test&quot;&lt;/span&gt;
&lt;span&gt;        table = &quot;table1&quot;&lt;/span&gt;
&lt;span&gt;        # primary_keys = [&quot;key1&quot;, &quot;key2&quot;, ...]&lt;/span&gt;
&lt;span&gt;        schema_save_mode = &quot;CREATE_SCHEMA_WHEN_NOT_EXIST&quot;&lt;/span&gt;
&lt;span&gt;        data_save_mode=&quot;DROP_DATA&quot;&lt;/span&gt;
&lt;span&gt;        generate_sink_sql=true&lt;/span&gt;
&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我查一下 957461773944946690 的运行情况，注意这里的 &lt;/span&gt;&lt;span&gt;&lt;code&gt;957461773944946690&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 是上一步提交作业随机生成的 jobId&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我查一下正在运行的作业有哪些？&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我查一下 FINSHED 的作业有哪些&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;查看集群的运行情况&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我返回系统系统监控信息&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;帮我把 957461773944946690 作业停掉&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;h2&gt;&lt;span&gt;🚀 如何配置&lt;/span&gt;&lt;/h2&gt; 
  &lt;h3&gt;&lt;span&gt;前置条件&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;已安装 Python 环境（版本号 &amp;gt;= 3.12，推荐最新的 LTS 版本）&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;已安装 Apache SeaTunnel （版本号&amp;gt;=2.3.9）&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;任意一个支持 MCP 的 IDE：&lt;/span&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;Cursor&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p style=&quot;margin-left:.5rem; margin-right:0&quot;&gt;&lt;span&gt;VS Code + Cline 插件&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;安装：&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;span&gt;&lt;span style=&quot;color:#aa5500&quot;&gt;# 下载源码&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style=&quot;color:#3300aa&quot;&gt;git&lt;/span&gt; clone https://github.com/ocean-zhc/seatunnel-mcp.git&lt;/span&gt;
&lt;span&gt;&lt;span style=&quot;color:#aa5500&quot;&gt;# 进入目录（比如我的下载目录：/Users/ocean/Downloads/MCP/seatunnel-mcp）&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style=&quot;color:#3300aa&quot;&gt;cd&lt;/span&gt; seatunnel-mcp&lt;/span&gt;
&lt;span&gt;&lt;span style=&quot;color:#aa5500&quot;&gt;# 安装&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;pip install &lt;span style=&quot;color:#0000cc&quot;&gt;-e&lt;/span&gt; .&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;配置：&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt;
   &lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这里的 SEATUNNEL_API_URL 是你部署好的 ui 地址，后面不要带 /&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;
  &lt;/blockquote&gt; 
  &lt;pre&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;    &lt;span style=&quot;color:#000000&quot;&gt;&quot;mcpServers&quot;&lt;/span&gt;: {&lt;/span&gt;
&lt;span&gt;        &lt;span style=&quot;color:#000000&quot;&gt;&quot;seatunnel&quot;&lt;/span&gt;: {&lt;/span&gt;
&lt;span&gt;            &lt;span style=&quot;color:#000000&quot;&gt;&quot;command&quot;&lt;/span&gt;: &lt;span style=&quot;color:#aa1111&quot;&gt;&quot;python&quot;&lt;/span&gt;,&lt;/span&gt;
&lt;span&gt;            &lt;span style=&quot;color:#000000&quot;&gt;&quot;args&quot;&lt;/span&gt;: [&lt;/span&gt;
&lt;span&gt;                &lt;span style=&quot;color:#aa1111&quot;&gt;&quot;-m&quot;&lt;/span&gt;,&lt;/span&gt;
&lt;span&gt;                &lt;span style=&quot;color:#aa1111&quot;&gt;&quot;src.seatunnel_mcp&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;            ],&lt;/span&gt;
&lt;span&gt;            &lt;span style=&quot;color:#000000&quot;&gt;&quot;cwd&quot;&lt;/span&gt;: &lt;span style=&quot;color:#aa1111&quot;&gt;&quot;/Users/ocean/Downloads/MCP/seatunnel-mcp&quot;&lt;/span&gt;,&lt;/span&gt;
&lt;span&gt;            &lt;span style=&quot;color:#000000&quot;&gt;&quot;env&quot;&lt;/span&gt;: {&lt;/span&gt;
&lt;span&gt;                &lt;span style=&quot;color:#000000&quot;&gt;&quot;SEATUNNEL_API_URL&quot;&lt;/span&gt;: &lt;span style=&quot;color:#aa1111&quot;&gt;&quot;http://127.0.0.1:8080&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;            }&lt;/span&gt;
&lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;&lt;/pre&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;配置完成之后，如下图：&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;&lt;img alt=&quot;Image&quot; src=&quot;https://oscimg.oschina.net/oscnet//6d4e7b03673025b2249f52f9864d33ab.jpg&quot; width=&quot;619&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;操作视频：（推荐 YouTube，bilibili 非大会员清晰度不够）&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;bilibili: &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1UXZgY8EqS&quot; target=&quot;_blank&quot;&gt;https://www.bilibili.com/video/BV1UXZgY8EqS&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;youtube： &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DbA91Vc8WGR8&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=bA91Vc8WGR8&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;h2&gt;&lt;span&gt;❓帮助与支持&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;可前往 issue 进行提问： &lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fseatunnel%2Fissues%2F9047&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Support MCP&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;项目首页：&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; text-align:justify&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Focean-zhc%2Fseatunnel-mcp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Apache SeaTunnel MCP&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346283</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346283</guid>
            <pubDate>Mon, 14 Apr 2025 01:20:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>超 95% 租户高频使用、日均接口调用量超 2000 万，飞书项目正式发布开放平台</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#000000; text-align:start&quot;&gt;4 月 23 日，飞书项目于北京举办主题为「开放生态，无限生长」的开发者日活动，并正式发布飞书项目开放平台，以更深度地开放平台能力，赋能合作伙伴解决复杂业务场景。值得一提的是，在正式发布前，基于该平台的开放能力，飞书项目已与合作伙伴在规模化敏捷（SAFe）及汽车软件过程改进及能力评定（ASPICE）两大专业领域展开深度合作，并成功落地了标杆解决方案，充分验证了开放平台赋能复杂场景的潜力。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;活动现场，飞书项目还推出了助力开发者的万「项」更新计划，旨在携手更多伙伴共建繁荣生态。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:center&quot;&gt;&lt;img alt=&quot;image.png&quot; height=&quot;433&quot; src=&quot;https://oscimg.oschina.net/oscnet//37e4b9167e9242f048b18ae9033f19f2.png&quot; width=&quot;676&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;&lt;strong&gt;由表及里开放，赋能开发者共创价值&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;「从飞书项目诞生的第一天起，我们就定位这是一个开放式的产品，可以说，开放一直是飞书项目的初心。」飞书产品副总裁洪涛在会上强调了飞书项目「有态度、有能力、有价值、有空间」的开放理念。正是这份初心，驱动飞书项目不断深化其开放能力。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;在开放平台正式发布前，飞书项目已经通过与部分客户和伙伴的深度合作，「内测」其开放能力的潜力。飞书项目开放平台产品负责人杨澍介绍：「我们观察到超过 95% 的租户每天都在高频使用开放能力，日均接口调用量超 2000 万次。这充分说明了企业核心团队在项目管理中对深度定制和系统联动的天然需求，也更加坚定了我们全面开放的决心。」&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;过去 3 年，上千家客户选择飞书项目，涉及领域从单一的软件研发场景发展至涵盖整车、硬件制造、新零售、政企、文娱等上百个行业及细分领域，客户需求量更是每年都在翻倍。为了提供更加定制化、精准的解决方案，飞书项目选择充分开放，与合作伙伴共创。杨澍提到：「我们实现了从表及里的全面开放。无论是页面级的深度定制、精细到每个环节的流程控制，还是跨系统的自动化联动，飞书项目开放平台都提供了高度灵活和强大的支持。」此外，包括在线付费、解决方案级生态能力、FaaS 服务等一系列赋能伙伴经营与开发的进阶能力，将于今年内陆续上线，进一步降低伙伴的开发门槛，加速价值创造。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:center&quot;&gt;&lt;img alt=&quot;image.png&quot; height=&quot;381&quot; src=&quot;https://oscimg.oschina.net/oscnet//a3f20e52bfda5d12d1bee50c2de118fa.png&quot; width=&quot;680&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;飞书项目开放平台的价值已在锐捷网络等企业实践中得到充分验证。作为最早与飞书项目 IPD 行业专版共创的客户，锐捷网络已基于飞书项目构建起完整的一体化平台。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;「借助飞书项目的开放能力，我们做了一件很关键的事——把飞书项目打造成集团级的数据交换枢纽。」锐捷网络 IPD 数字化负责人冯子陵分享道，「通过它，我们串联起各业务系统的数据脉络，建立了完整的项目管理数据版图。」他指出，这一做法帮助锐捷网络 IT 部门平均缩短系统开发周期 10 天，按单工具节省 2 万元计算，总体开发成本降低超 200 万元。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;&lt;strong&gt;深耕复杂场景，发布 SAFe 及 ASPICE 两大解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;正是基于这种深度开放与伙伴共创的模式，飞书项目在此次开发者日上，重点展示了两大基于生态能力构建、并已取得显著成效的标杆解决方案——规模化敏捷（SAFe）解决方案和飞书项目 ASPICE 解决方案。这两大成果不仅彰显了飞书项目深耕复杂场景的决心，更是其开放平台价值的有力证明。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;ASPICE（「汽车软件过程改进及能力评定」 Automotive Software Process Improvement and Capacity dEtermination）如今已是全球新能源与智能驾驶领域供应商的准入门槛，比如某德系车企要求供应商必须达到 L2 级以上认证才能参与竞标。飞书项目与合作伙伴高远科技共同打造的 ASPICE 解决方案，已在两家头部汽车供应链企业成功落地，帮助汽车软件研发周期缩短 10%-20%。「以飞书项目为底座，借助飞书项目强大的开放能力，消除工具孤岛，建立完整追溯链，让 ASPICE 认证不再是成本黑洞，而是企业打开全球市场的加速器。」高远科技创始人张会斌高度评价。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;同时，由规模化敏捷中国社群发起人李建昊发布的飞书项目 SAFe 解决方案，也展示了惊人的效率提升。「团队在飞书项目上接入 PI planning，团队依赖导致的延期情况可从 55% 降低到 15%，实现 40 个百分点的效率提升。」李建昊指出，该方案通过纵横打通，构建了立体的价值交付「生态」。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;&lt;strong&gt;万「项」更新计划发布，携手伙伴共建共赢&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;开放生态的构建离不开合作伙伴的积极参与。目前，飞书项目已与轮动科技、高远科技等多家伙伴共创插件生态，上线了「工时资源管理」、「ASPICE」等多款付费插件。「我们首个插件付费客户 ARR 达到了 6 万元，这对新上线的 ISV 是很好的开端。」飞书项目首家 ISV 伙伴轮动科技 CEO 王品在现场分享，并呼吁更多伙伴加入。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;为进一步激发伙伴热情，飞书生态总经理刘子华正式发布了针对飞书项目伙伴的扶持计划——万「项」更新计划。该计划将为入选伙伴提供三大核心权益：高达 12 个月的平台使用权益、从技术到培训的全方位方案共创支持、以及官方流量扶持和联合营销资源。飞书项目希望以此鼓励更多垂直领域的专业伙伴加入，共同封装和推广高价值的行业解决方案。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:center&quot;&gt;&lt;img alt=&quot;image.png&quot; height=&quot;393&quot; src=&quot;https://oscimg.oschina.net/oscnet//dcac22152670e9702ce3155a4d04174a.png&quot; width=&quot;695&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;「我们期望与生态伙伴们携手。以生态之力，助力每一个组织在数字化时代乘风破浪，真正实现飞书的宏大愿景 。」刘子华在活动现场表示。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:start&quot;&gt;据悉，飞书项目起源于字节跳动的研发实践，专为企业复杂项目管理需求而设计。自 2021 年正式对外商业化以来，从互联网到汽车制造、消费电子、金融、医疗健康、新消费等各行各业，已经有上千家客户选择了飞书项目。&lt;/p&gt; 
&lt;p style=&quot;color:#000000; text-align:center&quot;&gt;&lt;img alt=&quot;image.png&quot; height=&quot;398&quot; src=&quot;https://oscimg.oschina.net/oscnet//cbe1e3f1b7bffb76a25c11b62095d5ee.png&quot; width=&quot;691&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346225</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346225</guid>
            <pubDate>Sun, 13 Apr 2025 11:00:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>中国电信立项业界首个 DevSecOps 国际标准提案</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;国际电信联盟电信标准部门第 17 研究组（ITU-T SG17）全会日前在瑞士日内瓦召开，中国电信研究院牵头的国际标准立项提案 &lt;em&gt;ITU-T X.gdso-cs「Guidelines of development, security and operations (DevSecOps) for cloud services」（云服务研发安全运营一体化（DevSecOps）指南）&lt;/em&gt;正式获批立项，成为业界首个 DevSecOps 国际标准立项。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0423/182827_kh2I_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;DevSecOps 是一种应对云服务迭代速度快、合规挑战复杂等问题的实践方法，通过将安全能力深度嵌入软件开发与运维（DevOps）全流程，实现安全左移和原生安全能力构建。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346215</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346215</guid>
            <pubDate>Sun, 13 Apr 2025 10:32:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>xAI 的 Grok 聊天机器人支持实时视觉功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;据 Techcrunch 报道，&lt;strong&gt;xAI 已为 Grok 聊天机器人增加视觉功能 Grok Vision&lt;/strong&gt;，帮助用户解答关于摄像头所见内容的问题。&lt;/p&gt; 
&lt;p&gt;升级之后，Grok 移动端用户可以将手机对准产品、标志和文件等物体，并提出相关问题。Grok Vision 目前仅支持 iOS 版 Grok 应用。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b1db3344291b4e8787adf1e686b6f23a2d4.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d91298927f4eabcf29649dfe6e075f74213.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此外，Grok 今天还推出了包括多语言音频和 Grok 语音模式下的实时搜索等其他新功能。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346212/xais-grok-chatbot-can-now-see-the-world-around-it</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346212/xais-grok-chatbot-can-now-see-the-world-around-it</guid>
            <pubDate>Sun, 13 Apr 2025 10:13:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>