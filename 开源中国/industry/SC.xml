<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 23 Jun 2025 07:43:30 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>MiniMax 宣布 Hailuo Video Agent 开启 Beta 公测</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniMax 宣布旗下视频创作 Agent 产品——Hailuo Video Agen&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FyphAy5SDzmOzUsNB21lsvA" target="_blank"&gt;t 已开放 Beta 版本&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-118191fd968c50acaec868448d58c4508b0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，在 Hailuo Video Agent 中，为了提供足够大的创意空间，且保证好的质量， MiniMax 做了以下设计：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;抛弃传统工作流+节点的工具模式，通过 LLM 语言模型的工具调用能力，创新性地支持用户在自然语言描述中构建完整视频；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;打造视频构思、资料收集、分镜制作、剪辑、配音等视频制作全流程工具集，并通过 Agent 模型在不同阶段实现自动调用。为了提高短片创作的质量，我们遴选了所有视频创作需要的最佳工具集；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Agent 思维链可视化，用户实时查看 Agent 创作流程，为自定义编辑功能提供可视窗口与操作空间。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Web 端登录 https://hailuoai.com/ 即可体验。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356853</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356853</guid>
      <pubDate>Mon, 23 Jun 2025 07:41:28 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>图挖掘在反作弊场景的应用</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;本文全面探讨了营销活动反作弊与电商反作弊的图算法应用。首先介绍了黑产薅取活动奖励、刷单等作弊行为的背景，随后深入讲解了同人挖掘技术，包括同人建模、挖掘步骤及稳定性处理。接着，依次介绍了标签传播算法、Fraudar 算法、GCN 网络的原理、优缺点及应用。最后，文章展望了未来图算法在风控反作弊应用的发展方向，如多模态数据融合与动态图实时计算，旨在应对黑产的快速演化，确保营销活动的公平性与数据真实性。&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;01 业务背景&lt;/h1&gt; 
&lt;p&gt;在营销活动场景中，黑产团伙通过自动化手段大规模获取活动奖励，挤占真实用户权益造成营销资金浪费，并污染数据指标导致活动效果失真，从而影响运营决策准确性。&lt;/p&gt; 
&lt;p&gt;以当前主流作弊模式为例，黑产实施路径如下：&lt;/p&gt; 
&lt;p&gt;1. 资源准备阶段：通过虚拟机登录批量购买的百度账号。&lt;/p&gt; 
&lt;p&gt;2. 任务执行阶段：部署自动化脚本模拟用户行为，如视频播放、广告点击等。&lt;/p&gt; 
&lt;p&gt;3. 资金变现阶段：使用分散的真实微信账号进行提现操作。&lt;/p&gt; 
&lt;p&gt;在与反作弊的对抗中，黑产工具持续升级（如改机工具、IP 池轮换等），传统特征采集数据趋于分散。我们的反作弊体系从两个方向不断提升防御能力：&lt;/p&gt; 
&lt;p&gt;1. 多维特征挖掘，包括设备指纹、行为特征以及环境特征。&lt;/p&gt; 
&lt;p&gt;2. 关联团伙分析，包括用户操作模式量化、暱称相似度分析以及基于账号-设备-提现账户等信息建立关联图谱。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-b567c76d759b133c58127296b4127e848a9.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上图为云手机工具示例。&lt;/p&gt; 
&lt;p&gt;在电商场景中，存在着类似于营销活动的批量团伙作弊，典型的即刷单。刷单作弊即非真实有购买需求的用户（机器或众包真人）为了提升店铺的销量、评分，替店铺虚假的下单、评价，然后收取店铺报酬的一种作弊方式。&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;02 同人挖掘&lt;/h1&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.1 同人建模&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;黑产为了节省成本往往存在账号、设备共用的情况，因此我们定义「同人」概念：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;若参与活动的账号、设备背后的主体相同，则为一个同人团伙。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在账号之外，增加一个同人粒度进行数据监控和风险控制。例如，某人使用 5 个手机号分别注册 5 个 uid，并使用 2 个身份证进行实名认证，每天在 3 个设备上参与活动，并将收益提取到 2 个微信账号中，我们希望通过构图将其归类为一个同人团伙。&lt;/p&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 同人挖掘&lt;/h3&gt; 
&lt;p&gt;挖掘步骤可分为以下 3 步：&lt;/p&gt; 
&lt;p&gt;1. 以用户百度账号为节点，共设备 ID/手机号/提现 ID/身份证号（加密）为边构图&lt;/p&gt; 
&lt;p&gt;2. 挖掘极大连通子图，即有边的强连通判为同人关系&lt;/p&gt; 
&lt;p&gt;3. 在多天参与活动的用户上挖掘同人关系，并与历史挖掘结果进行拼接，做同人 ID 稳定性处理&lt;/p&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 稳定性处理&lt;/h3&gt; 
&lt;p&gt;在与历史同人结果拼接时，可将情况分为以下几类：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-ab1a6ef3b27b0b9b955c9dc6b8740c0fc75.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;经过稳定性处理后，整体同人 ID 稳定性达 96.8%，排除已知合并等不稳定因素稳定性达 99.3%。&lt;/p&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.2 挖掘结果&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;由于线上已有一对多业务规则，同人团伙会采用多对多打散以绕过规则。&lt;/p&gt; 
&lt;p&gt;以下展示部分典型团伙构图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-7ce79c7f88211177a7133e1a96d8e3daec7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.3 同人应用&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;作弊识别&lt;/strong&gt;&lt;/strong&gt;：按照团大小逐渐收敛，从同人作弊株连、团内作弊风险浓度高、同人且有作弊风险几个思路进行策略迭代。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;发放打压&lt;/strong&gt;&lt;/strong&gt;：对于作弊风险较低的羊毛党用户，业务侧可根据情况进行奖励发放打压。&lt;/p&gt; 
&lt;span id="OSC_h1_8"&gt;&lt;/span&gt; 
&lt;h1&gt;03 标签传播算法及其应用&lt;/h1&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.1 标签传播算法&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;标签传播算法（Label Propagation Algorithm，LPA）是一种基于图的&lt;strong&gt;&lt;strong&gt;半监督&lt;/strong&gt;&lt;/strong&gt;学习算法，常用于社区检测和节点分类任务。它通过迭代传播标签信息，利用数据结构的相似性来推断未知节点的标签。&lt;/p&gt; 
&lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.1 算法流程&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;：图&lt;span class="math-tex"&gt;\(G=(V,E)\)&lt;/span&gt;，已知标签节点集合&lt;span class="math-tex"&gt;\(V_L\)&lt;/span&gt;，未知标签节点集合&lt;span class="math-tex"&gt;\(V_U\)&lt;/span&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;：所有节点预测标签&lt;span class="math-tex"&gt;\({\{y_i\}}_{i\in V}\)&lt;/span&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;初始化阶段&lt;/strong&gt;：为每个已标记节点&lt;span class="math-tex"&gt;\(v\in V_L\)&lt;/span&gt;分配固定标签&lt;span class="math-tex"&gt;\(y_v\)&lt;/span&gt;，为每个未标记节点&lt;span class="math-tex"&gt;\(v\in V_U\)&lt;/span&gt;随机分配标签（或按先验分布分配）。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;迭代传播阶段&lt;/strong&gt;：对于每个未标记节点，将出现频率最高的邻居标签作为自己的新标签。&lt;/p&gt; 
&lt;p&gt;定义&lt;span class="math-tex"&gt;\(N(v)\)&lt;/span&gt;为节点&lt;span class="math-tex"&gt;\(v\)&lt;/span&gt;的邻居集合，&lt;span class="math-tex"&gt;\(y_v^{(t)}\)&lt;/span&gt;为节点&lt;span class="math-tex"&gt;\(v\)&lt;/span&gt;在迭代&lt;span class="math-tex"&gt;\(t\)&lt;/span&gt;时的标签，Ⅱ为指示函数（当&lt;span class="math-tex"&gt;\(y_u=l\)&lt;/span&gt;时为 1，否则为 0）。&lt;/p&gt; 
&lt;p&gt;无权图标签更新规则&lt;span class="math-tex"&gt;\(y_v^{(t+1)} = \argmax_l \displaystyle\sum_{u\in N(v)} \Pi(y_u^{t}=l)\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;加权图标签更新规则&amp;nbsp;&lt;span class="math-tex"&gt;\(y_v^{(t+1)} = \argmax_l \displaystyle\sum_{u\in N(v)} w_{uv} \cdot\Pi(y_u^{t}=l)\)&lt;/span&gt;，其中&lt;span class="math-tex"&gt;\(w_{uv}\)&lt;/span&gt;为边权重。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;终止条件&lt;/strong&gt;：当迭代不再改变任何节点的标签时；或达到最大迭代次数。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-9f71c1149e2ddfb7d9ae359bbdbcd6fc955.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上图为标签传播示例。&lt;/p&gt; 
&lt;span id="OSC_h3_11"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.2 实践细节&lt;/h3&gt; 
&lt;p&gt;最高频率标签不唯一时：随机选择（结果可能不稳定），或结合其他信息（如节点度数等）。&lt;/p&gt; 
&lt;p&gt;传播顺序：同步更新（所有节点同时更新，可能振荡），或异步更新（按随机或度排序等顺序逐个更新）。&lt;/p&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.3 无监督改进&lt;/h3&gt; 
&lt;p&gt;在&lt;strong&gt;&lt;strong&gt;完全无监督&lt;/strong&gt;&lt;/strong&gt;的情况下，仍然可以通过改进方法实现社区检测或聚类任务。面对局部最优问题，使用模块度作为目标函数多次运行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;算法流程：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1. 随机初始化所有节点的标签（如 1 到 K，K 为社区数）&lt;/p&gt; 
&lt;p&gt;2. 执行标准 LPA 迭代，直到收敛，计算模块度 Q&lt;/p&gt; 
&lt;p&gt;3. 重复多次，选择模块度最高的划分结果&lt;/p&gt; 
&lt;p&gt;模块度指标的核心思想：社区内部的连接应显著高于随机情况&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(Q = \frac{1}{2m} \sum_{i,j}\Big[A_{ij}-\frac{k_ik_j}{2m}\Big]\delta(c_i,c_j)\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;其中&lt;span class="math-tex"&gt;\(A_{ij}\)&lt;/span&gt;为邻接矩阵元素（节点&lt;span class="math-tex"&gt;\(i\)&lt;/span&gt;和&lt;span class="math-tex"&gt;\(j\)&lt;/span&gt;相连时为 1，否则为 0），&lt;span class="math-tex"&gt;\(k_i\)&lt;/span&gt;为节点&lt;span class="math-tex"&gt;\(i\)&lt;/span&gt;的度数，&lt;span class="math-tex"&gt;\(m\)&lt;/span&gt;为图中总边数&lt;span class="math-tex"&gt;\(m=\frac{1}{2}\sum_iki\)&lt;/span&gt;，&lt;span class="math-tex"&gt;\(c_i\)&lt;/span&gt;节点&lt;span class="math-tex"&gt;\(i\)&lt;/span&gt;所属的社区，&lt;span class="math-tex"&gt;\(\delta(c_i,c_j)\)&lt;/span&gt;若&lt;span class="math-tex"&gt;\(c_i=c_j\)&lt;/span&gt;则为 1，否则为 0。&lt;/p&gt; 
&lt;span id="OSC_h3_13"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.4 算法优缺点&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1. 计算高效：每轮迭代复杂度&lt;span class="math-tex"&gt;\(O(|E|)\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2. 无需参数调优：完全基于图结构&lt;/p&gt; 
&lt;p&gt;3. 自然并行化：节点更新可并行执行&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;局限性：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1. 结果可能不稳定：受初始化顺序影响&lt;/p&gt; 
&lt;p&gt;2. 仅利用拓扑结构：忽略节点特征信息&lt;/p&gt; 
&lt;p&gt;3. 对稀疏图效果差：邻居信息不足时传播受限&lt;/p&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.2 在营销活动场景的应用&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;在营销活动场景中，黑产在资源准备和任务执行阶段存在批量化的账号生成和活动行为，在挖掘结果中也经常发现存在暱称、行为序列等相似的聚集特征。&lt;/p&gt; 
&lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.1 构图&lt;/h3&gt; 
&lt;p&gt;以用户账号为节点，以暱称与活动点位行为序列为例，分别采用针对字符串、序列相似度的建边算法。&lt;/p&gt; 
&lt;p&gt;暱称相似度：两两计算用户暱称的编辑距离，编辑距离越小说明两个暱称越相似。&lt;/p&gt; 
&lt;p&gt;序列相似度：拼接用户活动点位（活动行为类型标记）-时间作为行为序列，将序列中的打点转换为词频矩阵，使用 MinHash 估计 Jaccard 相似度。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;实践细节&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;1. 预处理，如做暱称长度分桶、异常用户筛选等，减少相似度计算量。&lt;/p&gt; 
&lt;p&gt;2. 使用局部敏感哈希（LSH）进行优化，减少搜索空间。&lt;/p&gt; 
&lt;p&gt;3. 可结合业务场景做相似度阈值过滤，缩减构图输入。&lt;/p&gt; 
&lt;span id="OSC_h3_16"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.2 团伙挖掘&lt;/h3&gt; 
&lt;p&gt;使用无监督的 LPA 算法进行团伙挖掘，设定团伙阈值、或结合业务场景添加其他特征进行作弊识别。&lt;/p&gt; 
&lt;p&gt;下表为实际应用中，通过用户行为序列相似挖掘出的一个团伙部分数据，其设备和地域并不聚集，但暱称可看出为批量操作。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-cd8efca074b9009b15bde0cbb5f30c8cc46.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;04 Fraudar 算法及其应用&lt;/h1&gt; 
&lt;p&gt;在电商场景中，用户-店铺之间天然形成一种二部图的结构，二部图是指图中的节点有两类、边有一类，两类节点互相连接，每类节点本身之间没有连接。Fraudar 算法是一种适用于二部图结构的算法，下文详细介绍我们在电商场景的应用。&lt;/p&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;4.1 Fraudar 算法原理&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_19"&gt;&lt;/span&gt; 
&lt;h3&gt;4.1.1 全局可疑度度量&lt;/h3&gt; 
&lt;p&gt;Fraudar 定义了一个全局度量&lt;span class="math-tex"&gt;\(g(S) = \frac{f(S)}{|S|}\)&lt;/span&gt;，其中：&lt;br&gt; ● &lt;span class="math-tex"&gt;\(f(S) = f_v(S) + f_{\epsilon}(S)\)&lt;/span&gt;：子网络&lt;span class="math-tex"&gt;\(S\)&lt;/span&gt;中节点的可疑度之和（&lt;span class="math-tex"&gt;\(f_v\)&lt;/span&gt;）与边的可疑度之和（&lt;span class="math-tex"&gt;\(f_{\epsilon}\)&lt;/span&gt;）；&lt;br&gt; ● 假设在一个用户-商品二部图中，那么&lt;span class="math-tex"&gt;\(f_v(S)\)&lt;/span&gt;可以理解为用户或商品的独立可疑度，&lt;span class="math-tex"&gt;\(f_{\epsilon}(S)\)&lt;/span&gt;可以理解为用户在商品下的订单/评论的可疑度。&lt;br&gt; ● &lt;span class="math-tex"&gt;\(|S|\)&lt;/span&gt;：子网络的规模（节点数）。&lt;br&gt; &lt;span class="math-tex"&gt;\(g(S)\)&lt;/span&gt;表示一个网络的平均可疑度，满足以下四个属性：&lt;/p&gt; 
&lt;p&gt;1. （节点可疑度）当节点总数、边可疑度保持一致时，由较高可疑度的节点组成的网络比由较低可疑度节点组成的网络更可疑。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(|S| = |S'| \land f_{\epsilon}(S) = f_{\epsilon}(S') \land f_v(S) &amp;gt; f_v(S') \Rightarrow g(S) &amp;gt; g(S')\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;2. （边可疑度）其他条件不变，在网络中添加边会增加该网络的可疑度。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(e \notin \epsilon \Rightarrow g(S(v, \epsilon \cup \{e\})) &amp;gt; g(S(v, \epsilon))\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;3. （大小）假设节点和边的权重都相等，边的密度也相等，那么更大的网络比小的网络更可疑。其中边的密度$\rho(S)$定义为网络中的边数除以它可能的最大边数。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(|S| &amp;gt; |S'| \land S \supset S' \land \rho(S) = \rho(S') \Rightarrow g(S) &amp;gt; g(S')\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;4. (集中度) 较小的网络比相同总可疑度但规模更大的网络更可疑。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(|S| &amp;lt; |S'| \land f(S) = f(S') \Rightarrow g(S) &amp;gt; g(S')\)&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_20"&gt;&lt;/span&gt; 
&lt;h3&gt;4.1.2 抗伪装设计&lt;/h3&gt; 
&lt;p&gt;即使虚假账户添加大量正常连接（伪装），算法仍能通过识别局部密集子网络发现异常，因为伪装行为会导致整体网络稀疏化，而欺诈子网络仍保持高密度。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-12ea6c9656a0117fc3f04e647772db3cd0d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上图是虚假账户常用的伪装方法，假设为用户-商品网络，那么（a）刷单用户通过向正常商品随机下单伪装；（b）刷单用户通过向正常商品添加有偏的伪装；（c）刷单用户劫持一些正常账户。&lt;/p&gt; 
&lt;p&gt;算法使用了列权重作为边权的方式来抗伪装，即利用商品的边数来定义边权。在一个用户商品图中，算法先确定商品节点的数量，利用 1/log(商品节点边数+5) 确定边权 （边可疑度），然后按照边权汇总求取商品节点、用户节点的权重（节点可疑度）。&lt;/p&gt; 
&lt;span id="OSC_h3_21"&gt;&lt;/span&gt; 
&lt;h3&gt;4.1.3 算法实现流程&lt;/h3&gt; 
&lt;p&gt;利用列权重定义边权能够抵抗虚假账户向正常商品增加边的伪装，因为是往正常商品增加边，不会影响欺诈商品的边数，也即三种伪装方式的欺诈块仍然是高权重的/密集的。而如果使用行权重，那么一个用户通过向正常商品增加边，就可以稀释自己的欺诈边的可疑度，达到伪装的目的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-3f0893250a1894485d2ba5248e81434106c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上图是 Fraudar 算法的步骤。迭代移除当前优先级最高的节点（可疑度贡献最低的节点），逐步缩小网络规模，直至所有节点被移除。每一步记录剩余子网络的全局可疑度&lt;span class="math-tex"&gt;\(g(S)\)&lt;/span&gt;。在所有迭代步骤中，&lt;span class="math-tex"&gt;\(g(S)\)&lt;/span&gt;值会先增大后减小，算法保留每一步的迭代结果，选择&lt;span class="math-tex"&gt;\(g(S)\)&lt;/span&gt;达到最大值的子网络作为最可疑的欺诈团伙。&lt;/p&gt; 
&lt;p&gt;由于遍历删除图中可疑度最低的节点是个&lt;span class="math-tex"&gt;\(O(|V|^2)\)&lt;/span&gt;的操作（迭代&lt;span class="math-tex"&gt;\(|V|\)&lt;/span&gt;次，每次找到可疑度最低的节点&lt;span class="math-tex"&gt;\(O(|V|)\)&lt;/span&gt;），因此算法引入了优先树（小顶堆），叶子节点对应图中的节点，父节点记录子节点中的最高优先级，以此实现快速访问和更新优先级。优化后算法需要迭代边数次，每次查找和更新节点优先级的复杂度变为&lt;span class="math-tex"&gt;\(O(log|V|)\)&lt;/span&gt;，算法的总时间复杂度为&lt;span class="math-tex"&gt;\(O(|\epsilon| log|V|)\)&lt;/span&gt;。&lt;/p&gt; 
&lt;p&gt;另外，在实际应用中，只获得可疑度最大的子图可能并不够用，可以在获取一个可疑度最大子图后将其中原始图中删除，然后再在剩余的图中获取次可疑的子图，循环往复得到多个可疑子图。&lt;/p&gt; 
&lt;span id="OSC_h3_22"&gt;&lt;/span&gt; 
&lt;h3&gt;4.1.4 优缺点及改进方向&lt;/h3&gt; 
&lt;p&gt;优势：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1. 抗伪装能力&lt;/strong&gt;&lt;/strong&gt;通过全局度量而非局部密度，算法能抵抗虚假账户添加正常连接的行为，即使部分节点被「污染」，仍能准确识别核心欺诈簇。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 高效性与可扩展性&lt;/strong&gt;&lt;/strong&gt;利用优先树结构优化节点移除操作，时间复杂度为&lt;span class="math-tex"&gt;\(O(|\epsilon| log |V|)\)&lt;/span&gt;，适用于大规模网络。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3. 实际应用场景&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;电商刷单检测&lt;/strong&gt;&lt;/strong&gt;：识别虚假评论形成的密集用户-商品子网络。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;社交网络反欺诈&lt;/strong&gt;&lt;/strong&gt;：检测伪卡交易或虚假关注关系。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;金融反洗钱&lt;/strong&gt;&lt;/strong&gt;：发现异常交易团伙。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;4.2 Fraudar 算法应用&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-928573e7eca9a5c3ce222a41201de5f7d3a.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_24"&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.1 构图与关系降噪&lt;/h3&gt; 
&lt;p&gt;实践中，我们利用用户-店铺的订单关系构建二部图，并且为了提升二部图中的风险浓度，对低风险店铺等做了剪枝实现关系的降噪，然后输入 Fraudar 算法挖掘异常子图。&lt;/p&gt; 
&lt;p&gt;原始的 Fraudar 算法只能挖掘出风险最高的一个子图，但实际业务中，一般不止一个作弊团伙，因此我们在每次运行 Fraudar 算法产生一个子图后，就将这个子图从原始图中裁剪掉，再次运行 Fraudar 算法得到次可疑的子图，即循环 Fraudar。通过这种方法，我们可以获得期望数量的异常子图。&lt;/p&gt; 
&lt;span id="OSC_h3_25"&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.2 结合监督模型&lt;/h3&gt; 
&lt;p&gt;挖掘出的风险子图由用户和店铺构成，而实际业务的识别目标是订单，且风险子图中会掺杂少量正常用户的订单。为了进一步提升算法识别结果的准确率，我们将挖掘出的风险子图输入到 LR 模型进行精细判别。LR 模型使用用户、店铺的特征作为输入，异常订单为正样本、正常订单为负样本训练，最后在风险子图的用户、店铺的订单上区分出异常订单并落地到业务。&lt;/p&gt; 
&lt;span id="OSC_h1_26"&gt;&lt;/span&gt; 
&lt;h1&gt;05 GCN 模型及其应用&lt;/h1&gt; 
&lt;p&gt;上文提到 Fraudar 模型为了提升图的风险浓度做了剪枝降噪，这样提升算法精准的同时会损失一部分召回。并且 Fraudar 本身是无监督模型，还需要结合监督模型做精细化判别。因此我们尝试了端到端的 GCN 模型，提升召回的同时简化了识别链路。&lt;/p&gt; 
&lt;span id="OSC_h2_27"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;5.1 GCN 模型原理&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_28"&gt;&lt;/span&gt; 
&lt;h3&gt;5.1.1 GCN 的核心思想：消息传递与聚合&lt;/h3&gt; 
&lt;p&gt;GCN 的核心是通过邻域聚合更新节点特征，其本质是让每个节点从邻居节点中提取有效信息：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1. 基础聚合公式：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(H^{(l+1)} = \sigma\left(\hat{D}^{-1/2} \hat{A} \hat{D}^{-1/2} H^{(l)} W^{(l)}\right)\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;其中：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span class="math-tex"&gt;\(\hat{A} = A + I\)&lt;/span&gt;：邻接矩阵加入自连接，防止节点自身信息丢失。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span class="math-tex"&gt;\(\hat{D}\)&lt;/span&gt;：度矩阵的对称归一化，解决节点度数差异导致的权重偏差。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span class="math-tex"&gt;\(W^{(l)}\)&lt;/span&gt;：可学习的权重矩阵，用于特征变换，即卷积核。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span class="math-tex"&gt;\(H^{(l)}\)&lt;/span&gt;：激活值，对于输入层可以理解成特征矩阵。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 关键设计：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;归一化：通过&lt;span class="math-tex"&gt;\(\hat{D}^{-1/2} \hat{A} \hat{D}^{-1/2}\)&lt;/span&gt;避免度数高的节点主导信息传播，使模型更稳定。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;非线性激活：如 ReLU 函数，增强模型的表达能力。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_29"&gt;&lt;/span&gt; 
&lt;h3&gt;5.1.2 数学视角：从拉普拉斯矩阵到频谱域卷积&lt;/h3&gt; 
&lt;p&gt;GCN 的理论基础源自图谱理论，通过将图信号转换到频域进行卷积操作，核心概念：&lt;/p&gt; 
&lt;p&gt;1. 拉普拉斯矩阵：定义为&lt;span class="math-tex"&gt;\(L = D - A\)&lt;/span&gt;，其特征分解&lt;span class="math-tex"&gt;\((L = U \Lambda U^T)\)&lt;/span&gt;将图结构映射到频域空间。&lt;/p&gt; 
&lt;p&gt;2. 图傅里叶变换：利用特征向量矩阵&lt;span class="math-tex"&gt;\(U\)&lt;/span&gt;对节点特征进行频域投影，卷积操作简化为频域的乘积。&lt;/p&gt; 
&lt;p&gt;a. 卷积定理：函数卷积的傅里叶变换是函数傅里叶变换的乘积，即对于函数&lt;span class="math-tex"&gt;\(f(t)\)&lt;/span&gt;与&lt;span class="math-tex"&gt;\(h(t)\)&lt;/span&gt;两者的卷积是其函数傅里叶变换乘积的逆变换。&lt;br&gt; b. 图傅里叶变换把图上定义的任意向量，表示成了拉普拉斯矩阵特征向量的线性组合。&lt;/p&gt; 
&lt;p&gt;3. 切比雪夫近似：为降低计算复杂度，GCN 采用一阶近似（仅考虑直接邻居），公式退化为经典聚合形式。&lt;br&gt; 第一代 GCN：将输入特征通过图傅里叶变换从空域映射到谱域，做卷积运算后再映射回空域。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(Y = U \cdot g_\theta(\Lambda) \cdot U^T X\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;第二代 GCN：利用切比雪夫多项式近似&lt;span class="math-tex"&gt;\(g_\theta(\Lambda)\)&lt;/span&gt;，避免&lt;span class="math-tex"&gt;\(O(N^3)\)&lt;/span&gt;复杂度的拉普拉斯矩阵分解。&lt;br&gt; 卷积核用 K 阶段切比雪夫多项式展开：&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(g_\theta(\Lambda) = \sum_{k=0}^K \theta_k T_k(\tilde{\Lambda})\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;最终 GCN 公式：&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(Y = \sum_{k=0}^K \theta_k T_k(\tilde{L}) X\)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;第三代 GCN：只保留一阶切比雪夫多项式，并加入自环和归一化。&lt;/p&gt; 
&lt;p&gt;&lt;span class="math-tex"&gt;\(H^{(l+1)} = \sigma \left( \hat{A} H^{(l)} W^{(l)} \right)\)&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_30"&gt;&lt;/span&gt; 
&lt;h3&gt;5.1.3 模型结构：轻量化与高效性&lt;/h3&gt; 
&lt;p&gt;GCN 的典型结构通常仅需 2-4 层即可完成高效学习，原因在于：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1. 层数限制&lt;/strong&gt;&lt;/strong&gt;：过深的网络会导致&lt;strong&gt;&lt;strong&gt;过平滑（图中同一连通分量的节点特征趋同）&lt;/strong&gt;&lt;/strong&gt;，因此实践中常用浅层架构。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 参数共享&lt;/strong&gt;&lt;/strong&gt;：每层共享权重矩阵，大幅减少参数量，适合处理大规模图数据。（相对于一个节点一个权重矩阵的全连接形式）&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3. 应用场景&lt;/strong&gt;&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;节点分类&lt;/strong&gt;&lt;/strong&gt;（如电商刷单用户检测）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;图分类&lt;/strong&gt;&lt;/strong&gt;（如分子属性判断）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;链接预测&lt;/strong&gt;&lt;/strong&gt;（如推荐系统好友关系推断）&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_31"&gt;&lt;/span&gt; 
&lt;h3&gt;5.1.4 GCN 的优缺点与改进方向&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1. 优势&lt;/strong&gt;&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;天然融合图结构与节点特征，适合复杂关系建模。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;计算高效，支持稀疏矩阵优化。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 局限&lt;/strong&gt;&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;过平滑问题&lt;/strong&gt;&lt;/strong&gt;：深层网络性能下降。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;strong&gt;静态图假设&lt;/strong&gt;&lt;/strong&gt;：难以处理动态变化的图结构。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_32"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;5.2 GCN 模型应用&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_33"&gt;&lt;/span&gt; 
&lt;h3&gt;5.2.1 构图&lt;/h3&gt; 
&lt;p&gt;利用订单作为节点、订单之间的属性关联关系构建同构图。特征上采用用户、 店铺等风险属性刻画订单，异常订单为正样本、正常订单为负样本。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-e413211583231cf96809e8be84b96306075.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_34"&gt;&lt;/span&gt; 
&lt;h3&gt;5.2.2 风险订单挖掘&lt;/h3&gt; 
&lt;p&gt;由于实际业务中有标签的风险订单、正常订单仅是全量订单的一小部分，因此我们采用了半监督的方式训练 GCN 模型，利用有标签的订单对无标签的订单进行推理。GCN 模型设计上针对的是静态图，应用中我们采用了随着时间窗口滚动构图的方式来适应动态变化的数据，滚动过程中排除了 GCN 模型本身推理的标签，防止对模型自身结果过拟合。&lt;/p&gt; 
&lt;p&gt;这里解释下，为什么我们不采用一个训练好的模型在线上不断的推理，而是滚动的训练推理。这是因为 GCN 模型从原理上属于直推式模型，通常的训练好一个模型后不断的对新数据推理的模型是归纳式模型。GCN 的直推式，本质上是因为卷积计算用到了图的拉普拉斯矩阵，图发生了变化，那么这个拉普拉斯矩阵也就发生变化，训练的模型也就失效了。&lt;/p&gt; 
&lt;p&gt;既然 GCN 是直推式的，这里又产生一个问题，为什么我们不使用归纳式模型呢？事实上，我们对比了 GraphSage 等模型在同样图结构、特征数据上的效果，在我们的场景中比 GCN 效果差，为了保证业务效果我们最终采用的是 GCN。&lt;/p&gt; 
&lt;span id="OSC_h1_35"&gt;&lt;/span&gt; 
&lt;h1&gt;06 总结和展望&lt;/h1&gt; 
&lt;p&gt;在风控反作弊的业务中，我们落地了 LPA、Fraudar、GCN 等算法并取得了良好的效果，未来我们希望做的更多。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1. 多模态数据融合：从单一图谱到全域关联&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;未来风控需整合图数据、时序数据（如交易频率）、文本数据（如聊天记录）等多模态信息。例如，通过图嵌入技术将设备、IP、地理位置等实体统一表征，构建全域风险画像。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2. 动态图实时计算：应对黑产快速演化&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当前黑产通过「少边构造」（刻意断开部分关联）绕过静态图检测，需引入动态图算法（如时序 GNN）实时捕捉行为演变，并结合增量计算优化性能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3. 可解释性与对抗防御：提升算法可信度&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;探索可视化工具（如子图归因分析）解释 GCN 决策逻辑，并研发对抗训练技术抵御黑产对模型的逆向攻击。&lt;/p&gt; 
&lt;p&gt;图算法正从「辅助工具」升级为风控系统的核心引擎，而未来的挑战在于如何平衡技术效能、业务合规与用户体验。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18627800</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18627800</guid>
      <pubDate>Mon, 23 Jun 2025 07:22:28 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>中国软件基因库 Gitee，如何扛起民营科技企业时代使命</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;当今世界格局，全球化退火，大国博进入弈白热化，内循环成为主战场，在此百年未有之大变局下，民营企业必须「跟随国家战略」，成为国家「政府、国企、民企战略共同体」中的重要一员，才能分享新一轮政策与市场红利。&lt;/p&gt; 
&lt;p&gt;开源中国于 2013 年发布代码托管平台 Gitee，是国内领先的代码托管服务平台，并于 2020 年牵头建设工信部国家开源托管平台项目。Gitee 于 2017 年上线发布针对企业级的研发效能平台 Gitee 企业版。同时，开源中国自 2020 年起开始深耕 DevOps 全生命周期产品国产替代方案，在满足开发者需求的同时，打造出一个自主创新、安全可信的本土开源软件工具与生态，减少开发者对海外开源软件的过度依赖，构建安全可控的中国信息化体系。&lt;/p&gt; 
&lt;p&gt;Gitee 以「国家代码库备份」和「国产替代」双核驱动，扛起民营科技企业的时代使命：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;span style="color:#e67e22"&gt;国家代码库备份：&lt;/span&gt;&lt;/strong&gt;构建国内最大、最安全、最全量的开源代码备份网络，承担「国家级软件基因库」职责。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&lt;span style="color:#e67e22"&gt;国产替代先锋：&lt;/span&gt;&lt;/strong&gt;深度兼容国际前沿技术生态，坚持走信创自主可控道路，实现从源码托管到 DevOps 工具链的全流程国产替代。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;以备份能力筑牢「数字长城」&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;「备份战略下的产业复制和转移」是未来民企获取红利的重要通道。Gitee 的「多中心异地容灾、多维度镜像同步」体系，正是这一战略在代码领域的具象化：&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;千万仓库一键同步：&lt;/strong&gt;&lt;/span&gt;&amp;nbsp;与 GitHub、GitLab 等全球主流平台实时镜像，同步延迟低于数分钟，解决境外访问不稳、政策风险及突发故障带来的断链隐患。&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;数据主权·安全可控：&lt;/strong&gt;&amp;nbsp;&lt;/span&gt;完全自主研发的加密存储与访问控制，从底层保障代码资产的主权与机密性。&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;智能完整性检测：&lt;/strong&gt;&amp;nbsp;&lt;/span&gt;引入 AI 驱动的代码健康扫描，定期校验、自动修复，构筑「代码防火墙」，确保备份仓库的可用性与可信度。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/163359_FY3B_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/163412_u877_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;深耕 DevOps 全生命周期国产替代&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;新一轮「国产替代」浪潮正加速推进，民企要「成为国家战略性新兴产业的先锋」 。Gitee 立足国产基础设施，自 2020 年以来，深耕 DevOps 全生命周期国产替代方案，在满足开发者需求的同时，打造出一个自主创新、安全可信的本土开源软件工具与生态，减少开发者对海外开源软件的过度依赖，构建安全可控的中国信息化体系。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/163442_nIuC_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/163451_0aZV_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;全链路国产化：&lt;/strong&gt;&lt;/span&gt;从托管、CI/CD、制品仓库到安全审计、项目管理，提供与国际同级、符合合规要求的一站式开发运营平台。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;生态互联互通：&lt;/strong&gt;&lt;/span&gt;与阿里云、华为云、腾讯云等国产云厂商深度集成，构建覆盖操作系统、数据库、网络安全等全栈国产软件图谱。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;本土化社区运营：&lt;/strong&gt;&lt;/span&gt;用中文场景深度激励高校与企业工程师参与开源，培养中国软件创新的「基因土壤」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;展望未来：让 Gitee 成为中国软件基因银行&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;作为中国开源基础设施奠基者，开源中国运营着 1800 万开发者聚集的 &lt;a href="https://oschina.net/"&gt;oschina.net&lt;/a&gt; 社区及代码托管平台 Gitee，服务 36 万企业级用户。开源中国自主研发的 DevOps 工具链已在金融、军工等关键领域实现 80% 市场渗透率，成为信创替代工程的标杆案例，验证了开源商业化的中国路径。&lt;/p&gt; 
&lt;p&gt;2024 年，开源中国推出对标 HuggingFace 的 AI 大模型平台 "模力方舟 (&lt;a href="https://ai.gitee.com/" target="_blank"&gt;moark.com&lt;/a&gt;)"，首创 "模型数据 - 算力调度 - 应用开发" 全栈服务体系。&lt;/p&gt; 
&lt;p&gt;平台已实现三大突破：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;生态开放化&lt;/strong&gt;：&lt;/span&gt;聚合数万开源模型，打造 AI 应用创新基座；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;服务一体化&lt;/strong&gt;：&lt;/span&gt;提供从模型体验、推理训练到应用部署的全生命周期服务；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;算力国产化&lt;/strong&gt;：&lt;/span&gt;完成多家国产 GPU 深度适配，成功运行 DeepSeek-V3 等千亿级模型。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;开源中国下一步将以模力方舟为核心，打造全方位的 AI 业务布局，助力 AI 应用创新、科技人才培养和新质生产力提升。在「十四五」「十五五」规划与「碳中和」「数字中国」等国家战略的交汇期，Gitee 将继续：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;升级备份体系&lt;/strong&gt;：&lt;/span&gt;引入更智能的灾备演练与灾后恢复机制，让「国家级代码基因库」永不缺席。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;引领国产替代&lt;/strong&gt;：&lt;/span&gt;与更多国产厂商共建联动机制，推动开发工具、语言运行时、操作系统等关键层面全面国产化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style="color:#e67e22"&gt;&lt;strong&gt;深耕社会价值&lt;/strong&gt;：&lt;/span&gt;在稳就业、促消费方面持续发力，让技术创新与社会发展形成良性循环。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;让我们携手，把握「备份与国产替代」的时代脉搏，让 Gitee 不仅是「中国版 GitHub」，更是中国软件基因库的守护者与创新引擎，共筑数字中国新未来！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356519</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356519</guid>
      <pubDate>Fri, 20 Jun 2025 14:01:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Linux libblockdev 本地提权漏洞</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h2&gt;漏洞描述&lt;/h2&gt; 
&lt;p&gt;libblockdev 是 Linux 上用于块设备管理的底层库，提供统一接口支持分区、文件系统、LVM 和加密等操作。udisks 是基于 D-Bus 的服务，封装调用 libblockdev 等工具，为桌面环境和应用程序提供挂载、格式化等存储管理功能。&lt;/p&gt; 
&lt;p&gt;受影响版本中，libblockdev 在挂载磁盘分区时遗漏 nosuid 安全标志，导致可在挂载点执行具备特殊权限（如 root 权限）的文件。攻击者拥有 allow_active 权限时，可利用该缺陷挂载恶意文件并执行，进而获取 root 权限。&lt;/p&gt; 
&lt;p&gt;由于 libblockdev 默认在较多 Linux 发行版中提供，该漏洞影响 Ubuntu、Debian、Fedora、openSUSE 等主流发行版，但由于 allow_active 权限限制，通常难以单独利用，在 SUSE 系统中可结合 CVE-2025-6018 漏洞可将 ssh 远程低权限用户提升为 allow_active 用户实现远程利用。&lt;/p&gt; 
&lt;p&gt;修复版本通过弃用系统默认挂载选项，显式添加 nosuid 和 nodev，防止本地提权漏洞。&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;漏洞名称&lt;/th&gt; 
   &lt;th&gt;Linux libblockdev 本地提权漏洞&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;漏洞类型&lt;/td&gt; 
   &lt;td&gt;权限管理不当&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;发现时间&lt;/td&gt; 
   &lt;td&gt;2025-06-19&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;漏洞影响广度&lt;/td&gt; 
   &lt;td&gt;-&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;MPS 编号&lt;/td&gt; 
   &lt;td&gt;MPS-mqf0-usbi&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;CVE 编号&lt;/td&gt; 
   &lt;td&gt;CVE-2025-6019&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;CNVD 编号&lt;/td&gt; 
   &lt;td&gt;-&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h2&gt;影响范围&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;libblockdev-lvm-dbus@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-lvm-dbus@影响所有版本&lt;/li&gt; 
 &lt;li&gt;python3-blockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;python3-blockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-crypto@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-dm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-btrfs-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-kbd@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-lvm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mpath@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mpath-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-crypto-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-btrfs@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-kbd-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-loop@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mdraid@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mdraid-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-nvdimm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-plugins-all@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-swap@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-dm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-fs@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-fs-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-loop-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-nvdimm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-lvm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-part@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-s390@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-swap-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-part-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-utils@影响所有版本&lt;/li&gt; 
 &lt;li&gt;python2-blockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-s390-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-vdo@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-utils-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-vdo-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-btrfs@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-btrfs-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-fs-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-loop-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mdraid-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-part@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-s390@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-crypto@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-crypto-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-kbd-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-loop@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mpath-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-nvdimm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-kbd@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-lvm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mpath@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-dm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-dm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-fs@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-lvm-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-mdraid@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-nvdimm@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-plugins-all@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-part-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-s390-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-utils@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-vdo-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-utils-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;python2-blockdev@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-swap-devel@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-vdo@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev-swap@影响所有版本&lt;/li&gt; 
 &lt;li&gt;libblockdev@(-∞, 2.30)&lt;/li&gt; 
 &lt;li&gt;libblockdev@[3.0, 3.2.2)&lt;/li&gt; 
 &lt;li&gt;libblockdev@[3.3.0, 3.3.1)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;修复方案&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;将组件 libblockdev 升级至 2.30 及以上版本&lt;/li&gt; 
 &lt;li&gt;将组件 libblockdev 升级至 3.2.2 及以上版本&lt;/li&gt; 
 &lt;li&gt;将组件 libblockdev 升级至 3.3.1 及以上版本&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;参考链接&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oscs1024.com%2Fhd%2FMPS-mqf0-usbi" target="_blank"&gt;https://www.oscs1024.com/hd/MPS-mqf0-usbi&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fstoraged-project%2Flibblockdev%2Fcommit%2F4e35eb93e4d2672686789b9705623cc4f9f85d02" target="_blank"&gt;Commit&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;    &lt;/p&gt; 
&lt;h2&gt;免费情报订阅&amp;amp;代码安全检测&lt;/h2&gt; 
&lt;p&gt;OSCS 是国内首个开源软件供应链安全社区，社区联合开发者帮助全球顶级开源项目解决安全问题，并提供实时的安全漏洞情报，同时提供专业的代码安全检测工具为开发者免费使用。社区开发者可以通过配置飞书、钉钉、企业微信机器人获取一手的情报。&lt;/p&gt; 
&lt;p&gt;免费代码安全检测工具： &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.murphysec.com%2F%3Fsrc%3Dosc" target="_blank"&gt;https://www.murphysec.com/?src=osc&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;免费情报订阅： &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oscs1024.com%2Fcm%2F%3Fsrc%3Dosc" target="_blank"&gt;https://www.oscs1024.com/cm/?src=osc&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;具体订阅方式详见： &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oscs1024.com%2Fdocs%2Fvuln-warning%2Fintro%2F%3Fsrc%3Dosc" target="_blank"&gt;https://www.oscs1024.com/docs/vuln-warning/intro/?src=osc&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4aeef4048430ca1baea7afb51fe0f5dc3dd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356507</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356507</guid>
      <pubDate>Fri, 20 Jun 2025 12:53:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>鸿蒙正当时 | HarmonyOS 开发者实战工坊上海站圆满收官</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;2025 年 6 月 20 日，中国上海 —— HarmonyOS 开发者实战工坊·开发者系列沙龙在热烈的技术交流氛围中圆满收官。本次活动吸引了众多开发者齐聚一堂，通过主题演讲、实战经验分享与大咖深度互动，共同探讨鸿蒙生态发展的前沿趋势与核心技术，现场交流热烈，创新思维涌动，参与者纷纷表示收获颇丰。&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-92573b770811fcedec1e6c65b07d5b90c99.jpg" width="800" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;「鸿蒙为开发者构建了一个天然的平台，超越单一平台限制，助力开发者构想和创造服务于多设备互联、高可靠环境的创新应用。希望通过共创协作，我们能够相互成就，共同成长！」上海对外经贸大学开源创新与数字治理研究院院长、上海开源信息技术协会创始人张国锋先生为活动致辞。&lt;/p&gt; 
&lt;p&gt;张国锋也进一步阐述时代机遇：这是一个万物互联、场景融合的时代。传统的设备界限正被打破，用户期待的是无缝流转、高度协同的智慧体验。鸿蒙操作系统，以其与生俱来的分布式基因和对全场景连接的深刻理解，正在为这场深刻的范式转变奠定基础。这样的技术趋势，为我们每一位开发者，尤其是金融、互联网等各行各业的应用开发者们，开启了前所未有的机遇之门。&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-f836c5b077897b1d15ebc8cb5d23924b1b3.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在深度洞察行业趋势的开篇之后，活动话题随即转向技术实践深度分享。 三位重量级技术专家轮番登场，分别从不同维度深入剖析鸿蒙应用开发的关键领域，涵盖生态背景、发展趋势、核心技术指引及典型应用案例，为开发者提供了落地的实战参考。&lt;/p&gt; 
&lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#27ae60"&gt;鸿蒙应用生态发展趋势：未来已来，共筑无限可能&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="text-align:center"&gt;&lt;span style="color:#27ae60"&gt;&lt;img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-ba33e0acae2e9aada90a922fd0ec9c2fbbd.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;中国科学院软件研究所高级工程师、资深鸿蒙应用研发专家贾文洋发表《鸿蒙应用生态发展趋势：未来已来，共筑无限可能》主题演讲。贾文洋在演讲中指出，鸿蒙生态发展获得了有力的政策支持。他提到，国际形势变化凸显了构建自主技术生态的重要性，国家层面明确要求坚持技术创新、培育鸿蒙生态、倡导开源合作。2025 年 4 月 18 日，工信部通信发展司司长讲话中，明确强调推动更多 APP 上架鸿蒙应用商店的重要性，将通过推动应用上架、支持开源共建、加速场景融合三大举措，构建中国数字经济的底层基础设施。&lt;/p&gt; 
&lt;p&gt;地方层面，作为中国的金融中心，上海拥有活跃的金融产业，而金融产业的发展与科技创新密不可分，鸿蒙生态在上海已开始实现规模化发展，已有约 500 款上海鸿蒙应用实现升级上架，助力上海加速迈向万物智联时代。作为中国数字化、智能化转型的前沿阵地，上海与鸿蒙的双向奔赴，无疑将给各地拥抱鸿蒙生态形成示范效应。&lt;/p&gt; 
&lt;p&gt;在此背景下，贾文洋指出，鸿蒙开发工具正持续迭代，通过技术的不断演进给开发者带来越来越便捷的开发体验。&lt;/p&gt; 
&lt;p&gt;比如，DevEco Studio 是鸿蒙官方推荐的集成开发工具，伴随 HarmonyOS 系统的发展不断迭代更新；ArkTS 在保持 TypeScript 基本语法风格的基础上，进一步通过规范强化静态检查和分析，在程序运行之前的开发期能检测更多错误，推出状态管理 V2，进一步提升运行时性能；跨平台开发方面，鸿蒙 Next 有 musl libc，有标准 POSIX API，有 Clang/LLVM，有 GN/ninja，Flutter 的最大优势之一是其优异的性能表现，热重载 RN 的性能取决，于 JavaScript 桥接机制的实现和优化程度；此外还有 AI 技术的加持，通过控件 AI 化，可以打造智能应用……&lt;/p&gt; 
&lt;p&gt;谈及开发者生态建设，贾文洋介绍了华为构建的多层次交流与成长平台，如华为开发者组织 HDG、全球性的华为开发者大会 HDC、HarmonyOS Connect 伙伴峰会、华为校园开发者组织 HSD 等。在产业生态方面，贾文洋展示了鸿蒙终端的广泛应用前景。鸿蒙操作系统已覆盖手机、平板、手表、智慧屏、车机等多种设备，其分布式架构实现了无缝协同。&lt;/p&gt; 
&lt;p&gt;最后，贾文洋也表示，鸿蒙生态建设正迎来前所未有的发展机遇，相信鸿蒙能够成为最大的操作系统，呼吁广大开发者积极加入鸿蒙生态，共同开拓未来。&lt;/p&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#27ae60"&gt;Flutter 与鸿蒙的高效融合——应用适配实战解析&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="text-align:center"&gt;&lt;span style="color:#27ae60"&gt;&lt;img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-cde48d7adad68a7632408bf18525650dd0c.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;锅圈食品（上海）股份有限公司开发经理、华为 HDG 核心组织者王阳科发表《Flutter 与鸿蒙的高效融合——应用适配实战解析》主题演讲，系统介绍了跨平台框架 Flutter 在鸿蒙系统的适配方案与技术路径。&lt;/p&gt; 
&lt;p&gt;王阳科指出，Flutter 与鸿蒙融合具备三大优势。首先是性能提升，Flutter 的 Skia 自绘引擎在鸿蒙设备可实现高效图形渲染，结合 JIT/AOT 编译模式保障应用流畅性；鸿蒙分布式架构更支持跨设备协同能力。第二是跨平台优势，包括单套代码可覆盖 iOS、Android 及鸿蒙多平台，在保持 UI 一致性的同时通过平台通道调用原生功能。第三是开发效率的提升，包括热重载功能缩短开发周期，现有 Flutter 代码经适配可快速生成鸿蒙版本，鸿蒙 Next 的混合开发模式进一步降低维护成本。&lt;/p&gt; 
&lt;p&gt;具体到适配流程方面，王阳科也做了关键节点的拆解。首先是 Flutter 工程：提供一个跨平台的应用基础，便于后续与鸿蒙系统的集成 。通过鸿蒙能力扫描，确定鸿蒙系统中有哪些能力可以被 Flutter 工程调用和利用，为后续的适配工作提供基础信息。然后进行缺失能力分析，明确需要额外开发或适配的部分，以便后续步骤进行补充和完善。紧接着是三方库适配层，弥补鸿蒙系统中缺失的能力，确保 Flutter 工程在鸿蒙系统上能够完整地实现其功能。再通过原生通信通道，建立一个可靠的通信桥梁，使 Flutter 工程能顺利地调用鸿蒙系统的能力，并接收返回的数据。最后进行鸿蒙组件注入，增强 Flutter 应用在鸿蒙系统上的原生体验，提升应用的性能和功能丰富度。&lt;/p&gt; 
&lt;p&gt;为了帮助开发者更好地理解适配过程，王阳科以获取设备定位为例，演示插件开发全流程：在 Flutter SDK 插件库的鸿蒙端适配案例中，获取设备定位功能的实现分为通信框架构建与定位功能开发两阶段。首先需通过 MethodChannel 建立双向通信机制：在鸿蒙端创建专属插件文件并实现定位功能逻辑，随后在 Ability 中注册该插件。当 Flutter 调用鸿蒙端功能时，通过预置通信渠道触发定位操作并接收返回数据。&lt;/p&gt; 
&lt;p&gt;通过技术讲解和多个案例演示，也证明了 Flutter 与鸿蒙融合可充分发挥跨平台开发效率与原生系统能力优势；标准化适配流程降低多平台维护成本；原生组件注入方案为生态拓展提供新路径。&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#27ae60"&gt;安全与高效并存——金融领域鸿蒙开发案例浅析&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="text-align:center"&gt;&lt;span style="color:#27ae60"&gt;&lt;img alt="" height="533" src="https://oscimg.oschina.net/oscnet/up-3587d930d01133307cf1206ff8112d87891.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;资深全栈开发专家、HarmonyOS 生态践行者蒋天泓发表《安全与高效并存——金融领域鸿蒙开发案例浅析》主题演讲，向开发者展示了鸿蒙系统在金融场景的深度实践成果。&lt;/p&gt; 
&lt;p&gt;蒋天泓介绍，根据国际数据公司 (IDC)，2023 年银联报告显示移动端交易占比显著，到 2025 年银行客户超过 80% 的流量将通过手机 APP 实现，移动端交易成为主流。根据人行数据，2024 年，银行共处理电子支付 11 业务 3016.68 亿笔，其中移动支付业务 2109.80 亿笔，70% 的交易都在移动支付业务中产生。金融行业需覆盖银行、证券、保险等全场景，多终端协同需求激增，以满足客户多样化的金融服务需求。&lt;/p&gt; 
&lt;p&gt;面对如此庞大的交易规模，鸿蒙系统为金融业务构建了安全底座。鸿蒙的 TEE 安全微内核获得全球最高 CC EAL 5+认证，金融级 TEE 微内核认证为金融交易提供了强大的安全保障。HarmonyOS 系统提供「一次开发，多端部署」能力，其应用开发框架支持一次开发复盖手机、车机、穿戴设备等，满足金融行业多终端协同需求。&lt;/p&gt; 
&lt;p&gt;此外，蒋天泓还拆解了多个金融机构的鸿蒙应用开发实践案例。京东金融采用架构分层迁移策略，基于流量分析优先迁移核心功能，上线版本包含 21 个功能模块、180 余个功能和页面，覆盖线上版本 90% 的能力。交通银行借助鸿蒙意图框架，用户可通过语音助手「小艺」快速唤起 APP 完成转账操作，简化流程。中原银行深度适配折叠屏设备，利用鸿蒙 Navigation 技术实现业务在不同屏幕状态下的自动适配和流畅交互。在持仓页实现了分屏展示。发证券打造 AI 大模型矩阵驱动智能服务。其投顾驾驶舱基于 DeepSeek-R1 大模型，聚焦解决股票分析、资讯分析等投资咨询问题。&lt;/p&gt; 
&lt;p&gt;基于过往的开发经验，蒋天泓分享了一些实际的开发挑战可应对经验。比如，迁移成本控制方面，可以借鉴京东金融「核心功能优先」策略，结合 PV/UV 漏斗模型分析确定迁移重点。H5 容器兼容性保障上，ArkWeb 基于 Chrome 内核，无需重写，有效保证了 H5 容器的兼容性。全场景金融服务突破方面，可以通过发展「原子服务」，即轻量化服务，以及实现车机、穿戴设备等多终端联动，拓展服务边界。&lt;/p&gt; 
&lt;p&gt;通过详实的案例解析和技术探讨，蒋天泓的分享为金融行业开发者应用鸿蒙系统提供了有价值的参考，展示了鸿蒙在推动金融科技创新与服务升级方面的潜力。&lt;/p&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#27ae60"&gt;技术洞见落地生根，互动交流共话未来&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;三位专家的精彩演讲，从鸿蒙生态的宏阔前景到 Flutter 融合的技术路径，再到金融场景的深度实践，为开发者铺就了清晰可见的鸿蒙开发图景。深入浅出的剖析与落地的实战案例，点燃了现场开发者的热情与思考。演讲结束，会场气氛即刻升温，众多意犹未尽的开发者争先举手，期待与台上大咖进行更深入地探讨。热烈的互动环节随即展开，演讲嘉宾们亦以饱满的热情和专业洞见，回应了大家最为关切的问题。以下撷取其中具有代表性的三个精彩问答，以飨读者：&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img alt="" height="259" src="https://oscimg.oschina.net/oscnet/up-ba0a4174e107a5e029e696a9850ef395339.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;问题一：开发者现在投入鸿蒙应用开发，如何平衡短期收益与长期生态红利？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;贾文洋：&lt;/strong&gt;目前来说，整个商用推广节奏是很快的，政企合作、金融银行、运行商等各大公司场景的落地。随着鸿蒙设备的普及，HarmonyOS 应用市场的用户基数快速扩大，开发者有机会接触到更广泛的用户群体，这为应用的下载量和收益提供了潜在的增长空间。例如，一些热门的鸿蒙原生应用在发布后短时间内就获得了大量的下载和使用。所以，从长远来看，鸿蒙应用市场份额是逐步提升的。&lt;/p&gt; 
&lt;p&gt;鸿蒙 Next 的分布式架构、AI 智能等特性为开发者提供了更多的创新空间。开发者可以利用这些特性开发出具有独特功能和体验的应用，满足用户在多设备互联、智能交互等方面的需求，从而提高应用的竞争力和吸引力，进而增加收益。例如，开发一款可以在手机、平板和智能电视上无缝切换和同步数据的视频播放应用，利用鸿蒙的分布式能力，用户可以在不同设备上继续观看之前的视频内容，这种创新的体验可能会吸引更多用户使用并付费。&lt;/p&gt; 
&lt;p&gt;华为推出了多项激励计划，如鸿蒙原生应用开发者激励计划、Next 变现激励等，为开发者提供了现金及流量扶持，以及额外的变现收益机会。可以参与鸿蒙开发者的比赛，探索一些创新性的应用。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;问题二：鸿蒙的&lt;/strong&gt;&lt;strong&gt;分布式&lt;/strong&gt;&lt;strong&gt;能力在金融行业有哪些创新应用场景？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;蒋天泓：&lt;/strong&gt;鸿蒙的分布式能力可以实现穿戴设备与车机间自动发现、秒级连接，保障指令传输时延＜100ms。&lt;/p&gt; 
&lt;p&gt;端云协同 AI：可以通过用户行为描绘对用户画像进行匹配，保障用户信息安全，防止多设备协同下的信息泄漏。&lt;/p&gt; 
&lt;p&gt;第二是交易协同，通过鸿蒙的分布式软总线技术，金融机构可构建覆盖手机、平板、车机、穿戴设备等多终端的统一服务。例如，交通银行用户可在手机银行发起转账后，直接在车机端确认交易，或在智能手表上接收还款提醒并一键完成支付。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;问题三：新启动的项目，是选择 Flutter 还是 All in ArkUI ？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;王阳科：&lt;/strong&gt;在新项目启动时，选择 Flutter 或 All in ArkUI 不应视为非此即彼的对立。若项目关键目标是快速抢占市场，频繁更新迭代以适应初期需求变化，那么 Flutter 是更优解。它凭借出色的跨平台性能、丰富的生态，一套代码能打包多个平台应用，极大地缩短开发周期、降低多平台开发成本，使产品能迅速推向市场，在竞争中抢占先机。&lt;/p&gt; 
&lt;p&gt;而 ArkUI 则是深度挖掘鸿蒙系统潜力的不二之选，能充分发挥鸿蒙的分布式等独特特性。至于使用 Flutter，虽无法实现鸿蒙的一次开发多端部署能力，但并不影响其在鸿蒙端运用碰一碰等功能的特性，可以单独在鸿蒙项目上增加，其在跨平台领域的优势依旧能为项目提供有力支撑。&lt;/p&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#27ae60"&gt;活动圆满落幕，期待携手前行&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;HarmonyOS 开发者实战工坊·上海站活动在热烈讨论与务实分享的氛围中成功结束。从宏观生态分析到具体技术实践，从金融安全应用到跨平台开发适配，整场活动为开发者带来了丰富的实用信息和解决方案。参会者们带着新的思路和具体的操作指南陆续离场，活动现场仍可见意犹未尽的开发者们聚在一起交流心得。&lt;/p&gt; 
&lt;p&gt;本次上海站活动，展现了鸿蒙生态在本地化发展上的活跃态势，也为开发者们搭建了宝贵的线下交流平台。我们相信，这样的连接与分享将为鸿蒙生态注入更多活力。&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img alt="" height="534" src="https://oscimg.oschina.net/oscnet/up-5676e23d55e3cdd724e4c5ad7a6eea0228d.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span style="color:#8f959e"&gt;&lt;em&gt;现场，开发者们积极交流，还有美味茶歇和贴心福利，收获满满！&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;欢迎所有对鸿蒙开发感兴趣的开发者，持续关注 HarmonyOS 开发者社区动态」，获取最新技术文档、活动信息和开发资源。期待在下一次活动中与大家再会！&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img alt="" height="340" src="https://oscimg.oschina.net/oscnet/up-2da8d695e5675e704afb788c01a9b5878a8.png" width="800" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4489239/blog/18628121</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/18628121</guid>
      <pubDate>Fri, 20 Jun 2025 10:54:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Gitee SBOM 扫描上线，全面守护开源软件供应链安全</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在软件开发逐渐开源化和协作化的今天，软件供应链的透明性与安全性已成为开发者和企业最关注的话题之一。&lt;/p&gt; 
&lt;p&gt;尤其对于国内开发者和开源社区来说，&lt;strong&gt;随着国际合作与市场需求的日益增加，明确掌握软件供应链的信息，保障合规性和安全性至关重要&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;Gitee 全新推出的 SBOM（软件物料清单）扫描功能，正是为了解决这些关键问题而生。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;SBOM 扫描是什么？&lt;/h2&gt; 
&lt;p&gt;软件物料清单（Software Bill of Materials，简称 SBOM）类似于软件的「配料表」，清晰记录了软件中包含的所有具体组件、库和依赖项。这种方式让开发者可以快速准确地了解软件的组成结构，从而及时发现可能存在的安全漏洞和隐患，防止问题扩大。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183218_t7Cp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，SBOM 还能协助中国的开发者和企业满足国内外的合规要求以及国际出口管制和知识产权保护相关的合规标准，确保软件开发与国际接轨且安全可信。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;SBOM 扫描能做什么？&lt;/h2&gt; 
&lt;h3&gt;识别开源依赖风险&lt;/h3&gt; 
&lt;p&gt;快速准确地识别项目中使用的开源组件，帮助开发者清晰了解依赖项，避免隐性风险，保护自主知识产权。&lt;/p&gt; 
&lt;h3&gt;追踪许可证合规性&lt;/h3&gt; 
&lt;p&gt;主动管理项目中组件许可证，确保合规性，避免法律纠纷，提升对开源项目的信任度。&lt;/p&gt; 
&lt;h3&gt;快速响应漏洞威胁&lt;/h3&gt; 
&lt;p&gt;一旦发现漏洞或风险，可以迅速定位问题组件，减少修复时间，提升项目整体安全性。&lt;/p&gt; 
&lt;h3&gt;多元数据来源支持&lt;/h3&gt; 
&lt;p&gt;Gitee SBOM 扫描能够灵活支持多种数据来源，包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;源码文件&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;包管理器配置文件&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;容器镜像&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;各类二进制格式文件&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;这种多样性确保了从软件开发初期到发布后的各个阶段都能被有效覆盖，保障了全生命周期的安全性和合规性。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;在 Gitee 上使用 SBOM 扫描&lt;/h2&gt; 
&lt;p&gt;SBOM 扫描服务现已对 Gitee 中&lt;strong&gt;所有开源仓库&lt;/strong&gt;开放使用，可在&lt;code&gt;服务&lt;/code&gt;中找到其入口。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183234_Hi5b_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;进入 SBOM 扫描功能后，可选择两种方式进行扫描，此处介绍在 Gitee Go 中使用 SBOM，选择&lt;code&gt;使用 Gitee Go 流水线进行扫描分析&lt;/code&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183247_hscT_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;如选择使用 SBOM 服务平台，请选择 Gitee 账号登录。若显示该网页不安全，可直接忽略，绑定 Gitee 账号操作即可。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;新建流水线，在&lt;code&gt;任务编排&lt;/code&gt;中选择&lt;code&gt;新的任务&lt;/code&gt;，添加&lt;code&gt;SBOM 扫描&lt;/code&gt;任务，保存并确认即可。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183259_qCRC_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此时，扫描任务已在运行状态，等待十分钟后即可扫描完成（扫描时间由仓库大小决定）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183310_PyTu_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;运行完成后，即可进入&lt;code&gt;构建历史&lt;/code&gt;，点击下图高亮处进入&lt;code&gt;构建详情&lt;/code&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183321_En7Y_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在&lt;code&gt;任务详情&lt;/code&gt;中即可看到本次 SBOM 扫描报告和提取码。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183339_ghVF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;输入提取码后即可查看本次扫描详情，报告中包含了&lt;code&gt;组件&lt;/code&gt;、&lt;code&gt;漏洞&lt;/code&gt;、&lt;code&gt;许可证&lt;/code&gt;相关风险项及依赖关系图。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183350_3TpU_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/183401_vUGn_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前该服务已对 Gitee&amp;nbsp;&lt;strong&gt;所有开源仓库&lt;/strong&gt;开放使用，欢迎开发者访问体验&amp;nbsp;&lt;a href="https://gitee.com/"&gt;https://gitee.com/&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;强大底层支撑，全面追踪风险&lt;/h2&gt; 
&lt;p&gt;开源项目的安全性和透明度不容忽视，为此，Gitee SBOM 扫描采用统一的规范和严谨的评估方法，保证物料信息的准确性和质量。同时，依托于强大的数据库和先进的 NLP、机器学习技术，实时更新开源组件与漏洞数据，实现风险精准追踪与管理。&lt;/p&gt; 
&lt;p&gt;立即使用 Gitee 的 SBOM 扫描功能，让你的软件开发和管理更加安全、可靠、高效！&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0411/120710_Spld_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356489</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356489</guid>
      <pubDate>Fri, 20 Jun 2025 10:35:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>打破 996 魔咒，重塑软件开发</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;当午夜的城市渐入梦乡，写字楼里的软件开发工位却依然灯火通明。在传统开发模式的桎梏下，程序员们被迫困在需求反复变更、设计难题频出、代码调试无尽的循环中，「996」 甚至 「007」 的工作节奏，让软件开发行业成为高压与疲惫的代名词。而如今，飞算 JavaAI 的横空出世，正以革命性的技术力量，为行业带来破局的曙光。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;回溯传统软件开发流程，宛如一场充满荆棘的艰辛跋涉。在需求分析阶段，业务方模糊的构想与开发者严谨的技术思维难以精准对接。频繁的沟通会议、反复修改的需求文档，使得项目前期投入的大量精力，可能因需求临时变动而付诸东流。进入软件设计环节，接口设计的灵活性、数据库表结构的合理性等问题，都需要开发者耗费大量时间权衡利弊，一旦某个环节考虑不周，后续开发便会陷入被动。而到了代码编写阶段，复杂的业务逻辑如同迷宫，调试过程中不断出现的错误提示，让开发者深陷焦虑与疲惫，项目进度也随之停滞不前。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;飞算 JavaAI 的诞生，彻底改写了软件开发的游戏规则。在需求分析层面，它化身智能需求处理专家，借助先进的大模型技术，能够精准解析用户输入的文字或语音需求。即便需求描述零散、逻辑混乱，它也能迅速梳理出清晰的脉络，快速生成完整且严谨的需求文档，将原本漫长的需求分析周期大幅压缩，从根源上减少需求变更带来的返工风险。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="363" src="https://oscimg.oschina.net/oscnet/up-264c3950f00f8dd56f6cb80052f1822b3b3.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;在软件设计领域，飞算 JavaAI 的自动化设计引擎展现出强大的实力。基于自研的 Java 专有模型，它能依据项目需求，瞬间生成专业且适配性强的接口设计与表结构方案。这些设计不仅满足当下业务需求，更具备出色的扩展性，可从容应对未来业务的变化。同时，它还能对复杂业务逻辑进行智能拆解，搭建起科学合理的设计框架，为开发者节省大量脑力与时间。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;飞算 JavaAI 的 「一键代码生成」 功能更是惊艳众人。它全面兼容 Maven、Gradle 等主流项目构建工具，开发者只需简单操作，便能获取包含完整功能的源码与工程文件。更为难得的是，其内置的自动代码优化机制，会对生成的代码进行严格审查，确保代码在语法、规范和逻辑上都达到高标准，生成的代码可直接投入使用，让开发者彻底告别深夜调试代码的困境。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;实践是检验技术的最佳标准。某知名互联网企业在开发全新电商平台时，大胆引入飞算 JavaAI 技术。以往需要开发团队日夜赶工、历经三个月才能完成的项目，借助飞算 JavaAI 的助力，仅用一个月便顺利交付，且项目质量远超预期。项目上线后运行稳定，功能丰富，开发团队成员得以摆脱繁重的加班压力，有更多时间投入到技术学习与创新探索中，职业发展与个人生活实现了更好的平衡。&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;飞算 JavaAI 所引发的，不仅是软件开发效率的巨大提升，更是整个行业发展模式的深刻变革。它有效缩短项目周期、降低开发成本，让开发者从重复性的劳动中解放出来，将更多精力投入到创造性的工作中。在飞算 JavaAI 的推动下，软件开发正从高强度的苦役转变为充满乐趣与挑战的创新之旅。这场席卷软件开发行业的变革已然开启，你是否准备好拥抱这一全新趋势，开启高效开发的新篇章？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;飞算 JavaAl 由国家高新技术企业飞算科技自主研发&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;飞算数智科技（深圳）有限公司（简称 「飞算科技」）是一家自主创新型的数字科技公司，也是国家级高新技术企业。公司以互联网科技、大数据、人工智能等技术为基础，凭借团队在相关领域多年的实践经验，将技术与应用深度融合，致力于为民生产业、中小企业、金融企业等不同类型客户提供科技支持与服务，助力客户实现科技化、数字化、智能化转型升级。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;飞算科技始终专注于中国原创技术的创新研发，已成功落地多项填补行业空白的技术应用。在技术落地过程中，公司得到了倪光南院士、石勇院士等国内科技泰斗的长期关注及支持，相关产品也曾先后获得图灵奖得主、美国三院院士大衞&lt;/span&gt;&lt;span&gt;・&lt;/span&gt;&lt;span&gt;帕特森，以及沈昌祥院士、柴天佑院士、张景安院士的点评。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;经过多次演进，飞算科技不断构建核心壁垒，目前已形成产业数字科技、数智科技、数字转型科技、数字决策科技四大业务板块。旗下涵盖飞算 JavaAI、SoData 数据机器人、AI.Modeler 建模机器人、产业数智通等应用于不同业务场景的科技产品及解决方案，能充分满足客户的技术发展需要，实现全方位客户赋能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356486</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356486</guid>
      <pubDate>Fri, 20 Jun 2025 10:22:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>老项目改造、定制开发太难搞？那是你没用对方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在互联网浪潮奔涌的当下，程序员群体凭借技术专长拓展副业的热情持续高涨。然而，这条副业创收之路布满荆棘 —— 老项目代码如同 「天书」，梳理起来耗时耗力；客户个性化需求千差万别，通用工具难以满足；开发过程不透明，沟通成本居高不下。这些难题像沉重的枷锁，束缚着程序员副业发展的脚步。飞算 JavaAI 的三大能力升级，宛如三把 「金钥匙」，精准解锁困境，成为程序员副业创收的得力助手。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本地化智能分析：破解老项目 「天书」，提速副业开发&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当程序员接手副业项目，常常被陌生的老项目代码困住手脚。那些混乱的代码、晦涩的逻辑，如同迷宫般难以捉摸，传统人工逐行梳理的方式，不仅效率低下，还会大幅增加时间成本，压缩盈利空间。飞算 JavaAI 的本地化智能分析功能，为程序员点亮了一盏明灯。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;只需将老项目导入，该功能便即刻启动，基于全量代码语义索引和上下文强关联分析，对项目架构、模块交互和核心业务逻辑展开深度剖析。比如在承接小型企业老系统优化的副业项目时，无需再像过去那样耗费数天时间梳理代码，飞算 JavaAI 能迅速理清项目脉络，精准输出适配代码，有效避免开发过程中边改边错的情况。这使得程序员能将更多精力聚焦于高价值的开发任务，快速交付项目，收获客户好评，为后续副业合作积累良好口碑。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="363" src="https://oscimg.oschina.net/oscnet/up-e7c65594aedcc0910c909f785d228763210.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;AI &lt;/span&gt;&lt;span&gt;规则引擎：定制专属代码，满足多元需求&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在副业开发领域，客户需求的多样性如同变幻莫测的万花筒。不同客户对代码的技术栈、风格规范要求各不相同，通用的 AI 代码生成工具往往难以应对。飞算 JavaAI 的 AI 规则引擎功能，赋予程序员强大的定制化能力，让个性化开发不再是难题。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;程序员只需通过自然语言编写规则，无论是特定的 Java 技术栈，还是独特的代码规范、安全要求，AI 都能严格遵循，生成高合规、高复用的定制化代码。以电商平台插件开发副业为例，依据客户的系统架构和代码风格设定规则后，生成的代码能够完美融入现有系统，实现即插即用，极大减少了反复修改的时间，高效满足客户需求。凭借这样优质的服务，程序员能在副业市场中脱颖而出，吸引更多潜在客户。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="396" src="https://oscimg.oschina.net/oscnet/up-9b13a8641532c2caee087fa3a0e948f22bb.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模块化智能引导：透明化开发流程，降低沟通成本&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在副业开发过程中，客户对项目进展的关注与日俱增。然而，传统 「黑盒式」 全量代码生成方式，常常导致沟通不畅，引发客户信任危机。飞算 JavaAI 的模块化智能引导功能，打破了这一局面，让开发过程变得透明可控。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;源码按照接口模块顺序逐步生成，程序员可以实时预览，并向客户清晰展示每一步的代码逻辑与设计思路。在承接 APP 功能模块开发副业时，客户能够直观看到每个接口的实现过程，随时提出意见和建议，有效减少因需求理解偏差导致的返工。这种透明化的开发模式，不仅降低了沟通成本，还能根据客户反馈及时调整，确保最终交付成果完全符合需求，进一步提升客户信任度，助力程序员在副业领域树立专业可靠的形象，赢得更多合作机会。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="315" src="https://oscimg.oschina.net/oscnet/up-9df66e67de08102267b85671ce0ea71e9d3.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;飞算 JavaAI 的三大能力升级，从项目处理、需求满足到开发流程优化，全方位为程序员的副业之路保驾护航。借助这些强大功能，程序员能够高效完成副业项目，拓宽收入渠道，在副业市场中崭露头角，实现技术价值与经济收益的双重提升。&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356484</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356484</guid>
      <pubDate>Fri, 20 Jun 2025 10:21:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>Suna —— 开源通用 AI 智能体</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Suna 是一款完全开源的 AI 助手，可帮助你轻松完成现实世界中的任务。通过自然对话，Suna 成为你研究、数据分析和应对日常挑战的数字伴侣--它将强大的功能与直观的界面相结合，能够理解你的需求并提供结果。&lt;/p&gt;

&lt;p&gt;Suna 强大的工具包包括用于浏览网页和提取数据的无缝浏览器自动化、用于创建和编辑文档的文件管理、网络爬虫和扩展搜索功能、用于系统任务的命令行执行、网站部署以及与各种 API 和服务的集成。这些功能协调工作，使 Suna 能够通过简单的对话解决你的复杂问题并实现工作流程自动化。&lt;/p&gt;

&lt;p&gt;&lt;img height="252" src="https://static.oschina.net/uploads/space/2025/0423/101622_pcw7_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/suna</link>
      <guid isPermaLink="false">https://www.oschina.net/p/suna</guid>
      <pubDate>Fri, 20 Jun 2025 10:16:00 GMT</pubDate>
    </item>
    <item>
      <title>《鸿蒙编程语言白皮书》发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;华为&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fguidebook%2Fprogramming-language-0000002323920052" target="_blank"&gt;发布&lt;/a&gt;了《鸿蒙编程语言白皮书》V1.0 版本。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e73cd052dad175f797b65d026eced0dbee7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;白皮书核心内容如下：&lt;/p&gt; 
&lt;h3&gt;一、鸿蒙编程语言整体框架&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;多语言生态&lt;/strong&gt;：鸿蒙支持 ArkTS、仓颉和 C/C++三种编程语言，它们相互补充，共同支撑鸿蒙应用生态构建。 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;ArkTS&lt;/strong&gt;：动态类型编程语言，基于 TypeScript，具有易学易用、生态丰富等特征，适用于高效开发场景。&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;仓颉&lt;/strong&gt;：静态类型编程语言，具有高性能、强安全、跨平台等特性，适用于对性能和安全要求较高的场景。&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;C/C++&lt;/strong&gt;：适用于高性能计算、硬件加速等特定场景，可通过跨语言互操作封装为 ArkTS 和仓颉扩展模块。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;语言互操作&lt;/strong&gt;：ArkTS 与 C/C++通过 Node-API 实现互操作；仓颉与 C 语言实现函数互相调用及跨语言数据转换；仓颉与 ArkTS 通过互操作库实现数据转换和函数调用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0620/180210_mEvI_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;二、鸿蒙编程语言适用场景&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;高效开发&lt;/strong&gt;：ArkTS 兼容 TS 高效语法，提供丰富的基础库和并发能力，支持声明式 UI 开发，可继承 TS/JS 语言生态。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;：ArkTS 编译运行时支持混合执行模式，优化模块加载机制，提供高效的并发编程模型；仓颉基于静态类型和静态编译优化技术，具有卓越的性能支持。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;安全&lt;/strong&gt;：ArkTS 在语言层面引入类型系统等特性，并在编译工具链和运行时提供额外的安全机制；仓颉通过静态类型系统、自动内存管理等确保程序安全。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;跨平台&lt;/strong&gt;：仓颉支持静态编译至不同 OS 平台的机器码，实现跨 OS 平台代码共享，支持多种操作系统平台。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;技术资产保护&lt;/strong&gt;：ArkTS 提供源码混淆工具 ArkGuard；仓颉提供外形混淆、数据混淆、控制流混淆等多种混淆技术。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;三、鸿蒙编程语言演进策略&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;ArkTS 演进策略&lt;/strong&gt;：将进一步定义和完善语言规范，提供基于语言规范的编译器实现，引入类型信息优化运行时性能等。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;仓颉演进策略&lt;/strong&gt;：将持续提升高效开发体验，提供高性能和强安全能力，在跨平台和智能化领域持续完善和探索。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;智能化演进策略&lt;/strong&gt;：仓颉通过元编程能力和 DSL 能力构建 Agent DSL 能力，未来将深化与 AI 技术的融合，推动在多领域的应用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h3&gt;四、未来一年语言演进策略&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;ArkTS&lt;/strong&gt;：将持续保持演进迭代，进一步丰富并发编程、完善类型系统、现代化语法等新特性，提升开发效率，丰富 SDK 功能等。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;仓颉&lt;/strong&gt;：将以提升开发者体验为目标，从语言特性构建、兼容现有生态、完善工具链易用性等方面持续建设语言能力，包括 API 发展、开发工具支持、资料文档完善等。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fguidebook%2Fprogramming-language-0000002323920052" target="_blank"&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356477</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356477</guid>
      <pubDate>Fri, 20 Jun 2025 10:03:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Ollama 已支持 RWKV-7 模型，可灵活开关思考模式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Ollama 最新版本已支持 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FBlinkDL%2Frwkv7-g1" target="_blank"&gt;RWKV7-G1&lt;/a&gt; 和 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FBlinkDL%2Frwkv-7-world%2Ftree%2Fmain" target="_blank"&gt;RWKV-7-World&lt;/a&gt; 系列模型。&lt;/p&gt; 
&lt;p&gt;3 月初，随着 RWKV 社区成员 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMollySophia" target="_blank"&gt;@MollySophia&lt;/a&gt; 的 PR 被合并，llama.cpp 正式支持 RWKV-7 模型。Ollama 近期更新了最新版 llama.cpp，因此同步支持 RWKV-7 架构和对应模型。&lt;/p&gt; 
&lt;p&gt;Ollama 官方模型仓库现已包含 RWKV-7 系列模型（&lt;strong&gt;推荐使用 RWKV7-G1 系列模型&lt;/strong&gt;）：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;RWKV-G1：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Follama.com%2Fmollysama%2Frwkv-7-g1" target="_blank"&gt;https://ollama.com/mollysama/rwkv-7-g1&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;RWKV-7-World：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Follama.com%2Fmollysama%2Frwkv-7-world" target="_blank"&gt;https://ollama.com/mollysama/rwkv-7-world&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="Ollama-rwkv-7-g1-model" src="https://oscimg.oschina.net/oscnet/up-fccb3d8e64926294cacbe4a11ee95d9a770.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;在 Ollama 中运行 RWKV 模型&lt;/h2&gt; 
&lt;p&gt;以下是在 Ollama 中体验 RWKV-7 G1 2.9B 模型的最简路径。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;在 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Follama.com%2Fdownload" target="_blank"&gt;https://ollama.com/download&lt;/a&gt; 页面，根据您的系统下载 Ollama 安装包：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img alt="Ollama-Download" src="https://oscimg.oschina.net/oscnet/up-4ea6cdae40f2b576d1013a04ce100b86e1b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;下载完毕后，双击安装包以安装 Ollama。任务栏出现 Ollama 图标时，意味着安装已完成：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img alt="Ollama-Install" src="https://oscimg.oschina.net/oscnet/up-a3ae79f1c042ea9a6d041491c2424644352.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;在终端中运行 &lt;code&gt;ollama run mollysama/rwkv-7-g1:2.9b&lt;/code&gt; 命令，Ollama 将&lt;strong&gt;自动下载并运行&lt;/strong&gt; RWKV7-G1 2.9B 模型。您可以在终端中与 RWKV 模型进行对话，如下图所示：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;若您曾经下载过 &lt;code&gt;mollysama/rwkv-7-g1:2.9b&lt;/code&gt; 模型，请运行 &lt;code&gt;ollama pull mollysama/rwkv-7-g1:2.9b&lt;/code&gt; 命令，拉取最新的变更。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img alt="ollama-Run" src="https://oscimg.oschina.net/oscnet/up-078fd28c775018d9e1b41165e88e4daa867.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Ollama 的 RWKV7 G1 模型默认开启思考模式，可以通过 &lt;code&gt;/set nothink&lt;/code&gt; 和 &lt;code&gt;/set think&lt;/code&gt; 命令灵活地开关思考模式：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img alt="ollama-run-nothink-mode" src="https://oscimg.oschina.net/oscnet/up-47a41f6324cd656bc720b5cac3242dd846d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;使用 &lt;code&gt;ollama stop mollysama/rwkv-7-g1:2.9b&lt;/code&gt; 命令可以停止当前模型实例，从而&lt;strong&gt;重置对话上下文&lt;/strong&gt;，否则 Ollama 会**持续保留当前会话的上下文（历史消息）**作为后续对话的参考&lt;/li&gt; 
&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Ollama 官方仓库提供 &lt;code&gt;Q6_K&lt;/code&gt; 量化的 RWKV7 G1 模型。&lt;/p&gt; 
 &lt;p&gt;如需使用其他量化类型，需手动&lt;strong&gt;创建自定义 RWKV 模型&lt;/strong&gt; ，详细教程请在 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frwkv.cn%2Ftutorials%2Fintermediate%2FRWKV-Inference%2FOllama" target="_blank"&gt;RWKV 教程 - Ollama 推理&lt;/a&gt; 中查看。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;RWKV Chat 端侧聊天助手&lt;/h2&gt; 
&lt;p&gt;除了在 Ollama 中运行 RWKV 模型，我们也推荐使用 &lt;strong&gt;RWKV Chat 端侧聊天助手&lt;/strong&gt;体验 RWKV 模型。&lt;/p&gt; 
&lt;p&gt;RWKV Chat 是 RWKV 官方推出的离线 AI 聊天应用，针对各类端侧设备进行深度推理优化。APP 内含多种小参数模型，支持会话配置调整、灵活切换思考模式，是你的高效生产力伙伴！&lt;/p&gt; 
&lt;p&gt;在开启和关闭思考模式两种情况下，RWKV Chat 回答同一个问题：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="RWKV-chat-dual-mode" src="https://oscimg.oschina.net/oscnet/up-0da002b7cc9c0e9f745e653ce7e39cfa22a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;下载 RWKV Chat APP：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frwkvos.com%2Frwkv-chat" target="_blank"&gt;https://rwkvos.com/rwkv-chat&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;加入 RWKV 社区&lt;/h2&gt; 
&lt;p&gt;欢迎大家加入 RWKV 社区，可以从 RWKV 中文官网了解 RWKV 模型，也可以加入 RWKV 论坛、QQ 频道和 QQ 群聊，一起探讨 RWKV 模型。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;📖 RWKV 中文文档：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.rwkv.cn" target="_blank"&gt;https://www.rwkv.cn&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;💬 RWKV 论坛：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcommunity.rwkv.cn%2F" target="_blank"&gt;https://community.rwkv.cn/&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;🐧 QQ 频道：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpd.qq.com%2Fs%2F9n21eravc" target="_blank"&gt;https://pd.qq.com/s/9n21eravc&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;📺 BiliBili 视频教程：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspace.bilibili.com%2F3546689096910933" target="_blank"&gt;https://space.bilibili.com/3546689096910933&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356473</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356473</guid>
      <pubDate>Fri, 20 Jun 2025 09:39:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>华为自研仓颉编程语言将于 7 月 30 日开源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;在华为开发者大会 HDC 2025 期间，华为宣布仓颉编程语言将于 7 月 30 日开源。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;2024 年 6 月，华为终端 BG 软件部总裁龚体宣布，下一代编程语言仓颉今日起正式开启预览。官网介绍显示，仓颉编程语言是一款面向全场景智能的新一代编程语言，主打智能化、全场景、高性能、强安全。融入鸿蒙生态，为开发者提供良好的编程体验。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="263" src="https://oscimg.oschina.net/oscnet/up-c8b68adb0faebdafc65da05a7b0d291b75c.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其具体特性表现为：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style="color:#000000"&gt;高效编程：面向应用开发，希望语言能够易学易用，降低开发者入门门槛和开发过程中的心智负担，支持各种常见的开发范式和编程模式，让开发者简洁高效地表达各种业务逻辑。仓颉是一门多范式编程语言，支持函数式、命令式和面向对象等多种范式，包括值类型、类和接口、泛型、代数数据类型、模式匹配、以及高阶函数等特性。此外，仓颉还支持类型推断，能够减轻开发者类型标注的负担；通过一系列简明高效的语法，能够减少冗余书写、提升开发效率；语言内置的各种语法糖和宏（macro）的能力，支持开发者基于仓颉快速开发领域专用语言（DSL），构建领域抽象。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style="color:#000000"&gt;安全可靠：作为现代编程语言，仓颉追求编码即安全，通过静态类型系统和自动内存管理，确保程序的类型安全和 null safety 等内存安全；同时，仓颉还提供各种运行时检查，包括数组下标越界检查、类型转换检查、数值计算溢出检查、以及字符串编码合法性检查等，能够及时发现程序运行中的错误；此外，还通过代码扫描工具、混淆工具以及消毒器，进一步提供跨语言互操作安全和代码资产保护等支持。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style="color:#000000"&gt;轻松并发：并发和异步编程能够有效提高处理器利用率，并在交互式应用中确保程序的响应速度，是应用开发中必不可少的能力。仓颉语言实现了轻量化用户态线程和并发对象库，让高效并发变得轻松。仓颉语言采用用户态线程模型，每个仓颉线程都是极其轻量级的执行实体，拥有独立的执行上下文但共享内存。对开发者来说，用户态线程的使用和传统的系统线程的使用方式保持一致，没有带来额外负担；而从运行态视角看，线程的管理由运行时完成，不依赖操作系统的线程管理，因此线程的创建、调度和销毁等操作更加高效，且资源占用比系统线程更少。为了避免数据竞争，仓颉语言提供了并发对象库，并发对象的方法是线程安全的，因此在多线程中调用这些方法和串行编程没有区别，应用逻辑的开发者无需额外关心并发管理。对于一些核心库，仓颉还提供了无锁或者细粒度锁的算法实现，能够进一步减少线程的阻塞，提升并发度。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style="color:#000000"&gt;卓越性能：仓颉编译器及运行时从全栈对编译进行优化，包括编译器前端基于 CHIR（Cangjie HighLevel IR）高层编译优化（比如语义感知的循环优化、语义感知的后端协同优化等），基于后端的编译优化（比如：SLP 向量化、Intrinsic 优化、InlineCache、过程间指针优化、Barrier 优化等），基于运行时的优化（比如轻量锁、分布式标记、并发 Tracing 优化等），一系列的优化让仓颉充分发挥处理器能力，为应用提供卓越的性能支持。另外仓颉语言对运行时进行原生的轻量化设计，通过对运行时模块化分层设计，定义仓颉公共对象模型和运行时公共基础组件，基于公共对象模型，实现运行时的内存管理、回栈、异常处理、跨语言调用等基础能力，大幅减少多个能力间的冗余对象设计，精简运行时体积。同时通过包的按需加载技术，减少仓颉应用启动的冗余包内存开销，因此对于资源敏感设备，占用资源更少，支持更友好。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;除此之外，仓颉还支持面向应用开发的一系列工具链，包括语言服务（高亮、联想）、调试（跨语言调试、线程级可视化调试）、静态检查、性能分析、包管理、文档生成、Mock 工具、测试框架、覆盖率工具、Fuzz 工具以及智能辅助编程工具，进一步提升软件开发体验以及效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/298396/huawei-cangjie-lang" target="_blank"&gt;华为仓颉编程语言正式亮相&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/318801" target="news"&gt;仓颉编程语言官网正式上线，首个公测版本开放下载&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356470</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356470</guid>
      <pubDate>Fri, 20 Jun 2025 09:31:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>JDK 高版本特性总结与 ZGC 实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;美团信息安全技术团队核心服务升级 JDK 17 后，性能与稳定性大幅提升，机器成本降低了 10%。高版本 JDK 与 ZGC 技术令人惊艳，且 Java AI SDK 最低支持 JDK 17。本文总结了 JDK 17 的主要特性，然后重点分享了 JDK 17+ZGC 在安全领域的一些实践，希望能对大家有所帮助或启发。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-31d46a32fb835d661ed43d399296dac8a92.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;从一句调侃的话 "你发任你发，我用 Java 8！" 可以看出，在开发新项目时，Java 8 依然是大家的首选。美团 Java 8 服务占比超过 70%，可以说 Java 8 依然是绝对的主流。但是，我们在多个核心服务上遇到较多的性能问题，这些问题无法通过 JVM 参数微调来解决，为此我们对部分核心服务使用了 JDK 17，升级后服务性能和稳定性指标也得到巨大的飞跃，同时机器成本可以下降约 10%，升级 JDK 版本收益十分明显。另外，目前正处在 AI 时代的爆发期，Java AI SDK 的最小支持版本为 JDK 17，这让升级 JDK 版本变得更具价值。接下来，期望跟大家一起探索 JDK 高版本和 ZGC 技术的奥秘，开启优化 Java 应用的新征程。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;JDK 17 的主要特性&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;包含 JDK 9~17 等中间版本的特性。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;从 JDK 8 直接升级到 JDK 17，以下是需要重点关注的特性，这些特性对开发效率、代码风格、性能优化和安全性都有显著影响。&lt;/p&gt; 
&lt;h3&gt;1.1 语言特性[1]&lt;/h3&gt; 
&lt;h4&gt;1.1.1 局部变量类型推断&lt;/h4&gt; 
&lt;p&gt;使用 var 关键字来声明局部变量，而无需显式指定变量的类型。在 Java 17 中，可以使用局部变量类型推断的扩展来编写更简洁的代码。其他语言如 Golang 很早就支持了 var 变量。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// JDK8
String str = "Hello world";

// JDK17
var str = "Hello world";
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;需要注意的是，var 类型的局部变量仍然具有静态类型，一旦被推断出来，类型就会固定下来，并且不能重新赋值为不兼容的类型。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;1.1.2 密封类&lt;/h4&gt; 
&lt;p&gt;它允许我们将类或接口的继承限制为一组有限的子类。如果想将类或接口的继承限制为一组有限的子类时，这非常有用。在下面的示例中，可以看到我们如何使用 sealed 关键字将类的继承限制为一组有限的子类。我们可以通过在类的声明前加上 sealed 关键字来将该类声明为密封类。然后，可以使用 permits 关键字列出该密封类允许继承的子类。这些子类必须直接或间接地继承自密封类。这样，只有在这个预定义的子类中，才能继承该密封类。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//使用 permits 关键字列出了允许继承的子类 Circle、Rectangle 和 Triangle
public sealed class Shape permits Circle, Rectangle, Triangle {
    // 省略实现
}

// 在与密封类相同的模块或包中，定义以下三个允许的子类， Circle，Square 和：Rectangle
public final class Circle extends Shape {
    public float radius;
}
 
public non-sealed class Square extends Shape {
   public double side;
}   
 
public sealed class Rectangle extends Shape permits FilledRectangle {
    public double length, width;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.1.3 Record 类&lt;/h4&gt; 
&lt;p&gt;Record 类的主要目的是提供一种更简洁、更安全的方式来定义不可变的数据载体类。它自动实现了常见的方法（如&lt;code&gt;equals()&lt;/code&gt;、&lt;code&gt;hashCode()&lt;/code&gt;、&lt;code&gt;toString()&lt;/code&gt;和构造函数），从而减少了样板代码。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;不可变性&lt;/strong&gt; ：Record 类的字段默认是&lt;code&gt;final&lt;/code&gt;的，因此 Record 类是不可变的。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;简洁性&lt;/strong&gt; ：Record 类自动提供了构造函数、&lt;code&gt;equals()&lt;/code&gt;、&lt;code&gt;hashCode()&lt;/code&gt;和&lt;code&gt;toString()&lt;/code&gt;方法，无需手动编写。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;组件访问&lt;/strong&gt; ：Record 类的字段可以通过&lt;code&gt;recordName.fieldName&lt;/code&gt;的方式直接访问。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;模式匹配&lt;/strong&gt; ：Record 类支持模式匹配（Pattern Matching），可以与&lt;code&gt;instanceof&lt;/code&gt;和&lt;code&gt;switch&lt;/code&gt;表达式结合使用。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;Record 类的定义非常简单，只需要使用&lt;code&gt;record&lt;/code&gt;关键字，并声明字段类型和名称即可。例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 这里有一个包含两个字段的记录类
record Rectangle(double length, double width) { }

// 这个简洁的矩形声明等同于以下普通类
public final class Rectangle {
    private final double length;
    private final double width;

    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    double length() { return this.length; }
    double width()  { return this.width; }

    // ...
    public boolean equals...
    public int hashCode...

    // ...
    public String toString() {...}
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.1.4 switch 表达式优化&lt;/h4&gt; 
&lt;p&gt;在 Java 17 中使用 switch 表达式时，不必使用关键字 break 来跳出 switch 语句，或 return 在每个 switch case 上使用关键字来返回值；相反，我们可以返回整个 switch 表达式。这种增强的 switch 表达式使整体代码看起来更清晰，更易于阅读。switch 打印一周中某一天的字母数量的语句。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;JDK 8&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public enum Day { SUNDAY, MONDAY, TUESDAY,
    WEDNESDAY, THURSDAY, FRIDAY, SATURDAY; }

// ...

    int numLetters = 0;
    Day day = Day.WEDNESDAY;
    switch (day) {
        case MONDAY:
        case FRIDAY:
        case SUNDAY:
            numLetters = 6;
            break;
        case TUESDAY:
            numLetters = 7;
            break;
        case THURSDAY:
        case SATURDAY:
            numLetters = 8;
            break;
        case WEDNESDAY:
            numLetters = 9;
            break;
        default:
            throw new IllegalStateException("Invalid day: " + day);
    }
    System.out.println(numLetters);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;JDK 17&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Day day = Day.WEDNESDAY;    
    System.out.println(
        switch (day) {
            case MONDAY, FRIDAY, SUNDAY -&amp;gt; 6;
            case TUESDAY                -&amp;gt; 7;
            case THURSDAY, SATURDAY     -&amp;gt; 8;
            case WEDNESDAY              -&amp;gt; 9;
            default -&amp;gt; throw new IllegalStateException("Invalid day: " + day);
        }
    ); 
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.1.5 文本块&lt;/h4&gt; 
&lt;p&gt;在不使用转义序列的情况下创建多行字符串。在创建 SQL 查询或 JSON 字符串时非常有用。在下面的示例中，可以看到使用文本块时代码看起来更加简洁。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// JDK8
String message = "'The time has come,' the Walrus said,\n" +
                 "'To talk of many things:\n" +
                 "Of shoes -- and ships -- and sealing-wax --\n" +
                 "Of cabbages -- and kings --\n" +
                 "And why the sea is boiling hot --\n" +
                 "And whether pigs have wings.'\n";

// 使用文本块可以消除大部分混乱：
String message = """
    'The time has come,' the Walrus said,
    'To talk of many things:
    Of shoes -- and ships -- and sealing-wax --
    Of cabbages -- and kings --
    And why the sea is boiling hot --
    And whether pigs have wings.'
    """;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;SQL 注解描述&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// JDK8    
@Select("select distinct ta.host_name from tb_agent_info tai, tb_agent ta where 1=1 " +
        "and ta.host_name=tai.host_name and ta.status=1 and ta.master=1 and tai.report_pid_count &amp;gt; 0")
Set&amp;lt;String&amp;gt; queryAllJavaHost();

// JDK17
@Select("""
    SELECT DISTINCT ta.host_name
    FROM tb_agent_info tai, tb_agent ta
    WHERE 1=1
      AND ta.host_name = tai.host_name
      AND ta.status = 1
      AND ta.master = 1
      AND tai.report_pid_count &amp;gt; 0
 """)
 Set&amp;lt;String&amp;gt; queryAllJavaHost2();
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;可读性更强&lt;/strong&gt;：文本结构清晰可见，无需处理转义字符或字符串连接。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;减少错误&lt;/strong&gt;：不需要手动添加换行符（\n），降低了出错的可能性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;易于编辑&lt;/strong&gt;：可以直接复制粘贴格式化好的 JSON，而不需要额外的处理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;保留缩进&lt;/strong&gt;：文本块会保留的缩进，使得其在 Java 代码中的呈现更加美观。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;1.1.6 模式匹配 instanceof 优化&lt;/h4&gt; 
&lt;p&gt;它允许将 instanceof 运算符用作返回已转换对象的表达式。当我们使用嵌套的 if-else 语句时，这非常有用。在下面的示例中，可以看到我们如何使用 instanceof 运算符来捕获对象，而不是进行显式转换。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;JDK 8&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Object obj = ...;

if (obj instanceof String) {
    String str = (String) obj;
    int length = str.length();
    System.out.println("字符串长度：" + length);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;JDK 17&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Object obj = ...;

if (obj instanceof String str) {
    int length = str.length();
    System.out.println("字符串长度：" + length);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.1.7 NullPointerExceptions 的优化&lt;/h4&gt; 
&lt;p&gt;对象空指针在日常开发中遇到的比较多，一般代码报错只能精确的某一行，如果该行的代码比较复杂，涉及到多个对象，往往不能直接确定是哪一个对象为空。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class NpeDemo { 
  public static void main(String[] args) { 
    Address address=new Address();
    User user=new User();
    user.setAddress(address);
    log.info(user.getAddress().getCity().toLowerCase()); 
  }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面代码中的第 6 行链式调用，如果某一个环节出现空指针，将会抛出空指针的异常：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Exception in thread "main" java.lang.NullPointerException 
at NpeDemo.main(Main.java:6)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;使用 JDK 17&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Exception in thread "main" java.lang.NullPointerException: 
Cannot invoke "String.toLowerCase()" because the return value of "Address.getCity()" is null 
  at NpeDemo.main(Main.java:6)
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.1.8 集合、Stream 和 Optional 的增强&lt;/h4&gt; 
&lt;p&gt;Java 在集合（Collections）、Stream API 和 Optional 类方面引入了许多增强功能。主要有：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;集合增强&lt;/strong&gt;：不可变集合： 引入了创建不可变集合的便捷方法，如 List.of()、Set.of() 和 Map.of()。这些方法用于快速创建不可变集合，减少了代码量并提高了安全性。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import java.util.*;

public class CollectionsDemo {
    public static void main(String[] args) {
        // 创建不可变 list
        List&amp;lt;String&amp;gt; list = List.of("Java", "Golang", "Python");
        // 创建不可变 set
        Set&amp;lt;String&amp;gt; set = Set.of("Java", "Golang", "Python");
        // 创建不可变 map
        Map&amp;lt;String, Integer&amp;gt; map = Map.of("Java", 1, "Golang", 2, "Python", 3);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;集合工厂方法&lt;/strong&gt;：Java 17 还引入了集合工厂方法，如 List.copyOf()、Set.copyOf() 和 Map.copyOf()，用于从现有集合创建不可变副本。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Stream API 增强&lt;/strong&gt; ：&lt;code&gt;takeWhile&lt;/code&gt;和&lt;code&gt;dropWhile&lt;/code&gt;：基于条件截取或跳过元素；&lt;code&gt;iterate&lt;/code&gt;：支持终止条件的迭代；&lt;code&gt;ofNullable&lt;/code&gt;：将可能为&lt;code&gt;null&lt;/code&gt;的值转换为 Stream。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Optional 增强&lt;/strong&gt; ： &lt;code&gt;ifPresentOrElse&lt;/code&gt;：值存在时执行操作，否则执行另一个操作；&lt;code&gt;or&lt;/code&gt;：在值不存在时提供替代值；&lt;code&gt;stream&lt;/code&gt;：将&lt;code&gt;Optional&lt;/code&gt;转换为 Stream。&lt;/p&gt; 
&lt;h3&gt;1.2 新 API 和工具&lt;/h3&gt; 
&lt;h4&gt;1.2.1 新的 HttpClient&lt;/h4&gt; 
&lt;p&gt;可以使用&lt;code&gt;HttpClient&lt;/code&gt;使用来发送请求并检索其响应。 &lt;code&gt;HttpClient&lt;/code&gt;可以通过&lt;code&gt;builder&lt;/code&gt;来创建。该&lt;code&gt;newBuilder&lt;/code&gt;方法返回一个构建器，用于创建默认&lt;code&gt;HttpClient&lt;/code&gt;实现的实例。该构建器可用于配置每个客户端的状态，例如：首选协议版本（HTTP/1.1 或 HTTP/2）、是否遵循重定向、代理、身份验证器等。 构建完成后，&lt;code&gt;HttpClient&lt;/code&gt;是不可变的，可用于发送多个请求。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 同步示例
HttpClient client = HttpClient.newBuilder()
        .version(Version.HTTP_1_1)
        .followRedirects(Redirect.NORMAL)
        .connectTimeout(Duration.ofSeconds(20))
        .proxy(ProxySelector.of(new InetSocketAddress("proxy.example.com", 80)))
        .authenticator(Authenticator.getDefault())
        .build();
   HttpResponse&amp;lt;String&amp;gt; response = client.send(request, BodyHandlers.ofString());
   System.out.println(response.statusCode());
   System.out.println(response.body());  

// 异步示例
HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create("https://foo.com/"))
        .timeout(Duration.ofMinutes(2))
        .header("Content-Type", "application/json")
        .POST(BodyPublishers.ofFile(Paths.get("file.json")))
        .build();
   client.sendAsync(request, BodyHandlers.ofString())
        .thenApply(HttpResponse::body)
        .thenAccept(System.out::println);  
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;如果不希望引入三方依赖（三方依赖漏洞和 Bug 等需要经常升级），可以使用 JDK 提供的原生的 httpClient API，适用场景&lt;code&gt;中间件&lt;/code&gt;。&lt;/p&gt; 
&lt;h4&gt;1.2.2 打包工具 jpackage[2]&lt;/h4&gt; 
&lt;p&gt;该工具将以 Java 应用程序和 Java 运行时镜像作为输入，生成包含所有必要依赖项的 Java 应用程序镜像。它能够生成特定平台格式的原生软件包，例如 Windows 上的 exe 文件或 macOS 上的 dmg 文件。每种格式都必须在其运行的平台上构建，不支持跨平台。该工具将提供一些选项，允许以各种方式定制打包的应用程序。该工具最大特点是无需单独安装 JDK 环境，例如用 JDK17 写了一个 MCP Server 工具，直接打包为可执行文件安装即可，减少环境依赖安装。&lt;/p&gt; 
&lt;h4&gt;1.2.3 进程相关 API[3]&lt;/h4&gt; 
&lt;p&gt;进程管理功能得到了显著增强，&lt;code&gt;ProcessHandle&lt;/code&gt;提供了更强大的功能来创建、监控和管理本地进程。这些改进使得 Java 程序能够更灵活地与操作系统交互，同时提供了更详细的进程信息和更强大的生命周期管理功能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1.创建进程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 Java 中，创建新进程通常使用&lt;code&gt;ProcessBuilder&lt;/code&gt;或&lt;code&gt;Runtime.getRuntime().exec()&lt;/code&gt;。而 Java 17 上&lt;code&gt;ProcessHandle&lt;/code&gt;提供了更强大的功能来管理这些进程。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ProcessBuilder pb = new ProcessBuilder("echo", "Hello World!");
Process p = pb.start();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;2.监控进程&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class ProcessTest {

  // ...

  static public void startProcessesTest() throws IOException, InterruptedException {
    List&amp;lt;ProcessBuilder&amp;gt; greps = new ArrayList&amp;lt;&amp;gt;();
    greps.add(new ProcessBuilder("/bin/sh", "-c", "grep -c \"java\" *"));
    greps.add(new ProcessBuilder("/bin/sh", "-c", "grep -c \"Process\" *"));
    greps.add(new ProcessBuilder("/bin/sh", "-c", "grep -c \"onExit\" *"));
    ProcessTest.startSeveralProcesses (greps, ProcessTest::printGrepResults);      
    System.out.println("\nPress enter to continue ...\n");
    System.in.read();  
  }

  static void startSeveralProcesses (
    List&amp;lt;ProcessBuilder&amp;gt; pBList,
    Consumer&amp;lt;Process&amp;gt; onExitMethod)
    throws InterruptedException {
    System.out.println("Number of processes: " + pBList.size());
    pBList.stream().forEach(
      pb -&amp;gt; {
        try {
          Process p = pb.start();
          System.out.printf("Start %d, %s%n",
            p.pid(), p.info().commandLine().orElse("&amp;lt;na&amp;gt;"));
          p.onExit().thenAccept(onExitMethod);
        } catch (IOException e) {
          System.err.println("Exception caught");
          e.printStackTrace();
        }
      }
    );
  }
  
  static void printGrepResults(Process p) {
    System.out.printf("Exit %d, status %d%n%s%n%n",
      p.pid(), p.exitValue(), output(p.getInputStream()));
  }

  private static String output(InputStream inputStream) {
    String s = "";
    try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {
      s = br.lines().collect(Collectors.joining(System.getProperty("line.separator")));
    } catch (IOException e) {
      System.err.println("Caught IOException");
      e.printStackTrace();
    }
    return s;
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;3.获取进程信息&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public static void getInfoTest() throws IOException {
        ProcessBuilder pb = new ProcessBuilder("echo", "Hello World!");
        String na = "&amp;lt;not available&amp;gt;";
        Process p = pb.start();
        ProcessHandle.Info info = p.info();
        System.out.printf("Process ID: %s%n", p.pid());
        System.out.printf("Command name: %s%n", info.command().orElse(na));
        System.out.printf("Command line: %s%n", info.commandLine().orElse(na));

        System.out.printf("Start time: %s%n",
            info.startInstant().map((Instant i) -&amp;gt; i
                .atZone(ZoneId.systemDefault()).toLocalDateTime().toString())
                .orElse(na));

        System.out.printf("Arguments: %s%n",
            info.arguments().map(
                (String[] a) -&amp;gt; Stream.of(a).collect(Collectors.joining(" ")))
                .orElse(na));

        System.out.printf("User: %s%n", info.user().orElse(na));
}

输出
Process ID: 18761
Command name: /usr/bin/echo
Command line: echo Hello World!
Start time: 2017-05-30T18:52:15.577
Arguments: &amp;lt;not available&amp;gt;
User: administrator
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;1.2.4 AI 工具最低版本为 JDK17&lt;/h4&gt; 
&lt;p&gt;最近火热的 AI 大模型工具，JDK 8 不再兼容，运行的最低版本为 JDK 17，例如 Spring AI 工具。&lt;/p&gt; 
&lt;h3&gt;1.3 性能优化与 Bug 修复&lt;/h3&gt; 
&lt;h4&gt;1.3.1 垃圾回收器改进 ZGC&lt;/h4&gt; 
&lt;p&gt;ZGC 作为新一代的垃圾回收器，主要目标：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持 TB 级内存&lt;/li&gt; 
 &lt;li&gt;停顿时间控制在 10ms 之内&lt;/li&gt; 
 &lt;li&gt;对程序吞吐量影响小于 15%&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;据官方测评数据，在内存为 128GB 的机器上，相比于 G1 来说，性能提高 30%，停顿时间减少 99%。&lt;/p&gt; 
&lt;h4&gt;1.3.2 NIO 重写与优化&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Unix-Domain 套接字&lt;/strong&gt;：在 JDK8 上如果想要使用 UDS，一般使用 Netty 或者开源的 Juds 库，JDK 17 支持了该功能，无需使用第三方库；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;文件通道的优化&lt;/strong&gt;：可以将文件的某个区域直接映射到内存中，从而实现高效的读写操作。这种方式利用了操作系统的内存映射机制，减少了 I/O 操作的开销；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;零拷贝支持&lt;/strong&gt;：允许数据直接从磁盘的一个位置复制到另一个位置，而无需经过用户态内存。这减少了数据在用户态和内核态之间的拷贝次数，从而显著提高了性能。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;1.3.3 Java SDK 模块化设计&lt;/h4&gt; 
&lt;p&gt;JVM 的模块化是 Java 9 引入的一个重要特性，通过 Java Platform Module System (JPMS) 实现。这一特性旨在解决 Java 应用在可扩展性和维护上的问题，提供更高级别的封装和依赖管理机制。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;减少环境资源开销&lt;/strong&gt;：在 JDK 9 之前，每次启动 JVM 都要耗费至少 30MB 到 60MB 的内存空间，因为 JVM 需要加载整个 rt.jar。模块化允许 JVM 选择性地加载必需的模块，从而减少内存占用。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;提升开发效率和运行速度&lt;/strong&gt;：随着代码库的复杂性增加，开发效率和运行速度会受到影响。模块化通过规范化路径和依赖关系，使系统更安全、更高效。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;规范化路径及依赖关系&lt;/strong&gt;：JDK 9 之前，系统没有对不同 JAR 之间的依赖或敏感路径进行限制，导致所有 JAR 都可以被访问，暴露了安全问题。模块化通过管理模块间的依赖关系，隐藏不必要的模块，提高了安全性和空间利用率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;1.3.4 Java Agent 机制的 Attach Bug 修复&lt;/h4&gt; 
&lt;p&gt;Java Attach Socket 文件被删除后会导致 Java Agent 注入失败，在 JDK 8 上只能通过重启解决，而 JDK 17 会重新创建一个新的文件。&lt;/p&gt; 
&lt;h4&gt;1.3.5 弹性元空间[4]&lt;/h4&gt; 
&lt;p&gt;更及时地将未使用的元空间内存回收，减少元空间占用的内存。&lt;/p&gt; 
&lt;ol start="2"&gt; 
 &lt;li&gt;JDK17+ZGC 在安全领域的实践&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;2.1 美团 JDK 的现状&lt;/h3&gt; 
&lt;p&gt;在美团信息安全部，JDK8（Oracle JDK8u201）依然是主流版本，其次是 Open JDK17，剩下为 Open JDK 11。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//741b89994a9cb115f8cfa24e32a8c514.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.2 ZGC 适用场景&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//63b1d3093a63550bd74f5489a0c68462.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;服务器成本压力大：服务器数量大于 100 台、单机配置大于 16C16G、Java 堆内存超过 16G 等。&lt;/li&gt; 
 &lt;li&gt;单机 CPU 高：峰值大约在 50%&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//33bd0463bac3ff69b941c53beb498801.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;性能火焰图中 GC 占比高&lt;/li&gt; 
 &lt;li&gt;高峰期故障雷达、监控大盘和服务日志等告警频繁&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2.3 ZGC 效果&lt;/h3&gt; 
&lt;h4&gt;2.3.1 性能压测效果&lt;/h4&gt; 
&lt;p&gt;在测试服务不同接口中，ZGC 在高 QPS 场景中收益较大（服务的 QPS 超过 1 万）：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;TP9999&lt;/strong&gt;：下降 220~380ms，下降幅度 18%~74%。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;TP999&lt;/strong&gt;：下降 60-125ms，下降幅度 10%~63%。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;TP99&lt;/strong&gt;：下降 3ms-20ms，下降幅度 0%-25%。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;一些重度依赖外部的接口中性能优化不大，原因是这些服务的响应时间瓶颈不是 GC，而是外部依赖的性能，在一些低 QPS 接口中对比不太明显。&lt;/p&gt; 
&lt;h4&gt;2.3.2 案例 1：智能决策系统（JDK 11+ZGC 升级到 JDK 17+ZGC）&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;峰值 cpu.busy 指标下降&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;升级前: 47.8565%&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//f718dd4d745bb448173cbe960ab78a8f.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;升级后: 41.4933%&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//6da00d3b35876b2f54ef3da8ce680972.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;系统长期运行时 TP9999 性能稳定&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;运行 15 天，JDK11 机器长时间不重启三九、四九线会逐渐升高，JDK 17 机器较为稳定。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//a82620036e2172e5eed80eede0944f36.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;服务失败率显著降低&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;UGC 集群升级效果：错误数量由峰值 6000 下降到 349。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//9d6499c78dd50077ab3a09c8b9a5fded.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;JVM 元空间使用降低&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//14e0e2f136345f99ea5521fe4de3de52.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;单机维度高峰期性能指标&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//1b3e2d500a2966651ec0ac9ecd2a5663.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.3.3 案例 2：内容安全核心服务 (JDK 8+CMS 升级到 JDK 17+ZGC）&lt;/h4&gt; 
&lt;p&gt;该服务是内容安全的代理层，主要负责匹配请求的分发、辅助功能支撑（日志、监控、熔断）以及一些个性化业务需求。当前该服务 GC 是 CMS，该服务线上的 Young GC 平均耗时是 17ms，平均每分钟 GC 次数是 6 次，该服务接口平均响应时间是 2.6ms。&lt;/p&gt; 
&lt;p&gt;根据文章《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2017%2F12%2F29%2Fjvm-optimize.html" target="_blank"&gt;从实际案例聊聊 Java 应用的 GC 优化&lt;/a&gt;》中提供的计算方式，受到 Young GC 影响的请求占比是：&lt;/p&gt; 
&lt;p&gt;$$受 GC 影响请求占比 = \frac{N * \left ( GC 时间 + 接口响应时间 \right ) }{T} = \frac{6 * \left ( 17 + 2.6 \right ) }{60000} = 0.196%$$&lt;/p&gt; 
&lt;p&gt;即有 0.196% 的请求收到 GC 时间 0-17ms 不等的影响。其中收到 GC 停顿完整影响的请求占比：&lt;/p&gt; 
&lt;p&gt;$$受 GC 完整影响请求占比 = \frac{N * \left (接口响应时间 \right ) }{T} = \frac{6 * 2.6}{60000} = 0.026%$$&lt;/p&gt; 
&lt;p&gt;即其中有 0.026% 的请求受到完整的 GC 停顿时间影响，即耗时增加 17ms，可以大致理解为请求响应的 9999 线会因 GC 停顿而导致 17ms 的上涨。&lt;/p&gt; 
&lt;p&gt;根据 ZGC 的 STW 的耗时在毫秒甚至亚毫秒级别，因此理论上升级后服务的 9999 线可以降低 17ms 左右。在实际生产中，还会有 Full GC 的影响，会带来耗时的进一步提升，ZGC 在该部分可以避免 Full GC 带来的影响。&lt;/p&gt; 
&lt;p&gt;服务升级采用的是 Tomcat 9+JDK 17 的配置，录制线上流量进行压测，使用同样的流量对先前采用 CMS 垃圾回收的以及采用 ZGC 垃圾回收方式的同时进行压测。服务器配置均为 8C16G，800QPS 的压测，通过 2h 左右的压测，&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;分析接口耗时统计&lt;/strong&gt;：可得到以下数据，发现耗时均有明显下降，9999 线的下降量低于理论的 17ms，由于实际环境中其他因素的影响也基本符合预期。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//56b4d79c7da3403c9fde82947bf34f88.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;分析 CPU 和 JVM 占用情况：CPU 和 JVM 占用情况发现，CPU 占用在峰值处会提升 10% 左右，JVM 占用情况基本一致。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//5c62be54cdd72cde90060ce5bf8c78cc.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.4 ZGC 实现原理简介&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;更多详情，可参考《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2020%2F08%2F06%2Fnew-zgc-practice-in-meituan.html" target="_blank"&gt;新一代垃圾回收器 ZGC 的探索与实践&lt;/a&gt;》一文。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;2.4.1 CMS 与 G1 停顿时间瓶颈&lt;/h4&gt; 
&lt;p&gt;在介绍 ZGC 之前，首先回顾一下 CMS 和 G1 的 GC 过程以及停顿时间的瓶颈。CMS 新生代的 Young GC、G1 和 ZGC 都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。&lt;/p&gt; 
&lt;p&gt;标记-复制算法应用在 CMS 新生代（ParNew 是 CMS 默认的新生代垃圾回收器）和 G1 垃圾回收器中。标记-复制算法可以分为三个阶段：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;标记阶段&lt;/strong&gt;，即从 GC Roots 集合开始，标记活跃对象；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;转移阶段&lt;/strong&gt;，即把活跃对象复制到新的内存地址上；&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;重定位阶段&lt;/strong&gt;，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下面以 G1 为例，通过 G1 中标记-复制算法过程（G1 的 Young GC 和 Mixed GC 均采用该算法），分析 G1 停顿耗时的主要瓶颈。G1 垃圾回收周期如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//475b53df8e7a764b5b232636407dfcaa.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;G1 的混合回收过程可以分为标记阶段、清理阶段和复制阶段：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;标记阶段停顿分析&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;初始标记阶段&lt;/strong&gt;：初始标记阶段是指从根节点（GC Roots）出发标记全部直接子节点的过程，该阶段是 STW 的。由于 GC Roots 数量不多，通常该阶段耗时非常短。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;并发标记阶段&lt;/strong&gt;：并发标记阶段是指从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和 GC 线程可以同时活动。并发标记耗时相对长很多，但因为不是 STW，所以我们不太关心该阶段耗时的长短。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;再标记阶段&lt;/strong&gt;：重新标记那些在并发标记阶段发生变化的对象。该阶段是 STW 的。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;清理阶段停顿分析&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是 STW 的。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;复制阶段停顿分析&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是 STW 的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;四个 STW 过程中，初始标记因为只标记 GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1 停顿时间的瓶颈主要是标记-复制中的转移阶段 STW。为什么转移阶段不能和标记阶段一样并发执行呢？主要是 G1 未能解决转移过程中准确定位对象地址的问题。&lt;/p&gt; 
&lt;h4&gt;2.4.2 ZGC 原理&lt;/h4&gt; 
&lt;p&gt;与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进：&lt;strong&gt;ZGC 在标记、转移和重定位阶段几乎都是并发的&lt;/strong&gt;，这是 ZGC 实现停顿时间小于 10ms 目标的最关键原因。&lt;/p&gt; 
&lt;p&gt;ZGC 垃圾回收周期如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//ff472f97b6b955687ebeabd32e9a9ee7.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;ZGC 只有三个 STW 阶段：&lt;strong&gt;初始标记，再标记，初始转移&lt;/strong&gt;。其中，初始标记和初始转移分别都只需要扫描所有 GC Roots，其处理时间和 GC Roots 的数量成正比，一般情况耗时非常短；再标记阶段 STW 时间很短，最多 1ms，超过 1ms 则再次进入并发标记阶段。即，ZGC 几乎所有暂停都只依赖于 GC Roots 集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与 ZGC 对比，G1 的转移阶段完全 STW 的，且停顿时间随存活对象的大小增加而增加。&lt;/p&gt; 
&lt;h4&gt;2.4.3 主要特点&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;单代&lt;/strong&gt;：ZGC 没有分代，基于"大部分对象朝生夕死"的假设，没有 Young GC 的概念（这里仅指 JDK 17，JDK 21 支持分代回收，性能更高）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;基于 Region&lt;/strong&gt;： G1 的每个 Region 大小是完全一样的，而 ZGC 的 Region 更灵活，其中大型 Region 大小不固定,可以动态变化，也不会被重分配，因为复制一个大对象代价太高。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;部分压缩&lt;/strong&gt;： 基于 Region，"标记-整理"，相对 CMS 压缩时间更短。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 NUMA&lt;/strong&gt;： 对应有 UMA，每个 CPU 对应有一块内存，每个 CPU 优先访问这块内存。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//addc3e92b946e1d9221a8cb50eff2b94.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;染色指针&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//143532af9ea5101d47ac6e49dec629eb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以前的垃圾回收器的 GC 信息都保存在对象头中，ZGC 将 GC 信息保存在了染色指针上,无需进行对象访问就可以获得 GC 信息。这就是 ZGC 在标记和转移阶段速度更快的原因。Marked0、Marked1 和 Remapped 这三个虚拟内存作为 ZGC 的三个视图空间，在同一个时间点内只能有一个有效。ZGC 就是通过这三个视图空间的切换，来完成并发的垃圾回收。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;读屏障&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;读屏障，在标记和移动对象的阶段，每次从堆里对象的引用类型中读取一个指针的时候，都需要加上一个 Load Barriers。用于确定对象的引用地址是否满足条件，并作出相应动作。&lt;/p&gt; 
&lt;ol start="3"&gt; 
 &lt;li&gt;JDK 17 升级实践过程&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;主要分为三个阶段：安装部署、解决兼容性问题、性能测试与参数优化。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;如果公司的中间件大部分基于 JDK 8，工程代码编译可以基于 JDK 8，运行环境使用 JDK 17。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;3.1 安装与兼容性问题&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;1.主要的问题举例&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;JVM 运行的报错信息：module java.base does not "opens java.util.concurrent.locks" to unnamed module&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;[ERROR] main JsonUtil Json parse failed
java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock java.util.concurrent.locks.ReentrantReadWriteLock.readerLock accessible: module java.base does not "opens java.util.concurrent.locks" to unnamed module @1ba9117e
at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)
at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)
at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)
at java.base/java.lang.reflect.Field.setAccessible(Field.java:172)
at com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(ClassUtil.java:939)
at com.fasterxml.jackson.databind.deser.impl.FieldProperty.fixAccess(FieldProperty.java:104)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;2.原因&lt;/strong&gt;：JDK9 之后 Java API 使用了模块化设计方案，用户模块无法反射调用 Java 代码，需要使用开启对应模块访问权限（没有引入新的安全问题，相当于没有用模块隔离的功能）。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3.解决方式&lt;/strong&gt;：　JVM 参数增加如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;--add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.io=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED --add-opens java.base/java.net=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/java.security=ALL-UNNAMED --add-opens java.base/java.text=ALL-UNNAMED --add-opens java.base/java.time=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.util.concurrent=ALL-UNNAMED --add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED --add-opens java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-opens java.base/jdk.internal.access=ALL-UNNAMED --add-opens java.base/jdk.internal.misc=ALL-UNNAMED
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其他软件等兼容性问题，根据自身服务报错，对应解决问题。&lt;/p&gt; 
&lt;h3&gt;3.2 性能压测&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;基准&lt;/strong&gt;： JDK 8+CMS&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;压测&lt;/strong&gt;：实验组和对照组压测后重启避免性能优化为结果影响并取平均值&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;指标监控&lt;/strong&gt;： 峰值 CPU、平均 CPU、TP9999、报错数量、GC 总时间和次数、JVM 堆内存和元空间变化等&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;其他&lt;/strong&gt;：性能火焰图&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;3.3 JVM 参数&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;-Xmx18g -Xms18g 堆大小&lt;/li&gt; 
 &lt;li&gt;-XX:MaxDirectMemorySize=2G 直接内存&lt;/li&gt; 
 &lt;li&gt;-XX:+HeapDumpOnOutOfMemoryError 当 JVM 发生 OOM 时，自动生成 DUMP 文件。&lt;/li&gt; 
 &lt;li&gt;-XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m 设置 codecache 大小，默认 128m&lt;/li&gt; 
 &lt;li&gt;-XX:+UseZGC 使用 ZGC&lt;/li&gt; 
 &lt;li&gt;-XX:ZAllocationSpikeTolerance=2 ZGC 触发自适应算法的修正系数，默认 2，数值越大，越早的触发 ZGC&lt;/li&gt; 
 &lt;li&gt;-XX:ZCollectionInterval=0 ZGC 的周期。默认值为 0，表示不需要触发垃圾回收。固定周期垃圾回收。ZGC 发生的最小时间间隔，单位秒&lt;/li&gt; 
 &lt;li&gt;-XX:ConcGCThreads=4 并发阶段的 GC 线程数，默认是总核数的 12.5%&lt;/li&gt; 
 &lt;li&gt;-XX:ZStatisticsInterval=10 控制统计信息输出的间隔，默认 10s&lt;/li&gt; 
 &lt;li&gt;-XX:ParallelGCThreads=16 并行工作线程数据，STW 阶段使用线程数，默认是总核数的 60%&lt;/li&gt; 
 &lt;li&gt;-Xlog:safepoint,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m' 设置 GC 日志中的内容、格式、位置以及每个日志的大小&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;本服务 prod 机器 16c，16g 成功运行起来的 JVM 参数（还在调整中，仅供参考）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-server -Xmx12g -Xms12g -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+UseZGC -XX:+UseDynamicNumberOfGCThreads -XX:ConcGCThreads=3 -XX:ParallelGCThreads=8 -XX:ZCollectionInterval=130 -XX:ZAllocationSpikeTolerance=1 -XX:MaxDirectMemorySize=460m -XX:MetaspaceSize=330m -XX:MaxMetaspaceSize=330m -XX:ReservedCodeCacheSize=256m -XX:InitialCodeCacheSize=256m -XX:+UseCountedLoopSafepoints -XX:+SafepointTimeout -XX:SafepointTimeoutDelay=500 -XX:GuaranteedSafepointInterval=0 -XX:+DisableExplicitGC -XX:+HeapDumpOnOutOfMemoryError -XX:ZStatisticsInterval=130 -XX:+PrintGCDetails -Xlog:safepoint,class+load=info,class+unload=info,classhisto*=trace,age*,gc*=info:file=/opt/logs/logs/gc-%t.log:time,tid,tags:filecount=5,filesize=50m --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.io=ALL-UNNAMED --add-opens java.base/java.math=ALL-UNNAMED --add-opens java.base/java.net=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/java.security=ALL-UNNAMED --add-opens java.base/java.text=ALL-UNNAMED --add-opens java.base/java.time=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED --add-opens java.base/java.util.concurrent=ALL-UNNAMED --add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED --add-opens java.base/java.util.concurrent.atomic=ALL-UNNAMED --add-opens java.base/jdk.internal.access=ALL-UNNAMED --add-opens java.base/jdk.internal.misc=ALL-UNNAMED --add-opens java.base/sun.reflect.generics.reflectiveObjects=ALL-UNNAMED --add-opens java.base/jdk.internal.perf=ALL-UNNAMED --add-opens java.base/java.instrument=ALL-UNNAMED --add-opens jdk.attach/sun.tools.attach=ALL-UNNAMED 
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;总结&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;ul&gt; 
 &lt;li&gt;ZGC 作为新一代垃圾回收器，各项性能指标都比较突出，升级之后，机器成本和性能收益明显；&lt;/li&gt; 
 &lt;li&gt;Spring AI SDK 支持的 JDK 版本最小为 17，升级到 JDK 17 能更好地拥抱 AI 新技术；&lt;/li&gt; 
 &lt;li&gt;直接从 JDK 8 升级到 JDK 17 跨度较大，需要解决的兼容性问题较多，如果公司的基础组件不支持 JDK 17，可以考虑先升级到 JDK 11 做一个过渡；&lt;/li&gt; 
 &lt;li&gt;如果在升级与实践的过程中遇到了一些问题，可以结合 AI 大模型来给出解决方案，帮助提高升级效率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;[1] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fen%2Fjava%2Fjavase%2F17%2Flanguage%2Fjava-language-changes-summary.html" target="_blank"&gt;语言特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[2] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fen%2Fjava%2Fjavase%2F17%2Fdocs%2Fspecs%2Fman%2Fjpackage.html" target="_blank"&gt;打包工具 jpackage&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[3] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.oracle.com%2Fen%2Fjava%2Fjavase%2F17%2Fcore%2Fprocess-api1.html" target="_blank"&gt;进程相关 API&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[4] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F387" target="_blank"&gt;弹性元空间&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[5] TP999：指的是 OctoService.TP999&lt;/li&gt; 
 &lt;li&gt;[6] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmalloc.se%2Fblog%2Fzgc-jdk16" target="_blank"&gt;TP9999&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;| 关注「美团技术团队」微信公众号，在公众号菜单栏对话框回复【2024 年货】、【2023 年货】、【2022 年货】、【2021 年货】、【2020 年货】、【2019 年货】、【2018 年货】、【2017 年货】等关键词，可查看美团技术团队历年技术文章合集。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//99197a0cda5599168313884ca25c4fd6.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;| 本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明 "内容转载自美团技术团队"。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至 &lt;a href="https://www.oschina.net/action/GoToLink?url=mailto%3Atech%40meituan.com" target="_blank"&gt;tech@meituan.com&lt;/a&gt; 申请授权。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/meituantech/blog/18627969</link>
      <guid isPermaLink="false">https://my.oschina.net/meituantech/blog/18627969</guid>
      <pubDate>Sun, 11 May 2025 03:41:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>深圳程序员住车里，被质疑占用公共资源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;今年 4 月，深圳程序员张运来因不租房住车里引发大量关注。报道称，张运来工作日期间天天睡车里，周五晚上再开车约 300 公里回阳江老家陪家人，周一一早再开车回深圳上班。利用公园的公共衞生间洗漱，每晚只需花费 6 元停车费，每日消费仅 100 元上下。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;通过住进车里，「三年多省了差不多十万块钱」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="416" src="https://oscimg.oschina.net/oscnet/up-a27f5633fe69b3d829c02629eb8616161d2.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;但该行为也引来了许多网友的质疑，认为他占用了公共资源。对此，红星新闻记者近日专访张运来。张运来解释称，自己并没有不文明行为。深圳湾晚上的空闲车位很多，他只是刚好利用空闲时间在那边过夜，最多也只是在公园的洗手间进行刷牙洗脸。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356800</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356800</guid>
      <pubDate>Sun, 11 May 2025 03:20:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>罗永浩：3 个月后发布新 AI 产品，梁文锋建议我「靠嘴吃饭」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;罗永浩近日以「科技创业者」身份出席线下活动时表示，接下来两三个月内，他会发布一款与邮件等场景相关的提高工作效率的 AI 生产力软件工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;罗永浩表示，他认为用 AI 做图片生成、视频生成等技术比较惊艳。但他认为，具体到 Email 场景中，无论是雅虎还是谷歌，当前很多 Email 和 AI 结合的 AI 邮件产品体验做得不好。而且，很多相关的美国明星创业公司也融了不少钱，但产品做得很差。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「然后我就感觉，我们可以把 AI 邮件这块做得更好，这个过程里我们虽然没有资源和钱去做预训练，但基于第一批的用户不断优化，我们是有信心的。而且我不担心这个事儿会被大公司覆盖掉。所以我们想要做得更好，被收费也是一个好的出路。」罗永浩表示，用 GUI 设计出来的工作流可以处理海量的邮件，如果利用 AI 把邮件产品优化的话，可以节省掉 2/3 以上的时间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="335" src="https://oscimg.oschina.net/oscnet/up-ccc7ab26346d316e69b64e6f303f93227d1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;谈到 AI 取代人类话题，罗永浩表示，「我经常被非科技行业的人问，AI 替代了人怎么办。为什么都问我呢？毕竟我也还没做出来 AI 产品」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;罗永浩说，AI 并不意味着所有人都会失业，但是每个人都要学会 AI，哪怕是在办公室里偷懒，也要把更多的时间用在 AI 上，否则被裁员而失业了，你们也不知道该怎么办。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「我们以前招了几个人做战略分析，写 15000 字战略报告那种，现在用 AI 很快能写出来，15 分钟做到之前一周内的水平，质量还好。结果还没裁这几个人，他们就自己走了。去了哪里呢？去了那些对 AI 还不懂的传统公司。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，罗永浩也谈到 DeepSeek，他曾在去年见过一次梁文锋。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;罗永浩表示，他在酒店大堂里面和梁文锋见面攀谈，他认为梁文锋不像是老板，而像一名学生，甚至像是「没找到工作的博士后」，非常朴素。对于 AI 创业，梁文锋给罗永浩提了意见，问他为什么要做 AI，说他用嘴说话的能力是中国前三，就应该专注在用嘴这件事，建议去做个播客节目。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「他说我没有别的意思，我说我只是觉得一个人在任何领域里，如果能做到全国前几名，应该要坚持做这件事。」因此，罗永浩现场表示，2025 今年底前，他将可能创立一个 AI 领域的播客节目。而梁文锋对于罗永浩做 AI 应用称「结果我不好判断」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356791</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356791</guid>
      <pubDate>Sun, 11 May 2025 03:01:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>网信办整治 AI 滥用，3500 余款违规 AI 产品被处置</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;「清朗·整治 AI 技术滥用」专项行动于 2025 年 4 月启动。第一阶段累计处置违规小程序、应用程序、智能体等 AI 产品 3500 余款，清理违法违规信息 96 万余条，处置账号 3700 余个，各项工作取得积极进展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="245" src="https://oscimg.oschina.net/oscnet/up-61fa8623f6acb022a23177614c906e2d7ea.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其中，在处置违规 AI 产品方面，腾讯规范应用程序管理，提高准入门槛，优化巡查机制，驳回、处置违规小程序、应用程序等共计 570 余款。在清理违规 AI 产品教程和商品方面，微博通过策略识别、用户举报等多渠道审核，累计处置违规内容 4800 余条，并公布典型案例。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在加强训练语料管理方面，通义平台围绕数据生命周期建立安全管理体系，在数据采集、训练、使用等阶段加强训练语料管理。在强化安全管理措施方面，抖音建立「红蓝对抗」机制，模拟攻击案例，修复潜在安全漏洞，优化模型对虚假信息的识别能力。在落实内容标识要求方面，阿里、快手、稀宇等重点平台积极推进元数据隐式标识落地落实。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在防范重点领域安全风险方面，小红书在模型后置训练阶段输入专业领域数据，提升模型对医疗、金融、未成年人等重点领域问题的理解能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;据悉，下一步，中央网信办将聚焦 AI 造谣、低俗内容等 7 类突出问题，开展「清朗·整治 AI 技术滥用」专项行动第二阶段工作，构建技术监测体系，形成处置处罚规范，推动内容标识如期落地，形成长效工作机制，着力维护清朗网络生态，推动人工智能向善向好。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356788</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356788</guid>
      <pubDate>Sun, 11 May 2025 02:44:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>月之暗面 Kimi 首个 Agent 开始灰度测试</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Kimi 首个 Agent Kimi-Researcher（深度研究）已于日前开始小范围灰度测试。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FYV4M8YNZ5hnzfxaFQ7PL9A" target="_blank"&gt;公告&lt;/a&gt;称，Kimi-Researcher 是基于端到端自主强化学习（end-to-end agentic RL）技术训练的新一代 Agent 模型，也是一个专为深度研究任务而生的 Agent 产品。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;接下来，Kimi 还计划逐步开源 Kimi-Researcher 基础预训练模型、以及强化学习后的模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据介绍，对于每一个问题，Kimi-Researcher 都会自主规划任务执行流程，最终交付完整结果：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;澄清问题（clarification）：理解问题时主动反问，构建更清晰的问题空间；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;深入思考：每个任务平均进行 23 步推理，自主梳理并解决需求；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;主动搜索：每个任务，平均规划 74 个关键词，找到 206 个网址，由模型判断并筛选出信息质量最高的前 3.2% 内容，剔除冗余、低质信息；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;调用工具，交付结果：自主调用浏览器、代码等工具，处理原始数据、自动生成分析结论，端到端完成交付。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;为了保证输出的质量和信息覆盖度，Kimi-Researcher 采用异步执行方式，用更多时间逐步推理、检索和撰写内容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="250" src="https://oscimg.oschina.net/oscnet/up-7bf271cbc490315d0514136f703d2363fc1.gif" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;在完全&lt;/span&gt;&lt;strong style="color:#000000"&gt;零结构、无流程设计&lt;/strong&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;的设置下，&lt;/span&gt;&lt;span style="color:#000000"&gt;Kimi-Researcher 的&amp;nbsp;&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;Humanity’s Last Exam（HLE）基准测试得分如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Pass@1 准确率：26.9%&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Pass@4 准确率：40.17%&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这一表现超过了 Claude 4 Opus（10.7%）、Gemini 2.5 Pro（21.6%），略高于 OpenAI Deep Research（26.6%），和 Gemini-Pro 的 Deep Research Agent（26.9%）打平，是目前已知最高水平之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;在红杉中国发布的 xbench 基准测试中 —— 一套对齐真实任务场景的 AI 能力评估体系，Kimi-Researcher 在 DeepSearch 任务中取得 69% 的平均通过率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="331" src="https://oscimg.oschina.net/oscnet/up-34b4836de3fd3cf3656ab62331a137ccf11.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span style="color:#000000"&gt;可访问&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#0080ff"&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kimi.com%2F" target="_blank"&gt;&lt;u&gt;&lt;strong&gt;&lt;u&gt;kimi.com&lt;/u&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/a&gt;&amp;nbsp;&lt;/span&gt;&lt;strong style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span style="color:#000000"&gt;申请内测。&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#000000"&gt;对于获得&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;内测权限的用户：只需打开 Kimi 对话框下方的「深度研究」按钮，即可开始使用（每月 20 次额度，同时支持 1 条任务并发）。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356787</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356787</guid>
      <pubDate>Sun, 11 May 2025 02:37:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>比尔·盖茨与 Linus 共同参加晚宴，50 年来首次会面</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;近日，微软创始人比尔·盖茨与 Linux 内核创始人林纳斯·托瓦兹在微软 Azure 首席技术官马克·鲁西诺维奇家中出席晚宴，这是二人 50 年来首次同框。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-8a55b472cfd2df4a60c8160a72ba060d705.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据 The Verge 报道，马克·鲁西诺维奇在 LinkedIn 上&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linkedin.com%2Fposts%2Fmarkrussinovich_i-had-the-thrill-of-a-lifetime-hosting-dinner-activity-7341857033932914691-f5Kw%2F" target="_blank"&gt;分享&lt;/a&gt;了一张四人合照，除盖茨和托瓦兹外，还包括戴维·卡特勒和他自己。他发文表示，能举办这次晚宴是一生的荣幸，托瓦兹从未见过盖茨，戴维也从未见过托瓦兹。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-9676330f0dec6a2dc99200788e85e70504f.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Tom's Hardware 的报道&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomshardware.com%2Fsoftware%2Foperating-systems%2Flong-time-rivals-bill-gates-and-linus-torvalds-meet-for-the-first-time-have-dinner-no-major-kernel-decisions-were-made-but-maybe-next-dinner" target="_blank"&gt;指出&lt;/a&gt;，这次会面是一次历史性突破，二人坐在一起畅谈，而几十年前这样的场景可能会引发激烈争吵，但现在时间让一切变得包容。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356781/bill-gates-linus-torvalds-meeting-photo</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356781/bill-gates-linus-torvalds-meeting-photo</guid>
      <pubDate>Sun, 11 May 2025 02:24:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>tlmqtt:如何基于责任链模式的高效认证</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt;是一款基于&lt;code&gt;Java&lt;/code&gt;开发的轻量级高并发&lt;code&gt;MQTT Broker&lt;/code&gt;，采用&lt;code&gt;Netty&lt;/code&gt;和&lt;code&gt;Project Reactor&lt;/code&gt;实现异步通信，完整支持&lt;strong&gt;MQTT 3.1.1&lt;/strong&gt;协议，包括&lt;strong&gt;QoS&lt;/strong&gt;消息分级、主题通配符、消息持久化等核心功能。项目采用模块化设计，&lt;strong&gt;提供认证（文件/数据库/HTTP）&lt;/strong&gt;、&lt;strong&gt;数据桥接（Kafka/MySQL&lt;/strong&gt;）和&lt;strong&gt;存储（内存/Redis）&lt;strong&gt;等可扩展组件，支持&lt;/strong&gt;MQTT&lt;/strong&gt;和&lt;strong&gt;WebSocket&lt;/strong&gt;双协议接入。具备生产级特性如&lt;strong&gt;SSL&lt;/strong&gt;加密、会话恢复及高并发处理能力，适用于物联网和实时通信场景。&lt;/p&gt; 
&lt;h1&gt;认证&lt;/h1&gt; 
&lt;p&gt;&lt;code&gt;mqtt&lt;/code&gt;协议规定了&lt;strong&gt;CONNECT&lt;/strong&gt;包含有&lt;code&gt;Username&lt;/code&gt;和&lt;code&gt;Password&lt;/code&gt;字段。实现可以选择如何使用这些字段的内容。他们也可能提供自己的认证机制，使用额外的认证系统。 而&lt;strong&gt;tlmqtt&lt;/strong&gt;实现了&lt;strong&gt;基本文件&lt;/strong&gt;，&lt;strong&gt;mysql&lt;/strong&gt;和&lt;strong&gt;http 接口&lt;/strong&gt;的 3 种认证方式，并且提供了扩展让用户自行去实现认证方式并添加到认证链中，其中只要有任何一个认证通过了，那么此次客户端连接就是通过的&lt;/p&gt; 
&lt;h1&gt;tlmqtt 认证原理&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt;存在一个抽象类&lt;code&gt;AbstractTlAuthentication&lt;/code&gt;它定义了认证相关的抽象方法，有具体的认证器去实现&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;nbsp; /**
&amp;nbsp; &amp;nbsp; &amp;nbsp;* 认证接口
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @author hszhou
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @datetime: 2025-05-10 10:51:55
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param username 用户名
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param password 密码
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @return boolean 是否成功
&amp;nbsp; &amp;nbsp; &amp;nbsp;**/
&amp;nbsp; &amp;nbsp; abstract public boolean authenticate(String username, String password);

&amp;nbsp; &amp;nbsp; /**
&amp;nbsp; &amp;nbsp; &amp;nbsp;* 是否启用了该认证器
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @author hszhou
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @datetime: 2025-05-12 10:11:26
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @return boolean 是否启用
&amp;nbsp; &amp;nbsp; &amp;nbsp;**/
&amp;nbsp; &amp;nbsp; abstract public boolean enabled();


&amp;nbsp; &amp;nbsp; /**
&amp;nbsp; &amp;nbsp; &amp;nbsp;* 添加新的认证主体
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @author hszhou
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @datetime: 2025-05-15 17:53:17
&amp;nbsp; &amp;nbsp; &amp;nbsp;* @param object 添加的认证实体
&amp;nbsp; &amp;nbsp; &amp;nbsp;**/
&amp;nbsp; &amp;nbsp; abstract public void add(Object object);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;NoneAuthenticationService&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt; 是可以通过一个配置来进行关闭客户端的认证的。 &amp;nbsp;&lt;code&gt;yml &amp;nbsp;auth: &amp;nbsp; enabled: true #是否开启认证 false 就是关闭认证&lt;/code&gt; &amp;nbsp;其实现原理就是通过&lt;code&gt;NoneAuthenticationService&lt;/code&gt;这个认证器。也是认证链中的第一个认证器。 &amp;nbsp;&lt;code&gt;@Override &amp;nbsp; &amp;nbsp; public boolean authenticate(String username, String password) { &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true; &amp;nbsp; &amp;nbsp; }&lt;/code&gt; 其主要实现了&lt;code&gt;authenticate&lt;/code&gt;方法返回的是&lt;code&gt;true&lt;/code&gt;。&lt;code&gt;NoneAuthenticationService&lt;/code&gt;并不关心客户端的用户名和密码，也就是无论用户名和密码是什么，他都不会在意，只会返回&lt;code&gt;true&lt;/code&gt;。表示认证通过，而&lt;code&gt;enabled&lt;/code&gt;方法返回的就是是否开启，一旦开启了，那么这个&lt;code&gt;authenticate&lt;/code&gt;就会执行。由于处于认证链的首位。只要通过了就不会执行其他的认证了。&lt;/p&gt; 
&lt;h2&gt;FixTlAuthentication&lt;/h2&gt; 
&lt;p&gt;&lt;code&gt;FixTlAuthentication&lt;/code&gt;是基于固定用户的认证方式。其固定的用户的配置方式有 2 种， 第一种是基于文件的,这种方式是提前将用户写入到配置文件中&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yml"&gt;auth:
&amp;nbsp; enabled: true #是否开启认证 false 就是关闭认证
&amp;nbsp; user: #开启认证后 fix 的认证信息
&amp;nbsp; &amp;nbsp; - username: watson
&amp;nbsp; &amp;nbsp; &amp;nbsp; password: 12345
&amp;nbsp; &amp;nbsp; - username: zhouhs
&amp;nbsp; &amp;nbsp; &amp;nbsp; password: 12345
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;第二种方式是基于编程的&lt;strong&gt;tlmqtt&lt;/strong&gt;启动引导类支持动态添加用户&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;tlBootstrap.setFixUser(Collections.singletonList(new TlUser("admin","12345")))
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;FixTlAuthentication&lt;/code&gt;的内部维护了一个用户列表，&lt;code&gt;authenticate&lt;/code&gt;方法就是将客户端的用户名与密码将内部的用户列表继续依次匹配。只要有任何一个匹配成功就返回。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; &amp;nbsp; public boolean authenticate(String username, String password) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if(users.isEmpty()){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (TlUser user : users) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (user.getUsername().equals(username) &amp;amp;&amp;amp; user.getPassword().equals(password)) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.debug("username = 【{}】,password = 【{}】 pass",username,password);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;
&amp;nbsp; &amp;nbsp; }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;而编程式的添加用户就是往内部的用户列表中添加用户&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; public void add(Object object) {

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if( object instanceof TlUser){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.debug("join fix authentication user 【{}】",object);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.users.add((TlUser) object);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }

&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;HttpTlAuthentication&lt;/h2&gt; 
&lt;p&gt;&lt;code&gt;HttpTlAuthentication&lt;/code&gt;认证器是基于&lt;code&gt;http&lt;/code&gt;请求的认证器。也是&lt;strong&gt;tlmqtt&lt;/strong&gt;的内置认证器之一。通过将用户名与密码当做参数请求第三方的 API 进行认证。只要&lt;code&gt;API&lt;/code&gt;返回的状态码为&lt;strong&gt;200&lt;/strong&gt;，注意的是这里的状态码&lt;strong&gt;200&lt;/strong&gt;是&lt;code&gt;HTTP&lt;/code&gt;的状态码，而不是第三方系统自己定义的&lt;strong&gt;200&lt;/strong&gt;. &lt;strong&gt;tmqtt&lt;/strong&gt;将&lt;code&gt;http&lt;/code&gt;请求封装成一个对象&lt;code&gt;HttpEntityInfo&lt;/code&gt;。里面有&lt;code&gt;API&lt;/code&gt;的地址，参数等等信息&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;public class HttpEntityInfo {

&amp;nbsp; &amp;nbsp; /**请求的地址*/
&amp;nbsp; &amp;nbsp; private String url;
&amp;nbsp; &amp;nbsp; /**方法类型 post 或者 get*/
&amp;nbsp; &amp;nbsp; private String method;
&amp;nbsp; &amp;nbsp; /**请求头*/
&amp;nbsp; &amp;nbsp; private HashMap&amp;lt;String, String&amp;gt; headers;
&amp;nbsp; &amp;nbsp; /**用户的参数，例如，参数是 uname 与 pwd 那么这个 params 的参数就是 ("username","uname") ("password","pwd")*/
&amp;nbsp; &amp;nbsp; private HashMap&amp;lt;String,String&amp;gt; params;

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;HttpTlAuthentication&lt;/code&gt;将认证接口大致分为 3 类，&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;POST&lt;/code&gt;请求的&lt;code&gt;form&lt;/code&gt;表单提交&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;POST&lt;/code&gt;请求的&lt;code&gt;json&lt;/code&gt;数据提交&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;GET&lt;/code&gt;请求&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;最终只要请求返回的是&lt;strong&gt;200&lt;/strong&gt;就认证认证成功&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;HttpTlAuthentication&lt;/code&gt;认证过滤器不单单可以设置一个&lt;code&gt;API&lt;/code&gt;。可以通过多个&lt;code&gt;API&lt;/code&gt;接口组成的集合进行认证。其内部维护了一个&lt;code&gt;HttpEntityInfo&lt;/code&gt;的集合。只要任何一个 API 通过，及认证通过&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; &amp;nbsp;private final List&amp;lt;HttpEntityInfo&amp;gt; httpEntityInfos;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;HttpTlAuthentication&lt;/code&gt;提供了动态添加&lt;code&gt;http&lt;/code&gt;接口的方式&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; public void add(Object object) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (object instanceof HttpEntityInfo) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this.httpEntityInfos.add((HttpEntityInfo) object);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;使用方式&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; HttpEntityInfo entityInfo = AuthenticationHttpProvider.formLogin();
&amp;nbsp; HttpEntityInfo login = AuthenticationHttpProvider.getLogin();
&amp;nbsp; tlBootstrap.addAuthEntity(entityInfo)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .addAuthEntity(login)
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;SqlTlAuthentication&lt;/h2&gt; 
&lt;p&gt;&lt;code&gt;SqlTlAuthentication&lt;/code&gt;认证器是基于 mysql 数据库的认证，&lt;strong&gt;tlmqtt&lt;/strong&gt;将&lt;code&gt;SqlTlAuthentication&lt;/code&gt;的数据封装成了一个 SQL 对象&lt;code&gt;SqlEntityInfo&lt;/code&gt;。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp; /**地址*/
&amp;nbsp; &amp;nbsp; private String host;

&amp;nbsp; &amp;nbsp; /**端口号*/
&amp;nbsp; &amp;nbsp; private String port;

&amp;nbsp; &amp;nbsp; /**用户名*/
&amp;nbsp; &amp;nbsp; private String username;

&amp;nbsp; &amp;nbsp; /**密码*/
&amp;nbsp; &amp;nbsp; private String password;

&amp;nbsp; &amp;nbsp; /**数据库名*/
&amp;nbsp; &amp;nbsp; private String &amp;nbsp;database;

&amp;nbsp; &amp;nbsp; /**表名*/
&amp;nbsp; &amp;nbsp; private String table;

&amp;nbsp; &amp;nbsp; /**用户名字段*/
&amp;nbsp; &amp;nbsp; private String usernameColumn;

&amp;nbsp; &amp;nbsp; /**密码字段*/
&amp;nbsp; &amp;nbsp; private String passwordColumn;

&amp;nbsp; &amp;nbsp; private String driverClassName;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;如果需要使用到&lt;code&gt;SqlTlAuthentication&lt;/code&gt;认证过滤器，就需要添加相应的&lt;code&gt;SqlEntityInfo&lt;/code&gt;。&lt;code&gt;SqlEntityInfo&lt;/code&gt;设置数据库的地址，表名和用户名和密码的字段。然后其内部维护了一个&lt;code&gt;SqlEntityInfo&lt;/code&gt;集合，与&lt;code&gt;http&lt;/code&gt;认证器一致，只要有任何一个认证通过即可，当用户设置成功后，&lt;strong&gt;tlmqtt&lt;/strong&gt;会执行内部的&lt;code&gt;sql&lt;/code&gt;语句并替换相应的参数&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-sql"&gt;&amp;nbsp;private static final String SQL = "SELECT COUNT(*) FROM %s WHERE %s = ? AND %s = ?";
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;SqlTlAuthentication&lt;/code&gt;提供动态方法新增 SqlEntityInfo 的方式。使用方法&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;SqlEntityInfo sqlEntityInfo = AuthenticationMysqlProvider.providerDemo();
tlBootstrap .addAuthEntity(sqlEntityInfo) &amp;nbsp; &amp;nbsp;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;可扩展的认证链&lt;/h2&gt; 
&lt;p&gt;当上述认证器不满足系统的认证方式，&lt;strong&gt;tlmqtt&lt;/strong&gt;提供了可扩展的认证器。是需要用户继承&lt;code&gt;AbstractTlAuthentication&lt;/code&gt;类即可。然后实现&lt;code&gt;authenticate&lt;/code&gt;方法。然后通过辅助引导类&lt;code&gt;TlBootstrap&lt;/code&gt;的&lt;code&gt;addAuthentication&lt;/code&gt;方法即可。&lt;/p&gt; 
&lt;h3&gt;实现 AbstractTlAuthentication 类&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;@Slf4j
public class NoneA extends AbstractTlAuthentication {
&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; public boolean authenticate(String username, String password) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; public boolean enabled() {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return true;
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; public void add(Object object) {

&amp;nbsp; &amp;nbsp; }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;添加认证器&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&amp;nbsp;tlBootstrap.addAuthentication(new NoneA())
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这样就可以将自定义的认证器添加到&lt;code&gt;tlmqtt&lt;/code&gt;的整个认证体系中。&lt;/p&gt; 
&lt;h1&gt;结语&lt;/h1&gt; 
&lt;p&gt;欢迎通过以下方式参与项目共建：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;提交 Issue&lt;/strong&gt;：反馈 Bug 或提出功能建议&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;提交 PR&lt;/strong&gt;：优化代码或新增功能（建议先创建 Issue 沟通方案）&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Star/Fork&lt;/strong&gt;：支持项目持续发展&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h1&gt;联系方式：&lt;/h1&gt; 
&lt;p&gt;项目地址 &amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FZHSQJM%2Ftlmqtt%23" target="_blank"&gt;https://github.com/ZHSQJM/tlmqtt&lt;/a&gt; &amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/PiQiHenHaoDeGangTieXia/tlmqtt"&gt;https://gitee.com/PiQiHenHaoDeGangTieXia/tlmqtt&lt;/a&gt; &amp;nbsp;&amp;nbsp; &amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt;致力于为物联网开发者提供轻量、高效的 MQTT 消息服务，期待您的加入！ 🚀&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356775</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356775</guid>
      <pubDate>Sun, 11 May 2025 02:08:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>新一代小游戏图形渲染技术 WebGE 首发！助力小游戏开发更高效</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;6 月 21 日，华为开发者大会 2025（HDC 2025）游戏服务分论坛在广东东莞松山湖成功举办。众多游戏开发者、行业领军人物及生态合作伙伴齐聚一堂，聚焦「新机遇、新体验、新服务，鸿蒙创新技术赋能游戏产业」主题，展开深度交流与研讨。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;中国音像与数字出版协会常务副理事长兼秘书长敖然出席分论坛活动并表示，鸿蒙在数字化发展的浪潮中经受住了时间的挑战，逐步走向成熟。同时，他还鼓励更多的游戏开发者加入到鸿蒙生态中来，「希望有更多富有创意和品质的鸿蒙游戏创作涌现出来，为玩家带来更加丰富的游戏体验，共同推动游戏行业的创新发展和繁荣进步。」&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="1.jpg" height="467" src="https://oscimg.oschina.net/oscnet//92214fd40953f6979dc76b7ad250cc21.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;华为终端云服务互动媒体 BU 总裁张思建表示，华为游戏中心将为开发者提供一站式的赋能服务，同时，面向全场景、小游戏、大联运和出海等全新的鸿蒙游戏激励计划也在持续升级，鼓励开发者结合鸿蒙系统特性进行创新，构建全媒体流量矩阵，实现全场景智慧化分发，触达亿级的游戏玩家。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="2.jpg" height="467" src="https://oscimg.oschina.net/oscnet//cd08ed7fcd687699c20e38ea386be4f1.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;新机遇：全场景机遇迸发，激活游戏用户全域价值&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;过去一年，鸿蒙游戏生态发展迅速，截至目前，已有超 4900 款鸿蒙游戏上架。这一数字不仅是量的积累，更是整个游戏产业协同共进、创新突破的生动见证。立足当下，鸿蒙为游戏产业带来的全新机遇正全面迸发。鸿蒙系统实现「一次开发、多端部署」的技术突破，让游戏开发者得以跨越手机、电脑、智能穿戴设备等全场景终端，将优质内容精准触达全域用户，带来全新的用户增长机遇。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="3.jpg" height="467" src="https://oscimg.oschina.net/oscnet//3415cf7293a5f164308d34ac246458e2.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;国产黑马刷宝爽游《英勇之地》商务负责人在本次分论坛分享了鸿蒙全场景游戏实践经验，《英勇之地》手游于 5 月首发上线鸿蒙平台，同时完成了 PC 版对鸿蒙电脑的全方位技术适配。借势鸿蒙生态丰富的分发场景与成熟的首发运营方案，《英勇之地》在首发阶段斩获亮眼成绩，首周流水 300 万+，其中鸿蒙平台占比 30%，预约转化率高达 40%。由此可见，鸿蒙全场景生态的流量红利，正在为游戏用户增长带来全新机会点。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="4.jpg" height="467" src="https://oscimg.oschina.net/oscnet//9264fede42687ab0b6c4fbdecff975c6.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;作为游戏产业重要增量的小游戏赛道，在华为小游戏焕新升级下也迎来了全新机遇。华为小游戏持续优化接入流程、强化开发套件、完善联运体系，助力开发者高效融入鸿蒙游戏生态。同时进阶小游戏产品能力，完成小游戏从即点即玩到即时转化的增长路径，助力开发者抢滩小游戏百亿市场。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;针对内容驱动型的独立游戏，华为游戏中心专业的内容阵地和全生命周期服务支持，为其创造了更广阔的发展空间和更有利的成长环境。华为游戏中心还上线独立游戏专区，构建多维游戏分发阵地，直达目标用户群体，不断推动独立游戏掌握全场景时代新的流量机遇，塑造独立游戏的流量新场域。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;如今，随着鸿蒙生态的快速壮大和用户基数的增长，越来越多的游戏厂商加速布局鸿蒙，众多新游选择首发上线鸿蒙版本，抢占用户增长新机遇。对此，华为游戏中心也推出全新的鸿蒙游戏激励政策体系，包括游戏鸿飞计划、全场景创新激励等，从技术支持到流量倾斜，全方位助力优质内容绽放光彩，助力游戏开发者加速商业成功。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;新体验：游戏体验革新，内容+玩法焕新用户感知&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;在用户感受层面，鸿蒙游戏生态致力于突破交互边界，创造极致体验。华为游戏中心精心打磨优质内容社区，承载专业游戏内容，满足玩家高效获取优质内容的需求，并为游戏开发者提供广阔展示游戏内容的生态平台和内容矩阵。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="5.jpg" height="467" src="https://oscimg.oschina.net/oscnet//19820a8e31920af7eedaf7f1409a1bea.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;「看」游戏，更专业的游戏内容，整合玩家真实测评、开发者创作心路等深度内容，让游戏故事更生动可感；「找」游戏，更智能的搜索推荐，优化搜索功能，通过标签查找、专题查找和搜索专区，让优质游戏更容易被发现；「玩」游戏，更贴心的游戏助手，完善游戏工具、我的资产和 AI 问答等功能，激发玩家主动探索的热情。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;同时，更具创新性与趣味性的鸿蒙创新特性，已被纳入多款游戏的开发规划蓝图：《英勇之地》《NBA 巅峰对决》在分论坛分享了近场快传创新实践经验，无需网络下载，借助鸿蒙分布式软总线技术，实现游戏资源包在手机之间的高速传输。玩家之间只需轻触设备，即可分享游戏资源包，相比网络下载速提升 3 倍；而经典国风手游《浮生忆玲珑》即将基于鸿蒙创新特性，推出桌面萌宝版，将创新互动卡片添加至桌面，内置多种轻互动玩法，在桌面养娃，将游戏轻量化体验融入玩家日常，让游戏与生活无缝衔接；弹幕射击类游戏《雷电：觉醒》则深度契合小游戏玩家碎片化时间娱乐需求，上线华为小游戏 App，无需下载也能体验 90 帧超流畅画质，点击秒开畅玩，以轻量化社交玩法激活玩家活跃度。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="6.jpg" height="466" src="https://oscimg.oschina.net/oscnet//4bfca420c2fe4781247df218f108e66d.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;新服务：全栈式服务调优，推动游戏创意高质量落地&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;在开发者服务领域，华为游戏中心始终以全生命周期护航者的角色，与开发者并肩前行。一站式的鸿蒙游戏开发者服务（HGS）为开发者带来了赋能套件、运营服务、技术能力、商务政策等全方位的服务，覆盖开发—分发—运营全流程，助力行业伙伴抢占鸿蒙生态发展先机。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;本次分论坛上，《QQ 飞车》手游引擎负责人分享了《QQ 飞车》与 HGS 游戏性能调优技术合作与探索的经验。通过 HiSmartPerf 调优工具，能快速定位游戏渲染问题，针对游戏运行性能数据，如 CPU、GPU、功耗等进行深度分析，打造更高性能、更稳定的游戏产品。华为游戏中心还提供多种降功耗服务，包括插帧，二进制优化，游戏场景感知，以及专家诊断服务等，通过这些优化手段，《QQ 飞车》游戏综合功耗在不同场景下最高可下降 20%。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="7.jpg" height="467" src="https://oscimg.oschina.net/oscnet//aa00e09f55170c8c36855a0e7bedca6f.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;针对开发者关注的小游戏开发领域，华为游戏中心首发新一代小游戏图形渲染技术 WebGE，WebGE 在小游戏领域实现 WebGPU 标准，为小游戏提供更优体验。基于 WebGE 的渲染性能优化，开放冒险小游戏《曙光重临》3D 实时光影渲染帧率提升 30%，场景切换更流畅；3D 弹幕射击小游戏《雷电：觉醒》以更低功耗突破 90 帧功耗降低 15%，性能更稳定，画质更流畅。WebGE 图形渲染技术的发布，助力小游戏实现更炫酷的渲染效果，从而激发小游戏设计的无限想象空间。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="8.jpg" height="466" src="https://oscimg.oschina.net/oscnet//9ac20692852f5cade6968ddffb3b34a5.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;此外，华为游戏中心还积极搭建开发者成长平台，通过行业大咖分享、实战培训、创新大赛等系列活动，为开发者提供学习交流、竞技展示的舞台。HDC 期间，鸿蒙生态最大规模开发者官方赛事 2025 HarmonyOS 创新赛正式公布赛制，最高可获百万激励。大赛设置游戏创新专项奖，从参赛作品的创新玩法、技术深度、视觉表现等多维度设置评分标准，鼓励游戏开发者基于 HarmonyOS 新技术开拓创新，孵化游戏创意。&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img alt="9.jpg" height="467" src="https://oscimg.oschina.net/oscnet//2dd837d46d35c4fdb551bcbc5a4827f2.jpg" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#555555; margin-left:0; margin-right:0; text-align:start"&gt;鸿蒙游戏生态的每一次突破，都凝结着开发者的智慧与汗水。无论是《NBA 巅峰对决》通过近场快传技术实现的秒级资源共享，还是《雷电：觉醒》在 WebGE 图形渲染技术的加持下无需下载也能保持 90 帧超流畅画质，都在印证：鸿蒙生态绝非孤军奋战的孤岛，而是多方共赢的命运共同体。未来，华为游戏中心将与开发者继续携手，深耕技术创新，优化用户体验，完善服务生态，培育更多兼具品质与创意的精品游戏，共同书写游戏产业高质量发展的崭新篇章。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356582</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356582</guid>
      <pubDate>Fri, 09 May 2025 06:44:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
  </channel>
</rss>
