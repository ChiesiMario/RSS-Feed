<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 Jun 2025 07:42:53 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>中国 AI Coding 市场在 2025 年迎来应用爆发期</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;国际数据公司（IDC）于近日发布了《中国市场代码生成产品评估，1H25》，报告对 AI Coding 产品进行了市场分析和调研，并测试了中国市场的主流产品，从核心代码实现、注释质量、工程化引导三个维度进行模型打分，并对产品整体能力进行评估，来为市场用户提供选型参考。&lt;/p&gt; 
&lt;p&gt;根据报告数据，AI Coding 市场在 2025 年迎来应用爆发期，更多技术供应商基于代码工程化优势发布和更新产品，&lt;strong&gt;AI 编码助手在产品界限上逐渐模糊，集成编程助手、工具、模型、对话交互界面等多种能力&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;此外，各个模型之间的差距在缩小，已经可以帮助开发者完成简单任务的端到端实现，并对复杂任务搭建框架，在 RAG / 知识库、联网搜索、跨文件检索上持续更新，各家厂商的竞争也逐渐收敛到用户入口和独立 IDE 产品上。&lt;/p&gt; 
&lt;p&gt;中国市场仍有极大发展空间，AI 编程助手对开发者的覆盖率在 30%。而美国已有 91% 的开发者使用 AI 工具，且超过 50% 的受访者表示采用 OpenAI ChatGPT 来创建生产级应用程序。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0604/152404_eUUg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0604/152711_rUXz_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0604/152733_keWG_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;另一项调研显示，使用 AI 编码助手的开发人员平均生产力提高了 35%，其中超过 20% 的受访者表示对其生产效率的提升超过 50%。&lt;/p&gt; 
&lt;p&gt;开发者使用 AI 编程助手可以执行各种与开发相关的任务，不仅是代码生成和补全，还包括单元测试生成、代码版本自动升级以及自定义企业编码规范。约 50% 的开发者认为增强团队协作、提高工作满意度、加快问题解决速度是编程助手的主要优势，当前 AI 的核心能力在于提高开发者的生产效率，并非创新。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353521</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353521</guid>
      <pubDate>Wed, 04 Jun 2025 07:29:50 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>「互联网女皇」发布 340 页 AI 趋势报告</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;被称为「互联网女皇」的 Mary Meeker 在沉寂数年后，于 2025 年 5 月 30 日再次发布了其标志性的深度趋势报告 &lt;em&gt;《Trends – Artificial Intelligence》。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;这位曾经的摩根士丹利明星分析师，如今的风险投资公司 Bond Capital 创始合伙人，通过这份长达 340 页的重磅报告详细介绍了 AI 的发展现况、未来趋势等内容。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ffbb618303f41e093ce8bb8a50c8fd50dc7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/151307_ToP4_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;如果用一个词来形容这份报告，会是「史无前例」，即 AI 史无前例的发展速度和普及度：AI 的用户增长、技术迭代和全球扩散速度远超以往任何技术浪潮，如互联网。&lt;/p&gt; 
&lt;p&gt;报告称：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ChatGPT 在 17 个月内用户数就突破了 8 亿，这是史无前例的；&lt;/li&gt; 
 &lt;li&gt;AI 公司数量以及如此多的公司实现高年经常性收入的速度是史无前例的；&lt;/li&gt; 
 &lt;li&gt;AI 模型的推理成本下降速度是史无前例的——虽然训练一个大模型的成本最高要 10 亿美元，但推理成本两年内下降了 99%；&lt;/li&gt; 
 &lt;li&gt;AI 公司以极低成本匹配竞争对手模型功能的速度也是史无前例的。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/151356_jTsS_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/151448_ufHT_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/151723_EMvF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;报告指出，AI 唯一没有超越其它科技革命的领域是财务回报，暂时还不知道哪些公司能成长为长期盈利的下一代科技巨头。&lt;/p&gt; 
&lt;p&gt;Mary 在报告中提到，目前主流的 AI 企业其估值与收入的差距过大。具体来看，Perplexity 在估值/收入倍数中，达到了约 75 倍的差距，而 OpenAI 则以 92 亿美元的年收入、预计 3000 亿美元的估值获得了 33 倍的差距。&lt;/p&gt; 
&lt;p&gt;而在近一年时间中，中国的模型通过低成本的方式，打破了各大 AI 企业的高昂价格「泡沫」。Mary 对此表示：「投资人，请只投你愿意损失的金额」。&lt;/p&gt; 
&lt;p&gt;更多报告内容查看：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bondcap.com%2Freports%2Ftai" target="_blank"&gt;https://www.bondcap.com/reports/tai&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353516/trends%E2%80%93artificial-intelligence</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353516/trends%E2%80%93artificial-intelligence</guid>
      <pubDate>Wed, 04 Jun 2025 07:15:50 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Anthropic 「封杀」 Windsurf</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;AI 编程工具 Windsurf 开发商&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwindsurf.com%2Fblog%2Fanthropic-models" target="_blank"&gt;发布公告称&lt;/a&gt;&lt;/u&gt;，Anthropic 在几乎没有预先通知的情况下切断了 Windsurf 的 API 访问权限。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/143502_jh84_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根据 Windsurf 的声明，Anthropic 在提前不到一周的通知时间内，切断了其几乎所有 Claude 3.x 模型的直接访问权限 (first-party capacity)，具体涉及的模型包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Claude 3.5 Sonnet&lt;/li&gt; 
 &lt;li&gt;Claude 3.7 Sonnet&lt;/li&gt; 
 &lt;li&gt;Claude 3.7 Sonnet Thinking&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;由于 Windsurf 从未获得 Claude 4 的直接访问权限，等于直接被 Anthropic 彻底封杀了。&lt;/p&gt; 
&lt;p&gt;Windsurf CEO Varun Mohan&amp;nbsp;表示，Windsurf 一直希望支付服务费用以获得完整访问权限，对 Anthropic 这一决定和通知时间之短感到失望。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/144530_0dYo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Windsurf 目前虽有部分第三方算力资源，但远不能满足需求，短期内可能影响用户访问 Claude 模型的稳定性。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353506</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353506</guid>
      <pubDate>Sun, 11 May 2025 06:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>QuantumGuard OS 发布：全球首个融合后量子加密的物联网边缘操作系统</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;QuantumGuard OS 发布：全球首个融合后量子加密的物联网边缘操作系统，通过 FIPS 140-3 认证&amp;nbsp;&lt;em&gt;在物联网安全威胁日益严峻的背景下，QuantumGuard OS 的发布标志着边缘计算安全进入新纪元。这款全球首个融合后量子加密技术的物联网操作系统，不仅通过严苛的 FIPS 140-3 认证，更重新定义了设备级数据保护标准。本文将深度解析其架构特性、加密原理及行业应用价值。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;QuantumGuard OS 发布：全球首个融合后量子加密的物联网边缘操作系统，通过 FIPS 140-3 认证&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;后量子加密技术的革命性突破&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;QuantumGuard OS 的核心突破在于其集成的格基加密（Lattice-based Cryptography）算法，这种被 NIST 选为后量子加密标准的技术，能够有效抵抗量子计算机的暴力破解。传统 RSA 加密在量子计算面前仅需数分钟即可被攻破，而格基加密的数学复杂性使其破解时间预估超过 1000 年。在边缘计算场景中，系统采用混合加密模式，既兼容现有 AES-256 标准，又无缝衔接抗量子算法，这种双重保障机制为智能电表、工业传感器等设备提供了前所未有的安全基线。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;FIPS 140-3 认证的深层意义&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;获得美国联邦信息处理标准（FIPS）最高级别认证，意味着 QuantumGuard OS 的加密模块经受了包括物理防篡改、侧信道攻击防御等 11 类严苛测试。特别值得注意的是其"零信任密钥派生"机制，每个设备在启动时都会动态生成专属加密种子，即使同一批次的设备也不会存在密钥重复问题。对于医疗物联网中的胰岛素泵、工业控制系统的 PLC 等关键设备，这种认证级别的安全保障能有效阻断供应链攻击。认证过程中，系统在-40℃至 85℃的极端温度范围内仍保持加密稳定性，这为户外物联网设备部署扫清了障碍。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;边缘计算架构的独特设计&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;区别于传统物联网操作系统，QuantumGuard OS 采用微内核架构将安全域（Security Domain）与功能域严格隔离。其内存保护单元（MPU）可实现亚毫秒级的上下文切换，使得加密运算对设备性能的影响降至 5% 以下。在智慧城市的路况监测场景中，系统表现出惊人的能效比——处理 1080P 视频流时的功耗仅为同类系统的 1/3。独特的"安全飞地"设计允许敏感数据在加密状态下直接进行边缘计算，这种隐私增强技术（PET）完美解决了人脸识别等场景的数据合规难题。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;抗量子攻击的实际防御能力&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过模拟量子攻击环境的压力测试，QuantumGuard OS 展现出令人信服的防御能力。其采用的 CRYSTALS-Kyber 密钥封装机制，在模拟 1000 量子比特（Qubit）攻击时仍保持加密有效性。对于智能电网中的电表数据采集，系统实现了端到端的量子安全隧道，每个数据包都经过独立加密且具备前向安全性。更值得关注的是其"加密敏捷性"设计，当监测到异常解密请求时，系统可在 50ms 内自动切换至备用的 SIKE 加密算法，这种动态防御机制远超传统物联网系统的响应速度。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;跨行业应用场景解析&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在工业 4.0 领域，QuantumGuard OS 已成功部署于西门子新一代 PLC 控制器，其安全启动（Secure Boot）功能可检测 0.1% 的固件篡改。车联网方面，系统支持 V2X 通信的毫秒级密钥轮换，满足自动驾驶对实时安全的需求。农业物联网中，结合国密 SM9 算法特别优化了传感器节点的能耗表现，使得土壤监测设备的电池寿命延长至 5 年。医疗行业应用更具突破性，系统通过"分片加密"技术实现了 ECG 数据在边缘端的匿名化处理，既满足 HIPAA 合规要求，又保留了数据分析价值。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;QuantumGuard OS 的诞生不仅解决了物联网设备面临的量子计算威胁，其通过 FIPS 140-3 认证更树立了行业安全新标杆。从加密算法革新到边缘架构优化，这套系统为智能城市、工业互联网等关键领域提供了面向未来的安全基座。随着量子计算时代的临近，这种融合经典加密与后量子防御的混合方案，或将成为物联网操作系统的标准配置。&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353495</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353495</guid>
      <pubDate>Sun, 11 May 2025 06:10:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>得物自研 DScript 2.0 脚本能力从 0 到 1 演进</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;h1&gt;一、前言&lt;/h1&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在高并发推荐引擎场景中，C++的极致性能往往以开发效率为妥协，尤其在业务频繁迭代时，C++的开发效率流程成为显著瓶颈。传统嵌入式脚本（如 Lua）虽支持动态加载，但其与 C++的交互成本（如虚拟栈数据中转、类型转换）仍会带来额外性能损耗。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;为此，我们探索设计 DScript2.0——一种与 C++内存布局及调用约定深度兼容的动态脚本语言，通过自研编译器实现即时编译与无缝嵌入，尝试在保留脚本灵活性的同时，尽可能贴近 C++的原生性能，为性能与效率的平衡提供了轻量化解决方案。&lt;/span&gt;&lt;/p&gt; 
&lt;h1&gt;二、动态脚本在引擎中的引用&lt;/h1&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;C++引擎的迭代效率瓶颈&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在搜推引擎中的实践中，出于对高并发场景下极致性能的追求，使用 C++进行引擎自研成为了一种业界常态。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;众所周知，C++通过开放底层控制权限（如内存分配，指令优化等），提升了可达的性能上限，但这种提升伴随了大量底层细节的处理，消耗了更多的开发时间，追求性能优先的同时，却又限制了开发效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我们希望能够在保持性能的同时，提升引擎的开发效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;利用嵌入式脚本提升迭代效率&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我们的目标是寻求一种平衡性能与迭代效率的方案，一种主流方案是在 C++中嵌入脚本语言。例如，在游戏引擎和 Nginx 开发中集成 Lua，在 C/C++代码中实现性能需求，结合脚本代码中实现控制逻辑，从而提升开发效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式脚本对迭代效率的提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持动态加载，无需编译部署。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;无需 C/C++经验，脚本学习成本低，提升参与迭代的人力总量。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;引擎的迭代拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;引擎内部的技术性迭代&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;业务侧的需求支持&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;业务侧的需求非常适合引入嵌入式脚本，实现对易变需求的自迭代，提升开发效率，这也是一种业界主流方案。例如，一些搜索中台中，对于相关性和粗排逻辑封装为插件，业务侧的算法工程师使用 Lua 开发计算逻辑，可以极大地提升迭代效率。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;嵌入式脚本的额外性能开销&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在引擎中嵌入脚本，虽然可以提升迭代效率，但并非全无代价，高阶语言与低阶语言的交互存在着额外的性能开销。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，Lua 和 C++的交互机制基于 Lua 提供的虚拟栈来实现，这个栈是两者进行数据交换的核心通道。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用虚拟栈实现语言交互存在额外的开销，包括但不限于压栈和弹栈操作、栈空间管理、类型检查和转换、复杂数据结构的处理等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//3e6d8349d3c8b462cc5a9df4bd5e9d57.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;更加极致的方案&amp;nbsp;&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;基于以上的瓶颈，我们期望一种更加极致的方案，实现性能与效率的平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式脚本的额外性能开销&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;（主要源于两种语言在 ABI 层面的不一致）&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;函数调用约定不一致，需要一个虚拟栈进行中转。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据类型内存布局不一致，需要额外的检查和转换。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;一个直观的解决方案就是我们设计一种编程语言，在底层实现上与 C++具有一致内存布局与调用约定，从而消除额外的转换开销。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;同时，这种编程语言可以在 C++嵌入，也支持即时编译，提升效率的同时，也拥有与原生 C++近似的执行性能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;以上是我们规划 DScript2.0 项目初衷。&lt;/span&gt;&lt;/p&gt; 
&lt;h1&gt;三、DScript2.0 的编译器实现&lt;/h1&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;语法设计&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 被设计为一种轻量级面向过程的编程语言，同时它也是静态类型的编译语言。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在语法支持上，包含了基础数据类型、变量、运算符、控制流和函数，额外支持了与 C++的语言互操作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;数据类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;int，long，bool，float，double，void&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;自定义变量，隐式类型转换。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;C++变量：支持访问和操作外部注册的 C++变量，支持 C++的结构体部分操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;运算符&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;算术运算符：+，-，*，/，%&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;关系运算符：==，!=，&amp;gt;=，&amp;gt;，&amp;lt;=，&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;逻辑运算符：!，&amp;amp;&amp;amp;，||&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;赋值运算符：=，+=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;自增自减运算符：++i，--i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;控制流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;分支语句：if (...) else if (...) else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;循环语句: for 循环&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;自定义函数：基础类型值传递，对象类型引用传递。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;C++API：支持调用外部注册的 C++函数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;浅析编译器架构&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//0002b3da20c2712954db692af8d1c91b.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（编译器的三段结构）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;一个完整的编译器通常由三个主要部分组成：前端、优化器和后端。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;前端：&lt;/strong&gt;负责词法分析、语法分析、语义分析、生成中间代码。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;优化器（中端）：&lt;/strong&gt;负责对中间代码进行优化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;后端：&lt;/strong&gt;负责将中间代码转换成目标机器的的机器码。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;基于 LLVM 实现 DScript2.0 编译器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//afd841f8ba9fca992d5f2b6f32ec9dcc.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM 是一个模块化且高度可重用的编译器基础设施项目。它提供了前端、优化器和后端工具链，已支持多种编程语言和平台。LLVM 具有跨平台性，允许开发者灵活定制编译流程，提供高级优化能力，支持即时编译，被广泛用于编译器开发、虚拟机和代码分析工具场景。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;采用 LLVM 实现 DScript2.0 的优势&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;提升开发效率：&lt;/strong&gt;LLVM 的前端、中端和后端采用了模块化设计，每个部分都可以独立替换或扩展，这种灵活性使得 LLVM 非常适合定制编译器，&lt;strong&gt;我们可以复用 LLVM 的中端与后端，专注于前端开发，减少开发成本。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持高级优化：&lt;/strong&gt;LLVM 提供了一套强大的优化工具，能够对代码进行静态和动态优化。这些优化不仅能够提高代码的执行效率，还可以减少代码体积。&lt;strong&gt;这是 DScript2.0 理论上可能提供接近原生 C++性能的关键因素之一。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持即时编译：&lt;/strong&gt;LLVM 支持即时编译（JIT），通过 JIT 编译，LLVM 能够在运行时生成和执行代码，大大提升了执行效率。通过运行时进行编译后运行，&lt;strong&gt;这是 DScript2.0 理论上可能提供接近原生 C++性能的关键因素之二&lt;/strong&gt;。支持在线的即时编译能力，&lt;strong&gt;同时也是算子开发与分发效率的保障。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;DScript2.0 编译器架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//972c134f7ea81077c7a1ed3e97e7c6c6.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;DScript2.0 编译器同样包含前端、中端、后端三部分，前端能力自研，优化器和后端基于 LLVM 的 Pass 和 JIT 实现。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;编译器最终输出为 x86_64 平台的可执行二进制，以 JIT 实例的方式常驻内存，通过入口函数地址执行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;编译器支持注入 C++类型与函数参与编译，实现 DScript2.0 对 C++的调用。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;编译器前端实现&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;前端的实现流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;编译器前端的任务是&lt;strong&gt;将源码转换为优化器可处理的中间代码&lt;/strong&gt;，这个转换的流程通常包含 4 个步骤：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;词法分析&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;语法分析&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;语义分析&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;中间代码生成&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//34e7a033f0a4360ff25f44ea62bd08ad.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（编译器前端架构）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;词法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;源代码是一堆连续的字符，计算机要先识别出这些字符组成的基本单元，才能进一步理解代码含义。就像读句子先得认出单词一样，这是理解程序的第一步。词法分析的本质是&lt;strong&gt;将代码的字符流，转换为更易处理的 token 流。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：字符流-&amp;gt;记号流（Tokens）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;词法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中了使用 Flex，可以根据自定义的正则表达式规则，自动生成词法分析的扫描器，减少手工编写词法分析器的工作量。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 工作流程&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//4f5ea2329f5f69d9eee567e4741fa745.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 语法&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 Flex 的定义文件中包含三部分：&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;定义段：&lt;/strong&gt;包含头文件和全局变量，如输入和输出流的定义。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;规则段：&lt;/strong&gt;由模式和对应的动作组成。当扫描器匹配到模式时，执行对应的动作。例如，匹配到"int"字符串时，将其识别为 INT 标识。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;用户代码段：&lt;/strong&gt;通常可以在此区域定义&lt;strong&gt;&amp;nbsp;main()&amp;nbsp;&lt;/strong&gt;函数，它调用&lt;strong&gt;&amp;nbsp;yylex()&amp;nbsp;&lt;/strong&gt;，启动词法分析过程。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/* 定义段段开始 */
/* 引入的 c/c++代码 */
%{
#include &amp;lt;string&amp;gt;
%}


/* 正则表达式的宏定义 */
LineTerminator &amp;nbsp; &amp;nbsp; &amp;nbsp; \n|\r|\r\n
WhiteSpace &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [ \t\f]|{LineTerminator}
Identifier &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [a-zA-Z_][a-zA-Z0-9_]*
/* 定义段结束 */


%%




/* 规则段开始 */
/* 规则：正则表达式 { return 传递给语法分析器的记号类型 } */
"int"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;INT; }
"float"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;FLOAT; }
"void"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;VOID; }


{Identifier} {
&amp;nbsp; &amp;nbsp; yylval.identifier = new std::string(yytext);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;IDENTIFIER;
}
{LineTerminator} {}
{WhiteSpace} {}


&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;END;
}
/* 规则段结束 */




%%




/* 用户代码段开始 */
/* 用户代码段结束 */&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;匹配规则&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;最长匹配：当多个规则可匹配时，Flex 选择&lt;strong&gt;最长匹配&lt;/strong&gt;的词素。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;最先定义：若多个规则长度相同，则选择&lt;strong&gt;最先定义&lt;/strong&gt;的规则。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;语法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;语法分析的原理是根据上下文无关文法（CFG）对输入的 tokens 序列进行分析，验证其是否符合某种语言的语法规则，并构建对应的抽象语法树。其核心在于建立程序的分层逻辑结构，并确保这种结构符合语法约束。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：记号流-&amp;gt;抽象语法树（AST）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;由语法分析原理拆分&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;结构验证：&lt;/strong&gt;检查记号流的排列是否符合语法规则，DScript2.0 的语法规则由上下文无关文法（CFG）描述，验证算法采用了自底向上的 LR 算法。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;// 示例：分支语法规则：if (conditon) { stmts }
// 符合语法规则
if&amp;nbsp;(a &amp;lt;&amp;nbsp;1) {


// 不符合语法规则
if&amp;nbsp;a &amp;lt;&amp;nbsp;1&amp;nbsp;{&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;层次构建：&lt;/strong&gt;将线性的记号流转换为树状或嵌套的语法结构，以抽象语法树为例：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;FunctionDefinition
&amp;nbsp; ├── ReturnType:&amp;nbsp;int
&amp;nbsp; ├── FunctionName: func
&amp;nbsp; ├── Parameters
&amp;nbsp; │ &amp;nbsp; └── Parameter
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Name: a
&amp;nbsp; └── Body
&amp;nbsp; &amp;nbsp; &amp;nbsp; ├── VariableDeclaration
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├── Name: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; └── InitialValue
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── +
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ├── Variable: a
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Constant:&amp;nbsp;1
&amp;nbsp; &amp;nbsp; &amp;nbsp; └── ReturnStatement
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Variable: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;上下文无关文法（CFG)&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;上下文无关文法（CFG） 是编译器语法分析的核心工具，用于形式化描述编程语言的语法结构。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;其核心要素包括：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;终结符&lt;/strong&gt;（如标识符、运算符），对应词法分析的 Token，不可再分解。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;非终结符&lt;/strong&gt;（如表达式、语句），需通过产生式规则展开为终结符或其他非终结符。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;产生式规则（如 E → E + T）&lt;/strong&gt;&amp;nbsp;，定义语法结构的生成方式。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;起始符号&lt;/strong&gt;（如&lt;strong&gt;&amp;nbsp;Program&amp;nbsp;&lt;/strong&gt;），代表语法分析的入口。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;产生式规则定义示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/* 局部变量声明 -&amp;gt; 类型，变量声明 */
/* 例如&amp;nbsp;int&amp;nbsp;a =&amp;nbsp;1&amp;nbsp;*/
/* Type 对应 int&amp;nbsp;*/
/* Variable_Declartor 对应 a =&amp;nbsp;1&amp;nbsp;*/
Local_Variable_Declartor -&amp;gt;
&amp;nbsp; &amp;nbsp; Type Variable_Declartor;


/* 变量声明 -&amp;gt; 变量 ID 或，变量 ID = 变量初始化 */
Variable_Declartor -&amp;gt;&amp;nbsp;
&amp;nbsp; &amp;nbsp; Variable_ID
&amp;nbsp; &amp;nbsp; | Variable_ID EQ Variable_Initializer;


/* 变量 ID -&amp;gt; 标识符 */ &amp;nbsp; &amp;nbsp;
Variable_ID -&amp;gt; IDENTIFIER;


/* 变量初始化 -&amp;gt; 任意表达式 */
Variable_initializer -&amp;gt; expression;&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;示例中根据形式化的语法，描述了变量定义和变量初始化规则。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;示例中包含 4 条产生式规则：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;局部变量声明规则&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;变量声明表达式规则&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;变量 ID 规则&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;变量初始化规则&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;终止符：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Type 对应一个 C++的 TypeNode&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IDENTIFIER 对应词法定义的 Token&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;语法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;语法分析器采用 Bison 来实现，Bison 可以与 Flex 进行协作，将词法分析器生成的记号序列解析为语法树，供编译器进一步处理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;通过与 Flex 协同工作，Bison 可以自动化地处理复杂的语法分析任务，使编译器的开发更加高效和灵活。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;语义分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;通过遍历抽象语法树，实现上下文相关的文法检查，对程序的类型、作用域和标识符等进行详细检查，&lt;strong&gt;确保程序在逻辑上符合编程语言的规则，同时生成中间表示代码&lt;/strong&gt;，作为优化器或后端的输入。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：&lt;/strong&gt;抽象语法树-&amp;gt;中间代码。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;语法分析与语义分析的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;输出目标不同：语法分析的主要任务是将记号流转换为结构化信息，语义分析是将结构化信息翻译为优化器可以处理的中间表示语言。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;语法正确的语句，语义未必正确：&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;例如，有函数原型&lt;strong&gt;&amp;nbsp;void echo(int a)&amp;nbsp;&lt;/strong&gt;，在调用时&lt;strong&gt;&amp;nbsp;int b = echo("a")&amp;nbsp;&lt;/strong&gt;，这是符合语法的，但不符合语义。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;再比如，语言要求使用变量前先定义，在未定义变量&lt;strong&gt;&amp;nbsp;a&amp;nbsp;&lt;/strong&gt;的前提下，执行赋值&lt;strong&gt;&amp;nbsp;a = 1;&amp;nbsp;&lt;/strong&gt;，这样也是符合语法但不符合语义的。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;语义分析的主要任务&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;符号表管理&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;作用域解析&lt;/strong&gt;：追踪变量/函数的作用域（如块级作用域、全局作用域）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;符号绑定：&lt;/strong&gt;将标识符与其声明关联（如变量类型、函数签名）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;重复定义检查：&lt;/strong&gt;禁止同一作用域内同名符号的重复声明。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;类型系统校验&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;类型推断与检查：&lt;/strong&gt;验证表达式和操作的合法性，如&lt;strong&gt;&amp;nbsp;int a = "str";&amp;nbsp;&lt;/strong&gt;类型不匹配。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;隐式类型转换：&lt;/strong&gt;处理类型提升，如&lt;strong&gt;&amp;nbsp;int + float&amp;nbsp;&lt;/strong&gt;自动转为浮点运算。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;函数签名匹配：&lt;/strong&gt;检查实参与形参的个数、类型一致性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;控制流合法性&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;语句上下文检查：&lt;/strong&gt;确保&lt;strong&gt;&amp;nbsp;break&amp;nbsp;&lt;/strong&gt;仅在循环内、&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;与函数返回类型一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;可达性分析：&lt;/strong&gt;检测不可达代码（如&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;后的语句）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;常量表达式求值&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;优化常量计算（如&lt;strong&gt;&amp;nbsp;const x = 2 + 3*4; &amp;nbsp;&lt;/strong&gt;直接计算为&lt;strong&gt;&amp;nbsp;14&amp;nbsp;&lt;/strong&gt;）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;用于数组长度、条件编译等需编译期确定值的场景。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;中间代码生成&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;中间代码的生成流程是通过递归遍历 AST 完成的，将语义检查无误的逻辑，转换为中间表示语言，这是编译器前端工作的最后一步。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中使用了&lt;strong&gt;LLVM IR&lt;/strong&gt;作为中间代码语言，它介于高级语言和目标代码之间，既能表达高级语言的抽象概念，又能适应底层机器代码的生成需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 提供了丰富的指令集，涵盖了从基本运算到复杂控制流、内存操作、同步操作等各种编程需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 指令集示例&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//fffc0e15f1be962695432d3b2b69989a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;转换示例：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（源代码）&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;; 函数定义: 函数名为 func，返回类型为 i32（32 位整数），参数为 i32 类型的 a
define i32 @func(i32 %a) {
entry:
&amp;nbsp; ; 定义局部变量 b，并将其初始化为 a +&amp;nbsp;1&amp;nbsp;的结果
&amp;nbsp; %b = add i32 %a,&amp;nbsp;1


&amp;nbsp; ; 返回 b 的值
&amp;nbsp; ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（与之对应的 LLVM 的中间代码）&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;编译器中端：中间代码优化&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//4427d784ffc7bf64021b597373528883.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;在 DScript2.0 中，优化器是通过&lt;strong&gt;复用 LLVM 的中端优化能力&lt;/strong&gt;来实现的，通过一系列 LLVM 预置的优化遍 (Pass)，对程序生成的中间代码进行优化，以&lt;strong&gt;提高代码的性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;中端的输出为优化过后的 IR 指令，这些 IR 指令需要提供给后端进行编译。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 LLVM 中，优化遍是指按照一定顺序执行的一个或多个优化算法。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;以下是一些常用的优化算法：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//aa73fe5a522d09fac64f469c9f1c016a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;编译器后端：即时编译&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//7ffd47a0be70b88382e468d14fe98757.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 使用 LLVM 的 ORC JIT 作为即时编译器的实现，支持在程序运行时编译脚本，并通过查找函数地址的方式执行脚本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;采用即时编译器的优势：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;避免了开发调试过程中，频繁的启停程序，&lt;strong&gt;提升迭代效率。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;且经过编译的代码，在执行时能够显著&lt;strong&gt;提升运行性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;语言互操作性&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;语言互操作性是指不同编程语言能够相互调用、协同工作的能力。通过这种能力，开发者可以在同一项目中结合多种语言的优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，&lt;strong&gt;C++ 与 Lua 的结合&lt;/strong&gt;是就互操作的经典场景，常见于游戏开发、搜推引擎、嵌入式系统等领域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在我们的需求中，要支持动态脚本访问引擎的表列资源，就需要 DScript2.0 也能具备与 C++交互操作的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 与 C++的语言互操作性体现在&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;DScript2.0 可以调用 C++的函数，并向 C++传递数据。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;C++可以调用 DScript2.0 的函数，并向 DScript 脚本传递数据。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;DScript2.0 可以访问和操作 C++传递的基础类型和结构体类型变量。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;调试能力&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 基于 GDB 实现了基本的调试能力：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持通过 Attach 进程进行实时调试&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持在 coredump 中保留栈信息&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;调试能力的实现主要基于 GDB 的通用调试接口，在编译 DScript2.0 源码时，生成调试信息，插入到 LLVM IR 的元数据中，然后通过 JIT 的监听器挂载 GDB 调试接口，并注入调试信息，最终实现调试能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//712d0be95e399fdf471e33364f57da3d.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;异常处理&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中也实现了异常处理能力，主要包括了硬件异常的主动防御和跨 C++与 DScript2.0 边界的异常传播。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;硬件异常防御&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;程序异常可以划分为硬件异常和主动异常：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;硬件异常&lt;/strong&gt;是底层不可控错误，硬件异常的处理需依赖信号钩子或语言运行时封装。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;典型例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;段错误（SIGSEGV）：&lt;/strong&gt;非法内存访问&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;浮点运算错误（SIGFPE）：&lt;/strong&gt;如整数除零或浮点运算异常&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;非法指令（SIGILL）：&lt;/strong&gt;执行未定义的机器指令&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;总线错误 （SIGBUS）：&lt;/strong&gt;如未对齐的内存访问&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;主动异常&lt;/strong&gt;是代码逻辑的一部分，用于可控的错误处理与资源管理，主动异常由开发者显式抛出，也可由语言运行时隐式转换。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;硬件异常的主动防御&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 在语言层面上，对代码引发的硬件异常进行了主动防御。实现上，是在语义分析阶段，对中间代码添加防御逻辑，防御策略则采用了可被捕获的主动异常抛出。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如下图所示，在编译阶段，编译器对于结构体指针进行了空引用检查逻辑，将硬件异常转换为了主动异常，而主动异常可以通过捕获来进行处理，避免了进程崩溃。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//6c7e8cac4f4f5824c798faa662322910.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;跨语言边界传播&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;因为 DScript2.0 的语言互操作性特性，会涉及到 C++与 DScript2.0 的函数互相调用（如下图所示），就会涉及到异常处理时，异常在 C++和 DScript2.0 之间传播，即所谓跨语言边界。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 主要实现了如下的异常传播机制：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;脚本调用 C++ 函数时若抛出异常，在脚本端不进行捕获，但支持异常传播到 C++端，同时正常完成栈回退。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;C++ 调用脚本函数时若抛出异常，可以在 C++ 端捕获。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//4ca2105f8da79d27155676715456951f.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h1&gt;四、DScript2.0 在线开发工作流&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//304b49d4719757821cbf6154aa5b5807.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 通过平台化实现了在线开发的工作流：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;引擎集成：以 SDK 方式与引擎进行集成，提供在线编译和加载的能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在线 IDE：实现编辑、编译的在线开发环境。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在线工作流：通过平台化支持脚本的在线分发与管理。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;五、总结&lt;/h1&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 的实践为推荐引擎的敏捷迭代探索了一条新路径。通过编译器架构与 C++底层机制的高度兼容设计，它在降低跨语言交互成本、支持动态加载等方面展现出潜力，同时保持了接近原生 C++的运行时性能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其即时编译能力与在线开发流程，使业务团队能独立完成逻辑更新，减少对传统 C++开发中编译部署的依赖，初步验证了兼顾性能与效率的可能性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未来，我们计划进一步完善调试工具链与异常处理机制，并探索其在混合语言场景下的扩展性，以更轻量的方式推动引擎架构的持续优化。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;算法团队大量 HC，欢迎加入我们：&lt;/strong&gt;得物技术大量算法岗位多地上线，「职」等你来！&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;往期回顾&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;社区造数服务接入 MCP｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;CSS 闯关指南：从手写地狱到「类」积木之旅｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;从零实现模块级代码影响面分析方案｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以细节诠释专业，用成长定义价值——对话@孟同学 ｜得物技术&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;得物可观测平台架构升级：基于 GreptimeDB 的全新监控体系实践&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 明远&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353485</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353485</guid>
      <pubDate>Sun, 11 May 2025 05:46:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>NebulaFlow 重构边缘计算：分布式 AI 推理框架正式开源，低延迟赋能工业物联网</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;em&gt;在工业物联网 (IIoT) 与边缘计算深度融合的今天，NebulaFlow 开源框架的发布标志着分布式 AI 推理技术迈入新阶段。本文深度解析该框架如何通过创新的数据流编排机制，在工业质检、设备预测性维护等场景中实现毫秒级响应，同时揭示其三层异构计算架构如何平衡算力成本与推理精度。&lt;/em&gt;&lt;/p&gt; 
&lt;h1&gt;NebulaFlow 重构边缘计算：分布式 AI 推理框架正式开源，低延迟赋能工业物联网&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;边缘计算范式下的 AI 推理困境与破局&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;传统云计算架构在工业物联网场景中面临的根本矛盾，在于数据传输延迟与集中式算力分配间的不可调和性。NebulaFlow 创新性地采用边缘节点协同推理策略，将 AI 模型拆解为可动态部署的微服务单元。通过实时监控网络带宽波动和设备算力状态，系统能自主决策将 ResNet-34 等视觉模型的卷积层部署在网关设备，而全连接层下沉至边缘服务器。这种混合精度推理机制使得汽车焊接质量检测的端到端延迟从传统方案的 800ms 降至惊人的 93ms，同时保持 99.2% 的缺陷识别准确率。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;三层异构架构的算力编排奥秘&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;NebulaFlow 框架最核心的竞争力在于其"终端-边缘-近云"三级计算架构设计。在半导体晶圆检测的实际部署中，框架的资源调度器会智能识别：轻量级 YOLOv5 模型的前处理阶段适合部署在带 NPU(神经网络处理单元) 的工业相机，特征提取层分配至工厂级边缘服务器集群，而复杂的分类决策则交由厂区级 GPU 节点完成。这种动态负载均衡策略使得单台注塑机的状态监测年运维成本降低 47%，而分布式推理过程中的梯度同步开销控制在总耗时的 15% 以内。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;数据流编排引擎的技术突破&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;框架内置的 Fluid DAG 引擎彻底改变了传统 AI 流水线的刚性结构。当处理风力发电机组的振动信号时，系统能根据传感器数据的信噪比动态调整 STFT(短时傅里叶变换) 的窗口参数，并智能跳过噪声干扰严重时段的数据预处理。这种具有容错能力的流式计算模式，使得 200ms 时间窗内的特征提取完成率从固定管道的 82% 提升至 98.7%。特别值得注意的是，引擎支持 TensorRT 和 ONNX Runtime 的混合部署，这让同一套 LSTM 模型能在不同代际的工业设备上保持一致的预测性能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;开源生态带来的产业变革机遇&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;NebulaFlow 选择 Apache 2.0 协议开源的战略决策，正在催生工业 AI 领域的"安卓时刻"。其模块化设计允许西门子等设备厂商快速集成私有协议栈，同时保持核心调度算法的持续升级。在首批试点项目中，某钢铁集团通过复用框架的模型分片功能，仅用 3 周就完成了轧钢温度预测系统的跨厂区部署。更值得关注的是社区贡献的 ROS2-Nebula 适配器，这使 AGV 调度系统的路径规划延迟突破性地降至 50ms 量级。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;工业级可靠性的实现路径&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;为满足制药行业 GMP(药品生产质量管理规范) 的严苛要求，框架创新性地引入了双通道容错机制。当检测到某边缘节点心跳丢失时，不仅会立即触发邻近节点的模型热迁移，还会自动启用压缩感知技术对缺失数据进行重建。在疫苗灌装产线的 72 小时连续测试中，系统在模拟 20% 节点故障的情况下仍保持 99.99% 的批次合格判定准确率。这种鲁棒性很大程度上源于其独特的联邦式检查点机制，该技术将模型状态同步的带宽消耗降低了 60%。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;NebulaFlow 的开源标志着边缘 AI 推理进入"生产就绪"阶段，其价值不仅体现在技术参数上的突破，更在于重构了工业智能化的实施范式。从半导体到能源装备，该框架证明分布式推理完全可以兼顾实时性与准确性，而其开放的架构更将加速工业元宇宙的生态构建。随着 5G-Advanced 网络的普及，这套框架有望成为连接物理世界与数字孪生的神经网络。&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353481</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353481</guid>
      <pubDate>Sun, 11 May 2025 04:49:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>腾讯开源跨平台框架 ovCompose，助力全端应用开发</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p style="color:#4d4f53; margin-left:0; margin-right:0; text-align:start"&gt;近日，腾讯开源平台正式推出了由腾讯视频团队主导开发的跨平台框架 ovCompose。该框架基于 Compose Multiplatform 生态构建，旨在解决 JetBrains Compose Multiplatform 当前不支持鸿蒙系统的问题，并改善 iOS 平台上布局受限的情况，从而帮助开发者更高效地打造全平台应用。&lt;/p&gt; 
&lt;p style="color:#4d4f53; margin-left:0; margin-right:0; text-align:start"&gt;在腾讯大前端 Oteam 的推动下，腾讯视频团队还推出了 KuiklyBase，涵盖 Kotlin/Native 对鸿蒙系统的适配、组件生态建设、编译流程优化、堆栈还原以及工具链完善等多个方面。这一系列技术方案有效提升了 Kotlin Multiplatform（KMP）开发者在鸿蒙平台上的开发效率。目前，ovCompose 与 KuiklyBase 已在 GitHub 上开源发布。&lt;/p&gt; 
&lt;p style="color:#4d4f53; margin-left:0; margin-right:0; text-align:start"&gt;现阶段，ovCompose 已在腾讯视频的鸿蒙平台全面应用，成为首个实现全跨端覆盖的 App。而 KuiklyBase 的核心能力也已在包括腾讯视频、QQ 浏览器、腾讯体育在内的十余款 App 中落地使用。&lt;/p&gt; 
&lt;p style="color:#4d4f53; margin-left:0; margin-right:0; text-align:start"&gt;通过采用一套代码覆盖 Android、iOS 与鸿蒙三大平台的开发模式，业务开发效率明显提升。随着鸿蒙系统的持续演进，ovCompose 与 KuiklyBase 的应用范围也将逐步拓展至电视端与 PC 端。&lt;/p&gt; 
&lt;p style="color:#4d4f53; margin-left:0; margin-right:0; text-align:start"&gt;值得关注的是，近年来 Kotlin Multiplatform（KMM）生态不断成熟，Kotlin-Native 在多个场景下的执行性能已超越 Kotlin-JVM。然而，Compose Multiplatform 在跨平台方面的技术尚未完全成熟。未来，ovCompose 与 KuiklyBase 将继续围绕以下方向进行优化：提升垃圾回收机制在实际业务中的表现、推进 Kotlin-Native 的组件化能力、优化 Kotlin-Native 的开发体验，以及进一步统一 UIKit 与 Skia 的渲染模式，力求为开发者提供更流畅、更高效的跨端开发体验。&lt;/p&gt; 
&lt;p&gt;https://github.com/Tencent-TDS/ovCompose-sample/blob/main/README-zh_CN.md&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353476</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353476</guid>
      <pubDate>Sun, 11 May 2025 04:04:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>Yandex 发布全球最大开源音乐推荐数据集 Yambda</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;Yandex &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsspai.com%2Flink%3Ftarget%3Dhttps%253A%252F%252Fwww.prnewswire.com%252Fnews-releases%252Fyandex-releases-worlds-largest-event-dataset-for-advancing-recommender-systems-302468616.html" target="_blank"&gt;发布&lt;/a&gt;开源音乐推荐数据集 Yambda，包含近 50 亿次匿名用户与流媒体平台 Yandex Music 音轨的互动数据。&lt;/p&gt; 
&lt;p&gt;Yandex 表示，该数据集来自旗下流媒体音乐服务的 My Wave 推荐系统，所有用户和跟踪数据都使用数字标识符匿名化处理：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;包含了跨度 10 个月、47.9 亿次匿名用户交互，拥有来自 100 万用户的数据和 939 万个曲目的匿名描述符&lt;/li&gt; 
 &lt;li&gt;包括隐式交互（侦听）和显式交互（喜欢、不喜欢和删除）两种反馈类型，并提供 50 亿、5 亿和 5000 万三种数据集大小，&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="1154" src="https://static.oschina.net/uploads/space/2025/0604/112437_dqLB_2720166.png" width="2026" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;相比现有的 Spotify Million Playlists、Netflix Prize dataset 等数据集，Yambda 在数据规模和时效性方面都更为出色。&lt;/p&gt; 
&lt;p&gt;Yambda 可作为通用基准用于电子商务、社交网络和短视频平台的推荐系统测试，现已在 Hugging Face 上提供：&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fdatasets%2Fyandex%2Fyambda" target="_blank"&gt;https://huggingface.co/datasets/yandex/yambda&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353465/yandex-releases-worlds-largest-event-dataset</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353465/yandex-releases-worlds-largest-event-dataset</guid>
      <pubDate>Sun, 11 May 2025 03:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 造物社区作品分享——超 mini 的 1.54 寸墨水屏多功能阅读器</title>
      <description/>
      <link>https://www.oschina.net/ai-creation/details/2005</link>
      <guid isPermaLink="false">https://www.oschina.net/ai-creation/details/2005</guid>
      <pubDate>Sun, 11 May 2025 03:09:00 GMT</pubDate>
    </item>
    <item>
      <title>阶跃星辰 C 端产品「冒泡鸭」停运，业务重心转向终端 Agent</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Ft6j6Wk5ekwdtbxvKP6HwmA" target="_blank"&gt;根据《智能涌现》的独家报道&lt;/a&gt;，大模型「六小虎」之一的阶跃星辰近半年在其 C 端应用布局上进行了一系列调整：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;2024 年 12 月，角色扮演类 Agent 产品「冒泡鸭」停止大范围投入，团队合并至对话产品「跃问」（现更名为「阶跃 AI」），目前仅留部分员工运维。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/110406_jreC_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;针对上述信息，阶跃星辰回复称，早期团队基于当时的模型能力进行了一些产品探索；&lt;strong&gt;2025 年，随着多模态和推理能力的成熟，团队对产品进行收敛，聚焦 Agent 方向&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;公司方面还表示，「跃问」改名为「阶跃 AI」，意味着它从 Chat 类的产品到 Agent 能力的转变。&lt;/p&gt; 
&lt;p&gt;而据阶跃星辰员工透露，经过一年以来的探索，团队现在在产品布局上学到的深刻一课是：不要在已有头部玩家的领域，参与竞争。&lt;/p&gt; 
&lt;p&gt;报道指出，2025 年以来，阶跃星辰的战略，也是将资源从短板，集中到长板业务上：重心从 C 端，转移到模型研发和 ToB/G 上。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353456</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353456</guid>
      <pubDate>Sun, 11 May 2025 03:04:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智源研究院开源 Video-XL-2：轻量级超长视频理解模型</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;近日，智源研究院联合上海交通大学等机构，正式发布新一代超长视频理解模型：&lt;strong&gt;Video-XL-2&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;相较于上一版本的 Video-XL，该模型在多个维度全面优化了多模态大模型对长视频内容的理解能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;效果更佳&lt;/strong&gt;：Video-XL-2 在长视频理解任务中表现出色，在 MLVU、Video-MME、LVBench 等主流评测基准上达到了同参数规模开源模型的领先水平。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;长度更长&lt;/strong&gt;：新模型显著扩展了可处理视频的时长，支持在单张显卡上高效处理长达万帧的视频输入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;速度更快&lt;/strong&gt;：Video-XL-2 大幅提升了处理效率，编码 2048 帧视频仅需 12 秒，显著加速长视频理解流程。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Video-XL-2 的模型架构示意图：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0604/104152_Zepa_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在模型架构设计上，Video-XL-2 主要由三个核心组件构成：视觉编码器（Visual Encoder）、动态 Token 合成模块（Dynamic Token Synthesis, DTS）以及大语言模型（LLM）。&lt;/p&gt; 
&lt;p&gt;目前，Video-XL-2 的模型权重已全面向社区开放。未来，该模型有望在影视内容分析、异常行为监测等多个实际场景中展现重要应用价值。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;项目主页：&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Funabletousegit.github.io%2Fvideo-xl2.github.io%2F" target="_blank"&gt;https://unabletousegit.github.io/video-xl2.github.io/&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;模型 hf 链接：&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FBAAI%2FVideo-XL-2" target="_blank"&gt;https://huggingface.co/BAAI/Video-XL-2&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;仓库链接：&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FVectorSpaceLab%2FVideo-XL" target="_blank"&gt;https://github.com/VectorSpaceLab/Video-XL&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353446</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353446</guid>
      <pubDate>Sun, 11 May 2025 02:44:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>「鸿蒙创想·创新场景共建挑战赛」开启，等你来战！</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;科技领域，生态竞争愈发激烈。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;HarmonyOS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;凭借全场景战略，推动原生应用全面普及，构建更安全、更智能、更开放的操作系统生态，已成为国产操作系统生态的核心力量之一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2025 年，开源中国携手 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;诚邀各路开发者一起&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;共建&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;HarmonyOS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发者场景技术能力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;并推出&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;鸿蒙创想·创新场景共建挑战赛&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;希望通过本次大赛，进一步加速 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;应用开发进程，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;推动 H&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;armonyOS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发者场景技术能力生态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，激发各路开发 OG 的无限创造力和创新力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;让我们以代码为笔，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;共筑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;HarmonyOS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发者场景技术能力的盛景繁花&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="162" src="https://static.oschina.net/uploads/space/2025/0604/103456_a3qU_4806939.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;鸿蒙创想 · 创新场景共建挑战赛&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;活动时间： 2025.5.30-2025.6.30&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;报名链接：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqaxb95n3g50.feishu.cn%2Fshare%2Fbase%2Fform%2FshrcnaQjWtDMJvkU62QaXkuZyld" target="_blank"&gt;&lt;u&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;https://qaxb95n3g50.feishu.cn/share/base/form/shrcnaQjWtDMJvkU62QaXkuZyld&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:center"&gt;&lt;img height="484" src="https://static.oschina.net/uploads/space/2025/0604/103551_WbZW_4806939.png" width="389" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;核心命题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;于&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;HarmonyOS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最新版本能力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;共&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;建&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三方开源代码库，可提交开源代码、SDK 接口、API 接口、插件、边缘工具集成、智能工具以及场景解决方案等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提交方向参考&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;多设备适配&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基于 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以及 ArkUI/RN/Flutter 技术栈，提供各种不同场景下的多设备响应式/自适应组件；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;跨平台框架&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：针对 RN/Flutter 等跨平台框架，提供鸿蒙特色能力的实现，例如：华为账号一键登录、碰一碰分享等；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;AI 辅助&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基于 AI 辅助，提升 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;应用开发效率、问题定位效率等各类场景的能力或方案；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;性能功耗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：①开发或移植高性能的数据库 ORM/Helper 、序列化/反序列化、后台任务管理等开源库 ②开发各类复杂场景的高性能 UI 组件；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;媒体方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：开发或移植功能完善的图片处理、音视频处理等开源库；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;网络方向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：开发或移植高质量、功能完善的 http、websocket 等各类网络协议库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#646a73"&gt;*提交内容广泛多样，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;如果与 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;&amp;nbsp;相关的开源库代码、组件、接口均可参与。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;&lt;span style="color:#000000"&gt;学习资料：&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fforum%2Fblock%2Fapplication%3Fha_linker%3DeyJ0cyI6MTcyMDU3ODU3MTQ0MywiaWQiOiJiZGMyZWVmNWU4MDFhYjI2OTA1YzM4ZWI0Y2QxYWFhMiJ9" target="_blank"&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#0000ff"&gt;&lt;u&gt;&lt;span&gt;https://developer.huawei.com/consumer/cn/forum/block/application?ha_linker=eyJ0cyI6MTcyMDU3ODU3MTQ0MywiaWQiOiJiZGMyZWVmNWU4MDFhYjI2OTA1YzM4ZWI0Y2QxYWFhMiJ9&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参赛要求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提交的作品必须紧扣核心命题，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;且&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;与 Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;相关&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可使用【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.qq.com%2Fsheet%2FDS0FqQXBDRU10VWVJ%3Ftab%3D35fdxw" target="_blank"&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#245bdb"&gt;&lt;u&gt;&lt;span&gt;HarmonyOS 工具包&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;】参与开发&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;并不适配最新&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;HarmonyOS &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作品将无法通过审核；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作品提交并通过审核后，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;名称和描述将不可更改&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，请在提交作品前谨慎操作；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;3、提交的作品为可以直接复用的开源组件，便于评审；&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提交的作品（包含标题、描述、内容）要求正向积极，且必须遵守相关法律法规，确保内容安全合法合规&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;活动流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、填写并提交【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqaxb95n3g50.feishu.cn%2Fshare%2Fbase%2Fform%2FshrcnaQjWtDMJvkU62QaXkuZyld" target="_blank"&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#0070c0"&gt;&lt;u&gt;&lt;span&gt;活动报名表&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;】，即为报名成功&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、提交活动作品：完成开发、适配后，进入【&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://gitee.com/gao-zhanr/harmony-os-third-party-library"&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#0070c0"&gt;&lt;u&gt;&lt;span&gt;提交入口&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;】，提交自己的作品，作品需要包含源代码、demo 演示和简要介绍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、提交截止后，三方库内的开源作品经由官方评选，最后结果公示&amp;amp;奖励发放&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;活动奖项&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img height="310" src="https://static.oschina.net/uploads/space/2025/0604/103836_17T3_4806939.png" width="552" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img height="171" src="https://static.oschina.net/uploads/space/2025/0604/103854_5c4s_4806939.png" width="503" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;评选维度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;命题准确（20%）————紧扣核心命题，适配&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最新&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;Harmony&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span&gt;系统&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;业务价值（35%）————贴合需求、市场价值及推广性，有明显的效率提升&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发能力（35%）————综合技术能力，良好的作品运行效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;文档规范（10%）————流程文档规范、工程质量优良、资料齐全&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;评选委员会将根据技术性、创新性、应用价值、用户体验、页面设计、使用体验、输出效果、体验流畅丝滑等维度综合评选出获奖作品。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;通过参加本次活动，参与者表明其理解并同意遵守以下条款和条件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;数据安全与第三方权益：参与者应独立保证和承担活动期间所涉及数据的合规及安全责任，并保证其活动不侵害任何第三方的合法权利和利益。参与者活动期间所获得任何数据不得用于本次活动之外的其他任何目的，不得向任何第三人提供或披露本次活动数据及任何信息。参与者不得从事任何违反适用的法律、法规、规章或活动协议的活动。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;提交作品的审查与评估：活动组织者保留对提交的模型和代码进行全面审查和评估的权利，以确保符合活动规则和标准，但不因此免除参与者任何责任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;活动规则和决策权：关于活动的所有相关事宜，包括但不限于活动规则、评估标准、奖励设定以及最终结果的决定，均由主办方全权决定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;最终解释权：主办方拥有对所有活动相关内容的最终解释权。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;规则修改与调整：主办方保留根据实际情况对未尽事宜进行解释和处理的权利，并保留随时修改活动规则、调整活动流程或取消活动的权利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;官方信息发布：请所有参与者密切关注活动官方网站或其他公告渠道，以便及时获取最新的活动信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;版权声明：参与者保证提交作品的创作不得侵犯任何第三方的合法权利，其作品版权归其作者及主办方共同所有。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353442</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353442</guid>
      <pubDate>Sun, 11 May 2025 02:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>ChatGPT 轻量级记忆功能已向所有免费用户开放</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;OpenAI CEO Sam Altman &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fsama%2Fstatus%2F1930007155723415560" target="_blank"&gt;宣布&lt;/a&gt;，从现在开始，将为 ChatGPT 的免费用户提供轻量级记忆功能，同时他自己也表示该功能是其最喜欢的 ChatGPT 功能，未来也将大幅改进这一功能。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0604/103431_rXKj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，ChatGPT 的记忆功能能记住用户最近的聊天内容，从而用户不必再经常重复表述自己的内容，GPT 也能回答更加个性化、更加符合用户偏好的内容，以及记住用户的部分信息、数据等内容。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-d7727d9f7a35e0da218a4455d9ff43c9038.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;即日起，打开 ChatGPT 即可收到「全新改进型记忆功能上线」的相关推送消息。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353439</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353439</guid>
      <pubDate>Sun, 11 May 2025 02:35:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 计划今年夏天发布 GPT-5</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fartificial-intelligence%2Fopenai-is-hopeful-gpt-5-will-compete-a-little-more%2F" target="_blank"&gt;据 BleepingC&lt;/a&gt;&lt;/u&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fartificial-intelligence%2Fopenai-is-hopeful-gpt-5-will-compete-a-little-more%2F" target="_blank"&gt;omputer 报道&lt;/a&gt;&lt;/u&gt;，OpenAI 的两位高管近日在出席在墨西哥举行的人工智能峰会上证实，GPT-5 确实正在研发中，并且它将比现有的 OpenAI 模型强大得多。OpenAI 目前仍在开发 GPT-5，尚未确定其成本。&lt;/p&gt; 
&lt;p&gt;一名 OpenAI 代表表示，他们希望借助 GPT-5 进一步提升竞争力，但未透露具体细节。&lt;/p&gt; 
&lt;p&gt;据悉，GPT-5 有望在今年夏季某个时间点发布，但具体时间尚不明确。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;值得一提的是，OpenAI CEO Sam Altman 就在刚刚疑似对新模型进行预告。其表示「火爆的 AI 夏天」，并透露 OpenAI 即将发布许多精彩内容。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2c222639a50749ed14090c376008a28b88e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据 AI 工程师 Tibor Blaho 近期透露，OpenAI 将在 7 月发布一个大规模模型。此前，Tibor Blaho 曾在 o3、o4 mini 系列模型发布前，在 ChatGPT 的网页中挖出相关信息。另据投资者「Chris（chatgpt21）」消息透露，GPT-5 发布时间有望定于 7 月。&lt;/p&gt; 
&lt;p&gt;今年 4 月，Altman 在 X 上宣布新模型发布计划的调整：GPT-5 将在几个月内发布。当时 Altman 解释了这次调整的原因，是要把 GPT-5 做得比最初预期的还要好得多，同时在整合上遇到了比想象中要大的困难。&lt;/p&gt; 
&lt;p&gt;今年 2 月，Altman 还曾公布了 GPT-5 的发展路线，并表示未来 OpenAI 旗下产品将简化分类：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;在 GPT-4.5 发布后，OpenAI 将会推出集成化模型系统，来统一 O 系列模型以及 GPT 系列模型。据 Altman 透露，GPT-5 将作为一个集成了 OpenAI 多项技术的系统进行发布，其中包含 o3 模型，同时 o3 模型将不再单独进行发布。&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353433</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353433</guid>
      <pubDate>Sun, 11 May 2025 02:23:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Quarkdown 横空出世：当 Markdown 遇上 LaTeX，排版世界迎来新变革</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;在科技圈，每隔一段时间就会出现试图「重新发明轮子」的项目。但当这个轮子确实比原来的更圆、更好用时，我们是否应该给它一个机会？最近在 GitHub 上爆火的 Quarkdown 项目，就是这样一个野心勃勃的「造轮子」工程——它想要结合 Markdown 的简洁与 LaTeX 的强大，创造一个全新的排版系统。&lt;/p&gt; 
&lt;h2&gt;从一个痛点说起&lt;/h2&gt; 
&lt;p&gt;如果你曾经写过学术论文或技术文档，一定对这个场景不陌生：用 Markdown 写作时觉得功能太少，想要更复杂的排版；切换到 LaTeX 后又被满屏的反斜杠和 begin/end 弄得头晕眼花。正如 HackerNews 用户 blenderob 所说：「LaTeX 的语法就像是在惩罚用户。」&lt;/p&gt; 
&lt;p&gt;Quarkdown 的诞生，正是为了解决这个两难困境。它的核心理念很简单：保持 Markdown 的易读性，同时提供 LaTeX 级别的排版控制能力。&lt;/p&gt; 
&lt;h2&gt;魔法般的函数系统&lt;/h2&gt; 
&lt;p&gt;Quarkdown 最引人注目的特性是其函数调用系统。想象一下，你可以在 Markdown 中这样写：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-markdown"&gt;.function {greet}
    to from:
    **Hello, .to** from .from!

.greet {world} from:{iamgio}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;结果会渲染为：&lt;strong&gt;Hello, world&lt;/strong&gt; from iamgio！&lt;/p&gt; 
&lt;p&gt;这种设计让 Markdown 瞬间变成了一门图灵完备的编程语言。你可以定义变量、创建循环、实现条件判断，甚至构建自己的函数库。用户 jamesgill 形象地比喻道：「这就像给自行车装上了发动机！」&lt;/p&gt; 
&lt;h2&gt;与 Typst 的正面交锋&lt;/h2&gt; 
&lt;p&gt;说到现代排版系统，就不得不提到近期大热的 Typst。有趣的是，Quarkdown 的对比表中最初竟然没有包含 Typst，这在 HackerNews 上引发了不小的争议。用户 structural 直言：「Typst 最近获得了大量关注，不把它列入对比表令人惊讶。」&lt;/p&gt; 
&lt;p&gt;两者的核心差异在于设计哲学。Typst 更像是「LaTeX 的现代化重制版」，它有自己完整的语法体系，学习曲线相对陡峭，但功能强大且专业。而 Quarkdown 则选择了「渐进式增强」的路线——你的 Markdown 文档依然是 Markdown，只是在需要时可以调用强大的函数功能。&lt;/p&gt; 
&lt;p&gt;用户 krick 精辟地总结道：「Quarkdown 倾向于『比 Markdown 稍微强大一点』，而不是『替代 LaTeX』。」这种定位差异决定了两者的不同受众。Typst 吸引的是那些想要彻底摆脱 LaTeX 但又需要专业排版能力的用户，而 Quarkdown 则更适合那些已经在使用 Markdown，但偶尔需要更强大功能的人。&lt;/p&gt; 
&lt;p&gt;从实用角度看，Typst 目前已经支持 HTML 输出（虽然还在实验阶段），而且有着更成熟的生态系统。但 Quarkdown 的优势在于更低的学习门槛——如果你已经熟悉 Markdown，上手 Quarkdown 几乎没有额外成本。&lt;/p&gt; 
&lt;h2&gt;实际应用：不只是纸上谈兵&lt;/h2&gt; 
&lt;p&gt;Quarkdown 不仅支持传统的文档输出，还能生成幻灯片（基于 reveal.js）、分页文档（书籍、文章，基于 paged.js）以及 PDF 导出（通过 Chrome 的打印功能）。项目还提供了一个令人印象深刻的实时预览功能。你可以一边编写，一边看到渲染结果，这对于调试复杂的排版来说简直是福音。&lt;/p&gt; 
&lt;p&gt;用户 speerer 兴奋地表示：「我可能终于找到了替代我那些 rickety 的模板和 pandoc 转换管道的工具了！」这种热情反映了许多技术写作者的心声——他们一直在寻找一个既简单又强大的解决方案。&lt;/p&gt; 
&lt;h2&gt;争议与讨论&lt;/h2&gt; 
&lt;p&gt;当然，任何新技术都会引发争议。在 HackerNews 的讨论中，几个核心问题被反复提及。&lt;/p&gt; 
&lt;p&gt;首先是 Java 依赖问题。Quarkdown 基于 Kotlin 开发，需要 Java 17+运行环境。用户 akagusu 直接表示：「看到需要 Java 17 或更高版本，我就失去兴趣了。」这种反应代表了相当一部分开发者的心声。正如用户 francislavoie 所说：「CLI 工具还要 JVM 语言？要是有静态二进制文件，我会更愿意尝试。」&lt;/p&gt; 
&lt;p&gt;其次是语法设计争议。函数参数需要缩进的设计引发了激烈讨论。用户 krick 认为这会导致整个文档都变成缩进的，破坏了 Markdown 的简洁性：「我的主要问题是函数参数需要制表符缩进。看起来这会导致整个文档都被制表符缩进。」&lt;/p&gt; 
&lt;p&gt;最具挑战性的是生态系统问题。用户 behnamoh 作为一名学者直言不讳：「作为学术工作者，我不会使用这个，因为我看不到我的合作者会用它。」这道出了所有新排版系统面临的鸡生蛋问题——没有用户就没有生态，没有生态就吸引不到用户。&lt;/p&gt; 
&lt;h2&gt;技术亮点与创新&lt;/h2&gt; 
&lt;p&gt;抛开争议，Quarkdown 确实有一些值得称道的技术创新。其媒体存储系统能自动管理文档中的图片和其他媒体资源，项目创建向导可以通过命令行工具快速搭建项目结构，而标准库系统则提供了布局构建器、I/O 操作、数学函数等丰富功能。&lt;/p&gt; 
&lt;p&gt;特别值得一提的是其实时编译功能。文件变化时自动重新编译，配合预览功能体验极佳。这种开发体验的提升，可能是吸引用户尝试新工具的重要因素。&lt;/p&gt; 
&lt;h2&gt;未来展望：理想与现实&lt;/h2&gt; 
&lt;p&gt;Quarkdown 代表了一种理想：让复杂的排版变得简单，让简单的文档保持简洁。但理想能否照进现实，还需要时间检验。&lt;/p&gt; 
&lt;p&gt;支持者认为，随着 AI 助手的普及，复杂的语法不再是障碍。用户 sgt 充满期待地说：「如果 LLM 开始默认输出 Quarkdown 格式——哪怕只是一个提供商（比如 OpenAI），这个项目就会像野火一样蔓延。Markdown 的局限性确实有点过时了。」&lt;/p&gt; 
&lt;p&gt;反对者则指出，LaTeX 已经统治学术界几十年，任何替代品都需要提供足够的价值才能说服用户迁移。用户 slashdave 质疑道：「我有二十年前写的 LaTeX 文档，现在还能完美渲染。当这个潮流过去后，10 年后 Quarkdown 文档会怎样？」&lt;/p&gt; 
&lt;p&gt;用户 coliveira 更是直接：「这就是为什么这些东西都走不远。如果我需要写格式化细节，最好使用 LaTeX，这是一个经过充分测试的稳定语言，还能再用 30 年。」&lt;/p&gt; 
&lt;h2&gt;结语：给创新一个机会&lt;/h2&gt; 
&lt;p&gt;在这个「重复造轮子」被视为贬义的时代，Quarkdown 的出现提醒我们：有时候，重新思考既有方案也许能带来意想不到的突破。&lt;/p&gt; 
&lt;p&gt;无论你是被 LaTeX 折磨的研究生，还是觉得 Markdown 功能不够的技术写作者，Quarkdown 都值得一试。即使它最终无法撼动 LaTeX 的地位，至少它展示了一种可能性：排版系统可以既强大又友好。&lt;/p&gt; 
&lt;p&gt;正如项目名称的寓意——夸克是构成物质的基本粒子，轻盈却蕴含无限可能。也许，Quarkdown 真的能成为下一代排版系统的基石。或者，它至少能激发更多人思考：我们真的需要忍受那些设计于几十年前的工具吗？&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353418</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353418</guid>
      <pubDate>Sun, 11 May 2025 01:23:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>​​字节跳动开源 Computer Use Agent：引领人机交互新革命​</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;div class="ckeditor-html5-video"&gt; 
 &lt;video controlslist="nodownload"&gt;
  &amp;nbsp;
 &lt;/video&gt; 
&lt;/div&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;字节跳动开源 Computer Use Agent：引领人机交互新革命&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;在人工智能技术日新月异的今天，字节跳动再次以创新者的姿态，宣布开源其自主研发的 Computer Use Agent（以下简称 CUA）。这一举措不仅标志着字节跳动在 AI 领域的又一重大突破，更为全球开发者提供了一个强大的工具，以前所未有的方式与计算机进行交互。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;CUA：从对话到行动的跨越&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;传统的 AI 助手往往停留在「对话式人工智能」的层面，即通过自然语言处理理解用户意图，并给出相应的回答或建议。然而，CUA 则实现了从「对话」到「行动」的跨越。它不仅能够理解用户的指令，更能通过自研的 Doubao 1.5 UI-TARS 模型，直接与计算机的图形用户界面（GUI）进行交互，执行复杂的任务。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;Doubao 1.5 UI-TARS 模型融合了视觉能力与高级推理，能够精准捕捉用户指令背后的场景意图。无论是视频剪辑、演示文稿制作，还是自媒体账号运维，CUA 都能轻松应对，极大地提升了用户的工作效率。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;强大的技术支撑&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;CUA 的强大背后，是字节跳动在 AI 领域的深厚积累。其核心技术包括：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;感知能力&lt;/strong&gt;：CUA 能够截取计算机屏幕图像，对数字环境中的内容进行情境化处理，为决策提供依据。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;推理能力&lt;/strong&gt;：借助思维链推理，CUA 能够评估观察结果，跟踪中间步骤的进展，动态适应新的挑战和不可预见的变化。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;行动能力&lt;/strong&gt;：利用虚拟鼠标和键盘，CUA 能够执行键入、点击和滚动等操作，实现与计算机的无缝交互。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;多系统支持与极致性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;CUA 不仅支持 Windows 操作系统，还兼容 Linux 系统，满足了不同用户的需求。Windows 系统拥有丰富的传统软件生态，而 Linux 系统则更加轻量与灵活，适合企业级计算环境。此外，依托字节跳动分布式架构的底层技术积累，CUA 实现了云主机实例的秒级启动响应，动态负载均衡机制可根据业务流量实时调整资源分配，构建从资源申请到服务就绪的极致弹性链路。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;灵活的服务组合&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;CUA 采用高内聚低耦合的微服务架构设计，支持全栈式部署与组件化调用。对于大型互联网客户，可以按需编排 Agent Planer、MCP Server、Sandbox Manager 等服务；对于小型客户，则提供全栈式的一体化解决方案，满足不同规模用户的需求。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;开源与社区支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;字节跳动此次开源 CUA，不仅是为了分享技术成果，更是为了与全球开发者共同构建一个更加智能、高效的人机交互生态。开发者可以通过 GitHub 轻松获取 CUA 的代码，并参与到其开发与优化中来。此外，字节跳动还提供了丰富的文档和社区支持，帮助开发者快速上手并充分利用 CUA 的强大功能。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;展望未来&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;随着人工智能技术的不断发展，人机交互将变得更加自然、高效。字节跳动开源 CUA，无疑为这一趋势注入了新的动力。未来，CUA 有望在更多领域得到应用，如智能家居、远程办公、教育培训等，为用户带来更加便捷、智能的体验。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;字节跳动开源 Computer Use Agent，是其在 AI 领域的一次重要布局，也是对全球开发者的一份厚礼。通过开源 CUA，字节跳动不仅分享了其技术成果，更与全球开发者共同探索人机交互的未来。让我们期待 CUA 在未来的发展中，为用户带来更多惊喜与便利。&lt;/p&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;开源链接&lt;/strong&gt;：&lt;span style="background-color:#f3f3f3; color:rgba(0, 0, 0, 0.9)"&gt;https://github.com/volcengine/ai-app-lab/tree/main/demohouse/computer_use&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353373</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353373</guid>
      <pubDate>Sat, 10 May 2025 11:42:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>11Labs 发布对话式 AI 2.0，集成话轮转换和知识库，多语言多角色多模态</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1920" src="https://oscimg.oschina.net/oscnet/up-fb27eb9853e5a2ba39b1a40c448360774ba.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开发者朋友们大家好：&lt;/p&gt; 
&lt;p&gt;这里是 &lt;strong&gt;「RTE 开发者日报」&lt;/strong&gt; ，每天和大家一起看新闻、聊八卦。我们的社区编辑团队会整理分享 RTE（Real-Time Engagement） 领域内「有话题的 &lt;strong&gt;技术&lt;/strong&gt; 」、「有亮点的 &lt;strong&gt;产品&lt;/strong&gt; 」、「有思考的 &lt;strong&gt;文章&lt;/strong&gt; 」、「有态度的 &lt;strong&gt;观点&lt;/strong&gt; 」、「有看点的 &lt;strong&gt;活动&lt;/strong&gt; 」，但内容仅代表编辑的个人观点，欢迎大家留言、跟帖、讨论。&lt;/p&gt; 
&lt;p&gt;本期编辑：@赵怡岭、@鲍勃&lt;/p&gt; 
&lt;h2&gt;01 有话题的技术&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;1、通义实验室语音团队推出 OmniAudio 技术，可直接从 360° 视频生成 FOA 空间音频&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;5 月 29 日，阿里通义大模型公布了「空间音频生成」模型——OmniAudio。据通义团队介绍，OmniAudio 能够直接从 360° 视频生成空间音频。&lt;/p&gt; 
&lt;p&gt;为了解决「如何利用全景视频生成与之匹配的空间音频」这一问题，通义实验室语音团队提出了 360V2SA（360-degree Video to Spatial Audio）任务，旨在直接从 360° 视频生成 FOA（First-order Ambisonics）音频。&lt;/p&gt; 
&lt;p&gt;据悉，FOA 是一种标准的 3D 空间音频格式，能够捕捉声音的方向性，实现真实的 3D 音频再现。&lt;/p&gt; 
&lt;p&gt;受限于现有的配对 360° 视频和空间音频数据极为稀缺，通义团队还为此精心设计并构建了 Sphere360 数据集。该数据集包含大量高质量的 360° 视频和相应的 FOA 空间音频。这是一个包含超过 10.3 万个真实世界视频片段的数据集，涵盖 288 种音频事件，总时长达到 288 小时。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="528" src="https://oscimg.oschina.net/oscnet/up-0dbe15c65229d3de4c65a785c1399b0d386.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;另外，OmniAudio 的训练方法分为了「自监督的 coarse-to-fine 流匹配预训练」以及「基于双分支视频表示的有监督微调」两个阶段。&lt;/p&gt; 
&lt;p&gt;目前，OmniAudio 已上架 GitHub 并同步公布了代码、数据开源仓库，以及相关技术论文。&lt;/p&gt; 
&lt;p&gt;项目主页：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fomniaudio-360v2sa.github.io%2F" target="_blank"&gt;https://omniaudio-360v2sa.github.io/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;代码和数据开源仓库：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fliuhuadai%2FOmniAudio" target="_blank"&gt;https://github.com/liuhuadai/OmniAudio&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;论文地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2504.14906" target="_blank"&gt;https://arxiv.org/abs/2504.14906&lt;/a&gt; （@APPSO、@阿里语音 AI）&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、可灵 2.1 系列视频模型发布，拥有卓越的动态效果表现，更强的语义响应&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;快手可灵 AI 发布了其 KLING 2.1 系列视频模型。据悉，可灵 2.1 系列拥有标准版和大师版两个版本模型：&lt;/p&gt; 
&lt;p&gt;标准版支持标准（720P）和高品质（1080P）两种模式。价格方面，标准模式为 20 积分/5 秒，高品质模式为 35 积分/5 秒。&lt;/p&gt; 
&lt;p&gt;大师模式全面升级为 1080P 输出，拥有卓越的动态效果表现，更强的语义响应。可灵 2.1 标准版暂仅支持「图生视频」功能，「文生视频」功能将在近期上线。目前，可灵 AI 官网已可体验可灵 2.1 系列模型。&lt;/p&gt; 
&lt;p&gt;可灵 AI：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapp.klingai.com%2Fcn%2F" target="_blank"&gt;https://app.klingai.com/cn/&lt;/a&gt; （@APPSO）&lt;/p&gt; 
&lt;h2&gt;02 有亮点的产品&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;1、PlayDiffusion：一种基于扩散的修补模型，具有修改现有语音的能力&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;PlayDiffusion 是一个让用户能够通过简单编辑文本来编辑音频/视频内容中语音的模型。该模型是一种基于扩散的修补模型，具有修改现有语音的能力，通过该模型可以像编辑文档一样编辑语音，无需重新录制。只需上传音频/视频，编辑自动生成的转录文本，即可获得更新后的语音。现已开源。&lt;/p&gt; 
&lt;p&gt;工作原理：&lt;/p&gt; 
&lt;p&gt;1、上传内容；&lt;/p&gt; 
&lt;p&gt;2、模型转录语音；&lt;/p&gt; 
&lt;p&gt;3、你编辑转录文本；&lt;/p&gt; 
&lt;p&gt;4、模型使用相同的声音进行更改。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="618" src="https://oscimg.oschina.net/oscnet/up-8ff87eed051a2f090ed7f43ab900a6cc0c7.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;并且 PlayDiffusion 不是像自回归模型那样逐个生成标记，而是能够一次性预测所有标记，并在大约 20 个去噪步骤中进行优化。这使得生成步骤的效率提高了最多 50 倍，同时没有任何损失。&lt;/p&gt; 
&lt;p&gt;GitHub: &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fplayht%2FPlayDiffusion" target="_blank"&gt;https://github.com/playht/PlayDiffusion&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;Demo: &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fspaces%2FPlayHT%2FPlayDiffusion" target="_blank"&gt;https://huggingface.co/spaces/PlayHT/PlayDiffusion&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;Fal: &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffal.ai%2Fmodels%2Ffal-ai%2Fplayai%2Finpaint%2Fdiffusion" target="_blank"&gt;https://fal.ai/models/fal-ai/playai/inpaint/diffusion&lt;/a&gt; (@HammadH4@X、 @PlayAIOfficial@X)&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、ElevenLabs 发布对话式人工智能 2.0 ，具备新一代先进的轮流发言功能和全面支持企业级应用&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;ElevenLabs 发布 Conversational AI 2.0，实现了自然转换对话能力，能识别语气词判断用户意图，避免尴尬停顿和不当打断。ElevenLabs Conversational AI 现已支持多模态，用户可以创建能够通过文本、语音或同时通过两者进行交流的智能体。&lt;/p&gt; 
&lt;p&gt;ElevenLabs 开发了批量呼叫功能，使用户能够自动化并扩展外呼语音通信。批量呼叫允许使用用户的对话式 AI 智能体同时发起多个外呼，非常适合发送警报、进行调查或向庞大联系人列表传递个性化信息等用例，提升速度和一致性。 新系统集成了多语言自动识别功能和检索增强生成（RAG）技术，支持多模态交互，一个 AI 助手可同时处理文本和语音。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="464" src="https://oscimg.oschina.net/oscnet/up-2268b07cc714d7df61acc312e4021b9d1f0.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;新功能概览：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;新一代先进的轮流发言模型；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;语言切换；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;多角色模式；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;多模态；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;批量调用；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;内置 RAG。（@elevenlabsio@X、@腾讯研究院、@海波学者聊 AI）&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;3、马斯克宣布推出 XChat，具备消息「阅后即焚」和无需电话号码即可使用的网络通话/视频功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1024" src="https://oscimg.oschina.net/oscnet/up-641ef9a7fa2678ebfb7b35f9975ecb87baa.png" width="1024" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;日前，马斯克宣布推出一款名为「XChat」的即时通信服务平台。据悉，该平台将具备消息「阅后即焚」和无需电话号码即可使用的网络通话/视频功能。&lt;/p&gt; 
&lt;p&gt;马斯克宣称 XChat 采用了「比特币风格的加密」，并用 Rust 语言开发，号称「全新架构」。&lt;/p&gt; 
&lt;p&gt;据 The Information 报道指出，XChat 本质上是为了与 WhatsApp、Telegram，甚至是微信展开竞争。&lt;/p&gt; 
&lt;p&gt;值得一提的是，Telegram 创始人 Pavel Durov 在一周前曾表示其与马斯克旗下的 xAI 签署了合作协议，并在 Telegram 中接入了 xAI 的 AI 聊天机器人 Grok。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;端到端加密：消息、通话内容只有通信双方能看到，第三方（包括 X 平台）无法窥探；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;阅后即焚：可以设置消息在一定时间后自动删除，比如 10 分钟后，保护隐私更彻底；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;任意文件传输：支持发送任何类型的文件，包括照片、视频、文档等，不再受限于格式或大小；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;跨平台音视频通话：无需手机号即可拨打，支持手机、电脑等多设备，通话内容同样加密。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;(@APPSO、@Techub Info)&lt;/p&gt; 
&lt;h2&gt;03 Real-Time AI Demo&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;1、使用手势和语音命令控制 3D 模型，包括移动、旋转、缩放、动画&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;来自 X 上的@measure_plan：你现在可以导入任何 3D 模型，并使用手势+语音来控制它&lt;/p&gt; 
&lt;h2&gt;04 有态度的观点&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;1、Anthropic CEO：未来五年 AI 或取代一半白领工作&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;最近在旧金山总部接受采访时，Anthropic CEO Dario Amodei 发出严峻警告：AI 的迅猛发展可能在未来一到五年内淘汰多达一半的初级白领岗位，社会失业率或飙升至 10% 到 20%。&lt;/p&gt; 
&lt;p&gt;Amodei 表示，现在是时候停止对 AI 潜在影响的「美化」，技术、金融、法律、咨询等多个行业的初级职位将面临大规模消失，而多数普通人对此几乎一无所知，也缺乏足够的重视。&lt;/p&gt; 
&lt;p&gt;他希望通过公开发声，促使政策制定者与同行开始采取行动，为社会转型做准备。「大多数人并不知道这件事就要发生，听起来像疯话，但他们不信。」&lt;/p&gt; 
&lt;p&gt;Amodei 表示，虽然 AI 也带来医疗突破、经济增长等潜力，但其风险同样不可忽视。「癌症治好了，GDP 每年增长 10%，财政平衡……可有 20% 的人失去了工作。」他坦言，这样的情境极可能在技术爆发中同时发生。(@APPSO)&lt;/p&gt; 
&lt;p&gt;&lt;img height="411" src="https://oscimg.oschina.net/oscnet/up-02d9ba069382d25ac98e7b02d29ed2b79ba.png" width="696" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;更多 Voice Agent 学习笔记：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSqXLZvq_zwWDcOVKbAb7HQ" target="_blank"&gt;级联 vs 端到端、全双工、轮次检测、方言语种、商业模式…语音 AI 开发者都在关心什么？丨 Voice Agent 学习笔记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7QPgzp8kDR_9iHUa4oFeiA" target="_blank"&gt;a16z 最新报告：AI 数字人应用层即将爆发，或将孕育数十亿美金市场丨 Voice Agent 学习笔记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUM1qs2IT1S6kJ4sZf_k3uA" target="_blank"&gt;a16z 合伙人：语音交互将成为 AI 应用公司最强大的突破口之一，巨头们在 B2C 市场已落后太多丨 Voice Agent 学习笔记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWI0gE4x-TZG0gdgSV_bVSA" target="_blank"&gt;ElevenLabs 33 亿美元估值的秘密：技术驱动+用户导向的「小熊软糖」团队丨 Voice Agent 学习笔记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSVsgDF8F1hxy3-e5-ntGbw" target="_blank"&gt;端侧 AI 时代，每台家居设备都可以是一个 AI Agent 丨 Voice Agent 学习笔记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4K5wdUEDxrs1afHZSAIuqg" target="_blank"&gt;世界最炙手可热的语音 AI 公司，举办了一场全球黑客松，冠军作品你可能已经看过&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FJCYzc1Ig-HFFAN3sTQDYbw" target="_blank"&gt;多模态 AI 怎么玩？这里有 18 个脑洞&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrN9poD_X6SDxRLMsudg_xg" target="_blank"&gt;AI 重塑宗教体验，语音 Agent 能否成为突破点？&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FeFS1mnAbUpAJdiLSSGWpSA" target="_blank"&gt;对话 TalktoApps 创始人：Voice AI 提高了我五倍的生产力，语音输入是人机交互的未来&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fr2z1bilamX6YWTg90F8xYA" target="_blank"&gt;a16z 最新语音 AI 报告：语音将成为关键切入点，但非最终产品本身（含最新图谱）&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;写在最后：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我们欢迎更多的小伙伴参与 &lt;strong&gt;「RTE 开发者日报」&lt;/strong&gt; 内容的共创，感兴趣的朋友请通过开发者社区或公众号留言联系，记得报暗号「共创」。&lt;/p&gt; 
&lt;p&gt;对于任何反馈（包括但不限于内容上、形式上）我们不胜感激、并有小惊喜回馈，例如你希望从日报中看到哪些内容；自己推荐的信源、项目、话题、活动等；或者列举几个你喜欢看、平时常看的内容渠道；内容排版或呈现形式上有哪些可以改进的地方等。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="241" src="https://oscimg.oschina.net/oscnet/up-486853450499be2bd7283c3af3f26b7bef1.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;素材来源官方媒体/网络新闻&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353371</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353371</guid>
      <pubDate>Sat, 10 May 2025 11:34:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>腾讯跨端框架 Kuikly 鸿蒙版正式开源</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;Kuikly 是腾讯开源的跨端开发框架，基于 Kotlin Multiplatform 技术构建，为开发者提供了技术栈更统一的跨端开发体验。&lt;/p&gt; 
&lt;p&gt;在 Android、iOS 开源基础上，本次开源鸿蒙平台支持和 Compose DSL 支持，进一步提升业务多端适配和鸿蒙开发效率。&lt;/p&gt; 
&lt;p&gt;据介绍，目前 Kuikly 鸿蒙版已接入腾讯多款业务，开发并上架鸿蒙 App，如 QQ 浏览器、腾讯新闻、搜狗输入法、全民 K 歌、自选股等。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在鸿蒙平台上，Kuiky 打开页面速度比 RN 快 6 倍：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="836" src="https://static.oschina.net/uploads/space/2025/0603/184902_dwpK_2720166.png" width="765" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Kuikly 基于 Kotlin MultiPlatform（KMP）技术，它利用了 KMP 逻辑跨平台的能力，并抽象出通用的跨平台 UI 渲染接口，复用平台的 UI 组件，从而达到 UI 跨平台，具有轻量、高性能、可动态化等优点；&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Kuikly 包括「KuiklyUI」和「KuiklyBase」两部分。其中，KuiklyUI 支持业务使用自研 DSL 和 Compose DSL 进行 UI 跨端开发，采用轻量、原生渲染方式，支持页面级动态化；KuiklyBase 支持 UI 和 KMP 逻辑全面跨端的基础能力和设施，包括丰富的跨端组件，完善的调试、构建、发布、监控配套工具链，稳定性监控能力等。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;同时，KuiklyBase 基建同样支持逻辑跨端。 让开发者&lt;strong&gt;可以使用 Kotlin 创建 Android、iOS、鸿蒙、Web、小程序应用&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-911df639ea27ac02b452b9a379738d91ddd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353362</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353362</guid>
      <pubDate>Sat, 10 May 2025 10:51:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>深入协议层：tlmqtt 如何通过自定义编解码器实现高性能 MQTT Broker</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;strong&gt;tlmqtt 是一款基于 Java 开发、底层依赖 Netty 和 Project Reactor 的完全开源免费的高性能 MQTT Broker。它提供完整的 MQTT 协议解析、QoS 0/1/2 消息支持、自定义消息存储、可扩展的认证机制以及数据桥接功能。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;MQTT 编解码：深入控制与理解&lt;/h1&gt; 
&lt;p&gt;在分析众多开源 &lt;code&gt;MQTT Broker&lt;/code&gt;实现时，发现绝大多数（约 99%）都直接使用 &lt;code&gt;Netty&lt;/code&gt;提供的编解码器，如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;pipeline.addLast(MqttEncoder.INSTANCE);
pipeline.addLast(new MqttDecoder(maxBytesInMessage));
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这种方式让开发者无需关注协议解析细节，专注于业务逻辑开发，是其显著优势。然而，它也带来了两个关键限制：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;em&gt;高度依赖 &lt;code&gt;Netty&lt;/code&gt;： 扩展性和灵活性受限于&lt;code&gt;Netty&lt;/code&gt;的实现&lt;/em&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;em&gt;协议理解不足： 开发者容易停留在「知其然」层面，对 &lt;code&gt;CONNECT&lt;/code&gt;、&lt;code&gt;PUBLISH&lt;/code&gt;等报文的具体结构和解析过程缺乏深入理解&lt;/em&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt; 选择了自定义编解码器的实现路径，对 &lt;code&gt;MQTT&lt;/code&gt;消息报文进行逐步解析。这为我们提供了更深入的控制、灵活性和扩展性，同时也是深入理解&lt;code&gt;MQTT&lt;/code&gt;协议细节的实践。&lt;/p&gt; 
&lt;h1&gt;Netty 基础与 MQTT 协议的挑战&lt;/h1&gt; 
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;高性能网络开发离不开 &lt;code&gt;Netty&lt;/code&gt;。它提供了多种开箱即用的编解码器，如固定长度、分隔符和基于长度域的帧解码器。在实现自定义编解码器之前，必须理解 &lt;code&gt;MQTT&lt;/code&gt;协议对消息长度的独特定义方式 &lt;strong&gt;剩余长度编码规则：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;单个字节可表示 0 到 127 的值。&lt;/li&gt; 
 &lt;li&gt;大于 127 的值处理如下： &amp;nbsp; &amp;nbsp; &amp;nbsp;- 每个字节的，低 7 位 (bits 0-6) 用于编码数据。 &amp;nbsp;&amp;nbsp; &amp;nbsp;- 最高位 (bit 7) 作为标识位：1 表示还有后续字节，0 表示结束。&lt;/li&gt; 
 &lt;li&gt;剩余长度最多由，四个字节，表示。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;显然， &lt;code&gt;MQTT&lt;/code&gt;的这种变长编码方式与 &lt;code&gt;Netty&lt;/code&gt;内置的标准长度域解码器（通常是固定字节数表示长度）并不完全匹配。因此，自定义编解码器成为必然选择。&lt;/p&gt; 
&lt;h2&gt;解码器实现：从字节流到消息对象&lt;/h2&gt; 
&lt;p&gt;自定义解码器需继承 &amp;nbsp;&lt;code&gt;Netty&lt;/code&gt;的 &amp;nbsp;&lt;code&gt;ByteToMessageDecoder&lt;/code&gt;类，核心任务是将接收到的 &lt;code&gt;ByteBuf&lt;/code&gt;字节流转换为业务逻辑所需的 &lt;code&gt;AbstractTlMessage&lt;/code&gt;对象（及其各种具体子类，如 &amp;nbsp;&lt;code&gt;TlMqttConnectReq&lt;/code&gt;）。 核心 &amp;nbsp;&lt;code&gt;decode&lt;/code&gt;方法流程如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) throws Exception {
&amp;nbsp; &amp;nbsp; // 1. 检查基本长度：可读字节数小于 2(固定头最小长度)，等待更多数据
&amp;nbsp; &amp;nbsp; if (in.readableBytes() &amp;lt; MIN_LENGTH) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; // 2. 标记当前读指针位置，以便后续数据不足时回退
&amp;nbsp; &amp;nbsp; in.markReaderIndex();

&amp;nbsp; &amp;nbsp; // 3. 读取第 1 字节：包含消息类型 (高 4 位) 和标志位 (低 4 位)
&amp;nbsp; &amp;nbsp; short firstByte = in.readUnsignedByte();
&amp;nbsp; &amp;nbsp; // 4. 解码剩余长度 (变长编码)
&amp;nbsp; &amp;nbsp; int remainingLength = decodeRemainingLength(in);

&amp;nbsp; &amp;nbsp; // 5. 检查载荷数据是否完整到达 (剩余长度指的就是载荷长度)
&amp;nbsp; &amp;nbsp; if (in.readableBytes() &amp;lt; remainingLength) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; in.resetReaderIndex(); // 数据不足，重置读指针，等待后续数据
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return;
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; // 6. 数据完整：读取载荷部分到临时 ByteBuf
&amp;nbsp; &amp;nbsp; ByteBuf payloadBuf = in.readBytes(remainingLength);
&amp;nbsp; &amp;nbsp; // 可选：打印原始报文 (十六进制) - TlLog.logger("mqtt raw hex", payloadBuf);
&amp;nbsp; &amp;nbsp; try {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 7. 提取消息类型 (右移 4 位取高 4 位)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int messageType = firstByte &amp;gt;&amp;gt; Constant.MESSAGE_BIT;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; MqttMessageType mqttType = MqttMessageType.valueOf(messageType);

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 8. 根据消息类型，分派给对应的具体解码器构建请求对象
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; AbstractTlMessage req = switch (mqttType) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case CONNECT -&amp;gt; connectDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case DISCONNECT -&amp;gt; disConnectDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PUBLISH -&amp;gt; publishDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PUBACK -&amp;gt; pubAckDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PUBREC -&amp;gt; pubRecDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PUBREL -&amp;gt; pubRelDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PUBCOMP -&amp;gt; pubCompDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case SUBSCRIBE -&amp;gt; subscribeDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case UNSUBSCRIBE -&amp;gt; unSubscribeDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; case PINGREQ -&amp;gt; heartBeatDecoder.build(payloadBuf, firstByte, remainingLength);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; default -&amp;gt; throw new IllegalArgumentException("Unknown MQTT message type: " + mqttType);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; };
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.add(req); // 9. 将解析好的消息对象加入输出列表，传递给后续 Handler
&amp;nbsp; &amp;nbsp; } finally {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payloadBuf.release(); // 10. 确保临时 ByteBuf 资源释放
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;关键辅助方法：剩余长度解码 ( &lt;code&gt;decodeRemainingLength&lt;/code&gt;)&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;private int decodeRemainingLength(ByteBuf in) {
&amp;nbsp; &amp;nbsp; int multiplier = 1; // 乘数因子 (128^0, 128^1, ...)
&amp;nbsp; &amp;nbsp; int value = 0; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 累积计算出的剩余长度值
&amp;nbsp; &amp;nbsp; byte encodedByte;
&amp;nbsp; &amp;nbsp; do {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; encodedByte = in.readByte(); &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 读取一个编码字节
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; value += (encodedByte &amp;amp; 0x7F) * multiplier; // 取低 7 位数据并乘以当前乘数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; multiplier *= 128; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 乘数递增 (128^1, 128^2, ...)
&amp;nbsp; &amp;nbsp; } while ((encodedByte &amp;amp; 0x80) != 0); &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 检查最高位 (标识位) 是否为 1 (还有后续字节)
&amp;nbsp; &amp;nbsp; return value;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;根据解析出的消息类型，数据会被分派给对应的具体解码器（如 &amp;nbsp;&lt;code&gt;TlMqttConnectDecoder&lt;/code&gt;）。这些解码器通常采用模块化设计，包含 &lt;code&gt;decodeFixedHeader&lt;/code&gt;（固定头）、 &lt;code&gt;decodeVariableHeader&lt;/code&gt;（可变头）和 &lt;code&gt;decodePayload&lt;/code&gt;（载荷）三个核心方法。 以 &amp;nbsp;&lt;code&gt;CONNECT&lt;/code&gt;报文解码 ( &lt;code&gt;TlMqttConnectDecoder&lt;/code&gt;) 为例：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;// 解码固定头 (相对简单，主要是类型和长度)
TlMqttFixedHead decodeFixedHeader(int remainingLength) {
&amp;nbsp; &amp;nbsp; TlMqttFixedHead fixedHead = new TlMqttFixedHead();
&amp;nbsp; &amp;nbsp; fixedHead.setMessageType(MqttMessageType.CONNECT);
&amp;nbsp; &amp;nbsp; fixedHead.setLength(remainingLength); // 设置整个报文剩余长度
&amp;nbsp; &amp;nbsp; return fixedHead;
}

// 解码可变头 (包含协议名、版本、连接标志和保活时间)
TlMqttConnectVariableHead decodeVariableHeader(ByteBuf buf) {
&amp;nbsp; &amp;nbsp; TlMqttConnectVariableHead variableHead = new TlMqttConnectVariableHead();

&amp;nbsp; &amp;nbsp; // 1. 协议名 (通常是"MQTT")
&amp;nbsp; &amp;nbsp; int protocolNameLen = buf.readUnsignedShort(); // 长度域 (2 字节)
&amp;nbsp; &amp;nbsp; variableHead.setProtocolNameLength(protocolNameLen);
&amp;nbsp; &amp;nbsp; byte[] protocolNameBytes = new byte[protocolNameLen];
&amp;nbsp; &amp;nbsp; buf.readBytes(protocolNameBytes);
&amp;nbsp; &amp;nbsp; String protocolName = new String(protocolNameBytes, StandardCharsets.UTF_8); // 显式指定字符集

&amp;nbsp; &amp;nbsp; // 2. 协议版本 (e.g., 4 for MQTT 3.1.1)
&amp;nbsp; &amp;nbsp; short protocolVersion = buf.readUnsignedByte();
&amp;nbsp; &amp;nbsp; variableHead.setProtocolVersion(protocolVersion);

&amp;nbsp; &amp;nbsp; // 3. 连接标志字节 (Connect Flags) - 关键!
&amp;nbsp; &amp;nbsp; int connectFlags = buf.readUnsignedByte();
&amp;nbsp; &amp;nbsp; // 位运算解析各个标志位
&amp;nbsp; &amp;nbsp; variableHead.setReserved(connectFlags &amp;amp; 0x01); &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Bit 0 (保留位，必须为 0)
&amp;nbsp; &amp;nbsp; variableHead.setCleanSession((connectFlags &amp;gt;&amp;gt; 1) &amp;amp; 0x01); // Bit 1 (Clean Session)
&amp;nbsp; &amp;nbsp; int willFlag = (connectFlags &amp;gt;&amp;gt; 2) &amp;amp; 0x01; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Bit 2 (Will Flag)
&amp;nbsp; &amp;nbsp; variableHead.setWillFlag(willFlag);
&amp;nbsp; &amp;nbsp; variableHead.setWillQos((connectFlags &amp;gt;&amp;gt; 3) &amp;amp; 0x03); &amp;nbsp; &amp;nbsp; // Bits 3-4 (Will QoS: 0, 1, 2)
&amp;nbsp; &amp;nbsp; variableHead.setWillRetain((connectFlags &amp;gt;&amp;gt; 5) &amp;amp; 0x01); &amp;nbsp;// Bit 5 (Will Retain)
&amp;nbsp; &amp;nbsp; variableHead.setPasswordFlag(((connectFlags &amp;gt;&amp;gt; 6) &amp;amp; 0x01) &amp;gt; 0); // Bit 6 (Password Flag)
&amp;nbsp; &amp;nbsp; variableHead.setUsernameFlag(((connectFlags &amp;gt;&amp;gt; 7) &amp;amp; 0x01) &amp;gt; 0); // Bit 7 (Username Flag)

&amp;nbsp; &amp;nbsp; // 4. 保活时间 (Keep Alive Timer - 秒)
&amp;nbsp; &amp;nbsp; short keepAlive = buf.readShort();
&amp;nbsp; &amp;nbsp; variableHead.setKeepAlive(keepAlive);

&amp;nbsp; &amp;nbsp; log.debug("解析【CONNECT】可变头: 协议名=[{}], 版本=[{}], CleanSession=[{}], "
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; + "WillFlag=[{}], WillQos=[{}], WillRetain=[{}], 用户名标志=[{}], 密码标志=[{}], KeepAlive=[{}]",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; protocolName, protocolVersion, variableHead.getCleanSession(),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; willFlag, variableHead.getWillQos(), variableHead.getWillRetain(),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; variableHead.isUsernameFlag(), variableHead.isPasswordFlag(), keepAlive);
&amp;nbsp; &amp;nbsp; return variableHead;
}

// 解码载荷 (内容由可变头中的标志位决定)
TlMqttConnectPayload decodePayload(ByteBuf buf, TlMqttConnectVariableHead variableHead) {
&amp;nbsp; &amp;nbsp; TlMqttConnectPayload payload = new TlMqttConnectPayload();

&amp;nbsp; &amp;nbsp; // 1. Client Identifier (必选)
&amp;nbsp; &amp;nbsp; int clientIdLen = buf.readUnsignedShort();
&amp;nbsp; &amp;nbsp; byte[] clientIdBytes = new byte[clientIdLen];
&amp;nbsp; &amp;nbsp; buf.readBytes(clientIdBytes);
&amp;nbsp; &amp;nbsp; payload.setClientId(new String(clientIdBytes, StandardCharsets.UTF_8));

&amp;nbsp; &amp;nbsp; // 2. Will Topic &amp;amp; Will Message (如果 Will Flag = 1)
&amp;nbsp; &amp;nbsp; if (variableHead.getWillFlag() == 1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int willTopicLen = buf.readUnsignedShort();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte[] willTopicBytes = new byte[willTopicLen];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buf.readBytes(willTopicBytes);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.setWillTopic(new String(willTopicBytes, StandardCharsets.UTF_8));

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int willMessageLen = buf.readUnsignedShort();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte[] willMessageBytes = new byte[willMessageLen];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buf.readBytes(willMessageBytes);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.setWillMessage(new String(willMessageBytes, StandardCharsets.UTF_8));
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; // 3. Username (如果 Username Flag = true)
&amp;nbsp; &amp;nbsp; if (variableHead.isUsernameFlag()) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int usernameLen = buf.readUnsignedShort();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte[] usernameBytes = new byte[usernameLen];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buf.readBytes(usernameBytes);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.setUsername(new String(usernameBytes, StandardCharsets.UTF_8));
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; // 4. Password (如果 Password Flag = true)
&amp;nbsp; &amp;nbsp; if (variableHead.isPasswordFlag()) { // 使用 VariableHead 中的标志位判断
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int passwordLen = buf.readUnsignedShort();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte[] passwordBytes = new byte[passwordLen];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buf.readBytes(passwordBytes);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.setPassword(new String(passwordBytes, StandardCharsets.UTF_8));
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp; log.debug("解析【CONNECT】载荷: clientId=[{}], willFlag=[{}], willQos=[{}], willTopic=[{}], username=[{}]",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.getClientId(), variableHead.getWillFlag(), variableHead.getWillQos(),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; payload.getWillTopic(), payload.getUsername());
&amp;nbsp; &amp;nbsp; return payload;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其他 &lt;code&gt;MQTT&lt;/code&gt;报文类型（ &lt;code&gt;PUBLISH&lt;/code&gt;, &amp;nbsp;&lt;code&gt;SUBSCRIBE&lt;/code&gt;, &amp;nbsp;&lt;code&gt;PUBACK&lt;/code&gt;等）的解码逻辑遵循类似模式，具体实现可参考对应的解码器类。&lt;/p&gt; 
&lt;p&gt;解码完成后，会得到一个具体的请求对象（如 &amp;nbsp;&lt;code&gt;TlMqttConnectReq&lt;/code&gt;）。该对象随后会被传递给专门处理该类型消息的 &lt;code&gt;ChannelInboundHandler&lt;/code&gt;，例如 &amp;nbsp;&lt;code&gt;TlMqttConnectHandler&lt;/code&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;public class TlMqttConnectHandler extends SimpleChannelInboundHandler&amp;lt;TlMqttConnectReq&amp;gt; {
&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; protected void channelRead0(ChannelHandlerContext ctx, TlMqttConnectReq req) throws Exception {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 在此处实现 CONNECT 请求的核心业务逻辑：
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 1. 认证 (用户名/密码校验)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 2. 会话管理 (新建或复用会话)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 3. 遗嘱消息处理
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 4. 构建并发送 CONNACK 响应
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;编码器实现：从对象到网络字节流&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;tlmqtt&lt;/strong&gt; 的编码器负责将业务逻辑中需要发送给客户端的消息对象（如 &amp;nbsp;&lt;code&gt;TlMqttConnack&lt;/code&gt;, &amp;nbsp;&lt;code&gt;TlMqttPublish&lt;/code&gt;等）序列化为符合 &lt;code&gt;MQTT&lt;/code&gt;协议规范的二进制数据。开发者只需操作这些对象即可：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;// 业务逻辑中创建 CONNACK 响应对象
TlMqttConnack connack = TlMqttConnack.build(cleanSessionPresent, MqttConnectReturnCode.CONNECTION_ACCEPTED);
// 通过通道管理器发送
channelManager.writeAndFlush(clientId, connack);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;编码器（继承 &amp;nbsp;&lt;code&gt;Netty&lt;/code&gt;的 &amp;nbsp;&lt;code&gt;MessageToByteEncoder&lt;/code&gt;）则透明地处理对象到字节流的转换。 以 &lt;code&gt;CONNACK&lt;/code&gt;报文编码 ( &lt;code&gt;TlMqttConnackEncoder&lt;/code&gt;) 为例：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;@ChannelHandler.Sharable // 标记为可共享，通常无状态
@Slf4j // 日志注解
public class TlMqttConnackEncoder extends MessageToByteEncoder&amp;lt;TlMqttConnack&amp;gt; {

&amp;nbsp; &amp;nbsp; @Override
&amp;nbsp; &amp;nbsp; protected void encode(ChannelHandlerContext ctx, TlMqttConnack connack, ByteBuf out) throws Exception {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TlMqttFixedHead fixedHead = connack.getFixedHead();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TlMqttConnackVariableHead variableHead = connack.getVariableHead();

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 1. 固定头编码
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; byte fixedHeaderByte = (byte) (fixedHead.getMessageType().value() &amp;lt;&amp;lt; 4); // 消息类型 (高 4 位) + 保留位 (低 4 位=0)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.writeByte(fixedHeaderByte);

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 2. 剩余长度编码 (CONNACK 固定为 2 字节)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.writeByte(2); // Remaining Length = 2

&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 3. 可变头编码
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.writeByte(variableHead.getSessionPresent()); // Byte 1: Session Present Flag (0 或 1)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; out.writeByte(variableHead.getConnectReturnCode().getValue()); // Byte 2: Connect Return Code
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;贡献与反馈&lt;/h2&gt; 
&lt;p&gt;欢迎通过以下方式参与项目共建：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;提交 Issue：反馈 Bug 或提出功能建议&lt;/li&gt; 
 &lt;li&gt;提交 PR：优化代码或新增功能（建议先创建 Issue 沟通方案）&lt;/li&gt; 
 &lt;li&gt;Star/Fork：支持项目持续发展&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h3&gt;联系方式：&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;邮箱：2534798858@qq.com&lt;/li&gt; 
 &lt;li&gt;项目地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FZHSQJM%2Ftlmqtt%23" target="_blank"&gt;https://github.com/ZHSQJM/tlmqtt&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;项目地址：&lt;a href="https://gitee.com/PiQiHenHaoDeGangTieXia/tlmqtt"&gt;https://gitee.com/PiQiHenHaoDeGangTieXia/tlmqtt&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;tlmqtt 致力于为物联网开发者提供轻量、高效的 MQTT 消息服务，期待您的加入！ 🚀&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353356</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353356</guid>
      <pubDate>Sat, 10 May 2025 09:59:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>三星计划投资 Perplexity AI，将其搜索技术深度整合至 Galaxy 设备</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-06-01%2Fsamsung-nears-wide-ranging-deal-with-perplexity-for-ai-features" target="_blank"&gt;彭博社报道称&lt;/a&gt;&lt;/u&gt;，三星电子即将达成一项涉及面广泛的协议，其将投资 Perplexity AI Inc.，并将这家人工智能初创公司的搜索技术置于其设备的核心位置。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0603/161937_vxgK_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据知情人士透露，两家公司正在洽谈在即将推出的三星设备上预装 Perplexity 的应用程序和助手，并将 Perplexity 的搜索功能集成到三星网络浏览器中。&lt;/p&gt; 
&lt;p&gt;由于谈判是私下进行的，这些知情人士不愿透露姓名。知情人士表示，两家公司还讨论了将 Perplexity 的技术融入三星的 Bixby 虚拟助手。&lt;/p&gt; 
&lt;p&gt;三星计划最早在今年宣布与 Perplexity 的集成，目标是将该服务作为 Galaxy S26 系列手机的默认助手选项，该系列手机将于 2026 年上半年推出。不过，具体细节尚未最终确定，仍有可能发生变化。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4ce528b30fdd0be47815eec1cbf00ac3ba5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;知情人士表示，这家科技巨头预计还将是 Perplexity 新一轮融资的最大投资者之一。据彭博社报道，这家初创公司正就融资 5 亿美元、估值 140 亿美元进行深入洽谈。&lt;/p&gt; 
&lt;p&gt;此次广泛的合作可能有助于三星减少对谷歌的依赖，并为其与多家人工智能开发商合作铺平道路，类似于苹果公司针对其设备和服务的战略。对于 Perplexity 而言，此次合作将是其迄今为止最大的移动合作伙伴关系，此前该公司最近与摩托罗拉达成了一项整合协议。&lt;/p&gt; 
&lt;p&gt;三星和 Perplexity 的代表均拒绝置评。&lt;/p&gt; 
&lt;p&gt;据彭博社 4 月报道，两家公司已于今年早些时候就合作展开洽谈。知情人士称，最近几周，双方在韩国会面，最终达成协议。&lt;/p&gt; 
&lt;p&gt;知情人士称，三星和 Perplexity 还讨论了构建一个融合人工智能的操作系统和一款人工智能代理应用程序，这些应用程序可以利用 Perplexity 和其他一系列人工智能助手的功能。&lt;/p&gt; 
&lt;p&gt;苹果也表现出了与 Perplexity 合作的兴趣。据彭博社报道，这家 iPhone 制造商已讨论使用 Perplexity 作为 Google 搜索的替代品，以及替代 Siri 语音助手中 ChatGPT 集成的功能。&lt;/p&gt; 
&lt;p&gt;「我们对 Perplexity 的表现印象深刻，因此我们已开始与他们讨论他们的工作」，苹果服务高级副总裁 Eddy Cue 在最近一次 Google 反垄断审判的证词中表示。&lt;/p&gt; 
&lt;p&gt;目前尚不清楚 Perplexity 与苹果最强劲竞争对手之一三星的关系将如何影响 Perplexity 的这一举措。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/353340</link>
      <guid isPermaLink="false">https://www.oschina.net/news/353340</guid>
      <pubDate>Sat, 10 May 2025 08:21:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
