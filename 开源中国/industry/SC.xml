<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 17 Jun 2025 12:42:44 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Mozilla Firefox 新增了固定和取消固定标签页的方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Mozilla Firefox 最近推出了一项备受期待的功能：垂直标签页。该功能于 2025 年 3 月作为 Firefox 136 更新的一部分推出。&lt;/p&gt; 
&lt;p&gt;现在，Mozilla 在其浏览器中推出了另一项备受欢迎的标签页管理改进，使用户能够更轻松地在 Firefox 中固定和取消固定标签页。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-93cb835b446a292e28f4b205592bd446ffe.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在最新的 Firefox Nightly 更新中，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1944907" target="_blank"&gt;Mozilla 引入了&lt;/a&gt;一种全新的标签页固定或取消固定方式：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;您只需将当前页面拖拽至另一个已固定的标签页即可将其固定，或将其拖拽出即可取消固定&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;就这么简单。新的逻辑适用于垂直和水平标签页视图，并且无需使用上下文菜单。唯一的前提条件是，您需要至少有一个已固定的标签页才能使用拖动功能。否则，您只能将标签页移动到标签页的任意位置。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/190024_Z6WI_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;很高兴看到 Firefox 为用户实现了这项小小的便利。然而，一些人认为它仍有改进空间。拖动标签页固然很酷，但专门的快捷方式或许能更好、更快捷地固定或取消固定标签页。不过，其他主流浏览器也缺乏这项功能。&lt;/p&gt; 
&lt;p&gt;改进的标签页固定功能现已在 Firefox Nightly 中推出，这是最不稳定的更新渠道。Mozilla 使用它来测试早期更改和重大平台变更，这些变更可能存在错误、不稳定或破坏功能。&lt;/p&gt; 
&lt;p&gt;因此，将 Nightly 版本作为您的主浏览器可能不是一个好主意。不过，您可以同时运行 Firefox Nightly 和其他渠道进行测试。如果您感兴趣，可以通过此链接从官方网站获取。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355850</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355850</guid>
      <pubDate>Sun, 11 May 2025 11:00:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 与美国国防部签署 2 亿美元合同</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 宣布与美国国防部达成了一项重磅合作，获得了一份价值 2 亿美元的为期一年的合同。这项合同旨在为国防部开发先进的人工智能工具，帮助应对一系列国家安全挑战。五角大楼在声明中指出，这项工作将主要在华盛顿及其周边地区进行，预计将于 2026 年 7 月完成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这是 OpenAI&lt;span&gt;首次&lt;/span&gt;与美国国防部签署合同，标志着其在国家安全领域的深入布局。随着全球安全形势的不断变化，人工智能技术在军事和安全领域的应用愈发重要。五角大楼表示，OpenAI 将致力于开发前沿的 AI 原型，以应对作战和企业领域的关键挑战。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bd93bf619f02cc812ac5e03db9d4a666430.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得一提的是，初创公司 Anduril 去年底也获得了一项 1 亿美元的国防合同，而 OpenAI 的竞争对手 Anthropic 则在与 Palantir 和亚马逊合作，提供其 AI 模型给美国的国防和情报机构。此外，OpenAI 去年曾与 Anduril 合作，专注于提升反无人机系统的能力，以应对空中威胁。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 的联合创始人兼首席执行官 Sam Altman 在一次关于 AI 与国家安全的峰会上表示，他们希望能够积极参与国家安全领域的发展。尽管这次合同金额不算庞大，但在 OpenAI 年化收入已经飙升至 100 亿美元的背景下，这项合作仍然意义深远。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年 3 月，OpenAI 还宣布了新一轮融资计划，软银集团领投，融资额预计达到 400 亿美元，投后估值将达 3000 亿美元。而截至 3 月底，OpenAI 的每周活跃用户数已达到 5 亿。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355848</guid>
      <pubDate>Sun, 11 May 2025 10:16:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>SCALE 正式开源：一个面向专业级任务的大语言模型 SQL 能力评测框架</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;随着大语言模型（LLM）在数据科学领域的应用日益广泛，学术界和工业界涌现出多种评测基准。然而，我们观察到，现有评测体系大多聚焦于&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Text-to-SQL&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的转换准确率，而这远不能全面反映模型在真实、复杂场景下的 SQL 处理能力。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;为了弥补这一关键空白，我们经过深入研究，提出了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE ------ 一个面向专业级任务的大语言模型 SQL 能力开源评测框架&lt;/strong&gt;。我们致力于通过开放、透明和社区驱动的方式，建立一个行业公认的评估标准。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="https://sql-llm-leaderboard.com/" src="https://oscimg.oschina.net/oscnet/up-d8de9745f7ddaa54f1659f6175dcbe78d5b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;背景：现有 LLM-SQL 评测的局限性&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;近年来，大语言模型处理结构化查询语言（SQL）的能力取得了长足进步。一系列公开的评测基准（Benchmark）也应运而生，它们在很大程度上推动了模型在 Text-to-SQL 任务上的发展。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;尽管如此，我们发现现有的评测体系仍存在显著的局限性。在专业的数据库管理和软件开发实践中，开发者面临的挑战远比 "将一句话转为 SQL" 要复杂得多：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;性能是生命线&lt;/strong&gt;：一个能返回正确结果但执行耗时数分钟的查询，在生产环境中是不可接受的。现有评测很少关注模型生成 SQL 的性能和效率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;环境是多样的&lt;/strong&gt;：数据库迁移和跨平台适配是常见需求。但模型能否精准处理不同数据库（如 MySQL，Oracle，PostgreSQL）之间的 "方言" 差异，现有评测也鲜有涉及。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;理解是深度的&lt;/strong&gt;：维护、审查和重构遗留代码是开发者的日常。这要求模型不仅能 "写" 代码，更能深度 "理解" 代码的逻辑、意图和潜在风险。这一点同样是当前评测的薄弱环节。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;现有评测的单一视角，使得开发者和决策者在面对真实、复杂的业务需求时，难以选择出真正合适的模型。&lt;/p&gt; 
&lt;h2&gt;我们的解决方案：SCALE 评测框架&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;为了系统性地解决上述问题，我们设计并实现了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(SQL Capability Leaderboard for LLMs)&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;大模型 SQL 能力排行榜&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;并非对现有评测的简单复现，而是一个从数据库专家和资深开发者真实工作流出发，构建的全新、完全开源的评测框架。我们相信，只有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;开放源代码、开放数据、开放方法&lt;/strong&gt;，才能建立最广泛的行业信任。&lt;/p&gt; 
&lt;h2&gt;评测基石：一个高质量、多层次的数据集&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;一个评测框架的公信力，源于其评测数据的质量与广度。为此，我们构建了一个高质量、多层次、贴近真实世界的数据集，并将其向社区完全开放。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;真实世界案例&lt;/strong&gt;：我们收集并脱敏了来自不同行业的真实查询案例。这些案例作为数据集的基础，确保了评测内容与生产环境的实际挑战保持一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;AI 辅助的典型场景构造&lt;/strong&gt;：为提升测试集的覆盖深度，我们针对容易引发逻辑错误或性能问题的复杂场景，如子查询、多表连接、嵌套查询、存储过程等，利用 AI 辅助构造了大量细粒度的测试用例，旨在精准评估模型在处理复杂查询时的逻辑稳健性与准确性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;评分权重设计&lt;/strong&gt;：为区分不同任务的复杂度，我们为测试用例设置了不同的评分权重。通常，技术复杂度更高的用例会获得更高的权重。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;答案验证&lt;/strong&gt;：所有测试用例的参考答案均经过交叉验证，以确保其准确性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三大核心评测维度&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;基于这一强大的数据集，SCALE 通过三个相互独立的核心维度，深入考察模型在处理高价值、高复杂度 SQL 任务时的真实水平。&lt;/p&gt; 
&lt;h3&gt;⚡ SQL 优化能力 (SQL Optimization)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究问题&lt;/strong&gt;：模型是否具备数据库专家（DBA）的性能优化意识？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;评估方法&lt;/strong&gt;：我们为模型提供一系列典型的低性能查询，评估其能否在保证逻辑等价的前提下，改写出性能更优的版本。评测指标不仅包含语法正确性，更引入了对优化规则复杂度的量化评估，以衡量其优化策略的优劣。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：当您需要进行数据库性能调优或代码重构时，此维度的评测结果将为您提供关键参考。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;🔄 方言转换能力 (Dialect Conversion)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究问题&lt;/strong&gt;：模型能否成为一个可靠的、跨数据库平台的 "代码翻译官"？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;评估方法&lt;/strong&gt;：我们评估模型在多种主流数据库 "方言" 之间进行转换的逻辑保真度与语法准确性，确保其转换结果是 "开箱即用" 且完全可靠的。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：对于面临数据库迁移、构建跨平台数据中台等挑战的团队，此维度的领先模型是首选。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;📊 SQL 理解能力 (SQL Understanding)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究问题&lt;/strong&gt;： 除了写代码，模型对 SQL 的理解有多深？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;评估方法&lt;/strong&gt;： 我们从执行结果准确性、语法错误识别、执行计划分析、查询类型判断等多个角度，全面考察模型对 SQL 代码的深度分析能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;应用场景&lt;/strong&gt;： 在进行代码审查（Code Review）、遗留系统维护、自动化代码分析等工作中，此维度的评测结果能帮您找到最 "懂"SQL 的 AI 助手。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;SCALE 的价值与应用&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我们相信，一个严谨、贴近实践的评测框架，能为不同角色的专业人士创造价值：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;对于数据与软件开发人员&lt;/strong&gt;：提升开发效率，保障交付质量。SCALE 能帮您快速找到最称手的 AI 工具，处理优化、迁移、代码审查等专业任务，将宝贵的精力聚焦于更有创造性的工作上。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;对于 AI 研究员与模型开发者&lt;/strong&gt;：精准定位座标，指明迭代方向。SCALE 透明的评测方法和开源的数据集，能清晰揭示您模型在专业 SQL 任务上的长处与短板，为下一阶段的优化和训练提供明确的、可量化的目标。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;对于企业 CTO 与技术决策者&lt;/strong&gt;：降低技术风险，驱动业务创新。基于 SCALE 客观、中立的数据做出技术选型，能确保您为企业引入的 AI 能力是真正可靠、高效的，从而赋能团队，构建更健壮的数据基础设施。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;结论与展望&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我们推出 SCALE，旨在为社区提供一个更专业、更深入、更贴近真实需求的 LLM SQL 能力评估标准。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;作为一个开源项目，我们深知社区的力量是其生命力的源泉&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;。 我们不仅发布评测结果，更开放所有评测脚本、数据集和方法论。我们诚挚地邀请您探索 SCALE 的评测结果，利用这一工具为您的研究和工作做出更精准的技术判断。更重要的是，我们欢迎您&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;加入我们的社区&lt;/strong&gt;，贡献代码、提交测试用例或提出宝贵建议。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;让我们一同完善 SCALE 的评测体系，共同推动大语言模型在数据库领域的应用走向新的深度。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;探索 SCALE 实时排行榜 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsql-llm-leaderboard.com%2F" target="_blank"&gt;https://sql-llm-leaderboard.com/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;了解评测方法与技术细节 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Factiontech%2Fsql-llm-benchmark" target="_blank"&gt;https://github.com/actiontech/sql-llm-benchmark&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;SCALE：为专业 SQL 任务，选专业 AI 模型。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;更多技术文章，请访问：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.actionsky.com%2F" target="_blank"&gt;https://opensource.actionsky.com/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355838</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355838</guid>
      <pubDate>Sun, 11 May 2025 09:32:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>GC-QA-RAG —— 检索增强生成系统</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;GC-QA-RAG 是一款面向葡萄城产品生态（包括&lt;a href="https://www.grapecity.com.cn/solutions/huozige"&gt; 活字格&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/solutions/wyn"&gt;WYN&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/developer/spreadjs"&gt;SpreadJS &lt;/a&gt;和 &lt;a href="https://www.grapecity.com.cn/developer/grapecitydocuments/excel-java"&gt;GCExcel&lt;/a&gt; 等）的检索增强生成（RAG）系统。该系统通过智能文档处理、高效知识检索、精准问答等功能，有效提升了知识管理效率和用户支持体验。&lt;/p&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本系统创新性地采用了 QA 预生成技术，克服了传统文本切片方法在知识库构建中的若干局限性。经过实践验证，该技术方案能够显著提升检索效果，可为 RAG 领域的技术实践提供新的思路。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于初学者，我们提供了详细的入门指南，帮助您快速掌握 QA-RAG 系统的构建方法&lt;/li&gt;
&lt;li&gt;对于面临传统架构挑战的开发者，我们的架构设计文档可为您提供参考，助力现有知识库的优化升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本项目也分享了葡萄城在 RAG 知识库产品设计方面的实践经验，希望能为相关领域的产品和技术探索提供有益参考。&lt;/p&gt;

&lt;p&gt;&lt;img height="356" src="https://oscimg.oschina.net/oscnet/up-322e0ef8752e9e5c72130b47ce44ff2d09a.png" width="802" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/gc-qa-rag</link>
      <guid isPermaLink="false">https://www.oschina.net/p/gc-qa-rag</guid>
      <pubDate>Sun, 11 May 2025 09:26:00 GMT</pubDate>
    </item>
    <item>
      <title>静态类型函数式编程语言 —— Darklang 宣布开源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Dark Inc 成立于 2017 年，专注于开发一种名为 Darklang 的静态类型函数式编程语言，为云原生应用开发而生，支持构建复杂应用系统，旨在简化后端编码。&lt;/p&gt; 
&lt;p&gt;然而，公司发展并不顺利，最终资金耗尽。为了确保用户和粉丝能够继续使用 Darklang，以及继续发展这一重要技术，Dark Inc 决定将其资产，包括 Darklang 语言、博客、托管服务、Discord 等，&lt;strong&gt;出售给由前员工创立的新公司 Darklang Inc&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/154855_nfp3_2720166.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Darklang 新公司创始人 Stachu Korick 宣布该项目现已开源，下文是官方开源公告的翻译：&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;作为 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fgoodbye-dark-inc-welcome-darklang-inc%2F" target="_blank"&gt;关闭 Dark Inc.&lt;/a&gt; 和 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Ffirst-steps-of-darklang-inc%2F" target="_blank"&gt;成立 Darklang Inc.&lt;/a&gt; 的一部分，我们终于开源了所有仓库。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdarklang%3Fref%3Dblog.darklang.com" target="_blank"&gt;我们的源代码&lt;/a&gt; 现在已采用 Apache License 2.0。&lt;/p&gt; 
&lt;p&gt;多年来，我们一直在思考可持续性问题以及如何构建真正赋能开发者的工具。我们一直从哲学上支持开源，但认为 Darklang 的独特架构和商业模式需要不同的方法。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;为何我们最初选择源代码可用 (&lt;/strong&gt;Source-Available&lt;strong&gt;)&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我们最初设计 Darklang 为一个仅托管的平台，您在 &lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdarklang.com" target="_blank"&gt;darklang.com&lt;/a&gt; 编写代码，程序会立即在生产环境中上线。我们认为这种集中的方式对于安全的代码迁移和统一部署等特性是必要的，而提供自托管选项会损害我们的可持续性模式。&lt;/p&gt; 
&lt;p&gt;核心挑战是构建有价值的东西，同时确保能够长期持续开发。传统的开源资金模式都有局限性，因此 Darklang 被设计为「一种具有商业模式的语言」——那些有大量工作负载的用户将通过我们的托管平台资助生态系统的发展。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;是什么改变了我们的思考&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;有三个关键转变改变了我们的观点：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;产品成熟度和用户反馈&lt;/strong&gt;：Darklang 采用的真正障碍从来不是许可问题，而是产品成熟度。随着我们越来越接近构建人们喜爱的东西，保持源码可用性开始感觉像不必要的风险。我们一直听到人们希望我们更加开放。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;面向本地优先开发&lt;/strong&gt;：我们的技术方向发生了显著变化。我们现在正在构建 Darklang，使其作为 CLI 在本地运行，并能够部署到我们的云或其他地方。没有人希望在自己的机器上运行专有语言的二进制文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;新的商业机会&lt;/strong&gt;：自 2017 年以来，开发工具市场已经成熟。我们现在看到成功的公司对团队协作功能和 AI 驱动的工具进行收费，同时保持核心平台的可访问性。这些功能创造了团队愿意支付的附加值，同时始终保留自行托管的选项。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;为何开源&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;开源使 Darklang 具备可访问性、可检查性和社区所有。这与我们普及编程的哲学一致，并确保平台无论哪家公司命运如何都能持续发展和演变。&lt;/p&gt; 
&lt;p&gt;我们已经学会在不依赖我们特定编辑器或托管环境的情况下，提供 Darklang 的关键优势——无形的基础设施、无部署部署、基于追踪的开发。这使开源成为可能，同时保留了 Darklang 的独特之处。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;开放性问题&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我们仍在探索 Darklang 生态系统中关于许可的一些有趣技术挑战。GitHub 通过附加 LICENSE.md 文件来处理这个问题，但在一个包管理器可以直接同步类型和函数的世界里，有一些值得深入思考的有趣挑战。核心平台是开源的，这为我们提供了一个坚实的基础来构建。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;原文：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fdarklang-goes-open-source%2F" target="_blank"&gt;https://blog.darklang.com/darklang-goes-open-source/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355813/darklang-goes-open-source</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355813/darklang-goes-open-source</guid>
      <pubDate>Sun, 11 May 2025 07:49:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>工作中对 InheritableThreadLocal 使用的思考</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;代码评审时，发现在线程池中使用 InheritableThreadLocal 上下文会使其中的线程变量失效，无法获取到预期的变量值，所以对问题进行了覆盘和总结。&lt;/p&gt; 
  &lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
  &lt;h2&gt;1. 先说结论&lt;/h2&gt; 
  &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 只有在父线程&lt;strong&gt;创建&lt;/strong&gt;子线程时，在子线程中才能获取到父线程中的线程变量；当配合线程池使用时：&lt;strong&gt;「第一次在线程池中开启线程，能在子线程中获取到父线程的线程变量，而当该子线程开启之后，发生线程复用，该子线程仍然保留的是之前开启它的父线程的线程变量，而无法获取当前父线程中新的线程变量」&lt;/strong&gt;，所以会发生获取线程变量错误的情况。&lt;/p&gt; 
  &lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
  &lt;h2&gt;2. 实验例子&lt;/h2&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;创建一个线程数固定为 1 的线程池，先在 main 线程中存入&lt;code&gt;变量 1&lt;/code&gt;，并使用线程池开启新的线程打印输出线程变量，之后更改 main 线程的线程变量为&lt;code&gt;变量 2&lt;/code&gt;，再使用线程池中线程（发生线程复用）打印输出线程变量，对比两次输出的值是否不同&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * 测试线程池下 InheritableThreadLocal 线程变量失效的场景
 */&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的线程池，保证线程复用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 线程，变量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 线程，变量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 线程，变量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 线程复用再取还是 main 线程，变量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;输出结果:&lt;/p&gt; 
   &lt;br&gt; main 线程，变量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;br&gt; main 线程，变量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;发现两次输出结果值相同，证明发生线程复用时，&lt;strong&gt;子线程获取父线程变量失效&lt;/strong&gt;&lt;/p&gt; 
  &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
  &lt;h2&gt;3. 详解&lt;/h2&gt; 
  &lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.1 JavaDoc&lt;/h3&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. Normally the child's values will be identical to the parent's; however, the child's value can be made an arbitrary function of the parent's by overriding the childValue method in this class.&lt;br&gt; Inheritable thread-local variables are used in preference to ordinary thread-local variables when the per-thread-attribute being maintained in the variable (e.g., User ID, Transaction ID) must be automatically transmitted to any child threads that are created.&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 继承了 &lt;code&gt;ThreadLocal&lt;/code&gt;, 以能够让子线程能够从父线程中继承线程变量: 当一个子线程&lt;code&gt;被创建&lt;/code&gt;时，它会接收到父线程中所有可继承的变量。通常情况下，子线程和父线程中的线程变量是完全相同的，但是可以通过重写 &lt;code&gt;childValue&lt;/code&gt; 方法来使父子线程中的值不同。&lt;/p&gt; 
   &lt;br&gt; 当线程中维护的变量如 UserId, TransactionId 等必须自动传递到 
   &lt;strong&gt;新创建的任何子线程&lt;/strong&gt;时，使用 
   &lt;code&gt;InheritableThreadLocal&lt;/code&gt;要优于 
   &lt;code&gt;ThreadLocal&lt;/code&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.2 源码&lt;/h3&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;/**
     * 当子线程被创建时，通过该方法来初始化子线程中线程变量的值，
     * 这个方法在父线程中被调用，并且在子线程开启之前。
     * 
     * 通过重写这个方法可以改变从父线程中继承过来的值。
     *
     * @param parentValue the parent thread's value
     * @return the child thread's initial value
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; &lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T&lt;/span&gt; parentValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; parentValue&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;,&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;其中&lt;code&gt;childValue&lt;/code&gt;方法来获取父线程中的线程变量的值，也可通过重写这个方法来将获取到的线程变量的值进行修改。&lt;/p&gt; 
  &lt;p&gt;在&lt;code&gt;getMap&lt;/code&gt;方法和&lt;code&gt;createMap&lt;/code&gt;方法中，可以发现&lt;code&gt;inheritableThreadLocals&lt;/code&gt;变量，它是 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，在&lt;code&gt;Thread 类&lt;/code&gt;中&lt;/p&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//8a5c46d2c14c4bd1ce6d1e980efe3e77.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;3.2.1 childValue 方法&lt;/h4&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;开启新线程时，会调用 Thread 的构造方法&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;沿着构造方法向下，找到&lt;code&gt;init&lt;/code&gt;方法的最终实现，其中有如下逻辑：&lt;strong&gt;为当前线程创建线程变量以继承父线程中的线程变量&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * @param inheritThreadLocals 为 ture，代表是为，包含可继承的线程变量，的线程进行初始化
 */&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; g&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; target&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;long&lt;/span&gt; stackSize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AccessControlContext&lt;/span&gt; acc&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;boolean&lt;/span&gt; inheritThreadLocals&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
  
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;inheritThreadLocals &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;// 注意这里创建子线程的线程变量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt;
            &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createInheritedMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;&lt;code&gt;ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)&lt;/code&gt;创建子线程 &lt;code&gt;InheritedMap&lt;/code&gt; 的具体实现&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p&gt;&lt;code&gt;createInheritedMap&lt;/code&gt; 方法，最终会调用到 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的&lt;strong&gt;私有构造方法&lt;/strong&gt;，传入的参数 parentMap 即为&lt;strong&gt;父线程中保存的线程变量&lt;/strong&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocalMap&lt;/span&gt; parentMap&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; parentTable &lt;span&gt;=&lt;/span&gt; parentMap&lt;span&gt;.&lt;/span&gt;table&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; len &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        table &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;len&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; j &lt;span&gt;&amp;lt;&lt;/span&gt; len&lt;span&gt;;&lt;/span&gt; j&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Entry&lt;/span&gt; e &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;[&lt;/span&gt;j&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 注意！！！ 这里调用了 childValue 方法&lt;/span&gt;
                    &lt;span&gt;Object&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;&lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;Entry&lt;/span&gt; c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;threadLocalHashCode &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;len &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        h &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;h&lt;span&gt;,&lt;/span&gt; len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; c&lt;span&gt;;&lt;/span&gt;
                    size&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;这个方法会对父线程中的线程变量做&lt;strong&gt;拷贝&lt;/strong&gt;，其中调用了&lt;code&gt;childValue&lt;/code&gt;方法来获取/初始化子线程中的值，并保存到子线程中&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;由上可见，可继承的线程变量&lt;strong&gt;只是&lt;/strong&gt;在线程&lt;strong&gt;被创建的时候&lt;/strong&gt;进行了初始化工作，这也就能解释为什么在线程池中发生线程复用时不能获取到父线程线程变量的原因&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
  &lt;h2&gt;4. 实验例子流程图&lt;/h2&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//13978e8555584a0539f17ca79e19b1f5.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;main 线程&lt;code&gt;set main 线程，变量 1&lt;/code&gt;时，会调用到&lt;code&gt;InheritableThreadLocal&lt;/code&gt;的 &lt;code&gt;createMap&lt;/code&gt;方法，创建 &lt;code&gt;inheritableThreadLocals&lt;/code&gt; 并保存线程变量&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;开启子线程 1 时，会拷贝父线程中的线程变量到子线程中，如图示&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;main 线程&lt;code&gt;set main 线程，变量 2&lt;/code&gt;，会覆盖主线程中之前 set 的 mian 线程变量 1&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;最后发生线程复用，子线程 1 无法获取到 main 线程新 set 的值，仍然打印 main 线程，变量 1&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
  &lt;h2&gt;5. 解决方案: TransmittableThreadLocal&lt;/h2&gt; 
  &lt;p&gt;使用阿里巴巴 &lt;code&gt;TransmittableThreadLocal&lt;/code&gt; 能解决&lt;strong&gt;线程变量线程封闭&lt;/strong&gt;的问题，测试用例如下，在线程池提交任务时调用&lt;code&gt;TtlRunnable&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法来完成线程变量传递&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的线程池，保证线程复用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 线程，变量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 线程，变量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 线程，变量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 使用 TransmittableThreadLocal 解决问题&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TtlRunnable&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;输出结果:&lt;br&gt; main 线程，变量 1&lt;br&gt; main 线程，变量 2&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;注意：对象类型需要注意线程安全问题&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;具体用法参考 https://github.com/alibaba/transmittable-thread-local&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;hr&gt; 
  &lt;p&gt;&lt;strong&gt;That's all.&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18626652</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18626652</guid>
      <pubDate>Sun, 11 May 2025 07:45:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>苹果内置终端应用在 macOS Tahoe 迎来「彩色」视觉设计更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;苹果内置的终端应用在 macOS Tahoe 中得到了视觉上的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macrumors.com%2F2025%2F06%2F16%2Fapples-terminal-app-macos-tahoe%2F" target="_blank"&gt;更新&lt;/a&gt;，这是该命令行工具亮相以来首次显著的设计更新。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6fcee60476e7476c2925193298f46bc5185.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根据苹果在 WWDC25 上的平台现状演示，更新后的终端将支持 24 位色彩和 Powerline 字体。该应用还将采用全新的 Liquid Glass 美学设计，并重新设计主题，以配合 macOS 26 更广泛的视觉改进。&lt;/p&gt; 
&lt;p&gt;虽然终端应用已经提供了各种颜色配置文件，但 macOS 26 版本承诺提供增强的自定义选项，以更具视觉吸引力的方式显示系统信息。&lt;/p&gt; 
&lt;p&gt;这是一个早就应该进行的现代化应用程序，对于开发人员和高级用户来说至关重要，因为它在二十多年来基本保持不变。&lt;/p&gt; 
&lt;p&gt;macOS Tahoe 将于今年秋季推出，开发者测试版现已发布，第一个公开测试版预计将于 7 月发布。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</guid>
      <pubDate>Sun, 11 May 2025 07:24:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>X.Org Server 项目回滚了大量代码</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FX.Org-Server-Lots-Of-Reverts" target="_blank"&gt;据报道&lt;/a&gt;，X.Org Serve 的 Git 代码库近日出现了大量&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F%3Fsort%3Dcreated_date%26state%3Dmerged%26first_page_size%3D20" target="_blank"&gt;回滚操作&lt;/a&gt;，主要目的是回滚有问题的代码。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-52f7b8884d7f58d9a488d0d105f625a75e7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这些代码由一名此前被驱逐的开发者提交，部分与不正确处理版权和许可通知有关，还有部分是新补丁导致功能破坏有关。&lt;/p&gt; 
&lt;p&gt;事件梳理如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;开发者变动&lt;/strong&gt; ：一位开发者被项目组织驱逐后创建分支另立门户（「X11Libre」），其此前提交的大量代码被资深 X.Org 开发人员审查，发现诸多问题，从而引发了一系列代码回滚。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;版权和许可证声明处理不当&lt;/strong&gt; ：原有代码宏被迁移至新文件时，新文件头部删除了既有版权持有者信息，仅保留了新贡献者署名，且代码许可证从 「MIT AND X11」 被擅自更改为 「MIT OR X11」，这导致相关代码被回退。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;功能破坏&lt;/strong&gt; ：此前的 「RandR 清理工作」 导致部分 RandR 功能失效，因此本周合并了针对此的大规模回退 。此外，一些新补丁的添加也可能导致功能破坏，进而引发回滚操作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;对驱动的影响&lt;/strong&gt; ：部分回退是为了避免对 NVIDIA 驱动造成不必要破坏。NVIDIA 方面也表示，后续还将提出更多回退请求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;代码价值及设计意图问题&lt;/strong&gt; ：一些代码的价值存疑，或是开发者在未理解 X.Org 开发者最初添加某些宏的设计意图就贸然修改，从而引发了回退操作。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="486" src="https://static.oschina.net/uploads/space/2025/0617/144634_Ala5_2720166.png" width="1852" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2012" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2012&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="436" src="https://static.oschina.net/uploads/space/2025/0617/144711_8iBz_2720166.png" width="2050" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2017%23note_2956688" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2017#note_2956688&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="354" src="https://static.oschina.net/uploads/space/2025/0617/144742_k5G0_2720166.png" width="1556" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2019" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2019&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</guid>
      <pubDate>Sun, 11 May 2025 06:57:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AMD 新 MI350 搅动 AI 芯片市场，微美全息加快 AI 算力+产业链垂直整合卡位赛道</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;获悉，日前，在圣何塞举行的「Advancing AI」大会上，AMD（AMD.US）发布了下一代人工智能 (AI) 芯片 Instinct MI350 系列，包含 Instinct MI350X 和 MI355X GPU 及平台，代际 AI 计算能力提升 4 倍，代际推理性能跃升 35 倍。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//7763666251c9d02806fc8fc9ac8bd143.png" width="719" referrerpolicy="no-referrer"&gt;
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;strong&gt;&lt;span&gt;新一代 AI 芯片前景广阔&lt;/span&gt;&lt;/strong&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;此外，AMD 展示了端到端开放式机柜级 AI 基础设施，该设施已在 Oracle Cloud Infrastructure（OCI）等超大规模部署中应用，集成 AMD Instinct MI350 系列加速器、第五代 AMD EPYC™处理器和 AMD Pensando™ Pollara 网卡，2025 年下半年将全面上市。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;值得注意的是，该公司还推出了一款名为 Helios 的全服务器机架，搭载 Instinct MI400 系列芯片，最多可在一台服务器中配置 72 颗芯片，预计该芯片系统对云公司和大型语言模型开发商等人工智能客户至关重要。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//d8910d810c68fc04fb3945b0e2317bc4.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;span&gt;&lt;span&gt;苏姿丰称，AMD 展示了全新的开放、可扩展的人工智能基础设施产品，目标是与市场领导者英伟达（NVDA.US）竞争。最新发布的 AI 处理器在性能上可挑战英伟达产品，在价格方面，AMD 的产品远低于英伟达。&lt;/span&gt;&lt;/span&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;今年 2 月，AMD 发布的数据中心业务展望显示其增长速度低于部分分析师预期。AMD 认为，MI 系列的这次更新将重振公司增长势头，预测 AI 芯片市场规模未来三年将超 5000 亿美元，并证明其有实力与体量远大的竞争对手正面交锋。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//a5d5428aeb4d511dbc525631e33349c6.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;strong&gt;&lt;span&gt;AI 芯片博弈混战&lt;/span&gt;&lt;/strong&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;当下，人工智能 ( AI ) 是这个时代重要的命题之一。尤其以 DeepSeek 为代表的大模型的广泛应用, 促进了算力迭代; 在全面铺开的 AI 长卷中, 夯实算力这一基石, 对于企业的数智化转型升级至关重要。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;随着全球范围内的大型科技公司向人工智能基础设施投入数百亿美元，对 AI 芯片的市场需求持续超过供应，推动芯片价格飙升，部分产品甚至高达数万美元一枚。从底层技术的角度, 充分发挥 CPU 的驱动力, 助力千行百业更好赋能 " 人工智能 +", 需要变中求进。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//7eb6d65ed1bd5d72b439e3c2fa01c026.png" width="612" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;strong&gt;&lt;span&gt;微美全息催生 AI 算力+产业链垂直整合&lt;/span&gt;&lt;/strong&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;AI 正在各行各业引爆前所未有的变革，对于企业来说 , 如果选错赛道可能意味着输在起跑线上。资料显示，AI 芯片企业微美全息（WIMI.US）加速 AI 在企业中落地，随着 AI 应用不断走向深入，推动其在 AI 算力芯片生态建设和合作研发，凭借自身的优势，更好助力 AI 产业全球竞争。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;当前，微美全息通过整合芯片-算法-场景技术链，构建覆盖 AI 算力全流程的创新体系，自主研发的高性能 AI 芯片及计算集群支持大规模模型训练和推理，并布局量子信息技术提升算力密度，适配多模态大模型、边缘计算等场景需求，实现毫秒级数据传输效率，芯片产品覆盖 AI 人机交互、智能机器人、无人驾驶等新质生产力升级。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;strong&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/strong&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;实际上，从 Advancing AI 2025 大会上获得信息来看，AMD 将按照既定的人工智能基础设施推进计划, 不断创新和扩展架构, 致力于将新的 GPU 架构整合到完整的 AI 系统中, 为 AI 的深入应用提供源源不断的算力。而在这场没有硝烟的战争中，真正的赢家，终将是那些坚守长期主义、拥抱开放创新的智者。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355801</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355801</guid>
      <pubDate>Sun, 11 May 2025 06:39:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>豆包电脑版与网页版上线「AI 播客」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;豆包电脑版已全量上线 AI 播客功能。该功能已在扣子空间、豆包电脑版上线；豆包 App 也已开启小流量测试，将于近期全量上线。&lt;/p&gt; 
&lt;p&gt;用户只需访问&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxn--doubao-295jx85g4v9amh9bmoxa51c.com" target="_blank"&gt; doubao.com&lt;/a&gt;，在页面中选择「AI 播客」功能，随后上传 pdf 文件或网页链接，便能迅速生成一段双人对话形式的播客内容。&lt;/p&gt; 
&lt;p&gt;&lt;img height="279" src="https://oscimg.oschina.net/oscnet/up-877916c1b4fad2396c34f71edb9e0b5424b.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根据介绍，在语音效果方面，豆包播客生成的语音极为自然，能够精准模拟真人播客的口语习惯，在对话过程中，停顿、附和等细节处理得恰到好处，完全去除了生硬的机器感。&lt;/p&gt; 
&lt;p&gt;使用「AI 播客」功能，在工作场景下，用户可将行业报告或竞品分析的链接发送给豆包，瞬间就能得到一段通俗易懂的播客内容，方便在忙碌的工作间隙快速获取关键信息。在学习场景中，学生可以把课程知识点等基础资料交给豆包，将文字转化为对话形式的播客，实现随时随地「听学习」，有效提升知识吸收效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355796</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355796</guid>
      <pubDate>Sun, 11 May 2025 06:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>前百度算法工程师、零一万物高管李先刚出任阿里通义语音实验室负责人</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《科创板日报》消息称，前百度算法工程师、零一万物高管李先刚已加入阿里，担任通义语音实验室负责人。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="375" src="https://oscimg.oschina.net/oscnet/up-3eb7193c346bf36d099ad08b95ac57f8819.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公开资料显示，李先刚博士毕业于北京大学，先后在百度、滴滴担任首席算法工程师。离开滴滴后，李先刚加入贝壳，任策略算法中心负责人。2023 年李先刚加入零一万物团队，担任联合创始人、技术副总裁，后又离职回归贝壳。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李先刚在零一万物任职期间，公司完成了 A 轮融资，金额为数亿美元。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355790</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355790</guid>
      <pubDate>Sun, 11 May 2025 06:00:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>我的开源十年</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;🌟&amp;nbsp;依稀记得十年前，发的第一条关于 OpenAuth.Net 的博客：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FOpenAuth.html" target="_blank" rel="nofollow"&gt;领域驱动设计实战—基于 DDDLite 的权限管理 OpenAuth.net&lt;/a&gt;。那时 star 数只有 1，现在各种平台零零散散东拼西凑加起来也 7K 多了😂。那时候，我对 DDD（领域驱动设计）简直是走火入魔，觉得它就是我通往高级境界、人生巅峰的不二法门。十年过去了，手搓过的项目多如牛毛，但 DDD 却早已被抛到九霄云外，好像啥用没有，又好像已经融入到我的血液里。&lt;/p&gt; 
&lt;p&gt;🚀 这十年来，技术栈换了一茬又一茬。从 asp.net mvc 到 asp.net core 到.net 6、7...10，从 jquery 到 vue，写了 c++、java、python、R 等等等等，直到现在，用上个 cursor，语法都不用学都可以手搓一个站点出来：&lt;a href="https://gitee.com/yubaolee/AstroFast" target="_blank" rel="nofollow"&gt;使用 Astro 三天完成官网&lt;/a&gt;。看着&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2F4652772.html" target="_blank" rel="nofollow"&gt;为了理想，我放弃了一切&lt;/a&gt;，仿佛又回到了十年前，那个对技术充满好奇的少年。&lt;/p&gt; 
&lt;p&gt;❤️&amp;nbsp;这十年，学过无数、放弃过无数。但唯一坚持的就是&lt;a href="https://gitee.com/dotnetchina/OpenAuth.Net" target="_blank" rel="nofollow"&gt;OpenAuth.Net&lt;/a&gt;，它对我的意义已经不是一个开源项目，而是我这十年来的记忆。心情特别好的时候，更新一下；突然难过的时候，更新一下；喝完酒大醉的时候，更新一下；夜深人静睡不着的时候，更新一下。这些年忘记很多事请，但它一直都在。&lt;/p&gt; 
&lt;p&gt;📢&amp;nbsp;唠叨了这么多，怎么也得来点干货。今天我想让它被更多人知道，也想它能帮更多人节约开发时间。于是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;✅全面开源原付费 vue2 版本源码及文档，免费使用&lt;/span&gt;&lt;/strong&gt;。当然对于以前付费用户，可以免费升级 vue3 版本。详见官网说明：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.openauth.net.cn%2Fnewpricing%2F" target="_blank" rel="nofollow"&gt;全新定价&lt;/a&gt;。&lt;/li&gt; 
 &lt;li&gt;✅&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;&lt;strong&gt;放弃&lt;/strong&gt;&lt;/span&gt;原有 mvc 版本。&lt;/li&gt; 
 &lt;li&gt;✅提供 UniApp 版本。&lt;/li&gt; 
 &lt;li&gt;✅更快更新优化 vue3 版本。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;目前市面上快速开发、权限管理方面优秀的.NET 开源项目很多，但我给 OpenAuth.Net 定了以下几条规则：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;不强制绑定 gitee、github 登录 star 后才能访问演示站点、文档等。&lt;/li&gt; 
 &lt;li&gt;更新快，基本每周都有更新，有问题及时修复。&lt;/li&gt; 
 &lt;li&gt;文档永不收费，所有人可见。&lt;/li&gt; 
 &lt;li&gt;开源版本代码不做任何限制，任何人都可以免费学习使用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;💯就是说，要就要&lt;span style="font-size: 18px"&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1)"&gt;真&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;开源！&lt;/p&gt; 
&lt;p&gt;🤔扯了这么多，OpenAuth.Net 到底值不值得入坑呢？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持最新版.Net 9.0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同时支持 EntityFramework、SqlSugar 两款最流行的 ORM 框架&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;内置代码生成器，可快速生成带有头/明细结构的页面，请参考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fvue2%2Fdevnew%2F" target="_blank" rel="nofollow"&gt;代码生成&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;超强的自定义权限控制功能，请参考：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FDataPrivilege.html" target="_blank" rel="nofollow"&gt;通用权限设计与实现&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;完整 API 鉴权，可以控制角色可访问的 API 资源，及模块功能字段可见及是否返回，请参考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fapiauth.html%23%25E6%258C%2589%25E8%25A7%2592%25E8%2589%25B2%25E6%258E%2588%25E6%259D%2583api%25E8%25B5%2584%25E6%25BA%2590" target="_blank" rel="nofollow"&gt;按角色授权 API 资源&lt;/a&gt;&amp;nbsp;及&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fdatapropertyrule%2F" rel="nofollow" target="_blank"&gt;字段权限&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可拖拽的表单设计。详情：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fdragform%2F" rel="nofollow" target="_blank"&gt;可拖拽表单&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可视化流程设计。&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fstartflow%2F" rel="nofollow" target="_blank"&gt;可视化流程设计&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;全网最好用的打印解决方案。详情:&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fprinterplan%2F" rel="nofollow" target="_blank"&gt;智能打印&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基于 Quartz.Net 的定时任务控制,可随时启/停，可视化配置 Cron 表达式功能，请参考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fjob%2F" rel="nofollow" target="_blank"&gt;定时任务&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持 sqlserver、mysql、Oracle、PostgreSql 数据库，理论上支持所有数据库&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持同时访问多数据源&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多租户&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持搭建自己的 IdentityServer 服务器，实现基于 OAuth2 的登录体系，请参考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fidentity%2F" rel="nofollow" target="_blank"&gt;登录认证及 OAuth 集成&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;最后放两张靓图养养眼：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153920_WFRd.png" height="575" width="1003" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_YBn9.png" height="644" width="1006" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_wsSc.png" height="484" width="1002" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/yubaolee/blog/18620526</link>
      <guid isPermaLink="false">https://my.oschina.net/yubaolee/blog/18620526</guid>
      <pubDate>Sun, 11 May 2025 05:51:00 GMT</pubDate>
      <author>工作日志</author>
    </item>
    <item>
      <title>研究：Meta Llama 3.1 能回忆《哈利波特》42% 的内容</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;一组来自斯坦福大学、康奈尔大学和西弗吉尼亚大学的计算机科学家与法律学者近日共同发表了一项引人瞩目的研究，分析了几款开源大型语言模型在文本记忆方面的表现。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这项研究着重考察了五种不同的开放权重模型，它们的能力是否能够重复经典书籍中的内容。这五款模型中，有三款来自 Meta，另外两款分别由微软和 EleutherAI 开发。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究团队采用了 Books3 这一流行的书籍数据库，作为训练这些大模型的素材，值得一提的是，这些书籍中许多依然受到版权保护。研究者们将 36 本书划分为多个重叠的 100 个标记段落，然后利用前 50 个标记作为提示，计算接下来的 50 个标记与原文相同的概率。如果逐字重复的概率超过 50%，那么这段内容就被标记为 「已记住」。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="390" src="https://oscimg.oschina.net/oscnet/up-e0eabffd56c2b6277a8c21feb6af1558c4f.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;令人惊讶的是，Meta 于 2024 年发布的 Llama3.170B 模型在回忆《哈利波特》&lt;span&gt;第一&lt;/span&gt;部的表现中，竟能记住 42% 的内容。而相比之下，Meta 在 2023 年发布的 Llama165B 模型仅能回忆起 4.4% 的内容。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究人员还发现，相较于冷门书籍，Llama3.170B 在热门书籍如《霍比特人》和乔治・奥威尔的《1984》中的记忆能力更为突出，记忆量远高于其他模型。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355785</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355785</guid>
      <pubDate>Sun, 11 May 2025 05:49:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>🔥 Solon AI 五步构建 RAG 服务：2025 最新 AI + 向量数据库实战</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#24292e; text-align:start"&gt;此文参考自：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.toutiao.com%2Farticle%2F7506140643970826779%2F" target="_blank"&gt;https://www.toutiao.com/article/7506140643970826779/&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;引言：RAG 会成为 2025 年 AI 落地核心？&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在 2025 年，检索增强生成（RAG）技术已成为企业级 AI 应用的标配。传统大模型受限于知识更新慢、业务适配性差，而 RAG 通过动态外接知识库，结合向量数据库与 AI 推理能力，显著提升回答的准确性与实时性。本文将基于 Solon AI 与 Redis Vector Search，从 0 到 1 搭建 RAG 服务，并结合电商客服场景，揭秘如何通过 5 步实现生产级落地。&lt;/p&gt; 
&lt;h2&gt;一、项目初始化：Solon AI&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;核心依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai-repo-redis&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-ai-load-pdf&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置参考：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;solon.ai.chat:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;ds3:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;apiUrl:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"http://127.0.0.1:11434/api/chat"&lt;/span&gt; &lt;em&gt;# 使用完整地址（而不是 api_base）&lt;/em&gt;
    &lt;span style="color:#986801"&gt;provider:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"ollama"&lt;/span&gt; &lt;em&gt;# 使用 ollama 服务时，需要配置 provider&lt;/em&gt;
    &lt;span style="color:#986801"&gt;model:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"llama3.2"&lt;/span&gt;

&lt;span style="color:#986801"&gt;solon.ai.embed:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;bgem3:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;apiUrl:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"http://127.0.0.1:11434/api/embed"&lt;/span&gt; &lt;em&gt;# 使用完整地址（而不是 api_base）&lt;/em&gt;
    &lt;span style="color:#986801"&gt;provider:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"ollama"&lt;/span&gt; &lt;em&gt;# 使用 ollama 服务时，需要配置 provider&lt;/em&gt;
    &lt;span style="color:#986801"&gt;model:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"bge-m3:latest"&lt;/span&gt;
        
&lt;span style="color:#986801"&gt;solon.ai.repo:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;redis:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;server:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;localhost:6379&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;实例构建：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.redisx.RedisClient;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.ChatModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.embedding.EmbeddingModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.RepositoryStorable;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.repository.RedisRepository;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.repository.redis.MetadataField;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Bean;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Configuration;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Configuration&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagConfig&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; ChatModel &lt;span style="color:#4078f2"&gt;chatModel&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.chat.ds3}")&lt;/span&gt; ChatModel chatModel)&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; chatModel;
    }

    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; EmbeddingModel &lt;span style="color:#4078f2"&gt;embeddingModel&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.embed.bgem3}")&lt;/span&gt; EmbeddingModel embeddingModel)&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; embeddingModel;
    }

    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; RedisClient &lt;span style="color:#4078f2"&gt;client&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${solon.ai.repo.redis}")&lt;/span&gt; RedisClient client)&lt;/span&gt; {  &lt;em&gt;//构建知识库的连接客户端&lt;/em&gt;
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; client;
    }
    
    &lt;span style="color:#4078f2"&gt;@Bean&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; RepositoryStorable &lt;span style="color:#4078f2"&gt;repository&lt;/span&gt;&lt;span&gt;(EmbeddingModel embeddingModel, RedisClient client)&lt;/span&gt; { &lt;em&gt;//构建知识库&lt;/em&gt;
        &lt;em&gt;// 创建元数据索引字段列表（用于支持混合搜索）&lt;/em&gt;
        List&amp;lt;MetadataField&amp;gt; metadataFields = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();
        metadataFields.add(MetadataField.tag(&lt;span style="color:#50a14f"&gt;"title"&lt;/span&gt;));
        metadataFields.add(MetadataField.tag(&lt;span style="color:#50a14f"&gt;"category"&lt;/span&gt;));
        metadataFields.add(MetadataField.numeric(&lt;span style="color:#50a14f"&gt;"price"&lt;/span&gt;));
        metadataFields.add(MetadataField.numeric(&lt;span style="color:#50a14f"&gt;"stock"&lt;/span&gt;));

        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; RedisRepository.builder(embeddingModel, client.jedis())
                .metadataIndexFields(metadataFields)
                .build();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;技术选型优势：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Redis Vector Search（建议 Redis 8+）：支持千亿级向量毫秒检索，实时数据更新秒级可见&lt;/li&gt; 
 &lt;li&gt;Solon AI：统一接口支持各种主流向量数据库，内置流式输出与异步处理。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;二、数据处理：文档分块与向量化&lt;/h2&gt; 
&lt;h3&gt;1. 文档加载与分块&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;{
        &lt;em&gt;// 加载 PDF/Word 文档&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分块（动态调整块大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;分块策略：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;动态分块：根据语义边界（如段落、表格）自动调整块大小，避免信息割裂；&lt;/li&gt; 
 &lt;li&gt;重叠机制：设置 64 Token 的重叠区，确保上下文连贯性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2. 向量嵌入与存储&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在 RagService 的基础上，进一步补充&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.embedding.EmbeddingModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.Document;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.RepositoryStorable;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.splitter.TokenSizeTextSplitter;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Component;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.io.IOException;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; RepositoryStorable  repository;
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; EmbeddingModel embeddingModel;

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;em&gt;// 加载 PDF/Word 文档&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分块（动态调整块大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);

        &lt;em&gt;// 存储（内部自动完成向量嵌入，内部支持分批入库）&lt;/em&gt;
        repository.insert(docs);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;性能优化：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;批量处理：数据批次插入，降低 I/O 开销；&lt;/li&gt; 
 &lt;li&gt;元数据附加：为每个向量附加来源、时间戳等字段，支持精准过滤。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三、检索增强：混合搜索&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;使用元信息字段 category 过滤（减少匹配范围），并使用向量检索&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#4078f2"&gt;@Component&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagService&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; RepositoryStorable repository;
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;private&lt;/span&gt; EmbeddingModel embeddingModel;

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;load&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;em&gt;// 加载 PDF/Word 文档&lt;/em&gt;
        List&amp;lt;Document&amp;gt; docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;PdfLoader&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"product-manual.pdf"&lt;/span&gt;).load();

        &lt;em&gt;// 智能分块（动态调整块大小）&lt;/em&gt;
        docs = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;TokenSizeTextSplitter&lt;/span&gt;(&lt;span style="color:#986801"&gt;500&lt;/span&gt;, &lt;span style="color:#986801"&gt;64&lt;/span&gt;).split(docs);

        &lt;em&gt;// 存储（内部自动完成向量嵌入）&lt;/em&gt;
        repository.insert(docs);
    }

    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; List&amp;lt;Document&amp;gt; &lt;span style="color:#4078f2"&gt;find&lt;/span&gt;&lt;span&gt;(String category, String query)&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; repository.search(&lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;QueryCondition&lt;/span&gt;(query)
                .filterExpression(&lt;span style="color:#50a14f"&gt;"category == '"&lt;/span&gt; + category + &lt;span style="color:#50a14f"&gt;"'"&lt;/span&gt;));
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;场景适配：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;元数据检索：处理明确实体（如商品目录）；&lt;/li&gt; 
 &lt;li&gt;向量检索：应对复杂语义（如「性价比高的手机推荐」）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;四、生成优化：提示工程与流式输出&lt;/h2&gt; 
&lt;h3&gt;1. 动态 Prompt 设计&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;promptTemplate&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"""
    你是一名电商客服专家，请根据以下上下文回答问题：
    #{context}
    问题：#{question}
    要求：回答需包含具体数据，若信息不足则回复「暂未收录」。
    示例：库存查询 → 「当前 iPhone 20 库存为 500 件，预计 48 小时发货。」
    """&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;关键技巧：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;指令约束：限制回答范围，减少幻觉；&lt;/li&gt; 
 &lt;li&gt;示例引导：提供标准回答格式，提升一致性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2. 流式响应与溯源&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;写一个控制器，整合 ChatModel 和 RagService&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.ChatModel;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.chat.message.ChatMessage;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.ai.rag.Document;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Controller;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Mapping;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; reactor.core.publisher.Flux;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.io.IOException;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Controller&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;RagController&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    RagService ragService;

    &lt;span style="color:#4078f2"&gt;@Inject&lt;/span&gt;
    ChatModel chatModel;

    &lt;span style="color:#a626a4"&gt;static&lt;/span&gt; &lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;promptTemplate&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"""
        你是一名电商客服专家，请根据以下上下文回答问题：
        #{context}
        问题：#{question}
        要求：回答需包含具体数据，若信息不足则回复「暂未收录」。
        示例：库存查询 → 「当前 iPhone 20 库存为 500 件，预计 48 小时发货。」
        """&lt;/span&gt;;

    &lt;span style="color:#4078f2"&gt;@Mapping("/ask")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; Flux&amp;lt;String&amp;gt; &lt;span style="color:#4078f2"&gt;streamAnswer&lt;/span&gt;&lt;span&gt;(String question)&lt;/span&gt; &lt;span style="color:#a626a4"&gt;throws&lt;/span&gt; IOException {
        List&amp;lt;Document&amp;gt; context = ragService.find(&lt;span style="color:#50a14f"&gt;"商品"&lt;/span&gt;, question);
        
        &lt;span style="color:#986801"&gt;ChatMessage&lt;/span&gt; &lt;span style="color:#986801"&gt;message&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; ChatMessage.ofUserTmpl(promptTemplate)
                .paramAdd(&lt;span style="color:#50a14f"&gt;"question"&lt;/span&gt;, question)
                .paramAdd(&lt;span style="color:#50a14f"&gt;"context"&lt;/span&gt;, context)
                .generate();

        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; Flux.from(chatModel.prompt(message).stream())
                .filter(resp -&amp;gt; resp.hasChoices())
                .map(resp -&amp;gt; resp.getMessage().getContent());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;用户体验优化：&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;逐字输出：响应延迟降低至 100ms 以内（要看模型服务的性能）；&lt;/li&gt; 
 &lt;li&gt;来源标记：返回答案关联的文档 ID 与置信度。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;五、实战案例：电商客服 RAG 系统&lt;/h2&gt; 
&lt;h3&gt;场景：秒杀活动问答&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;需求：用户询问「iPhone 20 秒杀库存和优惠规则」。&lt;/p&gt; 
&lt;h4&gt;RAG 处理流程：&lt;/h4&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;检索：从商品手册中匹配「iPhone 20」的库存条款与促销规则； 生成：返回「当前库存 2000 件，限购 1 台，叠加满减券再降 500 元」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355781</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355781</guid>
      <pubDate>Sun, 11 May 2025 03:48:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>木兰编程语言重现项目五年回顾</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;h3&gt;简介&lt;/h3&gt; 
&lt;p&gt;旨在重现 2020 年初报道后即被指为「Python 套壳」、「换皮」的木兰编程语言工具的所有功能。揣摩设计思路、验证实现技术路径及其可持续维护性。为低代价实现原创编程语言工具尤其是前端部分提供标本，也通过悬赏任务为开源合作探索新模式。&lt;/p&gt; 
&lt;h3&gt;历程&lt;/h3&gt; 
&lt;p&gt;五年前 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F265091649" target="_blank"&gt;因缘巧合的邂逅&lt;/a&gt; 后，一月二十三日启动 &lt;a href="https://gitee.com/MulanRevive/mulan-rework"&gt;木兰重现项目&lt;/a&gt; 并重金悬赏。&lt;/p&gt; 
&lt;p&gt;一月二十五日即于 GitHub 迎来首位响应者。感激 @thautwarm，受教良多。期间项目目标精确化。&lt;/p&gt; 
&lt;p&gt;2020 年六月项目搬迁到开源中国的 Gitee 平台。&lt;/p&gt; 
&lt;p&gt;至 2023 年一月复现几乎所有命令行选项，作了讲座 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Flives%2F1596877608825921536" target="_blank"&gt;三年小结&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;继 2023 年四月添加对 Python 3.8 的支持后，2024 年陆续添加了对 Python 3.9-3.12 的支持。&lt;/p&gt; 
&lt;p&gt;下图是悬赏历史，详见&lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E6%94%B6%E6%94%AF%E8%B4%A6%E6%9C%AC"&gt;收支账本&lt;/a&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://gitee.com/MulanRevive/bounty/raw/master/%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/%E6%88%AA%E5%9B%BE/2025-04-15-%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E.png" alt="悬赏历史" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;合作体会：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;平台支持之重要：Gitee 悬赏功能于 2021 年四月底上线，合作从此加速&lt;/li&gt; 
 &lt;li&gt;任务细化，确保可控&lt;/li&gt; 
 &lt;li&gt;团队之珍贵&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;项目相关文章汇于 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Fcolumn%2Fulang" target="_blank"&gt;知乎专栏&lt;/a&gt;。&lt;/p&gt; 
&lt;h3&gt;希冀&lt;/h3&gt; 
&lt;p&gt;原创编程语言的最大困难之一，是要「从零手写编译器」的心理阴影。希望此项目能让更多业务开发者可以更专注于语言工具与人的交互设计，并在需要时借助现有生态、以尽可能小的代价完成原型验证并逐渐过渡到实用产品。&lt;/p&gt; 
&lt;h3&gt;鸣谢&lt;/h3&gt; 
&lt;p&gt;期间碰到开发流程和悬赏等相关问题提出报告后，Gitee 官方充分支持响应，非常感激！&lt;/p&gt; 
&lt;p&gt;感激所有项目参与者的资助、合作时的耐心和探究精神！&lt;/p&gt; 
&lt;p&gt;为重现五年前昙花一现的 &lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%96%99/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"&gt;ulang-0.2.2.exe&lt;/a&gt; 的花费虽可观，但和原创团队从设计到推广所耗心血不可相提并论。致敬他们的创意、热情和付出！&lt;/p&gt; 
&lt;p&gt;天涯若比邻。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4552012/blog/18489924</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4552012/blog/18489924</guid>
      <pubDate>Sun, 11 May 2025 03:46:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>得物自研 DScript2.0 脚本能力从 0 到 1 演进</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
 &lt;h1&gt;一、前言&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在高并发推荐引擎场景中，C++的极致性能往往以开发效率为妥协，尤其在业务频繁迭代时，C++的开发效率流程成为显著瓶颈。传统嵌入式脚本（如 Lua）虽支持动态加载，但其与 C++的交互成本（如虚拟栈数据中转、类型转换）仍会带来额外性能损耗。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;为此，我们探索设计 DScript2.0——一种与 C++内存布局及调用约定深度兼容的动态脚本语言，通过自研编译器实现即时编译与无缝嵌入，尝试在保留脚本灵活性的同时，尽可能贴近 C++的原生性能，为性能与效率的平衡提供了轻量化解决方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
 &lt;h1&gt;二、动态脚本在引擎中的引用&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;C++引擎的迭代效率瓶颈&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在搜推引擎中的实践中，出于对高并发场景下极致性能的追求，使用 C++进行引擎自研成为了一种业界常态。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;众所周知，C++通过开放底层控制权限（如内存分配，指令优化等），提升了可达的性能上限，但这种提升伴随了大量底层细节的处理，消耗了更多的开发时间，追求性能优先的同时，却又限制了开发效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我们希望能够在保持性能的同时，提升引擎的开发效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;利用嵌入式脚本提升迭代效率&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我们的目标是寻求一种平衡性能与迭代效率的方案，一种主流方案是在 C++中嵌入脚本语言。例如，在游戏引擎和 Nginx 开发中集成 Lua，在 C/C++代码中实现性能需求，结合脚本代码中实现控制逻辑，从而提升开发效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式脚本对迭代效率的提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持动态加载，无需编译部署。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;无需 C/C++经验，脚本学习成本低，提升参与迭代的人力总量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;引擎的迭代拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎内部的技术性迭代&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;业务侧的需求支持&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;业务侧的需求非常适合引入嵌入式脚本，实现对易变需求的自迭代，提升开发效率，这也是一种业界主流方案。例如，一些搜索中台中，对于相关性和粗排逻辑封装为插件，业务侧的算法工程师使用 Lua 开发计算逻辑，可以极大地提升迭代效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;嵌入式脚本的额外性能开销&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在引擎中嵌入脚本，虽然可以提升迭代效率，但并非全无代价，高阶语言与低阶语言的交互存在着额外的性能开销。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，Lua 和 C++的交互机制基于 Lua 提供的虚拟栈来实现，这个栈是两者进行数据交换的核心通道。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用虚拟栈实现语言交互存在额外的开销，包括但不限于压栈和弹栈操作、栈空间管理、类型检查和转换、复杂数据结构的处理等。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="473" src="https://oscimg.oschina.net/oscnet/up-0054288a2e3e644efffe3b1ed219cd34818.jpg" width="920" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;更加极致的方案&amp;nbsp;&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;基于以上的瓶颈，我们期望一种更加极致的方案，实现性能与效率的平衡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式脚本的额外性能开销&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;（主要源于两种语言在 ABI 层面的不一致）&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;函数调用约定不一致，需要一个虚拟栈进行中转。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;数据类型内存布局不一致，需要额外的检查和转换。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;一个直观的解决方案就是我们设计一种编程语言，在底层实现上与 C++具有一致内存布局与调用约定，从而消除额外的转换开销。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;同时，这种编程语言可以在 C++嵌入，也支持即时编译，提升效率的同时，也拥有与原生 C++近似的执行性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;以上是我们规划 DScript2.0 项目初衷。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_7"&gt;&lt;/span&gt; 
 &lt;h1&gt;三、DScript2.0 的编译器实现&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;语法设计&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 被设计为一种轻量级面向过程的编程语言，同时它也是静态类型的编译语言。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在语法支持上，包含了基础数据类型、变量、运算符、控制流和函数，额外支持了与 C++的语言互操作。&lt;/span&gt;&lt;/p&gt; 
 &lt;table style="width:574px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;数据类型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;int，long，bool，float，double，void&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自定义变量，隐式类型转换。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++变量：支持访问和操作外部注册的 C++变量，支持 C++的结构体部分操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;运算符&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;算术运算符：+，-，*，/，%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;关系运算符：==，!=，&amp;gt;=，&amp;gt;，&amp;lt;=，&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;逻辑运算符：!，&amp;amp;&amp;amp;，||&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;赋值运算符：=，+=&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自增自减运算符：++i，--i&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;控制流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;分支语句：if (...) else if (...) else&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;循环语句: for 循环&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;自定义函数：基础类型值传递，对象类型引用传递。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++API：支持调用外部注册的 C++函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;浅析编译器架构&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;img height="114" src="https://oscimg.oschina.net/oscnet/up-cc6c2fd61871eded90a60e6e26ea2d701a2.png" width="998" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（编译器的三段结构）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;一个完整的编译器通常由三个主要部分组成：前端、优化器和后端。&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;前端：&lt;/strong&gt;负责词法分析、语法分析、语义分析、生成中间代码。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;优化器（中端）：&lt;/strong&gt;负责对中间代码进行优化。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;后端：&lt;/strong&gt;负责将中间代码转换成目标机器的的机器码。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;基于 LLVM 实现 DScript2.0 编译器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="206" src="https://oscimg.oschina.net/oscnet/up-3b5d7a82e72a82da5af334b5f4b8f4218be.png" width="558" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM 是一个模块化且高度可重用的编译器基础设施项目。它提供了前端、优化器和后端工具链，已支持多种编程语言和平台。LLVM 具有跨平台性，允许开发者灵活定制编译流程，提供高级优化能力，支持即时编译，被广泛用于编译器开发、虚拟机和代码分析工具场景。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;采用 LLVM 实现 DScript2.0 的优势&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;提升开发效率：&lt;/strong&gt;LLVM 的前端、中端和后端采用了模块化设计，每个部分都可以独立替换或扩展，这种灵活性使得 LLVM 非常适合定制编译器，&lt;strong&gt;我们可以复用 LLVM 的中端与后端，专注于前端开发，减少开发成本。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持高级优化：&lt;/strong&gt;LLVM 提供了一套强大的优化工具，能够对代码进行静态和动态优化。这些优化不仅能够提高代码的执行效率，还可以减少代码体积。&lt;strong&gt;这是 DScript2.0 理论上可能提供接近原生 C++性能的关键因素之一。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持即时编译：&lt;/strong&gt;LLVM 支持即时编译（JIT），通过 JIT 编译，LLVM 能够在运行时生成和执行代码，大大提升了执行效率。通过运行时进行编译后运行，&lt;strong&gt;这是 DScript2.0 理论上可能提供接近原生 C++性能的关键因素之二&lt;/strong&gt;。支持在线的即时编译能力，&lt;strong&gt;同时也是算子开发与分发效率的保障。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;DScript2.0 编译器架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1454" src="https://oscimg.oschina.net/oscnet/up-e75e425f479ce08e65ea5b597f1b04f7366.jpg" width="1594" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 编译器同样包含前端、中端、后端三部分，前端能力自研，优化器和后端基于 LLVM 的 Pass 和 JIT 实现。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;编译器最终输出为 x86_64 平台的可执行二进制，以 JIT 实例的方式常驻内存，通过入口函数地址执行。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;编译器支持注入 C++类型与函数参与编译，实现 DScript2.0 对 C++的调用。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;编译器前端实现&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;前端的实现流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;编译器前端的任务是&lt;strong&gt;将源码转换为优化器可处理的中间代码&lt;/strong&gt;，这个转换的流程通常包含 4 个步骤：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;词法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;语法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;语义分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中间代码生成&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="653" src="https://oscimg.oschina.net/oscnet/up-184dcf9ec5eea648706894ea1f861cf8399.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（编译器前端架构）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;词法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;源代码是一堆连续的字符，计算机要先识别出这些字符组成的基本单元，才能进一步理解代码含义。就像读句子先得认出单词一样，这是理解程序的第一步。词法分析的本质是&lt;strong&gt;将代码的字符流，转换为更易处理的 token 流。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：字符流-&amp;gt;记号流（Tokens）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;词法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中了使用 Flex，可以根据自定义的正则表达式规则，自动生成词法分析的扫描器，减少手工编写词法分析器的工作量。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 工作流程&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-a4857fc6f269c2441e72179493b1a628b42.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 语法&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 Flex 的定义文件中包含三部分：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;定义段：&lt;/strong&gt;包含头文件和全局变量，如输入和输出流的定义。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;规则段：&lt;/strong&gt;由模式和对应的动作组成。当扫描器匹配到模式时，执行对应的动作。例如，匹配到"int"字符串时，将其识别为 INT 标识。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;用户代码段：&lt;/strong&gt;通常可以在此区域定义&lt;strong&gt;&amp;nbsp;main()&amp;nbsp;&lt;/strong&gt;函数，它调用&lt;strong&gt;&amp;nbsp;yylex()&amp;nbsp;&lt;/strong&gt;，启动词法分析过程。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 定义段段开始 */
/* 引入的 c/c++代码 */
%{
#include &amp;lt;string&amp;gt;
%}


/* 正则表达式的宏定义 */
LineTerminator &amp;nbsp; &amp;nbsp; &amp;nbsp; \n|\r|\r\n
WhiteSpace &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [ \t\f]|{LineTerminator}
Identifier &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [a-zA-Z_][a-zA-Z0-9_]*
/* 定义段结束 */


%%




/* 规则段开始 */
/* 规则：正则表达式 { return 传递给语法分析器的记号类型 } */
"int"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;INT; }
"float"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;FLOAT; }
"void"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;VOID; }


{Identifier} {
&amp;nbsp; &amp;nbsp; yylval.identifier = new std::string(yytext);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;IDENTIFIER;
}
{LineTerminator} {}
{WhiteSpace} {}


&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;END;
}
/* 规则段结束 */




%%




/* 用户代码段开始 */
/* 用户代码段结束 */&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;匹配规则&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;最长匹配：当多个规则可匹配时，Flex 选择&lt;strong&gt;最长匹配&lt;/strong&gt;的词素。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;最先定义：若多个规则长度相同，则选择&lt;strong&gt;最先定义&lt;/strong&gt;的规则。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;语法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;语法分析的原理是根据上下文无关文法（CFG）对输入的 tokens 序列进行分析，验证其是否符合某种语言的语法规则，并构建对应的抽象语法树。其核心在于建立程序的分层逻辑结构，并确保这种结构符合语法约束。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：记号流-&amp;gt;抽象语法树（AST）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;由语法分析原理拆分&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;结构验证：&lt;/strong&gt;检查记号流的排列是否符合语法规则，DScript2.0 的语法规则由上下文无关文法（CFG）描述，验证算法采用了自底向上的 LR 算法。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;// 示例：分支语法规则：if (conditon) { stmts }
// 符合语法规则
if&amp;nbsp;(a &amp;lt;&amp;nbsp;1) {


// 不符合语法规则
if&amp;nbsp;a &amp;lt;&amp;nbsp;1&amp;nbsp;{&lt;/code&gt;&lt;/pre&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;层次构建：&lt;/strong&gt;将线性的记号流转换为树状或嵌套的语法结构，以抽象语法树为例：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;FunctionDefinition
&amp;nbsp; ├── ReturnType:&amp;nbsp;int
&amp;nbsp; ├── FunctionName: func
&amp;nbsp; ├── Parameters
&amp;nbsp; │ &amp;nbsp; └── Parameter
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Name: a
&amp;nbsp; └── Body
&amp;nbsp; &amp;nbsp; &amp;nbsp; ├── VariableDeclaration
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├── Name: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; └── InitialValue
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── +
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ├── Variable: a
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Constant:&amp;nbsp;1
&amp;nbsp; &amp;nbsp; &amp;nbsp; └── ReturnStatement
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Variable: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;上下文无关文法（CFG)&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;上下文无关文法（CFG） 是编译器语法分析的核心工具，用于形式化描述编程语言的语法结构。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;其核心要素包括：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;终结符&lt;/strong&gt;（如标识符、运算符），对应词法分析的 Token，不可再分解。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非终结符&lt;/strong&gt;（如表达式、语句），需通过产生式规则展开为终结符或其他非终结符。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;产生式规则（如 E → E + T）&lt;/strong&gt;&amp;nbsp;，定义语法结构的生成方式。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;起始符号&lt;/strong&gt;（如&lt;strong&gt;&amp;nbsp;Program&amp;nbsp;&lt;/strong&gt;），代表语法分析的入口。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;产生式规则定义示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 局部变量声明 -&amp;gt; 类型，变量声明 */
/* 例如&amp;nbsp;int&amp;nbsp;a =&amp;nbsp;1&amp;nbsp;*/
/* Type 对应 int&amp;nbsp;*/
/* Variable_Declartor 对应 a =&amp;nbsp;1&amp;nbsp;*/
Local_Variable_Declartor -&amp;gt;
&amp;nbsp; &amp;nbsp; Type Variable_Declartor;


/* 变量声明 -&amp;gt; 变量 ID 或，变量 ID = 变量初始化 */
Variable_Declartor -&amp;gt;&amp;nbsp;
&amp;nbsp; &amp;nbsp; Variable_ID
&amp;nbsp; &amp;nbsp; | Variable_ID EQ Variable_Initializer;


/* 变量 ID -&amp;gt; 标识符 */ &amp;nbsp; &amp;nbsp;
Variable_ID -&amp;gt; IDENTIFIER;


/* 变量初始化 -&amp;gt; 任意表达式 */
Variable_initializer -&amp;gt; expression;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;示例中根据形式化的语法，描述了变量定义和变量初始化规则。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;示例中包含 4 条产生式规则：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;局部变量声明规则&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;变量声明表达式规则&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;变量 ID 规则&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;变量初始化规则&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;终止符：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;Type 对应一个 C++的 TypeNode&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;IDENTIFIER 对应词法定义的 Token&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;语法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;语法分析器采用 Bison 来实现，Bison 可以与 Flex 进行协作，将词法分析器生成的记号序列解析为语法树，供编译器进一步处理。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;通过与 Flex 协同工作，Bison 可以自动化地处理复杂的语法分析任务，使编译器的开发更加高效和灵活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;语义分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;通过遍历抽象语法树，实现上下文相关的文法检查，对程序的类型、作用域和标识符等进行详细检查，&lt;strong&gt;确保程序在逻辑上符合编程语言的规则，同时生成中间表示代码&lt;/strong&gt;，作为优化器或后端的输入。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;输入与输出：&lt;/strong&gt;抽象语法树-&amp;gt;中间代码。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;语法分析与语义分析的区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;输出目标不同：语法分析的主要任务是将记号流转换为结构化信息，语义分析是将结构化信息翻译为优化器可以处理的中间表示语言。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;语法正确的语句，语义未必正确：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;例如，有函数原型&lt;strong&gt;&amp;nbsp;void echo(int a)&amp;nbsp;&lt;/strong&gt;，在调用时&lt;strong&gt;&amp;nbsp;int b = echo("a")&amp;nbsp;&lt;/strong&gt;，这是符合语法的，但不符合语义。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;再比如，语言要求使用变量前先定义，在未定义变量&lt;strong&gt;&amp;nbsp;a&amp;nbsp;&lt;/strong&gt;的前提下，执行赋值&lt;strong&gt;&amp;nbsp;a = 1;&amp;nbsp;&lt;/strong&gt;，这样也是符合语法但不符合语义的。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;语义分析的主要任务&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;符号表管理&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;作用域解析&lt;/strong&gt;：追踪变量/函数的作用域（如块级作用域、全局作用域）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;符号绑定：&lt;/strong&gt;将标识符与其声明关联（如变量类型、函数签名）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;重复定义检查：&lt;/strong&gt;禁止同一作用域内同名符号的重复声明。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;类型系统校验&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;类型推断与检查：&lt;/strong&gt;验证表达式和操作的合法性，如&lt;strong&gt;&amp;nbsp;int a = "str";&amp;nbsp;&lt;/strong&gt;类型不匹配。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;隐式类型转换：&lt;/strong&gt;处理类型提升，如&lt;strong&gt;&amp;nbsp;int + float&amp;nbsp;&lt;/strong&gt;自动转为浮点运算。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;函数签名匹配：&lt;/strong&gt;检查实参与形参的个数、类型一致性。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;控制流合法性&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;语句上下文检查：&lt;/strong&gt;确保&lt;strong&gt;&amp;nbsp;break&amp;nbsp;&lt;/strong&gt;仅在循环内、&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;与函数返回类型一致。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;可达性分析：&lt;/strong&gt;检测不可达代码（如&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;后的语句）。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;常量表达式求值&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;优化常量计算（如&lt;strong&gt;&amp;nbsp;const x = 2 + 3*4; &amp;nbsp;&lt;/strong&gt;直接计算为&lt;strong&gt;&amp;nbsp;14&amp;nbsp;&lt;/strong&gt;）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;用于数组长度、条件编译等需编译期确定值的场景。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;中间代码生成&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;中间代码的生成流程是通过递归遍历 AST 完成的，将语义检查无误的逻辑，转换为中间表示语言，这是编译器前端工作的最后一步。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中使用了&lt;strong&gt;LLVM IR&lt;/strong&gt;作为中间代码语言，它介于高级语言和目标代码之间，既能表达高级语言的抽象概念，又能适应底层机器代码的生成需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 提供了丰富的指令集，涵盖了从基本运算到复杂控制流、内存操作、同步操作等各种编程需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 指令集示例&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令种类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令/作用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;算术和位操作指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;&amp;nbsp;add:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整数加法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;sub:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整数减法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;mul:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整数乘法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;udiv/&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;sdiv:&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;无符号/有符号整数除法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;内存访问指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;alloca:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;在栈上分配内存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;load:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;从内存中加载值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;store:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;将值存储到内存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;getelementptr:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;计算数组或结构体成员的地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;比较指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;icmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span&gt;整数比较&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;fcmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;浮点数比较&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;br:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;条件或无条件分支&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;函数管理指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;call:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;调用函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;invoke:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;类似&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;call&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;，但支持异常处理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;ret:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;函数返回&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;phi:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;选择多个前驱块中的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;转换示例：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（源代码）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;; 函数定义: 函数名为 func，返回类型为 i32（32 位整数），参数为 i32 类型的 a
define i32 @func(i32 %a) {
entry:
&amp;nbsp; ; 定义局部变量 b，并将其初始化为 a +&amp;nbsp;1&amp;nbsp;的结果
&amp;nbsp; %b = add i32 %a,&amp;nbsp;1


&amp;nbsp; ; 返回 b 的值
&amp;nbsp; ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（与之对应的 LLVM 的中间代码）&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;编译器中端：中间代码优化&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="416" src="https://oscimg.oschina.net/oscnet/up-80b965c5be150535603d8f702d40fdfd6cb.png" width="1824" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;在 DScript2.0 中，优化器是通过&lt;strong&gt;复用 LLVM 的中端优化能力&lt;/strong&gt;来实现的，通过一系列 LLVM 预置的优化遍 (Pass)，对程序生成的中间代码进行优化，以&lt;strong&gt;提高代码的性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中端的输出为优化过后的 IR 指令，这些 IR 指令需要提供给后端进行编译。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 LLVM 中，优化遍是指按照一定顺序执行的一个或多个优化算法。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;以下是一些常用的优化算法：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table style="width:792px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;数据流分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;死代码消除 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;DCE&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通过数据流分析，LLVM 能够精确地识别和删除这些无用的指令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;全局值编号 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;GVN&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;检测并消除等价的冗余表达式，减少重复计算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循环优化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循环展开&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Unrolling)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通过展开循环体中的指令，减少循环控制的开销，并增加指令级并行性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循环分割&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Split)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;将复杂的循环拆分为多个更简单的循环，以便更好地优化每个循环。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循环不变代码外提&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;LICM&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;将循环中不变的计算移出循环体，从而减少不必要的重复计算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;条件合并&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Conditional Merging)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;合并控制流中多余的条件判断，从而简化分支结构。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;跳转线程化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Jump Threading)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;在控制流图中，将多个条件判断组合为一个单一的跳转，以减少不必要的分支。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;尾调用优化 (TCO)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;优化递归函数调用，使得尾递归调用能够直接重用当前栈帧，从而避免栈溢出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;访问优化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;别名分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Alias Analysis)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;确定不同指针是否指向相同的内存位置，从而帮助优化器在内存访问上进行优化，如消除冗余的内存加载和存储操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;堆栈分配优化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Stack Allocation Optimization)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通过分析栈上变量的生命周期，减少不必要的内存分配和释放，或者将栈分配的变量优化到寄存器中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;编译器后端：即时编译&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="267" src="https://oscimg.oschina.net/oscnet/up-f3e50fa3a189d76959930ec8fab07c58aae.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 使用 LLVM 的 ORC JIT 作为即时编译器的实现，支持在程序运行时编译脚本，并通过查找函数地址的方式执行脚本。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;采用即时编译器的优势：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;避免了开发调试过程中，频繁的启停程序，&lt;strong&gt;提升迭代效率。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;且经过编译的代码，在执行时能够显著&lt;strong&gt;提升运行性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;语言互操作性&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;语言互操作性是指不同编程语言能够相互调用、协同工作的能力。通过这种能力，开发者可以在同一项目中结合多种语言的优势。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，&lt;strong&gt;C++ 与 Lua 的结合&lt;/strong&gt;是就互操作的经典场景，常见于游戏开发、搜推引擎、嵌入式系统等领域。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在我们的需求中，要支持动态脚本访问引擎的表列资源，就需要 DScript2.0 也能具备与 C++交互操作的能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 与 C++的语言互操作性体现在&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以调用 C++的函数，并向 C++传递数据。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++可以调用 DScript2.0 的函数，并向 DScript 脚本传递数据。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以访问和操作 C++传递的基础类型和结构体类型变量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;调试能力&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 基于 GDB 实现了基本的调试能力：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持通过 Attach 进程进行实时调试&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;支持在 coredump 中保留栈信息&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;调试能力的实现主要基于 GDB 的通用调试接口，在编译 DScript2.0 源码时，生成调试信息，插入到 LLVM IR 的元数据中，然后通过 JIT 的监听器挂载 GDB 调试接口，并注入调试信息，最终实现调试能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1066" src="https://oscimg.oschina.net/oscnet/up-f80ad594f8632e01339667c91c3e30ae47b.jpg" width="2010" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;异常处理&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中也实现了异常处理能力，主要包括了硬件异常的主动防御和跨 C++与 DScript2.0 边界的异常传播。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;硬件异常防御&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;程序异常可以划分为硬件异常和主动异常：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;硬件异常&lt;/strong&gt;是底层不可控错误，硬件异常的处理需依赖信号钩子或语言运行时封装。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;典型例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;段错误（SIGSEGV）：&lt;/strong&gt;非法内存访问&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;浮点运算错误（SIGFPE）：&lt;/strong&gt;如整数除零或浮点运算异常&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非法指令（SIGILL）：&lt;/strong&gt;执行未定义的机器指令&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;总线错误 （SIGBUS）：&lt;/strong&gt;如未对齐的内存访问&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;主动异常&lt;/strong&gt;是代码逻辑的一部分，用于可控的错误处理与资源管理，主动异常由开发者显式抛出，也可由语言运行时隐式转换。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;硬件异常的主动防御&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 在语言层面上，对代码引发的硬件异常进行了主动防御。实现上，是在语义分析阶段，对中间代码添加防御逻辑，防御策略则采用了可被捕获的主动异常抛出。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如下图所示，在编译阶段，编译器对于结构体指针进行了空引用检查逻辑，将硬件异常转换为了主动异常，而主动异常可以通过捕获来进行处理，避免了进程崩溃。&lt;/span&gt;&lt;/p&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//330561eb2fd5d29de05f211a5205a6fe.webp" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;跨语言边界传播&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;因为 DScript2.0 的语言互操作性特性，会涉及到 C++与 DScript2.0 的函数互相调用（如下图所示），就会涉及到异常处理时，异常在 C++和 DScript2.0 之间传播，即所谓跨语言边界。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 主要实现了如下的异常传播机制：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;脚本调用 C++ 函数时若抛出异常，在脚本端不进行捕获，但支持异常传播到 C++端，同时正常完成栈回退。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++ 调用脚本函数时若抛出异常，可以在 C++ 端捕获。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="854" src="https://oscimg.oschina.net/oscnet/up-21add7106f9e6fac929e9d7c4c917d64c6c.jpg" width="1370" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h1_16"&gt;&lt;/span&gt; 
 &lt;h1&gt;四、DScript2.0 在线开发工作流&lt;/h1&gt; 
 &lt;img height="646" src="https://oscimg.oschina.net/oscnet/up-e203b933862df54885aa58b955cee294427.png" width="840" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 通过平台化实现了在线开发的工作流：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎集成：以 SDK 方式与引擎进行集成，提供在线编译和加载的能力。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在线 IDE：实现编辑、编译的在线开发环境。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在线工作流：通过平台化支持脚本的在线分发与管理。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
 &lt;h1&gt;五、总结&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 的实践为推荐引擎的敏捷迭代探索了一条新路径。通过编译器架构与 C++底层机制的高度兼容设计，它在降低跨语言交互成本、支持动态加载等方面展现出潜力，同时保持了接近原生 C++的运行时性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其即时编译能力与在线开发流程，使业务团队能独立完成逻辑更新，减少对传统 C++开发中编译部署的依赖，初步验证了兼顾性能与效率的可能性。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未来，我们计划进一步完善调试工具链与异常处理机制，并探索其在混合语言场景下的扩展性，以更轻量的方式推动引擎架构的持续优化。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;算法团队大量 HC，欢迎加入我们：&lt;/strong&gt;得物技术大量算法岗位多地上线，「职」等你来！&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;往期回顾&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;社区造数服务接入 MCP｜得物技术&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;CSS 闯关指南：从手写地狱到「类」积木之旅｜得物技术&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;从零实现模块级代码影响面分析方案｜得物技术&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以细节诠释专业，用成长定义价值——对话&lt;a href="https://my.oschina.net/u/2550946" class="referer" target="_blank"&gt;@孟同学&lt;/a&gt; ｜得物技术&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;得物可观测平台架构升级：基于 GreptimeDB 的全新监控体系实践&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 明远&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18627049</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18627049</guid>
      <pubDate>Sun, 11 May 2025 03:28:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>月之暗面开源面向软件工程的代码大模型 Kimi-Dev-72B</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;月之暗面&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoonshotai.github.io%2FKimi-Dev%2F" target="_blank"&gt;宣布开源 Kimi-Dev-72B&lt;/a&gt;，这是面向软件工程的代码大模型，并在 SWE-bench 上达到了开源模型中的 SOTA。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45476d7e8f257fde3b6a320ba89fcc0606c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b6ade9fe36167189fac92bab26ef34765ba.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Kimi-Dev-72B 的设计理念和技术细节包括 BugFixer 和 TestWriter 的双重角色、中期训练、强化学习以及测试时自博弈。&lt;/p&gt; 
&lt;p&gt;据介绍，Kimi-Dev-72B 通过大规模强化学习进行优化，能够自主地在 Docker 中修补真实代码库。通过 mid-train，RL，让模型在真实环境中修复代码并通过测试，有效提升了性能。测试显示，Kimi-Dev 在 SWE-bench Verified 上解决了 60.4% 的 issue。&lt;/p&gt; 
&lt;p&gt;模型现已在 Hugging Face 和 GitHub 开源：&lt;/p&gt; 
&lt;p&gt;Page: https://moonshotai.github.io/Kimi-Dev/&lt;br&gt; GitHub: https://github.com/MoonshotAI/Kimi-Dev&lt;br&gt; HuggingFace: https://huggingface.co/moonshotai/Kimi-Dev-72B&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355762/moonshotai-kimi-dev</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355762/moonshotai-kimi-dev</guid>
      <pubDate>Sun, 11 May 2025 02:46:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 与微软关系紧张加剧，或将控诉其反竞争行为</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;《华尔街日报》报道称，OpenAI 与其最大投资者微软之间的关系可能正面临重大转折。该报告引述匿名消息人士称，OpenAI 的高管们正在考虑公开指控微软在合作过程中存在反竞争行为。此外，OpenAI 还在讨论是否寻求对与微软的合同进行联邦监管审查。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-8877f036c3ac69cfcf0f02a9452bb68c96f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 希望能够削弱微软对其知识产权和计算资源的控制，但该初创公司在完成其盈利转型的过程中仍需获得微软的批准。目前，两家公司在 OpenAI 以 30 亿美元收购 AI 编码初创公司 Windsurf 的交易上处于对峙状态。OpenAI 不希望微软获得 Windsurf 的知识产权，因为这可能会增强微软自家 AI 编码工具 GitHub Cop ilot 的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;虽然微软曾是 OpenAI 快速成长的重要推动力，但近几个月来，两者之间的关系却愈发紧张。根据报道，OpenAI 近期尝试减少对微软云服务的依赖，这进一步加剧了双方的矛盾。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在这样的背景下，OpenAI 的高层考虑到与微软的未来合作，显然在寻找新的方向和机会。随着技术竞争的加剧，OpenAI 的举动或将引发行业内更广泛的关注和讨论。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355759</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355759</guid>
      <pubDate>Sun, 11 May 2025 02:36:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 发布开源混合架构推理模型 MiniMax-M1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniMax&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FMiniMax__AI%2Fstatus%2F1934637031193514237" target="_blank"&gt; &lt;u&gt;宣布开源&lt;/u&gt;&lt;/a&gt; MiniMax-M1 模型，据称是全球首款开放权重的大规模混合注意力推理模型。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="898" src="https://static.oschina.net/uploads/space/2025/0617/102018_yqRW_2720166.png" width="1660" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;开源地址：&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fcollections%2FMiniMaxAI%2Fminimax-m1-68502ad9634ec0eeac8cf094" target="_blank"&gt;https://huggingface.co/collections/MiniMaxAI/minimax-m1-68502ad9634ec0eeac8cf094&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMiniMax-AI%2FMiniMax-M1" target="_blank"&gt;https://github.com/MiniMax-AI/MiniMax-M1&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;模型亮点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模型采用 MoE 与 lightning attention 相结合架构&lt;/li&gt; 
 &lt;li&gt;模型大小为 456B ，单 token 激活参数为 45.9 B&lt;/li&gt; 
 &lt;li&gt;M1 原生支持 100 万 token 的上下文长度&lt;/li&gt; 
 &lt;li&gt;包含 40K 和 80K 思维预算两个推理模型&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;该模型基于 MiniMax-Text-01 模型开发，采用了混合专家模型（MoE）架构并结合了闪电注意力机制。M1 的总参数量高达 4560 亿，每个词元激活 459 亿参数，原生支持 100 万词元的上下文长度，是 DeepSeek R1 上下文大小的 8 倍。&lt;/p&gt; 
&lt;p&gt;其闪电注意力机制能高效扩展测试时计算，在生成 10 万词元时，M1 的浮点运算次数（FLOPs）仅为 DeepSeek R1 的 25%。这些特性使其特别适用于需要处理长输入和深度思考的复杂任务。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f4ba5c8b3006317bbd9481e2dbc663ea0c9.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/103148_wgeZ_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355755/minimax-m1-reasoning-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355755/minimax-m1-reasoning-model</guid>
      <pubDate>Sun, 11 May 2025 02:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通义千问 Qwen3 全系适配 MLX</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通义千问团队&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FL-QbHv7Rggh6TX38Vh21nw" target="_blank"&gt;宣布&lt;/a&gt;&lt;/u&gt;正式开源 Qwen3 全系列 32 款 MLX 量化模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-a657c8e40fd173032c06f858e80bd13ebf0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;MLX 是开源机器学习框架，专为苹果芯片深度适配。MLX 框架可高效地训练和部署 AI 大模型，被越来越多的 AI 开发者采用。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;为更好服务开发者，通义团队推出基于 MLX 框架深度优化的全部 Qwen3 系列模型，每款模型都有 4bit、6bit、8bit 和 BF16 等 4 种不同精度的量化版本，即共有 32 款官方的 Qwen3 MLX 模型一次性全开源。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1292" src="https://static.oschina.net/uploads/space/2025/0617/101118_B0E4_2720166.png" width="1734" referrerpolicy="no-referrer"&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/101200_Iohm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;现在，从 Mac Pro、Mac Studio 到 Mac mini、 MacBook ，再到 iPad ，甚至内存更小的设备如 iPhone，都能轻松部署 Qwen3。&lt;/p&gt; 
&lt;p&gt;下载地址：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Huggingface：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fcollections%2FQwen%2Fqwen3-67dd247413f0e2e4f653967f" target="_blank"&gt;https://huggingface.co/collections/Qwen/qwen3-67dd247413f0e2e4f653967f…&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;ModelScope： &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fcollections%2FQwen3-9743180bdc6b48" target="_blank"&gt;https://modelscope.cn/collections/Qwen3-9743180bdc6b48&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355751/qwen3-mlx</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355751/qwen3-mlx</guid>
      <pubDate>Sun, 11 May 2025 02:12:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
