<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 16 May 2025 02:40:57 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>微软 Copilot 应用开始支持「Hey Copilot」语音唤醒词</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软于 5 月 14 日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindows-insider%2F2025%2F05%2F14%2Fcopilot-on-windows-hey-copilot-begins-rolling-out-to-windows-insiders%2F" target="_blank"&gt;发布博文&lt;/a&gt;，邀请 Windows Insider 项目成员测试新版 Microsoft Copilot 应用程序（版本 1.25051.10.0 及以上）。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5a34382c61b9b7b18278a027534f39f7e0d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;用户在新版 Copilot 应用中启用相关选项后，可通过「Hey Copilot」唤醒词，在 PC 解锁且功能开启时、唤醒 Copilot 开启 AI 聊天，无需点击或输入。微软表示，用户在工作或思考时无需手动操作，即可获得帮助。&lt;/p&gt; 
&lt;p&gt;提问时，屏幕会显示 Copilot 麦克风图标，并伴随提示音，表明 Copilot 正在倾听。结束对话可点击 X 按钮，或在几秒无交互后自动结束，并发出确认音。&lt;/p&gt; 
&lt;p&gt;微软强调，设备仅在本地识别唤醒词，采用 10 秒内存音频缓冲区，不录音或本地存储数据。一旦识别到唤醒词，Copilot Voice 浮动界面将出现，随后音频会传输至云端处理用户请求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350160/copilot-on-windows-hey-copilot</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350160/copilot-on-windows-hey-copilot</guid>
      <pubDate>Fri, 16 May 2025 02:17:53 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>雷军：小米自研手机 SoC 芯片「玄戒 O1」将于 5 月下旬发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;小米集团创始人雷军发布微博透露，造芯十年，小米自主研发设计的手机 SoC 芯片名字叫「玄戒 O1」，将在 5 月下旬发布。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;和大家分享一条消息：&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;小米自主研发设计的手机 SoC 芯片，名字叫，玄戒 O1，即将在 5 月下旬发布。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;感谢大家支持！&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="266" src="https://oscimg.oschina.net/oscnet/up-a36d75d9b55368c7956744282be4ebb4cec.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="274" src="https://oscimg.oschina.net/oscnet/up-4d662277ff9587e8953da3929f020383f21.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;对此，人民网也发文点评称：「最近一年，小米在新能源汽车、国产芯片等领域接连带来突破创新。这证明了，只要坚定实干，就没有不可逾越的高山；只要奋起直追，后来者永远有机会。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="332" src="https://oscimg.oschina.net/oscnet/up-5bd8371176fd6755e7b2635cd8c858f5fce.png" width="500" referrerpolicy="no-referrer"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350157</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350157</guid>
      <pubDate>Fri, 16 May 2025 02:13:53 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 发布语音模型 MiniMax Speech 02</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniMax 现已&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4pa3KCRLwDlVZHCA_9R0iA"&gt;推出&lt;/a&gt;基于 AR Transformer 模型的高质量 TTS 系统 ——MiniMax Speech 02。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6f2d41090b2c4d82bff733ccc15046faf46.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;MiniMax Speech 02 具有足够强的泛化能力，&lt;strong&gt;能够轻松驾驭 32 语种、不同口音、不同情绪的人声&lt;/strong&gt;。该模型系统的核心创新之处在于其内在的 Zero-Shot 能力，其命为 Intrinsic Zero-Shot Text-to-Speech with a Learnable Speaker Encoder。&lt;/p&gt; 
&lt;p&gt;在提供更优异听感同时，MiniMax Speech 02 做到了价格更低，分别是 ElevenLabs Flash V2.5 与 Mutilingual V2 的一半与四分之一。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/101019_9RYc_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在国际权威的 Artificial Analysis 上，MiniMax Speech 02 也通过全球用户测评，位列全球第一。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/100728_YHJY_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/100932_INxq_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;体验 MiniMax Speech&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.minimax.io%2Faudio"&gt;https://www.minimax.io/audio&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.minimaxi.com%2Faudio"&gt;https://www.minimaxi.com/audio&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;更多技术细节、实验对比数据、以及开源的多语言测试集，阅读技术报告&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;GitHub：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMiniMax-AI%2FMiniMax-AI.github.io%2Fblob%2Fmain%2Ftts_tech_report%2FMiniMax_Speech.pdf"&gt;https://github.com/MiniMax-AI/MiniMax-AI.github.io/blob/main/tts_tech_report/MiniMax_Speech.pdf&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Hugging Face：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fspaces%2FMiniMaxAI%2FMiniMax-Speech-Tech-Report"&gt;https://huggingface.co/spaces/MiniMaxAI/MiniMax-Speech-Tech-Report&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350155/minimax-speech-02</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350155/minimax-speech-02</guid>
      <pubDate>Fri, 16 May 2025 02:08:53 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>梁文锋等发表 DeepSeek V3 回顾性论文</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;DeepSeek 创始人梁文锋等人近日发表了一篇名为《Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for Al Architectures（深入了解 DeepSeek-V3：人工智能架构硬件的扩展挑战与思考）》的回顾性论文。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;深入分析了 DeepSeek-V3/R1 模型架构及其人工智能基础架构，重点介绍了一些关键创新，如提高内存效率的多头潜意识（MLA）、优化计算与通信权衡的混合专家（MoE）架构、释放硬件能力全部潜力的 FP8 混合精度训练，以及最大限度降低集群级网络开销的多平面网络拓扑结构。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="308" src="https://oscimg.oschina.net/oscnet/up-7d3d04217f33b8b740ddaf8bd1753b2ce4b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;该研究表明，当前大语言模型（LLM）的迅速扩展暴露了现有硬件架构的许多局限性，比如内存容量、计算效率和互连带宽。DeepSeek-V3 在 2048 块 NVIDIA H800GPU 集群上训练，通过有效的硬件感知模型设计，克服了这些限制，实现了经济高效的大规模训练和推理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="348" src="https://oscimg.oschina.net/oscnet/up-1fa090ba2ba63a45ee9c1b284fe2b778ca0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;具体来说，论文中提出了几个关键点。首先，DeepSeek-V3 采用了先进的 DeepSeekMoE 架构和多头潜在注意力（MLA）架构，极大地提高了内存效率。MLA 技术通过压缩键值缓存，显著降低了内存使用，使得每个 token 只需 70KB 的内存，相比其他模型大幅减少。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其次，DeepSeek 还实现了成本效益的优化。通过其混合专家（MoE）架构，DeepSeek-V3 在激活参数的数量上实现了显著的降低，训练成本相比于传统密集模型降低了一个数量级。此外，该模型在推理速度上也进行了优化，采用双微批次重叠架构来最大化吞吐量，确保 GPU 资源得到充分利用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;DeepSeek 在未来硬件设计方面提出了创新的思考。他们建议通过联合优化硬件和模型架构，来应对 LLM 的内存效率、成本效益和推理速度三大挑战。这为日后的 AI 系统开发提供了宝贵的参考。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;更多详情可查看具体论文：&lt;/span&gt;&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2505.09343" target="_blank"&gt;https://arxiv.org/pdf/2505.09343&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350152</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350152</guid>
      <pubDate>Fri, 16 May 2025 01:56:53 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Go 语言读写 Excel 基础库</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;&lt;img src="https://xuri.me/excelize/images/excelize.svg" alt="Excelize" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;Excelize&lt;/a&gt; 是 Go 语言编写的一个用来操作 Office Excel 文档类库，基于 ECMA-376 Office OpenXML 标准。可以使用它来读取、写入 XLSX 文件。相比较其他的开源类库，Excelize 支持写入原本带有图片 (表) 的文档，还支持向 Excel 中插入图片，并且在保存后不会丢失图表样式。&lt;/p&gt; 
&lt;h3&gt;安装&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;go get github.com/xuri/excelize/v2
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;创建 XLSX&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f := excelize.NewFile()
    // Create a new sheet.
    index := f.NewSheet("Sheet2")
    // Set value of a cell.
    f.SetCellValue("Sheet2", "A2", "Hello world.")
    f.SetCellValue("Sheet1", "B2", 100)
    // Set active sheet of the workbook.
    f.SetActiveSheet(index)
    // Save xlsx file by the given path.
    err := f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;读取已有文档&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Get value from cell by given worksheet name and axis.
    cell, err := f.GetCellValue("Sheet1", "B2")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cell)
    // Get all the rows in the Sheet1.
    rows, err := f.GetRows("Sheet1")
    for _, row := range rows {
        for _, colCell := range row {
            fmt.Print(colCell, "\t")
        }
        fmt.Println()
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入图表&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/xuri/excelize/master/test/images/chart.png?version=1" alt="chart" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    categories := map[string]string{"A2": "Small", "A3": "Normal", "A4": "Large", "B1": "Apple", "C1": "Orange", "D1": "Pear"}
    values := map[string]int{"B2": 2, "C2": 3, "D2": 3, "B3": 5, "C3": 2, "D3": 4, "B4": 6, "C4": 7, "D4": 8}
    f := excelize.NewFile()
    for k, v := range categories {
        f.SetCellValue("Sheet1", k, v)
    }
    for k, v := range values {
        f.SetCellValue("Sheet1", k, v)
    }
    err := f.AddChart("Sheet1", "E1", `{"type":"col3DClustered","series":[{"name":"Sheet1!$A$2","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$2:$D$2"},{"name":"Sheet1!$A$3","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$3:$D$3"},{"name":"Sheet1!$A$4","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$4:$D$4"}],"title":{"name":"Fruit 3D Clustered Column Chart"}}`)
    if err != nil {
        fmt.Println(err)
        return
    }
    // Save xlsx file by the given path.
    err = f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入图片&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"
    _ "image/gif"
    _ "image/jpeg"
    _ "image/png"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Insert a picture.
    err = f.AddPicture("Sheet1", "A2", "./image1.png", "")
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture to worksheet with scaling.
    err = f.AddPicture("Sheet1", "D2", "./image2.jpg", `{"x_scale": 0.5, "y_scale": 0.5}`)
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture offset in the cell with printing support.
    err = f.AddPicture("Sheet1", "H2", "./image3.gif", `{"x_offset": 15, "y_offset": 10, "print_obj": true, "lock_aspect_ratio": false, "locked": false}`)
    if err != nil {
        fmt.Println(err)
    }
    // Save the xlsx file with the origin path.
    err = f.Save()
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;还有其他一些功能，在这里就不一一列举了，详细使用文档以及获取后期的维护更新可以从项目的主页获取&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;github.com/xuri/excelize&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/xuri/blog/3057381</link>
      <guid isPermaLink="false">https://my.oschina.net/xuri/blog/3057381</guid>
      <pubDate>Sat, 10 May 2025 10:24:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>AI 推理大模型或在一年内减缓增长</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 研究机构 Epoch AI 发布&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fepoch.ai%2Fgradient-updates%2Fhow-far-can-reasoning-models-scale" target="_blank"&gt;《推理模型能扩展多远（How far can reasoning models scale?）》&lt;/a&gt;报告，其中对推理模型的现状和未来作出了分析总结。&lt;/p&gt; 
&lt;p&gt;Epoch AI 通过各家开源的技术报告，来分析了目前推理模型的训练成本，同时也进一步总结，目前前沿的推理模型其推理训练规模仍未见顶，还能持续扩展（scalable），并且推理模型还有潜力在短期内快速实现能力拓展。&lt;/p&gt; 
&lt;p&gt;Epoch AI 的分析表明，人工智能行业可能无法在更长的时间内从推理人工智能模型中获得巨大的性能提升。根据该报告的研究结果，推理模型的进展最快可能在一年内放缓。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2b0a64ac6bff63c39819e86da31b4e92548.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;近几个月来，OpenAI 的 o3 等推理模型在人工智能基准测试中取得了大幅提升，尤其是在衡量数学和编程技能的基准测试中。这些模型可以对问题进行更多计算，从而提高性能，但缺点是它们完成任务的时间比传统模型更长。&lt;/p&gt; 
&lt;p&gt;Epoch AI 提到，如果推理阶段的算力需求见顶，那么其带来的增长率将收敛，大概是每年增长 4 倍，不会像 o1 到 o3 那样拥有「跳跃式增长」——几个月增长 10 倍的态势。&lt;/p&gt; 
&lt;p&gt;基于上述情况，Epoch AI 表示，如果推理模型的训练阶段只比前沿推理模型低几个（比如说不到三个）数量级，这种增长率可能在一年内减缓。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</guid>
      <pubDate>Sat, 10 May 2025 10:16:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>这就是 univer</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;零. 开篇&lt;/h1&gt; 
&lt;div&gt;
  这篇文章旨在帮助新人快速熟悉开源项目 univer 的架构及代码，也是我过去一段时间参与到 univer 开发中的学习和总结，肯定有不够准确或者理解偏差，欢迎大家评论指正 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第壹章，会聊聊我对 univer 架构的理解，univer 是如何拆分模块，以及模块之间的依赖关系。然后将 univer 放入 MVC 的架构模式中，分别分析下其模型层、视图层、控制器的边界和职责 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第贰章，我们先来看看 univer sheet 的模型层数据结构设计，如何区分 workbook、sheet、row、column、style 等，了解他们的包含关系，这对后面深入理解代码是有帮助的 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第叁、肆章，我将从两条控制链路来分析 univer 的代码，一条链路是 univer 启动和初始化渲染的过程。在这条链路中，是从模型层到视图层的过程。另外一条链路是 univer 响应用户事件，并且触发模型层数据变更，页面重新渲染，在这条链路中，是从视图层到模型层的过程。在这两部分，我们会涉及到大量的源码分析，在保留代码主逻辑的前提，删除了边界 case 的代码。同时在每个代码块第一行，表示该代码块所在的 TS 文件，这样便于直接阅读源码 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;壹. 对代码架构的理解&lt;/h1&gt; 
&lt;blockquote&gt; 
 &lt;div&gt;
   外表的美只能取悦于人的眼睛，而内在的美却能感染人的灵魂。 ——伏尔泰 
 &lt;/div&gt; 
&lt;/blockquote&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;Univer 中的模块拆分和依赖关系&lt;/h2&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;无依赖环原则&lt;/h3&gt; 
&lt;div&gt;
  软件架构的规则其实就是排列组合代码块的规则，软件架构会根据业务域来将组织项目代码，将项目拆分成不同的模块，各个模块做到关注点分离，同时模块之间有明确的依赖关系，并且依赖关系是一个单向无环图，也就是 
 &lt;strong&gt;无依赖环原则&lt;/strong&gt;。正如下面图中所示，系统级、应用级业务逻辑是整个项目最核心的部分，同时也是应用最稳定的部分，应该放在架构的最里层，其他如用户界面、渲染引擎、前端框架、持久化的数据库，这些在架构演进的过程中，可能被替换，所以他们都依赖于最中心的业务实体，置于外层 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp;&amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img align="left" alt="" height="327" src="https://oscimg.oschina.net/oscnet/up-3ab4dcd10c5e846f57c70e486ce2f37951d.png" width="340" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;（图注：core、base-sheet、base-render、base-ui、ui-plugin-sheet 对应仓库中 packages 下不同文件夹）&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer 在整个架构设计中，尽量保证核心模块（core）仅包含最核心的业务逻辑，在核心业务逻辑之上所构筑的其他功能，都是通过插件化来提供的，这也是 
 &lt;strong&gt;微内核架构&lt;/strong&gt;的思想。在上图中，base-render、base-ui、base-sheet 等都是插件化的，为 core 提供额外的能力。如 base-sheet 完善 sheet 相关功能，base-render（canvas 渲染引擎） 提供 canvas 渲染能力，公式引擎提供公式相关的计算和解析等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;依赖反转&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  直观理解，我们可能会认为，core 模块依赖于 base-render 模块来做 canvas 渲染，依赖 base-ui 来做页面框架渲染及样式菜单等，base-ui 又依赖于 React 框架来渲染组件。这样会有一个问题，核心模块依赖于其他模块，其他模块往往是不稳定的，比如样式菜单，我们可能会经常改变位置或者样式，这也有可能导致核心模块易变。在 Univer 中，利用了 
 &lt;strong&gt;依赖反转（Dependency Inversion）&lt;/strong&gt;解决上面面临的问题，这也就是上面图中，所有的外面的环都依赖内部的环，而内部的环不能依赖外部环。在 Univer 中引入了 
 &lt;strong&gt;依赖注入（DI）&lt;/strong&gt;，通过依赖注入的方式，反转依赖，避免了核心层对外层的依赖，通过下面代码示例来解释会更清晰一些 
&lt;/div&gt; 
&lt;div&gt;
  举个例子，在没有依赖注入，我们可能会写这样的代码： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    private _commandService = new CommandService(); 
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代码中，SheetPlugin 类依赖于 CommandService 类，CommandService 类中方法的变更直接会影响到 SheetPlugin，SheetPlugin 可能也需要修改，导致 SheetPlugin 的不稳定 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="256" src="https://oscimg.oschina.net/oscnet/up-d90622f22bde7a5dae35b7fe4953a7dff37.png" width="812" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  我们通过依赖注入，代码如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    constructor(
        // ...
        @ICommandService private readonly _commandService: ICommandService,
        // ...
    )

    otherMethod(){
        this._commandService.registerCommand(SomeCommand);
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面的代码中，声明了 _commandService 属性拥有 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口，通过相关的依赖绑定，就可以在 SheetPlugin 的方法中调用 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口所定义的方法了。这样 SheetPlugin 依赖于 ICommandService 接口，同时 CommandService 类实现了这个接口。这样就解耦了 SheetPlugin 和 CommandService 之间的直接依赖关系，图示如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="274" src="https://oscimg.oschina.net/oscnet/up-9fb80a8045b6fa4c8ac48c0f51d982460ba.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  如上图，我们通过 ICommandService 接口实现依赖反转，在没有 ICommandService 接口下，SheetPlugin 直接依赖于 CommandService，导致核心业务逻辑（SheetPlugin）的不稳定。通过引入 ICommandService 接口，及依赖注入，如果将虚线框看成一个整体，CommandService 类指向（实现接口）虚线框，最终实现依赖反转，保证了核心业务逻辑稳定性 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;浅谈 Univer 中的 MVC 架构模式&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="293" src="https://oscimg.oschina.net/oscnet/up-bacff8d1ee26d5039c6ff41f3b7489fef0d.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  MVC 在整个 GUI 编程领域已经有了 50 多年的历史了，但是 MVC 却一直没有一个明确的定义。如上图，就是两种比较典型的 MVC 变种，在 
 &lt;strong&gt;MVC with ASP.NET&lt;/strong&gt; 中，控制器负责管理视图和模型，当控制器改变模型层中数据后，通过一些订阅机制，视图层直接读取模型层中数据，更新视图。在 
 &lt;strong&gt;MVC with Rails &lt;/strong&gt;中，视图层不直接和模型层交互，通过控制器做了一层代理，视图层需要通过控制器从模型层取数据进行渲染。这样有个好处就是视图层和模型层完全的解耦，控制流会更清晰 
&lt;/div&gt; 
&lt;div&gt;
  打开 univer 工程代码，我们可以发现大量以 
 &lt;code&gt;controller&lt;/code&gt; 、 
 &lt;code&gt;view&lt;/code&gt; 和 
 &lt;code&gt;model&lt;/code&gt;后缀命名的文件，大致也能看出其采用了传统的 MVC 架构模式。Univer 中 MVC 架构更类似于 
 &lt;strong&gt;MVC with Rails&lt;/strong&gt;, 因为视图层不直接读取 Model 层数据，也不订阅模型层的改变（下面会提到，是订阅了 Mutations），而是做了一层数据缓存（类似 ViewModel）， 
 &lt;u&gt;SheetSkeleton &lt;/u&gt;类 
&lt;/div&gt; 
&lt;div&gt;
  在最开始看工程代码时，一些疑虑一直萦绕在脑海： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 是如何组织和管理模型层的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 中控制器有哪些职责，如何保证控制器代码架构清晰？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 的视图层怎么组织和管理的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  阅读源码，谈谈 Univer 如何从架构层面回答上面的问题 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;模型层（Model）&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  Univer 的整个模型层会比较薄，拿 univer sheet 来举例，在 core 模块中，通过 
 &lt;u&gt;Workbook&lt;/u&gt; 和 
 &lt;u&gt;Worksheet&lt;/u&gt; 类来管理和 sheet 相关的模型数据，提供了相关模型数据存储和管理的工作。如在 
 &lt;u&gt;Worksheet&lt;/u&gt; 类中，有 
 &lt;code&gt;row-manager&lt;/code&gt;、 
 &lt;code&gt;column-manager&lt;/code&gt;、相关的类和方法来管理每个 sheet 模型数据，拿 
 &lt;code&gt;row-manager&lt;/code&gt;来说，我们可以获取表格行的一些信息和数据： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;getRowData(): ObjectArray&amp;lt;IRowData&amp;gt;;
getRowHeight(rowPos: number): number;
getRowOrCreate(rowPos: number): IRowData;
// ...&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  很容易理解，我们渲染的数据不能够直接使用底层模型数据，往往需要经过一定的计算，生成一个用于渲染的「模型层」才能用于直接的视图渲染。比如在渲染视图的时候，我们需要计算行、列的总高度。通过每行的文档内容，计算能够容纳数据的最小行高度。通过一系列的计算，最终确定 sheet 页面的布局，用于最终的渲染。而这一系列的计算都放在了视图层 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 类中 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;控制器（Controller）的职责&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img alt="" height="428" src="https://oscimg.oschina.net/oscnet/up-95ce27fa3497387181c703081a693a984be.png" width="600" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在传统的 MVC 架构中，视图和模型层往往职责比较明晰，而控制器承担了主要的业务逻辑，和管理视图层、模型层的任务，往往会比较臃肿，那么 univer 是如何避免控制器臃肿的呢？在 Univer 中，控制器（MVC 中的控制器）进一步拆解为 
 &lt;strong&gt;Controllers&lt;/strong&gt;（Univer 中狭义的控制器）、 
 &lt;strong&gt;Commands&lt;/strong&gt; 和 
 &lt;strong&gt;Services&lt;/strong&gt;。同时在控制器中，几乎包含了 univer 所有的业务逻辑，他们各司其职，保证了 univer 应用的正常运行 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Controllers 职责&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    初始化一些渲染逻辑和事件的监听，如在 
   &lt;u&gt;SheetRenderController 类&lt;/u&gt;中，在应用 
   &lt;code&gt;Rendered&lt;/code&gt;生命周期执行，会去初始化页面的数据刷新（_initialRenderRefresh），会去监听 Commands 的执行，涉及到 Mutation 修改模型层，还会触发页面渲染逻辑 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和视图层交互，拿到视图层的一些数据信息。如在 
   &lt;u&gt;AutoHeightController &lt;/u&gt;类中，会根据 Commands 所需，通过视图层计算 sheet 自动行高 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    绑定 UI 事件，如在 
   &lt;u&gt;HeaderResizeController &lt;/u&gt;类中，会在应用 
   &lt;code&gt;Rendered&lt;/code&gt;生命周期执行，在初始化中，为 spreadsheetRowHeader、spreadsheetColumnHeader 绑定 hover 事件，显示和隐藏 resize header（用于调节行列高度和宽度），也为 resize header 绑定 pointer down/move/up 等事件，这样 resize header 就会响应拖拽移动，处理相关用户操作，最终也会反应到模型层的修改和视图层的更新 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Commands 职责&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Commands 可以理解为用户的单次交互操作，比如合并单元格、清除选区、插入行列、设置单元格样式等，并且更改模型层，触发视图层渲染。 
 &lt;code&gt;Commands&lt;/code&gt; 有三种类型： 
 &lt;code&gt;COMMAND&lt;/code&gt;、 
 &lt;code&gt;MUTATION&lt;/code&gt;、 
 &lt;code&gt;OPERATION&lt;/code&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;COMMAND&lt;/strong&gt; 就是用户的一次交互操作，有用户行为触发，可以派生出另外一个 
   &lt;code&gt;COMMAND&lt;/code&gt;，比如用户点击菜单中 text wrap 菜单项，会触发 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt;， 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt; 会派生出 
   &lt;code&gt;SetStyleCommand&lt;/code&gt; 统一处理所有样式的更改。一个 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生另外一个 
   &lt;code&gt;COMMAND&lt;/code&gt;，但是不能分叉，因为我们需要在 
   &lt;code&gt;COMMAND&lt;/code&gt; 中处理 undo/redo 相关操作（后面 undo/redo 可能会移到数据层）。但是一个 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生出多个 
   &lt;code&gt;MUTATION&lt;/code&gt; 和 
   &lt;code&gt;OPERATION&lt;/code&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;MUTATION&lt;/strong&gt; 可以理解为对模型层数据的原子操作，比如 
   &lt;code&gt;SetRangeValuesMutation&lt;/code&gt; 修改选区范围内的单元格样式和值， 
   &lt;code&gt;SetWorksheetRowHeightMutation&lt;/code&gt;修改选区范围内行的高度。MUTATION 的执行，不仅会修改模型数据，同时也会触发视图的重新渲染。MUTATION 中修改的数据需要处理协同，和解决协同中的冲突 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;OPERATION&lt;/strong&gt; 是对应用状态的变更，是应用的某个临时状态，如页面滚动位置、用户光标位置、当前的选区等，不涉及到协同和解决冲突的问题，主要用于之后 live share （类似于飞书的 magic share）等功能 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Services 职责&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Services 为整个 Univer 应用提供各种服务，是关注点分离（Separate of concern）在 Univer 项目架构中的承载者 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    管理应用生命周期，如 
   &lt;u&gt;LifecycleService &lt;/u&gt;类，保存应用生命周期的状态值，并提供 
   &lt;code&gt;subscribeWithPrevious&lt;/code&gt;方法供其他模块订阅应用生命周期状态值的变更，并做响应任务执行，如依赖的初始化等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    处理应用的 History 操作和存储历史操作，这样用户可以 undo/redo 之前的操作。在 
   &lt;u&gt;LocalUndoRedoService &lt;/u&gt;类中，通过 
   &lt;code&gt;pushUndoRedo&lt;/code&gt; 方法将 undo/redo 信息推入栈中，通过 
   &lt;code&gt;updateStatus&lt;/code&gt; 方法触发 undo/redo 操作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    处理网络 IO 和 websocket 链接 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  总结一下，将上面 Controllers、Commands、Services 统称为 MVC 中的控制器，他们完成了 univer 中大量业务逻辑，下面列举了其主要职责（在叁、肆部分，会更加详细的分析控制器是如何工作的）： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    负责整个应用的生命周期管理 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    绑定和响应 UI 事件，如双击、光标移动等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    控制视图的渲染和触发渲染的逻辑 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和视图层通信，如拿计算后页面布局信息 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通过 Command/Mutation 改变模型层，触发界面渲染 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    处理 undo/redo 相关工作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    负责协作、和网络 IO 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;视图层（View）&lt;/h3&gt; 
&lt;div&gt;
  在 Univer 中，有两种渲染方式：一种是 Canvas 渲染引擎，一种是 React 通过 DOM 进行渲染。Canvas 渲染引擎主要渲染 sheet 的主体部分：行表头、列表头、sheet 单元格、选区、单元格编辑器等。React 主要用于渲染顶部菜单栏、右键菜单栏、浮窗等 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 主体部分选用 Canvas 进行渲染，保证了在大数据量下表格渲染的极致性能体验，和流畅的动画效果。而菜单主要需要响应用户事件，DOM 往往比 Canvas 更具优势 
&lt;/div&gt; 
&lt;div&gt;
  Canvas 渲染所需要的组件、服务都在 
 &lt;code&gt;base-render&lt;/code&gt;文件夹中，如 sheet 渲染相关的： 
 &lt;u&gt;Spreadsheet、SpreadsheetRowHeader、SpreadsheetColumnHeader &lt;/u&gt;等。同时在 Canvas 组件上定义了一套事件响应机制，保证了各个组件能够独立响应事件，但是并不会在视图层处理这些事件。这些事件都需要在 Controllers 中处理 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;code&gt;Base-ui/Components&lt;/code&gt; 文件夹中代码负责菜单基础组件的渲染和用户事件的发布，base-ui 模块也负责整个应用的框架渲染。如在 
 &lt;u&gt;DesktopUIController &lt;/u&gt;类中，bootstrapWorkbench 启动了整个应用框架渲染，以及 Canvas 元素的挂载等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_13"&gt;&lt;/span&gt; 
&lt;h1&gt;贰. Univer sheet 数据结构&lt;/h1&gt; 
&lt;div&gt;
  了解一个项目，先从其数据结构开始 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 相关的数据类型定义在 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Ftree%2Fdev%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces" rel="nofollow" target="_blank"&gt;Interfaces&lt;/a&gt; 文件夹中，包含关系如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="576" src="https://oscimg.oschina.net/oscnet/up-538aaa85e011f7227788f7d59ab0abe1447.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer sheet 整体的数据类型定义如上图所示，一个 workbook 包含多个 sheets，sheets 所引用的 styles 字段定义在了顶层 workbook 上，保证了样式的复用，减少内存开销，这也是和 Excel 保持一致。在 IWorksheetConfig 中，定义了 cellData 字段，这是一个二维矩阵，用于持久化单元格信息，也就是 ICellData 中定义的类型信息， 
 &lt;strong&gt;p 是指富文本，接口类型 IDocumentData，也就是一篇 univer doc，这也是 univer 设计的独到之处，univer sheet 的每个单元格都可以转变成一个 univer doc。&lt;/strong&gt;s 字段大多是一个字符串 id，指向 IWorkbookConfig 中 styles 字段，从中检索出该单元格的样式信息 
&lt;/div&gt; 
&lt;div&gt;
  图中并没有包含各个接口定义的所有字段，想了解更多，建议直接查看上面的 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2F9a505ec3ba9de96677b9caaa821e287e71ebe0cf%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces%2FIWorkbookData.ts%23L12" rel="nofollow" target="_blank"&gt;类型定义文件&lt;/a&gt;，上面也有相应注释 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_14"&gt;&lt;/span&gt; 
&lt;h1&gt;叁. 应用启动到渲染的过程&lt;/h1&gt; 
&lt;div&gt;
  Univer 如何渲染页面，其实就是 univer 应用启动的整个过程，也是模型层到视图层的整个过程。在了解页面渲染前，我们先了解下 univer 的生命周期，其实在上面 Services 部分也有所提及 
&lt;/div&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;应用的生命周期&lt;/h2&gt; 
&lt;pre&gt;&lt;code class="language-javascript"&gt;export const enum LifecycleStages {
    /**
     * Register plugins to Univer.
     */
    Starting,
    /**
     * Univer business instances (UniverDoc / UniverSheet / UniverSlide) are created and services or controllers provided by
     * plugins get initialized. The application is ready to do the first-time rendering.
     */
    Ready,
    /**
     * First-time rendering is completed.
     */
    Rendered,
    /**
     * All lazy tasks are completed. The application is fully ready to provide features to users.
     */
    Steady,
}&lt;/code&gt;&lt;/pre&gt; 
&lt;div&gt;
  Univer 生命周期有四个阶段， 
 &lt;code&gt;Starting&lt;/code&gt;、 
 &lt;code&gt;Ready&lt;/code&gt;、 
 &lt;code&gt;Rendered&lt;/code&gt; 和 
 &lt;code&gt;Steady&lt;/code&gt;。如在 Starting 阶段去注册各个插件到 univer 上面，在 Ready 阶段实例化 UniverSheet，并且执行各个插件的初始化函数，Rendered 阶段完成首次渲染，Steady 阶段，应用完成启动，用户可以使用完整功能 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;各个生命周期状态在什么时候触发呢？&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Starting 状态&lt;/strong&gt;：在 
 &lt;code&gt;_tryStart&lt;/code&gt;方法中， 
 &lt;u&gt;LifecycleService &lt;/u&gt;类实例化，应用进入 Staring 阶段， 
 &lt;strong&gt;在这个阶段也会去执行插件的 onStarting 钩子函数&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Ready 状态&lt;/strong&gt;：在实例化 
 &lt;u&gt;UniverSheet&lt;/u&gt; 后，在 
 &lt;code&gt;_tryProgressToReady&lt;/code&gt;方法中，设置 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值为 Ready， 
 &lt;strong&gt;在这个阶段也会执行各个插件的 onReady 钩子函数&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Rendered 状态&lt;/strong&gt;：在 
 &lt;u&gt;DesktopUIController&lt;/u&gt; 中，bootStrap 整个应用后，标记 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值为 Rendered 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Steady 状态&lt;/strong&gt;：在 Rendered 状态后，延迟 3000 秒触发 Steady 状态 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  通过 @OnLifecycle 注解，我们可以精确控制某个类在什么生命周期阶段实例化，如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {
    //...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代码中，SheetRenderController 将在 Rendered 阶段实例化 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt; 
&lt;h2&gt;启动到渲染的整个过程&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-92859da81dc29e5183cf26c4e682302d65b.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第一步：&lt;/strong&gt;创建 
 &lt;u&gt;Univer &lt;/u&gt;实例、注册 sheet 所需的相关插件和创建 univer sheet 实例 
&lt;/div&gt; 
&lt;div&gt;
  注册的插件及相关功能如下： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-docs：用於单元格和公式的编辑 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-render：Canvas 渲染引擎，也包含 sheet、doc、slide 所需的基础组件，负责 Canvas 渲染整个过程 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-sheets：管理 sheet canvas 相关的渲染，如 row header、column header、单元格等，同时也处理大量 sheet 相关业务逻辑 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-ui：管理 React DOM 渲染的基础组件，如菜单相关的组件。同时也负责整个 univer sheet 页面框架的渲染，以及和用户交互的操作都会放在这个插件中，如快捷键注册、复制、剪切黏贴等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    ui-plugin-sheets：负责一些基础 UI 的渲染和业务逻辑，如右键菜单、单元格富文本编辑相关的任务 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  插件注册完成，通过 createUniverSheet 方法，创建 univer sheet 实例 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;/**
 * Create a univer sheet instance with internal dependency injection.
 */
createUniverSheet(config: Partial&amp;lt;IWorkbookConfig&amp;gt;): Workbook {
    let workbook: Workbook;
    const addSheet = () =&amp;gt; {
        workbook = this._univerSheet!.createSheet(config);
        this._currentUniverService.addSheet(workbook);
    };

    if (!this._univerSheet) {
        this._univerSheet = this._rootInjector.createInstance(UniverSheet);

        this._univerPluginRegistry
            .getRegisterPlugins(PluginType.Sheet)
            .forEach((p) =&amp;gt; this._univerSheet!.addPlugin(p.plugin as unknown as PluginCtor&amp;lt;any&amp;gt;, p.options));
        this._tryStart();
        this._univerSheet.init();
        addSheet();

        this._tryProgressToReady();
    } else {
        addSheet();
    }

    return workbook!;
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  通过上面代码，我们可以看到，univer 将上面注册的插件中 PluginType.Sheet 类型的插件，重新注册到了 univerSheet 实例上，然后通过 _tryStart 应用进入 Starting 阶段，然后初始化，通过 addSheet 实例化 
 &lt;u&gt;Workbook&lt;/u&gt;，完成了模型层的初始化。到这里模型数据准备完毕，univer 进入到 Ready 阶段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第二步&lt;/strong&gt;：初始化页面框架，渲染页面框架 
&lt;/div&gt; 
&lt;div&gt;
  在上面讲述 Univer 应用生命周期时，提到过插件会在 univer 不同的生命周期执行，在这一步，我们重点关注 base-ui 插件 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// base-ui-plugin.ts
override onStarting(_injector: Injector): void {
    this._initDependencies(_injector);
}

override onReady(): void {
    his._initUI();
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt;
    如上代码，base-ui 插件在 onStarting 阶段会去声明和添加依赖，在 onReady 阶段，会去初始化渲染整个页面框架，将 View 界面挂载到 container 上。 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;pre&gt;&lt;code class="language-javascript"&gt;// ui-desktop.controller.tsx
bootstrapWorkbench(options: IWorkbenchOptions): void {
    this.disposeWithMe(
        bootStrap(this._injector, options, (canvasElement, containerElement) =&amp;gt; {
            this._initializeEngine(canvasElement);
            this._lifecycleService.stage = LifecycleStages.Rendered;
            this._focusService.setContainerElement(containerElement);

            setTimeout(() =&amp;gt; (this._lifecycleService.stage = LifecycleStages.Steady), STEADY_TIMEOUT);
        })
    );
}
// ...
function bootStrap(
    injector: Injector,
    options: IWorkbenchOptions,
    callback: (canvasEl: HTMLElement, containerElement: HTMLElement) =&amp;gt; void
): IDisposable {
    let mountContainer: HTMLElement;
    // ...
    const root = createRoot(mountContainer);
    const ConnectedApp = connectInjector(App, injector);
    const desktopUIController = injector.get(IUIController) as IDesktopUIController;
    const onRendered = (canvasElement: HTMLElement) =&amp;gt; callback(canvasElement, mountContainer);

    function render() {
        const headerComponents = desktopUIController.getHeaderComponents();
        const contentComponents = desktopUIController.getContentComponents();
        const footerComponents = desktopUIController.getFooterComponents();
        const sidebarComponents = desktopUIController.getSidebarComponents();
        root.render(
            &amp;lt;ConnectedApp
                {...options}
                headerComponents={headerComponents}
                contentComponents={contentComponents}
                onRendered={onRendered}
                footerComponents={footerComponents}
                sidebarComponents={sidebarComponents}
            /&amp;gt;
        );
    }

    // ...
    render();
    // ...
}&lt;/code&gt;&lt;/pre&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代码可以看到，在页面框架挂载并渲染完成后，会去完成 canvas 渲染引擎容器挂载及调整 canvas 尺寸，整个应用进入 Rendered 阶段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：渲染 canvas 界面，完成整个渲染过程 
&lt;/div&gt; 
&lt;div&gt;
  其实这个过程在应用 Ready 阶段就已经开始了 sheet canvas 的初始化和组件组装和添加 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-canvas-view.ts
@OnLifecycle(LifecycleStages.Ready, SheetCanvasView)
export class SheetCanvasView {
    // ...
    constructor(
        // ...
    ) {
        this._currentUniverService.currentSheet$.subscribe((workbook) =&amp;gt; {
            // ...
            const unitId = workbook.getUnitId();
            if (!this._loadedMap.has(unitId)) {
                this._currentWorkbook = workbook;
                this._addNewRender();
                this._loadedMap.add(unitId);
            }
        });
    }

    private _addNewRender() {
        // ...
        if (currentRender != null) {
            this._addComponent(currentRender);
        }
        const should = workbook.getShouldRenderLoopImmediately();
        if (should &amp;amp;&amp;amp; !isAddedToExistedScene) {
            engine.runRenderLoop(() =&amp;gt; {
                scene.render();
            });
        }
        // ...
    }

    private _addComponent(currentRender: IRender) {
        // ...
        currentRender.mainComponent = spreadsheet;
        currentRender.components.set(SHEET_VIEW_KEY.MAIN, spreadsheet);
        currentRender.components.set(SHEET_VIEW_KEY.ROW, spreadsheetRowHeader);
        currentRender.components.set(SHEET_VIEW_KEY.COLUMN, spreadsheetColumnHeader);
        currentRender.components.set(SHEET_VIEW_KEY.LEFT_TOP, SpreadsheetLeftTopPlaceholder);
        // ...
        this._sheetSkeletonManagerService.setCurrent({ sheetId, unitId });
    }

    private _addViewport(worksheet: Worksheet) {
        // ...
        scene
            .addViewport(
                viewMain,
                viewColumnLeft,
                viewColumnRight,
                viewRowTop,
                viewRowBottom,
                viewLeftTop,
                viewMainLeftTop,
                viewMainLeft,
                viewMainTop
            )
            .attachControl();
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代码，其实就是 sheet canvas 渲染的整个过程，首先会去订阅 
 &lt;code&gt;currentSheet$&lt;/code&gt;，如果该 sheet 没有被 render 过，那么就会调用 
 &lt;code&gt;_addNewRender&lt;/code&gt; 方法，添加 sheet 所需的 canvas 渲染组件，添加 viewport，然后将 scene 的渲染添加到渲染引擎的渲染循环中（runRenderLoop） 
&lt;/div&gt; 
&lt;div&gt;
  在上面过程，完成了 sheet 所需 canvas 组件的组装以及添加 viewport，那么 canvas 的首次渲染发生在什么地方呢？和什么生命周期阶段呢？sheet canvas 的渲染被 
 &lt;u&gt;SheetRenderController &lt;/u&gt;类所管理，该类管理了 sheet canvas 的初始化渲染以及监听 Mutations 的变更，然后按需渲染 Canvas 界面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面的代码可以看到，sheet canvas 的渲染时间点是在整个应用 Rendered 阶段，其实也好理解，这个阶段，页面框架才完成挂载到 container 上，同时 sheet canvas 也完成了初始化工作。在 Rendered 阶段，会去订阅 currentSkeleton$ 改变，然后去更新 skeleton，完成页面首次渲染。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
         his._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                // ...
                if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                         ,
                        true
                    );
                }

                 this._sheetSkeletonManagerService.setCurrent({
                    unitId,
                    sheetId,
                    commandId: command.id,
                });
           }

            this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
        })
    );
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代码发生在 
 &lt;u&gt;SheetRenderController &lt;/u&gt;类，在 _commandExecutedListener 方法中，会去监听 Command 执行，如果在 
 &lt;code&gt;COMMAND_LISTENER_SKELETON_CHANGE&lt;/code&gt; 列表内，标记当前 skeleton 为 dirty，mainComponent 为 dirty，这样 Canvas 渲染引擎就会在下个渲染循环中重新渲染页面了 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：单元格编辑器初始化 
&lt;/div&gt; 
&lt;div&gt;
  其实在第三步，基本已经完成了整个 sheet 界面的渲染，我们再来关注一下单元格编辑器的初始化过程。在应用 Rendered 阶段，univer 会去初始化两个 Doc 实例，一个用於单元格的编辑，另一个用于公式输入框的编辑。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// initialize-editor.controller.ts
private _initialize() {
    this._currentUniverService.createDoc({
        id: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
    // create univer doc formula bar editor instance

    this._currentUniverService.createDoc({
        id: DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  同样在 Rendered 阶段， 
 &lt;u&gt;EditorBridgeController &lt;/u&gt;类实例化时，会去初始化相关的事件监听，如双击单元格，单元格进入编辑模式。但是直到 Steady 阶段， 
 &lt;u&gt;StartEditController &lt;/u&gt;类才完成实例化，单元格编辑才能完全可交互 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;肆. 界面如何响应用户操作？&lt;/h1&gt; 
&lt;div&gt;
  下面的时序图描述了当用户点击 text wrap 菜单项，univer 从响应事件到界面渲染的整个过程 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="819" src="https://oscimg.oschina.net/oscnet/up-5858c5e9fc2871f877345efca1f3aa5a740.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  第一步：用户点击菜单中 text wrap 菜单项。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // menu.ts
 export function WrapTextMenuItemFactory(accessor: IAccessor): IMenuSelectorItem&amp;lt;WrapStrategy&amp;gt; {
    // ...
    return {
        id: SetTextWrapCommand.id,
        // ...
    };
}
// ToolbarItem.tsx
 &amp;lt;Select
    // ...
    onClick={(value) =&amp;gt; {
        let commandId = id;
        // ...
        commandService.executeCommand(commandId, value);
     }}
     // ...
 /&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面是菜单栏中 text wrap 菜单项的 Select 组件，可以看到在上面绑定了 click 事件处理函数，当点击后，commandService 将执行 commandId，也就是在 WrapTextMenuItemFactory 中配置的 id 值：SetTextWrapCommand 的 id 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第二步：在 SetTextWrapCommand 中，包装一下参数，然后执行了统一设置样式的 Command，SetStyleCommand 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;export const SetTextWrapCommand: ICommand&amp;lt;ISetTextWrapCommandParams&amp;gt; = {
    type: CommandType.COMMAND,
    id: 'sheet.command.set-text-wrap',
    handler: async (accessor, params) =&amp;gt; {
        // ...
        const commandService = accessor.get(ICommandService);
        const setStyleParams: ISetStyleParams&amp;lt;WrapStrategy&amp;gt; = {
            style: {
                type: 'tb',
                value: params.value,
            },
        };
  
        return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    },
};&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：在 SetStyleCommand 中，因为改变了选区内样式值，所以需要组装 SetRangeValuesMutation 的参数，比如将选区内所有单元格的 tb 设置为 
 &lt;u&gt;WrapStrategy.WRAP&lt;/u&gt;。由于选区内 text wrap 的改变，同时该行是自动调整行高的，那么还需要去计算该行的一个 autoHeight，也就是容纳该行内容的一个最低高度。计算自动行高之前，需要先执行 SetRangeValuesMutation，因为 autoHeight 计算是依赖于更新后的视图数据的。 通过 SheetInterceptorService 中注册的 interceptor 拿到 autoHeight 的值（redos 中） 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // set-style.command.ts
 const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
       id: SetStyleCommand.id,
        params,
 });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：之所以上面能够拿到 autoHeight 的值，主要还是归因于 
 &lt;u&gt;AutoHeightController &lt;/u&gt;类，该类在 
 &lt;u&gt;LifecycleStages&lt;/u&gt;.Ready 阶段被实例化，并且添加了会影响到行自动行高的所有 Command 的拦截，如对 SetStylecommand 拦截。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
// for intercept set style command.
sheetInterceptorService.interceptCommand({
     getMutations: (command: { id: string; params: ISetStyleParams&amp;lt;number&amp;gt; }) =&amp;gt; {
          if (command.id !== SetStyleCommand.id) {
              return {
                  redos: [],
                  undos: [],
              };
          }
          // ...
          const selections = selectionManagerService.getSelectionRanges();
 
          return this._getUndoRedoParamsOfAutoHeight(selections);
      },
  });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第五步：因为计算行的自动行高需要用到文档模型以及单元格布局的相关计算，所相关计算都放在了管理 
 &lt;u&gt;Spreadsheet&lt;/u&gt; 的 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 类中 (视图层)， 通过该类中 
 &lt;code&gt;calculateAutoHeightInRange&lt;/code&gt; 方法最终计算出行的自动行高 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
private _getUndoRedoParamsOfAutoHeight(ranges: IRange[]) {
    // ...
    const { skeleton } = sheetSkeletonService.getCurrent()!;
    const rowsAutoHeightInfo = skeleton.calculateAutoHeightInRange(ranges);
    // ...     
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第六步：当拿到 autoHeight 的数据后，会触发 SetWorksheetRowHeightMutation。无论是上面触发的 SetRangeValuesMutation 还是 SetWorksheetRowHeightMutation，都会更改模型层，并且标记 sheetSkeleton 和 mainComponent 为 dirty，在 sheetSkeletion 重新计算布局等相关渲染所需信息，然后渲染页面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
        this._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                 // ...
                 if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                        },
                        true
                    );
                  }
                  // ...
              }
              this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
         })
     );
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  以上就完成了从事件触发到修改模型层，进而视图层更新的整个过程 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_18"&gt;&lt;/span&gt; 
&lt;h1&gt;伍. 更多阅读&lt;/h1&gt; 
&lt;div&gt;
  如果你想对架构有个整体的了解，推荐阅读 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fachitecture.md%23architecture-notes-%25E6%259E%25B6%25E6%259E%2584%25E6%25A6%2582%25E8%25A6%2581" rel="nofollow" target="_blank"&gt;Architecture Notes 架构概要&lt;/a&gt;&lt;/strong&gt;，如果你想了解更多 sheet 的架构和各个模块的设计和职责，推荐阅读 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fsheet-architecture.md%23univer-sheet-architecture---univer-sheet-%25E6%259E%25B6%25E6%259E%2584" rel="nofollow" target="_blank"&gt;Univer Sheet Architecture - Univer Sheet 架构&lt;/a&gt;&lt;/strong&gt;。如果你对 DI 系统比较陌生，建议，阅读 Univer 项目中所使用的 DI 框架 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredi.wendell.fun%2Fzh-CN%2Fdocs%2Fintroduction" rel="nofollow" target="_blank"&gt;redi&lt;/a&gt;&lt;/strong&gt;。项目使用 Rxjs 作为观察者模式，阅读 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frxjs.tech%2Fguide%2Foverview" rel="nofollow" target="_blank"&gt;Rxjs 相关文档&lt;/a&gt;&lt;/strong&gt; 
 &lt;strong&gt; &lt;/strong&gt;是快速熟悉 Rxjs 的方式 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/6977969/blog/10142382</link>
      <guid isPermaLink="false">https://my.oschina.net/u/6977969/blog/10142382</guid>
      <pubDate>Sat, 10 May 2025 10:12:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Stability AI 发布可在端侧运行的全新音频生成模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Stability AI &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstability.ai%2Fnews%2Fstability-ai-and-arm-release-stable-audio-open-small-enabling-real-world-deployment-for-on-device-audio-control" target="_blank"&gt;发布&lt;/a&gt;&lt;/u&gt;了一款名为 Stable Audio Open Small 的音频生成模型，可在手机端上运行。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-aa977d69f583aa125c61d78628c79f29a64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Hugging Face：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fstabilityai%2Fstable-audio-open-small" target="_blank"&gt;https://huggingface.co/stabilityai/stable-audio-open-small&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 是 Stability AI 与 Arm 公司合作的成果。该模型的训练集完全由免版税音频库 Free Music Archive 和 Freesound 中的歌曲组成。模型拥有 3.41 亿个参数，经过优化可在 Arm CPU 上运行。&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 专为快速生成简短的音频采样和音效（如鼓声和乐器旋律）而设计，Stability AI 公司称，它可以在 8 秒内在智能手机上生成长达 11 秒的音频。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350074</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350074</guid>
      <pubDate>Sat, 10 May 2025 10:06:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>因流量持续暴跌，Stack Overflow 寻求品牌重塑</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;编程问答社区 Stack Overflow 开发商表示由于 AI 在回答编程相关问题上更快捷更方便，其网站上的帖子数量正在持续急剧下降，为此他们计划进行「品牌重塑」。&lt;/p&gt; 
&lt;p&gt;根据官方统计数据，2025 年 4 月发布的问题和答案总数与 2024 年同期下降了超过 64%，与 2020 年 4 月（当时流量接近峰值）相比下降了超过 90%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-01d9e19775d998a0fa483d562a1a6b782e2.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;CEO Prashanth Chandrasekar 表示公司考虑在问答功能外加入社区和职业发展服务。该公司已在试验多项新服务，包括 AI Answer Assistant 和 Question Assistant，以及与 Indeed 合作的招聘网站等。&lt;/p&gt; 
&lt;p&gt;Stack Overflow 品牌广为人知，为什么还要进行品牌重塑？官方帖子提到了 AI 正在「重塑我们构建、学习和解决问题的方式」，并且该公司似乎正在寻找新的方式来提供价值（并推动业务）。&lt;/p&gt; 
&lt;p&gt;在这种情况下，许多用户并不认为品牌重塑是答案。有用户&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reddit.com%2Fr%2Fprogramming%2Fcomments%2F1km8mbc%2Fstack_overflow_seeks_rebrand_as_traffic_continues%2F" target="_blank"&gt;表示&lt;/a&gt;&lt;/u&gt;，「没有 DevOps、系统管理员、C/C++/Python/Rust/Java 程序员、数据库管理员或其他频繁使用 Stack Overflow 的用户关心品牌，现有的网站就很好」，&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</guid>
      <pubDate>Sat, 10 May 2025 09:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>从编译器、游戏引擎到游戏掌机，我是这样做独立游戏的</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;h2&gt;引言&lt;/h2&gt; 
&lt;p&gt;  自己开发制作游戏是一个儿时起就有的梦，特别是长时间接触魔兽争霸 3 世界编辑器后，我对游戏引擎和开发工具也有着特别的兴趣。学生时代接触编程以后，梦的外延开始扩散，不满足于使用各式编程语言做开发，开始维护一门自己喜欢的写游戏业务逻辑的编程语言项目 Yuescript，因为学习图形学和作为练手项目重写 Cocos2d-x 有了 Dora SSR 游戏引擎。工作后因为对游戏掌机的喜爱，开始与伙伴合作研发自由开放的可编程游戏掌机设备——吉祥机，实现自己游戏梦终极的 Digital Freedom。&lt;/p&gt; 
&lt;h2&gt;游戏脚本语言的乐趣与挑战&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-715e7bd07ab1f0fb9a982d2c625f69f9fef.png" alt="编程语言游乐场！" title="编程语言游乐场！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  各式新的编程语言的学习过程是充满乐趣的，对不同语言工具的接触也会感受到不同的编程理念和程序设计思想。为了学习制作游戏，对于复杂多变游戏玩法的脚本编程（Scripting），我也形成了自己编程偏好，即使用一门尽可能简洁和表达力强的编程语言来编写容易变化的业务逻辑。可以转译为 Lua 语言执行的 Yuescript 语言开源项目就是我为了满足这个需求的产物。后来随着使用自己的 Dora SSR 游戏引擎遇到更多的游戏开发场景，我又为 Dora SSR 开源游戏引擎引入了 Teal（为 Lua 语言添加静态类型检查能力的语言）、Typescript（进一步增强代码编辑器提示和代码检查的语言）、TSX 和 XML（提供描述性代码进行组件化开发的语言）等等。每一种脚本语言都能在特定的游戏开发场景发挥优势，并通过转译到最终运行的、同样的 Lua 语言进行无缝的互通调用。不只是基于 Lua 语言的扩展，Dora SSR 游戏引擎项目还在尝试通过 WASM 虚拟机来支持更加多样的可以用做游戏脚本编程的语言，如 Rust 和准备支持的 C++ 和 Go 等，兼顾性能与引擎的运行时扩展能力。&lt;/p&gt; 
&lt;h2&gt;游戏引擎的创新之路&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d13c83fb9e85ab500bfc4a52c25c25488be.png" alt="随时随地用任何设备制作游戏！" title="随时随地用任何设备制作游戏！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  说到游戏引擎大家总是想到高性能高质量的图形渲染，搭建复杂的游戏场景。实际上作为独立游戏开发者，或是游戏制作的爱好者，并不是人人都有条件追求 3A 游戏的制作能力（可能会缺少钞能力）。我认为很多 2D 游戏或是 2D 混合 3D 效果的游戏也能表达展现十分有创意和独特的游戏作品。而且能运行自己制作游戏的终端最好是不受限制的，再进一步，也许能用于开发游戏的终端和操作系统也可以是不受限制的。所以就有了 Dora SSR 开源游戏引擎的项目目标，在尽可能多的设备上为游戏开发爱好者提供便捷易用的环境甚至是游戏开发 IDE。&lt;/p&gt; 
&lt;p&gt;  一直以来游戏开发这件事也成为了我的个人生活的一个日常的部分。哪怕只有碎片化的时间和手边随机可用作游戏开发和运行的设备，我也想有空就利用起来碎片化地写两行游戏代码，或是调试一个游戏功能，并把它变成了一种比较随性和惬意的休闲娱乐活动。&lt;/p&gt; 
&lt;p&gt;  所以我也尝试了在 Dora SSR 上搭建了通过游戏引擎运行时内置用于游戏开发的 Web IDE 服务器，可以通过其它方便做输入的设备通过 Web 浏览器做访问，并实现直接在任意的终端设备上直接编写运行和调试游戏程序代码的体验。同时用户能获得代码编辑器可视提示服务、以及使用其它游戏开发和资源管理的可视化工具。目前 Dora SSR 在努力之下已具备了在 Windows、macOS、iOS、Android、多个 Linux 发行版上进行游戏开发的能力。&lt;/p&gt; 
&lt;h2&gt;向着自由开放的游戏掌机梦想迈进&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1a4efb08595713fcf90d5b06eecbe82f151.png" alt="开源开放？软件和硬件全都要！" title="开源开放？软件和硬件全都要！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  到此我觉得对游戏开发能力的自由和开放体验的追求还远不到尽头。作为喜好各式掌机的老玩家，在体验了诸多国产开源掌机的商业产品后，我感觉深深的不满足。用掌上游戏机玩游戏目前还是在卷硬件参数和外观设计来提供体验的差异化，而我期待的掌机并不只是玩游戏上的体验，还应该是一个可以用来自由的开发、运行甚至发行自制游戏的设备。很多掌机厂商都有自己的商业化模式和获得盈利的闭环，所以不会允许硬件设备获得太多可编程定制的能力。于是和同样对硬件发烧的伙伴一起研究构建了完全自由开放的掌机设备。并尽可能提供包括机器的计算核心、外设和外观均可进行模块化的定制和更换的能力（使科技不再以换壳为本）。于是又有了叫做「吉祥机」的项目。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-677fa26ccf81393c62a89ff15e0179e68e1.png" alt="吉祥机 + Dora SSR 游戏引擎" title="吉祥机 + Dora SSR 游戏引擎" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-563f088864ac8a58e6b9687daf303f6fcae.png" alt="不只是掌机和移动编程设备，「吉祥机」也是提供 GPIO + SPI + I2C 接口的外设开发板" title="不只是掌机和移动编程设备，「吉祥机」也是提供 GPIO + SPI + I2C 接口的外设开发板" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;回到游戏创作的初心&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1f5689f94e27f1b3cf208904e76c8041731.jpg" alt="社区在做的开源独立游戏项目《灵数奇缘》" title="社区在做的开源独立游戏项目《灵数奇缘》" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  所以折腾了半天我们的游戏到底做出来了没有呢？答案当然是做了，但没完全做出来啦。在生成式 AI 大模型进入彻底火爆前夕的 2020 年，我们就想象了这样一个关于未来的 AI 的游戏故事，在未来人的物质需求已经得到完全满足，人生下来的目的只剩下了通过进行游戏娱乐，并通过采集在游戏过程体现人创造力和展现智慧的交互数据给 AI 用做训练材料。人生的价值都是由未来的银行（数据银行），通过评估在游戏活动中人所创造的智能数据的质量和价值，来进行货币分配和评定的。最终数据训练出的 AI，则会帮助人完成一切的物质生产，从人类个体的养育到社会治理。游戏的剧情会探索在这样的设定背景下，人类会有什么样的故事。最后游戏输出的价值观就是人生来就应该是改造世界的主体，而不是只会适应一切现状的被改造的客体。也呼应了我和我的伙伴们一直在现实中追寻的东西，想要不被与生俱来的一切所定义，就靠自己的主动创造去重新定义一切。&lt;/p&gt; 
&lt;p&gt;  如果对我们在做的编程语言、游戏引擎、游戏掌机或是开源独立游戏项目感兴趣，欢迎 Star 我们的仓库或是进入我们的 Q 群一起聊聊。目前的项目都还在逐渐完善的阶段，但是几个项目都会互相整合和验证迭代，关注我们也可以及时看到我们的项目是怎么做的以及目前的进展。&lt;/p&gt; 
&lt;h3&gt;项目地址&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;游戏引擎：&lt;br&gt; &lt;a href="https://gitee.com/pig/Dora-SSR"&gt;https://gitee.com/pig/Dora-SSR&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FIppClub%2FDora-SSR" target="_blank"&gt;https://github.com/IppClub/Dora-SSR&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Yuescript 语言：&lt;br&gt; &lt;a href="https://gitee.com/pig/Yuescript"&gt;https://gitee.com/pig/Yuescript&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpigpigyyy%2FYuescript" target="_blank"&gt;https://github.com/pigpigyyy/Yuescript&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;《灵数奇缘》开源游戏项目：&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fluv-sense-digital.readthedocs.io" target="_blank"&gt;https://luv-sense-digital.readthedocs.io&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;游戏开发及掌机交流 Q 群：512620381&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4925410/blog/11049342</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4925410/blog/11049342</guid>
      <pubDate>Sat, 10 May 2025 09:29:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>DeepSeek 新论文公开 V3 大模型降本方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DeepSeek 团队近日发表了新论文《Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures》，把 DeepSeek-V3 在训练和推理过程中，如何解决「硬件瓶颈」的方法公布了出来。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/165038_St64_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;论文主要介绍了 DeepSeek-V3 在硬件架构方面的挑战和创新，以及如何通过软硬件协同设计实现高效训练和推理。&lt;/p&gt; 
&lt;p&gt;关键结论&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;内存效率：DeepSeek-V3 通过 MLA 将 KV 缓存大小显著减少到每个 token 仅需 70 KB，远低于其他模型（如 Qwen-2.5 72B 的 327 KB 和 LLaMA-3.1 405B 的 516 KB）。这使得模型更适合处理长文本和资源受限的环境。&lt;/li&gt; 
 &lt;li&gt;成本效益：MoE 架构允许在训练时仅激活部分参数，从而显著降低计算需求。例如，DeepSeek-V3 在扩展到 671B 参数时，每个 token 的激活参数仅为 37B，相比全参数激活的密集模型（如 72B 的 Qwen 和 405B 的 LLaMA），计算成本大幅降低。&lt;/li&gt; 
 &lt;li&gt;推理速度：通过重叠计算和通信以及多令牌预测模块，DeepSeek-V3 在推理时能够显著提高吞吐量和响应速度。例如，多令牌预测模块可以将生成速度提高 1.8 倍。&lt;/li&gt; 
 &lt;li&gt;低精度计算：FP8 混合精度训练在 DeepSeek-V3 中首次应用于大规模模型训练，通过细粒度量化策略，相对 BF16 的精度损失控制在 0.25% 以内。&lt;/li&gt; 
 &lt;li&gt;网络优化：采用多平面两层 Fat-Tree 网络拓扑，相比传统的三层 Fat-Tree 拓扑，显著降低了网络成本，并提高了网络的鲁棒性和可扩展性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;论文还提出了对未来 AI 硬件的建议和展望。详情查看：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2505.09343" target="_blank"&gt;https://arxiv.org/pdf/2505.09343&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350049</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350049</guid>
      <pubDate>Sat, 10 May 2025 08:52:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>vivo 开启顶尖人才招募计划：涉及芯片、AI 大模型等领域，称薪酬上不封顶</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;vivo 近日启动了一项名为「蓝极星计划」的顶尖人才招募项目。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1099" src="https://static.oschina.net/uploads/space/2025/0515/164047_c20b_2720166.png" width="750" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;招募信息显示，蓝极星计划的定位为 vivo 最核心的人才战略方案，面向全球高校顶尖技术人才。在待遇方面，vivo 承诺薪酬上不封顶。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164121_udGF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164136_65kU_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164149_53FG_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;不过，蓝极星计划的门槛也很高，仅向博士生开放。此次招募的岗位涉及 XR、AI 大模型、影像、芯片、器件开发等核心技术领域，岗位类型十余个。总体招募规模在百人左右，其中以影像方向名额最多。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350047</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350047</guid>
      <pubDate>Sat, 10 May 2025 08:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Ruby 已合并新的即时编译器 ZJIT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;ZJIT 是一个新的即时编译器（JIT），由与开发 YJIT 的同一编译器团队构建到参考 Ruby 实现 YARV 中，该工具目前已合并到 Ruby。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;相关阅读&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/231919/ruby-rjit" target="news"&gt;Ruby 引入新 JIT 编译器 RJIT，替代 MJIT&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/192164/rust-jit-for-ruby" target="news"&gt;Ruby 的新 YJIT 编译器已完成，使用 Rust 重新实现&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;ZJIT 在多个方面与 YJIT 有所不同：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;它不是直接将 YARV 字节码编译成低级中间表示（LIR），而是使用基于高级单赋值（SSA）的中间表示（HIR）&lt;/li&gt; 
 &lt;li&gt;它不是一次编译一个基本块，而是每次编译一个完整的方法&lt;/li&gt; 
 &lt;li&gt;它不是使用懒惰基本块版本化（LBBV）来分析类型，而是从已分析的解释器中读取历史类型信息&lt;/li&gt; 
 &lt;li&gt;与在将 YARV 降低到 LIR 时进行优化不同，它有一个工作在 HIR 上的高级模块化优化器&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;从高层次来看，ZJIT 接收 YARV 字节码，构建中间表示（IR），进行一些优化，并生成机器码。简化来说，它看起来像这样：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/162351_2fb3_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下示例为 Ruby 程序通过完整的编译器管道：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-ruby"&gt;# add.rb
def add(left, right)
  left + right
end

p add(1, 2)
p add(3, 4)&lt;/code&gt;&lt;/pre&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350040/ruby-merge-zjit</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350040/ruby-merge-zjit</guid>
      <pubDate>Sat, 10 May 2025 08:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>腾讯元宝推出 Chrome 浏览器插件</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯元宝上线了浏览器插件，可以在 Chrome 应用商店下载。安装之后，在网页上就能划词提问、总结内容、翻译外文网页，看到重要信息还能一键收藏，所有收藏的内容都会同步，方便之后接着问、继续看。&lt;/p&gt; 
&lt;p&gt;开启元宝插件后，页面右侧会有一个悬浮球，点击就能用元宝；右侧的侧边栏，支持截图提问、上传文件、搜索内容等操作，适合在浏览网页时顺手处理信息。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-38991e82b9d30a95f1547c862cbb75f202b.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-477743ad0ecf29d37287fdaab5a391134a8.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ed86f3ccf817ebd7d6844d987868865c677.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;下载地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyuanbao.tencent.com%2Fdownload" target="_blank"&gt;https://yuanbao.tencent.com/download&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350035</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350035</guid>
      <pubDate>Sat, 10 May 2025 08:05:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Databricks 官宣收购开源数据库引擎初创公司 Neon</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美国数据公司 Databricks&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.databricks.com%2Fblog%2Fdatabricks-neon" target="_blank"&gt;宣布&lt;/a&gt;已达成协议收购 Neon，这是一家以开发者为核心、提供无服务器 Postgres 解决方案的公司。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4671779d822a78c6be19b9199b6bae1e524.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该公司表示，Neon 的联合创始团队是全球极少数能够重构 Postgres 数据库架构、实现真正存储与计算分离的团队，这支由 Postgres 技术专家和数据库资深人士组成的团队将加入 Databricks，致力于在 AI 原生时代为开发者提供生产级规模的无服务器 Postgres 服务。&lt;/p&gt; 
&lt;p&gt;Databricks 在公告提到，当 Neon 去年正式发布时，他们注意到一个有趣的数据：30% 的数据库是由 AI Agent 创建的，而不是人类。当他们最近再次查看统计数据时，这个数字从 30% 上升到了 80% 以上。也就是说，AI Agent 创建的数据库数量是人类的四倍。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ec3bf200a942ba01e9a5788c048a3386cd3.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Neon 的约 140 名员工将在交易完成后加入 Databricks。Databricks 表示，在短期内，该初创公司将保持独立，但从长期来看，将会整合到 Databricks 平台中。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相关阅读&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/348379/scoop-databricks-talks-to-acquire-neon" target="_blank"&gt;Databricks 正洽谈以约 10 亿美元收购开源数据库初创公司 Neon&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/246894/databricks-strikes-1-3-billion-deal-for-mosaicml" target="news"&gt;大数据巨头 Databricks 斥资 13 亿美元收购 MosaicML&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350031/databricks-acquires-neon</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350031/databricks-acquires-neon</guid>
      <pubDate>Sat, 10 May 2025 07:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马化腾：微信有可能形成独特 Agent AI 生态</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;昨天，&lt;a href="https://www.oschina.net/news/349982"&gt;腾讯公布了 2025 年第一季度财报&lt;/a&gt;，总营收 1800 亿元，同比增长 13%。毛利为人民币 1000 亿元，同比增长 20%，净利润为 497 亿元，同比增长 17%。&lt;/p&gt; 
&lt;p&gt;在财报电话会议上，AI 成为了分析师们重点关切的话题。腾讯 CEO 马化腾、腾讯总裁刘炽平做了详细解读和提问。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151017_3gSe_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151007_rkWf_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;马化腾在回答分析师提问时表示，每个人都可以做通用的智能体，但与此同时，也有一种智能体可以存在于微信内部以及微信独特的生态系统中。&lt;/p&gt; 
&lt;p&gt;马化腾强调，「我认为这是两种不同的产品。」&lt;/p&gt; 
&lt;p&gt;马化腾表示，对于通用的智能体，腾讯正在公司的一些 AI 原生产品，例如，元宝和 Ima 等，中创建这种能力。在最初阶段，这些 AI 产品可能只是非常快速地回答问题，然后随着时间推移，它们开始包含思维链、长链路思考、推理模型，可以回答复杂的问题，再往后可以做更复杂的自动化任务。腾讯会继续发展这类产，但与我们同行提供的其他智能体没有太大区别。&lt;/p&gt; 
&lt;p&gt;马化腾认为，在微信生态系统内，腾讯有机会创建一个非常独特的智能体。它与微信生态系统的独特组成部分相连接，包括社交图谱、通信和社区能力、内容生态系统（如公众号和视频号），以及微信内数百万个小程序。&lt;/p&gt; 
&lt;p&gt;这些小程序实际上涉及各种信息以及跨越许多不同垂直应用的交易和操作能力。因此，为与其它更通用的智能体相比，这将是非常独特的。这对腾讯来说是一个非常差异化的产品&lt;/p&gt; 
&lt;p&gt;对于 AI 的商业模式，马化腾认为，通过 AI 提升广告收入存在巨大的机会，虽然 GPU 租赁与云业务直接相关，但这部分业务主要是转售 GPU，在腾讯内部优先级较低。马化腾还认为，在中国，用户都在免费获取 AI 服务，订阅模式不会是中国 AI 的主流商业模式。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350025</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350025</guid>
      <pubDate>Sat, 10 May 2025 07:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Anthropic 或将发布新模型，已开始内部安全测试</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.testingcatalog.com%2Fnew-claude-neptune-model-undergoes-red-team-review-at-anthropic%2F" target="_blank"&gt;据 TechingCatalog 报道&lt;/a&gt;&lt;/u&gt;，Anthropic 正在对一个名为「claude-neptune」的新 AI 模型进行安全测试。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-708826a51d39b3ae8c7c5212b0c223fa837.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;本次测试即将持续到 5 月 18 日，主要是测试该模型对于越狱尝试的防范性。新模型将使依赖 Claude 进行安全、高性能推理的开发人员、研究人员和企业用户受益匪浅，尤其是在代码生成和技术研究等领域，Claude 在这些领域的评估中一直保持强势。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-411a072df13c279a6cb41be11b7b27d7637.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 可能会在 5 月底或者 6 月初发布 Neptune 模型，与 OpenAI 以及谷歌展开正面对决。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</guid>
      <pubDate>Sat, 10 May 2025 06:59:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Canonical 今年将向开源开发者提供超过 10 万美元的捐款</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Canonical 宣布，将在未来一年向开源开发者捐赠 12 万美元。该公司计划从 4 月份发放的第一笔款项开始，每月捐赠 1 万美元，持续 12 个月。这些资金将通过&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthanks.dev%2F" target="_blank"&gt;thanks.dev 平台&lt;/a&gt;进行分配。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-60dfdea453b94c8e5e86c25d88085ea5029.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;该计划旨在为 Canonical 所依赖的小型上游开源项目提供资金支持。除了 Canonical 对 Eclipse 基金会、云原生计算基金会 (CNCF) 和 GNOME 基金会等主要开源基金会的持续支持之外，该计划也是一种回馈社会的额外方式。&lt;/p&gt; 
&lt;p&gt;Thanks.dev 的工作原理是分析公司 GitHub 代码库和依赖关系树（深度可达三层），并根据依赖关系的使用频率，通过算法分配捐款。Canonical 表示，它可以在编程语言层面调整资金的权重，以更好地反映资金的使用情况。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoverage.readthedocs.io%2F" target="_blank"&gt;Canonical 使用了一些开发者的项目，例如编写了 coverage.py 的&lt;/a&gt;nedbat 和&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fadamchainz%2Ftime-machine" target="_blank"&gt;维护 Ubuntu 网站使用的库 time-machine 的&lt;/a&gt;adamchainz&amp;nbsp;。该公司表示，即使是微小的认可或资金支持，对开源开发者来说也意义非凡。这是对这些项目幕后工作的赞赏。Canonical 的大部分代码都是开源的，并在 GitHub 和 Launchpad 等平台上公开开发。&lt;/p&gt; 
&lt;p&gt;该公司还指出，thanks.dev 正在努力添加对检查 Launchpad 上托管的依赖项的支持。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2Fblog%2Fcanonical-thanks-dev-giving-back-to-open-source-developers" target="_blank"&gt;此公告&lt;/a&gt;是在最近发布的 Ubuntu 25.04「Plucky Puffin」之后发布的，这是一个临时版本，包含许多受益于活跃的上游开发的新开源组件，例如 GNOME 4.8 桌面和 Linux 内核 6.14。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350018</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350018</guid>
      <pubDate>Sat, 10 May 2025 06:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>在微软任职 18 年的资深 TypeScript 工程师被裁员</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软近期进行了&lt;a href="https://www.oschina.net/news/349773/microsoft-is-cutting-3percent-of-workers"&gt;全球裁员&lt;/a&gt;，约 6,000 名员工受到影响，占其全球员工总数的近 3%。其中包括资深 TypeScript 工程师 Ron Buckton。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/114444_6gWh_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Frbuckton%2Fstatus%2F1922364558426911039" target="_blank"&gt;https://x.com/rbuckton/status/1922364558426911039&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Ron Buckton 在微软工作了 18 年，其中近 10 年致力于 TypeScript 的开发。&lt;/p&gt; 
&lt;p&gt;两个月前，TypeScript、C#、Delphi 语言之父 Anders Hejlsberg 宣布了「&lt;a href="https://www.oschina.net/news/338304/typescript-native-port"&gt;10x Faster TypeScript&lt;/a&gt;」项目——将 TypeScript 编译器以及工具链将移植到 Go 语言，性能提升高达 10 倍！&lt;/p&gt; 
&lt;p&gt;该项目由 Anders Hejlsberg 主导，Ron Buckton 则是其中核心开发者。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="2070" src="https://static.oschina.net/uploads/space/2025/0515/115256_8t1n_2720166.png" width="2806" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Ftypescript-go%2Fgraphs%2Fcontributors" target="_blank"&gt;https://github.com/microsoft/typescript-go/graphs/contributors&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;目前，该项目还在进展中，然而其核心成员已经被解雇了。作为 TypeScript 核心开发者，Ron 的离开也让大家对微软此次裁员的标准和背后的决策逻辑产生了疑问。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115906_rOTp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;有人讽刺地说：「被裁要么是你工作太差，要么是太优秀——如果不是前者，那就只能是后者。」甚至有人调侃道，「10 倍工程师实现了 10 倍性能提升后被裁，HR AI 宣布：‘价值已提取，执行终止。’」&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115558_zk7j_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;阅读更多：&lt;a href="https://www.oschina.net/news/338304/typescript-native-port" target="news"&gt;TypeScript 编译器和工具链将移植到 Go：性能提升 10 倍&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</guid>
      <pubDate>Sat, 10 May 2025 03:56:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>KuaiMod —— SVP 内容审核框架</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;KuaiMod，是快手推出的一个具有真实用户/审阅者反馈的 SVP 内容审核基准。&lt;/p&gt;

&lt;p&gt;KuaiMod 审核框架由三个部分组成：训练数据构建、离线自适应以及在线部署和改进。快手利用&lt;strong style="color:#363636"&gt;大规模视觉语言模型 (VLM) 和思维链 (CoT) 推理&lt;/strong&gt;，基于稀疏的用户反馈对视频恶意程度进行充分建模，并构建了更新速度快、准确率高的动态审核策略。&lt;/p&gt;

&lt;p&gt;基准测试结果表明，KuaiMod 的部署降低了 20% 的用户举报率，其在视频推荐中的应用提高了酷我多个场景中的日活跃用户（DAU）和 APP 使用时间（AUT）。&lt;/p&gt;

&lt;p&gt;&lt;img height="309" src="https://static.oschina.net/uploads/space/2025/0509/141639_WJZZ_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;h2 style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Kuaimod 实现细节&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img height="93" src="https://static.oschina.net/uploads/space/2025/0509/141652_v2nX_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img height="153" src="https://static.oschina.net/uploads/space/2025/0509/141710_FayU_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img height="269" src="https://static.oschina.net/uploads/space/2025/0509/141741_hk71_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img height="201" src="https://static.oschina.net/uploads/space/2025/0509/141758_NNw5_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/kuaimod</link>
      <guid isPermaLink="false">https://www.oschina.net/p/kuaimod</guid>
      <pubDate>Sat, 10 May 2025 03:54:00 GMT</pubDate>
    </item>
  </channel>
</rss>
