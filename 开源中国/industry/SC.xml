<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 02 Sep 2025 02:41:39 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>《上海合作组织成员国元首理事会关于进一步深化人工智能国际合作的声明》发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;《上海合作组织成员国元首理事会关于进一步深化人工智能国际合作的声明》&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gov.cn%2Fyaowen%2Fliebiao%2F202509%2Fcontent_7038710.htm" target="_blank"&gt;发布&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="298" src="https://oscimg.oschina.net/oscnet/up-c1e1998ec520ff1faa874f536b3ea15109a.png" width="600" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;其中提到，成员国将采取以下行动：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在充分考虑成员国优先事项和各自国内法律法规的基础上，支持联合国在人工智能决策中的核心作用，欢迎联合国大会通过的「加强人工智能能力建设国际合作」决议，以及「人工智能在为中亚可持续发展创造新机遇方面发挥的作用」的决议；&lt;/li&gt; 
 &lt;li&gt;欢迎提出《人工智能能力建设普惠计划》，成立人工智能能力建设国际合作之友小组，举办「人工智能之旅」国际会议（「AI Journey」），以及其他上合组织成员国人工智能领域倡议；&lt;/li&gt; 
 &lt;li&gt;加强人工智能基础设施合作，促进人工智能基础设施联通，在自愿参加的基础上推动人工智能应用国际合作；&lt;/li&gt; 
 &lt;li&gt;推动人工智能人才培养合作，扩大校际合作与学术交流，促进科研成果和教育资源交流；&lt;/li&gt; 
 &lt;li&gt;推动人工智能领域投资合作，发挥上合组织银联体的作用，充分挖掘上合组织成员国投资潜力，在自愿参加的基础上为成员国人工智能领域投资项目提供资源支持；&lt;/li&gt; 
 &lt;li&gt;在尊重国家主权的基础上发展人工智能领域对话伙伴机制，加强发展战略、治理规则、技术标准的对接协调，发展安全负责任的人工智能，开发可信赖的人工智能系统；&lt;/li&gt; 
 &lt;li&gt;在人工智能全球治理领域推动互惠理念，在人工智能国际监管方面始终坚持发展与安全并重。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;各成员国将努力推动人工智能向更加开放、包容、普惠、公平、向善的方向发展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369799</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369799</guid>
      <pubDate>Tue, 02 Sep 2025 02:40:37 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>R8 疑难杂症分析实战：外联优化设计缺陷引起的崩溃</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R8 作为谷歌官方的编译优化工具，在编译阶段会对字节码进行大规模修改，以追求包体优化和性能提升。但是 Android 应用开发者数量太过庞大，无论测试流程多么完善，终究难以避免在一些特定场景下出现问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;近期我们在升级项目的 AGP，遇到了一个指向系统 SurfaceTexture 类的 native 崩溃问题。经反编译分析发现问题最终指向了 smali 字节码中多余的一行 new-instance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c5f08cf575756e08466c223dc6283005.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1c03aaa90c06e347c22e752eeb0ccb1d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;该指令创建了一个 SurfaceTexture 对象，但是并未调用其&amp;lt;init&amp;gt;方法，这意味着构造方法没有执行，但是这个类重写了 finalize 方法，后续被 gc 回收时会调用其中的 nativeFinalize 这个 JNI 方法，最终在 native 层执行析构函数时触发了 SIGNALL 11 的内存访问错误.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d639c13a4be57106726e6ea52ee6c3f4.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//2210f4a541d54e36690a7e1fbfb16627.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、复现问题&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们注意到多出来的 new-instance 指令下面紧接着的是对 a0.e 类中的静态方法 i() 的调用，其内部实现就是 SurfaceTexture 的构造方法。这是典型的代码外联操作，即一段相同的代码在工程中多次出现，则会被抽出来单独作为一个静态函数，原先的调用点则替换成该函数的调用，这样可以减小代码体积，是常见的编码思路。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }
}
//外联生成的类
class&amp;nbsp;Activity$Outline{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;log(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们根据这个生成类的类名可以知道是 R8 中 ApiModelOutline 功能生成了这个类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//832dad3a1078a82298590ae249e4c937.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们进到 R8 工程中检索下相关的关键字，再加上 demo 多次尝试，可以确认满足以下条件能够必现该问题:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用了高于当前 minSdkVersion 的系统函数/变量（仅限系统类，自己写的无效）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用 synchronized 或者 try 语句块包裹了该调用，或者给该函数传参时有任何计算行为（除了传局部变量）。例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、问题分析&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在确认复现条件之后，我们带着几个问题来逐个分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 外联是什么？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;R8 中的优化大多数跟包体优化有关，代码外联也是其中一种，但是外联的前提是代码重复的次数满足一定阈值，但是 ApiModel 会对所有调用了高版本系统 API 的代码做外联，包括只调用一次的场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 并非为了包体优化，我们通过 R8 工程的 issueTracker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://issuetracker.google.com/issues/333477035）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;检索到了相关的信息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5020bee9863c252049d9f1d8f055c200.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;译：AGP 新增的 ApiModel 功能是为了防止在低版本设备上不可能执行的代码引起类验证错误，从而降低 App 启动耗时。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从这篇介绍 ART 虚拟机类验证的文档&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://chromium.googlesource.com/chromium/src/+/HEAD/build/android/docs/class_verification_failures.md#chromium_s-solution）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;就能够理解上面这句话的含义：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ART 虚拟机会在 APK 安装之后立刻执行 AOT class verification，即对 dex 文件中所有的类进行验证，如果验证成功则后续运行时将不需要再进行验证，反之若失败，则该 class 会被 ART 打上&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;RetryVerificationAtRuntime&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;的标记，后续运行时还得重新执行类验证。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;同时这些失败的类也将无法被 dex2oat 优化成 oat 格式的优化字节码（oat 字节码的加载和执行速度更快）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5d3b99565c562dff751ba4ac636da574.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是在 MainActivity，启动任务中使用了这些高版本 API，那么在低版本设备 App 启动时就必须额外执行一次类验证（比较耗时，有的类能到 8ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;nbsp;https://issues.chromium.org/issues/40574431&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;），而 ApiModel 外联则是相当于将这些肯定验证失败的函数的调用单独抽到一个生成类中，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这样运行时就能将类验证失败问题彻底隔离在生成类中，从而规避运行时的类验证耗时。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//安装 apk 后验证失败，运行时验证失败，但是能正常执行
class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk&amp;nbsp;&amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk &amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a0.b();&amp;nbsp;//这样类验证就能成功
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}
//生成的外联类，类验证会失败，但是运行时不可能走到，不影响
class&amp;nbsp;a0{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;b(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;更多关于 ApiModel 的详细介绍，见这篇文章：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://medium.com/androiddevelopers/mitigating-soft-verification-issues-in-r8-and-d8-7e9e06827dfd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么会多生成一个&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;new-instance 指令?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;介绍完 ApiModel 之后，我们已经知道了为什么&amp;lt;init&amp;gt;方法的调用被替换成了一个生成函数的调用，接下来我们再分析下导致崩溃的罪魁祸首 new-instance 指令是如何出现的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们先来了解下 java 文件在编译过程中的格式转换过程，因为 ApiModel 是基于 IRCode 格式（R8 自定义的格式）来做外联。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;文件转换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;javac&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;javac 将 java 文件编译成 class 文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是 sychronized 语句块在 javac 编译之后会为其内部代码生成 try-catch，这是为了确保在语句块抛异常时能够正常释放锁，因此和问题有关的是 try-catch 语句块，和 synchronized 无关。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//36889c510c4d4a88957306d93cdf7d59.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;D8&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;目前 R8 已经整合 D8，因此输入 class 文件之后就会先通过 D8 转为 dex 格式，并持有在内存中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;转换之后的指令基本和 class 字节码基本类似。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//876e7cf561f3a8aa1ee57005986ae7f0.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;IRcode&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了做进一步的优化，会将 dex 格式的代码转化成 R8 自定义的 IRcode 格式，其特点是代码分块。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;案例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b04a46ddb675fd3446029e19aa3fc632.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;问题根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 工程里检索 ApiModel 关键字，最终定位到针对构造函数生成外联函数和指令替换的代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;InstanceInitializerOutliner-&amp;gt;rewriteCode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;执行此方法之前的指令如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java：
new&amp;nbsp;SurfaceTexture(false);&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;dex：
:&amp;nbsp;-1:&amp;nbsp;NewInstance &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1&amp;nbsp;&amp;lt;- &amp;nbsp;android.graphics.SurfaceTexture
: -1: ConstNumber &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v2(0) &amp;lt;- &amp;nbsp;0 (INT)
: -1: Invoke-Direct &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1,&amp;nbsp;v2(0); method:&amp;nbsp;void&amp;nbsp;android.graphics.SurfaceTexture.&amp;lt;init&amp;gt;(boolean)&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;对整个方法中所有的指令从上往下进行遍历，第一次遍历主要是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;检索 &amp;lt;init&amp;gt;方法调用的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;判断该方法的 androidApiLevel 是否高于 minSDK&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;生成包含完整构造函数指令的外联函数，并替换&amp;lt;init&amp;gt;函数调用为外联函数调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;执行完替换逻辑，就记录信息到 map 中，key 是&amp;lt;init&amp;gt;对应的 new-instance 指令，value 是前一步中替换的新指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;经过这一步，字节码会变成这样：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//e6b105ab1ca583830e11bee8baafc4e5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具体替换逻辑如下（可以参考注释理解）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c919c6ad05e651de339fb13da747bfaa.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;第二次遍历则是对 new-instance 指令的处理：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;找到 new-instance 指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;查询 map，确认&amp;lt;init&amp;gt;方法已完成替换&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根据&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;方法返回的结果分为两种场景：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;无类初始化逻辑：直接移除 new-instance 指令，不影响原代码的语义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//f1f56bfb61c5396de49e85cc7eec3a7e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;有类初始化逻辑：生成外联函数，只包含该 new-instance 指令，和前一次遍历一样进行指令替换。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1959f35cfade28f57d11667c652bea3e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具体替换逻辑:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fac201236889edc5ad19870621442c23.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;问题重点就在于&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这个函数的实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;它会检查 new-intance 指令和 invoke &amp;lt;init&amp;gt;指令之间是否存在任何局部变量声明以外的指令，如果存在，他会认为这些指令是这个类初始化的逻辑，因此为了保留源代码的执行顺序，这种情况下就是需要额外执行一次 new-instance 指令来触发类初始化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9fe3bbc584708c6a61e6b7a0d4e808bd.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;但是实际上，如果在调用这个构造函数传参时执行了任何运算（和类加载无关），都会生成相关的指令插在中间，例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;java 写法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new-intance 和 invoke &amp;lt;init&amp;gt;指令之间的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;invoke-virtual &amp;nbsp; v2 &amp;lt;-; method: void xx.xx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;StaticGet &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v3 &amp;lt;- ; field: boolean &amp;nbsp;xxx.xxx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: CheckCast &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v5 &amp;lt;- v3; java.lang.Boolean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: Invoke-Virtual &amp;nbsp; &amp;nbsp; &amp;nbsp; v6 &amp;lt;- v5; method: boolean java.lang.Boolean.booleanValue()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从作者留下的 todo 也能看出，后续准备扩展这个方法，实现对这些夹在中间的指令的判断，如果是对类初始化无影响的入参计算逻辑，则也将正常移除 new-intance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fa19a3d661f5f19c0bf5fdb01d8c8aba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是，我们最终 APK 里 new-intance 指令并没有被外联，这是因为 SurfaceTexture 这个类本身在安卓 21 之前的版本就已经存在，只是入参为 bool 类型的构造方法是在安卓 26 新增的，所以他其实是被外联之后又被内联回到了调用处，因此看起来像是没有被外联。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//48f375f6e8c147cd435c140b6c8864ba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;小结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;至此，我们就明白了多出来一个看似无用的 new-intance 指令，实际上是为了保全源代码的语义，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;触发类加载&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用的，但是作者没有考虑到这些被优化的类可能重写了 finalize 方法来释放一些本就不存在的资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;而且不局限于调用 native 函数，只要是重写了 finalize，并在里面访问一些在构造函数中初始化的成员变量，一样可能造成 NPE 等崩溃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 是如何计算出 API 的版本？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d58a071ec92ca506d6e4f3e1ab4c7122.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R83.3 版本开始，它编译时会下载一个.ser 格式的数据库文件，里面记录了所有系统 API、变量与安卓版本号的映射信息，在运行时通过行号和偏移量来寻找各自的版本号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9842b0b5f78805c080d71cbda30f1c44.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么 try-catch&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;也会导致该问题？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前面解释了在构造函数入参中添加函数调用等写法导致的字节码异常原因，但是实际上这次我们遇到的崩溃场景是在 sychronized 里 new 了一个 SurfaceTexture。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//cec26da2ccbd01a385a47d0914cbd615.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前文中已经解释过，sychronized 在编译成 class 后会生成 try-catch 语句块，这段代码改成用 try-catch 语句块包裹，一样会复现崩溃，因此我们跟踪 try-catch 在文件转换过程中对字节码的影响即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;回到 class 文件转 dex 文件的阶段，我们发现 try 语句块中的每一行指令，都会在其后生成一条 FALLTHROUGH 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;dex 格式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//dc87199452140addbab0d7de45794ad8.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 是什么指令，他是做什么的？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 指令表示指令自然流转，没有实际含义，它主要是为了帮助优化器识别哪些指令是可达的。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如下面这种写法，case1 没有写 break，这样会接着执行 case2 的代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;switch&amp;nbsp;(value) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;1:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("One");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 故意不写 break
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;2:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Two");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;3:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Three");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;其字节码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;正常有 break 的话，会对应一条 GOTO 指令跳转到 switch 语句块最后一行，但是没写 break 的话，就会出现：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 12 行执行 goto 13 跳转到 13 行的指令，这种指令毫无意义，且运行时会消耗性能，因此可以替换成 FALLTHROUGH 指令，这样最终在生成 dex 文件时会被移除掉，从而避免浪费性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;switchWithFallthrough(int);
&amp;nbsp; Code:
&amp;nbsp; &amp;nbsp; stack=2, locals=1, args_size=1


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载参数
&amp;nbsp; &amp;nbsp;&amp;nbsp;0: iload_0


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 检查 case 1
&amp;nbsp; &amp;nbsp;&amp;nbsp;1: iconst_1
&amp;nbsp; &amp;nbsp;&amp;nbsp;2: if_icmpne&amp;nbsp;13&amp;nbsp; &amp;nbsp;&amp;nbsp;// 如果不等于 1，跳转到 case 2
&amp;nbsp; &amp;nbsp;&amp;nbsp;5: getstatic #2&amp;nbsp; &amp;nbsp;&amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;8: ldc #3&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// String One
&amp;nbsp; &amp;nbsp;&amp;nbsp;10: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;12:&amp;nbsp;goto&amp;nbsp;13


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 2 (fallthrough 目标)
&amp;nbsp; &amp;nbsp;&amp;nbsp;13: iconst_2
&amp;nbsp; &amp;nbsp;&amp;nbsp;14: if_icmpne&amp;nbsp;28&amp;nbsp; &amp;nbsp;// 如果不等于 2，跳转到 case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;17: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;20: ldc #5&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Two
&amp;nbsp; &amp;nbsp;&amp;nbsp;22: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;25:&amp;nbsp;goto&amp;nbsp;40&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 跳转到 switch 结束


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;28: iconst_3
&amp;nbsp; &amp;nbsp;&amp;nbsp;29: if_icmpne&amp;nbsp;40&amp;nbsp; &amp;nbsp;// 如果不等于 3，跳转到结束
&amp;nbsp; &amp;nbsp;&amp;nbsp;32: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;35: ldc #6&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Three
&amp;nbsp; &amp;nbsp;&amp;nbsp;37: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V


&amp;nbsp; &amp;nbsp;&amp;nbsp;// switch 结束
&amp;nbsp; &amp;nbsp;&amp;nbsp;40:&amp;nbsp;return&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;既然没用为什么还要加这个指令？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;class 文件是通过 Exception table 来指定异常处理的指令范围，而 dex 文件则是通过为每一行可能产生 throwable 的指令后面添加 FALLTHROUGH 指令来实现 try-catch。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这里会把每一行可能崩溃的指令都链接到 catch 指令所在的 block 中，确保任意位置的崩溃都能正常走到 catch 中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//144f461c63929a79f8346da8a6731ecb.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;问题根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 4.0.26 版本，IRCode 翻译器新增了对 FALLTHROUGH 指令的处理，即新建一个 block 并&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;生成一条 GOTO 指令指向新的 block。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//941934987c5518db50e697aacc04d794.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根据前文的结论，GOTO 指令一样会被认为是类初始化相关的逻辑，因此 try-catch 语句块一样会导致最终多出来一个 new-instance 字节码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么只升级 AGP 会导致&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 功能出问题？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们在数个版本之前就已经单独升级了 R8，正好涵盖了 ApiModel 这个变更，但是直到近期才升级了 AGP。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以看到从 AGP7.3-beta 版本开始，才默认打开 ApiModel 功能，这就解释了为什么升级 AGP 之后才出现此崩溃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//09bde1db3ff6dd55f96188f2c6337b24.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、解决方案&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;禁用 ApiModel&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 通过牺牲些微包体，换来启动阶段类验证耗时，但是从他覆盖的类范围来看，对启动速度的收益微乎其微，因此可以直接通过配置开关关闭整个功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;System.setProperty("com.android.tools.r8.disableApiModeling",&amp;nbsp;"1")&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;虽说这是个实验中的功能，且逻辑相对独立，但是考虑到后续还有内联优化等操作，贸然关闭整个功能无法评估影响面，潜在的稳定性风险较高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;官方修复&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;该问题反馈给 R8 团队后，官方提供了临时规避的方案，即确保高版本 API 在单独的函数中调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://issuetracker.google.com/issues/441137561&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//358c6b1b9714ab22bdff45c27378289c.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;随后不久就提了 MR 针对 SurfaceTexture 这个类禁用了 ApiModel，并未彻底解决此问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://r8-review.googlesource.com/c/r8/+/109044&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//403f68ae953ddd19b67dc90602d69475.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;官方的修复方案比较权威，且影响面较小，但是并未彻底解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;自行修复&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果要修复此问题，关键是要将多余的 new-instance 指令替换成一个合适的触发类加载的指令，根据 java 官方文档里的介绍，只有 new 对象，访问静态的成员变量或者函数的指令才能安全的触发类加载，比较理想的方案是改成访问静态变量，但是很多类并没有静态变量，比如 SurfaceTexture 就没有。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//168eeaad61d7b9e162730708773e256d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;因此我们可以考虑结合 getStatic 指令和扫描 finalize 的方式来解决该问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//baa3977f849ce680a7684f38a4d68176.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;虽说可以通过打印日志来约束此改动的影响面，但毕竟要自行修改并编译 R8 的 jar 包，且需要自行长期维护，整体影响面还是偏大，对稳定性要求高的 App 不建议采用该方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;业务改造（推荐）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在前文中提到的外联函数生成处打印日志，即可感知到工程中有哪些类受 ApiModel 影响，如果数量不多，分别让业务改造其相关的写法，确保传参时是局部变量且无 try-catch/synchronized 语句块即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//a7fd6ee2c6b96d340b89116b8a76d5d5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;考虑到 App 整体的稳定性，最终我们采用了业务改造的方式绕过了此问题，并在 R8 异常代码处添加了日志告警来预防后续增量问题，并仿照官方 MR 中的写法补充了类的黑名单，用于应对无法编辑的三方库引入此问题的场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、总结&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 Android 开发中，即使是 AGP、R8 这样的官方工具链升级，也要保持足够的警惕。毕竟 Android 生态太过复杂，再加上开发者们千奇百怪的代码写法，不论多么完善的测试流程都无法规避这类特定场景的 bug。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这次的 ApiModel 外联优化问题就是一个很好的例子——它只在特定条件下才会暴露，但一旦出现就是必现的 native 崩溃。所以对于这种影响面无法评估的重大升级，还是需要经过足够长时间的独立灰度验证，才能合入主干分支。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;可扩展系统设计的黄金法则与 Go 语言实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;得物新商品审核链路建设分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;营销会场预览直通车实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;基于 TinyMce 富文本编辑器的客服自研知识库的技术探索和实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;AI 质量专项报告自动分析生成｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 永乐&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18690286</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18690286</guid>
      <pubDate>Tue, 02 Sep 2025 02:30:37 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>我国智能算力规模达 788 百亿亿次/秒</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;人民日报北京 9 月 1 日电 &amp;nbsp;（记者刘温馨、郑洋洋）截至今年 6 月底，我国在用算力中心机架总规模达 1085 万标准机架，智能算力规模达 788 百亿亿次/秒 (EFLOPS)；存力规模超过 1680 艾字节 (EB)，相比 2023 年增长约 40%；已发布 1509 个大模型，在全球位居前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="334" src="https://oscimg.oschina.net/oscnet/up-f7c4902ec7cb7f48c81c629fb38170914e5.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;近日，中国算力平台完成山西、辽宁、上海、江苏、浙江、山东、河南、青海、宁夏、新疆 10 个省份分平台接入工作，实现「平台、主体、资源、生态、场景」全面贯通。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作为国家级综合性算力服务平台，中国算力平台集「供、需、服」于一体，可实现不同系统、平台和工具之间的兼容性和互操作性。截至 7 月底，平台运营层注册企业用户超 1000 家，入驻算力服务商逾 100 家，上架优质算力产品 110 余项，接入主流基础大模型和垂类模型 90 余个，累计沉淀数十亿条算力监测大数据。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369793</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369793</guid>
      <pubDate>Tue, 02 Sep 2025 02:23:37 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智谱上线 Claude Code 专属包月套餐，月费低至 20 元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智谱&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FJKSKSrjw3aqUODEN_LzRMg" target="_blank"&gt;宣布&lt;/a&gt;，自 9 月 1 日起推出 Claude Code 专属「GLM Coding Plan」限时套餐，月费低至 20 元。&lt;/p&gt; 
&lt;p&gt;该套餐适用于智谱最新旗舰模型 GLM-4.5 及 GLM-4.5-Air。用户可通过扫描活动海报二维码，或者登录智谱开放平台&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbigmodel.cn%2Fclaude-code" target="_blank"&gt;bigmodel.cn&lt;/a&gt;，直接购买并获取详细使用攻略。&lt;/p&gt; 
&lt;p&gt;首期主推 Claude Code，未来将拓展到更多 Coding 工具。目前，GLM-4.5 已接入包括 Claude Code、Cline、Gemini CLI、Grok CLI、CodeGeeX、Kilo Code、Roo Code、Trae 在内的多款主流编程工具，全面支持日常开发流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/101910_Nw8D_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369792</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369792</guid>
      <pubDate>Tue, 02 Sep 2025 02:20:37 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>腾讯开源 Hunyuan-MT-7B 翻译模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrKcf7jXAYlCKcwan0o756Q" target="_blank"&gt;宣布&lt;/a&gt;开源在国际机器翻译比赛拿下 30 个第 1 名的翻译模型 Hunyuan-MT-7B，除了中文、英语、日语等常见语种，也包含捷克语、马拉地语、爱沙尼亚语、冰岛语等小语种。&lt;/p&gt; 
&lt;p&gt;Hunyuan-MT-7B 总参数量仅 7B，支持 33 个语种、5 种民汉语言/方言互译，是一个能力全面的轻量级翻译模型。&lt;/p&gt; 
&lt;p&gt;&lt;img height="293" src="https://oscimg.oschina.net/oscnet/up-dfbb59995d2db0c828e006ce4d0041931a0.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;同时开源的还有一个翻译集成模型 Hunyuan-MT-Chimera-7B （奇美拉），是业界首个翻译集成模型，它能够根据原文和多个翻译模型给出的不同内容，再生成一个更优的翻译结果，不仅原生支持 Hunyuan-MT-7B，也支持接入 deepseek 等模型，对于一些有专业翻译需求的用户和场景，可以提供更加准确的回复。&lt;/p&gt; 
&lt;p&gt;公告称，在业界常用的翻译能力测评数据集 Flores200 上，腾讯混元 Hunyuan-MT-7B 模型也有卓越的效果表现，明显领先于同尺寸模型，与超大尺寸模型效果对比也不逊色。&lt;/p&gt; 
&lt;p&gt;取得全面领先的成绩，离不开技术上的全面突破，针对翻译场景，腾讯混元提出了一个完整的翻译模型训练范式，覆盖从预训练、到 CPT 再到监督调参、翻译强化和集成强化全链条，使得模型的翻译效果达到业界最优。&lt;/p&gt; 
&lt;p&gt;&lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-66e18aed212fea1e14be8e0b31d401ea4a1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Hunyuan-MT-7B 的特点在于仅用少量的参数，就达到甚至超过了更大规模模型的效果，这也为模型的应用带来了众多优势。&lt;/p&gt; 
&lt;p&gt;首先是计算效率，7B 模型的推理速度明显快于大型模型，在相同硬件条件下能够处理更多的翻译请求，并且，基于腾讯自研的 AngelSlim 大模型压缩工具对 Hunyuan-MT-7B 进行 FP8 量化压缩，推理性能进一步提升 30%。&lt;/p&gt; 
&lt;p&gt;其次是部署友好性，Hunyuan-MT-7B 能够在更多样化的硬件环境中部署，从高端服务器到边缘设备都能良好运行，并且模型的部署成本、运行成本和维护成本都相对更低，在保证翻译质量的前提下，为企业和开发者提供了更具吸引力的解决方案。&lt;/p&gt; 
&lt;p&gt;目前，腾讯混元翻译模型已经接入腾讯多个业务，包括腾讯会议、企业微信、QQ 浏览器、翻译君翻译、腾讯海外客服翻译等，助力产品体验提升。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369791</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369791</guid>
      <pubDate>Tue, 02 Sep 2025 02:17:37 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>DeepSeek 公开模型原理与训练方法说明</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DeepSeek 发布官方说明，披露了其大语言模型的训练原理、数据来源等信息。DeepSeek 表示其线上服务基于深度神经网络大模型，采用「预训练—优化训练」两阶段流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/100812_xXNj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在预训练阶段，模型通过大规模自监督学习获取通用语言能力；在优化训练阶段，则使用有监督微调（SFT）或强化学习（RL）对模型进行任务适配；最终部署的模型以自回归方式实时生成文本，而非简单的信息检索。&lt;/p&gt; 
&lt;p&gt;数据来源方面，预训练语料由互联网公开信息和第三方合作数据组成，不主动收集个人信息。优化训练阶段的数据由研究团队自建问答对，少量样本可能源自用户输入，但均经过了去标识化、加密及匿名化处理，并为用户提供了退出机制。&lt;/p&gt; 
&lt;p&gt;完整内容查看：&lt;em&gt;https://cdn.deepseek.com/policies/zh-CN/model-algorithm-disclosure.html&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369790</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369790</guid>
      <pubDate>Tue, 02 Sep 2025 02:09:37 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>openKylin 嵌入式系统发力工业领域：与松科智能 AI 视觉小车、机械臂共拓应用新场景</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="margin-left:0; margin-right:0"&gt;近日，OpenAtom openKylin（简称「openKylin」）2025 年度开发者大会在北京盛大启幕，活动现场展示区展演重要进展 —— 广东松科智能科技有限公司（简称「松科智能」）研发的 AI 视觉小车与机械臂，已成功完成在 openKylin 操作系统的适配调试，两款设备均搭载飞腾派作为主控板，标志着 openKylin 嵌入式系统在工业场景的应用落地迈出关键一步。&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet//3f891ad63f386e3bddc9553c544d82bc.png" width="" referrerpolicy="no-referrer"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet//b53797a3dbef4b7d205ff6c745551a4e.png" width="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;活动现场，openKylin 生态委员会主任李震宁现场开展技术演示，生动展现了 openKylin 操作系统的工业应用实力。演示中，搭载 openKylin 系统的松科 AI 视觉小车表现亮眼 —— 在无人驾驶模式下沿预设路线平稳行驶，面对手势指令能快速响应转向、启停等操作，遇到障碍物时更是毫秒级完成识别与规避，全程运行流畅无卡顿；松科 AI 视觉机械臂则精准完成多场景任务，不仅能通过视觉识别快速区分不同颜色色块并分类放置，还可基于算法进行路径规划与简易计算。与会嘉宾近距离观摩体验，切实感受到 openKylin 系统在支持智能硬件协同控制、复杂场景实时响应等方面的强大能力，对系统的稳定性与兼容性给予高度认可。&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet//d7932b9ac9366c3fcdd876fb19b54c8f.jpeg" width="" referrerpolicy="no-referrer"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet//6f0009e7b70cad7dbff147eb3403964d.jpeg" width="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;此次适配测试以搭载 Phytium E2000Q 处理器的飞腾派开发板为核心硬件（配置 4GB RAM 与 32GB 存储），通过全流程验证确认：openKylin 操作系统可稳定支持机械臂精准控制、神经网络高效加速及视觉识别实时响应，三大核心能力的协同达标，为后续工业级设备的规模化应用扫清了系统适配障碍，也为开源操作系统在智能制造领域的实践提供了技术参照。&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;img height="350" src="https://oscimg.oschina.net/oscnet//472a37d180cf39403ebb951658c0965b.png" width="" referrerpolicy="no-referrer"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;img height="350" src="https://oscimg.oschina.net/oscnet//0dcd44a8185cf7f842f2128c2718f224.png" width="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;openKylin 以「为世界提供与人工智能技术深度融合的开源操作系统」为愿景，致力于聚合产业及开发者力量共同打造全球领先的智能桌面开源操作系统根社区。社区构建的覆盖 「芯片 - 系统 - 应用」 的认证体系，不仅推动了开源操作系统在 RISC-V 生态、AI 融合及跨平台兼容性领域的标准化进程，也吸引了众多社区会员单位的积极参与，共同为 openKylin 生态的繁荣发展贡献力量。此次与松科智能的携手合作，将进一步加速中国开源操作系统在工业与人工智能交叉领域的渗透应用，助力产业数字化转型中的技术突破。&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;在本次开发者大会上，openKylin 2.0 SP2 版本重磅发布，诚邀所有共建伙伴与开发者点击&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.openkylin.top%2Fdownloads%2F" target="_blank"&gt;https://www.openkylin.top/downloads/&lt;/a&gt;&amp;nbsp; 下载安装，亲身体验系统新能力，共促开源生态成长。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369774</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369774</guid>
      <pubDate>Mon, 01 Sep 2025 01:35:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>飞致云开源社区月度动态报告（2025 年 8 月）</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;自 2023 年 6 月起，中国领先的开源软件公司飞致云以月度为单位发布《飞致云开源社区月度动态报告》，旨在向广大社区用户同步飞致云旗下系列开源软件的发展情况，以及当月主要的产品新版本发布、社区运营成果等相关信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;飞致云开源运营数据概览（2025 年 8 月）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;2025 年 8 月飞致云开源软件运营数据概览（统计时间为 2025.8.1～2025.8.29）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;img alt="" height="648" src="https://oscimg.oschina.net/oscnet/up-a8b0c9bef3a9289564d711fa8af1360d845.png" width="1070" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;strong&gt;&lt;span style="color:#3370ff"&gt;2025 年 8 月产品发布事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ SQLBot 智能问数系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 7 日，DataEase 开源项目组发布 SQLBot 开源项目（&lt;/span&gt;&lt;em&gt;&lt;span style="color:#010101"&gt;github.com/dataease/SQLBot&lt;/span&gt;&lt;/em&gt;&lt;span style="color:#010101"&gt;）。SQLBot 是一款基于大语言模型（Large Language Model，LLM）和 RAG（Retrieval Augmented Generation，检索增强生成）的智能问数系统。借助 SQLBot，用户可以实现数据的即问即答，快速提炼获取所需的数据信息及可视化图表，并且支持进一步的智能数据分析。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-a6f1da9e1e9331e8fdb267c8384b41b0bfd.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ DataEase 开源 BI 工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 19 日，人人可用的开源 BI 工具 DataEase 正式发布 v2.10.12 LTS 版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;这一版本的功能变动包括：图表方面，图表提示框的背景颜色支持配置透明度，桑基图提示信息中支持配置总数占比显示项，线面图的纵轴轴值自动分档时可以根据实际使用的数据自动计算最小刻度，堆叠条形图/柱状图可以设置图例排序，基础条形图/柱状图支持点击阴影部分执行下钻、联动、跳转操作；查询组件方面，下拉组件 Tag 支持自定义背景颜色；仪表板/数据大屏方面，图片组支持设置刷新频率；数据源方面，API 数据源接口参数可以调用已创建的接口参数。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;X-Pack 增强包的功能变动包括：同步管理方面，增量同步设置支持指定正负偏移量，新增支持 CTE（Common Table Expression，通用表表达式）查询；数据填报方面，批量上传的内容增加单条记录的提交信息；外观设置方面，增加是否显示 Slogan 的配置项。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ MaxKB 开源企业级智能体平台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 7 日，MaxKB 开源企业级智能体平台正式发布 v2.0.2 版本。在 MaxKB v2.0.2 版本中，社区版方面，高级编排应用新增会话变量功能，适用于用户在多次对话中进行数据暂存、逻辑判断的场景，能够有效增强系统的逻辑处理能力。X-Pack 增强包方面，在对话用户登录时，MaxKB 新增企业微信、钉钉、飞书等第三方平台扫码登录支持；在系统资源管理中，新增支持系统管理员对系统内所有工作空间的应用、知识库、工具、模型等资源进行统一管理。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 21 日，MaxKB 开源企业级智能体平台正式发布 v1.10.10 LTS 版本。这一版本在知识库方面，针对数据量较大的复杂场景，提升了知识库检索性能；问答页面方面，支持用户直接发送文件或者图片进行提问。此外，MaxKB 开源项目组还进行了一些问题修复的工作。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ JumpServer 开源堡垒机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 21 日，广受欢迎的开源堡垒机 JumpServer 发布了 v4.10.5 LTS 版本。在这一版本中，JumpServer 的新增功能包括添加报表以支持可视化数据分析和导出、改进命令记录和过滤功能以及支持 Proxmox 云主机同步等，另外，JumpServer 项目组还进行了 3 项功能优化和问题修复工作。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月 28 日，JumpServer 开源堡垒机正式发布 v3.10.19 LTS 版本。在这一版本中，Lion 组件在连接 Windows 资产时新增会话分享功能，JumpServer 新增用户与授权规则的默认过期时间设置，同时优化了授权规则、端点规则等功能，提升了运维管理的便捷性。此外，这一版本还增强了 Ansible 任务超时设置和 SSO 用户登录的 MFA 校验机制，进一步强化了系统的安全性与稳定性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ 1Panel 开源面板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;2025 年 8 月，现代化、开源的 Linux 服务器运维管理面板 1Panel 持续迭代，发布了多个新版本。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;在网站管理方面，1Panel 新增 HTTPS 防窜站功能；计划任务方面，支持任务一键导入/导出，计划任务报告页新增日志追踪和下载功能，同时还新增了任务分组功能；SSH 管理方面，1Panel 增强了 SSH 密钥管理功能，进一步提升远程运维的安全性和易用性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span style="color:#010101"&gt;此外，1Panel 开源项目组还完成了超过 60 项功能优化与问题修复，持续提升产品的稳定性和使用体验。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;strong&gt;&lt;span style="color:#3370ff"&gt;其他重要事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ MaxKB 在企业环境中实现 AI 落地的具体场景盘点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;目前，「DeepSeek+MaxKB」的组合正在被包括高等教育院校和中小学教育机构在内的用户群体所深度使用。在教育行业，MaxKB 拥有广泛的用户基础，并且持续获得认可。近期，MaxKB 新增的教育行业用户包括：浙江师范大学、上海应用技术大学、广西外国语学院、广东医科大学、张家口职业技术学院机电工程学院、天津商业大学、河南医药健康技师学院、湖南大学非洲研究院和常州信息职业技术学院。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;高等院校主要将 MaxKB 用于在本地部署的大模型之上构建 AI 助手或智能体，使用场景包括行政办公、校园服务、教学科研、技能培训、就业指导等，与已有的统一身份认证体系进行对接，面向校内师生提供服务。在此基础上，MaxKB 开始被一些院校应用在国际化办学与合作领域。同时，MaxKB 正在被越来越多的高校及中小学教师用于教学科研，有多篇教研文章公开发表。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ 1Panel 漏洞通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;2025 年 8 月 1 日，1Panel 开源项目组发布 CVE 编号为 CVE-2025-54424 的漏洞通知及修复方案。请用户尽快将 1Panel 升级至 v2.0.6 及以后的版本。1Panel V1 版本不受影响。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#00355d"&gt;■ 1Panel 应用商店下载趋势及下载排名情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;为了方便广大用户快捷安装部署相关软件应用，1Panel 特别开通应用商店，精选各类高质量的开源工具和应用软件，为用户的应用安装与升级操作提供便利。目前，1Panel 应用商店已经上架了超过 190 款精品软件并且定期更新维护，基本涵盖了大部分用户的装机需求。&lt;strong&gt;&lt;span style="color:#ff8124"&gt;2025 年 8 月，1Panel 应用商店软件下载量达到 229,212 次。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;img alt="" height="938" src="https://oscimg.oschina.net/oscnet/up-334a20f906cd0fceeedc245cf7870c724a5.png" width="1380" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;▲图 1 1Panel 应用商店月下载总量统计&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;img alt="" height="1008" src="https://oscimg.oschina.net/oscnet/up-2281427408194ff8bc02b05441ac04ac373.png" width="1454" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;▲图 2 1Panel 应用商店软件下载排名 Top 20（2025 年 8 月）&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4736111/blog/18690227</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/18690227</guid>
      <pubDate>Sun, 31 Aug 2025 11:34:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>「世界最轻量网站」阿部宽官网将采用 HTTPS</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;以 「网页加载速度极快」 闻名的日本演员阿部宽官方网站，近日因一则技术变更预告，意外在社交平台引发广泛讨论。&lt;/p&gt; 
&lt;p&gt;这个被网友亲切称作 「阿部宽的首页」 的网站，设计极度简洁复古，图片稀少，风格宛如回溯至 1990 年代网络初期，也正因如此，它在任何网络环境下都能瞬间载入，还被誉为 「世界最轻量的网站」。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1856" src="https://static.oschina.net/uploads/space/2025/0901/191845_J1jw_2720166.png" width="3360" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;http://abehiroshi.la.coocan.jp/&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;不过，支撑该网站的托管商 Nifty LaCoocan 日前宣布，为强化安全防护，将从今年 10 月 1 日起支持 https 加密连接，且预计在 2026 年 7 月后全面强制转换。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;这意味着，未来所有访问旧版 「http://」 网址的请求，都将自动跳转至新的 「https://」 页面。 &amp;nbsp;尽管 https 化能显著提升网页浏览的安全性，却也让网友们既热议又惋惜。过去，不少人会利用这个仍采用 http 协议的网站，测试老旧电脑、PDA，或是 PlayStation 2、3DS 等不支持 https 的游戏机能否正常连网。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;如今网站即将切换至 https，这个独特的 「网络联机测试页」 也将正式退出历史舞台。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;消息传开后，网络上迅速涌现大量讨论。有网友感慨：「没想到阿部宽的首页也要跟上时代浪潮了，旧设备用户要哭了」。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;与此同时，这次事件也让许多人首次认识到这个特别的网站，有人忍不住赞叹：「居然还有纯 HTML 打造的网站，速度是真的快」「这种简约风格放在现在看，反而有种新潮感」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369726</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369726</guid>
      <pubDate>Sun, 31 Aug 2025 11:21:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>用 deepin 的人，也是吃上好的了</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;deepin 搞了个 AI 助手，叫 UOS AI。&lt;/p&gt; 
&lt;p&gt;应该没有人不知道 deepin （&lt;span&gt;&lt;span&gt;深度操作系统&lt;/span&gt;&lt;/span&gt;）吧？&lt;span&gt;&lt;span&gt;它是中国第一个具备国际影响力的&lt;span&gt;&amp;nbsp;Linux&amp;nbsp;&lt;/span&gt;发行版本，支持全球&lt;span&gt;33&lt;/span&gt;种语言，在国际&lt;span&gt;&amp;nbsp;Linux&lt;/span&gt;&amp;nbsp;发行版排行榜中稳居前十。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;你是不是也跟我一样好奇，搞操作系统的，为什么也要来搞 AI 助手？&lt;/p&gt; 
&lt;p&gt;跟其他大部分只会聊天、写文章，最多生成 PPT 文件相比的 AI 小助手相比，UOS AI&amp;nbsp;有什么不一样，是不是会有更多系统级别的能力？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答案就是当然有 ！这就是搞操作系统的人搞 AI 的优势了。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前大部分的 AI 助手，能回答问题，写文章、生成图片，但它动不了我们的电脑——想整理文件、调个设置、装个软件，还是得自己动手，它始终活聊天框里。&lt;/p&gt; 
&lt;p&gt;而 UOS AI，像是这个电脑系统的大管家。它长在了系统里，拥有其他 AI 助手所没有的权限，你动动嘴，它就能直接动手帮你操作。&lt;/p&gt; 
&lt;p&gt;比如，你想批量整理系统文件，只需打开 UOS AI 助手，跟它说「把项目资料文件夹的所有文件，命名为 UOS 项目资料，按数字顺序排好」，UOS MCP 立刻识别文件，几秒钟就能完成批量重命名。&lt;/p&gt; 
&lt;p&gt;或者你说「把屏幕调亮点儿，再帮我连一下蓝牙音箱」，它不用教、不用你动手，几秒钟就能直接帮你搞定。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;简单说，最大的不一样就是：别的 AI 是说说而已，UOS AI 可以说到做到。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;就算是复杂操作，也能完成。这都是因为 deepin 开发了系统级的 MCP 服务器，高达 120+ 项系统控制，一键就能完成系统设置、应用管理、文件管理、联网搜索等。&lt;/p&gt; 
&lt;p&gt;此外，UOS AI 还支持快速接入第三方 MCP 工具或智能体，不管是想用它办公、学习，还是娱乐都可以。&lt;/p&gt; 
&lt;p&gt;总之就是别人有的，它也有了。&lt;/p&gt; 
&lt;p&gt;比如，你想要续写文档，根本不需要打开文档，对 UOS AI 说「续写桌面上的 AI 技术报告第三章，要 3 个分论点」，它就能顺着前文风格生成逻辑连贯的内容，直接保存到文档。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;也是没想到，用 deepin 系统的人吃得这么好！&lt;/strong&gt;感兴趣的朋友可以，前往官网下载最新版 deepin 体验：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh" target="_blank"&gt;https://www.deepin.org/index/zh&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;另外，我们也想探究一下， UOS AI 的 AI 能力是怎么实现的？以后还会有哪些令人期待的地方？&lt;/p&gt; 
&lt;p&gt;9 月 5 日晚，开源中国将邀请 UOS AI 产品负责人姜琬莹，做客《技术领航》栏目直播间，跟大家分享&amp;nbsp;UOS AI 的能力及实现。&lt;br&gt; &lt;br&gt; &lt;img height="740" src="https://oscimg.oschina.net/oscnet/up-210deaf87c39f1459061b78f9bfd676f627.jpg" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;p&gt;&lt;strong&gt;直播福利：&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;福袋抽奖：直播中将有 5 轮抽奖，参与就有机会获得 OSC T 恤、马建仓蛇年公仔（限量版）、代码圣杯、马克杯、冰箱贴、前沿技术书籍等。&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="up-d0ddd08ceeff2b5526d3def6537a6ac649b.png" height="253" src="https://oscimg.oschina.net/oscnet/up-d0ddd08ceeff2b5526d3def6537a6ac649b.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;hr&gt; 
 &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《技术领航》是开源中国 OSCHINA 推出的一档直播栏目，旨在为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开源软件、商业产品、前沿技术、知名品牌活动等各类项目&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供一个展示平台，基本上每周五晚上开播&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;栏目邀请项目的创始人、核心团队成员或资深用户作为嘉宾，通过路演式直播分享项目的亮点和经验，有助于提高项目的知名度，吸引更多的用户和开发者关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你手上也有好的项目，想要跟同行交流分享，欢迎联系我，栏目随时开放～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"&gt;&lt;img height="537" src="https://oscimg.oschina.net/oscnet/up-4dd54c1b0b817689ceefa15aa66d79cfae8.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3859945/blog/18690242</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/18690242</guid>
      <pubDate>Sun, 31 Aug 2025 10:40:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Firecrawl 将于 9 月 8 日开源 AI 适应性检测工具</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;网页抓取与数据处理解决方案提供商 Firecrawl &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCalebPeffer%2Fstatus%2F1962183698306179345" target="_blank"&gt;宣布&lt;/a&gt;将于 2025 年 9 月 8 日开源其 AI 适应性检测工具。&lt;/p&gt; 
&lt;p&gt;主要功能&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;符合 LLMs.txt 规范&lt;/li&gt; 
 &lt;li&gt;AI 可读的内容质量&lt;/li&gt; 
 &lt;li&gt;合理的站点地图结构&lt;/li&gt; 
 &lt;li&gt;以及 10 多项其他检查&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0901/183141_3H9U_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，该工具通过 12 项技术指标诊断网站的 AI 搜索生态适配度，涵盖 LLMs.txt 规范、站点地图完整性和移动端响应效率等维度。&lt;/p&gt; 
&lt;p&gt;Firecrawl 专注于 AI 时代网站基础设施优化，其工具可识别索引失效问题并生成 SEO 优化建议，支持 React 和 Django 等开发框架。行业认为其开源策略将降低企业应对 AI 搜索变革的技术门槛，解决传统 CMS 语义化支持不足等痛点。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369714</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369714</guid>
      <pubDate>Sun, 31 Aug 2025 10:32:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>宇树科技推出数字孪生机器人运动控制技术</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;杭州宇树科技股份有限公司申请的专利 「一种基于数字孪生的机器人运动控制方法和电子设备」 于近日正式公布。这项新技术旨在通过数字孪生技术提升机器人在舞台表演中的灵活性和适应性，进而实现复杂而精彩的舞蹈表演。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="331" src="https://oscimg.oschina.net/oscnet/up-185be11f97770d6539d0801b40b9ac9b5b0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;这项发明的核心在于构建了多个功能模块，包括环境采集模块、地图处理模块、数字舞台孪生模块、舞蹈动作设计模块、轨迹规划模块以及舞蹈合成模块。这些模块通过数据交互和功能协同，有效提升了机器人的舞蹈设计和执行能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;首先，环境采集模块能够实时收集舞台环境的信息，确保机器人及时了解周围的变化。接着，地图处理模块则将这些信息进行处理和分析，为机器人的运动提供精确的背景数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;数字舞台孪生模块是这项技术的关键，它能够创建舞台的数字化模型，帮助机器人更好地理解和适应环境。舞蹈动作设计模块则让艺术家能够设计出更为复杂和富有表现力的舞蹈动作，而轨迹规划模块则负责将这些动作与实时环境相结合，确保机器人的舞蹈表演与舞台环境的完美匹配。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;通过舞蹈合成模块，所有的舞蹈动作得以整合，形成一套完整且流畅的表演。这种高效、可扩展的舞蹈设计方案，不仅确保机器人在表演时能够精准感知和适应环境的变化，还避免了机器人动作与环境脱节的问题。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369713</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369713</guid>
      <pubDate>Sun, 31 Aug 2025 10:32:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>微软 Copilot Labs 上线「音频表达式」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软在 Copilot Labs 上线了名为「音频表达式（Audio Expression）」的实验性功能，用户可输入提示并让 AI 以不同语音风格朗读文本，该功能仅限文本转语音。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1856" src="https://static.oschina.net/uploads/space/2025/0901/180307_ik24_2720166.png" width="3360" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://copilot.microsoft.com/labs/audio-expression&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，Copilot Audio Expressions 的功能是让输出的音频更接近真人，并可根据需求加入创意润色。用户无需注册即可直接体验，并可下载 MP3 格式音频，方便在任何设备播放。&lt;/p&gt; 
&lt;p&gt;该工具目前提供 Emotive（情感表达）和 Story（故事创作）两种模式。&lt;/p&gt; 
&lt;p&gt;在 Emotive 模式下，生成的音频不仅朗读了文字，还自动增添细节、调整措辞，让表达更生动。单段音频最长 59 秒，支持十余种声音与风格组合。在 Story 模式下，系统自动选择音色和风格，用户仅需提供主题提示。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369702</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369702</guid>
      <pubDate>Sun, 31 Aug 2025 10:07:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>WhisperLiveKit - 实时、完全本地语音转文</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;实时、完全本地语音转文本，支持说话人识别。实时语音转录直接发送到你的浏览器，带有可立即使用的后端+服务器和简单的前端。&lt;/p&gt;

&lt;p&gt;&lt;img height="272" src="https://static.oschina.net/uploads/space/2025/0828/135735_EKWx_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img height="175" src="https://static.oschina.net/uploads/space/2025/0828/135747_DGD3_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;后端支持多个并发用户。语音活动检测功能可在未检测到语音时减少开销。&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;安装和快速启动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span&gt;&lt;span&gt;pip install whisperlivekit&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要 FFmpeg&lt;/strong&gt;，必须在使用 WhisperLiveKit 之前安装&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#59636e; display:block; font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Segoe UI&amp;quot;,&amp;quot;Noto Sans&amp;quot;,Helvetica,Arial,sans-serif,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;; font-size:16px; font-style:normal; font-variant:tabular-nums; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; max-width:100%; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:max-content; word-spacing:0px"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="border-color:#d1d9e0"&gt;OS&lt;/th&gt;
&lt;th style="border-color:#d1d9e0"&gt;How to install&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Ubuntu/Debian&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;code&gt;sudo apt install ffmpeg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;MacOS&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;code&gt;brew install ffmpeg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Windows&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Download .exe from&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://ffmpeg.org/download.html"&gt;https://ffmpeg.org/download.html&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;and add to PATH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/whisperlivekit</link>
      <guid isPermaLink="false">https://www.oschina.net/p/whisperlivekit</guid>
      <pubDate>Sun, 31 Aug 2025 09:55:00 GMT</pubDate>
    </item>
    <item>
      <title>GP Batteries 携手 GPTBots 打造全球智能客服网络</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;GP Batteries 携手 GPTBots 打造全球智能客服网络&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;在数字化转型浪潮中，传统制造企业如何突破边界，构建更智能、高效的客户服务体系？全球领先的电池制造商 GP Batteries（超霸电池）与企业级无代码 AI 智能体平台 GPTBots.ai 的合作，给出了行业范例。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//bb7db9d869ac1e17b95804901a3b155c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;电池专家的「客服难题」：复杂产品 + 多语言市场&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;总部位于香港的 GP Batteries，成立于上世纪六十年代，业务遍布全球 50 多个国家和地区。公司旗下产品包括 AA、AAA、CR2032、CR2025、充电电池、特种电池等数十种型号，广泛应用于家用电器、工具、电子产品等领域。然而，正是由于产品线的复杂与全球化布局，也给客户服务带来了前所未有的挑战：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;消费者难以分辨电池型号及适用场景；&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;客服需记忆庞杂知识，重复解答占用大量时间；效率难以提升；&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;跨语言、跨地区的服务响应缓慢，影响客户满意度。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;「即使是我们的员工，有时候也记不清各种型号的区别，更别说消费者了。」GP Batteries 市场负责人坦言。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;携手 GPTBots：打造「电池顾问」+「全球客服大使」&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GPTBots 提供的解决方案融合了企业知识库、AI 问答、自然语言处理与多通道接入等能力。通过拖拽式配置，GP Batteries 团队无需代码开发，即可构建具备电池型号推荐、常见问题解答、位置引导等功能的智能客服系统。目前系统已具备以下核心能力：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;即时推荐最优电池型号&lt;/strong&gt;：过训练企业知识，消费者可直接提问如「Makita 工具用哪种电池？」系统即时给出推荐型号及应用场景说明；&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;覆盖多个国家语言&lt;/strong&gt;：系统支持泰语、马来语、繁体中文等语种，原本需多团队翻译的流程可「一键完成」；&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;结合位置数据推荐购买渠道&lt;/strong&gt;：结合用户地理位置与渠道数据，推荐最近的线上/线下购买地点，打通「问-选-买」的服务闭环；&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;多渠道部署&lt;/strong&gt;：系统已在官网、社交媒体平台（如 Instagram、Facebook）、线下信息终端同步上线，实现消费者随时随地触达。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//7be1a1e9c973d1951b26feb6a4285d76.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;图片来源：https://nl.gpbatteries.com/en&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;在荷兰上线不到两个月，该系统就已覆盖超千个销售渠道相关用户咨询，客服工作量减少一半以上。聊天机器人成为首层客服接口，人工客服只处理复杂个案，整体效率大幅提升。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;运营成本下降超 50%，服务体验大升级&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GPTBots 上线后，GP Batteries 客服自动应答率超 50%，运营成本降低 50% 以上，服务时间延展至 7×24 小时，客户满意度和响应速度显著提升。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;「我们不是 AI 专家，但 GPTBots 提供的可视化平台非常友好，支持团队几乎 24 小时在线协助，让我们的构想快速落地成产品。」项目负责人表示，「从 IT、市场、到高管层，GPTBots 的专业支持让我们团队内部的沟通、共识和推进效率都提升了。」&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;AI 赋能全链条，制造业数字化转型新范式&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GPTBots 的应用不止于客户服务。GP Batteries 正在与 GPTBots 团队合作，将 AI 能力拓展至企业运营的多个关键环节：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;销售预测与供应链优化：&lt;/strong&gt;通过 AI 分析历史数据和市场趋势，提升全球销售预测的准确性，优化供应链管理，提升工厂产能利用率。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;新员工多语种培训系统：&lt;/strong&gt;基于 AI 多语种问答能力，为来自不同国家的员工统一推送标准化培训内容，极大降低沟通与培训成本。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;内部流程自动化：&lt;/strong&gt;AI 智能体参与订单处理、渠道管理、库存调度等流程，实现业务流转自动化，提升整体运营效率。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GP Batteries 市场负责人表示：「AI 的多语种能力让我们的全球团队培训和服务实现了统一标准，沟通成本大幅下降。」&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GPTBots.ai 创始人兼首席执行官罗伟东表示：「我们不仅是工具，更是企业 AI 落地的长期伙伴。很荣幸与 GP Batteries 携手，共同推动制造业服务智能化、运营数智化。」&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;结语&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;从客服自动化到企业全链条智能化，GP Batteries 与 GPTBots 的合作，展现了制造企业数字化转型的全新范式。GPTBots 也将持续以企业级无代码 AI 解决方案，助力更多企业低门槛、高效率迈向智能化未来。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369692</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369692</guid>
      <pubDate>Sun, 31 Aug 2025 09:41:00 GMT</pubDate>
      <author>作者: 开源科技</author>
    </item>
    <item>
      <title>极光月狐数据参展 2025 人民数据大会，以数据智能驱动决策新未来</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;极光月狐数据参展&lt;/strong&gt;&lt;strong&gt;2025&lt;/strong&gt;&lt;strong&gt;人民数据大会，以数据智能驱动决策新未来&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;近日，以"生态互联，价值共创"为主题的 2025 人民数据大会在深圳圆满落幕。本次大会由人民网·人民数据主办，旨在打造数据要素领域的前沿观察站、市场风向标和合作新枢纽。中国领先的全场景数据洞察与分析服务专家，极光月狐数据携旗下全线产品重磅参展，其产品副总经理刘洋航在 「生态路演」 专场发表《从 AI 生态到投资组合，数据智能时代的决策引擎》主题演讲成为大会亮点。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;聚焦数据智能，驱动商业决策&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;在大会主题演讲中，极光月狐数据产品副总经理刘洋航深入分享了数据智能时代的前沿洞察。他指出，随着人工智能技术的快速发展，AI Agent 正成为 AI 行业的核心赛道，预计到 2030 年，全球 AI Agent 市场规模达到 471 亿美元。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e68967198d81bf85c924e944750c2b2b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;"我们正处在一个数据智能驱动决策的新时代。"刘洋航表示，"极光月狐数据通过整合线上平台用户活跃度、线下门店客流、工厂产能及社交媒体舆情等多维动态数据，构建了量化金融数据的监测体系，能够提前 1-1.5 月预测企业营收趋势，为投资决策提供有力支持。"&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;四大产品体系全面亮相，展现数据实力&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;展会期间，极光月狐数据全面展示了其四大标准产品体系：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;移动应用数据（&lt;/strong&gt;&lt;strong&gt;iAPP&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;提供移动应用、小程序和手机品牌市场的覆盖与分析，帮助客户进行产品竞争分析与商业投资决策。该产品覆盖 100 万+APP，监测 14.6 亿+月独立活跃设备，累计 SDK 安装量达 625 亿+。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;营销洞察数据（&lt;/strong&gt;&lt;strong&gt;iMarketing&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;专注于多维度人群洞察，解决市场数据混乱、目标客户画像模糊等痛点，助力企业精准刻画消费者全貌、实现精准营销。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;品牌洞察数据（&lt;/strong&gt;&lt;strong&gt;iBrand&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;助力企业洞察品牌表现，打造品牌生态，包括目标客群分析、用户标签制定、人群洞察等。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;金融另类数据：&lt;/strong&gt;为金融、证券投资客户提供市场研究、行业分析，帮助投资者了解行业发展现状及趋势，抓住投资风口。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//7ecacccf169e6a3f26dc33793b2fa241.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;独特优势引领行业创新&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;极光月狐数据通过融合线上流量数据与线下行为偏好，公司能够多角度分析目标用户，为客户提供更加全面和精准的数据服务。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;此次展会中，极光月狐数据的展位（B09）吸引了大量参会者驻足交流，不少与会者对其数据产品表现出浓厚兴趣，并进行了深入的业务洽谈。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;赋能数据生态，共创行业未来&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;本次人民数据大会打造了"数据+场景+交易"三位一体对接平台，极光月狐数据通过这一平台与众多政府机构和企业进行了多维度沟通，推动了政企项目的精准对接和合作交易的高效落地。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;未来，极光月狐数据将继续秉承"让每一次数据握手，都成为价值流动的起点"的大会理念，持续深化数据智能技术研发，为繁荣数据产业生态赋能增势，助力各地各领域高质量发展。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369691</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369691</guid>
      <pubDate>Sun, 31 Aug 2025 09:41:00 GMT</pubDate>
      <author>作者: 开源科技</author>
    </item>
    <item>
      <title>具身智能高质量合成数据集开源发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;国家数据局发文&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FSi6YQUzRwOgNjN29YaOQqg" target="_blank"&gt;宣布&lt;/a&gt;，具身智能灵巧手多样抓取仿真数据集（DexonomySim）已开源发布。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;具身智能灵巧手多样抓取仿真数据集（DexonomySim）是在国家数据局数字科技和基础设施建设司指导下，由银河通用介绍发布。DexonomySim 专为具身智能机器人灵巧抓取任务设计，包含超过 950 万条高质量抓取姿态，覆盖超 1 万个物体与 31 种常用抓握类型，涵盖人类抓握分类法中约 94% 的类型，是当前具身智能领域开源的最大规模灵巧手操作高质量合成数据集。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;该数据集适用于多指灵巧手在高自由度操作场景下的模型训练与算法验证，其生成方式基于高效优化的物理仿真，具有数据格式规范统一、真实可溯、内容优质、模型适配性高等优势，且多样性与规模均远超已有数据集，有效满足模型泛化需求，助力人形机器人实现对外形不规则或需精细操作物体的稳定、多样化抓取，提升复杂环境下的操作适应性与任务成功率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="191" src="https://oscimg.oschina.net/oscnet/up-087f340a737ec99d0fd59df16c8f689f257.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;具身智能高质量合成数据集的开源，将为全球研究者和产业开发者提供关键的基础设施和生产要素支撑，加速推动人形机器人在商超零售、工业分拣、家庭服务、医疗康养等多元场景落地应用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此次成果的开源，体现出行业企业在高质量数据集建设上的积极探索，也为推动数据要素价值释放提供了鲜活实践。下一步，国家数据局将持续推进高质量数据集建设，推动人工智能与具身智能等前沿领域加速发展，助力新质生产力培育与应用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;具身智能灵巧手多样抓取仿真数据集开源链接可查看&lt;/span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdisk.pku.edu.cn%2Fanyshare%2Fzh-cn%2Flink%2FAA126F20CCF8EC44DC819FFB494FFD96AD%3F_tb%3Dnone%26expires_at%3D2045-08-30T23%253A56%253A30%252B08%253A00%26item_type%3Dfolder%26password_required%3Dfalse%26title%3D%25E5%2585%25B7%25E8%25BA%25AB%25E6%2599%25BA%25E8%2583%25BD%25E7%2581%25B5%25E5%25B7%25A7%25E6%2589%258B%25E5%25A4%259A%25E6%25A0%25B7%25E6%258A%2593%25E5%258F%2596%25E4%25BB%25BF%25E7%259C%259F%25E6%2595%25B0%25E6%258D%25AE%25E9%259B%2586%25EF%25BC%2588DexonomySim%25EF%25BC%2589%26type%3Danonymous%26verify_mobile%3Dfalse" target="_blank"&gt;此处&lt;/a&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369688</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369688</guid>
      <pubDate>Sun, 31 Aug 2025 09:28:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>微软发布开源数学推理模型 rStar2-Agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软近日发布了名为「rStar2-Agent」的开源模型，这是一个 14B 参数的数学推理模型，通过智能而非冗长的思考，实现了与 671B DeepSeek-R1 相当的性能&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;该模型通过自主规划、推理和使用代码工具来高效地探索、验证和反思复杂问题的解决方案。其能力依赖于三大创新：GRPO-RoC 算法、可扩展的高效 RL 基础设施，以及从非推理 SFT 开始的 Agent 训练方案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-9b6d7c27cd2a66813c3797df2919819a9cc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;rStar2-Agent 的核心在于实现更智能的思考而非单纯延长推理时间，通过纯粹的智能体强化学习，其性能可媲美 6710 亿参数的 DeepSeek-R1 模型。&lt;/p&gt; 
&lt;p&gt;该模型能自主规划、推理并运用编码工具，高效完成探索、验证与反思以解决更复杂问题。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;GRPO-RoC 算法——采用创新的「正确时重采样」推演策略，优化编码工具使用，通过选择性保留高质量成功轨迹（同时完整保存失败案例）实现更短更智能的推理；&lt;/li&gt; 
 &lt;li&gt;可扩展高效的 RL 基础设施，支持高吞吐量工具调用执行，同时降低智能体 RL 推演的高成本，使有限 GPU 资源（64 块 MI300X GPU）也能实现高效训练；&lt;/li&gt; 
 &lt;li&gt;Agent 训练方案：从非推理式 SFT 起步，通过多阶段 RL 逐步推进，各阶段采用精简的最大响应长度并逐步提升数据集难度。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为此，rStar2-Agent 仅用一周时间通过 510 步 RL 训练，将预训练的 140 亿参数模型提升至顶尖水平，在 AIME24 和 AIME25 数据集上分别实现 80.6% 和 69.8% 的平均通过率，以更短响应超越 DeepSeek-R1（6710 亿参数）。除数学领域外，rStar2-Agent-14B 在对齐、科学推理及智能体工具使用任务中也展现出强大的泛化能力。&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/microsoft/rStar&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369674</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369674</guid>
      <pubDate>Sun, 31 Aug 2025 08:48:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>腾讯开源混元翻译模型 Hunyuan-MT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯混元团队正式开源了面向翻译场景的 Hunyuan-MT 系列模型。该系列目前包含两个版本：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;Hunyuan-MT-7B&lt;/strong&gt;：单模型版本，支持 33 种语言之间的双向翻译，覆盖中、英、日、法等主流语种以及藏、维、蒙、哈、朝 5 种中国少数民族语言；在 WMT25 竞赛的 31 个语言方向上取得领先成绩 。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Hunyuan-MT-Chimera-7B&lt;/strong&gt;：集成模型，通过融合多路翻译结果进一步提升译文质量 。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;Hunyuan-MT-7B 在同等规模下达到了业界领先的翻译性能，而 Hunyuan-MT-Chimera-7B 通过集成多路翻译输出进一步提升了质量。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心特性与优势&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;WMT25 参赛 31 语种之中 30 语种获得第一名的成绩。&lt;/li&gt; 
 &lt;li&gt;Hunyuan-MT-7B 同尺寸业界效果最优&lt;/li&gt; 
 &lt;li&gt;Hunyuan-MT-Chimera-7B 是业界首个开源翻译集成模型，可以将翻译效果再拉高一个档次&lt;/li&gt; 
 &lt;li&gt;提出了一个完整的翻译模型训练范式，从 Pretrain-&amp;gt;CPT-&amp;gt;SFT-&amp;gt; 翻译强化 -&amp;gt; 集成强化，翻译效果达到同尺寸 SOTA。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5bd2919794ff20550f3ce6d3102fb6d0fae.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/Tencent-Hunyuan/Hunyuan-MT&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369672</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369672</guid>
      <pubDate>Sun, 31 Aug 2025 08:29:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 网关代理 RAG 检索：Dify 轻松对接外部知识库的新实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：赵源筱、王灏廷&lt;/p&gt; 
&lt;p&gt;Dify 是一款开源的 AI 应用开发平台，旨在帮助开发者和非技术人员快速构建和运营基于生成式 AI 的应用。截至目前，Dify 开源 Star 数量已经突破 11 万，具有庞大的用户群体，已成为构建生成式 AI 应用的热门选择之一。&lt;/p&gt; 
&lt;p&gt;然而，随着 Dify 在实际生产实践中持续落地，根据云上客户以及社区反馈，其内置的 RAG 引擎逐渐暴露出复杂文本分块处理能力低、检索功能薄弱、配置不够简洁智能等问题，这些问题直接导致 Dify 内置 RAG 的召回质量不理想，进而影响了大模型生成内容的准确性与可靠性，难以满足企业级生产环境对高精度知识检索的需求。&lt;/p&gt; 
&lt;p&gt;为解决上述云上客户以及社区用户反馈的问题，Higress AI 网关通过提供关键桥梁作用，支持 Dify 应用便捷对接业界成熟的 RAG 引擎。通过 AI 网关将 Dify 的高效编排能力与专业 RAG 引擎的检索效能结合，企业可在保留现有 Dify 应用资产的同时，有效规避其内置 RAG 的局限，显著提升知识驱动型 AI 应用的生产环境表现。&lt;/p&gt; 
&lt;h2&gt;Dify 内置 RAG 引擎的局限&lt;/h2&gt; 
&lt;p&gt;通过分析 Dify 开源社区近几个月的 Issue，同时结合云上客户以及内部的 Dify 生产实践，尽管目前 Dify 提供了开箱即用的内置 RAG 引擎，但在实际落地中，依然会遇到一些问题，其中被云上以及社区客户反馈比较多的问题包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;复杂文档处理能力不足：对含图片、图表、PDF 等非结构化文档的解析与分块能力较弱，信息提取精度有限。&lt;/li&gt; 
 &lt;li&gt;检索功能薄弱：内置检索策略在复杂查询或大型知识库场景下，召回效果和相关性排序表现欠佳，导致关键信息遗漏或排序不当。&lt;/li&gt; 
 &lt;li&gt;配置不够简洁智能：分块策略、参数调整等配置项繁多，缺乏自适应优化，用户需较高技术门槛才能调优，易用性不足。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;这些问题导致 Dify 内置 RAG 引擎和业界被广泛认可的高质量 RAG 引擎相比，仍存在一定的提升空间。从开源视角来看，Dify 内置 RAG 能力的提升，是一项需要持续迭代和优化的过程。&lt;/p&gt; 
&lt;h2&gt;通过 AI 网关帮助 Dify 应用"开挂"&lt;/h2&gt; 
&lt;p&gt;目前，市面上的 RAG 引擎层出不穷，但易用性和运行效果上也良莠不齐，想要构建一套优秀的 RAG 引擎，并不仅仅是向量化、向量存储与向量匹配那么简单，还需要优质的内容理解与处理算法以及检索优化策略，并且持续不断的调优。&lt;/p&gt; 
&lt;p&gt;好在市面上已经逐渐涌现了许多优秀的 RAG 引擎，逐渐得到越来越多的开发者认可。例如阿里云百炼知识库以其配置简洁、开箱即用的特性，加之以底层持续调优，其 RAG 效果也得到越来越多企业用户的认可；以深度文档理解能力著称的 RagFlow，作为一款开源的专业 RAG 引擎，得到许多对数据存储有安全和隐私性要求用户的青睐，目前能够通过阿里云 SAE 一键部署高可用的 RagFlow 实例，极大降低自部署和运维的成本。&lt;/p&gt; 
&lt;p&gt;因此，快速打通更专业更优质的 RAG 引擎，现阶段也不失为一个更优解。&lt;/p&gt; 
&lt;p&gt;为了突破 Dify 内置知识库的限制，Higress AI 网关支持 Dify 应用快速对接外部优质 RAG 引擎，以更高质量的 RAG 能力替代其原生功能，从而实现让用户在使用 Dify 强大的 Workflow、Agent 编排能力同时，获得更专业的文本处理与信息检索体验。&lt;/p&gt; 
&lt;p&gt;根据用户对检索结果处理方式的不同需求，Higress AI 网关提供了两种灵活的集成方案：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;：RAG 检索代理。Higress AI 网关仅做检索并返回给用户，由用户自主处理检索结果，并更新到 Context 中。适用于场景相对复杂，用户对信息整合有自定义诉求的场景。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;：自动检索注入。在调用 LLM 的链路中，Higress AI 网关自动执行 RAG 检索结果并将接入注入到 Context 中。适用于场景相对简单，用户只关注 LLM 调用结果，无信息自主处理的场景。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;方案一：RAG 检索代理&lt;/h3&gt; 
&lt;p&gt;基于 Dify 外部知识库扩展功能，通过 Higress AI 网关代理，能够实现在 Dify 知识库中创建并连接 RagFlow 以及百炼知识库。对于 Workflow，可以使用知识检索节点选择对应外部知识库获取检索结果；对于 Agent，可以直接选择对应外部知识库实现检索。详细介绍请见 AI RAG 检索代理 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;1]&lt;/strong&gt; 。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-50022f9250479a4f65adce4098314a7590e.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这种方式专门针对 Dify 应用设计，更符合 Dify 的标准用法，通过 Dify 知识库扩展的能力实现了对外部知识库的访问，同时能够便捷的通过 Dify 内置的观测能力观察知识检索节点的输入输出信息。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-029a85347f2c8716ec6d005e559f008df57.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;方案二：自动检索注入&lt;/h3&gt; 
&lt;p&gt;Dify 应用访问 LLM 时，使用 Higress AI 网关的 Model API 代理，Higress AI 网关在发起 LLM 调用前，自动执行 RAG 检索并把结果写入到调用模型的 Context 中。其中，Context 的写入方式包括：追加新的系统提示词；添加到用户指定的 Prompt 模版位置中。详细介绍请见 AI 检索增强生成（加强版） &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;2]&lt;/strong&gt; 。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-37317d346525f1308d6134a70522562da3c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这种方式能够实现对应用开发者透明，无需手动实现复杂的知识库检索步骤，只需直接调用模型即可自动获得开箱即用的 RAG 能力。此外，该方式同样适用于 Spring AI Alibaba、N8N 等不同平台或框架。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-f5fcf65535c2b10d24ede8cf7f01f19f366.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;实操指南与效果展示&lt;/h2&gt; 
&lt;p&gt;接下来，本文将分别以使用 RAG 检索代理方案打通 Dify 与百炼知识库、使用自动检索注入方案打通 Dify 与 RagFlow 为例，详细介绍上述两种方案的操作方式，并展示实际效果。&lt;/p&gt; 
&lt;h3&gt;实践案例一：Dify 知识检索节点访问百炼知识库&lt;/h3&gt; 
&lt;p&gt;本节将以 Dify 应用打通已经存在的百炼知识库为例，介绍 RAG 检索代理方案的操作方式与实际效果。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;AI 网关创建百炼服务、自定义 Agent API 路由，作为 Dify 外部知识库 API。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;a. AI 网关创建百炼检索服务。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-148c0d00f39b5199dbbe46389c47176625c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;b. 创建自定义 Agent API。点击 Agent API-创建 Agent API，域名和 Base Path 可按需自定义，协议选择自定义，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9ac33d5851e7f877d84b253346380a98137.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;c. 创建 Agent API 路由。进入已经创建的 Agent API，点击创建路由，注意需要确保路径后缀为/retrieval，服务选择前述步骤创建的百炼服务。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bbba2ddbeb01cd5832aabdb6901806eeade.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol start="2"&gt; 
 &lt;li&gt;AI 网关配置插件。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;a. 获取百炼 API KEY。登录阿里云百炼平台 API Key &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;3]&lt;/strong&gt; 并获取 API Key。&lt;/p&gt; 
&lt;p&gt;b. 配置插件。在网关实例控制枱，点击插件-安装插件-AI，选择 &lt;strong&gt;AI RAG 检索代理&lt;/strong&gt;插件，点击安装并配置规则，设置启用并点击保存后，插件即可生效，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-4a71365d273d7a1b2712ce0c66cf6e6469c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol start="3"&gt; 
 &lt;li&gt;Dify 创建百炼知识库。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;a. Dify 知识库创建外部 API。在 Dify 控制枱，点击知识库-外部知识库 API-添加外部知识库 API，配置示例如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0e30fc4c4aed2179bbbe9e15426f8734feb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;b. 获取知识库 ID。前往百炼知识库控制枱，选择待检索的知识库并获取 ID，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-979d1e29b06fadfeae2c16c4b78e7061058.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;c. 配置知识库信息。在 Dify 控制枱，点击知识库-连接外部知识库，配置示例如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-68e17e5fed0881b2794e4a7fd4958ee09a4.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;验证检索连通性。在 Dify 知识库页面点击上述步骤创建的知识库，在召回测试输入源文本进行验证，能够根据召回设置返回文本分块，即说明实现连通。接下来就可以在 Workflow 和 Agent 中通过访问已创建好的知识库进行百炼 RAG 检索。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-df8b970e03130d997af9f92ecc9ca27d8db.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c245fbe79de6ea728d6f3e612e6a256640b.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;实践案例二：模型调用前自动检索 RagFlow&lt;/h3&gt; 
&lt;p&gt;接下来，本节以 Dify 应用打通已经存在的 RagFlow 知识库为例，介绍自动检索注入方案的操作方式与实际效果。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;部署 RagFlow 、创建知识库并上传知识。对于企业级场景，推荐使用阿里云 SAE 一键部署高可用版本 RagFlow 服务，降低部署和运维成本，详情请见 RAGFlow 社区版-Serverless 部署 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;4]&lt;/strong&gt; 。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在 AI 网关创建 AI 服务和文本生成场景 Model API，让 Dify 应用通过调用该 API 访问模型。使用 AI 网关代理 Dify 模型流量操作方式可参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNzYxNjAzMg%3D%3D%26mid%3D2247576813%26idx%3D1%26sn%3Dc515eb8c39eb3133e9b44a0d7ad17610%26scene%3D21%23wechat_redirect" target="_blank"&gt;Dify 性能瓶颈？Higress AI 网关为它注入「高可用之魂」！&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;AI 网关插件配置。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;a. AI 网关创建 RagFlow 服务，同时获取 RagFlow 服务的 FQDN 和 Port。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-5d60d80f89f735da7cd3fefbd597bd60c57.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;b. 获取 RagFlow API Key。进入 RAGFlow 控制枱，点击右上角用户头像 -&amp;gt; 左侧选择 API -&amp;gt; API KEY，获取 API Key。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-e3eeaa4a2170349a024e49c3fc7f7fada21.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;c. 获取 RagFlow 知识库 ID。在 RAGFlow 知识库页面，点击对应知识库，网页 url 中的 id 即为知识库 ID。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-03c3db5ccb6253879a352c39e8ce0210888.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;d. 配置网关插件。在网关实例控制枱，点击插件-安装插件-AI，选择 &lt;strong&gt;AI 检索增强生成（&lt;strong&gt;加强版&lt;/strong&gt;）&lt;/strong&gt; 插件，点击安装并配置规则，配置到对应的生效范围，将前述步骤获取的参数添入到指定参数位置，配置示意如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-33412f7f370eb15f0f7377949cdf26f703a.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;调试并验证效果。在 AI 网关实例控制枱，点击插件作用生效的 Model API 并调试，验证添加自动检索能力之后的模型返回结果。验证无误后，在 Dify 中通过访问该 API 进行模型访问，即可具备打通 RagFlow 知识库的 RAG 能力。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-2cd4c8b2cd0eea653b1f45d4cd259cd2078.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;总结与展望&lt;/h2&gt; 
&lt;p&gt;由于 Dify 内置 RAG 引擎在生产实践中的效果局限，许多 Dify 应用开发者期望能便捷的为 Dify 系统打通更多外部知识库，丰富 RAG 系统的选型。Higress AI 网关提供了快速打通外部 RAG 引擎的方案，将 Dify 的高效编排能力与专业 RAG 引擎的检索效能结合。通过帮助 Dify 应用"开外挂"，主要带来以下增益：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;效果跃升：通过集成 RAGFlow、百炼知识库等专业引擎，显著提升知识分块质量与检索准确性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;无缝增强：配置化实现，无需改造 Dify 应用代码即可获得高阶 RAG 能力，0 开发成本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;灵活适配：支持开源引擎私有化部署或 SaaS 化服务的 RAG 引擎选型，满足多样化场景需求。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;目前，该能力已经上线至阿里云云原生 AI 网关 &lt;strong&gt;[&lt;/strong&gt; &lt;strong&gt;5]&lt;/strong&gt; 中，除此以外，Higress AI 网关还提供了安全、高可用治理等其他丰富能力，提升 Dify 应用安全性和可用性。在 RAG 方面， Higress AI 网关将持续深化 RAG 能力，在多模态、生态扩展、场景扩展等方面持续探索，帮助 Dify 等 AI 应用从"可用"走向"高精度、高可靠"的企业级知识中枢。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相关链接：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;[1] AI RAG 检索代理&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Fapi-gateway%2Fai-gateway%2Fuser-guide%2Fai-retrieval-agent" target="_blank"&gt;https://help.aliyun.com/zh/api-gateway/ai-gateway/user-guide/ai-retrieval-agent&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;[2] AI 检索增强生成（加强版）&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhelp.aliyun.com%2Fzh%2Fapi-gateway%2Fai-gateway%2Fuser-guide%2Fai-retrieval-enhanced-generation-enhanced-version" target="_blank"&gt;https://help.aliyun.com/zh/api-gateway/ai-gateway/user-guide/ai-retrieval-enhanced-generation-enhanced-version&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;[3] API Key&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbailian.console.aliyun.com%2F%3Ftab%3Dmodel%23%2Fapi-key" target="_blank"&gt;https://bailian.console.aliyun.com/?tab=model#/api-key&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;[4] RAGFlow 社区版-Serverless 部署&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsaenext.console.aliyun.com%2Fcn-hangzhou%2Fscene-market%2Fmarket%2Fdetail%2Fservice-611f1d5343924329a69e%3Ftab%3Ddocument%26name%3DRAGFlow%25E7%25A4%25BE%25E5%258C%25BA%25E7%2589%2588-Serverless%25E9%2583%25A8%25E7%25BD%25B2%26dataSource%3DcomputeNest" target="_blank"&gt;https://saenext.console.aliyun.com/cn-hangzhou/scene-market/market/detail/service-611f1d5343924329a69e?tab=document&amp;amp;name=RAGFlow%E7%A4%BE%E5%8C%BA%E7%89%88-Serverless%E9%83%A8%E7%BD%B2&amp;amp;dataSource=computeNest&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;[5] 阿里云云原生 AI 网关&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aliyun.com%2Fproduct%2Fapigate" target="_blank"&gt;https://www.aliyun.com/product/apigate&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;🔥🔥拥抱 AI 原生！&lt;/p&gt; 
&lt;p&gt;8 月 29 日深圳，企业实践工作坊火热报名中！&lt;/p&gt; 
&lt;p&gt;阿里云诚挚邀请您参加【AI 原生，智构未来------AI 原生架构与企业实践】工作坊，从开发范式到工程化实践，全链路解析 AI 原生架构奥秘，与 AI 先行者共探增长新机遇。&lt;/p&gt; 
&lt;p&gt;⬇️ 点击&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1678323" target="_blank"&gt;此处&lt;/a&gt;，立即了解完整议程！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3874284/blog/18690020</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3874284/blog/18690020</guid>
      <pubDate>Sun, 31 Aug 2025 08:17:00 GMT</pubDate>
      <author>原创</author>
    </item>
  </channel>
</rss>
