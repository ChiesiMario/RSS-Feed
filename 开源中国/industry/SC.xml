<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 简体中文</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 25 Jul 2025 07:44:16 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Qwen3-Coder 和 Kimi-K2 均已上线模力方舟</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Kimi-K2 和 Qwen3-Coder 这两个模型是最近在编程任务上表现不错的开源模型，关于二者的比较可阅读这篇文章：&lt;em&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/news/362129/kimi-k2-vs-qwen-3-coder-coding-comparison"&gt;Kimi K2 和 Qwen-3 Coder 在编程任务的详细对比&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/360215/kimi-k2"&gt;&lt;strong&gt;Kimi K2&lt;/strong&gt;&amp;nbsp;&lt;/a&gt;是一个最先进的混合专家 (MoE) 语言模型，激活参数为 320 亿，总参数为 1 万亿。通过 Muon 优化器进行训练，Kimi K2 在前沿知识、推理和编码任务上表现出色，同时在智能体能力方面进行了精心优化。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/news/361848"&gt;&lt;strong&gt;Qwen3-Coder-480B-A35B-Instruct&lt;/strong&gt;&lt;/a&gt;&amp;nbsp; 是一款专为代码生成、代码理解和高效开发场景设计的大型语言模型。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;模力方舟已上线这两个模型：&lt;/p&gt; 
&lt;p&gt;&lt;img height="798" src="https://static.oschina.net/uploads/space/2025/0725/153841_vb9V_2720166.png" width="2540" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153900_equi_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;访问网址&amp;nbsp;&lt;a href="https://ai.gitee.com/serverless-api" target="_blank"&gt;https://ai.gitee.com/serverless-api&amp;nbsp;&lt;/a&gt;即可体验。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362345</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362345</guid>
      <pubDate>Fri, 25 Jul 2025 07:40:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌 CEO 皮查伊个人财富达 11 亿美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#242424"&gt;Alphabet Inc. 本周凭借一份重磅财报跨越了一个新的里程碑，标志着该公司自 2023 年初以来市值增长超过 1 万亿美元的惊人增长历程。据彭博社报道，Alphabet 在此期间为投资者带来了 120% 的回报。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这一飙升也使印度裔首席执行官桑达尔·皮查伊（Sundar Pichai）一跃成为亿万富翁。根据彭博亿万富翁指数，现年 53 岁的皮查伊目前的身价为 11 亿美元，这主要得益于 Alphabet 的强劲增长以及多年来稳定的薪酬。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="370" src="https://oscimg.oschina.net/oscnet/up-bb4910901988674d27aa1657be7af73ddd9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;对于非公司创始 CEO 来说，这是一项罕见的成就，尤其是在科技行业，包括 Meta Platforms 的扎克伯格和英伟达的黄仁勋在内的许多高管的财富都来自于在各自公司的创始股权。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;尽管皮查伊在 1998 年谷歌创立时并不在场，但截至本月他将成为了任职时间最长的首席执行官，今年 8 月就将是他上任 10 周年。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Alphabet 股价周四一度上涨 4.1%，此前该公司公布的第二季度业绩好于预期。该公司将 2025 年的资本支出预期上调了 100 亿美元，达到 850 亿美元，主要用于资助人工智能基础设施建设。「我们的人工智能基础设施投资对于满足云客户需求的增长至关重要。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span style="color:#000000"&gt;该公司还公布研发支出增长了 16%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:start"&gt;&lt;a href="https://www.oschina.net/news/362043" target="news"&gt;谷歌母公司发布 Q2 财报：全年资本支出飙升至 850 亿美元&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362344</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362344</guid>
      <pubDate>Fri, 25 Jul 2025 07:37:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>清华大学&amp;生数科技提出可控长时文生音频系统 FreeAudio</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;清华大学与生数科技&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FRmYYXiW0yU8Ey8BbzkYMSw" target="_blank"&gt;合作&lt;/a&gt;发表论文，提出了一种名为&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffreeaudio.github.io%2FFreeAudio%2F" target="_blank"&gt;FreeAudio&lt;/a&gt;的精准时间可控长时文生音频系统。该系统无需额外训练，即可基于自然语言文本和时间提示，生成超过 10 秒且时间点精确可控的音频，突破了现有技术普遍存在的 10 秒时长限制。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153316_1wmg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://arxiv.org/abs/2507.08557&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;FreeAudio 系统利用大语言模型（LLM）对时间结构进行规划，将复杂的文本和时间提示解析为一系列不重叠的时间窗口，并为每个窗口生成独立的描述。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153346_YDxo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/153420_m0XE_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;随后，通过「解耦与聚合注意力控制」机制，在 DiT-based T2A 模型中引导各子段与对应描述对齐。最后，通过上下文潜变量合成、参考引导和上下文修剪与拼接等长时生成优化技术，确保音频片段间的平滑过渡和全局一致性。在 AudioCondition 测试集上，FreeAudio 的事件级和片段级得分均排名第一，并在多项客观和主观评估中表现优异。&lt;/p&gt; 
&lt;p&gt;该研究成果已被计算机多媒体领域的顶级会议 ACM Multimedia 2025 录用，并可能在未来应用于生数科技的 Vidu 产品中。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362341</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362341</guid>
      <pubDate>Fri, 25 Jul 2025 07:35:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源企业级智能体平台 MaxKB 正式发布 v1.10.9 LTS 版本</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="color:#000000; text-align:start"&gt;2025 年 7 月 24 日，MaxKB 开源企业级智能体平台正式发布 v1.10.9 LTS 版本。这一版本主要进行了一些问题修复工作。&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;问题修复&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;安全：修复 MCP 调用时可能存在的远程命令执行漏洞（CVE-2025-53928）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;知识库：修复飞书知识库文档在「设置」功能中修改「命中处理方式」选项时保存报错的问题（X-Pack）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;知识库：修复在文档中添加、删除、修改分段操作后，文档列表的更新时间未同步更新的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;函数库：修复内置的数据库查询函数序列化为 JSON 字符串时失败的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;问答页面：修复通过快捷键复制粘贴图片时，会覆盖此前上传图片的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;问答页面：修复 Firefox 浏览器无法通过拖拽方式上传文件的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;问答页面：修复上传的文件名称中含有「&lt;/span&gt;&lt;em&gt;&lt;span&gt;&amp;amp;nbsp&lt;/span&gt;&lt;/em&gt;&lt;span&gt;」 字符时，不显示 URL 的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;问答页面：修复应用名称过长导致界面显示错位的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;问答页面：修复对话记录超过 20 条后无法展示最新提问的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;问答页面：修复开场白中单个英文单词被拆分显示到两行的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;应用：修复简易应用未在「显示设置」功能中勾选「显示历史记录」选项时，问答页面显示异常的问题（X-Pack）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;应用：修复高级编排应用中，部分情况下丢失思考过程标签的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;应用：修复对话用户并发较多时，特殊情况下会出现数据库文件损坏的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;应用：修复在对话日志中自定义查询时间后导出报错的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;应用：修复通过 API Key 进行非流式对话时未统计 Token 消耗的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;应用：修复指定回复节点输出的表单参数中含有特殊字符导致报错的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;应用：修复 MCP 节点的配置信息填写错误时提示信息不正确的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;应用：修复使用阿里云百炼的 DeepSeek-R1 模型通过 Streamable HTTP MCP 方式调用 MCP 服务时无法返回内容的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;安装部署：修复若干已知问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#5a55fa"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;API 文档：修复若干已知问题。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4736111/blog/18685802</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/18685802</guid>
      <pubDate>Fri, 25 Jul 2025 07:29:13 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>从 「卡顿」 到 「秒开」：外投首屏性能优化的 6 个实战锦囊</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    
    ********************************************************************************************************************
    ********************************************************************************************************************
    ********************************************************************************************************************
    ********************************************************************************************************************
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18684649</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18684649</guid>
      <pubDate>Fri, 25 Jul 2025 07:26:13 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Anthropic 组建「AI 精神病学」团队</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;昨日，Anthropic 神经科学研究员 Jack Lindsey &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FJack_W_Lindsey%2Fstatus%2F1948138767753326654" target="_blank"&gt;宣布&lt;/a&gt;，公司将成立「AI 精神病学」团队，作为其可解释性部门的重要组成部分，旨在研究模型的角色、动机和情境意识，以及如何导致诡异、失控等行为表现，以建立对神经网络的机制性理解并确保其安全性。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-02d75dfdeeb8071e8534839cdb867691694.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该团队短期内重点攻克「叠加」问题（导致模型神经元和注意力头等计算单元难以单独解释），并致力于将模型分解为更具可解释性的组件。&lt;/p&gt; 
&lt;p&gt;目前，Anthropic 正在招聘研究科学家（年薪 31.5-56 万美元，约合人民币 220 万-400 万元）加入该团队，鼓励任何有意愿的人申请，并非所有候选人需完全符合列出的资格要求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362333</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362333</guid>
      <pubDate>Fri, 25 Jul 2025 07:25:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>新起点·新征程·新高度！禅道软件全面升级为集团公司</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;2025 年 7 月，禅道软件（青岛）有限公司全面升级，正式更名为禅道软件（青岛）集团有限公司（&lt;strong&gt;以&lt;/strong&gt;下简称「禅道集团」）。&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;此次战略升级标志着禅道在深耕项目管理领域 16 年后，正式迈入规模化、多元化发展的全新格局，也标志着禅道在企业规模、业务布局和发展战略上迈入了全新阶段。&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:center"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zentao.net%2Ffile.php%3Ff%3Dzentao%2F202507%2Ff_9ddee713753c983c95c1c0405e560671%26t%3Dpng%26o%3D%26s%3D%26v%3D1753082376" target="_blank"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//7f1679fb170766fcc44a1592300e0a77.jpg" referrerpolicy="no-referrer"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;集团化升级，开创发展新高度&lt;/h2&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#39485d"&gt;禅道集团的升级，是公司战略布局的重要里程碑，也是对客户价值的深度承诺。升级后的禅道集团，依托在项目管理领域的深厚积累，持续深耕项目管理领域，聚焦企业协作效率提升，通过技术创新与管理实践的融合，让更多企业享受数字化转型红利。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;聚力前行，共筑项目管理新生态&lt;/h2&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#39485d"&gt;作为国内领先的项目管理软件提供商，禅道集团始终致力于为企业提供专业、高效的项目管理解决方案。升级后的禅道集团将进一步整合资源优势，完善旗下产品和服务生态，为广大用户提供更加全面、优质的项目管理服务体验。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;不忘初心，赋能每一个成长中的企业&lt;/h2&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;升级后的禅道集团将继续坚持自主研发与开源开放的初心，秉承「让每一个成长中的企业都可高效协作」的使命，不断创新产品技术，拓展业务领域，全面赋能企业智能化转型，为推动项目管理行业发展贡献更大力量。&lt;/p&gt; 
&lt;p style="color:#39485d; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;站在新的起点，未来的禅道集团将以更开放的姿态、更专业的服务，与百万用户共同书写国产项目管理新篇章！&lt;/strong&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362330</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362330</guid>
      <pubDate>Fri, 25 Jul 2025 07:23:13 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>AI 编程工具 Lovable 年收入突破 1 亿美元，全面转向 Agentic 模式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 编程工具初创公司 Lovable&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flovable.dev%2Fblog%2Fagent" target="_blank"&gt;宣布&lt;/a&gt;其年度经常性收入（ARR）已正式突破 1 亿美元，距离其实现首个 100 万美元 ARR 仅用时 8 个月，成为全球增长最快的初创公司之一。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/151258_YWyp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前，用户已在 Lovable 上构建了超过 1000 万个项目，每天新增项目达 10 万个。公司团队现有 45 人，并在近期以 18 亿美元估值完成了 2 亿美元的融资。&lt;/p&gt; 
&lt;p&gt;同时，Lovable 发布了重大的产品更新，全面转向 Agentic 模式，并将其设为新用户的默认体验。新的 Agent 模式旨在更像一个真正的开发者，当接收到请求时，它会解释需求、探索代码库以理解上下文、发现缺失部分、进行修改并修复出现的问题，最后提供清晰的总结，整个过程无需用户逐步指导。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-dc15c72df0829afada2bde8461a321e6adc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据称，这种新模式将错误减少了 91%。Agentic 模式还解锁了与现实世界的集成能力，Lovable 现在可以利用外部工具执行代码编写之外的操作，如浏览网站、从 URL 获取内容、搜索网络信息、生成和编辑图像、在代码库中搜索特定模式以及跨多个文件同步更新代码。&lt;/p&gt; 
&lt;p&gt;随着模式的转变，Lovable 也转向了基于用量的定价模型。请求的成本根据其复杂性可能低于 1 个积分或需要数个积分。&lt;/p&gt; 
&lt;p&gt;公司表示，这种模式下许多操作的成本会降低，且编辑更精确，每次交互能完成更多工作，对大多数用户而言更实惠。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362329/lovable-agent</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362329/lovable-agent</guid>
      <pubDate>Fri, 25 Jul 2025 07:17:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 计划于 8 月初发布 GPT-5</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2Fnotepad-microsoft-newsletter%2F712950%2Fopenai-gpt-5-model-release-date-notepad" target="_blank"&gt;据报道&lt;/a&gt;&lt;/u&gt;，OpenAI 计划于 8 月初发布 GPT-5。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/145718_7osQ_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/145405_JoVW_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这一备受瞩目的升级版 AI 模型由 OpenAI CEO 奥特曼亲自预热，集成了 o 系列推理能力，定位为通往 AGI（通用人工智能）的关键一步。&lt;/p&gt; 
&lt;p&gt;奥特曼表示，他测试新模型时，GPT-5 成功解答了一封邮件中他自己都没看懂的问题，&lt;strong&gt;让他感受到前所未有的「无能为力」，他甚至夸张地表示「那时我靠在椅子上，心里想：哇，这一刻终于来了……」。&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;那本来是我觉得自己应该能搞定的问题，但我却做不到。这真的挺难受的。但 AI 就轻轻松松地完成了。那是一种很奇怪的感觉。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height="340" src="https://static.oschina.net/uploads/space/2025/0725/145818_Frtu_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;GPT-5 相关情况如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;版本信息&lt;/strong&gt;：GPT-5 将包含标准版、mini 版和仅通过 API 提供的 nano 版。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;功能特点&lt;/strong&gt;：GPT-5 将不再单独推出 o 系列模型，而是将其推理能力内嵌其中，成为 OpenAI 整合大模型架构的重要里程碑，有望提升泛用性与一致性，为通用人工智能（AGI）奠定基础。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;发布时间的不确定性&lt;/strong&gt;：尽管定档 8 月初，但消息人士透露，OpenAI 仍可能依据开发测试、安全审查甚至竞品动向调整发布时间表。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/145323_0uW1_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，奥特曼此前预告的开源模型也即将上线，赶在 GPT-5 前夕，是一款类似 o3 mini 的开源语言模型。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362321/openai-gpt-5-model-release-date-notepad</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362321/openai-gpt-5-model-release-date-notepad</guid>
      <pubDate>Fri, 25 Jul 2025 06:55:13 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>浙大校友推出 AI 代码测试神器，30 分钟打造无 bug 网站</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;浙江大学校友团队开发出了一款名为 TestSprite2.0 的智能测试平台，声称可以在 30 分钟内创建一个全新的网站，而且全程不需要人工干预。且 AI 生成代码的准确率也实现了从 42% 提升至 93%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;根据介绍，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.testsprite.com%2F" target="_blank"&gt;TestSprite&lt;/a&gt; 是首个专为 AI 编程设计的测试平台，用户只需在集成开发环境（IDE）中输入一句简单的命令：「使用 TestSprite 测试这个项目」。随后，平台会自动审查项目需求文档、描述符和代码库，并生成一个全面的集成测试计划。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="389" src="https://oscimg.oschina.net/oscnet/up-dfabcc9bef641e981714d4f0a849a8180aa.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在测试过程中，TestSprite 会自动完成以下几个步骤:生成所需的测试用例、编写测试代码、编译测试脚本，并在云端基础设施上并行执行这些测试。最后，系统会将结构化报告反馈给开发者，清楚地指出哪些功能通过了测试，哪些存在问题。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;测试结果显示，在使用 Trae 编写代码时，TestSprite 能够自动进行测试、调试和修复错误，最终只用了 30 分钟就创建出了一个无 bug 的网站。这个效率不仅让开发团队大大节省了时间，也帮助他们更好地聚焦于问题，迅速优化代码。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;TestSprite2.0 引入了强大的调度和监控功能，旨在为持续测试提供保障，确保系统始终处于可发布状态。该平台的智能调度引擎实现了跨时区的自动化测试，实时推送 QA 预警与故障分析，有效降低了版本回退的风险。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362311</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362311</guid>
      <pubDate>Thu, 17 Jul 2025 06:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>财跃星辰发布「AI 小财神 Pro」智能体</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;大模型科技公司财跃星辰宣布推出自主研发的金融深度研究智能体产品——「AI 小财神 Pro」，具备创新性智能体框架、独家数据与专业工具集、专属长期记忆等核心优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;财跃星辰由上海报业集团旗下国内领先的财经媒体和金融信息服务商界面财联社与国内头部通用大模型公司阶跃星辰联合成立。根据介绍，AI 小财神 Pro 基于阶跃星辰 Deep Research 能力构建了一套专为复杂研究任务设计的大模型智能体框架。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="276" src="https://oscimg.oschina.net/oscnet/up-2454159c179b4fd18f6e6d5c48964d42aa8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;当用户提出需求时，先由规划智能体（Plan Agent）模拟研究人员的思考与行为逻辑做出规划，将研究任务拆解为多个独立的子任务，分发给对应的「子智能体」。随后，多个子智能体会同步开展企业基本面分析等，互不依赖和干扰，极大缩短了信息搜集与分析的时间。最后，专家报告智能体会对所有子任务结果进行整合，不仅进行金融信息整理、加工、编辑与校准，确保产出内容的逻辑性与专业性，还能按照机构研报的标准生成逻辑严密、可读性强的最终报告。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这种创新架构带来了显著的效率提升。在实际应用中，能够将传统需要 5 小时完成的深度研究报告缩短至半小时内完成。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外， AI 小财神 Pro 深度融合了财联社的独家数据资源，并提供化繁为简的智能绘图工具，将枯燥的财务数据自动转化为直观、清晰的可视化图表，如 K 线图、财务比率图、趋势分析图等。AI 小财神 Pro 还内置独特的长期记忆机制，能够主动学习并记忆用户的个人偏好、研究习惯与特定需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;财跃星辰还同步自主研发了 FinResearchBench——一个专为金融深度研究量身打造的评测框架。在这一评测体系下， AI 小财神 Pro 的综合得分达到 70.73，在国内所有参评产品中位列第一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在衡量数据可视化与文本内容融合能力的「图文结合能力」（Visual-Linguistic Synergy）维度上，AI 小财神 Pro 以 70.05 分的绝对优势高居所有参评模型（包括 Gemini、OpenAI 等国际顶尖模型）的榜首。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="138" src="https://oscimg.oschina.net/oscnet/up-45e2c4da7e4bfa54086b0ccf55ecc1f4ec8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;而在 GitHub 上公布的外部评测榜单 FinGAIA 上，AI 小财神 Pro 也获得了国内第一的成绩。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="196" src="https://oscimg.oschina.net/oscnet/up-bcdb37d0e9f531837a0c5700e3f0e0bf499.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362303</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362303</guid>
      <pubDate>Thu, 17 Jul 2025 06:09:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌：只要 AI 内容合规，SEO 基本原则依旧适用</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;在最近举办的搜索中央直播会议上，谷歌的搜索专家加里・伊利斯 (Gary Illyes) 和切瑞・西瑞通・普罗马温 (Cherry Sireetorn Prommawin) 详细阐述了人工智能 (AI) 如何影响谷歌搜索，并强调了 SEO (搜索引擎优化) 基本规则依旧有效。他们的观点由谷歌产品专家铃木健一在 LinkedIn 上分享，指出像 AI 概述和 AI 模式这样的新 AI 功能是建立在传统谷歌搜索的基础设施上的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="312" src="https://static.oschina.net/uploads/space/2025/0725/113206_VdRO_4252687.jpg" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;伊利斯和普罗马温表示，核心系统如谷歌机器人 (Googlebot)、搜索索引和排名算法仍然在驱动 AI 搜索结果。因此，现有的 SEO 原则依然适用，没有必要重新思考你的策略或单独制定 「AI SEO」 策略。只要网站遵循谷歌的质量指导方针，情况就不会发生变化。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;伊利斯还强调，谷歌并不试图区分人类生成的内容和 AI 生成的内容。关键在于内容是否高质量、有用和可信。如果 AI 生成的材料符合这些标准，那么就没有问题。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;随着 AI 技术的发展，AI 模型现在参与了谷歌搜索的每个环节。在爬虫阶段，AI 帮助决定何时抓取网站；在索引阶段，BERT 语言模型分析文本以理解其含义并过滤掉被谷歌认为低价值的页面。同时，SpamBrain 用于检测垃圾信息，RankBrain 用于理解新的和不寻常的搜索查询，帮助提供相关结果，即使是谷歌以前未见过的问题。多任务统一模型 (MUM) 则将不同格式的信息 (包括文本、图像和视频) 整合在一起。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 概述在搜索过程的最后阶段有所不同。谷歌会将用户查询拆解为多个聚焦的子查询（「查询分发」），并并行发送去探索不同角度。生成的摘要随后经过与索引的 「基础验证」 过程进行核对，以减少错误信息的出现。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尽管 SEO 的技术规则没有改变，但其影响正在减小。根据最近皮尤研究中心的研究，AI 摘要出现在搜索结果中时，普通结果的点击率下降至 8%，而没有 AI 概述时为 15%。用户直接点击概述中的源链接的比例仅为 1%。其他研究也显示了相同的趋势:SEO 的技术细节没有改变，但随着用户越来越依赖 AI 生成的答案，访问外部网站的需求减少，传统网站的曝光度和可见性也在下降。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;对于出版商、零售商和内容创作者而言，这意味着即使你可以影响聊天机器人链接到你的网站，但由于点击率的急剧下降，回报的价值也变得值得怀疑。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362278</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362278</guid>
      <pubDate>Thu, 17 Jul 2025 03:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>蚂蚁新设通用人工智能研究中心</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;雷峰网「AI 科技评论」爆料称，蚂蚁集团近日新设了通用人工智能研究中心，隶属于蚂蚁技术研究院，人员包括蓝振忠、武威、吴翼、赵俊博等一众「明星 AI 新秀」，发力 AGI 基础技术研究。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;今年年初，就有消息称蚂蚁将设立 AGI 研究部门，不过上半年是隶属于蚂蚁集团 CTO 线，由何征宇直接领导。这次的调整则是由 AGI 研究转向研究院，并由蓝振忠担任中心主任，赵俊博、吴翼、武威等人向其汇报。报道称，此举或是旨在更聚焦 AGI 的基础研究并强调技术创新，而非商业潜力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;蓝振忠本科毕业于中山大学，后在卡内基梅隆大学（CMU）取得博士学位，研究方向涵盖计算机视觉与多媒体分析。IT 之家从爆料中获悉，他是谷歌的 Google Lab 前科学家，也是知名轻量化预训练语言模型 ALBERT 的第一作者。ALBERT 是 BERT 之后的重要架构创新，在参数量上实现了惊人的压缩：模型参数仅为 BERT 的 1/18，但在多个任务上的性能却能达到 95% 以上甚至持平。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;2020 年，蓝振忠加入西湖大学，创建「深度学习实验室」并担任博士生导师。他是国内第一批大模型研究科学家，早在 2022 年就率先创立「西湖心辰科技」，是国内最早探索 AIGC、AGI 等技术产业化落地的团队，曾打造日活百万 AIGC 应用「造梦师」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;武威本科与博士均毕业于北京大学数学科学学院。2012 年加入微软亚洲研究院，历任主管研究员、小冰首席科学家。随后担任美团 NLP 中心负责人，在语言模型与应用场景结合方面经验丰富，现为蚂蚁 AGI 中心的重要技术骨干。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;吴翼本硕就读于清华大学，博士阶段在加州大学伯克利分校深造，师从著名 AI 学者 Stuart Russell，专注深度强化学习与多智能体系统研究。吴翼曾在 OpenAI 任职，是为数不多在硅谷核心 AI 实验室做过一线研究的中国学者之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;赵俊博毕业于纽约大学，师从图灵奖得主、Meta 首席科学家 Yann LeCun。曾在 Meta（原 Facebook）人工智能实验室工作，参与 PyTorch 与向量数据库 Faiss 的开发，并主导了 Meta 内部对话机器人相关研究。他目前也是浙江大学「百人计划」研究员。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362273</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362273</guid>
      <pubDate>Thu, 17 Jul 2025 03:17:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>让复杂 AI 应用构建就像搭积木：Spring AI Alibaba Graph 使用指南与源码解读</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;作者：罗天，怀玉，刘宏宇，刘军&lt;/p&gt; 
&lt;h2&gt;目录&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;引言与概述&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心架构与设计理念&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心概念深度解析&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;预定义组件与工具箱&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;高级特性与扩展能力&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;快速开始与实战指南&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;引言与概述&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;1.1 Spring AI Alibaba Graph 概述&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 是社区核心实现之一，也是整个框架在设计理念上区别于 Spring AI 只做底层原子抽象的地方，Spring AI Alibaba 期望帮助开发者更容易的构建智能体应用。基于 Graph 开发者可以构建工作流、多智能体应用。&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 在设计理念上借鉴 LangGraph，社区在此基础上增加了大量预置 Node、简化了 State 定义过程等，让开发者更容易编写对等低代码平台的工作流、多智能体等。&lt;/p&gt; 
&lt;h3&gt;1.2 核心特性与优势&lt;/h3&gt; 
&lt;p&gt;相比传统的 AI 应用开发方式，Spring AI Alibaba Graph 具有以下核心优势：&lt;/p&gt; 
&lt;h4&gt;Java 生态深度集成&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Spring 原生支持&lt;/strong&gt;：完整的依赖注入、配置管理、监控观测。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高并发处理&lt;/strong&gt;：Java 天然的多线程优势，支持高并发场景。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;丰富的预置组件&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;15+ 预定义节点类型&lt;/strong&gt;：QuestionClassifierNode、LlmNode、ToolNode、KnowledgeRetrievalNode 等。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多种 Agent 模式&lt;/strong&gt;：内置 React、Reflection、Supervisor 等智能体模式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;简化的 State 管理&lt;/strong&gt;：统一的状态定义和合并策略。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;声明式 API 设计&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;类似 LangGraph 的 API&lt;/strong&gt;：Java 开发者更容易上手。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;链式调用&lt;/strong&gt;：简洁的流式 API，代码更加优雅。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;条件分支&lt;/strong&gt;：支持复杂的条件逻辑和并行处理。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;生产级特性&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;观测性支持&lt;/strong&gt;：完整的指标收集、链路追踪。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;容错机制&lt;/strong&gt;：支持检查点、状态恢复、错误处。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;人机协作&lt;/strong&gt;：Human-in-the-loop 支持，支持修改状态、恢复执行。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;快速开始：客户评价分类系统&lt;/h2&gt; 
&lt;p&gt;让我们通过一个具体示例了解 Spring AI Alibaba Graph 的使用方式。这个示例展示了如何构建一个客户评价分类系统：&lt;/p&gt; 
&lt;h3&gt;系统架构&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-f4319279c59e197905a18836855bc4b2464.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;核心代码实现&lt;/h3&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class CustomerServiceWorkflow {

    @Bean
    public StateGraph customerServiceGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel)
            .defaultAdvisors(new SimpleLoggerAdvisor())
            .build();

        // 评价分类器 - 区分正面/负面评价
        QuestionClassifierNode feedbackClassifier = QuestionClassifierNode.builder()
            .chatClient(chatClient)
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("positive feedback", "negative feedback"))
            .build();

        // 问题细分器 - 对负面评价进行细分
        QuestionClassifierNode specificQuestionClassifier = QuestionClassifierNode.builder()
            .chatClient(chatClient)
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("after-sale service", "transportation", "product quality", "others"))
            .build();

        // 状态工厂定义 - 简化的状态管理
        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("classifier_output", new ReplaceStrategy());
            strategies.put("solution", new ReplaceStrategy());
            return strategies;
        };

        // 构建工作流 - 声明式 API
        return new StateGraph("客户服务评价处理", stateFactory)
            .addNode("feedback_classifier", node_async(feedbackClassifier))
            .addNode("specific_question_classifier", node_async(specificQuestionClassifier))
            .addNode("recorder", node_async(new RecordingNode()))
            .addEdge(START, "feedback_classifier")
            .addConditionalEdges("feedback_classifier",
                edge_async(new FeedbackQuestionDispatcher()),
                Map.of("positive", "recorder", "negative", "specific_question_classifier"))
            .addEdge("recorder", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;以上代码只展示了图结构（StateGraph）的构建，具体的代码实现你可以关注 &lt;strong&gt;spring-ai-alibaba-example&lt;/strong&gt; 仓库：spring-ai-alibaba-example【1】。&lt;/p&gt; 
&lt;p&gt;这个示例展示了 Spring AI Alibaba Graph 的核心特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;预置组件&lt;/strong&gt;：使用 QuestionClassifierNode 快速实现分类功能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;简化状态管理&lt;/strong&gt;：通过 KeyStrategyFactory 统一管理状态。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;声明式 API&lt;/strong&gt;：链式调用构建复杂工作流。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Spring Boot 集成&lt;/strong&gt; ：通过 &lt;a href="https://my.oschina.net/pointdance"&gt;@Configuration&lt;/a&gt; 和 &lt;a href="https://my.oschina.net/bean"&gt;@Bean&lt;/a&gt; 完成依赖注入。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol start="2"&gt; 
 &lt;li&gt;核心架构与设计理念&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;2.1 整体数据流转架构&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 采用工作流模型，整个框架的数据流转遵循"构建→编译→执行"的三阶段模式：&lt;/p&gt; 
&lt;h4&gt;2.1.1 完整数据流转图&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8044bb577ef789fad03f0b89260211c26c7.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.1.2 核心执行流程详解&lt;/h4&gt; 
&lt;p&gt;数据流转的核心理念：整个框架围绕 OverAllState 这个数据载体进行流转，每个节点都是状态的转换器，通过 AsyncNodeGenerator 这个状态机来驱动整个流程的执行。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-862e32dc74bfcdbbb3d062d0f24239917cc.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.1.3 关键数据结构流转&lt;/h4&gt; 
&lt;p&gt;StateGraph → CompiledGraph 转换：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0671a9be50153ec784ca8f6e11ba0162347.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AsyncNodeGenerator 执行机制：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1c6a5464beb66a4f3eef18a879cf98702ff.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.2 整体架构设计&lt;/h3&gt; 
&lt;p&gt;基于上述数据流转机制，Spring AI Alibaba Graph 的整体架构设计具有以下特点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;清晰的执行流程&lt;/strong&gt;：每个节点代表一个处理步骤，边表示数据流向。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;灵活的条件分支&lt;/strong&gt;：支持根据状态动态选择执行路径。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;并行处理能力&lt;/strong&gt;：多个节点可以并行执行，提高处理效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;状态可追溯&lt;/strong&gt;：完整的状态变化历史，便于调试和监控。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;架构核心理念&lt;/strong&gt;：Spring AI Alibaba Graph 将复杂的 AI 任务分解为可组合的原子操作，每个节点专注於单一职责，通过状态驱动的方式实现节点间的协调。这种设计让开发者可以像搭积木一样构建复杂的 AI 应用，既保证了系统的可维护性，又提供了足够的灵活性。&lt;/p&gt; 
&lt;h4&gt;2.2.1 系统架构总览&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b992e1bb969c3fc0b17dd65eb6554a6aef1.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.2.2 StateGraph 构建流程&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;StateGraph 是工作流的蓝图设计器&lt;/strong&gt;，它负责定义整个工作流的结构和执行逻辑，就像建筑师绘制建筑图纸一样。通过声明式的 API，开发者可以轻松定义节点、边和状态管理策略，最终编译成可执行的 CompiledGraph。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a36870845eb1c5f38fdd00194a2ee6c354c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;关键设计思想&lt;/strong&gt;：StateGraph 采用了"先定义后执行"的模式，将工作流的结构定义与实际执行分离，这样可以在编译时进行各种验证和优化，确保运行时的稳定性和高效性。&lt;/p&gt; 
&lt;h4&gt;2.2.3 CompiledGraph 执行流程&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;CompiledGraph 是工作流的运行时引擎&lt;/strong&gt;，它将 StateGraph 的静态定义转换为可执行的动态流程。就像将建筑图纸变成真正的建筑物一样，CompiledGraph 负责协调各个组件的执行，管理状态流转，确保整个工作流按照预期运行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;AsyncNodeGenerator 是整个图流转执行的唯一状态机&lt;/strong&gt;，它控制着工作流的每一步执行，包括节点调度、状态更新、条件判断和异常处理。这种单一状态机的设计确保了执行的一致性和可预测性。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-93700281d0161f7006ae41c50a561496883.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心执行机制&lt;/strong&gt;：CompiledGraph 采用了基于迭代器模式的异步执行机制，每次调用 next() 方法都会推进工作流的执行，这种设计既支持同步调用，也支持流式处理，为不同的使用场景提供了灵活性。&lt;/p&gt; 
&lt;h3&gt;2.3 核心组件关系图&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;组件职责说明&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;StateGraph&lt;/strong&gt;：工作流的架构师，负责定义整个流程的结构和规则。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;CompiledGraph&lt;/strong&gt;：工作流的指挥官，负责协调和管理整个执行过程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;OverAllState&lt;/strong&gt;：工作流的记忆中心，负责存储和管理所有状态数据。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;：工作流的执行单元，每个节点专注于特定的业务逻辑。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Edge&lt;/strong&gt;：工作流的连接器，定义节点之间的转换关系和条件。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AsyncNodeGenerator&lt;/strong&gt;：工作流的执行引擎，是推动整个流程运转的核心状态机。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1a8ca5f21d61ad2e4cc88459e9bfe38ca01.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;2.4 核心设计理念&lt;/h3&gt; 
&lt;h4&gt;2.4.1 声明式编程模型&lt;/h4&gt; 
&lt;p&gt;借鉴 LangGraph 的设计理念，Spring AI Alibaba Graph 采用声明式编程模型，开发者只需要描述"做什么"：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 声明式定义工作流
StateGraph graph = new StateGraph("客户服务工作流", stateFactory)
    .addNode("feedback_classifier", node_async(feedbackClassifier))
    .addNode("specific_question_classifier", node_async(specificQuestionClassifier))
    .addNode("recorder", node_async(recorderNode))
    .addEdge(START, "feedback_classifier")
    .addConditionalEdges("feedback_classifier", 
        edge_async(new FeedbackQuestionDispatcher()),
        Map.of("positive", "recorder", "negative", "specific_question_classifier"))
    .addEdge("recorder", END);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.4.2 状态驱动的执行模型&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-41abdcbf09f142ffec106f9e638a1e30cf0.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;所有的数据流转都通过 &lt;code&gt;OverAllState &lt;/code&gt;进行管理，确保状态的一致性和可追溯性：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 状态工厂定义
KeyStrategyFactory stateFactory = () -&amp;gt; {
    Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
    strategies.put("input", new ReplaceStrategy());
    strategies.put("classifier_output", new ReplaceStrategy());
    strategies.put("solution", new ReplaceStrategy());
    return strategies;
};
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.4.3 异步优先的设计&lt;/h4&gt; 
&lt;p&gt;框架优先支持异步处理，提高系统的吞吐量和响应性，同时还原生支持了&lt;strong&gt;节点内模型流式透传&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-78603d91cb1abd542ef4076133cadf120a5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 异步节点定义
AsyncNodeAction asyncNode = node_async(new CustomNodeAction());

// 并行节点处理
public class ParallelNode extends Node {
    record AsyncParallelNodeAction(
        List&amp;lt;AsyncNodeActionWithConfig&amp;gt; actions,
        Map&amp;lt;String, KeyStrategy&amp;gt; channels
    ) implements AsyncNodeActionWithConfig {

        @Override
        public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
            var futures = actions.stream()
                .map(action -&amp;gt; action.apply(state, config))
                .toArray(CompletableFuture[]::new);

            return CompletableFuture.allOf(futures)
                .thenApply(v -&amp;gt; {
                    // 合并所有结果
                    Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
                    for (CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; future : futures) {
                        result.putAll(future.join());
                    }
                    return result;
                });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.5 Spring 生态集成&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 与 Spring 生态深度集成，你可以轻松在你的 Spring 应用中引入 AI 模型工作流以开发智能 Java 应用。&lt;/p&gt; 
&lt;h4&gt;2.5.1 依赖注入架构&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8602e6c328daa5d3ce74093335accb575bd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;2.5.2 依赖注入支持&lt;/h4&gt; 
&lt;p&gt;以下代码演示了 Spring AI Alibaba Graph 是如何被 IOC 容器所管理的。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class GraphConfiguration {

    @Bean
    public StateGraph workflowGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel)
            .defaultAdvisors(new SimpleLoggerAdvisor())
            .build();

        // 构建图定义...
        return stateGraph;
    }

    @Bean
    public CompiledGraph compiledGraph(StateGraph stateGraph, 
                                      ObservationRegistry observationRegistry) {
        return stateGraph.compile(CompileConfig.builder()
            .withLifecycleListener(new GraphObservationLifecycleListener(observationRegistry))
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;2.5.3 观测性集成&lt;/h4&gt; 
&lt;p&gt;Spring AI Alibaba Graph 基于 Micrometer 内置了可观测支持，可以无缝集成 Spring Boot 可观测性。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
public class GraphController {

    public GraphController(@Qualifier("workflowGraph") StateGraph stateGraph,
                          ObjectProvider&amp;lt;ObservationRegistry&amp;gt; observationRegistry) {
        this.compiledGraph = stateGraph.compile(CompileConfig.builder()
            .withLifecycleListener(new GraphObservationLifecycleListener(
                observationRegistry.getIfUnique(() -&amp;gt; ObservationRegistry.NOOP)))
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="3"&gt; 
 &lt;li&gt;核心概念深度解析&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;3.1 StateGraph (状态图)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;StateGraph 是整个框架的设计蓝图&lt;/strong&gt;，它就像建筑师的设计图纸一样，定义了工作流的完整结构和执行逻辑。StateGraph 采用声明式 API，让开发者可以用简洁的代码描述复杂的业务流程，而不需要关心底层的执行细节。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心设计理念&lt;/strong&gt;：StateGraph 将复杂的工作流抽象为节点和边的组合，每个节点代表一个具体的操作，边定义了操作之间的流转关系。这种抽象让开发者可以专注于业务逻辑的设计，而不是执行机制的实现。&lt;/p&gt; 
&lt;h4&gt;3.1.1 StateGraph 生命周期&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-26e2710bcff04e78bdd9f100f1b4ed03177.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.1.2 基本构造&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class StateGraph {
    // 核心数据结构
    final Nodes nodes = new Nodes();  // 存储所有节点
    final Edges edges = new Edges();  // 存储所有边

    // 特殊节点常量
    public static final String END = "__END__";
    public static final String START = "__START__";
    public static final String ERROR = "__ERROR__";

    // 状态管理
    private KeyStrategyFactory keyStrategyFactory;
    private PlainTextStateSerializer stateSerializer;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;3.1.3 节点管理流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1b5c60e1ca41dbf2f83e8baca9e68fb7ebd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;支持的节点添加方式：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 添加普通节点
public StateGraph addNode(String id, AsyncNodeAction action) {
    Node node = new Node(id, (config) -&amp;gt; AsyncNodeActionWithConfig.of(action));
    return addNode(id, node);
}

// 添加带配置的节点
public StateGraph addNode(String id, AsyncNodeActionWithConfig actionWithConfig) {
    Node node = new Node(id, (config) -&amp;gt; actionWithConfig);
    return addNode(id, node);
}

// 添加子图节点
public StateGraph addNode(String id, StateGraph subGraph) {
    subGraph.validateGraph(); // 先验证子图
    var node = new SubStateGraphNode(id, subGraph);
    return addNode(id, node);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;3.1.4 边管理流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-3fb278877a662cf572a677630d2eb39898c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.1.5 图验证机制&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c090a594bcea54323db6c34775029fe7f89.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.2 OverAllState (全局状态)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;OverAllState 是工作流的数据中枢&lt;/strong&gt;，它就像工作流的记忆系统一样，负责在各个节点之间传递和管理状态数据。OverAllState 不仅存储数据，还定义了数据的合并策略，确保不同节点产生的数据能够正确地整合在一起。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;设计巧思&lt;/strong&gt;：OverAllState 采用了策略模式来处理状态更新，不同的数据类型可以采用不同的合并策略（如替换、追加、合并等），这种设计让状态管理变得非常灵活，能够适应各种复杂的业务场景。&lt;/p&gt; 
&lt;h4&gt;3.2.1 状态管理架构&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9fd248301844eb71ba85b5c3c2caaa26df2.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.2.2 状态更新流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9ee4261e5ddb0bb06bb3ba404168df290ac.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.2.3 状态策略详解&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;策略模式架构&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8f44cfca5c89147a8710ea303bb8ebd6ad2.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;内置策略实现&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 替换策略 - 新值覆盖旧值
public class ReplaceStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        return newValue;
    }
}

// 追加策略 - 新值追加到列表，支持复杂的列表操作
public class AppendStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (newValue == null) {
            return oldValue;
        }

        // 处理 Optional 类型
        if (oldValue instanceof Optional&amp;lt;?&amp;gt; oldValueOptional) {
            oldValue = oldValueOptional.orElse(null);
        }

        boolean oldValueIsList = oldValue instanceof List&amp;lt;?&amp;gt;;

        // 处理移除操作
        if (oldValueIsList &amp;amp;&amp;amp; newValue instanceof AppenderChannel.RemoveIdentifier&amp;lt;?&amp;gt;) {
            var result = new ArrayList&amp;lt;&amp;gt;((List&amp;lt;Object&amp;gt;) oldValue);
            removeFromList(result, (AppenderChannel.RemoveIdentifier) newValue);
            return unmodifiableList(result);
        }

        // 处理新值为集合的情况
        List&amp;lt;Object&amp;gt; list = null;
        if (newValue instanceof List) {
            list = new ArrayList&amp;lt;&amp;gt;((List&amp;lt;?&amp;gt;) newValue);
        } else if (newValue.getClass().isArray()) {
            list = Arrays.asList((Object[]) newValue);
        } else if (newValue instanceof Collection) {
            list = new ArrayList&amp;lt;&amp;gt;((Collection&amp;lt;?&amp;gt;) newValue);
        }

        // 合并逻辑
        if (oldValueIsList) {
            List&amp;lt;Object&amp;gt; oldList = (List&amp;lt;Object&amp;gt;) oldValue;
            if (list != null) {
                if (list.isEmpty()) {
                    return oldValue;
                }
                // 合并并去重
                var result = evaluateRemoval(oldList, list);
                return Stream.concat(result.oldValues().stream(), result.newValues().stream())
                    .distinct()
                    .collect(Collectors.toList());
            } else {
                oldList.add(newValue);
            }
            return oldList;
        } else {
            ArrayList&amp;lt;Object&amp;gt; arrayResult = new ArrayList&amp;lt;&amp;gt;();
            if (list != null) {
                arrayResult.addAll(list);
            } else {
                arrayResult.add(newValue);
            }
            return arrayResult;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;自定义策略示例&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 自定义 Map 合并策略
public class MapMergeStrategy implements KeyStrategy {
    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (oldValue instanceof Map &amp;amp;&amp;amp; newValue instanceof Map) {
            Map&amp;lt;String, Object&amp;gt; merged = new HashMap&amp;lt;&amp;gt;((Map) oldValue);
            merged.putAll((Map) newValue);
            return merged;
        }
        return newValue; // 默认替换
    }
}

// 自定义字符串连接策略
public class StringConcatStrategy implements KeyStrategy {
    private final String separator;

    public StringConcatStrategy(String separator) {
        this.separator = separator;
    }

    @Override
    public Object apply(Object oldValue, Object newValue) {
        if (oldValue instanceof String &amp;amp;&amp;amp; newValue instanceof String) {
            return oldValue + separator + newValue;
        }
        return newValue;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;策略工厂模式&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class StrategyFactory {

    public static KeyStrategyFactory createDefaultFactory() {
        return () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("messages", new AppendStrategy());
            strategies.put("input", new ReplaceStrategy());
            strategies.put("output", new ReplaceStrategy());
            return strategies;
        };
    }

    public static KeyStrategyFactory createCustomFactory(Map&amp;lt;String, KeyStrategy&amp;gt; customStrategies) {
        return () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            // 添加默认策略
            strategies.put("messages", new AppendStrategy());
            strategies.put("input", new ReplaceStrategy());
            // 覆盖自定义策略
            strategies.putAll(customStrategies);
            return strategies;
        };
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3.3 Node (节点)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Node 是工作流的功能模块&lt;/strong&gt;，每个节点就像一个专门的工作站，负责执行特定的业务逻辑。Node 的设计遵循单一职责原则，每个节点只关注一件事情，这样既保证了代码的可维护性，也提高了节点的可复用性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;执行特性&lt;/strong&gt;：Node 支持同步和异步两种执行模式，还支持并行执行多个子任务。这种灵活的执行机制让 Node 既能处理简单的数据转换，也能处理复杂的外部服务调用，满足各种性能要求。&lt;/p&gt; 
&lt;h4&gt;3.3.1 节点执行流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0f32a073a0c333563e611cab19f961d7f95.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.3.2 节点类型层次结构&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a485bb79a834cbc7d6f6db17a52684b0ef4.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.3.3 并行节点处理机制&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6fd1b90acfbdc8be027db48ec175b56e697.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.4 Edge (边)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Edge 是工作流的路由器&lt;/strong&gt;，它决定了数据在节点之间的流转路径。Edge 不仅仅是简单的连接线，它还包含了复杂的条件判断逻辑，能够根据当前状态动态决定下一步的执行路径。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能路由&lt;/strong&gt;：Edge 支持静态路由和动态路由两种模式。静态边提供固定的转换路径，而条件边则可以根据状态内容进行智能判断，这种设计让工作流具备了强大的条件分支能力，能够处理各种复杂的业务逻辑。&lt;/p&gt; 
&lt;h4&gt;3.4.1 边的类型与结构&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-37f3702ab9000b7fbb0acb82335d5041701.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.4.2 条件边路由流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0a87569b8fe010a8fdd21fd5b64b0409064.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.4.3 边验证机制&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class Edge {
    public void validate(Nodes nodes) throws GraphStateException {
        // 验证源节点存在
        if (!nodes.anyMatchById(sourceId)) {
            throw Errors.missingNodeInEdgeMapping.exception(sourceId);
        }

        // 验证目标节点
        for (EdgeValue target : targets()) {
            if (target.id() != null) {
                // 静态边：直接验证目标节点
                if (!nodes.anyMatchById(target.id()) &amp;amp;&amp;amp; !END.equals(target.id())) {
                    throw Errors.missingNodeInEdgeMapping.exception(target.id());
                }
            } else if (target.value() != null) {
                // 条件边：验证映射中的所有目标节点
                for (String targetNodeId : target.value().mappings().values()) {
                    if (!nodes.anyMatchById(targetNodeId) &amp;amp;&amp;amp; !END.equals(targetNodeId)) {
                        throw Errors.missingNodeInEdgeMapping.exception(targetNodeId);
                    }
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3.5 CompiledGraph (编译图)&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;CompiledGraph 是工作流的执行引擎&lt;/strong&gt;，它将 StateGraph 的静态定义转换为高效的运行时代码。就像将高级语言编译成机器码一样，CompiledGraph 对工作流进行了各种优化，包括节点预处理、边路由优化、状态管理策略等。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;运行时优化&lt;/strong&gt;：CompiledGraph 在编译过程中会进行多种优化，如节点依赖分析、并行执行规划、状态访问优化等，这些优化确保了工作流在运行时的高效性和稳定性。&lt;/p&gt; 
&lt;h4&gt;3.5.1 编译过程详解&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8f37fa869476a45f5d807052d17e6dd1b3d.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.5.2 AsyncNodeGenerator 执行机制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;AsyncNodeGenerator 是工作流执行的核心状态机&lt;/strong&gt;，它负责推动整个工作流的运行。AsyncNodeGenerator 采用了基于迭代器的设计模式，每次调用 next() 方法都会执行一个步骤，这种设计既支持同步执行，也支持异步流式处理。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;执行控制&lt;/strong&gt;：AsyncNodeGenerator 内置了完善的执行控制机制，包括最大迭代次数检查、中断条件处理、错误恢复等，确保工作流在各种情况下都能稳定运行。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-57b304d6487ce5a1d9e7531319e3916f1cd.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;3.5.3 状态流转核心逻辑&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncNodeGenerator&amp;lt;Output extends NodeOutput&amp;gt; implements AsyncGenerator&amp;lt;Output&amp;gt; {

    @Override
    public Data&amp;lt;Output&amp;gt; next() {
        try {
            // 1. 检查最大迭代次数
            if (++iteration &amp;gt; maxIterations) {
                return Data.error(new IllegalStateException(
                    format("Maximum number of iterations (%d) reached!", maxIterations)));
            }

            // 2. 检查是否结束
            if (nextNodeId == null &amp;amp;&amp;amp; currentNodeId == null) {
                return releaseThread().map(Data::&amp;lt;Output&amp;gt;done)
                    .orElseGet(() -&amp;gt; Data.done(currentState));
            }

            // 3. 处理 START 节点
            if (START.equals(currentNodeId)) {
                doListeners(START, null);
                var nextNodeCommand = getEntryPoint(currentState, config);
                nextNodeId = nextNodeCommand.gotoNode();
                currentState = nextNodeCommand.update();

                var cp = addCheckpoint(config, START, currentState, nextNodeId);
                var output = (cp.isPresent() &amp;amp;&amp;amp; config.streamMode() == StreamMode.SNAPSHOTS)
                    ? buildStateSnapshot(cp.get()) : buildNodeOutput(currentNodeId);

                currentNodeId = nextNodeId;
                return Data.of(output);
            }

            // 4. 处理 END 节点
            if (END.equals(nextNodeId)) {
                nextNodeId = null;
                currentNodeId = null;
                doListeners(END, null);
                return Data.of(buildNodeOutput(END));
            }

            // 5. 检查中断条件
            if (shouldInterruptAfter(currentNodeId, nextNodeId)) {
                return Data.done(currentNodeId);
            }
            if (shouldInterruptBefore(nextNodeId, currentNodeId)) {
                return Data.done(currentNodeId);
            }

            // 6. 执行节点
            currentNodeId = nextNodeId;
            var action = nodes.get(currentNodeId);
            return Data.of(evaluateAction(action, overAllState));

        } catch (Exception e) {
            return Data.error(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;预定义组件与工具箱&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;4.1 预定义节点类型&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;Spring AI Alibaba Graph 提供了丰富的预定义节点工具箱&lt;/strong&gt;，这些节点就像乐高积木一样，开发者可以通过组合这些预定义节点快速构建复杂的 AI 应用。每个预定义节点都经过了精心设计和优化，不仅功能强大，而且易于使用。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;设计理念&lt;/strong&gt;：预定义节点的设计遵循了"开箱即用"的原则，开发者只需要提供必要的配置参数，就能立即使用这些节点的强大功能，大大降低了 AI 应用的开发门槛。&lt;/p&gt; 
&lt;h4&gt;4.1.1 节点分类架构&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c36ae118bcf46fbe9a86dc3e82c8e4dd136.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;4.1.2 QuestionClassifierNode - 智能分类节点&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;QuestionClassifierNode 是工作流的智能分拣员&lt;/strong&gt;，它能够理解文本内容并将其归类到预定义的类别中。这个节点内置了少样本学习机制，即使没有大量训练数据，也能实现准确的分类效果。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心优势&lt;/strong&gt;：QuestionClassifierNode 采用了提示工程的最佳实践，通过精心设计的提示词模板和少样本示例，让大语言模型能够准确理解分类任务的要求，实现高质量的文本分类。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-cb2c43e28f75f6c4b0848eb194aeabff20a.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：QuestionClassifierNode 特别适合客服系统的问题分类、内容审核的类型判断、邮件的自动分拣等场景，能够显著提高业务处理的自动化程度。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;QuestionClassifierNode classifier = QuestionClassifierNode.builder()
    .chatClient(chatClient)
    .inputTextKey("input")
    .outputKey("classifier_output")
    .categories(List.of("positive feedback", "negative feedback"))
    .classificationInstructions(List.of(
        "Try to understand the user's feeling when giving feedback."
    ))
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;核心实现原理：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Override
public Map&amp;lt;String, Object&amp;gt; apply(OverAllState state) throws Exception {
    // 1. 从状态获取输入文本
    if (StringUtils.hasLength(inputTextKey)) {
        this.inputText = (String) state.value(inputTextKey).orElse(this.inputText);
    }

    // 2. 构建少样本学习消息
    List&amp;lt;Message&amp;gt; messages = new ArrayList&amp;lt;&amp;gt;();
    messages.add(new UserMessage(QUESTION_CLASSIFIER_USER_PROMPT_1));
    messages.add(new AssistantMessage(QUESTION_CLASSIFIER_ASSISTANT_PROMPT_1));
    messages.add(new UserMessage(QUESTION_CLASSIFIER_USER_PROMPT_2));
    messages.add(new AssistantMessage(QUESTION_CLASSIFIER_ASSISTANT_PROMPT_2));

    // 3. 调用大模型进行分类
    ChatResponse response = chatClient.prompt()
        .system(systemPromptTemplate.render(Map.of(
            "inputText", inputText, 
            "categories", categories,
            "classificationInstructions", classificationInstructions)))
        .user(inputText)
        .messages(messages)
        .call()
        .chatResponse();

    // 4. 返回分类结果
    Map&amp;lt;String, Object&amp;gt; updatedState = new HashMap&amp;lt;&amp;gt;();
    updatedState.put(outputKey, response.getResult().getOutput().getText());
    return updatedState;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.1.3 LlmNode - 大模型调用节点&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;LlmNode 是工作流的智能大脑&lt;/strong&gt;，它封装了与大语言模型的所有交互逻辑，让开发者可以轻松地在工作流中使用 AI 的强大能力。LlmNode 不仅支持简单的文本生成，还支持复杂的对话管理和流式输出。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能特性&lt;/strong&gt;：LlmNode 内置了提示词模板引擎，支持动态参数替换，还能管理完整的对话历史，这些特性让它能够处理各种复杂的 AI 交互场景。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-13aa9a44b060d42bf0c7f49fb158a29fe41.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;流式处理优势&lt;/strong&gt;：LlmNode 原生支持流式输出，这意味着用户可以实时看到 AI 的生成过程，而不需要等待完整的响应，大大提升了用户体验。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;LlmNode llmNode = LlmNode.builder()
    .chatClient(chatClient)
    .systemPromptTemplate("You are a helpful assistant.")
    .userPromptTemplate("Please process: {input}")
    .messagesKey("messages")
    .outputKey("llm_response")
    .stream(true)  // 启用流式输出
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;核心特性&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;模板支持&lt;/strong&gt;：支持系统提示词和用户提示词模板。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;消息历史&lt;/strong&gt;：支持消息历史管理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;流式输出&lt;/strong&gt;：原生支持流式处理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;参数渲染&lt;/strong&gt;：支持动态参数替换。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;4.1.4 ToolNode - 工具调用节点&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ToolNode 是工作流的万能工具箱&lt;/strong&gt;，它让 AI 能够调用外部工具和 API，极大地扩展了 AI 的能力边界。ToolNode 不仅能执行单个工具调用，还能并行执行多个工具，显著提高了处理效率。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心价值&lt;/strong&gt;：ToolNode 将 AI 从纯文本生成扩展到了实际的行动能力，让 AI 能够查询数据库、调用 API、执行计算等，真正实现了 AI Agent 的概念。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1839ec7060e57c080ada3efe2ae17df7634.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;灵活性设计&lt;/strong&gt;：ToolNode 支持各种类型的工具调用，从简单的函数调用到复杂的 API 集成，都能轻松处理，这种灵活性让 AI 应用能够适应各种业务场景。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ToolNode toolNode = ToolNode.builder()
    .toolCallbacks(toolCallbacks)
    .llmResponseKey("llm_response")
    .outputKey("tool_response")
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;执行机制：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Override
public Map&amp;lt;String, Object&amp;gt; apply(OverAllState state) throws Exception {
    // 1. 获取助手消息（包含工具调用）
    this.assistantMessage = (AssistantMessage) state.value(this.llmResponseKey)
        .orElseGet(() -&amp;gt; {
            List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElseThrow();
            return messages.get(messages.size() - 1);
        });

    // 2. 执行工具调用
    ToolResponseMessage toolResponseMessage = executeFunction(assistantMessage, state);

    // 3. 返回工具响应
    Map&amp;lt;String, Object&amp;gt; updatedState = new HashMap&amp;lt;&amp;gt;();
    updatedState.put("messages", toolResponseMessage);
    if (StringUtils.hasLength(this.outputKey)) {
        updatedState.put(this.outputKey, toolResponseMessage);
    }
    return updatedState;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.1.5 KnowledgeRetrievalNode - 知识检索节点&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;KnowledgeRetrievalNode 是工作流的知识专家&lt;/strong&gt;，它能够从庞大的知识库中快速找到与问题相关的信息，为 AI 提供准确的背景知识。这个节点结合了向量检索和重排序技术，确保检索结果的准确性和相关性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;技术优势&lt;/strong&gt;：KnowledgeRetrievalNode 采用了先进的 RAG（检索增强生成）技术，通过向量相似度计算找到相关文档，再通过重排序模型进一步优化结果质量，这种两阶段的设计确保了检索的精准性。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-52f61bd24f4b307bb15eb00c5cbab458b1b.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;应用价值&lt;/strong&gt;：KnowledgeRetrievalNode 让 AI 能够基于企业的私有知识库回答问题，这对于构建企业级 AI 助手、智能客服等应用具有重要意义。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;KnowledgeRetrievalNode retrievalNode = KnowledgeRetrievalNode.builder()
    .vectorStore(vectorStore)
    .userPromptKey("query")
    .topK(5)
    .similarityThreshold(0.7)
    .enableRanker(true)
    .rerankModel(rerankModel)
    .outputKey("retrieved_docs")
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;4.2 预定义 Agent 类型&lt;/h3&gt; 
&lt;h4&gt;4.2.1 ReactAgent - 反应式 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReactAgent 是工作流的智能决策者&lt;/strong&gt;，它实现了经典的 ReAct（Reasoning and Acting）模式，能够根据当前情况动态决定是否需要调用工具。ReactAgent 就像一个有经验的助手，知道什么时候需要查找信息，什么时候可以直接回答。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;：ReactAgent 将推理和行动结合在一起，让 AI 不仅能思考，还能行动。这种设计让 AI 具备了解决复杂问题的能力，能够通过多轮推理和工具调用来完成复杂任务。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-5d013d61cb33f9a717b97fd8f4455c4a025.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;智能循环&lt;/strong&gt;：ReactAgent 的执行过程是一个智能循环，每次循环都会评估当前状态，决定下一步行动，这种设计让 AI 能够处理各种复杂和动态的任务场景。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ReactAgent reactAgent = new ReactAgent(
    "weatherAgent",
    chatClient,
    toolCallbacks,
    10  // 最大迭代次数
);

// 编译并使用
CompiledGraph compiledGraph = reactAgent.getAndCompileGraph();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;内部图结构构建&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private StateGraph initGraph() throws GraphStateException {
    StateGraph graph = new StateGraph(name, this.keyStrategyFactory);

    // 添加核心节点
    graph.addNode("llm", node_async(this.llmNode));
    graph.addNode("tool", node_async(this.toolNode));

    // 构建执行流程
    graph.addEdge(START, "llm")
         .addConditionalEdges("llm", edge_async(this::think),
             Map.of("continue", "tool", "end", END))
         .addEdge("tool", "llm");

    return graph;
}

// 决策逻辑
private String think(OverAllState state) {
    if (iterations &amp;gt; max_iterations) {
        return "end";
    }

    List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElseThrow();
    AssistantMessage message = (AssistantMessage) messages.get(messages.size() - 1);

    // 检查是否有工具调用
    return message.hasToolCalls() ? "continue" : "end";
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.2.2 ReflectAgent - 反思 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReflectAgent 是工作流的质量监督者&lt;/strong&gt;，它实现了反思模式，能够对自己的输出进行评估和改进。ReflectAgent 就像一个严格的编辑，会反复检查和修改内容，直到达到满意的质量标准。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;自我改进机制&lt;/strong&gt;：ReflectAgent 采用了双节点协作的设计，一个节点负责生成内容，另一个节点负责评估质量，通过多轮迭代不断提升输出质量。这种设计让 AI 具备了自我完善的能力。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-dac4641f7e3e156e5cb802a28d0ac2db271.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;质量保证&lt;/strong&gt;：ReflectAgent 特别适合对输出质量要求较高的场景，如文档写作、代码生成、创意内容等，通过反思机制确保最终输出的质量。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ReflectAgent reflectAgent = ReflectAgent.builder()
    .graph(assistantGraphNode)      // 生成节点
    .reflection(judgeGraphNode)     // 评判节点
    .maxIterations(3)
    .build();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;执行流程详解：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public StateGraph createReflectionGraph(NodeAction graph, NodeAction reflection, int maxIterations) {
    StateGraph stateGraph = new StateGraph(() -&amp;gt; {
        HashMap&amp;lt;String, KeyStrategy&amp;gt; keyStrategyHashMap = new HashMap&amp;lt;&amp;gt;();
        keyStrategyHashMap.put(MESSAGES, new ReplaceStrategy());
        keyStrategyHashMap.put(ITERATION_NUM, new ReplaceStrategy());
        return keyStrategyHashMap;
    })
    .addNode(GRAPH_NODE_ID, node_async(graph))
    .addNode(REFLECTION_NODE_ID, node_async(reflection))
    .addEdge(START, GRAPH_NODE_ID)
    .addConditionalEdges(GRAPH_NODE_ID, edge_async(this::graphCount),
        Map.of(REFLECTION_NODE_ID, REFLECTION_NODE_ID, END, END))
    .addConditionalEdges(REFLECTION_NODE_ID, edge_async(this::apply),
        Map.of(GRAPH_NODE_ID, GRAPH_NODE_ID, END, END));

    return stateGraph;
}

// 迭代次数检查
private String graphCount(OverAllState state) {
    int iterationNum = state.value(ITERATION_NUM, Integer.class).orElse(0);
    state.updateState(Map.of(ITERATION_NUM, iterationNum + 1));

    return iterationNum &amp;gt;= maxIterations ? END : REFLECTION_NODE_ID;
}

// 消息类型检查
private String apply(OverAllState state) {
    List&amp;lt;Message&amp;gt; messages = state.value(MESSAGES, List.class).orElse(new ArrayList&amp;lt;&amp;gt;());
    if (messages.isEmpty()) return END;

    Message lastMessage = messages.get(messages.size() - 1);
    return lastMessage instanceof UserMessage ? GRAPH_NODE_ID : END;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;4.2.3 ReactAgentWithHuman - 人机协作 Agent&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ReactAgentWithHuman 是工作流的人机协作专家&lt;/strong&gt;，它在 ReactAgent 的基础上增加了人工干预能力，让 AI 和人类能够协作完成复杂任务。这种设计特别适合需要人工审核、决策确认或专业判断的场景。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;协作机制&lt;/strong&gt;：ReactAgentWithHuman 内置了完善的中断和恢复机制，当遇到需要人工干预的情况时，系统会自动暂停执行，等待人工处理，然后无缝恢复执行。这种设计让人机协作变得自然而流畅。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b1377a00599660d4661b88f5b2ba11abceb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;人机协作实现：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private StateGraph initGraph() throws GraphStateException {
    StateGraph graph = new StateGraph(name, keyStrategyFactory)
        .addNode("agent", node_async(this.llmNode))
        .addNode("human", node_async(this.humanNode))
        .addNode("tool", node_async(this.toolNode))
        .addEdge(START, "agent")
        .addEdge("agent", "human")
        .addConditionalEdges("human", edge_async(humanNode::think),
            Map.of("agent", "agent", "tool", "tool", "end", END))
        .addEdge("tool", "agent");

    return graph;
}

// HumanNode 的决策逻辑
public String think(OverAllState state) {
    // 检查是否需要中断
    if (shouldInterruptFunc != null &amp;amp;&amp;amp; shouldInterruptFunc.apply(state)) {
        // 设置中断消息，等待人工处理
        state.setInterruptMessage("等待人工审批");
        return "human_interrupt";
    }

    // 检查是否需要工具调用
    List&amp;lt;Message&amp;gt; messages = (List&amp;lt;Message&amp;gt;) state.value("messages").orElse(new ArrayList&amp;lt;&amp;gt;());
    if (!messages.isEmpty()) {
        Message lastMessage = messages.get(messages.size() - 1);
        if (lastMessage instanceof AssistantMessage &amp;amp;&amp;amp; 
            ((AssistantMessage) lastMessage).hasToolCalls()) {
            return "tool";
        }
    }

    return "agent";
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="5"&gt; 
 &lt;li&gt;高级特性与扩展能力&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;5.1 可观测性&lt;/h3&gt; 
&lt;p&gt;Spring AI Alibaba Graph 提供了企业级的全链路观测能力，基于 OpenTelemetry 和 Micrometer 标准，实现了从 Graph 执行到模型调用的完整追踪。&lt;/p&gt; 
&lt;h4&gt;5.1.1 核心特性&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;全链路可观测&lt;/strong&gt;：实时追踪每个节点的输入、输出和状态变化。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;流式数据采集&lt;/strong&gt;：支持异步、并行、流式节点的观测。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;异常溯源&lt;/strong&gt;：快速定位异常节点和数据。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多平台支持&lt;/strong&gt;：兼容 Langfuse、Jaeger、Zipkin、Prometheus 等主流平台。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;5.1.2 快速接入&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;使用观测性 Starter&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-ai-alibaba-starter-graph-observation&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

@Bean
public CompiledGraph compiledGraph(StateGraph observabilityGraph, 
                                  CompileConfig observationCompileConfig) throws GraphStateException {
    return observabilityGraph.compile(observationCompileConfig);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.1.3 详细文档&lt;/h4&gt; 
&lt;p&gt;关于 Spring AI Alibaba Graph 观测性的完整架构设计、实现原理、配置方式、最佳实践等详细内容，请参考官方观测性文档：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;📚&lt;/strong&gt; &lt;strong&gt;Graph 观测性完整指南&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 观测性设计与实现【2】&lt;/p&gt; 
&lt;p&gt;该文档涵盖：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;观测性设计理念与架构&lt;/li&gt; 
 &lt;li&gt;并行与流式观测实现&lt;/li&gt; 
 &lt;li&gt;多平台集成配置&lt;/li&gt; 
 &lt;li&gt;Langfuse 等可视化平台使用&lt;/li&gt; 
 &lt;li&gt;最佳实践与扩展建议&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;🔗完整示例代码&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;graph-observability-langfuse【3】&lt;/p&gt; 
&lt;h3&gt;5.2 并行节点与流式处理&lt;/h3&gt; 
&lt;h4&gt;5.2.1 并行节点的两种创建方式&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;Spring AI Alibaba Graph 提供了两种创建并行节点的方式&lt;/strong&gt;，这两种方式在底层实现上有所不同，但都能实现并行处理的效果。&lt;/p&gt; 
&lt;h5&gt;方式一：直接创建 ParallelNode&lt;/h5&gt; 
&lt;p&gt;直接创建一个 ParallelNode 实例，并将其注册到 StateGraph 中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 创建并行任务列表
List&amp;lt;AsyncNodeActionWithConfig&amp;gt; parallelActions = List.of(
    node_async(new DataProcessingNode1()),
    node_async(new DataProcessingNode2()),
    node_async(new DataProcessingNode3())
);

// 定义状态合并策略
Map&amp;lt;String, KeyStrategy&amp;gt; channels = Map.of(
    "results", new AppendStrategy(),
    "metadata", new ReplaceStrategy()
);

// 创建并行节点
ParallelNode parallelNode = new ParallelNode(
    "data_processing",           // 节点内部 ID  
    parallelActions,            // 并行任务列表
    channels                    // KeyStrategy 映射
);

// 添加到 StateGraph
stateGraph.addNode("parallel_tasks", parallelNode);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;方式二：通过 StateGraph 描述并行边&lt;/h5&gt; 
&lt;p&gt;&lt;strong&gt;这是更常用的方式&lt;/strong&gt;，通过添加多个指向相同目标的边来定义并行结构：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;StateGraph workflow = new StateGraph(keyStrategyFactory)
    .addNode("source", node_async(sourceNode))
    .addNode("task1", node_async(task1Node))
    .addNode("task2", node_async(task2Node))
    .addNode("task3", node_async(task3Node))
    .addNode("merger", node_async(mergerNode))

    // 创建并行分支 - 从 source 到多个任务
    .addEdge("source", "task1")
    .addEdge("source", "task2")
    .addEdge("source", "task3")

    // 汇聚到 merger 节点
    .addEdge("task1", "merger")
    .addEdge("task2", "merger")
    .addEdge("task3", "merger")

    .addEdge(START, "source")
    .addEdge("merger", END);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;编译时转换机制&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;当 StateGraph 编译时，框架会自动检测并行边模式，并在内部创建 ParallelNode：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// CompiledGraph 编译过程中的处理逻辑
if (targets.size() &amp;gt; 1) {
    // 检测到并行边，获取所有并行目标节点的 Action
    var actions = parallelNodeStream.get()
        .map(target -&amp;gt; nodes.get(target.id()))
        .toList();

    // 自动创建 ParallelNode
    var parallelNode = new ParallelNode(e.sourceId(), actions, keyStrategyMap);

    // 替换原有节点和边的映射
    nodes.put(parallelNode.id(), parallelNode.actionFactory().apply(compileConfig));
    edges.put(e.sourceId(), new EdgeValue(parallelNode.id()));
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.2.2 并行节点的内部执行机制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;ParallelNode 的核心实现&lt;/strong&gt;基于 CompletableFuture.allOf()，实现真正的并行执行：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class ParallelNode extends Node {

    record AsyncParallelNodeAction(
        List&amp;lt;AsyncNodeActionWithConfig&amp;gt; actions,
        Map&amp;lt;String, KeyStrategy&amp;gt; channels
    ) implements AsyncNodeActionWithConfig {

        @Override
        public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
            Map&amp;lt;String, Object&amp;gt; partialMergedStates = new HashMap&amp;lt;&amp;gt;();
            Map&amp;lt;String, Object&amp;gt; asyncGenerators = new HashMap&amp;lt;&amp;gt;();

            // 并行执行所有 Action
            var futures = actions.stream()
                .map(action -&amp;gt; action.apply(state, config)
                    .thenApply(partialState -&amp;gt; {
                        // 分离普通结果和 AsyncGenerator
                        partialState.forEach((key, value) -&amp;gt; {
                            if (value instanceof AsyncGenerator&amp;lt;?&amp;gt; || value instanceof GeneratorSubscriber) {
                                ((List) asyncGenerators.computeIfAbsent(key, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;())).add(value);
                            } else {
                                partialMergedStates.put(key, value);
                            }
                        });
                        // 立即更新状态
                        state.updateState(partialMergedStates);
                        return action;
                    }))
                .toList()
                .toArray(new CompletableFuture[0]);

            // 等待所有任务完成
            return CompletableFuture.allOf(futures)
                .thenApply((p) -&amp;gt; CollectionUtils.isEmpty(asyncGenerators) 
                    ? state.data() 
                    : asyncGenerators);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.2.3 并行流式处理的合并机制&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;核心挑战&lt;/strong&gt;：当多个并行分支都产生流式输出时，如何将这些异步流合并成统一的输出流？&lt;/p&gt; 
&lt;p&gt;Spring AI Alibaba Graph 通过 &lt;code&gt;AsyncGeneratorUtils.createMergedGenerator &lt;/code&gt;在&lt;strong&gt;框架内核中&lt;/strong&gt;解决了这个复杂问题：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-819552cef2022851091a8cde1f4c15e25af.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.2.4 MergedGenerator 核心实现&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;AsyncGeneratorUtils.createMergedGenerator&lt;/strong&gt; 是框架内核的核心算法，实现了多个异步流的智能合并：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; AsyncGenerator&amp;lt;T&amp;gt; createMergedGenerator(
    List&amp;lt;AsyncGenerator&amp;lt;T&amp;gt;&amp;gt; generators,
    Map&amp;lt;String, KeyStrategy&amp;gt; keyStrategyMap) {

    return new AsyncGenerator&amp;lt;&amp;gt;() {
        // 使用 StampedLock 优化并发性能
        private final StampedLock lock = new StampedLock();
        private AtomicInteger pollCounter = new AtomicInteger(0);
        private Map&amp;lt;String, Object&amp;gt; mergedResult = new HashMap&amp;lt;&amp;gt;();
        private final List&amp;lt;AsyncGenerator&amp;lt;T&amp;gt;&amp;gt; activeGenerators = new CopyOnWriteArrayList&amp;lt;&amp;gt;(generators);

        @Override
        public AsyncGenerator.Data&amp;lt;T&amp;gt; next() {
            while (true) {
                // 乐观读锁快速检查
                long stamp = lock.tryOptimisticRead();
                boolean empty = activeGenerators.isEmpty();
                if (!lock.validate(stamp)) {
                    stamp = lock.readLock();
                    try {
                        empty = activeGenerators.isEmpty();
                    } finally {
                        lock.unlockRead(stamp);
                    }
                }
                if (empty) {
                    return AsyncGenerator.Data.done(mergedResult);
                }

                // 轮询策略选择 Generator
                final AsyncGenerator&amp;lt;T&amp;gt; current;
                long writeStamp = lock.writeLock();
                try {
                    final int size = activeGenerators.size();
                    if (size == 0) return AsyncGenerator.Data.done(mergedResult);

                    int currentIdx = pollCounter.updateAndGet(i -&amp;gt; (i + 1) % size);
                    current = activeGenerators.get(currentIdx);
                } finally {
                    lock.unlockWrite(writeStamp);
                }

                // 在无锁状态下执行 Generator
                AsyncGenerator.Data&amp;lt;T&amp;gt; data = current.next();

                // 处理结果并更新状态
                writeStamp = lock.writeLock();
                try {
                    if (!activeGenerators.contains(current)) {
                        continue;
                    }

                    if (data.isDone() || data.isError()) {
                        handleCompletedGenerator(current, data);
                        if (activeGenerators.isEmpty()) {
                            return AsyncGenerator.Data.done(mergedResult);
                        }
                        continue;
                    }

                    handleCompletedGenerator(current, data);
                    return data;
                } finally {
                    lock.unlockWrite(writeStamp);
                }
            }
        }

        private void handleCompletedGenerator(AsyncGenerator&amp;lt;T&amp;gt; generator, AsyncGenerator.Data&amp;lt;T&amp;gt; data) {
            // 移除完成的 Generator
            if (data.isDone() || data.isError()) {
                activeGenerators.remove(generator);
            }

            // 使用 KeyStrategy 合并结果
            data.resultValue().ifPresent(result -&amp;gt; {
                if (result instanceof Map) {
                    Map&amp;lt;String, Object&amp;gt; mapResult = (Map&amp;lt;String, Object&amp;gt;) result;
                    mergedResult = OverAllState.updateState(mergedResult, mapResult, keyStrategyMap);
                }
            });
        }
    };
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;核心算法特点&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;轮询机制&lt;/strong&gt;：通过 pollCounter 实现公平的轮询调度。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;StampedLock 优化&lt;/strong&gt;：使用乐观读锁提高并发性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;状态合并&lt;/strong&gt;：通过 KeyStrategy 实现灵活的状态合并策略。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;线程安全&lt;/strong&gt;：CopyOnWriteArrayList 确保并发访问的安全性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;5.2.5 流式输出配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
@RequestMapping("/stream")
public class StreamingController {

    private final CompiledGraph compiledGraph;

    @GetMapping(value = "/process", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&amp;lt;ServerSentEvent&amp;lt;String&amp;gt;&amp;gt; processStream(@RequestParam String input) {
        return Flux.create(sink -&amp;gt; {
            try {
                AsyncGenerator&amp;lt;NodeOutput&amp;gt; generator = compiledGraph.stream(
                    Map.of("input", input),
                    RunnableConfig.builder()
                        .threadId(UUID.randomUUID().toString())
                        .build()
                );

                generator.forEachAsync(output -&amp;gt; {
                    if (output instanceof StreamingOutput) {
                        StreamingOutput streamingOutput = (StreamingOutput) output;
                        String chunk = streamingOutput.chunk().toString();
                        sink.next(ServerSentEvent.builder(chunk).build());
                    }
                }).thenRun(() -&amp;gt; {
                    sink.complete();
                }).exceptionally(throwable -&amp;gt; {
                    sink.error(throwable);
                    return null;
                });

            } catch (Exception e) {
                sink.error(e);
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;5.3 子图节点&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;子图节点是工作流的模块化组件&lt;/strong&gt;，它允许将复杂的工作流分解为可重用的子模块。子图节点就像函数调用一样，可以在主工作流中调用预定义的子工作流，实现代码复用和模块化设计。&lt;/p&gt; 
&lt;h4&gt;5.3.1 子图节点类型&lt;/h4&gt; 
&lt;p&gt;Spring AI Alibaba Graph 支持两种类型的子图节点：&lt;/p&gt; 
&lt;h5&gt;SubStateGraphNode - 未编译子图节点&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;public class SubStateGraphNode extends Node {
    private final StateGraph subGraph;

    public SubStateGraphNode(String id, StateGraph subGraph) {
        super(id, (config) -&amp;gt; {
            // 在运行时编译子图
            CompiledGraph compiledSubGraph = subGraph.compile(config);
            return new SubGraphAction(compiledSubGraph);
        });
        this.subGraph = subGraph;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;SubCompiledGraphNode - 预编译子图节点&lt;/h5&gt; 
&lt;pre&gt;&lt;code&gt;public class SubCompiledGraphNode extends Node {
    private final CompiledGraph subGraph;

    public SubCompiledGraphNode(String id, CompiledGraph subGraph) {
        super(id, (config) -&amp;gt; new SubGraphAction(subGraph));
        this.subGraph = subGraph;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.3.2 子图定义与使用&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;定义文档处理子图&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class DocumentProcessingSubGraph {

    public static StateGraph createDocumentProcessingGraph(ChatModel chatModel) {
        ChatClient chatClient = ChatClient.builder(chatModel).build();

        // 文档提取节点
        DocumentExtractorNode extractorNode = new DocumentExtractorNode(
            "document_path", "extracted_text", List.of("pdf", "docx", "txt")
        );

        // 文档分析节点
        LlmNode analysisNode = LlmNode.builder()
            .chatClient(chatClient)
            .systemPromptTemplate("你是一个文档分析专家，请分析文档内容并提取关键信息。")
            .userPromptTemplate("请分析以下文档内容：\n{extracted_text}")
            .outputKey("analysis_result")
            .build();

        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("document_path", new ReplaceStrategy());
            strategies.put("extracted_text", new ReplaceStrategy());
            strategies.put("analysis_result", new ReplaceStrategy());
            return strategies;
        };

        return new StateGraph("文档处理子图", stateFactory)
            .addNode("extractor", node_async(extractorNode))
            .addNode("analyzer", node_async(analysisNode))
            .addEdge(START, "extractor")
            .addEdge("extractor", "analyzer")
            .addEdge("analyzer", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;在主工作流中使用子图&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class MainWorkflowConfiguration {

    @Bean
    public StateGraph mainWorkflow(ChatModel chatModel) {
        // 创建子图
        StateGraph documentProcessingSubGraph = DocumentProcessingSubGraph
            .createDocumentProcessingGraph(chatModel);

        // 创建其他节点
        QuestionClassifierNode classifierNode = QuestionClassifierNode.builder()
            .chatClient(ChatClient.builder(chatModel).build())
            .inputTextKey("input")
            .outputKey("classifier_output")
            .categories(List.of("document_processing", "general_question"))
            .build();

        LlmNode generalAnswerNode = LlmNode.builder()
            .chatClient(ChatClient.builder(chatModel).build())
            .systemPromptTemplate("你是一个通用助手，请回答用户的问题。")
            .userPromptTemplate("用户问题：{input}")
            .outputKey("general_answer")
            .build();

        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("classifier_output", new ReplaceStrategy());
            strategies.put("document_path", new ReplaceStrategy());
            strategies.put("extracted_text", new ReplaceStrategy());
            strategies.put("analysis_result", new ReplaceStrategy());
            strategies.put("general_answer", new ReplaceStrategy());
            return strategies;
        };

        return new StateGraph("主工作流", stateFactory)
            .addNode("classifier", node_async(classifierNode))
            .addNode("document_processor", documentProcessingSubGraph)  // 添加子图
            .addNode("general_answer", node_async(generalAnswerNode))
            .addEdge(START, "classifier")
            .addConditionalEdges("classifier", 
                edge_async(new ClassifierDispatcher()),
                Map.of("document_processing", "document_processor", 
                       "general_question", "general_answer"))
            .addEdge("document_processor", END)
            .addEdge("general_answer", END);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.3.3 子图执行流程&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bb60589b6217b7b551946b05fb8c22e0214.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.3.4 子图状态管理&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;状态隔离与传递&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class SubGraphAction implements AsyncNodeActionWithConfig {
    private final CompiledGraph subGraph;

    @Override
    public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            try {
                // 从主状态中提取子图需要的数据
                Map&amp;lt;String, Object&amp;gt; subGraphInput = extractSubGraphInput(state);

                // 执行子图
                Optional&amp;lt;OverAllState&amp;gt; subGraphResult = subGraph.invoke(subGraphInput, config);

                // 将子图结果映射回主状态
                return mapSubGraphOutput(subGraphResult.orElse(null));

            } catch (Exception e) {
                throw new RuntimeException("子图执行失败", e);
            }
        });
    }

    private Map&amp;lt;String, Object&amp;gt; extractSubGraphInput(OverAllState state) {
        Map&amp;lt;String, Object&amp;gt; input = new HashMap&amp;lt;&amp;gt;();
        // 根据子图的输入需求提取数据
        state.value("document_path").ifPresent(value -&amp;gt; input.put("document_path", value));
        state.value("input").ifPresent(value -&amp;gt; input.put("input", value));
        return input;
    }

    private Map&amp;lt;String, Object&amp;gt; mapSubGraphOutput(OverAllState subGraphState) {
        Map&amp;lt;String, Object&amp;gt; output = new HashMap&amp;lt;&amp;gt;();
        if (subGraphState != null) {
            // 将子图的输出映射到主状态
            subGraphState.value("analysis_result").ifPresent(value -&amp;gt; 
                output.put("analysis_result", value));
            subGraphState.value("extracted_text").ifPresent(value -&amp;gt; 
                output.put("extracted_text", value));
        }
        return output;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;5.4 中断与恢复机制&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;中断与恢复机制是工作流的容错保障&lt;/strong&gt;，它让工作流能够在遇到需要人工干预或外部条件不满足时优雅地暂停执行，并在条件满足后无缝恢复。这种机制对于构建可靠的企业级 AI 应用至关重要。&lt;/p&gt; 
&lt;h4&gt;5.4.1 中断机制原理&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-87ca42d66647b36a58fa828a43d2c65a556.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5.4.2 中断条件配置&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;InterruptBefore - 节点执行前中断&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class InterruptConfiguration {

    @Bean
    public CompiledGraph interruptableGraph(StateGraph stateGraph) {
        return stateGraph.compile(CompileConfig.builder()
            .withInterruptBefore("human_approval")  // 在 human_approval 节点前中断
            .build());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;InterruptAfter - 节点执行后中断&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Bean
public CompiledGraph interruptableGraph(StateGraph stateGraph) {
    return stateGraph.compile(CompileConfig.builder()
        .withInterruptAfter("data_processing")  // 在 data_processing 节点后中断
        .build());
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;动态中断条件&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class DynamicInterruptNode implements AsyncNodeActionWithConfig {

    @Override
    public CompletableFuture&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; apply(OverAllState state, RunnableConfig config) {
        return CompletableFuture.supplyAsync(() -&amp;gt; {
            // 检查是否需要中断
            if (shouldInterrupt(state)) {
                // 设置中断消息
                state.setInterruptMessage("需要人工审批，请检查数据质量");

                Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
                result.put("interrupt_reason", "data_quality_check");
                result.put("requires_approval", true);
                return result;
            }

            // 正常处理逻辑
            return processData(state);
        });
    }

    private boolean shouldInterrupt(OverAllState state) {
        // 自定义中断条件逻辑
        Double confidence = (Double) state.value("confidence_score").orElse(1.0);
        return confidence &amp;lt; 0.8;  // 置信度低于 80% 时中断
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;5.4.3 状态快照管理&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;内存快照存储&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Component
public class MemorySnapshotManager {

    private final Map&amp;lt;String, OverAllState&amp;gt; snapshots = new ConcurrentHashMap&amp;lt;&amp;gt;();

    public String saveSnapshot(OverAllState state) {
        String snapshotId = UUID.randomUUID().toString();
        snapshots.put(snapshotId, state.snapShot().orElse(state));
        return snapshotId;
    }

    public OverAllState loadSnapshot(String snapshotId) {
        OverAllState snapshot = snapshots.get(snapshotId);
        if (snapshot == null) {
            throw new IllegalArgumentException("快照不存在: " + snapshotId);
        }
        return snapshot;
    }

    public void removeSnapshot(String snapshotId) {
        snapshots.remove(snapshotId);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;持久化快照存储&lt;/strong&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Component
public class PersistentSnapshotManager {

    private final RedisTemplate&amp;lt;String, String&amp;gt; redisTemplate;
    private final ObjectMapper objectMapper;

    public String saveSnapshot(OverAllState state) {
        try {
            String snapshotId = UUID.randomUUID().toString();
            String serializedState = objectMapper.writeValueAsString(state);

            redisTemplate.opsForValue().set(
                "snapshot:" + snapshotId, 
                serializedState, 
                Duration.ofHours(24)  // 24 小时过期
            );

            return snapshotId;
        } catch (Exception e) {
            throw new RuntimeException("保存快照失败", e);
        }
    }

    public OverAllState loadSnapshot(String snapshotId) {
        try {
            String serializedState = redisTemplate.opsForValue().get("snapshot:" + snapshotId);
            if (serializedState == null) {
                throw new IllegalArgumentException("快照不存在: " + snapshotId);
            }

            return objectMapper.readValue(serializedState, OverAllState.class);
        } catch (Exception e) {
            throw new RuntimeException("加载快照失败", e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ol start="6"&gt; 
 &lt;li&gt;快速开始与实战指南&lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;h3&gt;6.1 环境准备&lt;/h3&gt; 
&lt;h4&gt;6.1.1 依赖配置&lt;/h4&gt; 
&lt;p&gt;在你的 Spring Boot 项目中添加 Spring AI Alibaba Graph 依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;spring-ai-alibaba.version&amp;gt;1.0.0.3-SNAPSHOT&amp;lt;/spring-ai-alibaba.version&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-ai-alibaba-starter-dashscope&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba.cloud.ai&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-ai-alibaba-graph-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring-ai-alibaba.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.2 快速开始流程&lt;/h3&gt; 
&lt;h4&gt;6.2.1 创建第一个工作流&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@Configuration
public class MyFirstGraphConfiguration {

    @Bean
    public StateGraph myFirstGraph(ChatModel chatModel) {
        // 1. 创建 ChatClient
        ChatClient chatClient = ChatClient.builder(chatModel).build();

        // 2. 定义节点
        LlmNode welcomeNode = LlmNode.builder()
            .chatClient(chatClient)
            .systemPromptTemplate("你是一个友好的助手")
            .userPromptTemplate("欢迎用户：{input}")
            .outputKey("welcome_message")
            .build();

        // 3. 定义状态策略
        KeyStrategyFactory stateFactory = () -&amp;gt; {
            Map&amp;lt;String, KeyStrategy&amp;gt; strategies = new HashMap&amp;lt;&amp;gt;();
            strategies.put("input", new ReplaceStrategy());
            strategies.put("welcome_message", new ReplaceStrategy());
            return strategies;
        };

        // 4. 构建工作流
        return new StateGraph("我的第一个工作流", stateFactory)
            .addNode("welcome", node_async(welcomeNode))
            .addEdge(START, "welcome")
            .addEdge("welcome", END);
    }

    @Bean
    public CompiledGraph compiledGraph(StateGraph myFirstGraph) {
        return myFirstGraph.compile();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;6.2.2 使用工作流&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;@RestController
public class GraphController {

    private final CompiledGraph compiledGraph;

    @PostMapping("/chat")
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; chat(@RequestBody String input) {
        Optional&amp;lt;OverAllState&amp;gt; result = compiledGraph.invoke(Map.of("input", input));
        return ResponseEntity.ok(result.map(OverAllState::data).orElse(Map.of()));
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.3 完整示例项目&lt;/h3&gt; 
&lt;p&gt;为了帮助开发者更好地理解和使用 Spring AI Alibaba Graph，我们提供了完整的示例项目：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;📚官方示例仓库&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;spring-ai-alibaba-graph-example【1】&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;快速体验步骤&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. 克隆仓库&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;git clone https://github.com/springaialibaba/spring-ai-alibaba-examples.git
cd spring-ai-alibaba-examples/spring-ai-alibaba-graph-example
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;2. 配置环境&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 设置 DashScope API Key
export AI_DASHSCOPE_API_KEY=your_api_key_here
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;3. 运行示例&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;mvn spring-boot:run
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;6.4 社区支持&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;技术支持&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;GitHub Issues&lt;/strong&gt; ：&lt;br&gt; 提交问题和建议【4】&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;官方文档&lt;/strong&gt; ：&lt;br&gt; 完整文档站点【5】&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;示例代码&lt;/strong&gt; ：&lt;br&gt; 更多示例【6】&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;通过以上指南和完整的示例项目，你可以快速掌握 Spring AI Alibaba Graph 的使用方法，并在实际项目中高效地构建智能化应用。&lt;/p&gt; 
&lt;p&gt;【1】spring-ai-alibaba-example 仓库&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples%2Ftree%2Fmain%2Fspring-ai-alibaba-graph-example" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples/tree/main/spring-ai-alibaba-graph-example&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【2】Spring AI Alibaba Graph 观测性设计与实现&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.yuque.com%2Fdisaster-4qc4i%2Fxhs01z%2Fqrh6lv7m3sexgvr4" target="_blank"&gt;https://www.yuque.com/disaster-4qc4i/xhs01z/qrh6lv7m3sexgvr4&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【3】完整示例代码&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples%2Ftree%2Fmain%2Fspring-ai-alibaba-graph-example%2Fgraph-observability-langfuse" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples/tree/main/spring-ai-alibaba-graph-example/graph-observability-langfuse&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【4】提交问题和建议&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Falibaba%2Fspring-ai-alibaba%2Fissues" target="_blank"&gt;https://github.com/alibaba/spring-ai-alibaba/issues&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【5】完整文档站点&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjava2ai.com%2F" target="_blank"&gt;https://java2ai.com/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;【6】更多示例&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspringaialibaba%2Fspring-ai-alibaba-examples" target="_blank"&gt;https://github.com/springaialibaba/spring-ai-alibaba-examples&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3874284/blog/18685786</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3874284/blog/18685786</guid>
      <pubDate>Thu, 17 Jul 2025 03:10:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>秘塔搜索 API 上线，每次查询 3 分钱</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;秘塔&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FAKYOZfBM_Ph0OiIj_8lCeg" target="_blank"&gt;宣布&lt;/a&gt;正式上线搜索 API，为开发者提供了在 Bing Search API 下线后的一个新选择。&lt;/p&gt; 
&lt;p&gt;该 API 的定价为每次查询 0.03 元，。秘塔表示，该服务基于其过去一年自建的数百亿规模的多语言索引库，该索引库已在「秘塔 AI 搜索」产品中经受了每天千万级的调用考验。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0725/110223_NAmj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;访问 metaso.cn，点击首页 「API」 按钮，测试和接入。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;API 支持网页、图片、视频、文库等多模态搜索，并且没有使用门槛，开发者可以即时测试和接入。除了常规搜索 API，秘塔还提供网页全文获取和问答接口，可按需调用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362265</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362265</guid>
      <pubDate>Thu, 17 Jul 2025 03:03:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>筑牢软件供应链安全屏障，链图・SBOM 管理服务平台重磅来袭</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;进入数字化时代，软件已成为支撑经济社会正常运行的关键基础设施，而随着软件开发模式逐步由闭源集约开发转变为开源规模化协作，软件供应链也愈发复杂多元。与此同时，漏洞缺陷、协议合规、供应链「投毒」等安全事件屡有发生，给软件供应链安全带来巨大挑战。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;去年 9 月，国家工业信息安全发展研究中心依托「开源社区软件物料清单（SBOM）平台」国家专项，牵头建设「SBOM 标准社区」，并&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;发起&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;了「SBOM 筑链计划」。聚焦 SBOM 标准开源、技术突破、应用实践、生态繁荣等方面，旨在&lt;/span&gt;提升软件供应链的透明度与安全性，强化对软件供应链风险的管控与治理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;7 月 24 日，由开放原子开源基金会主办，国家工业信息安全发展研究中心、开源风险评估与治理技术实验室联合承办的「2025 开放原子开源生态大会软件物料清单（SBOM）分论坛」在北京国家会议中心二期正式召开。&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="845" src="https://oscimg.oschina.net/oscnet/up-ed2e42e5f9fb13ace71f50f03422df2ce81.png" width="1267" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;会上，&lt;strong&gt;&lt;strong&gt;国家工业信息安全发展研究中心牵头 11 家联合体成员单位建设的「链图·SBOM 管理服务平台」正式发布&lt;/strong&gt;&lt;/strong&gt;。该平台面向个人开发者、企业用户、开源社区、重点行业四类用户提供 SBOM 全生命周期管理，助力提升软件透明度和供应链管理水平，防范开源代码风险。&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="827" src="https://oscimg.oschina.net/oscnet/up-9eae602569c72746369e7da3ab9161eebed.png" width="1264" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;官方链接：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.csbom.cn" rel="nofollow" target="_blank"&gt;https://www.csbom.cn&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;平台核心功能，全方位保障软件供应链安全&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;链图·SBOM 管理服务平台提供了较为完善的 SBOM 管理功能，为保障软件供应链安全提供有力支撑，涵盖 SBOM 生成、SBOM 下载、SBOM 分享、SBOM 对比、格式转换等功能，同时通过集成多种类型的安全检测能力，实现 SBOM 风险分析及有效管理，提高软件供应链的透明度，有助于发现潜在的安全风险及合规问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;平台支持源码文件、包管理器配置文件、二进制格式文件、容器镜像文件等多类型软件格式的 SBOM 生成，生成的文件格式不仅支持《T/CQAE 19004-2025 软件物料清单构成和要求》（BOM-SW）这一标准，还兼容 SPDX、CycloneDX、SWID 等主流格式，确保了平台的广泛适用性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-a47d1745f3f7df56f5ea6319e7aa346ee33.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;值得一提的是，借助平台内置的智能算法和规则引擎，用户只需一键操作，就能快速获得一份详细且准确的 SBOM 文件，提高了工作效率，同时也保证了文件质量，为后续的软件供应链安全管理奠定了坚实基础。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="406" src="https://oscimg.oschina.net/oscnet/up-427ba61fe6e92232b96a2c1fe73162c8c0c.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;BOM-SW 标准结构图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在软件管理过程中，文件分享又是必不可少的。平台的 SBOM 分享功能既灵活又安全。用户选中文件点击分享后，可根据需求设置分享信息，通过链接分享给特定用户，并能设置验证码和时效。这一设计在确保信息顺利传递的同时，又为用户提供了便利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-e518ce71cc2e5becd87860d3d134243d72c.png" width="546" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;因格式不兼容，在软件物料清单交互时带来的不便，平台的 SBOM 转换功能也相应给出了解决方案。根据交互需求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;平台支持 SBOM 文件的格式在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;BOM-SW、SPDX、CycloneDX、SWID 标准&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;之间相互转换，并且在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;转换过程中严格保证数据的完整性和准确性，确保软件物料清单信息不丢失，为跨系统、跨组织的软件供应链安全管理提供了支持。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="196" src="https://oscimg.oschina.net/oscnet/up-b3132918e81f33ee4454103df0d8549003b.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在软件的开发、更新迭代过程中，SBOM 对比功能同样发挥着重要作用。用户只需要在平台选择两份需要对比的 SBOM 文件，平台就能迅速分析并直观呈现出对比结果，如组件的增减、版本差异、许可证变动等关键信息。用户可通过 SBOM 对比功能快速把握软件物料清单的变化，为软件升级、整合等决策提供可靠依据，避免因软件变动引发的安全问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="265" src="https://oscimg.oschina.net/oscnet/up-0f21c1b68eb57c42b397f051d120cdce314.png" width="552" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;个性化服务，满足多元安全需求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;针对不同用户在软件供应链安全管理方面有着不同的需求，链图·SBOM 管理服务平台为个人用户、企业用户、行业用户及开源社区用户分别提供了个性化服务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1、个人用户&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;个人用户登录平台后，会看到简洁明了且功能丰富的 SBOM 总览页面，进行中的项目、SBOM 数量、组件数量、许可证数量，及平台工具等关键信息一目了然。侧边栏还拥有一个「快速使用」的入口，涵盖常用的 SBOM 管理操作，极大简化了操作流程，降低了使用门槛，让个人用户也能轻松管理软件安全事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="268" src="https://oscimg.oschina.net/oscnet/up-12f4e07c9de6b6aa624ada76967e105d897.png" width="548" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、企业用户&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;企业用户增设专属的总览页面，呈现企业层面更为全面的数据视图。企业管理者可以查看项目数量、SBOM 数量、格式及类型分布、组件许可证使用情况和风险情况等。通过这些数据，管理者能从全局视角把握企业软件供应链的整体状况，为战略决策提供数据支撑，合理调配资源，优化风险管理策略，确保企业软件供应链的稳健运营。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="303" src="https://oscimg.oschina.net/oscnet/up-a3c718e765b3bad397e1c5d3860c77d9b28.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、行业用户&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;行业用户在平台的后台监测大屏上则可以快速查看整个行业的 SBOM 管理情况概览。平台以直观的统计图表和关键数据指标，呈现行业内软件物料清单的分布、风险水平和合规状况等重要信息，为制定行业政策、规范行业标准提供有力依据。同时，行业用户还能深入查看单个企业的详细情况，实现精准监管，保障行业软件供应链的安全与合规。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="362" src="https://oscimg.oschina.net/oscnet/up-853841a6f01ec94fdf7d1a8a0bec84dacf9.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、开源社区用户&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开源社区用户在平台上拥有便捷的使用体验。他们可以通过授权第三方社区账号权限直接登录，开启分享功能后能将 SBOM 信息在社区内高效传播。平台与开源社区通过插件集成实现深度融合，社区用户在社区界面就能进行 SBOM 上传、下载等操作，优化了操作体验，促进了开源生态的协同发展，让开源社区的软件安全管理更加高效。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-e044c8efb12389bc4a5ac467f99a28d8c55.png" width="554" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此前，开源中国 Gitee 平台积极响应国家战略，已上线链图·SBOM 管理服务平台相关服务并试运行。在此期间，Gitee 上已有超过 350 家企业试用了链图·SBOM 管理服务平台，而在开源社区层面，也有超 40 家开源社区试用，生成 SBOM 文件数量超 1000 份。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;除此之外，链图·SBOM 管理服务平台还为各类型用户提供了一个「工具市场」，例如：容器镜像成分分析工具、开源代码自动化巡检工具、许可证合规分析工具原型、二进制文件安全验证工具等，以支持不同使用场景下的工具调用，在使用者无需跨平台调用工具的同时，也保证了账号的数据安全，进一步为软件供应链安全护航。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px; text-align:center"&gt;&lt;img height="260" src="https://oscimg.oschina.net/oscnet/up-4076142b6b7c6e007b5e27eeb7a0f290d2b.png" width="553" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;未来展望，持续守护软件安全&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;链图·SBOM 管理服务平台后续将为开源社区等组织提供软件资产管理、漏洞感知、链路追溯等一系列服务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过这些服务，平台能够及时掌握产业发展动态及安全威胁，为相关单位提供决策支撑，有效保障开源供应链安全，助力软件产业高质量发展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;未来，国家工业信息安全发展研究中心依托「筑链计划」深化与业界各方的交流合作，持续加强标准应用、工具测评、平台推广等方面创新和实践，进一步完善软件供应链安全体系，护航我国开源软件高质量发展，为数字化时代的安全发展保驾护航！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4806939/blog/18685839</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4806939/blog/18685839</guid>
      <pubDate>Thu, 17 Jul 2025 03:00:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>智谱即将发布 GLM-4.5 系列模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智谱 AI 即将发布其 GLM-4.5 系列模型，预计将包括一个 106B 和一个 355B 的大模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0725/105226_VfFm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;从 vLLM 和 modelscope/ms-swift 代码库中的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmodelscope%2Fms-swift%2Fcommit%2Fa26c6a1369f42cfbd1affa6f92af2514ce1a29e7" target="_blank"&gt;提交记录&lt;/a&gt;可以看到，此次发布预计将包括两个型号：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;名为 GLM-4.5-Air 的 106B-A12B 模型&lt;/li&gt; 
 &lt;li&gt;名为 GLM-4.5 的 355B-A32B 模型。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;智谱在 2025 年 4 月 15 日发布 GLM-4-32B/9B 系列开源模型（含基座、推理、沉思三类模型），并在 7 月 2 日开源了 GLM-4.1V-Thinking 视觉语言模型。此外，智谱在 2024 年 ICLR 大会上曾提出 GLM-4.5 及后续升级模型的技术方向，强调将基于 「超级认知」 和 「超级对齐」 技术，构建原生多模态大模型，并推动 GLM-OS（以大模型为中心的通用计算系统）的发展 。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362260</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362260</guid>
      <pubDate>Thu, 17 Jul 2025 02:54:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>字节 Agent 产品扣子空间上线网页设计功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;字节系 Agent 产品扣子空间&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(Coze Space)&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;宣布正式推出其网页设计功能，5 分钟即可完成一个网页设计。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;用户可打开扣子空间网站 (&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fcoze.cn" target="_blank"&gt;coze.cn&lt;/a&gt;&lt;span style="color:#000000"&gt;)，点击「网页」标签，然后在对话框中输入具体的设计需求，系统即可自动生成一个符合用户描述的网页。例如，用户可以要求生成一个现代、响应式的招聘网站，指定主题色、背景色、布局风格等细节，扣子空间能够在短时间内生成一个完整的网站，并提供实时预览。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="273" src="https://oscimg.oschina.net/oscnet/up-7add01b828e3be5ec8bdbdd6ee694594fbd.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这一功能不仅支持自然语言输入，还允许用户通过点击元素进行二次编辑，调整细节，如颜色、布局等。此外，扣子空间还支持上传参考图片，无论是截图、Figma 设计稿、网站链接还是手绘稿，系统都能一键复刻，实现 1:1 还原设计。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;扣子空间的网页设计功能适用于多种场景，包括活动营销页面、机构主页、个人主页、生活网页和前端工具等。用户可以根据不同的需求，输入相应的指令公式，生成符合特定场景的网页。例如，用户可以生成一个专注于北极探险的旅游预订页面，或者一个创意设计工作室的官方网站，甚至是一个个人技术简历网站。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362259</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362259</guid>
      <pubDate>Thu, 17 Jul 2025 02:51:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>从 Workflow 到 Agent：构建自己的自主智能体</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;「自主智能体」正从论文热词变成真实生产力，相较于传统 Workflow 只能按图索骥，自主智能体把方向盘直接交给大模型，让它在动态、开放、甚至不可收敛的问题里自由驰骋。&lt;/p&gt; 
&lt;p&gt;可一旦落地，排队时间长、环境隔离难、幻觉失控、工具对接碎片化……每一道都是现实的高墙。&lt;/p&gt; 
&lt;p&gt;网易 CodeWave 技术负责人姜天意和其团队正在探索从如何让自主智能能通过各种技术达成最佳实践。&lt;/p&gt; 
&lt;p&gt;本周六，姜天意也将出席【Al Agent：从工具助手到自主行动】OSC 源创会・杭州站活动，并发表《从 Workflow 到 Agent：构建自己的自主智能体》主题演讲，从网易自研自主智能体平台 CoreAgent 出发，讲解如何通过自主 Agent，MCP 协议，运行沙箱，长短记忆管理等技术构建一个自主智能体产品。&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;即刻报名：&lt;/span&gt;&lt;a href="https://www.oschina.net/event/8597955"&gt;https://www.oschina.net/event/8597955&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1440" src="https://oscimg.oschina.net/oscnet/up-d11d0a649fa2a9c9416a212f5addcdeb230.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：「自主智能体」这个概念近来非常火爆，在您看来，「自主智能体」区别于传统「Workflow 自动化」最核心的、革命性的特质是什么？它带来了哪些之前难以实现的场景可能性？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;Workflow 则是按照预设去完成标准化、重复性的任务，是很死板的，完全依赖预设的流程。自主智能体主要是交给大模型自主完成复杂，动态的目标，解决个性化，不收敛的问题。所以你像编程方面的 Code Agent，科研方面的 DeepResearch，甚至说你在日常遇到的比如旅游路线推荐，帮我分析下 Excel 做总结等，均是 WorkFlow 智能体非常难以实现的。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：网易自研的 CoreAgent 平台在解决当前主流的 Agent 框架面临的哪些关键挑战上有独特的优势？它的核心设计哲学是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;其实像 Manus 这类自主智能体的创业公司，他们产品体验时最常出现的一个问题是排队、执行时间长。为什么会有这个问题呢，因为自主智能体在每个实例运行时，都需要动态去分配一个虚拟化的运行容器，还要有容器的生命周期管理的机制，心跳等等。这一类产品在容器的动态扩缩容，资源复用，启动加速等其实比较难有积累。网易这边之前做过很多云原生项目的积累，对容器、沙箱管理、资源加载等都比较擅长。同时因为我们团队长期做一些智能开发产品，对 Code Agent、数据分析 Agent 等场景非常熟悉，也能够针对性地对任务调优，这也是我们的优势。还有一点由于我们做过很多 toB 项目，在 toB 里自主智能体他并不一定是一个全发散的场景也会有一定收敛，所以我们设计了一个机制叫最佳实践，用户可以每次跑自主智能体都积累这个最佳实践并针对性修正，下次跑的时候可以召回参考，同时也可以作为全局的经验供其他类似场景的自主智能体参考，这样会越跑越准确。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：能否简要透露一下 MCP 协议主要解决了自主 Agent 协同中的哪些核心问题？而「运行沙箱」对于 Agent 的可靠性和安全性起到了怎样的保障作用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;其实原先 OpenAI 通过 Function Calling 提供了类似工具使用的能力。MCP 协议最重要的是提供了一个标准化的万物互联的协议，我们认为他是 Function Calling 的标准实现，对于工具提供商再也不需要写那么多不同种类的 SDK 给外面用了，统一暴露 MCP 服务即可，对于模型应用开发者，调用工具更简单更稳定，不需要通过像 Prompt 工程来约束 LLM 的返回，也不需要做复杂的参数解析等。这样极大地扩展了 LLM 的上限。&lt;/p&gt; 
&lt;p&gt;运行时沙箱主要提供了硬件级别的隔离，因为自主智能体他操作的能力很多，包括电脑的，代码的，环境的浏览器的，很容易影响到运行环境。因此通过沙箱可以有效的做环境的隔离。同时自主智能体经常是长尾需求，也能通过沙箱及时回收资源降低资源占用。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：在构建和落地像 CoreAgent 这样的自主智能体平台过程中，您认为面临的最大技术挑战或工程挑战是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;最大的技术挑战有两个&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;保证智能体运行的稳定，避免幻觉。在工程上我们做了很多兜底，比如对工具使用的、返回结果的约束，运行过程中的优化等，同时我们也通过像最佳实践、知识召回的能力来约束智能体的行为，让他尽可能反思&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;对沙箱环境的管理和稳定性等，包括沙箱生命周期的管理、沙箱的存活时间、沙箱跟外界的通信，沙箱环境启动速度的加快和预热等&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：您认为「自主智能体」从技术概念走向大规模实际应用，最迫切需要跨越的门槛是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;主要还是依赖模型能力的提升和周边 MCP 能力的建设。自主智能体对模型的 Plan 能力和 MCP 支持，要求非常高，目前我们测试下来可能只有 Claude 能够达到较好的效果。同时我们发现在公司内部落地的时候，很多工具平台都缺少 MCP 服务，对接困难，所以都会有个打磨的过程。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#27ae60"&gt;&lt;strong&gt;问：对于想要开始在自己的项目中尝试构建或集成「自主智能体」能力的开发者/工程师，您有什么最重要的建议或关键考量？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;答：&lt;/strong&gt;自主智能体虽然以开放性任务为主，但还是要在任务过程中做好足够的干预，避免跑偏。可以在跑完后进行最佳实践的修正&lt;/p&gt; 
&lt;p&gt;同时要注意提供足够的工具来完成任务，对接该工具的 MCP 服务。比如跑的过程中要发消息之类，就需要提前先把这个消息工具准备好。&lt;/p&gt; 
&lt;p&gt;&lt;img height="6021" src="https://oscimg.oschina.net/oscnet/up-4f94d78edf59b79e2169b9509b4d9e02a2e.png" width="1800" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4489239/blog/18685831</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/18685831</guid>
      <pubDate>Thu, 17 Jul 2025 02:44:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>阿里通义千问推出机器翻译模型 Qwen-MT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里云通义千问 Qwen 团队发文宣布推出机器翻译模型 Qwen-MT，基于 Qwen3 模型打造，进一步使用超大规模多语言和翻译数据对模型进行训练，全面增强其多语言理解与翻译能力，并结合强化学习技术，显著提升了翻译结果的准确性与语言流畅度。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;核心亮点包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;92 种语言互译 ：支持超过 92 种主流官方语言及重要方言之间的高质量互译，覆盖全球 95% 以上的人口，满足广泛的语言交流需求。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;高度可控性：提供术语干预、领域提示、记忆库等专业翻译功能，并支持用户自定义提示，有效提升模型在复杂、专业或特定应用场景下的翻译表现。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;低延迟、低成本：采用轻量级 MoE（Mixture of Experts）架构，在保证卓越性能的同时实现更快的响应速度和更低的 API 调用价格（每百万输出 token 低至 2 元），更适合高并发、实时性要求高的应用场景。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告称，在中英、英德多领域翻译以及 WMT24 多语言翻译任务中，Qwen-MT 显著优于同规模模型，如 GPT-4.1-mini、Gemini-2.5-Flash 和 Qwen3-8B。甚至与 GPT-4.1、Gemini-2.5-Pro、Qwen3-235B-A22B 等顶级大模型相比，翻译效果依然毫不逊色。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="292" src="https://oscimg.oschina.net/oscnet/up-e8768779345866a736fcf524d45915410a8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;人工评估结果也表明，&lt;span style="color:#000000"&gt;在合格率、优良率上，Qwen-MT 均展现出显著优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-4ce65be0c17a1234532e45315784dd1cf8d.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-b94159e883c125cebe49827b6b92ede7c3a.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;更多详情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F2LQIrsaBgXcxw76BYshfdw" target="_blank"&gt;查看官方公告&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/362251</link>
      <guid isPermaLink="false">https://www.oschina.net/news/362251</guid>
      <pubDate>Thu, 17 Jul 2025 02:21:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
