<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Sun, 13 Apr 2025 07:41:27 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>「天衍」量子计算云平台访问量突破 2700 万</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnstock.com%2FcommonDetail%2F394917&quot; target=&quot;_blank&quot;&gt;据报道&lt;/a&gt;&lt;/u&gt;，「天衍」量子计算云平台当前访问量已突破 2700 万。该平台面向全球开放，涵盖海内外 50 多个国家的用户，提交的实验任务数超过 140 万次。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1856&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/192538_z4F9_2720166.png&quot; width=&quot;3360&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqc.zdxlz.com%2Fhome%3Flang%3Dzh&quot; target=&quot;_blank&quot;&gt;https://qc.zdxlz.com/home?lang=zh&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;「天衍」量子计算云平台发布于 2023 年 11 月，由中国电信发布，各项性能均达到国际一流水平。该平台配备 5 类运算性能世界一流的高性能仿真机和 Cqlib 系列编程框架，支持量子模拟、量子化学、量子气象、量子人工智能等领域的应用探索。&lt;/p&gt; 
&lt;p&gt;2024 年 12 月，「天衍」量子计算云平台正式接入全国单台比特数最多的超导量子计算机「天衍-504」，实现了「天衍」量子计算云平台在算力规模和算力类型上的双重升级，构建起由一台 24 比特、两台 176 比特和一台 504 比特的量子计算机组成的国内最大规模量子计算集群。&lt;/p&gt; 
&lt;p&gt;据了解，2025 年被联合国宣布为「国际量子科技年」（International Years of Quantum, IYQ），旨在以量子力学诞生 100 周年为契机，在全球范围内提升公众对量子科技的认知度，促进各国在量子领域的交流与合作，加速推进量子技术的研发与产业化应用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344050</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344050</guid>
            <pubDate>Thu, 03 Apr 2025 11:26:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌发布《Prompt Engineering》白皮书</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;谷歌近日发布了一份长达 68 页的白皮书，系统阐述了提示工程（Prompt Engineering）的核心理念与最佳实践。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1600&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/190255_bXPt_2720166.png&quot; width=&quot;1260&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;本白皮书详细讨论了提示词工程，探讨各种提示词技巧，帮助新手入门，并分享一些技巧和最佳实践，助任何人成为提示专家。还讨论了在设计提示时可能遇到的一些挑战。&lt;/p&gt; 
&lt;p&gt;白皮书深入探讨了多种提示技术，包括：零样本提示（Zero-Shot Prompting）、单样本提示（One-Shot Prompting）、少样本提示（Few-Shot Prompting）、思维链提示（Chain-of-Thought，CoT）、ReAct 提示以及代码提示。&lt;/p&gt; 
&lt;p&gt;这些技术各有适用场景，白皮书通过案例分析展示了如何根据任务需求选择合适的提示策略。&lt;/p&gt; 
&lt;p&gt;详情访问：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.kaggle.com%2Fwhitepaper-prompt-engineering&quot; target=&quot;_blank&quot;&gt;https://www.kaggle.com/whitepaper-prompt-engineering&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344043/whitepaper-prompt-engineering</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344043/whitepaper-prompt-engineering</guid>
            <pubDate>Thu, 03 Apr 2025 11:04:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>全球脑机接口应用迎来新突破</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;全球脑机接口技术飞速发展，应用领域正逐渐从医疗领域扩大至教育、游戏等非医疗领域。与此同时，人工智能（AI）等新兴技术的快速演进正在推动脑机接口技术应用实现更多突破。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;脑机接口是一种变革性的人机交互技术，其工作原理是采集脑部神经信号并分析转换成特定指令。该技术能够在大脑与外部设备之间创建直接连接，实现「脑」与「机」之间的直接信息交换。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;脑机接口设备的重要功能包括帮助治疗记忆力衰退、颈脊髓损伤及其他神经系统疾病，帮助有运动功能障碍的患者、瘫痪人群恢复部分能力，甚至帮助他们重新行走，改善和提升他们的生活质量。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;随着脑机接口技术的发展，其在医疗领域与非医疗领域的潜在应用场景也在不断扩展，包括监测与评估大脑状态、调控神经、增强感官能力、提高游戏的操控性以及用于教育等领域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，脑机接口技术按照其是否需要侵入大脑以及侵入的程度分为非侵入式、侵入式、半侵入式三类。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;侵入式脑机接口需要将电极或传感器等硬件设备植入到大脑皮层，以直接捕获神经信号，主要优点是信号质量较高，可以实现对神经信号的直接监测和调控。但由于涉及手术风险和可能的健康隐患，侵入式脑机接口的应用范围相对有限。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;非侵入式脑机接口则不需要通过手术将硬件设备植入人体，而是通过采集脑电信号等无创方式来间接监测大脑活动，具有无创、低风险、易操作等优点，但存在信号质量相对较低、对环境干扰较为敏感等局限性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;半侵入式脑机接口介于非侵入式和侵入式脑机接口之间，虽然仍需要通过手术布置电极，但电极并不植入大脑皮层，而是置于颅骨下、皮层上方。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;业内人士认为，全球脑机接口的发展历程可以分为学术探索阶段、科学论证阶段和应用试验阶段，目前该技术正处于第三个阶段，并蓬勃发展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年 1 月，美国「神经连接」公司完成了该公司首例脑机接口设备人体移植，移植后患者可通过意念移动电脑屏幕上的光标；2024 年 3 月，中国团队宣布成功研发出 65000 通道、双向的脑机接口芯片；2024 年 8 月，「神经连接」公司表示，已完成该公司第二例脑机接口设备人体移植，接受移植者在术后用意念控制光标、玩电子游戏等能力增强。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2025 年，脑机接口应用持续迎来新进展。在 AI 赋能下，脑机接口的实时性和低延迟性能显著提升；而高密度柔性电极和解码算法的协同创新，使半侵入式技术也取得新进展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;今年 1 月，「神经连接」公司创始人埃隆·马斯克在社交媒体上宣布，该公司已完成第三例脑机接口设备人体植入手术，且设备运行良好，预计 2025 年还会增加约 20 例至 30 例。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 31 日，美国加利福尼亚大学旧金山分校领衔的研究团队在英国《自然·神经学》杂志上发表论文说，他们利用人工智能算法改进了脑机接口植入设备，使一名失语 18 年的中风患者能以更接近自然语言的速度将想法转换成语言表达出来。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;据介绍，经改进的脑机接口系统可在 3 秒内同步完成对患者所思考语句的实时解析与语音转化，而患者此前所用的辅助通信设备完成这一过程需要超过 20 秒。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;近期，中国脑机接口植入人脑技术也取得新突破。中国自主研发的半侵入式脑机接口「北脑一号」第三例人体植入手术于 3 月 20 日在天坛医院成功完成。前两例先后在北大第一医院、首都医科大学宣武医院完成。接受手术后，瘫痪病人已实现意念控制运动，因患渐冻症而失语的病人已实现语言交流能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;据业内专家介绍，「北脑一号」集成了中国自主研发的柔性高密度脑皮层电极，128 通道同时采集的信号通量在同类产品中处于国际领先水平。这种新型的半侵入式脑机接口既提升了信号采集的精准度，又降低了手术创伤和术后风险，弥补了侵入式和非侵入式技术的不足。（新华社）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344040</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344040</guid>
            <pubDate>Thu, 03 Apr 2025 10:32:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>AI 有病，得治！</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;凝视深渊过久，深渊将回以凝视。——尼采&lt;/p&gt; 
 &lt;/blockquote&gt; 
 &lt;p&gt;2022 年，全球最大的轻博客网站 Tumblr 上发生了一件挺有意思的事情。&lt;/p&gt; 
 &lt;p&gt;大量的 Tumblr 用户对马丁·斯科塞斯（就是拍《华尔街之狼》的那位）1973 年执导的电影 &lt;strong&gt;Goncharov &lt;/strong&gt;大加赞赏，称赞这部鲜为人知的电影是有史以来最大的黑手党电影——「 Goncharov 远胜于它的时代，却从未赢得它应有的赞赏。」&lt;/p&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//109fb366bbb4aca7b0696040705bf52f.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;随着一张电影海报被翻出，热度一下子冲上网站前五 ，很多人都在 Tumblr 刷屏「求云盘」 「带价拿资源」。但其实，&lt;strong&gt;马丁·斯科塞斯根本就没有拍过这部电影，人类历史上也没有一部名为 Goncharov 的电影！&lt;/strong&gt;这意味着，一张挂名「 Martin Scorsese 」的电影海报，几句互联网背后的虚构影评，最终演变成了一场群体欺骗，直至现在还有人坚信这部电影的存在。&lt;/p&gt; 
   &lt;p&gt;心理学将这样的现象称之为「媒体等同」（media equation），人类天生会倾向一些群体性认同事件，换言之，当群体对同一件事情表现出肯定时，个体对事件往往会丢失判断。你或许会说，怎么可能，难道我就没有独立思考吗？来看下面这张图片👇&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1082a316dd13d43db624d10b0b6d5acd.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;表面上，这是一个被压废墟的孩子，让人怜惜，但细看，&lt;strong&gt;孩子左手为六根手指&lt;/strong&gt;。央视新闻后续为此事件辟谣，该视频为 AI 生成内容，并称：AI 让造谣变得更简单和更「科学」。诸如此类的 AI 乌龙还有很多，比如川普被捕、AI 教皇，只要不是原则性问题，大家反而对这样的「欺骗」趋之若鹜。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//d807597275859fff48069619fbcc1686.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;如果说 Goncharov 的群体欺骗，是藏在人性里的戏谑因子，那么，在人工智能迭代如此迅速的今天，AI 「欺骗」人类，是技术缺陷还是人为？AI 所掀起的全球狂热，是否也该降降温？既然 AI 存在一定的失准，我们如何与 AI 相处？笔者想静下心来和大家聊聊。&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;span id=&quot;OSC_h3_1&quot;&gt;&lt;/span&gt; 
   &lt;h3&gt;技术之病：AI 幻觉&lt;/h3&gt; 
   &lt;p&gt;AI 本身就有「病」—— &lt;strong&gt;AI Hallucinations&lt;/strong&gt; （即：「AI 幻觉」）。&lt;/p&gt; 
   &lt;p&gt;简单理解，它是指诸如 GPT4 、PaLM 、DeepSeek 等大语言模型「一本正经地胡说八道」，将编造的事实与多个段落的连贯性和一致性编织在一起，且称之为真实信息的情况。比如，人有三条腿（常识错误）、李逵大闹五台山（剧情混淆）、第一个登上月球的人是 Charles （实际上是 Neil ，历史虚构）、阿联酋的首都是迪拜（实际上是阿布扎比，数据干扰）...大致分为两类：&lt;/p&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;事实性幻觉：指模型生成的内容与可验证的现实世界事实不一致&lt;/p&gt; &lt;/li&gt; 
    &lt;li&gt; &lt;p&gt;忠实性幻觉：指模型生成的内容与用户的指令或上下文不一致&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
   &lt;p&gt;就拿现在很多企业普遍接入的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvectara%2Fhallucination-leaderboard&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt; DeepSeek R1 来说，幻觉率高达 14.3% ，远高于 V3 的 3.9% &lt;/a&gt;。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//64ff0d04ef2e161ab894ff25a198d756.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;如果说 AI 幻觉是病，这些病是如何来的呢？&lt;/p&gt; 
   &lt;p&gt;首先，病从口入，大数据的数据缺陷，是导致 AI 产生幻觉的一大原因。这其中包括数据缺陷、数据中捕获的事实知识的利用率较低。&lt;/p&gt; 
   &lt;p&gt;具体来说，数据缺陷分为错误信息和偏见（重复偏见、社会偏见），此外大模型也有知识边界，所以存在领域知识缺陷和过失的事实知识——即便大模型吃掉了大量数据，也会在利用时出现问题。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6fe289499621b7bbb0946cde88bed59d.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;除了数据，训练过程也会使大模型产生幻觉。&lt;/p&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;预训练阶段&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
   &lt;p&gt;【架构缺陷】：基于前一个 token 预测下一个 token，这种单项建模阻碍了模型捕捉复杂的上下文关系的能力；随着 token 长度增加，不同位置的注意力被稀释；&lt;/p&gt; 
   &lt;p&gt;【曝露偏差】：模型推理时依赖于自己生成的 token 进行后续推测，错误的 token 会在整个 token 中产生级联错误。&lt;/p&gt; 
   &lt;ul&gt; 
    &lt;li&gt; &lt;p&gt;对齐阶段：&lt;/p&gt; &lt;/li&gt; 
   &lt;/ul&gt; 
   &lt;p&gt;【能力错位】：大模型内在能力与标注数据中描述的功能之间可能存在错位。（边界在哪里，也就放大了幻觉的风险）；&lt;/p&gt; 
   &lt;p&gt;【信念错位】：基于 RLHF 等的微调，使大模型的输出更符合人类偏好，进而牺牲信息真实性。&lt;/p&gt; 
   &lt;p&gt;简言之，AI 的幻觉之病，并不是单一因素导致，而是数据集、架构、算法、训练、推理等等，一系列的发展态叠加而成。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//81a1d494e86c1a830c42d9f1e2b1fbdc.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;图片来源：《 DeepSeek 与 &lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;AI&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt; 幻觉》@清华大学&lt;/span&gt;&lt;/p&gt; 
   &lt;p&gt;既然 AI 幻觉会带来如此多不确定性，科学家为什么不尝试「去幻觉」？事实是，有些问题从根本上就无解，我们能做的：&lt;strong&gt;只有与幻觉共存。&lt;/strong&gt;&lt;/p&gt; 
   &lt;p&gt;不过，在某些特定的情况下，AI 幻觉也可能有一些「意外」的好处。比如，大衞·贝克团队获得 2024 诺贝尔化学奖，源于 AI 幻觉的「错误折叠」启发出新型蛋白质结构；DeepMind 团队发现，AI 在图像分割任务中产生的「超现实边界」虽不符合真实场景，却意外提升了自动驾驶对极端天气的识别精度...&lt;/p&gt; 
   &lt;p&gt;以至于，科学界目前正在构建「 AI 幻觉-实验验证-理论重构」三阶段研究流程，试图通过 AI 幻觉却发现一些人类尚未探索过的可能。&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
   &lt;h3&gt;市场之病：AI 狂欢&lt;/h3&gt; 
   &lt;p&gt;从千模大战，到 DeepSeek 一骑绝尘，AI 市场的狂欢背后，是每天少说都有十几个 AI 新项目如雨后春笋一般诞生。笔者相信这些项目不单是追风口、蹭热度，而是 AI 开辟出了新的道路、新的可能。&lt;/p&gt; 
   &lt;p&gt;但高投入和低收益之间的「剪刀差」的背后，仿佛大家都开诚布公地默认了一件事情：搞 AI 就能赚钱！这又何尝不是一种病态！&lt;/p&gt; 
   &lt;p&gt;根据摩根士丹利的计算，亚马逊、谷歌、Meta 和微软这四大科技巨头整 2024 年的资本支出达到 2460 亿美元，其中大部分资金流向了 AI 领域，大头是数据中心和先进芯片的建设，但实际产生的收益却不够理想，反而在继续加码。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//57d6bceb94075d709e098b923d5fc57b.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;IT 桔子统计，34 家 AI 上市公司中，有 19 家在 2024 年上半年仍然处于亏损状态。显然，&lt;strong&gt;尽管 AI 技术发展迅速，但大多数 AI 公司仍未实现盈利&lt;/strong&gt;。反而，第一批吃螃蟹的人除了像英伟达这种提供芯片的公司，就是赶上 AI 风口利用信息差割韭菜的自媒体博主。&lt;/p&gt; 
   &lt;p&gt;为什么搞 AI 难赚钱，市场上还是有那么多狂热分子？&lt;/p&gt; 
   &lt;p&gt;首先，覆水难收。即便在大模型高唱降本的今天，想要研究一个大模型出来，所投入的资金、物力、人才都是极为庞大的。高昂的开发门槛，砸出了一个巨大的资金缺口，如果后面不持续投入，活到云开见日的那一天，前面的所有心血都会打水漂。&lt;span style=&quot;color:#8f959e&quot;&gt;（还不如赌一把！对吧。）&lt;/span&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e502e07a077296957dceec07cd4a86e6.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;来源：新浪财经&lt;/p&gt; 
   &lt;p&gt;其次，市场开拓不足。俗话说，好马配好鞍，我花了那么多钱砸出来的 AI 产品，第一时间肯定是想开拓稳定的 ToB 、ToG 市场对吧。但这类赛道，不仅决策期长，市场容量小，还伴随一系列的人情边际，一个招标文件就能急死一大批 AI 老板，谁能不发疯？&lt;span style=&quot;color:#8f959e&quot;&gt;（如果 AI 老板是技术出身，疯得更快！）&lt;/span&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7231daa6932eda7894adb0614c057208.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;那么，ToC 赛道呢？聊个人之常情的逻辑：有多少人用，才是 C 端市场的容积，一旦面临经济下行或消费转移，就容易引发一系列的连锁反应。同时，在如此激烈的抢人环境下，许多 AI 公司不得不采取烧钱补贴、广告曝光的策略来争夺市场份额，实际利润也就被稀释了。具体可以参考下图👇&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//f64044917f50cfd8aa22f3c81c563fee.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;这些都是沉默成本啊...&lt;/span&gt;&lt;/p&gt; 
   &lt;p&gt;并且，AI 技术并不具备任何的商业逻辑，市场上的狂热，也只能由市场去慢慢消化。笔者认为，市场之病，目前还只处于 1.0 阶段，当大批量的 AI 公司搁浅，市场上仅剩下几极之后，2.0 的 AI 市场才可能慢慢自愈。&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
   &lt;h3&gt;个体之病：AI 依赖&lt;/h3&gt; 
   &lt;p&gt;AI 作为这个时代的新质生产力，确实带给了人们很多的便利。比如，我要写这篇稿子，可以找 AI 帮我写个框架；开会要做总结，可以让 AI 帮我划重点；专业名词不了解，交给 AI ，除了得到答案，还可以得到一些拓展性回答。&lt;/p&gt; 
   &lt;p&gt;偷懒起来，简直不要太爽！但渐渐的，我发现：AI 其实只能帮助我们在短时间内提升一个领域的认知下限，对于一些专业性极强、需要实操，并伴生多种知识体系的领域（如：生命科学、国际经贸等），光是靠 AI 问问题，无异于管中窥豹。&lt;/p&gt; 
   &lt;p&gt;并且，对于普罗大众来说，目前的 AI 应用更偏重于提升效率，如 AI 搜索、AI 总结、AI 写作，越是将简单的工作交给 AI ，人们的内心预判就越不会觉得 AI 做得不好&lt;span style=&quot;color:#8f959e&quot;&gt;（但其实 AI 的出错率真的很高）&lt;/span&gt;，就越容易产生 AI 依赖。&lt;/p&gt; 
   &lt;p&gt;2024 年的最后一天，南方日报发了一篇&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fviews.ce.cn%2Fview%2Fent%2F202412%2F31%2Ft20241231_39252324.shtml&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《「AI 依赖症」怎么治》&lt;/a&gt;的文章，其中点名：&lt;strong&gt;大学生作业里充满了 AI 味，文科生快失去了原创写作的能力。&lt;/strong&gt;&lt;/p&gt; 
   &lt;p&gt;据英国高等教育政策研究所发布的调研，1250 名英国本科生中，有 53% 的学生正在使用 AI 写论文，而在使用 AI 的学生中，25% 的人用 AI 来制定论文主题，还有 5% 的学生直接承认曾直接将 AI 生成内容复制粘贴到论文中。&lt;/p&gt; 
   &lt;p&gt;「这一现象已经不是新问题了。我们曾经发现，学生的毕业论文里，有的段落的中文‘不像中文’，后来才知道，学生是将自己以前发表的英文论文用 AI 工具翻译成中文粘贴过来。」南京大学人工智能学院副院长戴新宇教授&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nju.edu.cn%2Finfo%2F1056%2F355561.htm&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;表示&lt;/a&gt;。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//274adda7135c56f171f345fae2c13060.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;百度相关问题的索引&lt;/span&gt;&lt;/p&gt; 
   &lt;p&gt;不仅如此，纯靠 AI 在职场上也混不走。&lt;/p&gt; 
   &lt;p&gt;今年 2 月，美国知名律所 Morgan &amp;amp; Morgan 向 1000 多名律师发送了紧急邮件，警告称 AI 可能生成虚假的判例信息，若律师在法律文件中使用这些虚构内容，可能会被解雇。&lt;/p&gt; 
   &lt;p&gt;不可否认，生成式 AI 技术极大地缩短了律师研究判例和撰写的时间，但 AI 也存在「编造事实」的风险。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3d07f03d8b998dd33da036d1dbb4d034.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;反观国内的医疗行业，则是在「 AI 诊疗」上频加红线，北京市衞健委明确指出：医疗机构开展互联网诊疗活动要加强药品管理，严禁使用人工智能等自动生成处方，且人工智能软件等不得冒用、代替医师本人提供诊疗服务。&lt;/p&gt; 
   &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//9176ea65b1ede419b435cec8577beed1.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
   &lt;p&gt;真是应了那句话：AI 能帮你上班，但不能帮你背锅。那么，在这个高喊 All in AI 的时代，普通人该如何相处呢？笔者总结为八个字：&lt;strong&gt;敬畏工具，保持怀疑。&lt;/strong&gt;&lt;/p&gt; 
   &lt;p&gt;AI 真的只是一个工具而已，当你在使用 AI 的同时，不妨也向 AI 学习，它的思考方式、思维广度，&lt;strong&gt;与 AI 共舞更能促进 AI 的发展&lt;/strong&gt;；其次，开篇也提到了，虽然在群体认同保持清醒很难，但保持怀疑，却很简单，不妨试试！&lt;/p&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;p&gt;AI 有病，但它并不是我们的敌人，这一点需要明确。&lt;/p&gt; 
   &lt;p&gt;之所以放在最后来说，是因为笔者在查资料的过程中，发现了很多科学家正在研究如何降低 AI 幻觉，已经有很多企业开始了 AI 商业的探索，并且身边的很多人都开始将 AI 看作是映射自身的镜子，透过 AI 这个时代产物去完善自身的缺陷。&lt;strong&gt;AI 的未来，其实就是与人类共愈的过程。&lt;/strong&gt;&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/7819858/blog/18134663</link>
            <guid isPermaLink="false">https://my.oschina.net/u/7819858/blog/18134663</guid>
            <pubDate>Thu, 03 Apr 2025 10:10:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>n8n 完成 5500 万欧元 B 轮融资</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;n8n 是一个开源的、可扩展的工作流程自动化工具，它提供了直观的界面，让用户可以通过拖放方式连接不同的应用程序和服务，从而创建自定义的自动化流程。&lt;/p&gt; 
&lt;p&gt;n8n 支持 400+ 应用和服务集成，包括各种常见的应用程序和服务，如 Google、Slack、GitHub、Trello 等。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ab937377604fdb12632fa6217cf05240f21.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;近日，n8n 开发商&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.n8n.io%2Fseries-b%2F&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;获得了由 Highland Europe 领投的 5500 万欧元 B 轮融资，HV Capital 和之前的投资者 Sequoia、Felicis 和 Harpoon 也参与了此次投资。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bd5bf1ab0789036ab84de20679b181c6475.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;n8n 创始人兼首席执行官 Jan Oberhauser 表示：「自动化不应是一个黑匣子——企业需要透明度、定制化和成本效益。通过 n8n，我们构建的不仅仅是一个平台；我们还建立了一个热爱我们并信赖我们的社区。从个人贡献者到全球企业，n8n 让每个人都拥有 10 倍开发者的能力，这在人工智能在职场爆炸式增长的今天至关重要。」&lt;/p&gt; 
&lt;p&gt;过去一年，n8n 经历了一年的爆炸式增长，去年活跃用户已超过 20 万，年度经常性收入 (ARR) 增长了 5 倍。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344033/n8n-series-b</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344033/n8n-series-b</guid>
            <pubDate>Thu, 03 Apr 2025 10:03:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>声称 AI 技术实为人工操作，AI 购物应用创始人被控欺诈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;ai-shopping-app-powered-by-humans&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;美国司法部周三发布的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.justice.gov%2Fusao-sdny%2Fpr%2Ftech-ceo-charged-artificial-intelligence-investment-fraud-scheme&quot; target=&quot;_blank&quot;&gt;新闻稿&lt;/a&gt;指出，声称提供&quot;通用&quot;结账体验的 AI 购物应用 Nate 的创始人兼前 CEO Albert Saniger 被指控欺诈投资者。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Nate 成立于 2018 年，曾从 Coatue 和 Forerunner Ventures 等机构筹集超过 5000 万美元资金，包括 2021 年由 Renegade Partners 领投的 3800 万美元 A 轮融资。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;该公司声称其应用程序凭借 AI 技术，允许用户一键在任何电商网站完成购物。但美国司法部纽约南区法院指控称，Nate 实际上严重依赖菲律宾呼叫中心数百名人工承包商手动完成这些交易。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;236&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5209b5913251e9a302ce20b65b82a278e0d.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Saniger 声称 Nate 能够「无需人工干预」地进行在线交易（除非出现 AI 无法完成交易的极端情况），从而筹集了数百万美元的风险投资。然而，美国司法部调查发现，尽管 Nate 获得了一些 AI 技术并聘请了数据科学家，但其应用程序的实际自动化率实际上为 0%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Saniger&amp;nbsp;没有回应置评请求。他目前是纽约风险投资公司 Buttercore Partners 的执行合伙人，该公司也没有回应置评请求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Nate 大量使用人类承包商的行为曾在 2022 年成为 The Information 调查的对象。根据起诉书，Nate 公司于 2023 年 1 月资金耗尽，被迫出售资产，导致投资者&quot;几乎全部&quot;损失。Saniger&amp;nbsp;的领英资料显示，他自 2023 年起不再担任 CEO。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Nate 并非唯一一家涉嫌夸大 AI 能力的创业公司。报道称，一家菲律宾&quot;AI&quot;免下车软件创业公司以及 AI 法律科技独角兽 EvenUp 也被曝主要依靠人工完成大部分工作。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344028</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344028</guid>
            <pubDate>Thu, 03 Apr 2025 09:41:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>欧盟披露投建 13 家 AI 超级工厂细节</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;欧洲联盟披露兴建人工智能（AI）超级工厂计划细节。这一计划将耗资 200 亿欧元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;欧盟委员会 9 日发布「人工智能大陆行动计划」。这一委员会负责技术主权等事务的执行副主席汉娜·维尔库宁在声明中说，在使欧洲更具竞争力、更安全并拥有更多技术主权方面，AI 技术处于核心地位，「全球 AI 竞赛远未结束」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;英国《衞报》9 日报道，欧盟已着手落实一项计划，建设 13 家 AI 超级工厂。超级工厂内设超级计算机和数据中心。欧盟委员会主席乌尔苏拉·冯德莱恩 2 月 11 日在法国首都巴黎举行的 AI 行动峰会上宣布「投资 AI」倡议，旨在调动 2000 亿欧元投资，以推动 AI 发展。根据这一倡议，欧盟将专门设立 200 亿欧元基金用于建设欧洲 AI 超级工厂。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据「人工智能大陆行动计划」，欧盟性能最佳的几家 AI 超级工厂的超级计算机将搭载多达 2.5 万枚高端 AI 处理器。每家超级工厂的高端 AI 处理器数量将超过 10 万枚。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;《衞报》援引欧盟一名高级官员的话报道说，这些 AI 超级工厂所使用液冷技术将「尽可能」由绿色电力支持，同时计划「循环使用」水资源。报道提供的数据显示，欧盟去年 47% 的电力来自可再生能源。一些环保人士担心，数据中心耗能巨大，可能动摇欧盟在环保方面设立的目标。（卜晓明，新华社微特稿&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344018</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344018</guid>
            <pubDate>Thu, 03 Apr 2025 09:13:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Wisdom SSH，运维人的 「Cursor」，部署 Jenkins 详细使用教程</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;运维工作事儿多且杂，从服务器日常维护到故障修复，都得小心翼翼。对运维人来说，一款好工具特别重要。编程人员有 Cursor 帮忙，咱们运维人也有类似的，就是 Wisdom SSH，它能让运维变得轻松&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;Wisdom SSH 作为一款集成 AI 的现代化 SSH 终端工具，能极大简化 Jenkins 的部署流程。以下将为你逐步介绍如何使用 Wisdom SSH 完成 Jenkins 的部署。&lt;/p&gt; 
&lt;h2&gt;一、准备工作&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;下载与安装 Wisdom SSH&lt;/strong&gt;：打开浏览器，在地址栏输入官网地址&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fssh.wisdomheart.cn%2F&quot; target=&quot;_blank&quot;&gt;ssh.wisdomheart.cn&lt;/a&gt;，进入 Wisdom SSH 官网。按照网页上清晰的提示，下载 Wisdom SSH 的安装包，并完成安装。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;确保服务器具备基本条件&lt;/strong&gt;：目标服务器需拥有合适的操作系统（如常见的 Linux 发行版，如 Ubuntu、CentOS 等），并且具备网络连接以及必要的权限（通常需要 root 或具有 sudo 权限的用户）。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;二、启动 Wisdom SSH 并连接服务器&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;启动 Wisdom SSH&lt;/strong&gt;：安装完成后，在应用列表中找到 Wisdom SSH 并启动它。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;添加服务器连接&lt;/strong&gt;：在 Wisdom SSH 界面中，找到添加服务器连接的按钮。点击后，填写服务器的相关信息，包括服务器 IP 地址、用户名以及对应的密码（若使用密钥认证，需正确配置密钥文件路径等信息）。填写完成后，点击服务器会话，建立与目标服务器的连接。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;867&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-95c5ba928b9d0adc959aac67afa7ab30895.png&quot; width=&quot;1544&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;三、通过 Wisdom SSH 部署 Jenkins&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;进入 AI 助手对话区&lt;/strong&gt;：成功连接服务器后，在 Wisdom SSH 界面右侧是 AI 助手对话区，它类似于我们日常使用的聊天窗口。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;提出部署需求&lt;/strong&gt;：在 AI 助手对话区输入：「部署 Jenkins」。输入完成后，按下回车键发送指令。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;872&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-4ec714f781b89acba3d5a0acbc8a2098793.png&quot; width=&quot;1544&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;添加 Jenkins 官方软件源&lt;/strong&gt;：Wisdom SSH 的 AI 会根据服务器的操作系统类型，生成相应的部署步骤和命令。首先，AI 会进行添加 Jenkins 官方软件源的步骤。以 Debian 或 Ubuntu 系统为例，给出以下操作： 
  &lt;ul&gt; 
   &lt;li&gt;执行命令：&lt;code&gt;wget -q -O - https://pkg.jenkins.io/debian - stable/jenkins.io.key | sudo apt - key add -&lt;/code&gt;，此命令用于下载并添加 Jenkins 软件源的 GPG 密钥，以确保软件源的安全性和可靠性。执行命令后等待其完成。&lt;/li&gt; 
   &lt;li&gt;执行命令：&lt;code&gt;sudo sh - c &#39;echo deb https://pkg.jenkins.io/debian - stable binary/ &amp;gt; /etc/apt/sources.list.d/jenkins.list&#39;&lt;/code&gt;，该命令将 Jenkins 软件源信息添加到系统的软件源列表文件中。&lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;img height=&quot;872&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3820df02fa347e71e91b8e76fdd583909c8.png&quot; width=&quot;1543&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;执行安装 Java 步骤&lt;/strong&gt;：接下来提示安装 Java，因为 Jenkins 运行依赖 Java 环境。例如，若服务器是基于 Debian 或 Ubuntu 系统，AI 给出如下命令及提示： 
  &lt;ul&gt; 
   &lt;li&gt;执行命令：&lt;code&gt;sudo apt update&lt;/code&gt;，此命令用于更新系统软件包列表，确保获取到最新的软件信息。输入命令后，按下回车键执行。由于我们演示服务器是 root 账号，直接使用「AI 执行」，如果你使用过程中需要输入密码，请选择「终端执行」。&lt;/li&gt; 
   &lt;li&gt;执行命令：&lt;code&gt;sudo apt install openjdk-17-jre&lt;/code&gt;，此命令用于安装 OpenJDK 开发工具包。按下回车键执行。等待安装完成，这可能需要一些时间，取决于服务器的网络速度和性能。&lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;img height=&quot;843&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-71ee1d51679ffc3b819540bce028c4d4047.png&quot; width=&quot;1545&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;安装 Jenkins&lt;/strong&gt;：以上步骤执行成功后，AI 会引导你安装 Jenkins。执行命令：&lt;code&gt;sudo apt install jenkins&lt;/code&gt;，开始安装 Jenkins 然后等待安装完成。 &lt;p&gt;&lt;img height=&quot;868&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-66523a0a545e0dd1310d2b06ef66e832aca.png&quot; width=&quot;1545&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;启动 Jenkins 服务&lt;/strong&gt;：Jenkins 安装完成后，接下来需要启动 Jenkins 服务，使其能够正常运行。执行命令：&lt;code&gt;sudo systemctl start jenkins &amp;amp;&amp;amp;&amp;nbsp;sudo systemctl enable jenkins&lt;/code&gt; &lt;p&gt;启动 Jenkins 服务并启用 Jenkins 开机自动启动，再执行命令：&lt;code&gt;sudo systemctl status jenkins&lt;/code&gt;&amp;nbsp;检查服务状态。&lt;/p&gt; &lt;p&gt;&lt;img height=&quot;870&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-03d64b46dca6518622efca2f3b0c003f09c.png&quot; width=&quot;1545&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;四、Jenkins 初始配置&lt;/h2&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;获取初始管理员密码&lt;/strong&gt;：Jenkins 首次启动后，需要获取初始管理员密码进行首次登录配置。此处，AI 自动获取并给出获取密码，复制该密码备用。 &lt;p&gt;&lt;img height=&quot;871&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-62dad16418acc85cd8047de90df71863160.png&quot; width=&quot;1545&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;访问 Jenkins 初始配置页面&lt;/strong&gt;：打开本地浏览器，在地址栏输入 「http:// 服务器 IP 地址：8080」。在打开的页面中，输入刚才复制的初始管理员密码，然后点击 「继续」 按钮。 &lt;p&gt;&lt;img height=&quot;870&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-df72edfcf3e31ee8585819dfadb0e9f3c5c.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;安装推荐插件&lt;/strong&gt;：接下来的页面会提示安装插件，选择 「安装推荐的插件」 选项，Jenkins 会自动下载并安装一系列常用插件，这一过程可能需要一些时间，耐心等待直到插件安装完成。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;870&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3d65ebd5090d6cd495a1d00b4a95f36f232.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;873&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-745d4f2e66b484957ca2ff48b6445967fac.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;871&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7acd11759353ae9cc8abcde930a65f7515c.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;创建管理员用户&lt;/strong&gt;：插件安装完成后，会进入创建管理员用户页面。按照页面提示，填写用户名、密码、邮箱等信息，完成后点击 「保存并完成」 按钮。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;870&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-fa6a4ea3ae174f69cfb09fe27272abf94f3.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;完成配置&lt;/strong&gt;：最后，点击 「开始使用 Jenkins」 按钮，至此 Jenkins 的部署和初始配置全部完成。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;img height=&quot;867&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-eddd5c0918490edf1ac6f2ea469bf6b9c85.png&quot; width=&quot;1547&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt;
 通过以上详细步骤，使用 Wisdom SSH 你可以轻松完成 Jenkins 的部署及初始配置工作，即使是对部署流程不太熟悉的用户也能顺利操作。我们的官网有详细的软件使用视频教程，欢迎大家前来下载体验。
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/344013</link>
            <guid isPermaLink="false">https://www.oschina.net/news/344013</guid>
            <pubDate>Thu, 03 Apr 2025 09:06:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>mcp-agent —— 专门为 MCP 构建的 AI 框架</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;mcp-agent&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://modelcontextprotocol.io/introduction&quot;&gt;是一个使用模型上下文协议&lt;/a&gt;构建代理的简单、可组合的框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;灵感&lt;/strong&gt;：Anthropic 为 AI 应用程序开发人员宣布了两项基础更新：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anthropic.com/news/model-context-protocol&quot;&gt;模型上下文协议&lt;/a&gt;- 一种标准化接口，允许任何软件通过 MCP 服务器被 AI 助手访问。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anthropic.com/research/building-effective-agents&quot;&gt;构建有效代理&lt;/a&gt;- 关于构建可用于生产的 AI 代理的简单、可组合模式的开创性文章。&lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;mcp-agent&lt;/code&gt;将这两个基础部分放入 AI 应用框架中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;它负责管理 MCP 服务器连接生命周期的繁琐工作，这样你就不必再处理了。&lt;/li&gt;
&lt;li&gt;它实现了「构建有效代理」中描述的每个模式，并且以可组合的方式实现，允许你将这些模式链接在一起。&lt;/li&gt;
&lt;li&gt;&lt;strong style=&quot;color:#1f2328&quot;&gt;Bonus&lt;/strong&gt;：它以与模型无关的方式实现了&lt;a href=&quot;https://github.com/openai/swarm&quot;&gt;OpenAI 的 Swarm 模式，用于多智能体编排。&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总而言之，这是构建强大代理应用程序最简单、最轻松的方法。与 MCP 非常相似，该项目处于早期开发阶段。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前已经有太多的 AI 框架了。但是，&lt;code&gt;mcp-agent&lt;/code&gt;它是唯一一个专门为共享协议（&lt;a href=&quot;https://modelcontextprotocol.io/introduction&quot;&gt;MCP）&lt;/a&gt;构建的框架。它也是最轻量的，并且更接近于代理模式库而不是框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align:start&quot;&gt;随着&lt;a href=&quot;https://github.com/punkpeye/awesome-mcp-servers&quot;&gt;越来越多的服务变得能够感知 MCP&lt;/a&gt;，你可以使用 mcp-agent 构建强大且可控的 AI 代理，以便开箱即用地利用这些服务。&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/mcp-agent</link>
            <guid isPermaLink="false">https://www.oschina.net/p/mcp-agent</guid>
            <pubDate>Thu, 03 Apr 2025 08:50:00 GMT</pubDate>
        </item>
        <item>
            <title>LinkedIn 数据：全球 AI 人才最集中的十个国家，以色列居首</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据 LinkedIn&amp;nbsp;最新发布的数据，全球范围内对于人工智能（AI）人才的需求正迅速上升。为了应对这一挑战，许多国家正在积极培养和吸引 AI 人才。LinkedIn 通过其 「AI 人才集中度」 指标，分析了不同国家的 AI 人才供应情况，以下是 2024 年 AI 人才浓度最高的十个国家。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;首先，以色列在 2024 年的数据显示，其 AI 人才占到全国劳动力的 1.98%，位居全球第一。紧随其后的是新加坡，其 AI 人才的比例为 1.64%。卢森堡位列第三，AI 人才比例为 1.44%。此外，爱沙尼亚、瑞士、芬兰、爱尔兰、德国、荷兰和韩国分别占据第四至第十位，人才比例从 1.17% 到 1.06% 不等。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;值得注意的是，这些国家通常在地理和人口规模上相对较小，但在 AI 人才的培养和发展上却表现不俗。这些国家建立了良好的生态系统，企业对员工技能发展的投资以及政府促进持续学习的政策，都为 AI 人才的培养提供了有力支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;LinkedIn 亚太地区首席经济学家蔡佩盈指出，虽然印度未能进入前十名，但在 2016 年至 2024 年间，该国的 AI 人才浓度增加了 252%。这一数据表明，印度的专业人士正积极提升他们的 AI 技能。此外，2024 年，印度的 AI 招聘需求同比增长了 33.4%，高于新加坡的 25% 和美国的 24.7%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;新加坡在 AI 人才培养方面的竞争力也不容忽视，蔡佩盈提到，新加坡的文化强调学习，专业人士在 AI 技能学习上花费的时间比亚太其他国家高出 40%。随着 AI 技术的迅速发展，企业和个人对于 AI 技能的需求只会进一步上升。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;具体排名如下:&lt;/span&gt;&lt;/p&gt; 
&lt;ol style=&quot;margin-left:0; margin-right:0&quot;&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;以色列 （1.98%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;新加坡 （1.64%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;卢森堡 （1.44%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;爱沙尼亚 （1.17%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;瑞士 （1.16%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;芬兰 （1.13%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;爱尔兰 （1.11%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;德国 （1.09%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;荷兰 （1.07%）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;韩国 （1.06%）&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343985</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343985</guid>
            <pubDate>Thu, 03 Apr 2025 07:39:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>vivo Trace 监控追求极致的建设历程</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互联网服务器团队- Zhang Yi 当前 vivo 的应用监控产品 Vtrace 经常遇到用户反馈某个 Trace 链路信息没法给他们提供到实质的帮肋，对此团队一直在持续完善 JavaAgent 的采集。经过不断增加各类插件的支持，同时想方设法去补全链路信息，但一直还是无法让用户满意。面对这样的困境，需要改变思路，从用户角度思考，在产品中找灵感。同时产品重新思考在应用监控中一条完整的 Trace 应该展现给用户哪些信息？业界其它产品对 Trace 的监控可以观测到什么程度？带着这些问题，Vtrace 通过全面的同类产品对比分析，结合 vivo 实际情况自研 Profile 采集，从而开启涅槃之路。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;专业术语&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;【Vtrace】：vivo 应用监控系统，是一款 vivo 自研应用性能监控产品。&lt;/p&gt; 
&lt;p&gt;【Trace】：通常用于表示一系列相关的操作或事件，这些操作或事件通常跨越多个组件或服务，一个 Trace 可能由多个 Span 组成。&lt;/p&gt; 
&lt;p&gt;【Span】：属于 Trace 中的一个小部分，表示某个特定操作的时间跨度，比如执行一次查询 SQL 的记录。&lt;/p&gt; 
&lt;p&gt;【APM】：APM 为 Application Performance Monitoring 的缩写，意为应用性能监控。&lt;/p&gt; 
&lt;p&gt;【POC】：通常指的是 &quot;Proof of Concept&quot;，即概念验证。在软件开发和信息技术领域，POC 是指为了验证某项技术、方法或想法的可行性而进行的实验或测试。在监控领域，一个监控 POC 通常指的是为了验证某个监控方案、工具或系统的可行性而进行的验证。&lt;/p&gt; 
&lt;p&gt;【Continuous Profiling】：持续剖析，有些厂商叫 Continuing Profile 或 Profiler，也有人将 Continuous Profiling 和 Trace、Metric、Log 放在同一位置。总之是一种持续性的性能分析技术，它可以实时监测和记录程序的性能数据，以便开发人员可以随时了解程序的性能状况。这种技术可以帮助开发人员发现程序中的性能瓶颈和优化机会，从而改进程序的性能。通过持续性地监测程序的性能数据，开发人员可以更好地了解程序的行为和性能特征，从而更好地优化程序的性能。本文中 Profile 一般指持续剖析。&lt;/p&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p&gt;当前应用监控产品 Vtrace 中的 Trace 链路数据只串联了服务与服务，服务与组件之间的 Span 信息，但对于发生于服务内部方法具体执行耗时是无法监控的，即所谓监控盲区。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4c7a7b1ad6ce8a821ec366d7d610cee0.jpeg&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 1&lt;/p&gt; 
&lt;p&gt;图 1 为当前 Vtrace 系统的一个 Trace 信息，这个 Trace 显示内部没有任何其它组件，事实上真的如此么？先看看下面实际代码：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@GetMapping(&quot;/profile/test&quot;)
public String testProfile() {
        try {
            //执行 sleep 方法
            doSleep();
            //执行查询 MySQL，但方法使用 synchronized 修饰，多线程的时候会塞阻，同时查询 SQL 时一般会先获取数据库链接池
            synchronizedBlockBySelectMysql();
            //读取文件数据，并且将数据序列化转 JSON
            readFileAndToJson();
            //发送数据到 kafka
            sendKafka();
            return InetAddress.getLocalHost().getHostAddress();
        } catch (Exception e) {
            log.error(&quot;testProfile {}&quot;, e.getStackTrace());
        }
        return &quot;&quot;;
    }
    private void doSleep() throws InterruptedException {
        Thread.sleep(1000);
    }
    private synchronized void synchronizedBlockBySelectMysql() {
        profileMapper.selectProfile();
    }
    private void readFileAndToJson() throws InterruptedException {
        String fileName = VivoConfigManager.getString(&quot;profile.test.doc.path&quot;,&quot;D:\\json1.json&quot;);
        StringBuilder builder = new StringBuilder();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), &quot;UTF-8&quot;))) {
            String line;
            while ((line = br.readLine()) != null) {
                builder.append(line);
            }
            br.close();
            JSONArray jsonArray = JSON.parseArray(builder.toString());
        } catch (Exception e) {
            log.error(&quot;testProfile {}&quot;, e.getStackTrace());
        }
    }
    private void sendKafka() {
        for (int i = 0; i &amp;lt; 5; i++) {
            kafkaTemplate.send(topic, &quot;{\&quot;metricName\&quot;:\&quot;java.profile.test\&quot;,\&quot;id\&quot;:1,\&quot;isCollect\&quot;:false}&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;从上面的代码可以看出接口/profile/test 的 profileTest 方法实际执行了四个私有方法：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;doSleep() 方法，让程序休眠 1 秒&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;synchronizedBlockBySelectMysql 方法查询 MySQL，但这个方法使用了 synchronized 修饰，多线程同时执行这个方法时会塞阻。另外查询 MYSQL 一般会使用连接池，这次测试的代码使用 Hikari 连接池&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;readFileAndToJson 方法读取文件数据并且将数据转 JSON 为 JSONArray&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;sendKafka 方法主要是发送数据到 Kafka&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;但这四个方法在 Vtrace 系统中的 Trace 信息中什么都体现不了，JavaAgent 并没有采集到相关信息。这恰好说明了这里存在监控盲区，并且盲区远比想象中的要大，某些场景中连最基本的 MySQL 执行的信息都看不到。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cc9f8e18d9fca3274ba38ce153a13d1d.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 2&lt;/p&gt; 
&lt;p&gt;对于图 1 那种情况在实际中会经常遇到，用户会发现 Trace 中没有他想要的信息。有时会像图 2 中那样有几个组件的 Span，但整个 Trace 中依然存在一大片空白的地方，不知道具体的代码执行情况。&lt;/p&gt; 
&lt;p&gt;针对上述的场景，为了让用户通过 Trace 获取更多有用信息，后续需要做的有两件事：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持对更多组件的埋点采集&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;针对 Trace 进行方法调用栈的采集&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;而本文主要从下面几个角度论述我们如何改变当前 Vtrace 的&lt;strong&gt;现状&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;同类产品对比分析&lt;/strong&gt;：通过 SkyWalking、DataDog 和 Dynatrace 三款产品的 Trace 观测程度对比分析，从产品的视角去获得 Vtrace 的优化思路。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;程序设计&lt;/strong&gt;：通过同类的产品功能引入行业中 Continuous Profiling 概念，结合同类产品的技术实现情况设计 Vtrace JavaAgent 对方法调用栈采集的技术方案。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;压测分析&lt;/strong&gt;：针对在 JavaAgent 增加方法调用栈采集之后进行压测，评估出 JavaAgent 改进后的资源影响，并且分析出资源消耗增加的根因与确定后续持续优化的方向。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;落地评估&lt;/strong&gt;：通过当前已经接入 Vtrace 产品的服务情况与 JavaAgent 压测结果去分析 Vtrace 的方法调用栈采集功能如何落地。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;二、同类产品对比分析&lt;/h1&gt; 
&lt;p&gt;在设计 JavaAgent 方法调用栈监控采集前，先看看业界的监控同类产品对 Trace 的分析能够做到何种程度。&lt;/p&gt; 
&lt;p&gt;下面我们使用 SkyWalking、DataDag 和 Dynatrace 三款同类产品，对上面/profile/test 接口进行监控分析。通过对同类产品监控情况的分析会给我们带来一些启发，同类产品的一些优秀设计思路也会有助于我们完善的 Vtrace 产品。&lt;/p&gt; 
&lt;h2&gt;2.1 Apache SkyWalking&lt;/h2&gt; 
&lt;p&gt;Apache SkyWalking 是一款优秀的开源应用性能监控产品，Vtrace 的 JavaAgent 就是基于早期的 SkyWalking 3.X 版本开发的。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4c2577fa43c8badf1f3efbff06947497.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 3&lt;/p&gt; 
&lt;p&gt;上图为/profile/test 接口在 SkyWalking 的 trace 信息，显然可以看出请求中访问 MySQL 与 Kafka，其中 SQL 的执行时间大约为 2 秒（图 3 中的 MySQL/JDBC/PrepardStatement/execute 为实际执行 SQL 的 Span）。同时使用 Hikari 链接池工具获取数据库链接的信息也记录了，这个记录很有用，如果数据库链接池满了，一些线程可能一直在等待数据库链接池释放，在某些情况下很可能是用户数据库链接池配置少了。&lt;/p&gt; 
&lt;p&gt;相对于 Vtrace 系统的 trace 信息，显然 SkyWalking 观测能力强了不少，但依然存在 doSleep 与 readFileAndToJson 这两个方法没有观测到。&lt;/p&gt; 
&lt;p&gt;对于这种情况，想到了 SkyWalking 的性能剖析功能，那再利用性能剖析看看能不能分析出 doSleep 与 readFileAndToJson 这两个方法。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a8a7d80f7b937d1a7c1ac04d274cbfdd.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 4&lt;/p&gt; 
&lt;p&gt;图 4 是 SkyWalking 对/profile/test 接口配置性能剖析的交互，这里可以配置端点名称、监控的持续时间，监控间隔以及采集的最大样本数。而监控间隔配置的越小采集到的数据会越精确，同时对服务端的性能影响则越大。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//63efbae0613613fdfef2ce250bba78ff.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 5&lt;/p&gt; 
&lt;p&gt;配置好性能剖析规则后，再次发出/profile/test 请求。等待了一段时间，从图 5 中可以看到 doSleep 和 synchronizedBlockBySelectMysql 方法的执行情况。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//11284b6536a13866c4a7654fa8e4ee74.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 6&lt;/p&gt; 
&lt;p&gt;关于 synchronizedBlockBySelectMysql 方法的，如果是执行 sql 耗时，采集到的应该如图 6 左侧那样看到的是正在执行 SQL 的 socketRead0 方法，而这里显示的是 synchronizedBlockBySelectMysql 这个代码块，即性能剖析时 SkyWalking 采集到的数据方法栈的栈项为&lt;/p&gt; 
&lt;p&gt;synchronizedBlockBySelectMysql，这里由于 synchronized 的修饰在执行 SQL 前需要等待别的线程释放整个方法块。&lt;/p&gt; 
&lt;p&gt;从上述可以看出 SkyWalking 显然对 profileTest 方法能很有效地分析，但存在一个问题就是性能剖析不能自动持续分析，需要用户手动开启，遇到难以复现的情况时不好回溯分析。&lt;/p&gt; 
&lt;p&gt;虽然 SkyWalking 持续剖析存在这一点小瑕疵，但我们不得不承认 Skywalking 对 Trace 的分析还是挺强大的。Vtrace 的 JavaAgent 是在 SkyWalking3.X 版本的基础上实现的，而 SkyWalking 成为 Apache 项目后经过这几年的持续迭代已经发展到 10.X 版本了。对比我们 Vtrace JavaAgent，显然 SkyWalking 的进步巨大。&lt;/p&gt; 
&lt;h2&gt;2.2 DataDog&lt;/h2&gt; 
&lt;p&gt;与开源的 SkyWalking 不同，DataDog 是一款商用可观测软件，在 Gartner 可观测排名靠前。接下来我们使用 DataDog 去分析刚才的/profile/test 接口。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6513d7294cd3f3f87ab9ad47c4dfb4dd.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 7&lt;/p&gt; 
&lt;p&gt;图 7 是使用 DataDog 采集到/profile/test 接口 Trace 数据，明显可以看出：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;MySQL 组件与 Kafka 组件的执行耗时&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;整个 Trace 的 Safepoint 和 GC 占用时间&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//f35318bc5ddab45f75cb0ded1258da2b.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 8&lt;/p&gt; 
&lt;p&gt;图 8 为本次 trace 的火焰图，从图中可以看到 readFileAndTojson 这个方法热点。&lt;/p&gt; 
&lt;p&gt;从 DataDog 的 Trace 信息中我们可以看出 DataDog 也能直接发现 MySQL 与 kafka 组件，同时提供这次 trace 的火焰图，从火焰图中能够看出 readFileAndTojson 方法执行。但 doSleep 方法与 synchronizedBlockBySelectMysql 方法关键字 synchronized 同步等待的时间没被观测到。&lt;/p&gt; 
&lt;p&gt;不过感觉到意外的是可以在 DataDog 中看到这次 trace 的 Safepoint 和 GC 占用时间，这样用户可以分析出该 Trace 是否受到 Safepoint 和 GC 影响。&lt;/p&gt; 
&lt;h2&gt;2.3 Dynatrace&lt;/h2&gt; 
&lt;p&gt;Dynatrace 也是一款商用可观测产品，Gartner 可观测排名常年第一，技术上遥遥领先。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//bf8e1c9dd06d47abd0cc8e75cda1ddbb.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 9&lt;/p&gt; 
&lt;p&gt;图 9 为/profile/test 接口在 Dyantrace 中的一个 Trace 信息，图中左侧红框可以直接看到 MySQL 和 Kafka 组件，中间红框是这次 trace 的线程整体时间分布情况，包括 CPU 时间，Suspension 挂起时间，还有 Waiting、Locking、Disk I/O 和网络 I/O ，为了方便大家理解深层的性能特征他们用不同的颜色区分，具体说明如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//43c28f7b990659badfdb71a12679849f.jpeg&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 1&lt;/p&gt; 
&lt;p&gt;从图 9 右边红色框框的可以看到这个 Trace 整个生命周期的线程各个阶段的分布，再点击&quot;View method hotspots&quot;，则本次 trace 的方法热点如下图图 10 所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//d5e9faf3ad33a8c49510192a69f38db7.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 10&lt;/p&gt; 
&lt;p&gt;看到图 10 的内容非常惊讶，源代码中的四个私有方法全部被观测到，四个方法底层的实质也显露出来，具体如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;发现 doSleep 与 sendKafka 这两个方法，并且他们的操作主要是在 Waiting。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;synchronizedBlockBySelectMysql 方法图中浅蓝色部分显示他在 Locking，等待着别的线程执行完 synchronized 修饰的方法；后半段粉色部分为查询 MySQL 的 IO 操作，细分为 Network I/O。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;readFileAndToJson 方法中有一段紫色的部分 ，那是在读取文件的 IO 操作，分类为 Disk I/O，而同时读取文件与将文件中的内容转换为 JSON 也是这次 Trace 消耗 CPU 的主要代码。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;上面除了整个 Trace 的方法热点的总览信息，还可以下钻进入每个方法再深度分析。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//fb4d2666178fa5a3004591c669fa4049.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 11&lt;/p&gt; 
&lt;p&gt;图 11 是展开 doSleep 与 sendKafka 两个 Waiting 方法分析，可以明显看出 doSleep 方法实际上底层耗费在 Thread.sleep，而 sendKafka 方法的 Waiting 是 Kafka 底层工具类 SystimeTime.waitObject 中执行更底层的 Object.wait。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6010e8d1d570b94e0b0b948c520b0121.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 12&lt;/p&gt; 
&lt;p&gt;图 12 为选定&quot;Code execution&quot;后再展开 readFileAndToJson 方法，这里两处主要耗费 CPU 的操作，一个是 JSON.parseArray，一个是 BufferedReader.readLine。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//ae2e88691bf36ae469ecb902350533d7.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 13&lt;/p&gt; 
&lt;p&gt;除了方法热点分析，Dynatrace 还提供了&quot;Code level&quot;的分析，从图 13 中可看到 Hikari 链接池的获取情况。&lt;/p&gt; 
&lt;p&gt;从结果上来看，Dynatrace 的观测能力果然遥遥领先，他的观测能力不是仅仅简单告诉用户每个地方的执行耗时，他告诉用户代码执行情况的同时让用户更好地了解程序每个行为的底层原理和性能特征。&lt;/p&gt; 
&lt;h2&gt;2.4 分析总结&lt;/h2&gt; 
&lt;p&gt;在完成上述三个产品的 Trace 分析后，结合当前 Vtrace 产品，做了一些对比：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//788f6888df5ebcec9ed539eba9fdac11.jpeg&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 2&lt;/p&gt; 
&lt;p&gt;通过同类产品对比分析发现当前 Vtrace 整体功能与业界领先的产品比较显得相对落后。另外，业界优秀的产品还有很多，而我们选择 SkyWalking、DataDog 和 Dynatrace 因为他们具有一定的典型性和代表性。而对于上述的三款产品，本文产品分析只是针对 Trace 链路的观测能力来测试来比较。&lt;/p&gt; 
&lt;p&gt;最初在考虑如何完善我们的 Trace 链路，我们的计划是参考新版 SkyWalking 的 Profile 功能，所以当时的同类产品分析只选 SkyWalking，而/profile/test 接口的四个私有方法也是提前就设计好的。&lt;/p&gt; 
&lt;p&gt;但在做设计评审时，发现只基于一个开源产品的能力去设计，最后可能得出的方案会是片面的。考虑到不同产品的 Trace 信息呈现会有所不同，于是我们决定再找一些同类的商用产品来对比分析。而同类产品 Trace 呈现出来的信息涉及数据采集，我们需要分析产品能力的同时也要去了解同行的采集技术方案。&lt;/p&gt; 
&lt;p&gt;因为曾经主导过一个可观测项目，邀请了国内外的主要 APM 厂商来企业内部私有化部署产品，用了长达半年多的时间对大概 10 款产品进行 POC 测试，大部分产品的 Trace 信息展示是差不多的，而当时很多产品的 Trace 观测能力并不比现在的 SkyWalking 会好。同时，简单看了当前一些国内大厂可观测产品 Trace 的交互后，为了避免同质化，便选择了当时 POC 没法私有化部署的 DataDog 与 POC 测试时效果远超同行的 Dynatrace。&lt;/p&gt; 
&lt;p&gt;由于/profile/test 接口的四个私有方法是在 SkyWalking 测试前就已经设计好的，所以在要把 DataDog 和 Dynatrace 加入测试时并不知道这两款产品会呈现出什么样的实际效果。现在都知道 DataDog 和 Dynatrace 的测试结果，这两个产品的 Trace 中都有出乎意料的重要信息，这带给我们不少启发。&lt;/p&gt; 
&lt;p&gt;本节最后说些题外话，相信国内很多大厂都有自己的可观测产品或者正在使用一些其它厂商可观测产品，你们可以将/profile/test 接口的代码用你们现在使用的监控产品测试一下，看看你们的 Trace 能观测到什么，如果有一些意外的发现，不防联系我们，大家一起相互学习学习。&lt;/p&gt; 
&lt;h1&gt;三、程序设计&lt;/h1&gt; 
&lt;p&gt;通过同类产品的对比分析，为了让我们的 Trace 信息更完整，第一件事是需要完善组件。同时同类产品可以观测到更多有用的信息，所以第二件事我们需要知道这些信息同类产品是如何采集的。另外也不能只顾着单一完善 Trace 信息而设计 ，设计上需要考虑后续的整体规划。&lt;/p&gt; 
&lt;p&gt;随着对同类产品的深入了解知道同类产品使用了一种叫 Continuous Profiling 技术手段，通过这种手段他们才有如此丰富 Trace 信息。比如 DataDog 的火焰图和 Dynatrace 的方法热点正是这技术手段的体现。同时在他们产品中 Continuous Profiling 有明确的定位，常见有下面四个功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;CPU Profiling&lt;/strong&gt;：深入了解进程的方法热点，按代码执行、网络 I/O、磁盘 I/O、锁定时间和等待时间分解和过滤数据，常见的火焰图正是 CPU Profiling 的产品体现。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Memory Profiling&lt;/strong&gt;：内存分析可以了解应用程序随时间变化的内存分配和垃圾回收行为，识别分配了最多内存的上下文中的方法调用，并将此信息与分配的对象数量相结合。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Memory Dump Aalysis&lt;/strong&gt;：通过进程的内存使用进行 dump 并分析。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Continuous Thread Analysis&lt;/strong&gt;：对线程持续分析，主要是后台线程组，记录每个线程各个时间段的线程状态以及资源使用情况。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;不难看出上述功能在很多同类产品都有，比如 Vtrace 现在利用 Vivo 运维工具实现了 CPU Profiling、Memory Profiling 以及 Memory Dump Analysis。但是 Vtrace 的 CPU Profiling 与 Memory Profiling 并不是持续的，需要用户手动触发，每次最多只能剖析 5 分钟。后续我们会慢慢实现或优化 Continuous Profiling 的各个功能，而现在 Vtrace 系统是借助 CPU Profiling 的技术手段去完善每个 Trace 的方法调用栈信息。&lt;/p&gt; 
&lt;h2&gt;3.1 方案选择&lt;/h2&gt; 
&lt;p&gt;在分析 SkyWalking、DataDog 和 Dynatrace 是如何实现他们的 Profile 信息采集前，我们先看看 Java 应用在业界主流实现 CPU profling 的技术方案：&lt;strong&gt;JMX 、JFR 和 JVMTI AsyncGetCallTrace。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）JMX&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Java Management Extensions（JMX）是 Java 平台上的一种管理和监控技术，它允许开发人员在运行时监视和管理 Java 应用程序，一般使用 ThreadMXBean 中的 dumpAllThreads 可以获取当前线程执行的方法栈情况，利用每次获得的线程调用栈栈帧信息，可以实现方法热点的监测。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）JFR&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Java Flight Recorder（JFR）是 Java 平台上的一种性能监控和故障诊断工具，JFR 的特点包括低性能开销、低停顿、持续监控、动态配置和丰富的数据。它可以在应用程序运行时收集性能数据，而几乎不会对应用程序的性能产生影响。但 JFR 的支持对 Java 版本有一定的要求。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（3） JVMTI AsyncGetCallTrace&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;AsyncGetCallTrace 是 JVMTI 中的一个非标函数，用于异步获取线程的调用堆栈信息。使用 AsyncGetCallTrace，开发人员可以在应用程序运行时异步去获取线程的调用堆栈信息，且不会阻塞线程的执行。这对于性能分析和故障诊断非常有用，因为它允许开发人员在不影响应用程序性能的情况下获取线程的调用堆栈信息，从而更好地了解应用程序的执行情况和性能特征。&lt;/p&gt; 
&lt;p&gt;上述三种方案便是实现 CPU Profiling 的主流方案，这三个方案在我们之前分析的三个产品中使用情况如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//26cbdf4581b7b1af0e8156d2fcff4686.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 3&lt;/p&gt; 
&lt;p&gt;SkyWalking 使用 JMX 实现性能剖析。他的实现是通过将采集到的 Trace 在 JVM 内部开启线程任务，线程任务通过 segmentId 绑定当前 segmentId 所在的线程，按照采集频率定时使用 getStackTrace 获取各个时段的调用栈信息。但它的设计并不是为了实现 CPU Profiling，他只是一个补全 Trace 的链路分析快速实现，针对一些已知问题，常复现的问题，可以快速定位到根因。后续 SkyWalking 也不一定会使用上述三种方法实现 Java 语言的 CPU profling。&lt;/p&gt; 
&lt;p&gt;DataDog 最开始是用 JFR 实现 CPU Profiling，后来结合开源工具 Async-profiler，完善整个 Continuous Profiling 功能。Async-profiler 实现完全基于 JVMTI，其中它的 CPU 热力图就是得益于 AsyncGetCallTrace 接口。&lt;/p&gt; 
&lt;p&gt;Dynatrace 是个异类，它做分布式 Trace 链路监控的时候，谷歌 Dapper 论文还要几年才出世，谷歌 Dapper 流行后，它已放弃了通过&quot;-javaagent&quot;指令的方式实现字节码增强，在 java，.net，go，python 等众多语言实现无需引用相应的 agent 即可深入监控代码级别的内部链路。它早期使用 JavaAgent 实现的产品 AppMon 可能使用过 JMX 实现 CPU Profiling，10 年前它改版后便完全基于 JVMTI 的 AsyncGetCallTrace 实现。&lt;/p&gt; 
&lt;p&gt;基于 JFR 或 AsyncGetCallTrace 实现 CPU Profiling 性能开销会低很多。我们 vivo 的每个人都追求极致的性能，在技术选型上更偏向性能好的方案。而从厂商 DataDog 已经从 JFR 转向通过结合 Async-profile 来实现整个 Continuous Profiling，JFR 可能并不是一个好选择，所以剩下 AsyncGetCallTrace 的实现方式。或许最终我们也会利用 Async-profiler。&lt;/p&gt; 
&lt;p&gt;但是无论利用 Async-profiler 或者像 Dynatrace 一样独自去实现基于 AsyncGetCallTrace 采集，这对于我们监控团队来说都存在困难，因为我们团队缺少这方面的人力储备。如果我们选择基于 AsyncGetCallTrace 实现，要从零开始，需要学习 c++与 Async-profiler。这样整个研发周期会被拉得很长，短则至少三个月长则半年，同时有较大的不确定性，交付存在风险。&lt;/p&gt; 
&lt;p&gt;另外基于 JMX 实现的采集方案被认为性能不够好，但真正的性能损耗情况需要实践去检验。如果 10ms 和 20ms 的采集频率消耗资源太高，可以尝试降低采集频率。为了快速解决用户痛点，现阶段我们先选择基于 JMX 在 Vtrace 的 JavaAgent 中实现，在 JavaAgent 中实现后再基于压测情况决定后续落地方案。&lt;/p&gt; 
&lt;h2&gt;3.2 基于 JMX Profile 采集设计&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//c25b50150577b7bb02650a502a19b53e.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 14&lt;/p&gt; 
&lt;p&gt;事实上我们这次的设计并不是为了实现 CPU Profiling，更多是为了补全 Trace 的信息。而对 Trace 的方法堆调用栈情况采集，我们基于 JMX Profile 设计如下：&lt;/p&gt; 
&lt;p&gt;1、JavaAgent 启动时，如图 14 所示开启一个采集频率 50ms Profile 采集线程，当然这里采集频率用户是可以自行配置的。&lt;/p&gt; 
&lt;p&gt;2、Trace 进入时将 traceId 与当前 trace 线程 id 合并成一个 traceSegmentId(基于 SkyWalking 6 以上实现的 JavaAgent 可以直接使用他们自身的 traceSegmentId)，同时将这 traceSegmentId 与当前线程 Id 绑定放到一个叫 TRACE_PROFILE_MAP(Map) 的集合中。TRACE_PROFILE_MAP 除了记录 traceSegmentId 和线程 id，同时会记录后续被 Profile 线程采集到的快照。&lt;/p&gt; 
&lt;p&gt;3、Profile 数据采集的线程会定时将 TRACE_PROFILE_MAP 集合当前的所有线程 id 通过 ThreadMXBean.getThreadInfo 获得每个线程当前栈帧信息。记录当前栈帧顶部信息并按照我们设置的深度保留栈帧的一些信息当作本次快照。如果这个 trace 线程下一次被采集的栈帧顶部信息与栈深度与这次一样，我们不需要记录本次快照，只需将上次快照出现的次数+1，如图 14 中栈顶为 Thread.sleep 的快照被我们记录了 4 次。如果相邻的两次采集栈帧顶部信息不一样，我们则记录两次快照信息，如图 14 对于这个 trace 我们最后记录了栈顶为 Object.wait 的快照 3 次。&lt;/p&gt; 
&lt;p&gt;4、trace 结束时，先根据 traceSegmentId 获取到本次 trace 采集到的 Profile 快照数据，然后交给后续 Profile 数据上报线程异步处理，同时将 TRACE_PROFILE 集合记录当前 trace 线程的相关数据从集合中移除。&lt;/p&gt; 
&lt;p&gt;5、如果这个 trace 是使用到多线程会整个 trace 会多个不同的 traceSegmentId，每个异步线程的相关 Profile 数据也会被采集到。&lt;/p&gt; 
&lt;p&gt;从流程上来看，基于 JMX 实现 CPU profiling 采集确实简单，但也可以看出定时采样的方式本身的缺陷，如图 11 中 readFileToJson 方法中显示的采集频率太大两次采样会中间的读取文件的 Disk I/O 会被忽略，但这也是无法避免的，用其它技术方案来实现也一样会有这种问题。因此在实现 Profile 采集后，后续需要测试不同场景下不用采集频率对资源的利用情况，然后结合当前 vivo 服务的整体情况，再最终决定这个方案是否用于生产。&lt;/p&gt; 
&lt;h2&gt;3.3 基于 AsyncGetCallTrace Profile 采集设计&lt;/h2&gt; 
&lt;p&gt;虽然我们先尝试基于 JMX 的方式实现 Profile 采集，但不妨碍我们探讨别的实现方案，很可能后续团队能力起来后再转向基于 AsyncGetCallTrace 实现。&lt;/p&gt; 
&lt;p&gt;通过分析 AsyncGetCallTrace 源码与 Async-Profiler 的实现，发现基于 AsyncGetCallTrace Profile 的采集流程和上述流程相差不大，无非就是怎么触发采集，在 Liunx 系统一般使用信号量来触发，这也会大大地降低采集时的性能损耗。&lt;/p&gt; 
&lt;p&gt;有些操作系统不支持使用信号量来调用 AsyncGetCallTrace 函数，可能需要用 c++实现一个不受 JVM 管理的线程，避免采集时受 JVM SavePiont 或 GC 的影响。&lt;/p&gt; 
&lt;p&gt;另外并不是所有操作系统的 JVM 中都提供 AsyncGetCallTrace 这个函数。&lt;/p&gt; 
&lt;p&gt;上述基于 AsyncGetCallTrace 的采集设计只是通过简单的一些了解而设想的，并不一定正确，欢迎指正。&lt;/p&gt; 
&lt;p&gt;后续如果我们完全实现了基于 AsyncGetCallTrace Profile 采集我们再向大家介绍实现的细节。&lt;/p&gt; 
&lt;h2&gt;3.4 存储设计&lt;/h2&gt; 
&lt;p&gt;介绍了 Profile 数据的采集设计，接下来聊一下存储设计。&lt;/p&gt; 
&lt;p&gt;一个时间跨度为 1 秒的 Trace，在采集频率为 50ms 时最多可能会被采集到 10 个副本。假设 Profile 采集记录 stack 深度为 20，一份快照信息大约 1KB，这样的话每个 Trace 最多可能需要增加 10KB 的存储。如果记录 stack 深度为 100 时快照信息大小则 6KB 左右。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//fd1b56f71c4d848f4377ed6e5b90f7c6.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 15&lt;/p&gt; 
&lt;p&gt;上图为我们 Prfoile 采集的一个快照文本内容，这个数据大约 1kb。如果每个快照数据都这样存储，则会占用大量的存储。同一个接口不同 Trace 的 Profile 数据会存在大量相同的快照文本，相同的快照文本用同一个 UID 来保存。UID 可以为快照文体的 MD5 值，每个 UID 只占 16 字节。后续在分析 Trace 信息时再将 UID 对应快照文本显示给用户，这样会节省大量的存储成本 。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//c0e724739495047fccb3b3d768e21c32.jpeg&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 16&lt;/p&gt; 
&lt;p&gt;图 16 为 Vtrace 基于 JMX 实现 Profile 采集到数据，为了快速验采集的效果直接让采集到的快照数据作为 Span 存储。图中第一行数据为整个请求的 trace 耗时，而红色框中的则为这个在 trace 我们 Profile 采集线程采集到的调用栈信息，从结果来看把我们原先的一些监控盲区补上来了。这图的数据只是临时处理，实际后续产品交互并不会这样展示。&lt;/p&gt; 
&lt;p&gt;现在存在的问题就是 Vtrace JavaAgent 对所有 Trace 采集会整个服务的性能有哪些影响，而这些影响，是否在我们的接受范围内。我们需要对增加 Profile 采集后对 JavaAgent 进行压力测试，需要对比开启 Profile 采集与未开启 Profile 采集的性能指标差异。&lt;/p&gt; 
&lt;h1&gt;四、压测分析&lt;/h1&gt; 
&lt;h2&gt;4.1 测试设计&lt;/h2&gt; 
&lt;p&gt;测试时需要考虑很多因素，因此在测试前先对测试做好设计，有以下的测试要点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;测试需要考虑环境，比如 cpu 核心数，容器或虚机，有条件最好使用物理机测试&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;测试考虑不同采集频率时对性能的影响&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;需要在不同 TPS 的情况下对比资源的消耗&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;要考虑同一 TPS 下，IO 不同的密集程度下资源消耗差异&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;4.2 测试结果&lt;/h2&gt; 
&lt;p&gt;测试的时候我们记录了很多指标，有很多数据，本文中就不一一展示了。Vtrace 的 Profile 采集对应用性能的产生实质影响在这里我们只需考虑 CPU 使用和 GC 情况，因为采集增加的内存会侧面反映在 GC 情况中。&lt;/p&gt; 
&lt;p&gt;下面为不同场景下开启与不开启 Profile 持续剖析时的资源利用情况对比：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//613900971419676553cbdf9e85dde055.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 4&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;上述场景中 TPS 小于等 50 时，GC 次数很少，开启 Profile 采集对 GC 的影响相差不多。而开启 Profile 采集后对内存的影响主机体现在 GC 上。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;场景 1 与场景 2、场景 3 与场景 4、场景 5 与场景 6 三组采集频率不同的对比测试，可以看出 Profile 采集频率直接影响服务的资源消耗。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;随着测试 TPS 的上升，Profile 采集消耗的资源也相应的增加，1000 TPS 内，从容器与虚机，CPU 4 核心时，开启 Profile 采集 CPU 消耗整体增加不高于 5%; CPU 2 核心时 100 TPS 内开启 Profile 采集 CPU 消耗整体增加不高于 4%。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;对于这个结果并不能说很理想，但又比预期要好一些，后续我们再结合我们当前应用的情况再分析是我们基于 JMX 实现的 Profile 是否可以投入生产使用。&lt;/p&gt; 
&lt;p&gt;而从上面的性能压测结果可以看出通过降低采集频率，CPU 资源消耗有明显减少。但采集频率不宜过低，50ms 对于大部分应用来说可以采集到很多有效的信息，这是我们的一个推荐值。&lt;/p&gt; 
&lt;h2&gt;4.3 资源消耗增加原因&lt;/h2&gt; 
&lt;p&gt;在压力测试后我们知道开启 Profile 采集后 CPU 资源会有所增加，接下来需要确定导致资源消耗增加的地方有哪些。&lt;/p&gt; 
&lt;p&gt;为了找出根因，最初我们想使用 Arthas 来生成火焰图来分析，虽然这个场景应该也能分析出根因，但并不是很直观，分析过程不会很流畅。Arthas 分析这个场景大概是这样的，在开启 Profile 采集前后分别生成火焰图，但这样没法直观地去对比出开启采集后额外增量的热点。同样针对线程分析，Arthas 并没有将线程归类分组，显示了大量的 http-nio-?-exec 线程 (?为线程 ID)。后来我们再次想起了前提到的 Dynatrace 中的 Cpu Profiling 与 Continuous thread analysis 功能，后续可能我们也会去实现类似的功能，抱着学习下商业化产品的 Continuous thread analysis 功能，于是便使用 Dynatrace 来分析。&lt;/p&gt; 
&lt;p&gt;虽然这个场景可以直接使用 Dynatrace 的方法热点分析，但从进程到线程对比开启 Profile 采集前后指标，整个流程会更加顺畅，同时这样的排查思路与产品呈现会带来一些设计上的启发。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5d830ec1be6c62112a4aae01282bdc8c.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 17&lt;/p&gt; 
&lt;p&gt;图 17 是流量相同的情况下，开启 Profile 采集前后指标的变化，从中可以看出：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;整个 java 进程 CPU 变化从 8.51% 增加到 12%&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;后台线程 CPU 变化从 4.81% 增加到 8.4%&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;GC 线程 CPU 变化从 0.15% 增加 0.3%&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;上述结论我们知道开启采集后导致进程 CPU 使用率增加的主要有后台线程和 GC 线程，GC 线程略有增加主要还是采集时额外使用的内存增加导致，所以下面我们重点对后台线程分析，这里用到的便是 Continuous thread analysis 功能。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//032004bc954f8f1a8290ece6041fc8ca.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 18&lt;/p&gt; 
&lt;p&gt;图 18 为开启 Profile 采集后的后台线程分析，展示了某段时间内主要所有后台线程组的运行情况，我们可以看出增加的两个进程组正好是我们的 Profile 采集线程与 Profile 数据发送线程，而 Profile 采集线程的奉献度占比远大于 Profile 数据发送线程。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e89140c94cccefde049c0c93c7b1152b.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 19&lt;/p&gt; 
&lt;p&gt;针对 Profile 采集线程我们再深入这个线程一段时间内的方法热点去看，从图 19 的结果上看 Profile 采集线程消耗 CPU 主要在调用 JVMTI 方法 (ThreadImpl.getThreadInfo1) 获取当前线程的信息。&lt;/p&gt; 
&lt;p&gt;对这个判断有点怀疑，认为线程信息采集到后处理调用栈的逻辑会有所消耗资源。对这个疑问，简单的方法可以先将 Profile 采集线程中调用 ThreadImpl.getThreadInfo1 方法之后的所有代码注释然后压力测试。接着加上线程栈数据处理的代码同时注释 Profile 采集发送的代码，然后再在同样的条件下压测，之后再对比两次压测的性能差异。当然也可以使用 Arthas 来生成火焰图分析，但我们并不是这样做的，明显有更加直观的办法，可以看看下面的 Profile 采集伪代码：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//第 1 步,记录当前 Profile 采线程 cpu 使用时间。getCpuTime 实际是直接调用 ThreadMXBean 的 getCurrentThreadCpuTime
long cpuTime = ThreadProvider.INSTANCE.getCurrentThreadCpuTime();
//第 2 步,获取线程集合的 stackTrace 信息。ids 为当前正在执行的 trace 的线程 ID 集合，MAX_TACK_DEPTH 为采集 stackTrace 的最大深度
//ThreadProvider.INSTANCE.getThreadInfos 实际是直接调用 ThreadMXBean 的 getThreadInfos，底层最终是调 ThreadImpl.getThreadInfo1
ThreadInfo[] threadInfos = ThreadProvider.INSTANCE.getThreadInfos(ids, MAX_TACK_DEPTH);
//第 3 步,计算第 2 步的程序执行 CPU 使用时间
long threadDumpCpuTime = ThreadProvider.INSTANCE.getCurrentThreadCpuTime() - cpuTime;
//第 4 步，线程数据 threadInfos 的处理逻辑
for (ThreadInfo threadInfo : threadInfos) {
//获得单个线程 StackTrace 信息，后续处理代码省略
StackTraceElement[] stackTrace = threadInfo.getStackTrace();
int stackDepth = Math.min(stackTrace.length, MAX_TACK_DEPTH);
for (int i = stackDepth - 1; i &amp;gt; 0; i--) {
  StackTraceElement element = stackTrace[i];
}
......
}
//第 5 步，计算整个采集线程结束时 CPU 的使用时间以及 ThreadMXBean 的 getThreadInfos 消耗 CPU 的时间占比。之后我们对比 threadDumpCpuTime 与 processCpuTime 便可知道整个线程 CPU 消耗在哪里
long processCpuTime = ThreadProvider.INSTANCE.getCurrentThreadCpuTime() - cpuTime;
float threadDumpCost = threadDumpCpuTime * 1.0f / processCpuTime * 100
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;通过上述代码测试后发现第 4 步的代码确实上也会有一些消耗，但几乎 99% 以上都是消耗在第 2 步中。而 Dynatrace 显示 ThreadImpl.getThreadInfo1 占比为 100%，这是因为 Dynatrace 的 Profiiling 功能一样也是有采样频率的，只是时间段内采集到的样本全部显示 Profile 采集线程获得 CPU 时间片的方法是 ThreadImpl.getThreadInfo1，而这个测试恰好印证了 Dynatrace 方法热点的准确性。&lt;/p&gt; 
&lt;p&gt;而对于 JMX 中的 ThreadImpl.getThreadInfo1，这是一个 native 方法，是无法直接优化的，只能等后续我们有能力基于 AsyncGetCallTrace 去实现 Profile 采集再解决。&lt;/p&gt; 
&lt;h2&gt;4.4 压测小结&lt;/h2&gt; 
&lt;p&gt;通过本次压力测试，我们清楚了基于 JMX 实现的 Profile 采集的性能消耗大致情况，也知道了性能瓶颈在哪里以及后续的优化方向。&lt;/p&gt; 
&lt;h1&gt;五、落地评估&lt;/h1&gt; 
&lt;p&gt;接下来我们需要分析当前接入 Vtrace 产品 vivo 服务的情况，后面基于上面的测试结果与现状去评估我们 Profile 采集能否最终落地。&lt;/p&gt; 
&lt;h2&gt;5.1 当前 vivo 服务情况&lt;/h2&gt; 
&lt;p&gt;目前接入 Vtrace 的 2500+个服务中有 200 多个服务他们实例的平均 TPS 大于 100 ，而单实例平均 TPS 小于 100 的服务占 91.2%。下面表格中的数据是基于工作日某一分钟统计得出的当前 Vtrace 所有服务实例平均 TPS 值的分布情况：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e0371ee9715263276dc67168fb209fa7.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 5&lt;/p&gt; 
&lt;h2&gt;5.2 落地分析&lt;/h2&gt; 
&lt;p&gt;通过上表可以看出 vivo 当前服务的情况，我们之前的测试结果表明在 2c4g 和 4c8g 的机器上服务 TPS 为 20 时 Profile 采集频率设置 50ms，cpu 消耗增加 1% 不到。而我们约 75% 的服务 TPS 小于 20，也就是说这些服务如果愿意接受 1% 的 CPU 资源消耗，基于 JMX 的 Profile 采集也能服务到大量的用户。&lt;/p&gt; 
&lt;p&gt;对于 TPS 大于 100 的服务，如果只是某些固定接口需要排查，可以通过配置对需要 Profile 采集的接口进行过滤，这样可以扩大落地的范围。&lt;/p&gt; 
&lt;p&gt;因为考虑压力测试的测试场景覆盖场景有限，我们会更谨慎一些，先完善一下 Profile 采集保护机制，后面一些服务中试点再逐步铺开。如果 TPS 小于 20 的服务顺利展开，之后再考虑覆盖 TPS 在 20 以上到 100 之间的服务。TPS 超 100 的服务可以针对需要分析的接口开启 Profile 采集。至于所有服务全量采集覆盖可能需要等于我们攻克基于 AsyncGetCallTrace 的采集设计之后。&lt;/p&gt; 
&lt;p&gt;很多大型企业可能和 vivo 差不多，大部分 90% 以上的服务单个实例 TPS 在 100 之内。而传统企业 TPS 小于 100 的占比则更高，如果是制造业的话可能 90% 的服务 TPS 不到 20。不过很多企业部署方式与 vivo 不同，他们可能在一个 8c16g 的机器上部署好几个服务实例，这样的话每个实例增加 1% 的资源消耗对於单个机器可能就显得多了。还好 vivo 基本上都是单机单实例部署或者容器部署，所以避免了上服务混合部署的情况。&lt;/p&gt; 
&lt;p&gt;最后，我们基于 JMX 的 Profile 设计虽然不是业界内的最优解，但却是当前快速解决 vivo Vtrace 监控的一个痛点的最优解。&lt;/p&gt; 
&lt;h1&gt;六、未来展望&lt;/h1&gt; 
&lt;p&gt;面对着困境我们努力优化却回报不高，在同类产品的分析后我们探索出改进方向，而在技术选型上我们做了一些妥协，最后随着对压测结果与 vivo 的实际情况分析发现我们还算交了一份不错的答卷。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5d4040298555aef4d89abce5a286220d.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;图 20&lt;/p&gt; 
&lt;p&gt;上图展示了 Profile 采集的最终效果，与图 1 相比，我们取得了巨大的进步。在优化了 MySQL 与 Kafka 的插件支持后，我们再次将 Vtrace 与同类产品进行对比：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b5d339e3687606ac92cf8deb4c44583f.png&quot; alt=&quot;图片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;表 6&lt;/p&gt; 
&lt;p&gt;重新对比，可以看出 Vtrace 的 Trace 分析能力有了显著的变化，从最初无法识别基本组件，提升到与头部同类产品不相上下。这样的 Trace 分析能力在国内可观测领域属于顶尖水准，全球范围内也达到一流水平。&lt;/p&gt; 
&lt;p&gt;后续我们会重新整体去规划 Continuous Profiling 的相关设计，同时团队慢慢学习提升技术让团队能够基于 AsyncGetCallTrace 将 Profile 采集的性能优化到最低。这并不只是为了优化 Profile 采集的性能，而是考虑到实现整个 Continuous Profiling 团队也必须提升相关的技术能力。强大齐全的 Continuous Profiling 能力可观测系统根因分析的关键，采集端消耗资源越小观测能力的上限才会越高。&lt;/p&gt; 
&lt;p&gt;涅槃之路已经开启，涅槃之路就在脚下，但这也只是刚刚开始。未来 Vtrace 不需要用户配置任何的检测规则，服务出现异常时 Vtrace 能够自动检测出问题。自动检测出来的问题会自动定位出异常的的根因及异常影响业务的范围，比如受到影响的接口上下文、接口请求量与用户数量。而告警通知用户可以按照自己的团队要求去分派告警或者按照个人需求去订阅告警，告警按照着每个团队或个人的喜好方式流转。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18123970</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18123970</guid>
            <pubDate>Thu, 03 Apr 2025 07:26:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>挑战 Rust 和 Scala，这门新语言震惊德国开发者</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;原标题：MoonBit 语言的十大特性（MoonBit Language in 10 Features）&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;原文链接：&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40hivemind_tech%2Fmoonbit-language-in-10-features-4dc41a3a1d6c&quot; target=&quot;_blank&quot;&gt;https://medium.com/@hivemind_tech/moonbit-language-in-10-features-4dc41a3a1d6c&lt;/a&gt;&lt;/em&gt;&lt;br&gt; &lt;strong&gt;作者：Ignacio 丨德国科技公司 Hivemind 工程师&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0411/151915_XnW1_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;作为一名 Scala 开发者，我最近注意到 Scala 的市场在逐渐萎缩，这促使我探索其他具有类似特性的编程语言，例如支持函数式编程、高阶类型、高阶函数、泛型、运算符重载和领域建模等。&lt;/p&gt; 
&lt;p&gt;最近，我在 X（前称 Twitter）上听说了 MoonBit 语言，并通过搜索了解了更多信息。MoonBit 是一种 AI 原生的通用编程语言，由张宏波领导开发。&lt;/p&gt; 
&lt;p&gt;张宏波在编程语言开发方面有着丰富的经验，曾是 OCaml 的核心贡献者，ReScript 的创建者，并在 Meta （前称 FaceBook）公司参与了 Flow 的开发。&lt;/p&gt; 
&lt;p&gt;MoonBit 由粤港澳大湾区数字经济学院（IDEA）开发，该机构致力于人工智能和数字经济领域的前沿研究和产业应用。&lt;/p&gt; 
&lt;p&gt;在其官方网站上，我发现 MoonBit 具有以下基本特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;融合了 Rust 和 Scala 的优点&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;不使用 Rust 中的「借用」概念&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;采用垃圾回收机制&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;性能卓越&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;可编译为 WebAssembly&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为了体验 MoonBit 的编程感受是否类似于编写高质量的 Scala 代码，我决定用 MoonBit 编写一些代码。我选择了一个众所周知的主题进行领域建模：国际象棋棋盘。我希望定义棋子、棋盘以及游戏的初始状态（暂不涉及棋子的移动和游戏逻辑）。&lt;/p&gt; 
&lt;p&gt;示例代码库可在以下链接找到：&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fignacio-hivemind%2FMoonBit-chess-example&quot; target=&quot;_blank&quot;&gt;https://github.com/ignacio-hivemind/MoonBit-chess-example&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;接下来，让我们逐一探讨 MoonBit 的这些特性。&lt;/p&gt; 
&lt;h2&gt;十大特性&lt;/h2&gt; 
&lt;h3&gt;1、枚举类型&lt;/h3&gt; 
&lt;p&gt;首先，我为棋盘上的棋子创建了一些定义。在国际象棋中，棋子可以是黑色或白色，种类包括兵（Pawn）、车（Rook）、马（Knight）、象（Bishop）、后（Queen）和王（King）。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// This application is about a chess board,
// and how to represent it in the MoonBit language.
//
// Board is a double dimension array of BoardPlace
// cols: &amp;nbsp;0 1 2 3 4 5 6 7
// row 0: R N B Q K B N R
// row 1: P P P P P P P P
// row 2: . . . . . . . .
// row 3: . . . . . . . .
// row 4: . . . . . . . .
// row 5: . . . . . . . .
// row 6: p p p p p p p p
// row 7: r n b q k b n r
//
// The upper case letters represent the white pieces,
// whereas the lower case letters represent the black pieces.
// The pieces are: Pawn (P or p), Rook (R or r), Knight (N or n),
// Bishop (B or b), Queen (Q or q), King (K or k).
// The dots represent empty places.


/// This is documentation for the Color enum data type.
/// This is the color of the pieces in a chess game.
pubenumColor&amp;nbsp;{
&amp;nbsp; &amp;nbsp;White
&amp;nbsp; &amp;nbsp;Black
}


/// This is documentation for the Piece enum.
/// It represents the different pieces in a chess game.
pubenumPiece&amp;nbsp;{
&amp;nbsp; &amp;nbsp;Pawn
&amp;nbsp; &amp;nbsp;Rook
&amp;nbsp; &amp;nbsp;Knight
&amp;nbsp; &amp;nbsp;Bishop
&amp;nbsp; &amp;nbsp;Queen
&amp;nbsp; &amp;nbsp;King
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;如上所示，在定义前使用三个斜杠（///）可为方法、数据类型或函数添加文档注释。使用两个斜杠（//）则表示单行注释。pub 关键字表示这些定义对其他文件或模块是公开的。枚举类型（enum）定义了一种新的类型，其值只能是大括号内指定的选项。例如，Color 的值只能是 White 或 Black，Piece 的值只能是 Pawn、Rook、Knight、Bishop、Queen 或 King 之一。&lt;/p&gt; 
&lt;h3&gt;2、内置 Trait 的自动派生&lt;/h3&gt; 
&lt;p&gt;在之前的枚举定义中，我们可以添加 derive(Show, Eq)，自动为这些枚举实现 Show 和 Eq 特性。这意味着我们可以直接比较和打印 Color 或 Piece 的实例。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;enum&amp;nbsp;Color&amp;nbsp;{
..
}&amp;nbsp;derive(Show,&amp;nbsp;Eq)

pub&amp;nbsp;enum&amp;nbsp;Piece&amp;nbsp;{
..
}&amp;nbsp;derive(Show,&amp;nbsp;Eq)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;例如，我们可以编写一个函数来比较棋子：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;enum&amp;nbsp;Color&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ..
}&amp;nbsp;derive(Show,&amp;nbsp;Eq)

pub&amp;nbsp;enum&amp;nbsp;Piece&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ..
}&amp;nbsp;derive(Show,&amp;nbsp;Eq)
&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;compare_pieces(piece: Piece)&amp;nbsp;-&amp;gt;&amp;nbsp;Unit {
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;piece == Pawn {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println(&quot;The piece is a pawn&quot;)
&amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println(&quot;The piece is a &quot;&amp;nbsp;+ piece.to_string())
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在这个示例中，我们可以直接使用&amp;nbsp;&lt;strong&gt;==&lt;/strong&gt;&amp;nbsp;运算符比较&lt;strong&gt;Piece&lt;/strong&gt;的实例，因为&lt;strong&gt;Piece&lt;/strong&gt;实现了&lt;strong&gt;Eq&lt;/strong&gt;特性。同时，我们可以使用&lt;strong&gt;to_string()&lt;strong&gt;方法打印&lt;/strong&gt;Piece&lt;/strong&gt;的实例，因为它实现了&lt;strong&gt;Show&lt;/strong&gt;特性。&lt;/p&gt; 
&lt;h3&gt;3、类型别名&lt;/h3&gt; 
&lt;p&gt;在定义棋盘时，我们可以使用类型别名来提高代码的可读性和可维护性。例如，定义&lt;strong&gt;BoardPlace&lt;/strong&gt;为&lt;strong&gt;Option[(Piece, Color)]&lt;/strong&gt;，表示棋盘上的每个位置要么为空，要么包含一个特定颜色的棋子。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// This is the representation of a place on a chess board.
/// It can be empty (None) or contain a piece with a color: Some((piece, color)).
pub&amp;nbsp;typealias BoardPlace =&amp;nbsp;Option[(Piece, Color)]
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;通过这种定义方式，在代码中任何位置，我们都可以用&lt;strong&gt;BoardPlace&lt;/strong&gt;代替对应的&lt;strong&gt;Option&lt;/strong&gt;类型，反之亦然。这只是右侧类型定义的简化表达方式。另外，值得注意的是，&lt;strong&gt;Option&lt;/strong&gt;数据类型内置于 MoonBit 语言的标准库中，与 Rust 和 Scala 类似。MoonBit 还内置了&lt;strong&gt;Result&lt;/strong&gt;数据类型，它与 Scala 中的&lt;strong&gt;Either&lt;/strong&gt;类型类似，但更专注于错误处理。&lt;/p&gt; 
&lt;h3&gt;4、模式匹配&lt;/h3&gt; 
&lt;p&gt;模式匹配 (Pattern Matching) 对熟悉 Haskell、Scala 或 Rust 的开发者而言，「模式匹配」是一个常见概念。在 MoonBit 中，可以通过如下方式定义一个使用模式匹配的函数：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fn&amp;nbsp;draw(self: BoardPlace)&amp;nbsp;-&amp;gt;&amp;nbsp;String&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;match&amp;nbsp;self&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;None&amp;nbsp;=&amp;gt;&amp;nbsp;&quot;.&quot;&amp;nbsp;// empty place
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Some((piece, Color::White)) =&amp;gt; pieceToString.get*or_default(piece,&amp;nbsp;&quot;.&quot;)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Some((piece, Color::Black)) =&amp;gt; pieceToString.get_or_default(piece,&amp;nbsp;&quot;.&quot;).to_lower()
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这里，&lt;strong&gt;pieceToString&lt;/strong&gt;是一个映射 (map)：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;let&amp;nbsp;pieceToString: Map[Piece,&amp;nbsp;String] = Map::of([
&amp;nbsp; &amp;nbsp; (Piece::Pawn,&amp;nbsp;&quot;P&quot;),
&amp;nbsp; &amp;nbsp; (Piece::Rook,&amp;nbsp;&quot;R&quot;),
&amp;nbsp; &amp;nbsp; (Piece::Knight,&amp;nbsp;&quot;N&quot;),
&amp;nbsp; &amp;nbsp; (Piece::Bishop,&amp;nbsp;&quot;B&quot;),
&amp;nbsp; &amp;nbsp; (Piece::Queen,&amp;nbsp;&quot;Q&quot;),
&amp;nbsp; &amp;nbsp; (Piece::King,&amp;nbsp;&quot;K&quot;)
])
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上述函数的输入是&lt;strong&gt;BoardPlace&lt;/strong&gt;类型，输出则是表示棋盘上该位置棋子的字符串。此外，你还可以使用特殊的通配符 *，来匹配所有未被前面的模式匹配到的其他情况。&lt;/p&gt; 
&lt;p&gt;需要注意的是，在 MoonBit 中，&lt;strong&gt;match&lt;/strong&gt;&amp;nbsp;和&amp;nbsp;&lt;strong&gt;if&lt;/strong&gt;&amp;nbsp;关键字都是表达式（expressions），而非语句（statements）。因此，它们会返回一个值。&lt;/p&gt; 
&lt;p&gt;与 Scala 类似，在一个由花括号&amp;nbsp;&lt;strong&gt;{}&lt;/strong&gt;&amp;nbsp;围成的代码块中，最后一个表达式的值即为该代码块的返回值。这一点在函数中同样适用，例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;abs(a: Int)&amp;nbsp;-&amp;gt;&amp;nbsp;Int {
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;absolute: Int =&amp;nbsp;if&amp;nbsp;a &amp;gt;=&amp;nbsp;0&amp;nbsp;{ a }&amp;nbsp;else&amp;nbsp;{ -a }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;absolute
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;当省略掉 return 关键字时，也能达到完全相同的效果：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;abs(a: Int)&amp;nbsp;-&amp;gt;&amp;nbsp;Int {
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;absolute: Int =&amp;nbsp;if&amp;nbsp;a &amp;gt;=&amp;nbsp;0&amp;nbsp;{ a }&amp;nbsp;else&amp;nbsp;{ -a }
&amp;nbsp; &amp;nbsp; absolute
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;然而，在某些场景中，使用显式的&lt;strong&gt;return&lt;/strong&gt;语句仍然是非常有用的，特别是当你希望提前返回（early return），跳过函数剩余逻辑处理特定情况时：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;early_return(a:&amp;nbsp;String)&amp;nbsp;-&amp;gt;&amp;nbsp;Bool {
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;a ==&amp;nbsp;&quot;.&quot;&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;false
}

// go on with the function logic:
// at this point you know that a is NOT 「.」
// ...
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;5、结构体类型&lt;/h3&gt; 
&lt;p&gt;结构体（struct）类型允许通过组合多个不同类型的字段来构造出新的数据类型。这种机制类似于其他编程语言中的类（class），特别是在结构体中加入方法定义以及信息隐藏（封装）时，更是如此。&lt;/p&gt; 
&lt;p&gt;例如，我们可以这样定义棋盘上的一行（Row）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// This is a struct that represents a row in the board
pub&amp;nbsp;struct&amp;nbsp;Row&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// Array type definition:
&amp;nbsp; &amp;nbsp;&amp;nbsp;priv&amp;nbsp;cols: Array[BoardPlace]&amp;nbsp;// information hiding: private fields
}&amp;nbsp;derive(Show,&amp;nbsp;Eq)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;再定义整个棋盘（Board）的网格结构以及棋盘当前的状态（BoardState）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// This is a struct that represents the board grid
pub&amp;nbsp;struct&amp;nbsp;Board&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;priv&amp;nbsp;grid: Array[Row]
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;/// This is a struct that represents the board state
pub&amp;nbsp;struct&amp;nbsp;BoardState&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;priv&amp;nbsp;board: Board
&amp;nbsp; &amp;nbsp;&amp;nbsp;priv&amp;nbsp;turn: Turn
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;以上定义清晰地表达了棋盘元素及棋盘状态的结构。&lt;/p&gt; 
&lt;p&gt;当我们想在&lt;strong&gt;Row&lt;/strong&gt;这个结构体的命名空间（namespace）下添加方法时，有两种方式：&lt;/p&gt; 
&lt;p&gt;方法一： 此方法定义了一个没有任何棋子的棋盘行。注意&amp;nbsp;&lt;strong&gt;Row::&lt;/strong&gt;&amp;nbsp;这个前缀，它明确表明这是针对类型&lt;strong&gt;Row&lt;/strong&gt;定义的方法。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;Row::empty_row()&amp;nbsp;-&amp;gt;&amp;nbsp;Row {
&amp;nbsp; &amp;nbsp; { cols: Array::make(8,&amp;nbsp;None) }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;方式二： 如果方法需要访问结构体自身（self）的数据，定义方式则如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// fn &amp;lt;name&amp;gt;(self: &amp;lt;type&amp;gt;, &amp;lt;parameters&amp;gt;) -&amp;gt; &amp;lt;return type&amp;gt; { &amp;lt;body&amp;gt; }
// And then you can call: &amp;lt;object&amp;gt;.&amp;lt;name&amp;gt;(&amp;lt;parameters&amp;gt;)
pub&amp;nbsp;fn&amp;nbsp;get_turn(self: BoardState)&amp;nbsp;-&amp;gt;&amp;nbsp;Turn {
&amp;nbsp; &amp;nbsp;&amp;nbsp;self.turn
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;例如，当&lt;strong&gt;board_state&lt;/strong&gt;是&lt;strong&gt;BoardState&lt;/strong&gt;类型的实例时，我们就可以通过&amp;nbsp;&lt;strong&gt;board_state.get_turn()&lt;/strong&gt;&amp;nbsp;来获取当前国际象棋游戏中的回合（Turn）信息。&lt;/p&gt; 
&lt;h3&gt;6、运算符重载&lt;/h3&gt; 
&lt;p&gt;可以通过重载「[]」运算符，以允许对棋盘行中的元素进行索引操作，如下面的代码片段所示。你只需为你的类型（在本例中为&lt;strong&gt;Row&lt;/strong&gt;类型）重载**op_get()**方法即可：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// This special method name &quot;op_get&quot; is used to overload the [] operator.
pub&amp;nbsp;fn&amp;nbsp;op_get(self:Row, index: Int)&amp;nbsp;-&amp;gt;&amp;nbsp;BoardPlace {
&amp;nbsp; &amp;nbsp;&amp;nbsp;self.cols[index]
}To allow&amp;nbsp;for&amp;nbsp;indexed&amp;nbsp;assignment operations, you can&amp;nbsp;override&amp;nbsp;the&amp;nbsp;op_set() method:
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;为了允许索引赋值操作，你还可以重载&amp;nbsp;&lt;strong&gt;op_set()&lt;/strong&gt;&amp;nbsp;方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;op_set(self: Row, index: Int, value: BoardPlace)&amp;nbsp;-&amp;gt;&amp;nbsp;Unit {
&amp;nbsp; &amp;nbsp;&amp;nbsp;self.cols[index] = value;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;例如，现在你可以这样做：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;check_first_element(row: Row)&amp;nbsp;-&amp;gt;&amp;nbsp;Unit {
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;element: BoardPlace = row[0]&amp;nbsp;// Access the row with an index using 「[]」 operator
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;element is&amp;nbsp;Some((Piece::Pawn, Color::White)) {
&amp;nbsp; &amp;nbsp;println(&quot;First element is a white pawn&quot;)
&amp;nbsp;}
&amp;nbsp;...
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;7、新类型定义&lt;/h3&gt; 
&lt;p&gt;MoonBit 允许你基于已有的类型定义一个新类型。例如，要定义 Turn 数据类型，我们可以这样做：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// This is a new type that represents a turn in a chess game.
pub&amp;nbsp;type&amp;nbsp;Turn&amp;nbsp;Color
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;现在，&lt;strong&gt;Turn&lt;/strong&gt;就是一个新类型，类似于 Scala 语言中的 opaque 类型。要创建一个&lt;strong&gt;Turn&lt;/strong&gt;类型的实例，你需要将值包装在类型名中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;BoardState::initialSetup!()&amp;nbsp;-&amp;gt;&amp;nbsp;BoardState {
&amp;nbsp; &amp;nbsp; { board: Board::initialize!(), turn:&amp;nbsp;Turn(Color::White) }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这种方式确保了颜色（Color）和回合（Turn）的值在编译时不会被混淆。&lt;/p&gt; 
&lt;h3&gt;8、特性&lt;/h3&gt; 
&lt;p&gt;下面是 MoonBit 中定义新特性的语法。由于它是「open」的，因此可以被扩展：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// This trait defines a draw method that returns a string
/// representation of the object.
/// It is used to draw the different objects in the chess game to a String.
/// (although it could be in another format or different resource, like a file or
/// screen).
pub(open)&amp;nbsp;trait&amp;nbsp;Drawable&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;draw(Self)&amp;nbsp;-&amp;gt;&amp;nbsp;String
&amp;nbsp; &amp;nbsp; }

&amp;nbsp; &amp;nbsp;&amp;nbsp;pub(open)&amp;nbsp;trait&amp;nbsp;Paintable&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;paint(Self)&amp;nbsp;-&amp;gt;&amp;nbsp;Unit
&amp;nbsp; &amp;nbsp; }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们定义了两个特性，每个特性中都有不同的（抽象）方法：&lt;strong&gt;draw()&lt;/strong&gt;&amp;nbsp;和&amp;nbsp;&lt;strong&gt;paint()&lt;/strong&gt;。这类似于 Java 中的接口或 Scala 中的 trait。&lt;/p&gt; 
&lt;p&gt;两个特性可以通过「+」运算符进行组合或继承：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// This is how you extend and combine traits in MoonBit language.
pub&amp;nbsp;trait&amp;nbsp;DrawableAndPaintable&amp;nbsp;: Drawable + Paintable {}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;特性中的方法通过以下方式进行实现：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// Implement Drawable for BoardPlace trait
pub&amp;nbsp;impl&amp;nbsp;Drawable&amp;nbsp;for&amp;nbsp;BoardPlace&amp;nbsp;with&amp;nbsp;draw(self: BoardPlace)&amp;nbsp;-&amp;gt;&amp;nbsp;String&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ...
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;如你所见，我在&amp;nbsp;&lt;strong&gt;BoardPlace&lt;/strong&gt;&amp;nbsp;类型上实现了&amp;nbsp;&lt;strong&gt;draw()&lt;/strong&gt;&amp;nbsp;方法（以满足&amp;nbsp;&lt;strong&gt;Drawable&lt;/strong&gt;&amp;nbsp;接口的要求）。如果我们同样为&amp;nbsp;&lt;strong&gt;BoardPlace&lt;/strong&gt;&amp;nbsp;类型实现** paint() ** 方法，那么该数据类型也将满足** Paintable ** 和&amp;nbsp;&lt;strong&gt;DrawableAndPaintable&lt;/strong&gt;&amp;nbsp;。&lt;/p&gt; 
&lt;p&gt;接下来，我们还可以为&amp;nbsp;&lt;strong&gt;Row&lt;/strong&gt;&amp;nbsp;类型实现&amp;nbsp;&lt;strong&gt;draw()&lt;/strong&gt;&amp;nbsp;方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/// Implement Drawable for Row
impl&amp;nbsp;Drawable&amp;nbsp;for&amp;nbsp;Row&amp;nbsp;with&amp;nbsp;draw(self: Row)&amp;nbsp;-&amp;gt;&amp;nbsp;String&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ...
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;9、内置测试&lt;/h3&gt; 
&lt;p&gt;通过定义一个辅助函数，我们可以根据字符串生成一行新的棋盘数据：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;Row::new_row_from_string!(rowStr:&amp;nbsp;String)&amp;nbsp;-&amp;gt;&amp;nbsp;Row {
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(rowStr.length(),&amp;nbsp;8)
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;cols&amp;nbsp;= []
&amp;nbsp; &amp;nbsp;&amp;nbsp;// for loops in MoonBit
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i&amp;nbsp;in&amp;nbsp;0..=7&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; cols.push(new_place_from_char(rowStr[i]))
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; { cols: cols }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这是在 MoonBit 中定义 for 循环的方式，用于从 0 到 7（包含 7）进行迭代。我将输入字符串中的每个棋子依次插入到&amp;nbsp;&lt;strong&gt;cols&lt;/strong&gt;&amp;nbsp;数组中。&lt;strong&gt;assert_eq!&lt;/strong&gt;&amp;nbsp;语句用于检查&amp;nbsp;&lt;strong&gt;rowStr&lt;/strong&gt;&amp;nbsp;参数的长度是否为 8，以确保可以正确构造出一行。最后一行返回一个新的&amp;nbsp;&lt;strong&gt;Row&lt;/strong&gt;&amp;nbsp;对象。&lt;/p&gt; 
&lt;p&gt;接下来，我们可以在代码的任何位置使用&amp;nbsp;&lt;strong&gt;test&lt;/strong&gt;&amp;nbsp;关键字定义测试：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;test&amp;nbsp;&quot;create a white row from string&quot;&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;my_row: Row = Row::new_row_from_string!(&quot;RNBQKBNR&quot;)

&amp;nbsp; &amp;nbsp; assert*eq!(my_row[0],&amp;nbsp;Some((Piece::Rook, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[1],&amp;nbsp;Some((Piece::Knight, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[2],&amp;nbsp;Some((Piece::Bishop, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[3],&amp;nbsp;Some((Piece::Queen, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[4],&amp;nbsp;Some((Piece::King, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[5],&amp;nbsp;Some((Piece::Bishop, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[6],&amp;nbsp;Some((Piece::Knight, Color::White)))
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(my_row[7],&amp;nbsp;Some((Piece::Rook, Color::White)))
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这种方式非常简洁，我们无需依赖其他测试框架，就可以直接在代码中嵌入测试块，用来验证某些性质是否一直成立，特别是在持续开发新功能或重构代码时非常有帮助。&lt;/p&gt; 
&lt;h3&gt;10、函数式编程支持&lt;/h3&gt; 
&lt;p&gt;让我们回顾上一节中定义的&amp;nbsp;&lt;strong&gt;new_row_from_string()&lt;/strong&gt;&amp;nbsp;函数。我们原本使用** for** 循环逐个将棋子压入行数组中，但其实可以使用数组的&amp;nbsp;&lt;strong&gt;map&lt;/strong&gt;&amp;nbsp;函数来生成这些元素：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;pub&amp;nbsp;fn&amp;nbsp;Row::new_row_from_string!(rowStr:&amp;nbsp;String)&amp;nbsp;-&amp;gt;&amp;nbsp;Row {
&amp;nbsp; &amp;nbsp;&amp;nbsp;assert_eq!(rowStr.length(),&amp;nbsp;8)
&amp;nbsp; &amp;nbsp; { cols: rowStr.to_array().map(new_place_from_char) }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;现在，它变成了一行搞定！&lt;/p&gt; 
&lt;p&gt;这个函数的逻辑是：将字符串转换为字符数组，然后逐个字符传入&amp;nbsp;&lt;strong&gt;new_place_from_char()&lt;/strong&gt;&amp;nbsp;函数，用以生成&amp;nbsp;&lt;strong&gt;cols&lt;/strong&gt;&amp;nbsp;数组。最后的表达式构造并返回一个包含&amp;nbsp;&lt;strong&gt;cols&lt;/strong&gt;&amp;nbsp;的结构体实例。&lt;/p&gt; 
&lt;p&gt;另外，作为一个额外的特性，MoonBit 支持泛型数据类型，你可以用它来定义集合或参数化类型：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fn&amp;nbsp;count[A](list : @immut/list.T[A])&amp;nbsp;-&amp;gt;&amp;nbsp;UInt {
&amp;nbsp; &amp;nbsp;&amp;nbsp;match&amp;nbsp;list {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Nil =&amp;gt;&amp;nbsp;0
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Cons(*, rest) =&amp;gt;&amp;nbsp;count(rest) +&amp;nbsp;1
&amp;nbsp; &amp;nbsp; }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;更多关于泛型和函数式编程的细节将在后续文章中介绍！&lt;/p&gt; 
&lt;h2&gt;优势&lt;/h2&gt; 
&lt;h3&gt;1、垃圾回收&lt;/h3&gt; 
&lt;p&gt;MoonBit 是一种表达能力非常强的语言，在许多方面与 Rust 相似，但不采用 Rust 中「借用」和「所有权」的内存管理概念。虽然这些机制能带来内存安全，但在我看来它们太底层、使用起来也不够友好。而 MoonBit 使用的是垃圾回收机制来回收内存空间，这使得语言对开发者更友好，编码体验也更加简洁自然。&lt;/p&gt; 
&lt;h3&gt;2、工具链&lt;/h3&gt; 
&lt;p&gt;本次示例我只写了大约 400 行代码，但用来运行和测试程序的工具（如&amp;nbsp;&lt;strong&gt;moon&lt;/strong&gt;&amp;nbsp;命令行工具）以及 VS Code 插件，给我的感觉是相当稳定、实用，能够很好地支持大型应用的开发。唯一的不足是调试器有时会显示局部变量的内部表示形式，而不是它们实际的值，这不太直观。&lt;/p&gt; 
&lt;h3&gt;3、性能表现&lt;/h3&gt; 
&lt;p&gt;虽然我只用 MoonBit 编程了几个小时，但它的编译和运行速度都非常快！编译器主要面向 WASM（WebAssembly）优化，但也支持编译为 JavaScript 和其他平台的代码。&lt;/p&gt; 
&lt;p&gt;你可以在 MoonBit 官方网站（https://www.MoonBitlang.com/）查看一些性能基准测试：&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;628&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/152039_7rbi_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;（此处原文附有链接和图表，建议前往官网获取最新数据）&lt;/p&gt; 
&lt;p&gt;令人惊讶的是，在一些基准测试中，MoonBit 的表现甚至超过了 Rust 和 Go。MoonBit 能够生成体积紧凑的二进制文件，这在 Web 环境中能显著提升加载速度和运行性能，使部署变得更容易、更快速、更具成本效益。&lt;/p&gt; 
&lt;h3&gt;4、与 Scala 的对比&lt;/h3&gt; 
&lt;p&gt;MoonBit 语言同样吸收了许多来自 Scala 的概念，比如「代码块返回最后一个表达式的值」。&lt;/p&gt; 
&lt;p&gt;MoonBit 的语言规模更小，也并未包含 Scala 中的所有特性。但考虑到 Scala 的学习曲线陡峭、精通难度较高，这反而可能是件好事——因为这意味着更容易让开发团队快速上手。虽然你不会拥有所有的函数式编程（FP）特性，但依然可以编写出非常不错的函数式代码，例如以下代码片段（摘自 MoonBit 官网）：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fn&amp;nbsp;main&amp;nbsp;{
&amp;nbsp; &amp;nbsp; resources
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .iter()
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .map*option(fn&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (name,&amp;nbsp;Text(str)) | (name,&amp;nbsp;CSV(content=str)) =&amp;gt;&amp;nbsp;Some((name,&amp;nbsp;str))
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (*, Executable) =&amp;gt;&amp;nbsp;None
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp; .map(fn&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (name, content) =&amp;gt; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;letname&amp;nbsp;= name.pad*start(10,&amp;nbsp;&#39; &#39;)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;letcontent&amp;nbsp;= content
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .pad_end(10,&amp;nbsp;&#39; &#39;)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .replace_all(old=&quot;\n&quot;, new=&quot; &quot;)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .substring(start=0, end=10)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;\{name}: \{content} ...&quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp; .intersperse(&quot;\n&quot;)
&amp;nbsp; &amp;nbsp; .fold(init=&quot;Summary:\n&quot;,&amp;nbsp;String::op_add)
&amp;nbsp; &amp;nbsp; |&amp;gt; println
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;你可以使用 Lambda 表达式、特性（traits）、结构体（structs，代替类）以及高阶函数。此外，就像在 Rust 和 Scala 中一样，MoonBit 也内建了&amp;nbsp;&lt;strong&gt;Option&lt;/strong&gt;&amp;nbsp;和&amp;nbsp;&lt;strong&gt;Result&lt;/strong&gt;&amp;nbsp;数据类型。Scala 在表达能力和灵活性方面更强，但也更复杂。&lt;/p&gt; 
&lt;p&gt;Scala 还能调用所有 Java 的库——这些库经过多年发展，数量庞大且非常稳定；相比之下，MoonBit 当前可用的库数量不多，成熟度也相对较低（在官方网站上，大约有 250 个左右的库可供使用）。&lt;/p&gt; 
&lt;p&gt;Moon CLI 也作为包管理器使用，例如：moon add peter-jerry-ye/async。这条命令告诉项目添加一个名为&amp;nbsp;&lt;strong&gt;peter-jerry-ye/async&lt;/strong&gt;&amp;nbsp;的依赖项。&lt;/p&gt; 
&lt;h3&gt;5、社区&lt;/h3&gt; 
&lt;p&gt;MoonBit 的社区规模尚不如 Rust 或 Scala，那意味着目前在网上找资料会比较困难，AI 编程助手（如 LLM 和 Copilot）对 MoonBit 的支持也还不够完善。&lt;/p&gt; 
&lt;p&gt;起初，我认为这个语言还非常不成熟，但当我在 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmooncakes.io%2F&quot; target=&quot;_blank&quot;&gt;https://mooncakes.io/&lt;/a&gt; 上查看其可用库时，发现其实 MoonBit 已经涵盖了许多基础领域的库，例如 HTTP、异步编程、机器学习工具（如 torch）等。&lt;/p&gt; 
&lt;p&gt;此外，MoonBit 还内置了&amp;nbsp;&lt;strong&gt;Json&lt;/strong&gt;&amp;nbsp;数据类型，这对于开发需要处理 HTTP JSON 服务的程序员来说非常实用：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;fn&amp;nbsp;main&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;json_example&amp;nbsp;: Json = {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;array&quot;: [&quot;a&quot;,&amp;nbsp;&quot;b&quot;],
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;age&quot;:&amp;nbsp;22,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;name&quot;:&amp;nbsp;&quot;John&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;boolean&quot;: True
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;let&amp;nbsp;greeting&amp;nbsp;=&amp;nbsp;match&amp;nbsp;json_example {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {&amp;nbsp;&quot;age&quot;:&amp;nbsp;Number(age),&amp;nbsp;&quot;name&quot;:&amp;nbsp;String(name) } =&amp;gt;&amp;nbsp;&quot;Hello \{name}. You are \{age}&quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; * =&amp;gt;&amp;nbsp;&quot;not match&quot;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; greeting |&amp;gt; println
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;最后总结&lt;/h2&gt; 
&lt;p&gt;截至 2025 年 3 月，MoonBit 已经超越测试阶段。其编译器（包括 WebAssembly 后端）已于 2024 年 12 月开源，这标志着向稳定版本迈出了重要一步。MoonBit 团队正在稳步推进 1.0 正式版的发布，预计将包括对异步支持和嵌入式编程能力的集成。&lt;/p&gt; 
&lt;p&gt;凭借其现代化的语言特性、高性能以及生成的二进制文件体积小，MoonBit 在部署到云端时非常轻便且成本低。&lt;/p&gt; 
&lt;p&gt;尽管 MoonBit 的表达能力不如 Scala 丰富、简洁，因此暂时还不能完全取代 Scala，但它目前在很多方面可以与 Rust 相抗衡。这使得 MoonBit 在某些商业领域具备强大的成功潜力。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;MoonBit（https://www.moonbitlang.cn/）是国内首个工业级编程语言及其配套工具链，由粤港澳大湾区数字经济研究院（简称「IDEA 研究院」）基础软件中心打造的 AI 原生的编程语言以及开发者平台。通过创新框架在程序语言界形成后发优势，在编译速度、运行速度、体积大小上已成功领先传统语言。&lt;/strong&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343981/moonbit-language-in-10-features</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343981/moonbit-language-in-10-features</guid>
            <pubDate>Thu, 03 Apr 2025 07:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>大模型基准测试 ITU 国际标准正式发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;国际电信联盟电信标准分局（ITU-T）于 2025 年 3 月正式发布 ITU-T F.748.44 基础模型的评估标准：基准测试/ Assessment criteria for foundation models: Benchmark。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;该项国际标准由中国信息通信研究院（简称「中国信通院」）牵头制定，规范了大模型基准测试的指标要求和测试方法。该标准旨在推动大模型基准测试体系架构形成国际共识，为大模型技术提供方和应用方提供高质量的能力评估依据，引导大模型技术及产业健康有序发展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;424&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-cee93114efaa5693f577dc5119ccb0d38c6.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据介绍，本次发布的国际标准基于当前产学研界 500 余项基准测试系统性研究，一方面确立了大模型基准测试的 4 项核心要素，包括测试维度（测试场景、测试能力、测试任务和测试指标）、测试数据集、测试方法和测试工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另一方面，针对通用场景的基础模型，提供了标准化的测试用例和范例流程，以支持企业规范开展大模型能力评估。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;中国信通院人工智能研究所于 2023 年开始布局大模型基准测试研究，并于 2023 年底发布「方升」大模型基准测试体系，推出自适应动态测试方法，积累 600 万条数据集，构建 FactTeting 测试工具，支撑整个大模型测试过程的自动化实施。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;自 2024 年以来，参照已发布的 ITU 大模型基准测试国际标准，对国内外标杆大模型以两个月为周期开展持续监测工作，包括 OpenAI o1、DeepSeek R1、Gemini 2.5 Pro、Claude 3.7 Sonnet、Qwen2.5-Max、百度文心大模型 X1 等上百个测试模型，目前已发布大语言通用能力、推理能力、代码能力，多模态理解能力、文生图能力、文生视频能力等多个轮次的评测结果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;国际标准 ITU-T F.748.44 的发布是大模型测试领域的重要标准化成果，对推动技术创新和发展、引领行业发展趋势、促进国际合作与交流等方面具有重要意义。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343980</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343980</guid>
            <pubDate>Thu, 03 Apr 2025 07:19:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>「开源 AI 分身」 Second Me 重大更新：Docker 跨平台支持正式上线</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Second Me 是一个完全开源的项目，致力于保护你的隐私，帮助每个人构建真正属于自己的、安全的、本地的 AI 身份。在这里，你完全掌握数据和智能的主权，仅在你授权下通过安全私密的方式加入网络，共享信息。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0325/161959_LOCV_4252687.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;近日，Second Me &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FKC37jRcLhhGtUks0uyLqMg&quot; target=&quot;_blank&quot;&gt;宣布推出首个重大更新&lt;/a&gt;&lt;/u&gt;：Docker 跨平台支持正式上线，让 Mac (Apple Silicon)、Windows 和 Linux 用户都能轻松一键部署。 此外还新增了标准 OpenAI 协议接口、MLX 本地高效训练能力，以及多项性能优化。&lt;/p&gt; 
&lt;p&gt;具体如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;全平台 Docker 支持&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Second Me 现已全面支持 Docker 部署，兼容 Mac（Apple Silicon）、Windows 及 Linux，让用户随时随地轻松部署。同时，Docker 版本也修复了 Apple Silicon 用户此前的环境依赖问题，带来更顺畅的体验。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;OpenAI 协议接口&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;全新支持标准 OpenAI 协议接口，无缝接入 VS Code、Notion、ChatBox 等数百款主流 AI 应用。只需将这些 AI 应用的 API 地址指向本地 Second Me。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;MLX 训练支持（Beta）&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;充分释放 Apple Silicon 芯片潜能，支持在 Mac 上高效训练更大参数的模型，让你的 Second Me 智能升级。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;性能与稳定性优化&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;训练日志细化，提升训练进度的透明度；增强 embedding 过程中的长文档处理能力；还有更多优化，等你来体验！&lt;/p&gt; 
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmindverse%2FSecond-Me%2Freleases%2Ftag%2Fsnapshot-0407&quot; target=&quot;_blank&quot;&gt;https://github.com/mindverse/Second-Me/releases/tag/snapshot-0407&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343979/second-me-support-docker</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343979/second-me-support-docker</guid>
            <pubDate>Thu, 03 Apr 2025 07:16:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>美教育部长误将「AI」称为「A1」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;外媒&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F04%2F10%2Fthe-us-secretary-of-education-referred-to-ai-as-a1-like-the-steak-sauce%2F&quot; target=&quot;_blank&quot;&gt;报道&lt;/a&gt;称，美国教育部长琳达·麦克马洪（Linda McMahon）本周出席 ASU+GSV 峰会时，在小组讨论过程中多次将「AI」表述为 「A1（A one）」——而 A1 是美国知名的牛排酱品牌。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;337&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a9b5cff08b6b9766abcd4c56582fca4c650.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;一开始，McMahon 确实有正确的表述为 AI，但在后面的发言中却逐渐走偏。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「你知道，AI 的发展--我是说，如果我们没有最好的技术，怎么能以光速进行教育呢？我听说......有一个学校系统将开始确保一年级学生，甚至学前班学生，从低年级开始，每年都有 A1 教学。」&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「不久之前，我们还在说，‘哇，我们的学校要接入互联网啦’。现在，让我们看看 A1，看看它能发挥什么作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;就当下的 AI 这无处不在的热度而言，美国教育部长犯下如此低级的失误确实令人咂舌。对此，美国教育部没有立即回应外媒的置评请求。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;可在此处查看完整&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyoutu.be%2Flxrg28zBv94&quot; target=&quot;_blank&quot;&gt;视频&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343976/us-secretary-of-education-referred-to-ai-as-a1</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343976/us-secretary-of-education-referred-to-ai-as-a1</guid>
            <pubDate>Thu, 03 Apr 2025 07:05:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Cursor 支付方式新增「支付宝」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;全球最火的 AI 编程工具 ——&amp;nbsp;Cursor 终于接入了「支付宝」，极大地方便广大开发者在国内进行使用。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5113170a47623893163436e3bd6c6673f62.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Cursor 是一款基于 AI 的代码编辑器，它不仅能自动补全代码，还能根据自然语言描述生成代码、重构优化、解答问题等。目前 Cursor 在全球 AI 编程工具排行榜中位居第一，不仅程序员喜欢，产品经理、设计师等非技术人员也都在用它来快速实现想法。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Cursor 订阅计划介绍&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;免费版本&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;每月 50 次使用慢速高级模型（GPT-4o、Claude 3.5 Sonnet、Claude 3.7 Sonnet 等），使用完，只能换账号了。&lt;/p&gt; 
&lt;p&gt;使用限制：每月 2000 次代码生成。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Pro 专业版&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;每月 20 美元（折合人民币 145￥），年付：192/年（1393￥）&lt;/p&gt; 
&lt;p&gt;高级模型使用：每月 500 次快速使用高级模型（GPT-4o、Claude 3.5 Sonnet、Claude 3.7 Sonnet 等）。&lt;/p&gt; 
&lt;p&gt;无限制：无限次代码生成。&lt;/p&gt; 
&lt;p&gt;额外功能：每日 10 次使用 o1-mini 模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/145728_F9nb_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cursor.com%2Fcn%2Fpricing&quot; target=&quot;_blank&quot;&gt;https://www.cursor.com/cn/pricing&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343975</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343975</guid>
            <pubDate>Thu, 03 Apr 2025 07:04:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Unity 6 确认将不再向中国用户提供，包括后续版本</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;有消息称在国内的 Unity 官网里疑似无法正常下载到 Unity 6，取而代之的则是「团结引擎」，该引擎专为中国开发者定制，基于 Unity 2022LTS，致力于满足中国开发者的独特需求，结合本土文化元素和市场特色，为创作提供全面支持。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-38ab8e2c64a2d1febdd35b7d94dc4090cca.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;日前，Unity 官方正式宣布，Unity 6 及后续版本将不再向中国用户提供，相关需求将由团结引擎承接。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;「这一调整旨在确保开发者获得更贴合中国市场需求的游戏引擎服务。」&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;1608&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/144956_4ZXL_2720166.png&quot; width=&quot;2460&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.unity.cn%2Fprojects%2F67ee5a4bedbc2a001e9ec5e3&quot; target=&quot;_blank&quot;&gt;&amp;gt;&amp;gt;&amp;gt;官方原文&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;据悉，团结引擎将提供&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.unity.cn%2Fprojects%2F67f4fa33edbc2a001ec2d485&quot; target=&quot;_blank&quot;&gt;两类授权版本&lt;/a&gt;，满足不同阶段开发者的需求，分别为专业版和个人版：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;团结引擎专业版（Pro）：适用于财务规模高于 20 万美元的专业团队及企业，需购买专业版 License。&lt;/li&gt; 
 &lt;li&gt;团结引擎个人版（Personal）：财务规模低于 20 万美元的个人开发者与小型企业免费使用，无需支付基础 License 费用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Unity 官方表示，在今年，团结引擎将持续升级完善 Unity 6 的部分功能特性，并针对中国用户需求改进相关渲染功能。「团结引擎已在小游戏解决方案、OpenHarmony 解决方案、HMI 车机解决方案等领域展现出出色的本地化服务能力，可精准契合中国市场与客户需求。与此同时，Unity 中国将始终重视开发者意见反馈，重点优化面向中小开发团队的定价策略，推出更友好的授权方案，持续降低创作门槛。」&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-fa62498ada45f1197d22233d55e1eed706c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;除此之外，Unity 2022 LTS 及更早版本将由 Unity 中国继续提供支持并持续维护。所有进行中和已经发布的项目均不会受到影响。基于团结引擎创建的项目，可以继续在全球发布，不受影响。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;阅读更多&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/273793/unity-tuanjie&quot; target=&quot;news&quot;&gt;Unity 引擎中国版 ——「团结引擎」开放下载&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/255156&quot; target=&quot;news&quot;&gt;Unity 引擎中国版「团结引擎」正式发布&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343970</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343970</guid>
            <pubDate>Thu, 03 Apr 2025 06:51:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>DeepMind CEO：谷歌最终将合并 Gemini 和 Veo AI 模型</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌 DeepMind 首席执行官 Demis Hassabis 最近在 LinkedIn 联合创始人 Reid Hoffman 联合主持的播客 Possible 上表示，谷歌计划最终将其 Gemini AI 模型与其 Veo 视频生成模型相结合，以提高前者对物理世界的理解。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Hassabis 表示：「我们从一开始就将 Gemini 打造成多模式的基础模型，我们这样做的原因是我们对通用数字助理这一理念有一个愿景，这种助理……能够在现实世界中真正为你提供帮助。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;331&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f5967ab30238c29d43c3a18171cb89ebdfe.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 行业正逐渐走向「全能」模型——可以理解和合成多种媒体形式的模型。谷歌最新的 Gemini 模型可以生成音频、图像和文本，而 OpenAI 的 ChatGPT 中的默认模型可以原生创建图像，包括吉卜力工作室风格的艺术作品。亚马逊也宣布计划在今年晚些时候推出「any-to-any」模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;而这些全能模型需要大量的训练数据，譬如图像、视频、音频、文本等等。Hassabis 暗示，Veo 的视频数据主要来自谷歌旗下的平台 YouTube。「基本上，通过观看 YouTube 视频--大量的 YouTube 视频，[Veo 2] 就能了解世界的物理原理。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;谷歌此前曾向 TechCrunch 表示，根据其与 YouTube 创作者的协议，其模型「可能」会使用「部分」YouTube 内容进行训练。据报道，谷歌去年扩大了服务条款， 部分原因是为了让该公司能够利用更多数据来训练其 AI 模型。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343969/deepmind-ceo-google-combine-gemini-and-veo-ai-models</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343969/deepmind-ceo-google-combine-gemini-and-veo-ai-models</guid>
            <pubDate>Thu, 03 Apr 2025 06:49:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>PostgreSQL 合并对 NUMA Awareness 的初步支持</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;PostgreSQL 开源数据库服务器最近经历了一系列令人兴奋的变化，比如 PostgreSQL 18 合并&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FPostgreSQL-Lands-IO_uring&quot; target=&quot;_blank&quot;&gt;IO_uring 支持&lt;/a&gt;、&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FPostgreSQL-CRC32C-AVX512&quot; target=&quot;_blank&quot;&gt;AVX-512 加速 CRC32 计算&lt;/a&gt;，可提升高达 3 倍的性能。&lt;/p&gt; 
&lt;p&gt;近日，PostgreSQL 合并了针对&lt;strong&gt;非一致性内存访问感知能力（NUMA Awareness&amp;nbsp;）&lt;/strong&gt;的初步支持，用于提升多节点/套接字服务器的 PostgreSQL 性能。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1226&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0411/142945_AkzC_2720166.png&quot; width=&quot;1556&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpostgres%2Fpostgres%2Fcommit%2F65c298f61fc70f2f960437c05649f71b862e2c48&quot; target=&quot;_blank&quot;&gt;commit 详情&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在 PostgreSQL 18.0 发布（预计 9 月）之前，合并到 PostgreSQL Git 中的是基本的 NUMA Awareness。如果使用&quot;--with-libnuma&quot;配置选项构建，目前只提供了 Linux 版本。其他操作系统的 NUMA Awareness 将在后续添加。&lt;/p&gt; 
&lt;p&gt;这项工作是基于去年由微软工程师 Andres Freund 在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fanarazel.de%2Ftalks%2F2024-10-23-pgconf-eu-numa-vs-postgresql%2Fnuma-vs-postgresql.pdf&quot; target=&quot;_blank&quot;&gt;PGConf EU 演讲&lt;/a&gt;中提出的。对于多插槽服务器尤其如此，这种 NUMA 感知能力能够帮助降低延迟，还可以帮助在更靠近 PCIe 连接的存储的 NUMA 节点上执行数据库 I/O，或者更好地处理 CXL 内存周围的问题。&lt;/p&gt; 
&lt;p&gt;在为 PostgreSQL 添加基本的 NUMA 意识之后，针对&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpostgres%2Fpostgres%2Fcommit%2F8cc139bec34a2971b0682a04eb52ce7b3f5bb425&quot; target=&quot;_blank&quot;&gt;pg_shmem_allocations_numa&lt;/a&gt;和&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpostgres%2Fpostgres%2Fcommit%2Fba2a3c2302f1248496322eba917b17a421499388&quot; target=&quot;_blank&quot;&gt;pg_buffercache_numa&lt;/a&gt;的一些后续工作也已经落地，这些工作提供了关于共享内存如何在 NUMA 节点之间分配的信息，以及单个缓冲区信息在 NUMA 内存节点上的分布情况。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343963/postgresql-lands-numa-awareness</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343963/postgresql-lands-numa-awareness</guid>
            <pubDate>Thu, 03 Apr 2025 06:31:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>我认识的最优秀程序员</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;本文翻译自：The Best Programmers I Know&lt;br&gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fendler.dev%2F2025%2Fbest-programmers%2F&quot; target=&quot;_blank&quot;&gt;https://endler.dev/2025/best-programmers/&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在我的生命中，我遇到了很多开发者。最近，我自问：「成为最优秀的人需要什么？他们有什么共同点？」&lt;/p&gt; 
&lt;p&gt;希望这篇文章能激励到某个角落里的人，我记录下了我在我们行业中遇到的最杰出人物所展现出的特质。我希望在我刚开始的时候就有这份清单。如果我当时遵循了这条道路，它将为我节省很多时间。&lt;/p&gt; 
&lt;h2&gt;阅读文档&lt;/h2&gt; 
&lt;p&gt;如果作为一个年轻的程序员，我应该做的事情之一就是 &lt;strong&gt;&lt;em&gt;阅读文档&lt;/em&gt;&lt;/strong&gt;。也就是说，阅读&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpd.apache.org%2Fdocs%2F2.4%2F&quot; target=&quot;_blank&quot;&gt;Apache Web 服务器文档&lt;/a&gt;，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Flibrary%2Findex.html&quot; target=&quot;_blank&quot;&gt;Python 标准库&lt;/a&gt;，或者&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftoml.io%2Fen%2Fv1.0.0&quot; target=&quot;_blank&quot;&gt;TOML 规范&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;不要去 Stack Overflow，不要询问 LLM，不要 &lt;em&gt;猜测&lt;/em&gt;，直接查看&lt;strong&gt;一手文档&lt;/strong&gt;。很多时候，它出人意料地容易访问且编写得很好。&lt;/p&gt; 
&lt;h2&gt;精通你的工具&lt;/h2&gt; 
&lt;p&gt;优秀的开发者对所使用的技术的理解是 &lt;strong&gt;根本性的&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;能够 &lt;em&gt;使用&lt;/em&gt; 一个工具是一回事，而真正 &lt;em&gt;理解&lt;/em&gt; 它则是另一回事。一个普通用户可能会摸索不定，容易困惑，操作不当，无法优化配置。&lt;/p&gt; 
&lt;p&gt;专家（在阅读了文档之后）会坐下来为这个工具编写配置，他们对工具的每一行都了如指掌，并能向同事解释。这样就不会留下任何疑问！&lt;/p&gt; 
&lt;p&gt;要深入了解一个工具，你必须知道：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;它的历史：谁创造了它？为什么？为了解决什么问题？&lt;/li&gt; 
 &lt;li&gt;它的现状：谁在维护它？他们在哪里工作？在什么上？&lt;/li&gt; 
 &lt;li&gt;它的限制：什么时候这个工具不适合？什么时候它会失败？&lt;/li&gt; 
 &lt;li&gt;它的生态系统：存在哪些库？谁在使用它？有哪些插件？&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;例如，如果你是一名后端工程师，并且大量使用 Kafka，我期望你对 Kafka 非常了解——而不仅仅是你在 Reddit 上看到的东西。至少，这是我对你期望成为最优秀工程师的标准。&lt;/p&gt; 
&lt;h2&gt;阅读报错信息&lt;/h2&gt; 
&lt;p&gt;就是&lt;strong&gt;真正阅读错误信息并尝试理解其内容&lt;/strong&gt;。事实证明，如果你静下心来阅读错误信息，它似乎开始对你说话。最优秀的工程师可以从非常少的上下文中推断出大量信息。仅通过阅读错误信息，你就可以自己解决大部分问题。&lt;/p&gt; 
&lt;p&gt;如果你帮助那些没有这种技能的人，这也感觉像是一种超能力。就像「从杯子里读取信息」一样。&lt;/p&gt; 
&lt;h2&gt;拆解问题&lt;/h2&gt; 
&lt;p&gt;每个人有时都会陷入困境。最擅长的人知道如何摆脱困境。他们会简化问题，直到它们变得容易理解。这是一种难以学习的技能，需要大量的经验。或者，你可能拥有出色的解决问题的能力，例如，你很聪明。如果不是这样，你可以通过训练来提高，但没有任何捷径可以绕过分解难题。世界上有一些问题对于任何参与的人来说都太难一次性解决了。&lt;/p&gt; 
&lt;p&gt;如果你是一名专业开发者，那么这就是你得到报酬去做的大部分工作：拆解问题。如果你做得正确，这会感觉像是「开挂」：你只需不断解决拆解后的简单问题，直到完成。&lt;/p&gt; 
&lt;h2&gt;不要害怕动手实践&lt;/h2&gt; 
&lt;p&gt;我所知道的最好的开发者阅读了大量代码，并且他们不畏惧去修改它。他们永远不会说「那不是我的事」或「我帮不上忙」。相反，他们只是开始并学习。代码只是代码。他们可以通过时间和努力掌握任何所需的技能。不知不觉中，他们成为了团队中遇到任何问题时的首选人物。主要是因为他们是唯一不畏惧去修改它的人。&lt;/p&gt; 
&lt;h2&gt;乐于帮助他人&lt;/h2&gt; 
&lt;p&gt;这是一个和上面相关的观点。优秀的工程师需求量大，总是很忙，但他们总是愿意提供帮助。这是因为他们的好奇心强，他们的支持性思维是他们最初成为优秀工程师的原因。有他们在团队中是一种纯粹的快乐，因为他们是问题解决者。&lt;/p&gt; 
&lt;h2&gt;写作&lt;/h2&gt; 
&lt;p&gt;大多数出色的工程师都善于表达，乐于分享知识。&lt;/p&gt; 
&lt;p&gt;最好的开发者都有自己的思想输出渠道：博客、演讲、开源项目，或者这些的组合。&lt;/p&gt; 
&lt;p&gt;我认为写作技巧与编程之间存在强烈的关联。我所认识的顶尖工程师都至少精通一门人类语言——很多时候甚至更多。掌握你的写作方式就是掌握你的思维方式，反之亦然。一个人的写作风格在很大程度上揭示了他们的思维方式。如果它令人困惑且缺乏结构，他们的编码风格也会如此。如果它简洁、富有教育意义、结构良好，有时甚至机智，他们的代码也会如此。&lt;/p&gt; 
&lt;p&gt;优秀的程序员从驾驭文字中找到乐趣。&lt;/p&gt; 
&lt;h2&gt;永不停止学习&lt;/h2&gt; 
&lt;p&gt;我所认识的最好的开发者中有些已经 60 多岁了。他们可以轻松地绕过我。部分原因在于他们持续学习。如果有一个他们尚未尝试的新工具或他们喜欢的语言，他们会去学习。这样，他们几乎不费吹灰之力就能始终保持在最前沿。&lt;/p&gt; 
&lt;p&gt;这并非理所当然：很多人在大学毕业后或开始第一份工作后很快就停止了学习。他们陷入了这样的思维定式，认为在学校学到的是「正确」做事的方式。所有新事物都是不好的，不值得他们花时间。因此，有 25 岁的人「心理上已经退休」，而 68 岁的人仍然思维敏捷。我努力希望有一天能属于后者。&lt;/p&gt; 
&lt;p&gt;与此相关的是，最好的工程师不会追随潮流，但他们总是会仔细评估新技术的益处。如果他们拒绝采用，他们可以清楚地告诉你「为什么」，在什么情况下这项技术是一个好的选择，以及有哪些替代方案。&lt;/p&gt; 
&lt;h2&gt;地位并不重要&lt;/h2&gt; 
&lt;p&gt;最优秀的开发者会与资深工程师和初级开发者进行交流。他们没有等级之分。他们试图从每个人身上学习，不论年龄大小。新来的人通常还没有深陷办公室政治，思维依然清新。他们不知道为什么事情会「困难」，因此他们提出了创造性的解决方案。也许过去的障碍已经不复存在，这使得这些人成为灵感的绝佳来源。&lt;/p&gt; 
&lt;h2&gt;建立声誉&lt;/h2&gt; 
&lt;p&gt;如果你&lt;strong&gt;做了&lt;/strong&gt;出色的工作，你可以成为一名优秀的工程师，但只有当你因为你的出色工作而&lt;strong&gt;闻名&lt;/strong&gt;时，你才能成为最优秀之一；至少在（更大的）组织中是这样。&lt;/p&gt; 
&lt;p&gt;有许多方法可以建立自己的声誉：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;你为（更大的）组织构建并发布了关键服务。&lt;/li&gt; 
 &lt;li&gt;你编写了一个著名的工具。&lt;/li&gt; 
 &lt;li&gt;你为流行的开源工具做出了贡献。&lt;/li&gt; 
 &lt;li&gt;你编写了一本经常被提及的书籍。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为什么我认为以你的工作而闻名很重要？上述所有方法都是扩展你在社区中影响力半径的方式。知名的开发者比非知名的开发者影响的人要多得多。你能编写的代码是有限的。如果你想「扩大」你的影响力，你必须成为一个思想领袖。&lt;/p&gt; 
&lt;p&gt;建立声誉是一个长期目标。它不会一夜之间发生，也不必如此。它也不会意外发生。你每天都要出现并完成工作。随着时间的推移，工作会为自己说话。更多的人会信任你和你所做的工作，他们愿意与你合作。你将参与更多声望较高的项目，圈子会不断扩大。&lt;/p&gt; 
&lt;p&gt;我曾听说过这样一个观点，即你的最新作品应该掩盖你之前所做的一切。这是你走在正确道路上的好迹象。&lt;/p&gt; 
&lt;h2&gt;保持耐心&lt;/h2&gt; 
&lt;p&gt;您需要耐心对待计算机和人类，尤其是对自己。不是所有事情都会立刻顺利，人们也需要时间来学习。这并不是你周围的人愚蠢；他们只是信息不完整。如果没有耐心，你会觉得全世界都在与你作对，周围的人都是无能之辈。那是一个糟糕的地方。你太聪明了，这对你自己来说并不好。&lt;/p&gt; 
&lt;p&gt;要想成为最优秀的人，你需要难以置信的耐心、专注和奉献。如果你想解决难题，你不能轻易分心。你必须回到键盘前才能克服它。你必须付出努力，将项目推过终点线。而且，如果你能在不成为一个傲慢的家伙的情况下做到这一点，那就更好了。这就是最优秀的人与其他人之间的区别。&lt;/p&gt; 
&lt;h2&gt;永远不要责怪计算机&lt;/h2&gt; 
&lt;p&gt;大多数开发者会责怪软件、其他人、他们的狗，或者天气，为那些脆弱的、看似「随机」的 bug 找借口。&lt;/p&gt; 
&lt;p&gt;最好的开发者不会这样做。&lt;/p&gt; 
&lt;p&gt;无论计算机的行为看起来多么古怪或淘气，总有一个&lt;strong&gt;逻辑上的解释&lt;/strong&gt;：你只是还没有找到它而已！&lt;/p&gt; 
&lt;p&gt;最好的做法是继续挖掘，直到找到原因。他们可能不会立即找到原因，甚至可能永远找不到，但他们绝不会责怪外部环境。&lt;/p&gt; 
&lt;p&gt;有了这种态度，他们能够取得惊人的进步，学习到其他人无法学到的东西。当你把错误当作无法理解的魔法时，魔法就会永远如此。&lt;/p&gt; 
&lt;h2&gt;不要害怕说「我不知道」&lt;/h2&gt; 
&lt;p&gt;在面试中，我刻意要求候选人至少说出一次「我不知道」。原因并非我想显得高人一等（尽管有些人确实有这种印象）。不，我想触及他们知识的边界。我想站在他们认为已知事物的边缘。通常，我自己也不知道答案。坦白说，我对答案并不关心。我关心的是当人们通过胡说八道混过面试时。&lt;/p&gt; 
&lt;p&gt;最优秀的候选人会说「嗯，我不知道，但这是个有趣的问题！如果我要猜测，我会说……」然后他们会继续推导出答案。这是你有可能成为一位优秀工程师的迹象。&lt;/p&gt; 
&lt;p&gt;如果你害怕说「我不知道」，那么你可能是出于自负或防御心理。我不喜欢团队中的胡说八道者。最好承认你不可能知道一切。一旦你接受了这一点，你就允许自己学习。「重要的是你不停止提问」，爱因斯坦曾说过。&lt;/p&gt; 
&lt;h2&gt;不要猜测&lt;/h2&gt; 
&lt;p&gt;「面对歧义，拒绝猜测的诱惑」这是我最喜欢的 Python Zen（PEP 20 – The Zen of Python）规则之一。&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpeps.python.org%2Fpep-0020%2F&quot; target=&quot;_blank&quot;&gt;PEP 20 – The Zen of Python&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;而且猜测的诱惑是如此之大！&lt;/p&gt; 
&lt;p&gt;我多次陷入过这种情况，并且因为自己的雄心而失败了。&lt;/p&gt; 
&lt;p&gt;当你猜测时，可能会发生以下两种情况：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;最好情况下&lt;/strong&gt;，你错了，你的错误假设导致了一个 bug。&lt;/li&gt; 
 &lt;li&gt;在&lt;strong&gt;最坏情况下&lt;/strong&gt;，你对了……但你永远不会停下来质疑自己。你会在错误的假设基础上建立你的心理模型。这可能会困扰你很长时间。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;再次，抵制猜测的诱惑。提问，阅读参考资料，使用调试器，务必彻底。做一切必要的事情来获得答案。&lt;/p&gt; 
&lt;h2&gt;保持简单&lt;/h2&gt; 
&lt;p&gt;聪明的工程师编写聪明的代码。卓越的工程师编写简单的代码。&lt;/p&gt; 
&lt;p&gt;这是因为大多数时候，简单就足够了。而且简单比复杂更容易维护。有时，确实很重要要做到正确，但知道区别才是将最优秀者与其他人区分开来的关键。&lt;/p&gt; 
&lt;p&gt;通过保持简单，你可以实现很多事情。专注于正确的事情。&lt;/p&gt; 
&lt;h2&gt;最后的思考&lt;/h2&gt; 
&lt;p&gt;上面的内容不是一份清单或一场竞赛；伟大的工程不是一场赛跑。&lt;/p&gt; 
&lt;p&gt;只是不要骗自己以为你可以跳过艰苦的工作。没有捷径。祝你在旅程中好运。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/343958</link>
            <guid isPermaLink="false">https://www.oschina.net/news/343958</guid>
            <pubDate>Thu, 03 Apr 2025 06:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>