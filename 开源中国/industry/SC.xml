<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-综合资讯</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-综合资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Thu, 27 Mar 2025 07:41:01 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>深度剖析 StarRocks 读取 ORC 加密文件背后的技术</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互联网大数据团队 - Zheng Xiaofeng&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;本文介绍了 StarRocks 数据库如何读取 ORC 加密文件，包括基础概念以及具体实现方案。深入探讨了利用 ORC 文件的四层结构和三层索引机制，实现高效查询加密数据。希望通过本文对 ORC 加密文件读取功能的实现细节的剖析，让读者更加深刻理解 ORC 文件，同时了解 StarRocks 支持加解密数据分析的方案。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;为了提升对敏感数据的保护，需要对 Hive 表一些敏感数据进行加密存储。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Spark 组件已经通过引入了 Apache ORC 项目（Java 版本）对 ORC 格式的 Hive 表的数据进行加解密。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;StarRocks 也使用了 Apache ORC 项目的 C++版本读写 ORC 文件，但是&lt;strong&gt;C++版本没有实现加解密功能&lt;/strong&gt;，在使用 StarRocks 对 Hive 表进行即席分析时，无法对具有加密列的 Hive 表进行查询，因此，需要对 StarRocks 的 Apache ORC 模块进行改造，使其支持对 ORC 格式的 Hive 加密表数据读取功能，数据架构图如下图所示：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//42662e0b81a83165a856f0c38387b668.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;希望通过本文对 ORC 加密文件读取功能的实现细节的剖析，让读者更加深刻理解 ORC 文件，同时了解 StarRocks 支持加解密数据分析的方案。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、问题引入&lt;/h1&gt; 
&lt;p&gt;在正式开启全文的阅读之前，我们首先引入几个问题，然后带着这些问题去阅读后面的内容，将会更有针对性与启发性，通过深入解答这些问题，我们不仅能够更好地理解相关的概念和技术，还能提升分析和解决问题的能力。问题如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;程序解压某个文件时，是否需要一次性读取整个文件后再进行解压操作？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;ORC 文件究竟是如何做到在不扫描全文件的情况下就能精准查询到想要的数据？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;当 SQL 查询条件不符合最左前缀原则时，ORC 文件中的索引是否就会失效？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;数据加密、解密、解压以及压缩之间的关联关系到底是怎样的？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在写 ORC 文件时为什么是先压缩后加密，而不是先加密后解压？&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/blockquote&gt; 
&lt;span id=&quot;OSC_h1_3&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、ORC 文件介绍&lt;/h1&gt; 
&lt;p&gt;ORC（Optimized Row Columnar）文件格式是一种高度优化的列式存储格式，它主要用于 Hadoop 生态系统中的大数据处理和分析。ORC 文件结构的设计旨在提高 I/O 效率、减少数据读取时间，并支持复杂的数据类型和压缩算法。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 四层结构 File ,Stripe,Stream，Group&lt;/h2&gt; 
&lt;p&gt;一个 File 中包含多个 Stripe，一个 Stripe 包含多个 Steam，一个 Stream 包含多个 Group，每个 Group 默认存储 1 万行数据，如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//daf79f27d162699ca73e6745cd92b780.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.2&amp;nbsp;三层索引&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt; ：文件级别各列的统计信息，用于判断 SQL 条件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;：Stripe 级别各列的统计信息，用于判断 SQL 条件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;：每个 Stripe 内部各列的索引信息，用于判断 SQL 条件是否下推。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在读取文件中数据之前，会先读取以上 3 类索引数据，根据 SQL 条件逐层进行比对，来决定是否跳过某些数据的读取，减少数据扫描量，从而提升 SQL 查询效率。&lt;/p&gt; 
&lt;p&gt;下表是只包含 id 和 name 两列的 ORC 文件的各层统计信息的案例：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//18e323617df740616d0230aa1e15ae4c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//0679ad98f36eaec4b8e50af132d4ee96.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a0ad1992999f1f653a589ab33cb184db.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.3 ORC 文件内部详细结构&lt;/h2&gt; 
&lt;p&gt;前面已经大体介绍了 ORC 文件的结构，下面详细介绍其内部结构，ORC 文件由多个逻辑层次组成，每个层次都有特定的作用和结构，下图具体描述了包含 2 列（id，name）的 ORC 文件结构图：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//51bb6963b452f9f0a51c7531681f452e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tail&lt;/strong&gt;：存储文件的元数据，如列的压缩信息、统计信息、版本等，包含了三个部分：PostScript、Footer、MetaData。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;：实际存储数据的部分，由多个 Stripe 组成。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下面分别介绍 Tail 和 Body 内部包含哪些结构：&lt;/p&gt; 
&lt;p&gt;Tail 文件尾部是读取 ORC 文件的起点，它包含了文件关键信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;PostScript&lt;/strong&gt;：存储文件的压缩类型、压缩块大小、版本信息，Footer 和 MetaData 的长度等，这部分数据不会被压缩。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Footer&lt;/strong&gt;：记录了整个文件所有列的统计信息（FileStat），所有 Stripe 的元数据信息（stripesList），加密信息（encryption）以及文件 body 长度。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;MetaData&lt;/strong&gt;：存储该文件所有 Stripe 的统计信息（StripeStat）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Body 实际存储数据的部分，由多个 Stripe 组成，每个 Stripe 包含多个 Stream，先存储索引相关的 Stream（index-Stream），后面存储实际数据相关的 Stream（data-Stream），每一列包含多个 index-Stream 和 data-Stream，Stripe 是 ORC 文件中数据存储的基本单元，每个 Stripe 数据大小一般不超过 200M，主要包含下面几块内容：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Stripe Footer&lt;/strong&gt;：包含所有 Stream 的元数据（streamsList）和加密信息（encryption）等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Index-Stream&lt;/strong&gt;：存储索引相关数据的 Stream，按列存储。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data-Stream&lt;/strong&gt;：储实际数据相关的 Stream，按列存储。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;ORC 文件的读取是从尾部最后一个字节开始的，得到 PostScript 的长度，读取 PostScript，然后根据 PostScript 中的 FooteLength，MetaDataLength 信息读取 MetaData 和 Footer，最后根据 Footer 中的 Stripe 信息读取具体的数据 Stripe，上面的文字介绍可能不是很直观，如果想更细节了解 ORC 文件结构内容可以参考（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.processon.com%2Fmindmap%2F6503c70803ab061eb31b80da&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件结构思维导图&lt;/a&gt;，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Forc.apache.org%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件官网介绍&lt;/a&gt;）。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、相关概念的理解&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 对称加解密&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1c56a2f7a82e7f369cd1548d0ef7eb36.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;对称加解密的要素包括密钥、明文、密文和加密算法。以下是对这些要素关系的描述：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密钥&lt;/strong&gt;：密钥是加密和解密过程中的关键元素，它是由随机数生成的，通常是固定长度的一串二进制数。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;明文&lt;/strong&gt;：明文是指原始的信息，可以是文本、图片、音频等各种形式的数据。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密文&lt;/strong&gt;：密文是经过加密算法处理后的数据，只有知道密钥的人才能解密还原成明文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密算法&lt;/strong&gt;：加密算法是将明文转换成密文的过程，这个过程通常涉及到一系列的数学运算，比如 AEC，RSA 等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;注意：对称加密的加密密钥，和 解密密钥是一样的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.2 文件的压缩和解压缩&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.1&amp;nbsp;压缩算法&lt;/h3&gt; 
&lt;p&gt;压缩算法是用于减小文件大小的数学方法。它通过各种技术，如替换、重新编码、差分编码、运行长度编码、字典编码、变换编码等，来减少数据的冗余和实现数据的体积缩小。压缩算法可以是无损的或有损的：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;无损压缩&lt;/strong&gt;：意味着原始数据可以完全从压缩文件中恢复，常用于文本和某些类型的数据文件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;有损压缩&lt;/strong&gt;：为了获得更高的压缩率，允许丢失一些数据，常用于图像、音频和视频文件。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h3_11&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.2 解压算法&lt;/h3&gt; 
&lt;p&gt;解压算法是压缩算法的逆过程，它用于将压缩文件恢复到其原始状态。无损压缩的解压算法能够完全恢复原始数据，而有损压缩的解压算法则可能无法完全恢复所有原始数据。&lt;/p&gt; 
&lt;p&gt;文件压缩和解压缩简单流程图如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3edcbf4fcc94f0f715892423538e2ded.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：数据的压缩算法和解压算法要一样&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.3 压缩块&lt;/h3&gt; 
&lt;p&gt;文件压缩块是指对文件进行压缩处理后生成的一组连续的数据块。在文件压缩过程中，文件被分割成多个块，每个块都经过压缩算法处理。一般来说，文件压缩块的大小可配置。例如，ZIP 压缩的每个压缩块的大小可以达到 64KB 或更大，而在其他压缩格式如 7z 中，压缩块的大小可以更大，通常为数 MB。这些大小可以根据文件的特性和压缩算法的性能进行调整，以达到更好的压缩比和解压性能。&lt;/p&gt; 
&lt;p&gt;注意：在解压文件的过程中会从文件中读取整个压缩块数据到内存之后再使用解压算法进行解压处理，所以压缩块越大每次解压读取到内存里的数据会越大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 加密压缩文件读写大致流程&lt;/h2&gt; 
&lt;p&gt;在掌握了数据加密和压缩的基础知识之后，让我们从宏观的角度了解一下 ORC 加密文件读写流程，如下图所示：在写入时，内存中的数据首先被序列化，然后压缩以减少体积，最后对数据加密。在读取时，数据首先被解密以恢复原始格式，然后解压数据得到原始数据，最后通过反序列化原始数据转换为内存对象。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cd6b640a5a79817353e9bfb6a7fe81d5.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;详细说明写入和读取过程中的各个步骤：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）写入过程（序列化、压缩、加密）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：在数据写入存储系统之前，首先需要将内存中的对象转换成可以存储或传输的格式，这个过程称为序列化。序列化后的数据通常是一个二进制格式，便于后续的处理。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;压缩&lt;/strong&gt;：序列化后的数据可能会占用较大的空间。为了减少存储需求和&lt;strong&gt;提升后续数据加密处理效率&lt;/strong&gt;，接下来对数据进行压缩。压缩算法会尝试去除数据中的冗余，从而减少数据的体积。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密&lt;/strong&gt;：压缩后的数据需要进行加密，以确保数据的安全性。加密算法会使用密钥对数据进行加密，生成密文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;存入文件中&lt;/strong&gt;：加密后的密文被存储在文件中，等待后续的读取或传输。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;（2）读取过程（解密、解压、反序列化）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;：当需要读取文件中的数据时，首先需要使用正确的密钥和加密算法对密文进行解密，恢复为压缩前的数据。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解压&lt;/strong&gt;：解密后，应用解压算法对数据进行解压，恢复到序列化前的状态。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：解压后的数据是一个二进制格式，需要进行反序列化，将其转换为内存中的对象。反序列化是序列化的逆过程，它将二进制数据转换为可读可操作的数据结构。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;内存对象&lt;/strong&gt;：经过解密、解压和反序列化之后，数据最终以内存对象的形式被程序处理。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_14&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、StarRocks 读取 ORC 加密文件实现方案&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_15&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.1 ORC 文件内部数据加密关系&lt;/h2&gt; 
&lt;p&gt;首先，介绍几个密钥的含义：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;statKey&lt;/strong&gt;：用于解密加密列的 FileStat，StripeStat 的密钥，每个列一个，加密存储在文件 Footer 里。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;dataKey&lt;/strong&gt;：用于解密加密列的 IndexData 和 RowData，每个 Stripe 的每一列都有一个，加密存储在 Stripe 的 Footer 里。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;masterKey&lt;/strong&gt;：文件的根密钥，用于解密 ORC 文件中被加密的 statKey 和 dataKey，该密钥没有存储在文件中，一般存储在 Hive 表属性上。要解密 ORC 文件中的数据，首先需要获取这个 masterKey。然而，masterKey 本身也是加密的，因此在读取 Hive 表之前，必须先从表属性中提取出加密的 masterKey,访问密钥管理服务（Key Management Service, KMS），对加密的 masterKey 进行解密，从而获得可用于实际解密操作的明文 masterKey 密钥，一旦获得了 masterKey 的明文形式，就可以用它来解密 ORC 文件中的 dataKey 和 statKey。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3f858f3c7fc6ed6c7e5dcdb8f10d2253.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下图是描述了 masterKey、statKey，dataKey 之间的关系，灰色部分代表是存储在文件中被加密的数据，绿色部分则是解密之后的数据，包括我们解密后的 statKey，dataKey。获得这两个密钥之后分别用于解密统计信息和文件中的真实数据。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.2 StarRocks 读取 ORC 加密文件流程&lt;/h2&gt; 
&lt;p&gt;在深入掌握了 ORC 文件中密钥的相互关系和功能后，我们现在转向探讨 StarRocks 是如何读取 ORC 加密表的数据。这个过程如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b39f8da7c9f25c2316cbbb845730a54b.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）提交 SQL 查询&lt;/strong&gt;：用户首先通过 SQL 客户端向 StarRocks FE 节点提交查询请求。这通常涉及到对 Hive 表下存储的 ORC 加密文件进行读取操作。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）获取解密的 masterKey&lt;/strong&gt;：查询提交后，系统首要根据 SQL 获取 Hive 表中的 ORC 文件所需的 masterKey。这个 masterKey 一般存储在表属性里，并且是加密存储的，必须调用 KMS 服务来解密，得到密钥明文。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）传递 masterKey 明文&lt;/strong&gt;：解密后的 masterKey，以明文形式传递给 StarRocks BE 节点。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）读取并解密密钥&lt;/strong&gt;：BE 拿到已解密的 masterKey 之后，读取并解密 ORC 文件中的 statKey 和 dataKey，这两个密钥分别用于解密统计信息（FileStat，StripeStat）和实际数据内容，为接下来的统计信息和数据解密做准备。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）使用 statKey 和 dataKey 解密数据&lt;/strong&gt;：BE 使用 statKey 来解密文件的统计信息（fileStat 和 StripeStat）同时使用 dataKey 来解密实际的数据内容。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.3 读取 ORC 加密文件的关键实现细节&lt;/h2&gt; 
&lt;p&gt;通过了解前文 StarRocks 读取 ORC 加密文件流程，我们将深入探讨读取 ORC 加密文件的数据关键实现细节。首先，我们提出一个问题：在物理存储中，文件存储的是什么内容？答案是二进制数据。这些二进制数据通常会经过压缩处理。&lt;/p&gt; 
&lt;p&gt;ORC 文件的读取流程是自外向内的，类似于&lt;strong&gt;剥洋葱的过程&lt;/strong&gt;，逐步深入到我们需要读取的目标数据。读取流程可以概括为：首先读取文件元数据，通过元数据获取目标数据的偏移量（offset）和数据长度如下图所示，然后通过流的方式读取目标数据。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e9be4bd8a50aa1870bb661641f960c6e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具体到 ORC 加密文件的读取实现代码，主要采用了设计模式中的装饰模式方式来组织代码的。在这个模式中，原始的文件流（SeekableFileInputStream）首先被解密流（DecryptionInputStream）所包装，如果是非加密文件就没有这一层，然后解密流又被解压缩流（DecompressionStream）所包装。每一层流都只负责向其包装的流请求数据，并在接收到一定量数据后开始处理自己的逻辑。如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//97de9ae2095fa9576fac708b4fe83419.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;这种分层的方法保证每一层都专注于自己的职责，共同协作完成 ORC 文件的读取任务。通过这种方式，我们不仅能够高效地读取 ORC 文件，还能确保数据的安全性和完整性。综上所述，ORC 文件的读取流程是一个从文件元数据到具体数据内容的逐步深入过程。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.4 加密字段跳读机制&lt;/h2&gt; 
&lt;p&gt;为了提升数据的查询效率，查询数据时会根据索引数据跳过不必要的数据读取，下面我们介绍加密列跳读机制，理解了这部分的内容，就能非常清晰的知道，读取加密字段时，对数据解密与解压是怎样协作的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.1 加密块与压缩块的关系&lt;/h3&gt; 
&lt;p&gt;加密列的数据划分了多个加密块与压缩块，一个压缩块，包含多个加密块，读取数据时，先对每个加密块进行解密，解密多个加密块之后，把这些解密后的数据块合并成一个完整的压缩块，然后对这个压缩块进行解压得到原始数据下图是加密块与压缩块的关系图：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cf9450e0def2e8eb5a9cbe6abbfde7fe.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_20&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.2 ORC 文件使用的加解密算法和模式&lt;/h3&gt; 
&lt;p&gt;下图描述了具体的数据加解密过程中以及设计到整个过程中各种元素输入输出的关系：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4f53e022e28a5159e3253e08d126e357.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：同一个数据块（16 字节）加密过程和解密过程中的，密钥、IV 值、加密算法和加密模式必须相同。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;明文块&lt;/strong&gt;：我们对 ORC 文件加密使用的加密算法是 AES-128-CTR/NoPadding，该算法加密数据时 ，会把明文按照 16 个字节划分多个块，每个块加密之后得到的数据就是加密块。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密块&lt;/strong&gt;：每个明文数据块加密之后得到的数据就是加密块。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;初始向量 IV&lt;/strong&gt;：初始向量 IV 的作用是使加密更加安全可靠（加盐），我们使用 AES 加密时需要主动提供这个初始向量 IV，而且只需要提供一个初始向量就够了，后面每个数据块的加密向量由加密模式决定，所以每个数据块的加密向量都不一样。初始向量 IV 的长度规定为 128 位 16 个字节，ORC 文件解密参数 IV 的描述如下：总共 16 个字节，前面 8 个字节分别存储：列 ID，Stream 类型，Stripe 的 ID ，后面 8 个字节用于填充 min_count，由于我们使用的是 CTR 加密模式，所以这个 min_count 就是加密块在整个加密数据中的计数，iv 各个内容长度定义如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7a5939566e16aa553d81b75f3c0936fd.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;密钥&lt;/strong&gt;：AES 要求密钥的长度可以是 128 位 16 个字节、192 位或者 256 位，位数越高，加密强度自然越大，但是加密的效率自然会低一些，因此要做好权衡。我们开发通常采用 128 位 16 个字节的密钥，我们使用 AES 加密时需要主动提供密钥，而且只需要提供一个密钥就够了，每个数据块加解密使用的都是同一个密钥。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密模式&lt;/strong&gt;：有 5 种加密模式，这些加密模式的主要目的是为了&lt;strong&gt;不让重复的明文加密之后得到的密文一样&lt;/strong&gt;，提升数据安全性，我们使用的是 CTR 模式（计数器模式）对数据加密，那解密的时候也需要 CTR 模式对数据解密，计数器模式介绍请参考链接，CTR 模式，的 iv 参数，包含了，加密块计数（min_count），所以，每次对一个加密块解密时，需要知道，当前加密块的初始计数值。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.3 举例说明跳读流程&lt;/h3&gt; 
&lt;p&gt;学习了前面读取加密数据的关键细节之后，举个例子说明跳读 ORC 文件流程，假设根据索引数据和查询条件确定需要读取某个文件中第 1 个 Strip 中第 1 列的第 5 个 group 的数据，那么我们知道 group5 数据的偏移量 offset，文件结构如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//84f4126e46e2dcc2d4149f24ffab44c2.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具体逻辑大体流程如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//712c47a3adf74ce35e0044d5b87e8498.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：解压数据块时，必须把当前解压块的所有数据读出来才能使用对应的解压算法解压数据。&lt;/p&gt; 
&lt;p&gt;1）group5 数据的偏移量 group_offset 计算出 group5 数据在哪个压缩块里,计算公式为：block_index = group_offset/zipBlockSize（压缩块大小），并得到该压缩块的起始位置 zip_head_offset 公式为：zip_head_offset = block_index*zipBlockSize。&lt;/p&gt; 
&lt;p&gt;2）获取 zip_head_offset 位置对应的加密块计数，加密块计数值计算公式为：min_count = zip_head_offset/encrypted-size（加密块大小） 更新 iv 向量的 min_count 值。&lt;/p&gt; 
&lt;p&gt;3）文件读指针定位到 zip_head_offset，开始读取压缩块的数据，这个压缩块的数据全部读出之后，使用解压算法进行解压。&lt;/p&gt; 
&lt;p&gt;4）通过 group5 在解压的数据上偏移量和长度，读取 group5 数据，然后再对数据进行解码。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_22&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;六、问题解答&lt;/h1&gt; 
&lt;p&gt;通过前面对相关内容的讲解，下面我们来解答前文提出的问题：&lt;/p&gt; 
&lt;p&gt;1）文件解压是否意味着一定是对整个文件进行解压操作？&lt;/p&gt; 
&lt;p&gt;答：不需要，文件是按照一定大小划分出若干个压缩块，只要读出相应的压缩块进行解压就行。&lt;/p&gt; 
&lt;p&gt;2）ORC 文件究竟是如何做到在不扫描全文件的情况下就能精准查询到想要的数据？&lt;/p&gt; 
&lt;p&gt;答：ORC 文件有三层索引，在读取文件数据之前先读取各层级的索引信息，根据过滤条件过滤掉不必要的数据扫描，从而提升数据查询效率。&lt;/p&gt; 
&lt;p&gt;3）当 SQL 查询条件不符合最左前缀原则时，其索引效果是否就会失效呢？&lt;/p&gt; 
&lt;p&gt;答：不会失效，ORC 文件是列式存储的，各列信息都是相互独立的，有自己的索引信息，与行式数据库的索引最左前缀规则不同。&lt;/p&gt; 
&lt;p&gt;4）数据加密、解密、解压以及压缩之间的关联关系到底是怎样的？&lt;/p&gt; 
&lt;p&gt;答：请参考本文：5.1 ORC 文件内部数据加密关系，内容。&lt;/p&gt; 
&lt;p&gt;5）在写加密列数据时，为什么不是先加密数据再压缩，而是先压缩后加密？&lt;/p&gt; 
&lt;p&gt;答：主要是为了提升加密效率，数据被压缩处理之后，数据量变少了，加密效率就提升了。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_23&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;七、总结&lt;/h1&gt; 
&lt;p&gt;本文介绍了 StarRocks 数据库如何读取 ORC 文件的加密数据，包括相关概念理解、ORC 文件介绍、以及 StarRocks 读取加密 ORC 文件的具体实现方案。阐述了出于数据安全的需要，对 Hive 表中的敏感数据进行加密存储的必要性，介绍了对称加密、文件压缩与解压、加密压缩文件读写流程等概念，深入探讨了 ORC 文件的三层结构和索引机制，以及如何利用这些特性实现高效查询加密数据。还详细描述了 StarRocks 读取加密 ORC 文件的流程，包括获取解密的 masterKey、使用 masterKey 解密 ORC 文件中的密钥、以及使用这些密钥解密数据。&lt;/p&gt; 
&lt;p&gt;希望通过本文对 ORC 加密文件读取功能的实现细节，让读者对 ORC 文件的理解更深刻。最后如果想从代码层面了解 ORC 文件解密过程可以参考&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FStarRocks%2Fstarrocks%2Fpull%2F46809&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;开源 PR&lt;/a&gt;。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18015502</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18015502</guid>
            <pubDate>Thu, 27 Mar 2025 07:23:58 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>AI 产品榜最新统计数据：夸克成国内唯一月活破亿 AI 应用</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 产品榜最新统计数据显示，2025 年 2 月份中国 AI 应用中仅夸克 MAU 破亿。AI 产品榜认为，中国互联网巨头即将拉开 AI 超级应用争夺战，而阿里夸克凭借 MAU 优势取得领先身位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;355&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a4a2edf6a5ba93c9a47715cca6b9c4c06f7.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 产品榜指出，以阿里、腾讯、字节为代表的中国互联网巨头纷纷将战略重心转向 AI，他们将重燃战火，争夺 AI 时代的超级应用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 13 日，阿里巴巴宣布推出 AI 旗舰应用——新夸克。全新夸克基于阿里通义领先的推理及多模态大模型，宣布告别传统搜索，升级为一个 All in One 的「AI 超级框」，满足用户工作、学习、生活的各类 AI 需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;夸克用户规模上的领先，很大程度上源于夸克对于产品价值的定位。阿里巴巴集团副总裁吴嘉近日在接受采访时就指出，「夸克的核心定位还是希望成为一个服务广大用户的有用的 AI 产品。我们的目标始终是成为 AI 时代体验领先的「超级入口」，让夸克通过‘AI 超级框’重构人与信息和任务的交互方式，成为覆盖工作、学习、生活的‘全能助手’。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;知名投资人、金沙江创投董事总经理朱啸虎前不久也在公开场合指出，AI 应用将迎来爆发，新的超级应用将不局限于 Chat 形态，要做成 AI 超级应用要足够易用、有产品创新。他提到像夸克就提供了一个好思路，通过一个「AI 超级框」连接用户与智能体。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，AIGCRank 最新一期发布的《中国 AI 应用排行榜》亦显示，在 2 月份的榜单中，夸克以日活用户 3429.8 万，连续两个月稳居行业第一。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341335</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341335</guid>
            <pubDate>Thu, 27 Mar 2025 07:20:58 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>DuckDB 路线图发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 是一个高性能的分析型关系数据库，旨在实现高效的数据分析，由非盈利组织 DuckDB 基金会管理。它易于安装，运行速度非常快，并且可以在进程内 (in-process) 运行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;项目团队发布了最新的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fstable%2Fdev%2Froadmap.html&quot; target=&quot;_blank&quot;&gt;发展路线图&lt;/a&gt;，具体内容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Planned Features (March 2025)&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 团队计划在来年开发的功能：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#fafafa; color:#0d0d0d&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fextension-template-c&quot; target=&quot;_blank&quot;&gt;C extension API&lt;/a&gt;&amp;nbsp;的文档&lt;/li&gt; 
 &lt;li&gt;Generic ODBC catalog，类似于现有的 PostgreSQL / MySQL / SQLite 集成&lt;/li&gt; 
 &lt;li&gt;支持 Go 和 Rust 扩展&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fextensions%2Ficeberg&quot; target=&quot;_blank&quot;&gt;通过 iceberg 扩展&lt;/a&gt;改进了对 iceberg 格式的支持&lt;/li&gt; 
 &lt;li&gt;用于模式匹配的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3994&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MATCH RECOGNIZE&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用缓冲区管理器缓存远程文件内容（例如，在 S3 上查询 Parquet 文件时）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Future Work&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;计划在未来的某个时间点完成以下实现：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;时间序列优化&lt;/li&gt; 
 &lt;li&gt;分区感知优化&lt;/li&gt; 
 &lt;li&gt;排序感知优化&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4512&quot; target=&quot;_blank&quot;&gt;数据库文件加密&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用自动维护的 table samples 进行更好的&amp;nbsp;Filter Cardinality Estimation&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fissues%2F14817&quot; target=&quot;_blank&quot;&gt;Parallel Python UDF&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4204&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;ALTER TABLE&lt;/code&gt;支持添加外键&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;查询分析的改进（尤其是对于并发运行的查询）&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F9547&quot; target=&quot;_blank&quot;&gt;XML 读取支持&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3638&quot; target=&quot;_blank&quot;&gt;Materialized views&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F13396&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MERGE&lt;/code&gt;statement&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3560&quot; target=&quot;_blank&quot;&gt;支持异步 I/O&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F8104&quot; target=&quot;_blank&quot;&gt;支持 PL/SQL 存储过程&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341325/duckdb-roadmap</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341325/duckdb-roadmap</guid>
            <pubDate>Sun, 23 Mar 2025 06:37:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Ferrous Systems 向 Rust 项目捐赠 Ferrocene 语言规范</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rust 基金会发文&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frustfoundation.org%2Fmedia%2Fferrous-systems-donates-ferrocene-language-specification-to-rust-project%2F&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;，Ferrous Systems 已同意将其 Ferrocene 语言规范 (FLS) 贡献给 Rust 项目。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&quot;这笔慷慨的捐赠将为提供官方 Rust 规范提供更清晰的途径。它还将使 Rust 项目能够监督其持续发展，为已经依赖 FLS 的公司和个人提供信心，并标志着 Rust 生态系统的一个重要里程碑。&quot;&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;245&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b43895946bbb58b8a614809fc729137ed7e.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;众所周知，Rust 一直缺乏一份官方的语言规范。2022 年 12 月，Rust 项目提交了一份 RFC 以鼓励 Rust 项目开始制定规范。该 RFC 于 2023 年 7 月获得批准，并开始工作的推进。起初，Rust 项目规范团队（t-spec）希望以 Rust Reference 为指导，从头开始创建文档。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但考虑到现有的一份被广泛应用的外部 Rust 规范 -- FLS。为避免行业内存在两种高度可见的 Rust 规范而造成的潜在混淆，t-spec 团队决定尝试将 FLS 与 Rust Reference 集成以创建官方 Rust 项目规范。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;FLS 是对 Rust 编程语言的描述，由 Ferrous Systems 于 2022 年 7 月开发，Ferrocene 是专为安全关键型和受监管行业设计的 Rust 编译器和工具链。FLS 为 Rust 的语法、语义和行为提供了结构化和详细的参考，可作为验证、合规性和标准化工作的基础。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在经过沟通后，Ferrous Systems 同意将其 FLS 贡献给 Rust 项目，并允许 Rust 项目接管其开发和管理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告指出，FLS 集成到 Rust 项目会有一个过渡期。第一阶段的工作将涉及将 FLS 整合到项目的工具和流程中，以符合现有的 Rust 项目目标。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「一旦集成完成，Ferrous Systems 将能够依赖该项目的规范版本并停止使用自己的版本。更广泛地说，这项工作将为其他需要 Rust 规范的人提供官方、权威的参考，帮助他们使用 Rust 编程语言。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</guid>
            <pubDate>Sun, 23 Mar 2025 06:27:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>李想官宣开源整车操作系统</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;李想又抛了一个重磅核弹：&lt;strong&gt;理想汽车要开源汽车操作系统&lt;/strong&gt;！&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;450&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/140153_niCC_2720166.png&quot; width=&quot;850&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;理想汽车董事长兼 CEO 李想在今天上午举办的中关村论坛年会上宣布理想汽车自研整车操作系统——&lt;strong&gt;「理想星环 OS」全面开源，4 月登陆开源社区，成为全球首个将整车操作系统开源的车企&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;563&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/140214_PaFU_2720166.png&quot; width=&quot;1000&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲理想星环 OS 架构&lt;/p&gt; 
&lt;p&gt;李想认为，智能汽车需要专用的操作系统，但每个企业都进行闭源开发会导致资源浪费，延缓行业发展。同时，李想指出，开源生态有助于车企节约研发成本，最终普惠终端消费者。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/140225_ublh_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲理想星环 OS 可有效节约硬件资源&lt;/p&gt; 
&lt;p&gt;长期以来，在汽车电子控制单元（ECU）的标准化软件架构上，基于 AUTOSAR（AUTomotive Open System ARchitecture）架构的操作系统占据行业主导地位。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/140237_0776_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲AUTOSAR 的作用&lt;/p&gt; 
&lt;p&gt;尽管该架构本身是开放标准，联盟成员里也有一汽、上汽、华为等国内公司深度参与，但里面的核心大厂其实还是传统欧美汽车产业巨头在主导。&lt;/p&gt; 
&lt;p&gt;同时，使用该架构的工具链需要支付高额授权费，加之闭源系统适配一款新的芯片要 6 个月，耗费大量人力，不确定性强。&lt;/p&gt; 
&lt;p&gt;对此，理想汽车开源整车操作系统打破「黑盒化」技术壁垒，再加之开源能够帮助企业降低基础研发投入，避免资源浪费。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;em&gt;来源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fx--tVE4jRT3tOwmglULGwg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/x--tVE4jRT3tOwmglULGwg&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341314</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341314</guid>
            <pubDate>Sun, 23 Mar 2025 06:02:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>英伟达计划收购贾扬清的创企 Lepton AI</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;The Information 报道称，英伟达正洽谈收购初创公司 Lepton AI，此次交易价值数亿美元。此举被认为是英伟达进军云计算和企业软件市场的一部分，旨在与亚马逊和谷歌等主要云计算提供商展开竞争。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;302&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-df08b6fc0c14edc200906b275dd01be2425.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Lepton AI 成立于 2023 年，由阿里云前副总裁贾扬清创办，是一家专注于构建高性能 AI 训练与推理平台。2023 年 5 月，Lepton AI 完成了 1100 万美元（折合人民币约 7900 万元）天使轮融资，由 Fusion Fund 基金和 CRV 风投两家机构投资。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，Lepton AI 主要发布了两款产品&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;FastGPU：2024 年 6 月上线的云 GPU 解决方案，主打经济高效和可靠。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;Lepton Search：2023 年 12 月推出的对话式搜索引擎，基于 Lepton AI 平台实现，代码量不到 500 行。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341312/nvidia-advanced-talks-acquire-lepton</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341312/nvidia-advanced-talks-acquire-lepton</guid>
            <pubDate>Sun, 23 Mar 2025 05:50:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌将 Android OS 完全转变为「内部开发」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Android Authority &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.androidauthority.com%2Fgoogle-android-development-aosp-3538503%2F&quot; target=&quot;_blank&quot;&gt;发布独家报道称&lt;/a&gt;&lt;/u&gt;，谷歌调整了针对 Android OS 的开发策略，&lt;strong&gt;未来 Android OS 将完全转变为「内部开发」&lt;/strong&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;谷歌已确认 Android OS 的开发将很快完全在「私有环境」中进行&lt;/li&gt; 
 &lt;li&gt;目前，谷歌会在公开的 AOSP Gerrit 上分享一些工作，但未来所有的工作都将在「私有环境」中进行&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;将&amp;nbsp;Android OS 将完全转变为「内部开发」是为了简化开发流程&lt;/strong&gt;，对外部开发者没有影响，谷歌承诺在每次发布新版操作系统后仍会将源代码更新到 AOSP&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2390338a0fc5120e9ddaf4181dad39a2051.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;根据报道，谷歌正在从根本上改变未来开发 Android 的方式，将相关开发工作流程彻底转向内部分支。&lt;strong&gt;这些内部分支仅供 Google 员工和拥有 Google 移动服务 (GMS) 许可的合作公司使用，例如三星和摩托罗拉&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;谷歌解释称，这一变化是为了简化开发工作流程和软件发布。这是近期主干开发趋势的延续。该公司表示，他们花了多少工作来保持内部开发分支和公共 AOSP 分支之间的同步，而这些分支在功能和 API 支持上会有所不同。合并开发应该可以让他们摆脱这些复杂性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;为了平衡 AOSP 的开源性质与产品开发策略，谷歌维护了两个主要的 Android 分支：公开的 AOSP 分支和内部开发分支。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;AOSP 分支面向所有人开放，而谷歌的内部分支仅限于拥有谷歌移动服务（GMS）许可协议的公司访问。虽然诸如 Android 蓝牙协议栈等一些 OS 组件是在 AOSP 分支中公开开发的，但大多数组件，包括核心 Android OS 框架，都是在谷歌的内部分支中私下开发的。&lt;/p&gt; 
&lt;p&gt;现在，&lt;strong&gt;谷歌已确认将把所有 Android OS 开发转移到其内部分支&lt;/strong&gt;，这一变化旨在简化其开发流程。&lt;/p&gt; 
&lt;p&gt;虽然发生了这一转变，但谷歌重申了其对开源的承诺。它继续致力于在完成开发和准备发布版本后将后续 Android 版本的最终源代码发布到 AOSP，坚持成品的开源性质。&lt;/p&gt; 
&lt;p&gt;谷歌很可能会在不久的将来宣布有关这一开发流程变化的更多信息，这些变化可能会在一周内生效。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341310/google-android-development-aosp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341310/google-android-development-aosp</guid>
            <pubDate>Sun, 23 Mar 2025 05:37:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Warm-Flow 过去、现在和未来都不会有商业版</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;h1&gt;Warm-Flow 过去、现在和未来都不会有商业版&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Warm-Flow 从 24 年 2 月加入 Dromara 开源社区，也正是由于加入他，Warm-Flow 才等到更多人的关注和帮助。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同时吸引了不少贡献者，有的也成为了 Warm-Flow 的成员。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;因此为了回馈大家，也是为了 Warm-Flow 更好的发展，再次申明&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;过去、现在和未来都不会有商业版！！！&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;所以还请大家不用担心，该有的功能陆续都会加上去，敬请期待！&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;事件&lt;/li&gt; 
 &lt;li&gt;子流程&lt;/li&gt; 
 &lt;li&gt;会签和票签通过率策略，支持扩展&lt;/li&gt; 
 &lt;li&gt;重启流程&lt;/li&gt; 
 &lt;li&gt;包容网关&lt;/li&gt; 
 &lt;li&gt;动态表单&lt;/li&gt; 
 &lt;li&gt;仿钉钉设计器&lt;/li&gt; 
 &lt;li&gt;取回&lt;/li&gt; 
 &lt;li&gt;撤销&lt;/li&gt; 
 &lt;li&gt;实体类、dto、vo 等独立成一个模块，方便微服务接入&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;项目介绍&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Dromara Warm-Flow 国产工作流引擎，其特点简洁轻量，五脏俱全，灵活扩展性强，是一个可通过 jar 引入设计器的工作流。&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;支持常见审批功能、监听器与流程变量、条件表达式、办理人变量表达式&lt;/li&gt; 
 &lt;li&gt;自带流程图、流程设计器、节点扩展属性&lt;/li&gt; 
 &lt;li&gt;支持常见的 orm 框架&lt;/li&gt; 
 &lt;li&gt;支持不同的数据库&lt;/li&gt; 
 &lt;li&gt;生态丰富可扩展，文档全面&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;&lt;strong&gt;功能思维导图&lt;/strong&gt;&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src=&quot;https://oscimg.oschina.net/oscnet//2e2cf041b103c7d70aa49f71b2eb2d72.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;流程图&lt;/strong&gt;&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src=&quot;https://oscimg.oschina.net/oscnet//e7b50dfdeb4fac83b405024b890982da.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;演示地址&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.hhzai.top&quot; target=&quot;_blank&quot;&gt;http://www.hhzai.top&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;账号密码：admin/admin123&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;官网&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwarm-flow.dromara.org&quot; target=&quot;_blank&quot;&gt;https://warm-flow.dromara.org&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Warm-Flow 视频&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1AWRGYEEVr%2F%3Fspm_id_from%3D333.1387.0.0%26vd_source%3D1be886ace16159801f6ed0106df215d9&quot; target=&quot;_blank&quot;&gt;Warm-Flow 初体验&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341305</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341305</guid>
            <pubDate>Sun, 23 Mar 2025 04:27:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>OpenAI 将完成 400 亿美元融资：软银领投、估值 3000 亿美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-26%2Fopenai-close-to-finalizing-its-40-billion-softbank-led-funding&quot; target=&quot;_blank&quot;&gt;据知情人士透露&lt;/a&gt;&lt;/u&gt;，OpenAI 即将完成由软银集团领投的 400 亿美元融资，包括 Magnetar Capital、Coatue Management、Founders Fund 和 Altimeter Capital Management 在内的投资者正在洽谈参与。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/113653_D5HA_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;据多名知情人士透露，总部位于伊利诺伊州埃文斯顿的对冲基金 Magnetar Capital 可能会注资高达 10 亿美元。由于信息属于保密性质，这些知情人士均要求不具名。&lt;/p&gt; 
&lt;p&gt;OpenAI、Magnetar 和 Founders Fund 的代表拒绝就此轮融资发表评论。Coatue 和 Altimeter 尚未立即回应置评请求。&lt;/p&gt; 
&lt;p&gt;根据研究公司 PitchBook 汇编的数据，这家人工智能开发商的这轮融资将是有史以来规模最大的一轮融资。这笔交易将使该公司的估值达到 3000 亿美元，几乎是 ChatGPT 制造商去年 10 月融资时 1570 亿美元的估值的两倍。&lt;/p&gt; 
&lt;p&gt;据一位知情人士透露，作为交易的一部分，软银将向该公司投资 75 亿美元，外加来自投资者财团的 25 亿美元。这位知情人士表示，今年晚些时候还将有第二笔 300 亿美元的投资，其中 225 亿美元来自软银，75 亿美元来自投资者财团。&lt;/p&gt; 
&lt;p&gt;软银拒绝置评。这家日本企业集团已向星际之门项目投入了数十亿美元，该项目是与 OpenAI、甲骨文公司和 MGX 等合作伙伴在德克萨斯州阿比林成立的合资企业。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341284/openai-close-to-finalizing-its-40-billion-softbank-led-funding</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341284/openai-close-to-finalizing-its-40-billion-softbank-led-funding</guid>
            <pubDate>Sun, 23 Mar 2025 03:38:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>2024 年度「中国科学十大进展」发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2025 年 3 月 27 日，国家自然科学基金委员会&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FNE2935ZMmTN1Ixd04orn6w&quot; target=&quot;_blank&quot;&gt;发布&lt;/a&gt;了 2024 年度「中国科学十大进展」，分别为：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;嫦娥六号返回样品揭示月背 28 亿年前火山活动&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;实现大规模光计算芯片的智能推理与训练&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;阐明单胺类神经递质转运机制及相关精神疾病药物调控机理&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;实现原子级特征尺度与可重构光频相控阵的纳米激光器&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;发现自旋超固态巨磁卡效应与极低温制冷新机制&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;异体 CAR-T 细胞疗法治疗自身免疫病&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;额外 X 染色体多维度影响男性生殖细胞发育&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;凝聚态物质中引力子模的实验发现&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;高能量转化效率锕系辐射光伏微核电池的创制&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;发现超大质量黑洞影响宿主星系形成演化的重要证据&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;302&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b9a7717267f93f463b0853bd1f6c5ae250f.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341273</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341273</guid>
            <pubDate>Sun, 23 Mar 2025 03:23:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>美图 AI 素材生成器 WHEE 接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;美图公司旗下的 AI 素材生成器 WHEE 近日&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9Sa0Q68P-74QR8WKhXg47Q&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;成功接入&amp;nbsp;DeepSeek R1 满血版。此举旨在将 DeepSeek 的专业提示词设计能力与 WHEE 的易用性相结合，帮助用户在无专业背景的情况下轻松生成高质量的图像内容。用户只需输入简单的词汇，AI 便能一键生成专业提示词，大大降低了使用门槛。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此次 WHEE 接入 DeepSeek R1，通过提示词优化功能，能够自动补全光影、构图和风格等关键词，从而生成更为丰富和完整的文案内容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;350&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-025674c89918714c860c2c35557502b8f99.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;WHEE 的相关负责人指出，DeepSeek 的接入不仅是功能上的叠加，更是一个 「翻译器」 和 「灵感孵化器」，能通过多种方案的对比来激发创作者的灵感。借助 DeepSeek 强大的语义理解和联想能力，WHEE 希望降低创作者的使用门槛，助力创意的精准落地。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，美图公司旗下的多款产品，如美图设计室、开拍、WHEE、MOKI 等均已接入 DeepSeek R1。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341261</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341261</guid>
            <pubDate>Sun, 23 Mar 2025 03:02:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 预估 2025 年营收将达到 127 亿美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-26%2Fopenai-expects-revenue-will-triple-to-12-7-billion-this-year&quot; target=&quot;_blank&quot;&gt;据彭博社今日报道&lt;/a&gt;&lt;/u&gt;，OpenAI 预估其 2025 年营收将达到 127 亿美元（约合 923 亿元人民币），相比 2024 年 37 亿美元（约合 269 亿元人民币）的营收翻了超三倍。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/103323_ghkE_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在该预估基础上，OpenAI 预计其 2026 年营收将达到 294 亿美元（约合 2,136.8 亿元人民币），2029 年更将超过 1,250 亿美元（约合 9085.2 亿元人民币）。&lt;/p&gt; 
&lt;p&gt;报道指出，OpenAI 此前正与软银集团进行谈判，软银计划以 2600 亿美元估值向 OpenAI 注资 400 亿美元，部分资金将用于 OpenAI 与软银、甲骨文联合成立的 Stargate 项目；此外，OpenAI 还一直在与监管机构谈判，计划从非营利组织转变为更传统的营利性公益公司。&lt;/p&gt; 
&lt;p&gt;产品迭代方面，&lt;a href=&quot;https://www.oschina.net/news/341240/openai-agents-sdk-mcp&quot;&gt;OpenAI 在今日凌晨对 Agent SDK 进行了重大更新&lt;/a&gt;：支持大模型上下文协议 MCP。&lt;/p&gt; 
&lt;p&gt;目前，OpenAI 已经在开源的 Agent SDK 中支持 MCP，API 和桌面版 ChatGPT 也将很快提供。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341252</guid>
            <pubDate>Sun, 23 Mar 2025 02:34:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>算力，并不是大模型厂商发展的护城河</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;p&gt;上个月，OpenAI CEO 山姆·奥尔特曼在社交媒体上表示，号称 52 万亿参数量的 GPT-5 将在数月内发布。相较于上一代 GPT-4 的 2 万亿参数，体量上足足增长了 26 倍，虽无公布具体的训练成本，但想必也一定是个天文数字，堪称大模型领域的「力大砖飞」。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b5d3d49a58e00ea764875a0cd773ce57.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;反观 LLM 界的「黑天鹅」，DeepSeek-V3 却仅用了 2048 块英伟达 H800 ，耗费了 557.6 万美金就完成了训练，一度引起硅谷恐慌，力证了：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;并非不可逾越的堡垒。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;一边是暴力填鸭，一边是技术深化，2025 年的大模型似乎走出了两条截然不同的道路，也逐渐撕开了 AI 行业最残酷的真相：&lt;strong&gt;早期以「&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;」建立护城河的大模型厂商们，在面对新一轮技术冲击时，高成本的算力反而成为了其灵活发展的累赘。&lt;/strong&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_1&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;算力的必要性和局限性&lt;/h3&gt; 
 &lt;p&gt;作为数字经济的「新电力」，算力在大模型的训练和推理过程中确实起到了不可或缺的作用。&lt;/p&gt; 
 &lt;p&gt;以 OpenAI 为例，早期在 GPT-4 的训练中，大概就使用了 25000 个 A100 芯片。如果 OpenAI 云计算的成本是差不多 1 美元/每 A100 小时的话，那么在这样的条件下，&lt;strong&gt;仅一次训练的成本大约是 6300 万美元&lt;/strong&gt;，同期还不乏实验、试错以及其他成本。OpenAI 的技术负责人直言：「每一次模型迭代都需要近乎天文数字的算力支撑。」&lt;/p&gt; 
 &lt;p&gt;而在推理成本方面，截至 2024 年 3 月，OpenAI 就已花费 40 亿美元租用微软的服务器集群，该集群相当于 35 万个英伟达 A100 芯片，算力消耗不可谓不大。&lt;/p&gt; 
 &lt;p&gt;反观国内，同样印证了这一规律。2025 年初，南京智算中心联合寒武纪，基于 7280 块国产 AI 加速卡构建全国产化算力平台，以运行 DeepSeek 671B 大模型，在供应链优化、智能客服等零售场景实现毫秒级响应。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2f8b6f62899001ee832509d86ebb956b.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;南京智算中心机房，来源：南京智算中心&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;这二者的共性在于：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;始终是&lt;/strong&gt;&lt;strong&gt;大模型&lt;/strong&gt;&lt;strong&gt;研发的「基础设施入场券」&lt;/strong&gt;，正如 DeepSeek 技术白皮书所言：大模型的竞争，首先是算力基础设施的竞争。&lt;/p&gt; 
 &lt;p&gt;但其实，「算力」本质上是一种「商品化」资源，自带经济周期属性，随着硬件成本的下降和云服务的普及，算力也逐渐脱离卖方市场，一些囤货居奇的算力厂商更是很难转型。&lt;/p&gt; 
 &lt;p&gt;比如，2023 年 AI 大模型热潮期间，算力需求呈爆发式增长，英伟达 H100 8 卡节点年租金峰值达到 20 万元，而随着大模型从训练阶段转向推理阶段，算力需求骤减（训练需千卡级，推理仅需单卡级），2024 年 H100 8 卡节点年租金跌至 6 万，很多中小型企业也能依靠算力租用跑步入场。&lt;/p&gt; 
 &lt;p&gt;而在算力租赁市场，截至去年，很多算力中心都出现了出租率不高、回款周期长，甚至一些底子不深的厂商直接关停一半机房，以降低日常运营成本。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5fb3eacaa5d6decdecd8eaf02618394d.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;来源：《&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;算力&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;荒，自主化智算还有必要吗？》-脑极体&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;可见，大模型厂商早期在硬件性能和算力中心上的建设，虽然能够在短期内加速模型的训练和推理，但并不意味着竞争对手无法通过硬件设施的「经济逆周期」，以及技术优化实现弯道超车，这就是「算力」这一大模型发展的必要资源所刻在骨子里的局限性。&lt;/p&gt; 
 &lt;p&gt;直至 DeepSeek 的出现，「卡多模优」的大模型发展格局，彻底失去优势。&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;护城河的重构：从「堆料」到「四维壁垒」&lt;/h3&gt; 
 &lt;p&gt;相较於单纯的硬件「堆料」，模型创新、数据规模、算法工程及生态构建的四维能力矩阵，正成为越来越多大模型厂商穿越周期的关键壁垒。2025 年行业数据显示，头部厂商研发投入中，算法优化（ 38% ）与场景化工程（ 27% ）的占比已超过硬件采购（ 25% ），书写新竞争法则——&lt;strong&gt;效率优先于规模。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;以 DeepSeek 为例，通过「三维创新体系」重构行业范式：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;模型层，首创「神经元动态剪枝+混合精度训练」架构，使 1.6 万亿参数模型体积压缩 80% ，推理速度提升 500%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;数据层，构建金融/政务领域「知识-行为-反馈」三元数据闭环，标注成本降低 65%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;而在跟算力相关的工程层，其分布式训练调度系统，将千卡集群利用率从 58% 提升至 92%。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//93414f30d7f61d6d5973d26012e11932.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;凭借这套组合拳下来，DeepSeek 训练成本降至同期竞品的 17% ，这种「技术驱动型」增长，不仅是对思维链突破、数据处理、系统优化等技术的最佳诠释，甚至使得 DeepSeek 利润猛增。&lt;/p&gt; 
 &lt;p&gt;以行业具体实施来看。在算力的制约下，长足以来，业内很多人都不太看好 MaaS 这样的商业模式，因为 MaaS 的核心成本是算力租赁，依赖 API 调用按 token 计费，本质上可以看作为「算力批发」——&lt;strong&gt;想要赚钱，你就得投入大量算力储备，保证高并发和弹性伸缩，碰上 API 价格内卷，很多厂商根本负担不起高额得硬件投入。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1ef35030fdc620a594a6096008472682.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;但随着 DeepSeek 出现，通过大规模的并行（包括数据并行和专家并行），尽可能为每个 GPU 分配均衡的计算负载、可通信负载，以技术升级，提升算力效率。根据&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27181462601&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《DeepSeek-V3 / R1 推理系统概括》&lt;/a&gt;一文中阐述：以 24 小时计算，DeepSeek V3 和 R1 推理服务峰值占用总和 278 个节点，平均占用 226.75 个节点（每个节点为 8 个 H800 GPU ）。假定 GPU 租赁成本为 2 美金/小时，日成本为 87072 美元/天。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;而对比 24 小时所输出的 tokens 全部按照 DeepSeek R1 的定价计算，理论上一天的总收入为 562027 美元/天，成本利润率高达 545%&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//92f0b2c24548560677469843c4826cc8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;除此之外，&lt;strong&gt;开源生态&lt;/strong&gt;正加速成为模型创新的催化剂。Meta Llama 3 通过开源策略（免费使用、多平台支持）及训练效率优化（预训练数据扩展、后训练技术），使中小企业模型部署成本显著降低；智谱 GLM-4 依托 10 万开发者社区的持续优化，在代码生成等任务上实现同参数模型的性能超越，体现了开源协作对模型迭代的推动作用。&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;如此看来，这场产业革命的深层动因，不仅源于算力资源的成本周期，更源自于技术演进的内在规律：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;供给的周期调整&lt;/strong&gt;&lt;/span&gt;：2023-2025 年全球总算力复合增长率达 147%，但单位算力成本下降曲线（年降 68%）远超规模扩张速度，标志着算力正从「战略资源」向「基础建设」加速蜕变。简言之，算力主导的大模型经济，难以覆盖早期硬件设备上的成本投入；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;价值创造的路径迁移&lt;/strong&gt;&lt;/span&gt;：算法创新对模型效能的贡献率从 2020 年的 38% 跃升至 2025 年的 67%。例如 DeepSeek 的算法优化、理论利润，间接证明了&lt;strong&gt;算法创新才能撬动&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;效益，并也能实现很好的商业变现。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;站在 2025 年的时代座标回望，算力作为产业发展的「数字燃料」，已完成了它帮助早期模型厂商爬坡式发展的使命，随着越来越多大模型应用的加速投产，模型厂商们能依仗的绝不是训练、推理这些模型的算力规模，而是真正能让这些算力产生乘积效应的技术创新、能力整合，以及市场洞察。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;之争的终局，是通过技术让算力不再成为问题。&lt;/strong&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/7819858/blog/18015313</link>
            <guid isPermaLink="false">https://my.oschina.net/u/7819858/blog/18015313</guid>
            <pubDate>Sun, 23 Mar 2025 02:31:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>腾讯元宝支持实时预览 HTML 代码</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 26 日，首发接入 DeepSeek V3-0324 最新模型后，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfYn2utj1aiJcuI58JuZ4zw&quot; target=&quot;_blank&quot;&gt;腾讯元宝再次发布更新&lt;/a&gt;&lt;/u&gt;，&lt;strong&gt;支持实时预览 HTML 代码&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/102015_iEXO_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;目前，元宝的混元与 DeepSeek 两大模型均支持代码生成，覆盖前端、脚本、数据处理等多种主流语言，适配多类开发场景，适合开发者和各类用户快速上手。结合元宝双模型在代码方面的表现，也还够帮助用户代码审查相关工作。&lt;/p&gt; 
&lt;p&gt;此外，使用 DeepSeek V3-0324 模型，除了网页生成，还能完成更多类型的代码生成任务，如生成 UI 组件、构建网页、编写小游戏，甚至是生成 3D 动画等。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;810&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/102200_dqsd_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;现在，用户在元宝选择 DeepSeek，并关闭「深度思考」，便可使用最新的 V3-0324。该模型在代码生成稳定性、逻辑控制精准度和响应速度上均有明显提升，在数学、代码类相关评测集上取得了超过 GPT-4.5、Claude Sonnet 3.7 的得分成绩。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/341137/deepseek-v3-0324-detail&quot; target=&quot;news&quot;&gt;DeepSeek 官方详解 V3 模型「小版本」升级，各项能力全面进阶&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340789/deepseek-v3-0324&quot; target=&quot;news&quot;&gt;DeepSeek V3 模型更新，大幅提升编程能力&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341248</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341248</guid>
            <pubDate>Sun, 23 Mar 2025 02:22:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>万字长文解读 MCP 框架，让你掌握 mark3labs/mcp-go</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、引言&lt;/h1&gt; 
&lt;div&gt;
  在 
 &lt;a href=&quot;https://my.oschina.net/qiangmzsx/blog/17987222&quot;&gt;《万字长文，带你读懂 Anthropic MCP》&lt;/a&gt;中我们介绍了 MCP 的基本框架和组件，并初步说了在 golang 中的框架 metoro-io/mcp-golang 和 mark3labs/mcp-go。本文将通过实践和源码的方式先解读 mark3labs/mcp-go。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;298&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-803fb33e305fbbb839a0166e62ed0c18111.jpg&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、MCP-Server 的简述&lt;/h1&gt; 
&lt;div&gt;
  MCP Server 一般为轻量的服务端程序，通过一种标准的协议 (MCP) 暴露出特定资源的一些特定的能力。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.1 连接生命周期&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 初始化连接&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img height=&quot;1104&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-71f5896875ced4bfcd504e32c61489dd750.png&quot; width=&quot;1250&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客户端发送带有协议版本和功能 initialize 请求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    服务器以其协议版本和功能进行响应 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客户端发送 initialized 通知作为确认 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    开始正常信息交换 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 信息交换&lt;/h3&gt; 
&lt;div&gt;
  初始化后，支持以下模式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    请求-响应：客户端或服务器发送请求，对方响应 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通知：任何一方发送单向消息 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.3 终止&lt;/h3&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}&lt;/code&gt;&lt;/pre&gt; 任何一方都可以终止连接： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通过 close() 干净关闭 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    传输断开 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    错误情况 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      请求的错误响应 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      传输中的错误事件 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      协议级错误处理程序 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  常见错误码： 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_7&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.2 MCP Server 的业务能力&lt;/h2&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Request Method&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;发起方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;响应方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;initialized&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;初始化会话&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;tools-list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;发现可用的工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;tools/call&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;调用工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;发现可用的资源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/read&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;获取资源内容&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/templates&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;发现可用的参数化资源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/subscribe&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;订阅特定资源，监听其变化事件&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;prompts/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;发现可用的提示词&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;prompts/get&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;获取特定提示词&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;roots/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;列出服务器有权访问的客户端文件系统根节点（暴露目录和文件）&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;sampling/create&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;启用服务器的 AI 生成能力（ sampling creation ）&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_8&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、mark3labs/mcp-go 示例&lt;/h1&gt; 
&lt;div&gt;
  我们就以框架中的官方示例代码为引子一步步解读流程和框架代码。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;context&quot;
    &quot;errors&quot;
    &quot;fmt&quot;

    &quot;github.com/mark3labs/mcp-go/mcp&quot;
    &quot;github.com/mark3labs/mcp-go/server&quot;
)

func main() {
    // 创建 MCP 服务器
    s := server.NewMCPServer(
       &quot;Demo 🚀&quot;, // 服务器名称
       &quot;1.0.0&quot;,  // 服务器版本
    )

    // 添加工具
    tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名称
       mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
       mcp.WithString(&quot;name&quot;, // 参数名称
          mcp.Required(), // 参数是必需的
          mcp.Description(&quot;Name of the person to greet&quot;), // 参数描述
       ),
    )

    // 为工具添加处理器
    s.AddTool(tool, helloHandler)

    // 启动标准输入输出服务器
    if err := server.ServeStdio(s); err != nil {
       fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服务器错误
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // 从请求参数中获取名字参数，并断言为字符串类型
    name, ok := request.Params.Arguments[&quot;name&quot;].(string)
    if !ok {
       // 如果断言失败，返回错误
       return nil, errors.New(&quot;name must be a string&quot;)
    }

    // 返回包含问候语的结果
    return mcp.NewToolResultText(fmt.Sprintf(&quot;Hello, %s!&quot;, name)), nil
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 搭建一个联调环境&lt;/h2&gt; 
&lt;div&gt;
  就以上面的代码为例，将上面的代码编译为二进制命令： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;$ go build -v -o server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;再启动 mcp inspetor：&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;$ npx -y @modelcontextprotocol/inspector ./server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;img height=&quot;701&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7c0fba487d16433005ebd394b937e30063b.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  这样一个简单的 MCP Client 和 MCP Server 就搭建好了，后续也为我们开发测试构建好了环境。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_10&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、源码解读&lt;/h1&gt; 
&lt;div&gt;
  在上面的代码中 main 函数中的第一个代码就是 server.NewMCPServer，那我们就从 MCPServer 这个结构体入手。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_11&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 MCPServer 结构体&lt;/h2&gt; 
&lt;div&gt;
  代码地址：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/server.go#L135 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type MCPServer struct {
    mu                   sync.RWMutex                       // 用于保护共享资源，确保并发访问时的数据一致性
    name                 string                             // 服务器的名称，用于标识服务器
    version              string                             // 服务器的版本，用于跟踪和管理服务器的不同版本
    instructions         string                             // 服务器的指令，通常在初始化响应中返回给客户端，提供使用指南或帮助信息
    resources            map[string]resourceEntry           // 存储服务器支持的资源及其处理函数
    resourceTemplates    map[string]resourceTemplateEntry   // 存储资源模板及其处理函数，支持 URI 模板匹配多类似资源
    prompts              map[string]mcp.Prompt              // 存储服务器支持的提示，用于与用户交互
    promptHandlers       map[string]PromptHandlerFunc       // 存储处理提示请求的函数，每个提示对应一个处理函数
    tools                map[string]ServerTool              // 存储服务器支持的工具及其处理函数
    notificationHandlers map[string]NotificationHandlerFunc // 存储处理传入通知的函数，接收客户端通知并处理
    capabilities         serverCapabilities                 // 定义服务器支持的功能特性，包括资源、提示、工具和日志记录等
    sessions             sync.Map                           // 存储当前活跃的客户端会话，用于跟踪用户交互
    initialized          atomic.Bool                        // 使用原子操作标记服务器是否已初始化，确保线程安全
    hooks                *Hooks                             // 存储服务器钩子，允许在请求处理前后或返回错误前执行自定义逻辑
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCPServer 是 Model Control Protocol (MCP) 服务器的实现，用于处理包括资源、提示和工具在内的各种类型的请求。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; height:30px; width:1111px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_12&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#333333&quot;&gt;4.2 MCPServer 初始化&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt;
  看看如何创建一个 MCPServer 对象。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewMCPServer(
    name, version string,
    opts ...ServerOption,
) *MCPServer {
    s := &amp;amp;MCPServer{
       resources:            make(map[string]resourceEntry),
       resourceTemplates:    make(map[string]resourceTemplateEntry),
       prompts:              make(map[string]mcp.Prompt),
       promptHandlers:       make(map[string]PromptHandlerFunc),
       tools:                make(map[string]ServerTool),
       name:                 name,
       version:              version,
       notificationHandlers: make(map[string]NotificationHandlerFunc),
       capabilities: serverCapabilities{
          tools:     nil,
          resources: nil,
          prompts:   nil,
          logging:   false,
       },
    }

    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;在 NewMCPServer() 方法中，我们需要关注的 opts ...ServerOption，进一步看看 ServerOption 有哪些选项：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;选项&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置资源相关的服务器功能，如订阅和资源列表变化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities(subscribe, listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;添加钩子函数，用于在请求处理前后执行特定逻辑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks(hooks *Hooks)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置提示相关的服务器功能，如提示列表变化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置工具相关的服务器功能，如工具列表变化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;启用服务器日志记录功能&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging()&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置服务器指令，用于在初始化响应中返回给客户端&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions(instructions string)&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  它接受一个 Hooks 类型的指针作为参数。允许在创建 MCPServer 实例时，为服务器添加自定义的钩子函数，这些钩子函数可以在请求处理前后或返回错误给客户端之前执行。 
&lt;/div&gt; 
&lt;div&gt;
  hooks 机制对开发和流程是非常有效的。框架中给的 hooks 能力有： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;字段名&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;类型&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeAny&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]BeforeAnyHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在请求被解析后但方法调用前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnSuccess&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnSuccessHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在请求成功生成结果但结果尚未发送给客户端之前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnError&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnErrorHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在请求解析或方法执行过程中发生错误时执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理初始化请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理初始化请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforePing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforePingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理 Ping 请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterPing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterPingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理 Ping 请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出资源请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出资源请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出资源模板请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出资源模板请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理读取资源请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理读取资源请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出提示请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出提示请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理获取提示请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理获取提示请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出工具请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理列出工具请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理调用工具请求前执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在处理调用工具请求后执行的钩子函数。&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  现在模拟创建一个完整的 MCPServer： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;hooks := &amp;amp;server.Hooks{}

hooks.AddBeforeAny(func(id any, method mcp.MCPMethod, message any) {
    fmt.Printf(&quot;beforeAny: %s, %v, %v\n&quot;, method, id, message)
})
hooks.AddOnSuccess(func(id any, method mcp.MCPMethod, message any, result any) {
    fmt.Printf(&quot;onSuccess: %s, %v, %v, %v\n&quot;, method, id, message, result)
})
hooks.AddOnError(func(id any, method mcp.MCPMethod, message any, err error) {
    fmt.Printf(&quot;onError: %s, %v, %v, %v\n&quot;, method, id, message, err)
})
hooks.AddBeforeInitialize(func(id any, message *mcp.InitializeRequest) {
    fmt.Printf(&quot;beforeInitialize: %v, %v\n&quot;, id, message)
})
hooks.AddAfterInitialize(func(id any, message *mcp.InitializeRequest, result *mcp.InitializeResult) {
    fmt.Printf(&quot;afterInitialize: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddAfterCallTool(func(id any, message *mcp.CallToolRequest, result *mcp.CallToolResult) {
    fmt.Printf(&quot;afterCallTool: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddBeforeCallTool(func(id any, message *mcp.CallToolRequest) {
    fmt.Printf(&quot;beforeCallTool: %v, %v\n&quot;, id, message)
})
// 创建 MCP 服务器
s := server.NewMCPServer(
    &quot;Demo 🚀&quot;, // 服务器名称
    &quot;1.0.0&quot;,  // 服务器版本
    server.WithLogging(),
    server.WithToolCapabilities(true),
    server.WithResourceCapabilities(true, true),
    server.WithPromptCapabilities(true),
    server.WithInstructions(&quot;initialized&quot;),
    server.WithHooks(hooks),
)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 Tools 模块&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_14&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.1 创建 Tool&lt;/h3&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架中创建 Tool 有两个方式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewTool(name string, opts ...ToolOption) Tool 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewToolWithRawSchema(name, description string, schema json.RawMessage) Tool 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  下面通过一段代码进行对比： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;方式一：mcp.NewTool()
tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名称
    mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
    mcp.WithString(&quot;name&quot;, // 参数名称
       mcp.Required(), // 参数是必需的
       mcp.Description(&quot;Name of the person to greet&quot;), // 参数描述
    ),
)

方式二：mcp.NewToolWithRawSchema()
rawSchema := json.RawMessage(`{
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
       &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Name of the person to greet&quot;}
    },
    &quot;required&quot;: [&quot;name&quot;]
}`)

// Create a tool with raw schema
toolRS := mcp.NewToolWithRawSchema(&quot;hello_world_1&quot;, &quot;Say hello to someone&quot;, rawSchema)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中 rawSchema 的结构需要符合 ToolInputSchema 结构体：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ToolInputSchema struct {
    Type       string                 `json:&quot;type&quot;`
    Properties map[string]interface{} `json:&quot;properties,omitempty&quot;`
    Required   []string               `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;需要注意的是 Properties 来源于 jsonSchema，所以具备的需要校验属性，比如 default、maximum、minimum、maxLength、minLength、enum 等等。其中 key 为请求传入的参数字段，interface{}为对 key 的各种属性校验。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;更建议使用方式一：mcp.NewTool() 更加符合编码方式，也更好控制器生成的&lt;/strong&gt; 
 &lt;strong&gt;jsonSchema&lt;/strong&gt; 
 &lt;strong&gt;。&lt;/strong&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_15&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.2 存放 Tool&lt;/h3&gt; 
&lt;div&gt;
  创建好 Tool 值之后，调用 server 的方法 AddTool() 将 Tool 添加进入，相当于 web 框架中的添加路由与相关 handle 的关系。相关代码如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// AddTool registers a new tool and its handler
func (s *MCPServer) AddTool(tool mcp.Tool, handler ToolHandlerFunc) {
    s.AddTools(ServerTool{Tool: tool, Handler: handler})
}

// AddTools registers multiple tools at once
func (s *MCPServer) AddTools(tools ...ServerTool) {
    // 检查工具
    if s.capabilities.tools == nil {
       s.capabilities.tools = &amp;amp;toolCapabilities{}
    }

    // 加锁
    s.mu.Lock()
    // 遍历工具
    for _, entry := range tools {
       s.tools[entry.Tool.Name] = entry
    }
    // 获取初始化状态
    initialized := s.initialized.Load()
    s.mu.Unlock()

    // 发送通知
    if initialized {
       s.sendNotificationToAllClients(&quot;notifications/tools/list_changed&quot;, nil)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以看出 Tool 是放入到 MCPServer 的 tools 字段中，使用 name 作为 key，ServerTool 作为 value，其中 ServerTool 结构如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ServerTool struct {
    Tool    mcp.Tool
    Handler ToolHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架还提供了：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    DeleteTools(names... string) 作为删除 Tool 关联的方法。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SetTools(tools ...ServerTool) 可以设置当前所有的 Tool 列表。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.4 Resource 模块&lt;/h2&gt; 
&lt;div&gt;
  老规矩先来一个 demo，再看器源码实现： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Static resource example - exposing a README file
resource := mcp.NewResource(
    &quot;docs://readme&quot;,
    &quot;Project README&quot;,
    mcp.WithResourceDescription(&quot;The project&#39;s README file&quot;),
    mcp.WithMIMEType(&quot;text/markdown&quot;),
)

// Add resource with its handler
s.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    content, err := os.ReadFile(&quot;main.go&quot;)
    if err != nil {
       return nil, err
    }

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      &quot;docs://readme&quot;,
          MIMEType: &quot;text/markdown&quot;,
          Text:     string(content),
       },
    }, nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在 MCP 中 Resource 是指允许 Server 公开可供客户端读取并用作交互上下文的数据和内容。有很多类型的 Resource： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    File contents 文件内容 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Database records 数据库记录 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    API responses API 响应 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Live system data 实时系统数据 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    images 图像 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Log files 日志文件 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    等等... ... 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  框架中 Resource 的结构体如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
type Resource struct {
    Annotated // 包含可选注解，用于告知客户端如何使用或显示对象

    // 资源的 URI
    URI string `json:&quot;uri&quot;` // 资源的唯一标识符，用于定位和访问资源

    // 资源的可读名称
    //
    // 客户端可以使用此名称来填充 UI 元素
    Name string `json:&quot;name&quot;` // 资源的显示名称，便于用户理解和界面展示

    // 对此资源所代表内容的描述
    //
    // 客户端可以使用此描述来帮助大型语言模型（LLM）理解可用资源
    // 这可以看作是对模型的「提示」
    Description string `json:&quot;description,omitempty&quot;` // 资源的详细描述，为模型提供上下文信息

    // 如果已知，此资源的 MIME 类型
    MIMEType string `json:&quot;mimeType,omitempty&quot;` // 资源的媒体类型，如 text/plain、image/jpeg 等，用于指示资源的内容格式
}

type Annotated struct {
    Annotations *struct {
       // 描述此对象或数据的预期客户是谁
       //
       // 它可以包含多个条目，以指示对多个受众有用的内容（例如，`[&quot;user&quot;, &quot;assistant&quot;]`）
       Audience []Role `json:&quot;audience,omitempty&quot;` // 受众群体，指示数据对哪些角色或用户群体有用

       // 描述此数据对服务器操作的重要性
       //
       // 值为 1 表示「最重要」，并指示数据实际上是必需的，而 0 表示「最不重要」，并指示数据完全是可选的
       Priority float64 `json:&quot;priority,omitempty&quot;` // 优先级，表示数据对服务器操作的重要程度，范围从 0（最不重要）到 1（最重要）
    } `json:&quot;annotations,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    URI 用于定位一个具体资源的标识，场景的有 http://、file://、postgres://等等还可以去 https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 看看。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    MIMEType 表示文件的类型，常见的有 text/html、image/png，这里也可以查看到更多：https://www.iana.org/assignments/media-types/media-types.xhtml。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *MCPServer) AddResource(
    resource mcp.Resource,
    handler ResourceHandlerFunc,
) {
    // 检查资源
    if s.capabilities.resources == nil {
       s.capabilities.resources = &amp;amp;resourceCapabilities{}
    }

    // 加锁
    s.mu.Lock()
    // 解锁（defer）
    defer s.mu.Unlock()

    // 存储资源
    s.resources[resource.URI] = resourceEntry{
       resource: resource,
       handler:  handler,
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;resource 是放入到 MCPServer 的 resources 字段中，使用 URI 作为 key，resourceEntry 作为 value，其中 resourceEntry 结构如下：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type resourceEntry struct {
    resource mcp.Resource
    handler  ResourceHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架还提供了添加 Resource templates 的功能，主要是针对动态资源，服务器可以公开 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc6570&quot; target=&quot;_blank&quot;&gt;URI 模板 &lt;/a&gt;，客户端可以使用它来构建有效的资源 URI。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Dynamic resource example - user profiles by ID
template := mcp.NewResourceTemplate(
    &quot;users://{id}/profile&quot;,
    &quot;User Profile&quot;,
    mcp.WithTemplateDescription(&quot;Returns user profile information&quot;),
    mcp.WithTemplateMIMEType(&quot;application/json&quot;),
)

// Add template with its handler
s.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract ID from the URI using regex matching
    // The server automatically matches URIs to templates
    userID := extractIDFromURI(request.Params.URI)

    profile := fmt.Sprintf(&quot;Hello %s&quot;, userID) // Your DB/API call here

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      request.Params.URI,
          MIMEType: &quot;application/json&quot;,
          Text:     profile,
       },
    }, nil
})

// extractIDFromURI 从给定的 URI 中提取用户 ID。
// 假设 URI 的格式为 &quot;users://{id}/profile&quot;。
func extractIDFromURI(uri string) string {
    // 定义正则表达式来匹配 URI 中的 ID
    re := regexp.MustCompile(`users://([^/]+)/profile`)

    // 使用正则表达式查找匹配项
    matches := re.FindStringSubmatch(uri)

    // 如果找到了匹配项，并且匹配项的数量正确，则返回 ID
    if len(matches) == 2 {
       return matches[1]
    }

    // 如果没有找到匹配项，或者匹配项的数量不正确，则返回空字符串
    return &quot;&quot;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.5 Prompts 添加&lt;/h2&gt; 
&lt;div&gt;
  Prompts 创建可重复使用的提示模板和工作流程，提示使服务器能够定义可重复使用的提示模板和工作流程。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Simple greeting prompt
s.AddPrompt(mcp.NewPrompt(&quot;greeting&quot;,
    mcp.WithPromptDescription(&quot;A friendly greeting prompt&quot;),
    mcp.WithArgument(&quot;name&quot;,
       mcp.ArgumentDescription(&quot;Name of the person to greet&quot;),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    name := request.Params.Arguments[&quot;name&quot;]
    if name == &quot;&quot; {
       name = &quot;friend&quot;
    }

    return mcp.NewGetPromptResult(
       &quot;A friendly greeting&quot;,
       []mcp.PromptMessage{
          mcp.NewPromptMessage(
             mcp.RoleAssistant,
             mcp.NewTextContent(fmt.Sprintf(&quot;Hello, %s! How can I help you today?&quot;, name)),
          ),
       },
    ), nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Prompt 的结构体如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Prompt 表示服务器提供的提示或提示模板。
// 如果 Arguments 非空且包含元素，则表示该提示是一个模板，
// 在调用 prompts/get 时需要提供参数值。
// 如果 Arguments 为空或为 nil，则这是一个不需要参数的静态提示。
type Prompt struct {
    // 提示或提示模板的名称。
    Name string `json:&quot;name&quot;`
    // 提示提供内容的可选描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 用于模板化提示的参数列表。
    // 参数的存在表明这是一个模板提示。
    Arguments []PromptArgument `json:&quot;arguments,omitempty&quot;`
}

// PromptArgument 描述提示模板可以接受的参数。
// 当提示包含参数时，客户端在发出 prompts/get 请求时
// 必须为所有必需参数提供值。
type PromptArgument struct {
    // 参数的名称。
    Name string `json:&quot;name&quot;`
    // 参数的可读描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 此参数是否必须提供。
    // 如果为 true，则客户端在调用 prompts/get 时必须包含此参数。
    Required bool `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以通过 mcp.NewPrompt 方法来生成 Prompt 对象：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewPrompt(name string, opts ...PromptOption) Prompt {
    prompt := Prompt{
       Name: name,
    }

    for _, opt := range opts {
       opt(&amp;amp;prompt)
    }

    return prompt
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;又见到了 opts ...PromptOption，看看有哪些选项：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithPromptDescription 用于设置 description； 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithArgument 用于设置 arguments； 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.6 选择传输方式&lt;/h2&gt; 
&lt;div&gt;
  现在代码已经来到了： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 启动标准输入输出服务器
if err := server.ServeStdio(s); err != nil {
    fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服务器错误
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCP 当前主要提供两类 Stdio transport 和 HTTP with SSE transport 。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.1 Stdio&lt;/h3&gt; 
&lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;创建 StdioServer&lt;/h4&gt; 
&lt;div&gt;
  StdioServer 的结构体： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type StdioServer struct {
    server      *MCPServer
    errLogger   *log.Logger
    contextFunc StdioContextFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中在，重要的字段有 server 和 contextFunc，给 MCPServer 进来就是为了具备 MCP 的能力，只是使用 stdio 的传输方式。contextFunc 是为了让外部自定义的 context 可以进入到 StdioServer，可以用于结束服务和控制超时.&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
// 为 MCP Server 启用 stdio
func ServeStdio(server *MCPServer, opts ...StdioOption) error {
    // 创建 Stdio 服务器
    s := NewStdioServer(server)
    // 设置错误日志
    s.SetErrorLogger(log.New(os.Stderr, &quot;&quot;, log.LstdFlags))

    // 应用选项
    for _, opt := range opts {
       opt(s)
    }

    // 创建上下文
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // 设置信号通道
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

    // 监听信号
    go func() {
       &amp;lt;-sigChan
       cancel()
    }()

    // 开始监听
    return s.Listen(ctx, os.Stdin, os.Stdout)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中最关键的是 Listen 方法，它是 StdioServer 类型的一个关键方法，用于监听标准输入输出的 JSON-RPC 消息。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Listen 启动监听，从提供的输入读取 JSON-RPC 消息，并将响应写入提供的输出。
// 它将持续运行，直到上下文被取消或发生错误。
// 如果在读取输入或写入输出时遇到问题，将返回错误。
func (s *StdioServer) Listen(
    ctx context.Context, // 监听过程的上下文，用于控制生命周期和传递请求范围的信息
    stdin io.Reader, // 标准输入流，用于读取客户端发送的 JSON-RPC 消息
    stdout io.Writer, // 标准输出流，用于将响应写回客户端
) error {
    // 由于标准输入输出只有一个客户端，因此设置一个静态客户端上下文，SessionId 为 stdio
    if err := s.server.RegisterSession(&amp;amp;stdioSessionInstance); err != nil {
       // 如果会话注册失败，返回错误
       return fmt.Errorf(&quot;register session: %w&quot;, err)
    }
    // 确保在函数结束时注销会话
    defer s.server.UnregisterSession(stdioSessionInstance.SessionID())
    // 更新上下文，将会话信息加入
    ctx = s.server.WithContext(ctx, &amp;amp;stdioSessionInstance)

    // 如果存在自定义上下文函数，则应用该函数修改上下文
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx)
    }

    // 创建一个带缓冲的读取器，用于从标准输入流高效读取数据
    reader := bufio.NewReader(stdin)

    // 启动一个协程专门处理通知
    go func() {
       for {
          select {
          case notification := &amp;lt;-stdioSessionInstance.notifications:
             // 收到通知时，调用 writeResponse 方法将通知写入标准输出
             err := s.writeResponse(notification, stdout)
             if err != nil {
                // 如果写入通知时出错，记录错误日志
                s.errLogger.Printf(&quot;Error writing notification: %v&quot;, err)
             }
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，退出协程
             return
          }
       }
    }()

    // 主循环，用于处理输入消息
    for {
       select {
       case &amp;lt;-ctx.Done():
          // 如果上下文完成，返回上下文错误
          return ctx.Err()
       default:
          // 使用协程使读取操作可取消
          readChan := make(chan string, 1) // 用于接收读取到的行
          errChan := make(chan error, 1)   // 用于接收读取错误

          go func() {
             line, err := reader.ReadString(&#39;\n&#39;) // 读取一行输入
             if err != nil {
                errChan &amp;lt;- err // 发送读取错误
                return
             }
             readChan &amp;lt;- line // 发送读取到的行
          }()

          select {
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，返回上下文错误
             return ctx.Err()
          case err := &amp;lt;-errChan:
             // 处理读取错误
             if err == io.EOF {
                // 如果是文件结束符，表示输入结束，返回 nil
                return nil
             }
             // 其他错误则记录日志并返回
             s.errLogger.Printf(&quot;Error reading input: %v&quot;, err)
             return err
          case line := &amp;lt;-readChan:
             // 处理读取到的行
             if err := s.processMessage(ctx, line, stdout); err != nil {
                // 如果处理消息时出错
                if err == io.EOF {
                   // 如果是文件结束符，返回 nil
                   return nil
                }
                // 其他错误则记录日志并返回
                s.errLogger.Printf(&quot;Error handling message: %v&quot;, err)
                return err
             }
          }
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.2 SSE&lt;/h3&gt; 
&lt;div&gt;
  SSE 模式凭借其分布式能力、实时性和架构灵活性，成为 MCP 在 
 &lt;strong&gt;企业级应用、云端协作、动态数据流处理&lt;/strong&gt;等场景的首选。所以对 SSE 的支持程度和易用程度，对于一个 MCP 框架而言是非常重要的。 
&lt;/div&gt; 
&lt;div&gt;
  mark3labs/mcp-go 如何支持 SSE 呢？看看如下代码： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mcpServer := NewMCPServer()
sseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(&quot;http://localhost:8080&quot;))
log.Printf(&quot;SSE server listening on :8080&quot;)
if err := sseServer.Start(&quot;:8080&quot;); err != nil {
    log.Fatalf(&quot;Server error: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;现在已经知道如何在 mark3labs/mcp-go 中启用 SSE 了，现在来分析一下，它是如何实现的。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;创建 SSEServer&lt;/h4&gt; 
&lt;div&gt;
  SSEServer 的结构体如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// SSEServer implements a Server-Sent Events (SSE) based MCP server.
// It provides real-time communication capabilities over HTTP using the SSE protocol.
type SSEServer struct {
    server          *MCPServer       // MCPServer 实例，用于处理实际的消息传递和通信逻辑
    baseURL         string           // SSE 服务器的基础 URL，用于构建完整的端点路径
    basePath        string           // SSE 服务器的基础路径，通常用于区分不同的服务或版本
    messageEndpoint string           // 消息端点的路径，客户端通过此端点发送 JSON-RPC 消息
    sseEndpoint     string           // SSE 端点的路径，客户端通过此端点建立 SSE 连接
    sessions        sync.Map         // 存储活动 SSE 会话的同步映射，用于跟踪和管理客户端连接
    srv             *http.Server     // 内部的 HTTP 服务器实例，用于处理 HTTP 请求和响应
    contextFunc     SSEContextFunc   // 可选的上下文函数，用于根据请求内容自定义上下文
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;与之前的 StdioServer 相比，SSEServer 多了用于 http 中使用的 URI、path，还有 srv 这是一个 httpServer 的类型，用于支持 HTTP 请求和响应。继续查看如何构建 SSEServer：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// NewSSEServer creates a new SSE server instance with the given MCP server and options.
func NewSSEServer(server *MCPServer, opts ...SSEOption) *SSEServer {
    s := &amp;amp;SSEServer{
       server:          server,
       sseEndpoint:     &quot;/sse&quot;,
       messageEndpoint: &quot;/message&quot;,
    }

    // Apply all options
    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;还是采用的才是经典 Option 模式，继续看看 SSEOption 有哪些选项：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;名称&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置 SSE 服务器的基础 URL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL(&quot;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fexample.com&quot; target=&quot;_blank&quot;&gt;https://example.com&lt;/a&gt;&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置 SSE 服务器的基础路径&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath(&quot;/v1&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置消息端点的路径&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint(&quot;/custom-message&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置 SSE 端点的路径&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint(&quot;/custom-sse&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置 HTTP 服务器实例（通常用于测试或自定义服务器配置）&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer(customHttpServer)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;设置一个函数，用于根据请求内容自定义上下文&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc(func(ctx context.Context, r *http.Request) context.Context { ... })&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  WithHTTPServer 适用于需要自定义服务器配置的场景，为后续替换更好性能的 http 服务实例打下基础，也体现了 mark3labs/mcp-go 扩展性。 
&lt;/div&gt; 
&lt;div&gt;
  剩下的 Start() 就是常见的启动 http 服务实例的功能了。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) Start(addr string) error {
    s.srv = &amp;amp;http.Server{
       Addr:    addr,
       Handler: s,
    }

    return s.srv.ListenAndServe()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;还可以调用 Shutdown() 实现对服务器的关闭。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_23&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.3 集成到 gin 框架&lt;/h3&gt; 
&lt;div&gt;
  在实际开发中，很多公司内部的业务有自己的框架，集成了许许多多的独特功能。总不能为了使用 MCP 重写一套 Web 框架，此时就需要使用到 mark3labs/mcp-go 集成到 Web 框架的能力了。下面以 gin 框架为例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 创建一个新的 Gin 引擎
r := gin.Default()

// 创建一个新的 MCPServer 实例（假设这是 SSEServer 所需的）
mcpServer := server.NewMCPServer(&quot;gin-mcp-server&quot;, &quot;1.0.0&quot;) // 根据你的实际代码调整
// mcpServer 新加 Tool、Resource、Prompt
// ... ...
// 创建一个新的 SSEServer 实例，并传入 MCPServer
sseServer := server.NewSSEServer(mcpServer)

// 将 SSEServer 的 SSE 端点和处理函数集成到 Gin 路由中
r.GET(sseServer.CompleteSsePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 将 SSEServer 的消息端点和处理函数集成到 Gin 路由中
r.POST(sseServer.CompleteMessagePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 启动 Gin 服务器
if err := r.Run(&quot;localhost:8081&quot;); err != nil {
    log.Fatalf(&quot;Gin server startup failed: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;上述的代码会生成两个路由：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; border:none; table-layout:fixed; width:500px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       路由 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       方法 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       作用 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       实例 
     &lt;/div&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /sse 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       GET 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         获取 SessionID 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         接受 Server 响应 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;请求：
curl &#39;http://localhost:3000/sse?transportType=sse&amp;amp;url=http%3A%2F%2Flocalhost%3A8081%2Fsse&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; 
  
  响应：
  event: endpoint
data: /message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /message 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       POST 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         使用 SessionID 保持会话 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         发起功能请求 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;请求：
curl &#39;http://localhost:3000/message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; \
  -H &#39;content-type: application/json&#39; 
  --data-raw &#39;{&quot;method&quot;:&quot;initialize&quot;,&quot;params&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;sampling&quot;:{},&quot;roots&quot;:{&quot;listChanged&quot;:true}},&quot;clientInfo&quot;:{&quot;name&quot;:&quot;mcp-inspector&quot;,&quot;version&quot;:&quot;0.7.0&quot;}},&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0}&#39;
 
/message 的响应：
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}

/sse 收到的响应：
event: message
data: {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_24&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.7 处理请求&lt;/h2&gt; 
&lt;div&gt;
  之前的内容，解析了如何构建 MCP Server 的实践和背后的实现。下面我们还需要了解 mark3labs/mcp-go 如何接受请求并进行响应的。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_25&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.1 路由入口&lt;/h3&gt; 
&lt;div&gt;
  从 SSEServer 结构体中已经知道使用的 http.Server，所以其接受请求的入口为 ServeHTTP 方法，实现了 http.Handler 接口，用于处理 HTTP 请求。根据请求的路径，它会将请求分发到不同的处理方法（handleSSE 或 handleMessage），或者返回 404 未找到。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 获取请求的路径
    path := r.URL.Path

    // 使用精确路径匹配，而不是模糊包含
    ssePath := s.CompleteSsePath() // 获取完整的 SSE 路径
    if ssePath != &quot;&quot; &amp;amp;&amp;amp; path == ssePath {
       // 如果请求路径与 SSE 路径匹配，则处理 SSE 请求
       s.handleSSE(w, r)
       return // 处理完成后直接返回，不再继续后续逻辑
    }

    // 获取消息处理的完整路径
    messagePath := s.CompleteMessagePath()
    if messagePath != &quot;&quot; &amp;amp;&amp;amp; path == messagePath {
       // 如果请求路径与消息处理路径匹配，则处理消息请求
       s.handleMessage(w, r)
       return // 处理完成后直接返回，不再继续后续逻辑
    }

    // 如果请求路径不匹配任何已知路径，则返回 404 未找到
    http.NotFound(w, r)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SSE 路径为：s.baseURL + s.basePath + s.sseEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Message 路径为：s.baseURL + s.basePath + s.messageEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  这些信息都是可以在 NewSSEServer() 方法中设置。 
&lt;/div&gt; 
&lt;div&gt;
  需要详细查看的是 s.handleSSE(w, r) 和 s.handleMessage(w, r) 方法，他们分别处理/see 和/message 的请求。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_26&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.2 handleSSE&lt;/h3&gt; 
&lt;div&gt;
  handleSSE 实现了一个处理服务器发送事件（SSE）的 HTTP 处理器。SSE 是一种允许服务器向客户端发送自动更新的技术。主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;请求方法检查&lt;/strong&gt;：只允许 GET 请求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;设置响应头&lt;/strong&gt;：设置适当的 SSE 响应头。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;创建会话&lt;/strong&gt;：为每个客户端创建一个新的 SSE 会话。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;注册和注销会话&lt;/strong&gt;：在服务器中注册会话，并在处理完成后注销。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;通知处理器&lt;/strong&gt;：启动一个 goroutine 处理来自通知通道的事件，并将其发送到客户端。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;主事件循环&lt;/strong&gt;：处理来自事件队列的事件，并将其发送到客户端。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 它设置适当的头信息并为客户端创建一个新的会话。
func (s *SSEServer) handleSSE(w http.ResponseWriter, r *http.Request) {
    // 1. 检查请求方法是否为 GET，如果不是，返回 405 Method Not Allowed 错误
    if r.Method != http.MethodGet {
       http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
       return
    }

    // 2. 设置 SSE 相关的响应头
    w.Header().Set(&quot;Content-Type&quot;, &quot;text/event-stream&quot;) // 设置内容类型为 text/event-stream
    w.Header().Set(&quot;Cache-Control&quot;, &quot;no-cache&quot;)         // 禁用缓存
    w.Header().Set(&quot;Connection&quot;, &quot;keep-alive&quot;)          // 保持连接活跃
    w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)  // 允许所有域跨域请求

    // 检查 ResponseWriter 是否支持 Flush，如果不支持，返回 500 Internal Server Error 错误
    flusher, ok := w.(http.Flusher)
    if !ok {
       http.Error(w, &quot;Streaming unsupported&quot;, http.StatusInternalServerError)
       return
    }

    // 3. 创建一个新的会话 ID 和会话对象
    sessionID := uuid.New().String() // 生成唯一的会话 ID
    session := &amp;amp;sseSession{
       writer:              w,                          // 响应写入器
       flusher:             flusher,                    // 刷新器
       done:                make(chan struct{}),        // 用于通知会话结束的通道
       eventQueue:          make(chan string, 100),     // 事件队列，缓冲区大小为 100
       sessionID:           sessionID,                  // 会话 ID
       notificationChannel: make(chan mcp.JSONRPCNotification, 100), // 通知通道，缓冲区大小为 100
    }

    // 4. 将会话存储到会话存储中，并在处理完成后删除
    s.sessions.Store(sessionID, session)
    defer s.sessions.Delete(sessionID)

    // 在服务器中注册会话，如果注册失败，返回 500 Internal Server Error 错误
    if err := s.server.RegisterSession(session); err != nil {
       http.Error(w, fmt.Sprintf(&quot;Session registration failed: %v&quot;, err), http.StatusInternalServerError)
       return
    }
    // 在处理完成后注销会话
    defer s.server.UnregisterSession(sessionID)

    // 5. 启动一个 goroutine 处理通知通道中的事件
    go func() {
       for {
          select {
          case notification := &amp;lt;-session.notificationChannel: // 从通知通道接收通知
             eventData, err := json.Marshal(notification) // 将通知序列化为 JSON
             if err == nil {
                select {
                case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData): // 将事件发送到事件队列
                   // 事件成功入队
                case &amp;lt;-session.done: // 如果会话结束，退出 goroutine
                   return
                }
             }
          case &amp;lt;-session.done: // 如果会话结束，退出 goroutine
             return
          case &amp;lt;-r.Context().Done(): // 如果请求上下文被取消，退出 goroutine
             return
          }
       }
    }()

    // 生成消息端点 URL 并发送初始的 endpoint 事件
    messageEndpoint := fmt.Sprintf(&quot;%s?sessionId=%s&quot;, s.CompleteMessageEndpoint(), sessionID)
    fmt.Fprintf(w, &quot;event: endpoint\ndata: %s\r\n\r\n&quot;, messageEndpoint) // 发送 endpoint 事件
    flusher.Flush() // 刷新响应，确保事件立即发送到客户端

    // 6. 主事件循环，运行在 HTTP 处理器 goroutine 中
    for {
       select {
       case event := &amp;lt;-session.eventQueue: // 从事件队列接收事件
          fmt.Fprint(w, event) // 将事件写入响应
          flusher.Flush()      // 刷新响应，确保事件立即发送到客户端
       case &amp;lt;-r.Context().Done(): // 如果请求上下文被取消，关闭会话并退出
          close(session.done)
          return
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;第三阶段又看到 Session 了，与之前的 stdioSession 相比，sseSession 明显复杂多了，它们都实现接口 ClientSession：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ClientSession interface {
    // NotificationChannel provides a channel suitable for sending notifications to client.
    NotificationChannel() chan&amp;lt;- mcp.JSONRPCNotification
    // SessionID is a unique identifier used to track user session.
    SessionID() string
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;sseSession 是专门用于表示一个基于服务器发送事件（Server-Sent Events, SSE）协议的活跃连接。sseSession 负责管理客户端与服务器之间的单向实时数据推送，并保持会话。其结构体如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type sseSession struct {
    writer              http.ResponseWriter // HTTP 响应写入器，用于向客户端发送数据
    flusher             http.Flusher       // HTTP 刷新器，用于刷新响应缓冲区，确保数据立即发送给客户端
    done                chan struct{}      // 用于通知会话结束的通道
    eventQueue          chan string        // 用于排队事件的通道，存储待发送给客户端的事件
    sessionID           string             // 会话的唯一标识符
    notificationChannel chan mcp.JSONRPCNotification // 用于接收 JSON-RPC 通知的通道
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_27&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;4.7.3 handleMessage&lt;/h3&gt; 
&lt;/div&gt; 
&lt;div&gt;
  handleMessage 方法是 SSEServer 类型的一个方法，用于处理传入的 JSON-RPC 消息，并通过 SSE 连接和 HTTP 响应返回结果。其主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    请求验证：检查请求方法 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      检查请求方法：方法首先检查请求方法是否为 HTTP POST。如果不是，返回 &quot;Method not allowed&quot; 错误，并终止处理。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      验证 sessionId 参数：从请求的 URL 查询参数中获取 sessionId。如果缺失，返回 &quot;Missing sessionId&quot; 错误。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      加载会话：使用 sessionId 从会话存储中加载会话。如果会话不存在，返回 &quot;Invalid session ID&quot; 错误。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    设置上下文 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      调用 s.server.WithContext 方法，将请求上下文和会话信息合并，生成新的上下文。如果提供了 contextFunc，则进一步处理上下文。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    解析 JSON-RPC 消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      使用 json.NewDecoder 解析请求体中的原始 JSON 消息。如果解析失败，返回 &quot;Parse error&quot; 错误。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    处理消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      将解析后的消息传递给 s.server.HandleMessage 方法进行处理，并获取响应结果。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    发送响应 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 返回了响应（非通知），则： 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 没有返回响应（通知），则仅设置 HTTP 响应状态码为 202 Accepted，不发送响应体。 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      将响应编码为 JSON 格式。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      将响应事件加入会话的事件队列，供 SSE 连接发送。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      设置 HTTP 响应头为 application/json，状态码为 202 Accepted，并发送响应体。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    事件队列处理 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  尝试将事件加入会话的事件队列。如果队列已满或会话已关闭，则丢弃事件。 
&lt;/div&gt; 
&lt;div&gt;
  那么 handleSSE 和 handleMessage 的关系是怎样的呢？使用一张图来说明： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;729&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7cab372d06266dac5b06a8959d2df0382ea.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// handleMessage 处理来自客户端的 JSON-RPC 消息，并通过 SSE 连接和 HTTP 响应返回结果
func (s *SSEServer) handleMessage(w http.ResponseWriter, r *http.Request) {
    // 1. 如果请求方法不是 POST，则返回 JSON-RPC 错误响应，表示方法不允许
    if r.Method != http.MethodPost {
       s.writeJSONRPCError(w, nil, mcp.INVALID_REQUEST, &quot;Method not allowed&quot;)
       return
    }

    // 从请求的 URL 查询参数中获取 sessionId
    sessionID := r.URL.Query().Get(&quot;sessionId&quot;)
    // 如果 sessionId 为空，则返回 JSON-RPC 错误响应，表示缺少 sessionId 参数
    if sessionID == &quot;&quot; {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Missing sessionId&quot;)
       return
    }

    // 从 session 存储中加载与 sessionId 对应的 session
    sessionI, ok := s.sessions.Load(sessionID)
    // 如果 session 不存在，则返回 JSON-RPC 错误响应，表示无效的 session ID
    if !ok {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Invalid session ID&quot;)
       return
    }
    session := sessionI.(*sseSession)

    // 在处理消息之前设置客户端上下文
    ctx := s.server.WithContext(r.Context(), session)
    // 如果提供了自定义的上下文函数，则应用它
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx, r)
    }

    // 将请求体解析为原始 JSON 消息
    var rawMessage json.RawMessage
    if err := json.NewDecoder(r.Body).Decode(&amp;amp;rawMessage); err != nil {
       // 如果解析失败，则返回 JSON-RPC 错误响应，表示解析错误
       s.writeJSONRPCError(w, nil, mcp.PARSE_ERROR, &quot;Parse error&quot;)
       return
    }

    // 通过 MCPServer 处理消息
    response := s.server.HandleMessage(ctx, rawMessage)

    // 如果存在响应（非通知），则发送响应
    if response != nil {
       // 将响应编码为 JSON 格式
       eventData, _ := json.Marshal(response)

       // 将事件排队以通过 SSE 发送
       select {
       case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData):
          // 事件成功排队
       case &amp;lt;-session.done:
          // 会话已关闭，不尝试排队
       default:
          // 队列已满，可以记录此情况
       }

       // 发送 HTTP 响应
       w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
       w.WriteHeader(http.StatusAccepted)
       json.NewEncoder(w).Encode(response)
    } else {
       // 对于通知，只发送 202 Accepted 状态码，无响应体
       w.WriteHeader(http.StatusAccepted)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  需要注意的是 HandleMessage 方法，这是通过 server/internal/gen/request_handler.go.tmpl 生成的，也根据 MCP 协议实现的模版，其流程如下： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    尝试将原始消息解析为对应请求类型。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果解析失败，记录错误信息。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    执行请求前的钩子函数。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    调用对应的处理函数处理请求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果处理过程中发生错误，执行错误钩子函数并返回错误响应。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    执行请求后的钩子函数。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    返回成功响应。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  以 initialize 请求为例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 根据消息方法进行分情况处理
switch baseMessage.Method {
// 初始化请求处理
case mcp.MethodInitialize:
    var request mcp.InitializeRequest
    var result *mcp.InitializeResult
    // 尝试将原始消息解析为初始化请求类型
    if unmarshalErr := json.Unmarshal(message, &amp;amp;request); unmarshalErr != nil {
       // 如果解析失败，记录错误信息
       err = &amp;amp;requestError{
          id:   baseMessage.ID,
          code: mcp.INVALID_REQUEST,
          err:  &amp;amp;UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
       }
    } else {
       // 执行初始化请求前的钩子函数
       s.hooks.beforeInitialize(baseMessage.ID, &amp;amp;request)
       // 处理初始化请求
       result, err = s.handleInitialize(ctx, baseMessage.ID, request)
    }
    // 如果处理过程中发生错误
    if err != nil {
       // 执行错误钩子函数
       s.hooks.onError(baseMessage.ID, baseMessage.Method, &amp;amp;request, err)
       // 返回错误响应
       return err.ToJSONRPCError()
    }
    // 执行初始化请求后的钩子函数
    s.hooks.afterInitialize(baseMessage.ID, &amp;amp;request, result)
    // 返回成功响应
    return createResponse(baseMessage.ID, *result)

// 其他方法处理逻辑类似，省略...

// 如果方法不匹配任何已知方法，返回方法未找到错误响应
default:
    return createErrorResponse(
       baseMessage.ID,
       mcp.METHOD_NOT_FOUND,
       fmt.Sprintf(&quot;Method %s not found&quot;, baseMessage.Method),
    )
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;代码比较多，可以自行查看：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/request_handler.go#L12&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_28&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、总结&lt;/h1&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架是一个简单易用的 MCP 框架，基本上实现了 MCP 协议，提供对 MCP 核心规范的完整支持，包括资源（Resources）、工具（Tools）、提示（Prompts）等核心组件，确保与主流 LLM 客户端（如 Claude、Cline）的兼容性。尤其是 mark3labs/mcp-go 提供的 hooks 机制，可以让开发者更好的使用类似 gin 空间一样的中间件能力，比如实现统一鉴权等能力。除此之外，还可以与主流的 Web 框架，如 gin 框架进行集成，进一步扩展了 mark3labs/mcp-go 的适用性。 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/qiangmzsx/blog/18014540</link>
            <guid isPermaLink="false">https://my.oschina.net/qiangmzsx/blog/18014540</guid>
            <pubDate>Sun, 23 Mar 2025 02:15:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>阿里通义千问开源端到端多模态模型 Qwen2.5-Omni</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 27 日，通义千问&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqwenlm.github.io%2Fzh%2Fblog%2Fqwen2.5-omni%2F&quot; target=&quot;_blank&quot;&gt;宣布推出&lt;/a&gt;&lt;/u&gt;新一代端到端多模态旗舰模型 Qwen2.5-Omni。该模型现已在 Hugging Face、ModelScope、DashScope 和 GitHub 上开源开放。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e620efb7beda14c716812fb6f4a8ed2f17f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Qwen2.5-Omni 是一种端到端多模态模型，旨在感知各种模态，包括文本，图像，音频和视频，同时以流式方式生成文本和自然语音响应。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;关键特点&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Omni 和新颖的架构：我们提出 Thinker-Talker 架构，这是一种端到端多模态模型，旨在感知各种模式，包括文本，图像，音频和视频，同时以流式方式生成文本和自然语音响应。 我们提出了一种新的位置嵌入，称为 TMRoPE (时间对齐多模态 RoPE), 以将视频输入的时间戳与音频同步。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;实时语音和视频聊天：专为完全实时交互而设计的架构，支持分块输入和即时输出。&lt;/li&gt; 
 &lt;li&gt;自然和强大的语音生成：超越许多现有的流媒体和非流媒体替代方案，在语音生成中表现出卓越的鲁棒性和自然性。&lt;/li&gt; 
 &lt;li&gt;跨模式的强大性能：在与类似规模的单模式模型进行基准测试时，在所有模式中表现出卓越的性能。 Qwen2.5-Omni 在音频功能方面优于类似尺寸的 Qwen2-Audio, 并实现与 Qwen2.5-VL-7B 相当的性能。&lt;/li&gt; 
 &lt;li&gt;优秀的端到端语音指令：Qwen2.5-Omni 在端到端语音指令中表现出性能，这与文本输入的有效性相媲美，MMLU 和 GSM8K 等基准测试就证明了这一点。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;模型架构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8eac4f9ca743454cd238cfa11a6319f1710.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ac3ad0960351e7733a1cfb5cabf05690d01.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型下载&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前只开源了 7B 尺寸的模型&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FQwen%2FQwen2.5-Omni-7B&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/Qwen/Qwen2.5-Omni-7B&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341243/qwen2-5-omni-7b</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341243/qwen2-5-omni-7b</guid>
            <pubDate>Sun, 23 Mar 2025 02:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI Agents SDK 已支持大模型上下文协议 MCP</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;OpenAI &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAIDevs%2Fstatus%2F1904957755829481737&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;&lt;/u&gt;其智能体——OpenAI Agents SDK 已支持大模型上下文协议 MCP，并表示称&lt;strong&gt;正在为 OpenAI API 和 ChatGPT 桌面应用程序开发 MCP 支持&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1052&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/095628_d79a_2720166.png&quot; width=&quot;1278&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/100304_ckel_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;OpenAI Agents SDK 支持 MCP 对于开发复杂的智能体具有巨大帮助。例如，在开发一个需要同时进行文件处理、数据查询和网络信息收集的智能体时，开发者可以通过 MCP 服务器分别集成文件系统工具、数据库查询工具和网络爬虫工具，更高效地完成任务。&lt;/p&gt; 
&lt;p&gt;参考文档&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.github.io%2Fopenai-agents-python%2Fmcp%2F&quot; target=&quot;_blank&quot;&gt;https://openai.github.io/openai-agents-python/mcp/&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenai%2Fopenai-agents-python&quot; target=&quot;_blank&quot;&gt;https://github.com/openai/openai-agents-python&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341240/openai-agents-sdk-mcp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341240/openai-agents-sdk-mcp</guid>
            <pubDate>Sun, 23 Mar 2025 02:04:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>张一鸣登顶中国首富</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 27 日，彭博亿万富豪指数及福布斯富豪榜均显示，字节跳动创始人张一鸣登顶中国富豪榜榜首，成为中国首富。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;福布斯预估张一鸣身家为 655 亿美元（约合 4760.67 亿元人民币），在全球富豪榜位列第 23 位，马化腾与钟睒睒分别以 535 亿美元、531 亿美元的身家分列富豪榜第 27 和 28 位。彭博亿万富豪指数预估张一鸣身家为 575 亿美元，位居全球富豪榜第 24 位，马化腾和钟睒睒分列第 25 和 26 位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另外根据彭博亿万富豪指数，张一鸣目前是亚洲第三大富豪，仅次于印度的 Mukesh Ambani 和 Gautam Adani。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;309&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-63eb3fc9dc2e64506bf7afcc27af90e9d51.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341239</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341239</guid>
            <pubDate>Sun, 23 Mar 2025 02:00:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>商汤科技：2024 年生成式 AI 收入占比达 63.7%</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商汤集团&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPBkhEy84piWtkBHwY8nDYA&quot; target=&quot;_blank&quot;&gt;发布&lt;/a&gt;截至 2024 年 12 月 31 日经审核全年业绩。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年，商汤集团总体收入同比增长 10.8%，达到 37.7 亿元人民币；其中，生成式 AI 业务收入突破 24 亿元，同比大幅增长 103.1%，这是生成式 AI 连续两年保持三位数增速，占总收入比例进一步提升至 63.7%，已成为集团最大业务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年集团毛利为 16.2 亿元人民币，毛利率为 42.9%，亏损同比收窄 33.7%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商汤集团董事会执行主席兼首席执行官徐立博士表示：「大模型算法与基础设施软件系统的联合优化已成为生成式 AI 飞速发展的核心驱动力。商汤秉承的‘大装置-大模型-应用’三位一体、联合优化的战略与此趋势契合，正在迎来高速发展阶段。商汤以‘1+X’组织架构重组推动资源的战略聚焦，以可持续增长与盈利能力为核心，增强商汤作为行业标杆的竞争力。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;3808&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-60709661fa23c67ebe39f9c529b30ba38ec.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341237</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341237</guid>
            <pubDate>Sun, 23 Mar 2025 01:56:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>英伟达正在洽谈收购贾扬清创业公司 Lepton AI</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fnvidia-nears-deal-buy-gpu-reseller-several-hundred-million-dollars&quot; target=&quot;_blank&quot;&gt;根据 The Information 的报道&lt;/a&gt;&lt;/u&gt;，英伟达即将收购成立两年的 AI 创业公司 Lepton AI。据称这笔交易的金额达数亿美元。&lt;/p&gt; 
&lt;p&gt;Lepton AI 创始人贾扬清是开源深度学习框架 Caffe 创始人、TensorFlow 作者之一、也是 PyTorch 1.0 的共同创始人。他在创立 Lepton AI 之前在阿里巴巴担任技术副总裁。&lt;/p&gt; 
&lt;p&gt;2023 年 3 月，贾扬清离职创立了 Lepton AI，主做 AI 底层架构方向的事情，希望通过产品的方式来降低 AI 应用开发的门槛，帮助开发者更容易地完成创建、部署和扩展任务。&lt;/p&gt; 
&lt;p&gt;2023 年 5 月，Lepton AI 完成了首轮天使轮融资，由 Fusion Fund 基金和 CRV 风投两家机构投资。创始团队成员还包括 ONNX 的联合创始人以及 etcd 的创始人。&lt;/p&gt; 
&lt;p&gt;成立至今，Lepton AI 主要发布了两款产品：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;FastGPU：2024 年 6 月上线的云 GPU 解决方案，主打经济高效和可靠。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Lepton Search：2023 年 12 月推出的对话式搜索引擎，基于 Lepton AI 平台实现，代码量不到 500 行。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Lepton AI 的基本思路是提供大模型训练、部署和应用时所需的基础设施，诸如提供 Python SDK 和云计算平台，支持 HuggingFace 模型集成和从 GitHub 仓库创建 AI 模型，以降低了 AI 应用开发的门槛。&lt;/p&gt; 
&lt;p&gt;而 NVIDIA 目前也正致力于扩展其 AI 能力和基础设施，为其客户更全面的解决方案。这是促成此次收购的核心战略逻辑。&lt;/p&gt; 
&lt;p&gt;英伟达正感受到来自其最大客户——主要云服务提供商，如亚马逊和谷歌的压力，这些客户试图通过开发和低价租赁替代芯片来削弱英伟达的市场地位，因此英伟达考虑进行多元化发展，直接下场做 Lepton AI 做的事情。&lt;/p&gt; 
&lt;p&gt;Lepton AI 的一个主要竞争对手是 Together AI，这同样是一家初创公司，尽管仅比 Lepton AI 早成立一年左右，但已筹集了超过 5 亿美元的风险投资。另外还有一个竞争对手是 Fireworks，由前 Meta PyTorch 团队成员创立，去年完成了 B 轮融资，英伟达也有参与跟投。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340005/nvidia-gretel-acquisition-synthetic-training-data&quot; target=&quot;news&quot;&gt;英伟达收购合成数据初创公司 Gretel&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/287935&quot; target=&quot;news&quot;&gt;贾扬清评价李彦宏对大模型行业趋势的预测：非常对&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/276738/search-with-lepton-opensource&quot; target=&quot;news&quot;&gt;贾扬清最新开源项目 —— 500 行代码构建的 AI 搜索工具&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341235</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341235</guid>
            <pubDate>Sun, 23 Mar 2025 01:46:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>