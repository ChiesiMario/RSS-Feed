<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Mon, 22 Sep 2025 07:40:13 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>谷歌深度學習專家 Dustin Tran 跳槽至 xAI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 宣佈從 Google DeepMind 跳槽至馬斯克的 xAI，成為公司研發新一代 Grok 模型的重要成員。此消息在他於社交媒體上正式官宣後不久，馬斯克便迅速轉發，確認了這一人事變動的真實性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="290" src="https://oscimg.oschina.net/oscnet/up-c6df198a66d14d96ac0ff58b9bdfb7a14c0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 是 Gemini 項目的核心開發者，自項目誕生以來，他在多個關鍵階段發揮了重要作用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;從 2014 年在加州大學伯克利畢業，取得數學與統計本科學位後，Tran 繼續攻讀哈佛大學的統計學博士，並最終在哥倫比亞大學獲得計算機科學博士學位。他在學術界的貢獻也頗為顯著，其論文總引用量超過 2.4 萬次，曾榮獲包括 Google 博士獎學金在內的多個獎項。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在離開 Google DeepMind 的長文中，Tran 深情回顧了自己在該公司的 8 年旅程，他參與了多個重要項目的開發，尤其是 Gemini 的成長過程。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他提到，最初人們對 Google 在 AI 領域的未來持悲觀態度，但隨着 Gemini 在用户偏好上佔據領先地位以及在科研突破上的不斷進展，這種看法逐漸改變。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;加入 xAI 的原因，他提到的是這裏的巨大算力和數據優勢。Tran 對 xAI 的信心滿滿，認為這是研發前沿級語言模型的必備條件。尤其是 Colossus 2 的強大算力，使他意識到 xAI 在行業中的競爭力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373709</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373709</guid>
      <pubDate>Mon, 22 Sep 2025 07:15:10 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>2TB 新 iPhone 導入 85GB 微信聊天記錄提示空間不足；微信員工稱代碼存在 Bug</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;iPhone 17 系列手機日前已開售，很多拿到新機的用户第一時間就是轉移數據。&lt;/p&gt; 
&lt;p&gt;不過有微信用户發現，在向新 iPhone 導入聊天記錄時，微信提示設備空間不足，但手機明明還有 1.29TB 可用容量，而導入的聊天記錄最多隻需 85.16GB 空間。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1354" src="https://static.oschina.net/uploads/space/2025/0922/150216_L3bN_2720166.png" width="744" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e5044091cab39969380f84c9693480a6030.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;對此，微信員工「客村小蔣」&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7876775013%2FQ5Ct4vIjM" target="_blank"&gt;回應稱&lt;/a&gt;，微信的代碼存在 Bug 導致無法獲取系統的真實剩餘空間，將很快修復。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我們們有個獲取剩餘空間的通用工具接口，這個接口內部有個緩存，在獲取間隔不超過 5 分鐘的時候，不會向系統獲取真實的剩餘空間，本意是為了避免頻繁讀取系統接口導致性能問題，但在新手機上，有概率會造成這種情況，因為該邏輯會在開機 5 分鐘內返回數據是 0。&lt;strong&gt;開機後用個 5 分鐘，接口就能獲取到真實的剩餘空間，就正常了&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/150356_WJpx_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373705</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373705</guid>
      <pubDate>Mon, 22 Sep 2025 07:05:10 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>從 Java 到 Go：面向對象的巨人與雲原生的輕騎兵</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;Go 語言在 2009 年被 Google 推出，在創建之初便明確提出了「少即是多（Less is more）」的設計原則，強調「以工程效率為核心，用極簡規則解決複雜問題」。它與 Java 語言生態不同，Go 通過編譯為 &lt;strong&gt;單一靜態二進制文件實現快速啓動和低內存開銷&lt;/strong&gt;，&lt;strong&gt;以 25 個關鍵字強制代碼簡潔性&lt;/strong&gt;，&lt;strong&gt;用接口組合替代類繼承&lt;/strong&gt;，&lt;strong&gt;以顯式返回 error 取代異常機制&lt;/strong&gt; 和 &lt;strong&gt;輕量級併發模型（Goroutine/Channel）&lt;/strong&gt; 在 &lt;strong&gt;雲原生基礎設施領域&lt;/strong&gt; 佔據主導地位，它也是 Java 開發者探索雲原生技術棧的關鍵補充。本文將對 Go 語言和 Java 語言在一些重要特性上進行對比，為 Java 開發者在閲讀和學習 Go 語言相關技術時提供參考。&lt;/p&gt; 
  &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
  &lt;h3&gt;代碼組織的基本單元&lt;/h3&gt; 
  &lt;p&gt;在 Java 中，我們會創建 &lt;code&gt;.java&lt;/code&gt; 文件作為 &lt;strong&gt;類&lt;/strong&gt;（類名與文件名相同），並在該類中定義相關的字段或方法等（OOP），如下定義 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相關的內容便需要聲明兩個 &lt;code&gt;.java&lt;/code&gt; 文件（&lt;code&gt;User.java&lt;/code&gt;, &lt;code&gt;Address.java&lt;/code&gt;）定義類：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; city&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 語言中，它是通過 &lt;strong&gt;「包」&lt;/strong&gt; 來組織代碼的：每個目錄下的所有 &lt;code&gt;.go&lt;/code&gt; 文件共享同一個 &lt;strong&gt;包&lt;/strong&gt;，在包內可以定義多個結構體、接口、函數或變量。它並不要求文件名與聲明的內容一致，比如創建 &lt;code&gt;User&lt;/code&gt; 「結構體」並不會要求 &lt;code&gt;.go&lt;/code&gt; 文件也命名為 &lt;code&gt;User.go&lt;/code&gt;，而是任何命名都可以（命名為 &lt;code&gt;user.go&lt;/code&gt; 甚至 &lt;code&gt;a.go&lt;/code&gt; 這種無意義的命名），而且同一個包下可以創建多個 &lt;code&gt;.go&lt;/code&gt; 文件。如下為在 &lt;code&gt;user&lt;/code&gt; 包下定義 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相關的內容，它們都被聲明在一個 &lt;code&gt;user.go&lt;/code&gt; 文件中：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;type&lt;/span&gt; Address &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   city &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;City&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;city
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;city &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   a&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;相比來説，Java 代碼組織的基本單元是類，作為面向對象的語言更側重對象定義，而 Go 代碼組織的基本單元是包，並更側重功能模塊的聚合。&lt;/p&gt; 
  &lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
  &lt;h4&gt;可見性控制&lt;/h4&gt; 
  &lt;p&gt;在 Java 中通過 &lt;code&gt;public/protected/private&lt;/code&gt; 關鍵字控制成員的可見性，而在 Go 語言中，通過 &lt;strong&gt;首字母大小寫&lt;/strong&gt; 控制「包級別的導出」（大寫字母開頭為 &lt;code&gt;public&lt;/code&gt;），&lt;strong&gt;包的導出成員對其他包可見&lt;/strong&gt;。以 user 包下 &lt;code&gt;User&lt;/code&gt; 類型的定義為例，在 main 包下測試可見性如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;// user package 的全路徑&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
   &lt;span&gt;// 不能導入未使用到的包&lt;/span&gt;
   &lt;span&gt;//"math"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; u user&lt;span&gt;.&lt;/span&gt;User
&lt;span&gt;// 在這裏是不能訪問未導出的字段 name&lt;/span&gt;
&lt;span&gt;// fmt.Println(u.name)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言不能導入未使用到的包，並且函數是基於包的一部分。比如 &lt;code&gt;fmt.Println&lt;/code&gt; 函數，這個函數是在 &lt;code&gt;fmt&lt;/code&gt; 包下的，調用時也是以包名為前綴。&lt;/p&gt; 
  &lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
  &lt;h3&gt;變量的聲明&lt;/h3&gt; 
  &lt;p&gt;在 Java 語言中，對變量（靜態變量或局部變量）的聲明只有一種方式，「採用 = 運算符賦值」顯式聲明（在 Jdk 10+支持 var 變量聲明），如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 語言中，變量聲明有兩種主要方式：&lt;strong&gt;短聲明（&lt;code&gt;:=&lt;/code&gt; 運算符）&lt;/strong&gt; 和 &lt;strong&gt;長聲明（&lt;code&gt;var&lt;/code&gt; 聲明）&lt;/strong&gt;，它們的適用場景和限制有所不同，以下是詳細區分：&lt;/p&gt; 
  &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
  &lt;h4&gt;短聲明（&lt;code&gt;:=&lt;/code&gt;）&lt;/h4&gt; 
  &lt;p&gt;只能在函數（包括 &lt;code&gt;main&lt;/code&gt;、自定義函數或方法、&lt;code&gt;if/for&lt;/code&gt; 塊等）內部使用，不能在包級別（全局作用域）使用，並且 &lt;strong&gt;聲明的局部變量必須被使用&lt;/strong&gt;，不被使用的局部變量不能被聲明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 正確&lt;/span&gt;
x &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 未被使用，不能被聲明&lt;/span&gt;
&lt;span&gt;// y := 20&lt;/span&gt;
&lt;span&gt;// 不賦值也不能被聲明&lt;/span&gt;
&lt;span&gt;// z :=            &lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 錯誤：不能在包級別使用短聲明&lt;/span&gt;
&lt;span&gt;// y := 20          &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這種短聲明直接根據右側值自動推斷變量類型，無需顯式指定類型，並且可以一次性聲明多個變量，但至少有一個變量是 &lt;strong&gt;新聲明的&lt;/strong&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 同時聲明 a 和 b&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
&lt;span&gt;// c 是新變量，b 被重新賦值&lt;/span&gt;
c&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"def"&lt;/span&gt;
&lt;span&gt;// 無新變量無法再次對已聲明的變量再次聲明&lt;/span&gt;
&lt;span&gt;//a, b := 4, "error"&lt;/span&gt;

fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; c&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
  &lt;h4&gt;長聲明（&lt;code&gt;var&lt;/code&gt; 聲明）&lt;/h4&gt; 
  &lt;p&gt;在全局作用域聲明變量必須使用 &lt;code&gt;var&lt;/code&gt;；在需要延遲初始化時也需要採用長聲明；顯示指定類型也需要使用長聲明&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; global &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// a = 0&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;// s = ""&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;// 未被初始化值會默認為「零」值，a 為 0，s 為空字符串&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;函數內部的局部變量，尤其是需要類型推斷和簡潔代碼時優先用短聲明；在包級別聲明變量，需要顯式指定類型或聲明變量但不立即賦值（零值初始化）時，使用長聲明。&lt;/p&gt; 
  &lt;p&gt;在 Go 語言中還有一點需要注意：&lt;strong&gt;聲明變量時，應確保它與任何現有的函數、包、類型或其他變量的名稱不同&lt;/strong&gt;。如果在封閉範圍內存在同名的東西，變量將對它進行覆蓋，也就是説，優先於它，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 這個變量會把導入的 fmt 包覆蓋掉&lt;/span&gt;
fmt &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fmt&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;那麼我們導入的 &lt;code&gt;fmt&lt;/code&gt; 包在被局部變量覆蓋後便不能再被使用了。&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;常量的聲明&lt;/h4&gt; 
  &lt;p&gt;Go 語言中對常量的聲明採用 &lt;code&gt;const&lt;/code&gt; 關鍵字，並且在聲明時便需要被賦值，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// DaysInWeek const 變量名，類型 = 具體的值&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; DaysInWeek &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;const&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
   fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; DaysInWeek&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 語言中對常量的聲明會使用 &lt;code&gt;static final&lt;/code&gt; 引用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Constants&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;DAYS_IN_WEEK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
  &lt;h3&gt;方法/函數的聲明&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中，方法的聲明遵循 &lt;strong&gt;func (接收器) 方法名 (入參) 返回值&lt;/strong&gt; 的格式，無返回值可以不寫（無需 void 聲明），通過 &lt;strong&gt;接收器（Receiver）&lt;/strong&gt; 將方法綁定到結構體上，如下為 &lt;code&gt;User&lt;/code&gt; 結構體方法的聲明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// Name (u *User) 即為接收器，表示該方法綁定在了 User 類型上&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而「函數」的聲明不需要定義接收器，遵循的是 &lt;strong&gt;func 方法名 (入參) 返回值&lt;/strong&gt; 的格式。Go 語言中的函數類似於 Java 語言中的靜態方法，以下是聲明將整數擴大兩倍的函數：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;並且，在 Go 語言中，方法/函數支持多返回值（常用於錯誤處理），並且如果並不需要全部的返回值，可以用 &lt;code&gt;_&lt;/code&gt; 對返回值進行忽略，因為 Go 語言不允許定義未使用的局部變量，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 忽略掉了第三個返回值&lt;/span&gt;
s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;"1"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;此外，接收器參數和函數的形參支持傳入指針，用 &lt;code&gt;*&lt;/code&gt; 符號表示。在 Go 語言中有指針的概念，我們在這裏説明一下：Go 語言是 &lt;strong&gt;「值傳遞」&lt;/strong&gt; 語言，方法/函數的形參（或接收器）如果不標記指針的話，接收的實際上都是 &lt;strong&gt;實參的副本&lt;/strong&gt;，那麼 &lt;strong&gt;在方法/函數中的操作並不會對原對象有影響&lt;/strong&gt;。如果想對原對象進行操作，便需要通過指針獲取到原對象才行（因為值傳遞會對原對象和形參對象都劃分空間，所以針對較大的對象都推薦使用指針以節省內存空間）。在如下示例中，如果我們將上文中 &lt;code&gt;double&lt;/code&gt; 方法的形參修改為值傳遞，這樣是不能將變量 a 擴大為兩倍的，因為它操作的是 a 變量的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要獲取 10，但打印 5&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;想要實現對原對象 a 的操作，便需要使用指針操作，將方法的聲明中傳入指針變量 &lt;code&gt;*int&lt;/code&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;// &amp;amp; 為取址運算符&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要獲取 10，實際獲取 10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// *int 表示形參 a 傳入的是指針&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// *a 表示從地址中獲取變量 a 的值&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;再回到 &lt;code&gt;User&lt;/code&gt; 類型的聲明中，如果我們將接收器修改成 &lt;code&gt;User&lt;/code&gt;，那麼 &lt;code&gt;SetName&lt;/code&gt; 方法是不會對原變量進行修改的，它的修改實際上只針對的是 &lt;code&gt;User&lt;/code&gt; 的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// SetName 指定為值接收器&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這樣 &lt;code&gt;SetName&lt;/code&gt; 方法便不會修改原對象，&lt;code&gt;SetName&lt;/code&gt; 的操作也僅僅對副本生效了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u &lt;span&gt;:=&lt;/span&gt; user&lt;span&gt;.&lt;/span&gt;User&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"abc"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 實際輸出為 {}，並沒有對原對象的 name 字段完成賦值&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 中並沒有指針的概念，Java 中除了基本數據類型是值傳遞外，其他類型在方法間傳遞的都是「引用」，對引用對象的修改也是對原對象的修改。&lt;/p&gt; 
  &lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
  &lt;h3&gt;接口&lt;/h3&gt; 
  &lt;p&gt;Go 語言也支持接口的聲明，不過相比於 Java 語言它更追求 &lt;strong&gt;「靈活與簡潔」&lt;/strong&gt;。Go 的接口實現是「隱式地」，&lt;strong&gt;只要類型實現了接口的所有方法，就自動滿足該接口&lt;/strong&gt;，無需顯式聲明。如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;type&lt;/span&gt; Writer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// File 無需聲明實現 Writer，實現了接口所有的方法便自動實現了該接口&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; File &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;f &lt;span&gt;*&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Java 語言則必須通過 &lt;code&gt;implements&lt;/code&gt; 關鍵字聲明類對接口的實現：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;File&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  &lt;span&gt;// 必須顯式聲明&lt;/span&gt;
   &lt;span&gt;@Override&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;它們對類型的判斷也是不同的，在 Go 語言中採用如下語法：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt; w Writer &lt;span&gt;=&lt;/span&gt; File&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
   &lt;span&gt;// 判斷是否為 File 類型，如果是的話 ok 為 true&lt;/span&gt;
   f&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Java 語言中則採用 &lt;code&gt;instanceof&lt;/code&gt; 和強制類型轉換：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Writer&lt;/span&gt; w &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;File&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; w&lt;span&gt;;&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言還採用空接口 &lt;code&gt;interface{}&lt;/code&gt; 來表示任意類型，作為方法入參時則支持任意類型方法的傳入，類似 Java 中的 &lt;code&gt;Object&lt;/code&gt; 類型：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ProcessData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;除此之外，Go 語言在 1.18+ 版本引入了泛型，採用 &lt;code&gt;[T any]&lt;/code&gt; 方括號語法定義類型約束，&lt;code&gt;any&lt;/code&gt; 表示任意類型，如果採用具體類型限制則如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;// Stringer 定義約束：要求類型支持 String() 方法&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; Stringer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; ToString&lt;span&gt;[&lt;/span&gt;T Stringer&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;通過類型的限制便能使用類型安全替代空接口 &lt;code&gt;interface{}&lt;/code&gt;，避免運行時類型斷言：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 舊方案：空接口 + 類型斷言&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OldMax&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 需要手動斷言類型，易出錯&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 新方案：泛型&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; NewMax&lt;span&gt;[&lt;/span&gt;T Ordered&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b T&lt;span&gt;)&lt;/span&gt; T &lt;span&gt;{&lt;/span&gt; &lt;span&gt;/* 直接比較 */&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;泛型還在通用數據結構上有廣泛的應用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Stack&lt;span&gt;[&lt;/span&gt;T any&lt;span&gt;]&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    items &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;T
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;s &lt;span&gt;*&lt;/span&gt;Stack&lt;span&gt;[&lt;/span&gt;T&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;item T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
  &lt;h3&gt;基本數據類型&lt;/h3&gt; 
  &lt;p&gt;Go 的基本數據類型分為 &lt;strong&gt;4 大類&lt;/strong&gt;，相比於 Java 更簡潔且明確：&lt;/p&gt; 
  &lt;table&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;th&gt;類別&lt;/th&gt; 
     &lt;th&gt;具體類型&lt;/th&gt; 
     &lt;th&gt;説明&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;數值型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;Go 的 &lt;code&gt;int&lt;/code&gt; 長度由平台決定（32 位系統為 4 字節，64 位為 8 字節），有符號整數（位數明確，如 &lt;code&gt;int8&lt;/code&gt; 佔 1 字節）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;uintptr&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;無符號整數（&lt;code&gt;uintptr&lt;/code&gt; 用於指針運算）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;浮點數（默認 &lt;code&gt;float64&lt;/code&gt;）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;複數（實部和虛部分別為 &lt;code&gt;float32&lt;/code&gt; 或 &lt;code&gt;float64&lt;/code&gt;，Java 無此類型）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;布爾型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;僅 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;（不可用 0/1 替代）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;不可變的 UTF-8 字符序列&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;派生型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;byte&lt;/code&gt;（=&lt;code&gt;uint8&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;1 字節數據&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;rune&lt;/code&gt;（=&lt;code&gt;int32&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;Go 語言的字符（rune）使用 Unicode 來存儲，而並不是字符本身，如果把 rune 傳遞給 &lt;code&gt;fmt.Println&lt;/code&gt; 方法，會在控制枱看到數字。雖然 Java 語言同樣以 Unicode 保存字符（char），不過它會在控制枱打印字符信息&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;p&gt;Go 和 Java 同樣都是 &lt;strong&gt;靜態類型語言&lt;/strong&gt;，要求在 &lt;strong&gt;編譯期&lt;/strong&gt; 確定所有變量的類型，且類型不可在運行時動態改變。Go 不允許任何隱式類型轉換（如 &lt;code&gt;int32&lt;/code&gt; 到 &lt;code&gt;int64&lt;/code&gt;），但是在 Java 中允許基本類型隱式轉換（如 &lt;code&gt;int&lt;/code&gt; → &lt;code&gt;long&lt;/code&gt;），除此之外，Go 語言會嚴格區分類型別名（如 &lt;code&gt;int&lt;/code&gt; 與 &lt;code&gt;int32&lt;/code&gt; 不兼容）。在 Go 語言中如果需要將不同類型的變量進行計算，需要進行類型轉換：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2.2&lt;/span&gt;
&lt;span&gt;// 如果不類型轉換則不能通過編譯&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
  &lt;h3&gt;「引用類型」&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中，&lt;strong&gt;嚴格來説並沒有「引用類型」這一官方術語&lt;/strong&gt;，但在 Go 語言社區中通常將 &lt;strong&gt;Slice（切片）、Map（映射）、Channel（通道）&lt;/strong&gt; 稱為「引用語義類型」（或簡稱引用類型），因為它們的行為與傳統的引用類型相似，在未被初始化時為 &lt;code&gt;nil&lt;/code&gt;，並無特定的「零值」。除了這三種類型之外，Go 的其他類型（如結構體、數組、基本類型等）都是 &lt;strong&gt;值類型&lt;/strong&gt;。&lt;/p&gt; 
  &lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
  &lt;h4&gt;Slice&lt;/h4&gt; 
  &lt;p&gt;Go 的 &lt;strong&gt;Slice&lt;/strong&gt; 本質上是動態數組的抽象，基於底層數組實現自動擴容。它類似於 Java 中的 &lt;code&gt;ArrayList&lt;/code&gt;，採用 &lt;code&gt;var s []int&lt;/code&gt; 或 &lt;code&gt;s := make([]int, 5)&lt;/code&gt; 聲明，如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;// 初始化到小為 0 的切片&lt;/span&gt;
  s &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 動態追加元素&lt;/span&gt;
  s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 子切片，左閉右開區間 sub = {2, 3}&lt;/span&gt;
  sub &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sub&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 修改子切片值會影響到 s 原數組&lt;/span&gt;
  sub&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;99&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;切片的底層數組並不能增長大小。如果數組沒有足夠的空間來保存新的元素，所有的元素會被拷貝至一個新的更大的數組，並且切片會被更新為引用這個新的數組。但是由於這些場景都發生在 &lt;code&gt;append&lt;/code&gt; 函數內部，所發知道返回的切片和傳入 &lt;code&gt;append&lt;/code&gt; 函數的切片是否為相同的底層數組，所以如果保留了兩個切片，那麼這一點需要注意。&lt;/p&gt; 
  &lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
  &lt;h4&gt;Map&lt;/h4&gt; 
  &lt;p&gt;Go 的 Map 本質上是無序鍵值對集合，基於哈希表實現。它的鍵必須支持 &lt;code&gt;==&lt;/code&gt; 操作（如基本類型、結構體、指針），聲明方式為 &lt;code&gt;m := make(map[string]int)&lt;/code&gt; 或 &lt;code&gt;m := map[string]int{"a": 1}&lt;/code&gt;，它與 Java 中的 &lt;code&gt;HashMap&lt;/code&gt; 類似，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;learnMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;// 安全的讀取&lt;/span&gt;
  value&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
  &lt;h4&gt;Channel&lt;/h4&gt; 
  &lt;p&gt;Go 的 Channel 是用於 &lt;strong&gt;協程（goroutine，Go 語言中的併發任務類似 Java 中的線程）間通信&lt;/strong&gt; 的管道，支持同步或異步數據傳輸。無緩衝區通道會阻塞發送/接收操作，直到另一端就緒。它的聲明方式為 &lt;code&gt;channel := make(chan string)&lt;/code&gt;（無緩衝）或 &lt;code&gt;channel := make(chan string, 3)&lt;/code&gt;（有緩衝，緩衝區大小為 3），創建無緩存區的 channel 示例如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// 創建沒有緩衝區的 channel，如果向其中寫入值後而沒有其他協程從中取值，&lt;/span&gt;
&lt;span&gt;// 再向其寫入值的操作則會被阻塞，也就是説「發送操作會阻塞發送 goroutine，直到另一個 goroutine 在同一 channel 上執行了接收操作」&lt;/span&gt;
&lt;span&gt;// 反之亦然&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// 啓動一個協程很簡單，即 go 關鍵字和要調用的函數&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// &amp;lt;- 標識符指出 channel 表示從協程中取值，輸出一直都會是 adbecf&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// &amp;lt;- 標識符指向 channel 表示向 channel 中發送值&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"b"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"c"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"d"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"e"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"f"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;如果創建有緩衝的 channel，在我們的例子中，那麼就可以實現寫入協程不必等待 main 協程的接收操作了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channelNoBlocked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 表示創建緩衝區大小為 3 的 channel，並且 channel 傳遞的類型為 string&lt;/span&gt;
channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;// 輸出一直都會是 adbecf&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;在 Go 中創建上述三種引用類型的對象時，都使用了 &lt;code&gt;make&lt;/code&gt; 函數，它是專門用於初始化這三種引用類型的，如果不使用該函數，直接聲明（如&lt;code&gt;var m map[string]int&lt;/code&gt;）會得到 &lt;code&gt;nil&lt;/code&gt; 值，而無法直接操作。它與 Java 中的 &lt;code&gt;new&lt;/code&gt; 關鍵字操作有很大的區別，&lt;code&gt;new&lt;/code&gt; 關鍵字會為對象分配內存 &lt;strong&gt;並調用構造函數&lt;/strong&gt;（初始化邏輯在構造函數中），而在 Go 的設計中是沒有構造函數的，Go 語言除了這三種引用類型，均為值類型，直接聲明即可，聲明時便會直接分配內存並初始化為零值。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
  &lt;h3&gt;從失敗中恢復&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中 &lt;strong&gt;沒有傳統「異常」概念&lt;/strong&gt;，它不依賴 &lt;code&gt;try/catch&lt;/code&gt;，而是通過 &lt;strong&gt;顯式返回錯誤值&lt;/strong&gt; 和 &lt;code&gt;panic/recover&lt;/code&gt; 機制處理。它的錯誤（error）也是普通的數據，能夠作為值傳遞。在多數方法中能看到如下類似的實現：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
data&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 處理錯誤&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;path &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 成功返回 data, nil&lt;/span&gt;
    &lt;span&gt;// 失敗返回 nil, error&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言使用 &lt;code&gt;panic&lt;/code&gt; 來處理不可恢復的或程序無法繼續運行的錯誤（如數組越界、空指針），這類似於 Java 語言中的 &lt;code&gt;throw&lt;/code&gt; 異常，它會中斷方法或函數的執行，向上拋出直到遇到 &lt;code&gt;defer&lt;/code&gt; 和 &lt;code&gt;recover()&lt;/code&gt; 函數的聲明捕獲或者程序崩潰：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 初始化失敗時觸發 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;checkDatabaseConnection&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;panic&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Database connection failed!"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 通過 recover 捕獲 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 延遲函數的執行&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 使用 recover() 函數嘗試捕獲異常 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; r &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;recover&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; r &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Recovered from panic:"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; r&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 正常邏輯...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 關鍵字 &lt;strong&gt;必須修飾的函數或方法&lt;/strong&gt;，而且被這個關鍵字修飾的函數或方法 &lt;strong&gt;一旦註冊&lt;/strong&gt; 無論如何都會被執行（類似於 Java 中的 &lt;code&gt;finally&lt;/code&gt;），但如果 &lt;code&gt;defer&lt;/code&gt; 聲明在函數尾部，但函數在運行到該 &lt;code&gt;defer&lt;/code&gt; 語句之前就退出（例如中途 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;panic&lt;/code&gt;），則 &lt;code&gt;defer&lt;/code&gt; &lt;strong&gt;不會註冊，也不會執行&lt;/strong&gt;。&lt;strong&gt;所以該關鍵字在資源被初始化之後應該立即使用，而非像 Java 一樣聲明在方法的尾部&lt;/strong&gt;。而且 &lt;code&gt;defer&lt;/code&gt; 支持聲明多個，但執行的順序是逆序的。&lt;/p&gt; 
  &lt;p&gt;&lt;code&gt;revocer()&lt;/code&gt; 函數與 &lt;code&gt;defer&lt;/code&gt; 關鍵字搭配使用，它會返回函數執行過程中拋出的 &lt;code&gt;panic&lt;/code&gt;（未發生 &lt;code&gt;panic&lt;/code&gt; 時會為 &lt;code&gt;nil&lt;/code&gt;），可以幫助開發者恢復或提供有用的異常信息。&lt;/p&gt; 
  &lt;p&gt;以下是在文件讀取場景 Go 和 Java 語言在語法上的不同：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Go&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    file&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 處理文件內容&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// try-with-resources&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;FileReader&lt;/span&gt; file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FileReader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 處理文件內容&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;err&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Error: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;問：我看到其他編程語言有 &lt;code&gt;exception&lt;/code&gt;。&lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 函數似乎以類似的方式工作。我可以把它們當作 &lt;code&gt;exception&lt;/code&gt; 來使用嗎？&lt;/p&gt; 
   &lt;p&gt;答：Go 語言維護者強烈建議不要這樣做。甚至可以説，語言本身的設計不鼓勵使用 &lt;code&gt;panic&lt;/code&gt;和 &lt;code&gt;recover&lt;/code&gt;。在 2012 年的一次主題會議上，RobPike（Go 的創始人之一）把 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 描述為「故意笨拙」。這意味着，在設計 Go 時，創作者們沒有試圖使 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 被容易或愉快地使用，因此它們會很少使用。這是 Go 設計者對 &lt;code&gt;exception&lt;/code&gt; 的一個主要弱點的回應：它們可以使程序流程更加複雜。相反，Go 開發人員被鼓勵以處理程序其他部分的方式處理錯誤：使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 語句，以及 &lt;code&gt;error&lt;/code&gt; 值。當然，直接在函數中處理錯誤會使函數的代碼變長，但這比根本不處理錯誤要好得多。（Go 的創始人發現，許多使用 &lt;code&gt;exception&lt;/code&gt; 的開發人員只是拋出一個 &lt;code&gt;exception&lt;/code&gt;，之後並沒有正確地處理它。）直接處理錯誤也使錯誤的處理方式一目瞭然，你不必查找程序的其他部分來查看錯誤處理代碼。所以不要在 Go 中尋找等同於 &lt;code&gt;exception&lt;/code&gt; 的東西。這個特性被故意省略了。對於習慣了使用 &lt;code&gt;exception&lt;/code&gt; 的開發人員來説，可能需要一段時間的調整，但 Go 的維護者相信，這最終會使軟件變得更好。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
  &lt;h3&gt;for 和 if&lt;/h3&gt; 
  &lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
  &lt;h4&gt;for&lt;/h4&gt; 
  &lt;p&gt;Go 語言的循環語法只有 &lt;code&gt;for&lt;/code&gt;，沒有 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do-while&lt;/code&gt;，但可實現所有循環模式：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1. 經典三段式（類似 Java 的 for 循環）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2. 類似 while 循環（條件在前）&lt;/span&gt;
sum &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; sum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    sum &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3. 無限循環（省略條件）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Infinite loop"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;// 需手動退出&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 4. 遍歷集合，採用 range 關鍵字，index 和 value 分別表示索引和值&lt;/span&gt;
arr &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; arr &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Index: %d, Value: %d\n"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_17"&gt;&lt;/span&gt; 
  &lt;h4&gt;if&lt;/h4&gt; 
  &lt;p&gt;Go 語言的 &lt;code&gt;if&lt;/code&gt; 語法相比於 Java 支持聲明 + 條件的形式，並且強制要求大括號（即使是單行語句也必須使用 &lt;code&gt;{}&lt;/code&gt;）：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 支持簡短聲明（聲明 + 條件）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// 簡單判斷&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
  &lt;h3&gt;巨人的肩膀&lt;/h3&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;《Head First Go 語言程序設計》&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18691874</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18691874</guid>
      <pubDate>Mon, 22 Sep 2025 06:58:10 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>華為將投入 150 億元發展軟件生態</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在日前舉行的 HUAWEI CONNECT 2025 大會上，華為&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0QXbEjdebh0-U_HCk9-w3A" target="_blank"&gt;宣佈&lt;/a&gt;搭載鴻蒙 5 的終端設備數量已突破 1700 萬台，開源鴻蒙兼容軟硬件產品超過 1300 款。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143528_t8rk_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="216" src="https://static.oschina.net/uploads/space/2025/0922/143332_rUYk_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;華為同時公佈，將投入 150 億元用於生態發展，併為開源社區提供 1500 PFLOPS 算力支持及 15000 人的開發團隊資源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="213" src="https://static.oschina.net/uploads/space/2025/0922/143401_RhmV_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;華為提出‘四個堅定’，即堅定開源開放、堅定發展人才、堅定全球合作、堅定戰略投入：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先，堅定開源開放&lt;/strong&gt;。華為既是開源的使用者、受益者，也是堅定的支持者與踐行者，堅持將長期積累的軟件能力持續回饋開源社區。華為是全球 20 多個開源基金會的創始成員或頂級成員，並在 300 多個上游社區中成為核心代碼貢獻者。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鴻蒙智聯萬物，成為 AI 原生的全場景終端操作系統&lt;/strong&gt;。OpenHarmony 開源 5 年，匯聚了 9200 多名社區貢獻者，貢獻了 1.3 億行代碼，孵化了 1100 多個三方組件庫，支撐手機、平板、PC 等複雜設備的應用開發。當前，已有 1300 多軟硬件產品通過兼容性測評，並在金融、交通、能源、航天等行業落地，有 60 多款、1700 多萬台華為終端設備搭載了基於 OpenHarmony 開發的鴻蒙 5。鴻蒙版應用全面啓動以來，將碰一碰、掃碼、安全訪問、意圖框架等系統創新能力不斷開放出來，超過 9000 個應用基於這些能力開發出了 70 多種體驗創新。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鯤鵬昇騰全面開源開放，為世界提供算力底座&lt;/strong&gt;。在通用計算領域，華為相繼開源了鯤鵬全系列軟件，包括 openEuler 操作系統、openGauss 數據庫、openUBMC 固件管理、openFuyao 算力集羣軟件、BoostKit 鯤鵬應用使能套件，助力開發者靈活自主地應用創新。未來，華為將圍繞通智融合向 openEuler 貢獻更多的組件和能力。在 AI 領域，昇騰基礎軟件全面開源開放，今年新增開源 CANN、Mind 系列應用使能套件、openPangu 等，支持用户深度挖掘昇騰潛力，加快自主創新。同時，昇騰優先支持業界主流的開源社區和開源項目，昇騰新特性、組件和開發計劃等都將在 PyTorch、vLLM、VeRL、SGLang、Triton 等開源社區上首發。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;華為雲做智能世界「黑土地」，加速千行萬業智能化&lt;/strong&gt;。過去一年，華為雲開發者新增 200 萬，累計達 850 萬。開發者空間迎來全面升級，帶來更多免費的使用時長、函數調用和 Token 資源，讓開發者「每人一台雲主機」。開發者可直接從代碼倉拉起雲開發環境，使用開發者自己偏好的 IDE 和工具，從本地直接使用鯤鵬和昇騰算力，實現代碼實時存儲和調試。&lt;/p&gt; 
&lt;p&gt;此外，在本次大會上華為還一併宣佈正式啓動「天工計劃」，未來將投入 10 億元人民幣支持鴻蒙 AI 生態創新。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143548_9AUB_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方表示，此舉旨在進一步完善鴻蒙生態體系，推動更多合作伙伴加入，共同加速軟硬件適配與創新應用落地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373695</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373695</guid>
      <pubDate>Fri, 19 Sep 2025 06:37:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>中科院推出類腦大模型 SpikingBrain：以 2% 數據實現百倍速度突破</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;中國科學院自動化研究所的李國齊與徐波團隊聯合發佈了全球&lt;span&gt;首款&lt;/span&gt;大規模類腦脈衝大模型 —— SpikingBrain1.0。該模型在處理長文本時展現出驚人的速度，能夠以超過當前主流 Transformer 模型 100 多倍的速度處理 400 萬 token 的超長文本，且僅需 2% 的數據量。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="471" src="https://oscimg.oschina.net/oscnet/up-431a043f8506ca3fef9a4fa56c443b1c610.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;當前主流的大語言模型，如 GPT 系列，普遍基於 Transformer 架構。儘管 Transformer 以其強大的自注意力機制而聞名，但其計算複雜度卻是一個致命的短板。在文本長度增加時，計算量呈現出平方級別的暴漲，使得長文本的處理變得異常耗時和耗能。這一現象讓 AI 在分析長篇小説或法律文書時顯得力不從心。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;為了尋求新的解決方案，研究團隊將目光投向了自然界最為高效的智能系統 —— 人腦。人腦由千億神經元構成，功耗卻僅為 20 瓦。團隊提出了 「基於內生複雜性」 的理念，旨在提升模型內部單元的效率與智能。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;SpikingBrain 模型通過全新的架構模擬了人腦神經元的工作方式，分為兩個版本：SpikingBrain-7B（70 億參數）和 SpikingBrain-76B(760 億參數)。首先，該模型拋棄了傳統 Transformer 的二次方複雜度自注意力機制，採用了 「混合線性注意力架構」，將計算複雜度降至線性 (O (n))，顯著提高了處理長文本的效率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;其次，SpikingBrain 引入了 「自適應閾值脈衝神經元」，使神經元的激活與否取決於接收到的信號強度。通過動態調整閾值，模型確保神經元在高效能狀態下工作，這種事件驅動的機制顯著節省了能耗，計算稀疏度高達 69.15%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，團隊還開發了一套高效的模型轉換技術，能夠將現有的 Transformer 模型直接轉化為 SpikingBrain 架構，降低了訓練成本。所有技術細節和代碼已在 GitHub 及魔搭平台上開源，供全球研究人員使用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373694</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373694</guid>
      <pubDate>Fri, 19 Sep 2025 06:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>滿載而歸，極光斬獲中國信通院多項榮譽</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;滿載而歸&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;極光斬獲中國信通院多項&lt;/strong&gt;&lt;strong&gt;榮譽&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;2025 年 9 月 17 日，由中國互聯網協會與中國信息通信研究院聯合主辦的「2025 數字生態發展大會暨鑄基計劃年中會議」在北京成功舉辦。大會以「洞見十五五——數字生態建設新方向」為主題，系統總結了「鑄基計劃」上半年成果，並圍繞產業數字化轉型路徑展開深度研討。中國互聯網協會副理事長黃澄清、中國信通院總工程師魏然出席並致辭，來自金融、汽車、互聯網、人工智能等 600 餘家企業的代表共聚一堂，展望數字生態新未來。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;在此次大會上，中國領先的客户互動和營銷科技服務商，極光（Aurora Mobile，納斯達克股票代碼：JG），憑藉其在數字化轉型領域的多項創新產品與解決方案，成功入選多項權威名單，榮獲中國信通院頒發的多項重磅榮譽，充分彰顯了極光在推動行業數字化進程中的技術實力與生態價值。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;一、四大產品入選《高質量數字化轉型產品及服務全景圖（2025）》&lt;/strong&gt;極光旗下四款產品通過嚴格評估，成功入選中國信通院編制的《高質量數字化轉型產品及服務全景圖（2025）》：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;strong&gt;GPTBots.ai&lt;/strong&gt;&lt;strong&gt;平台&lt;/strong&gt;&lt;strong&gt;」&lt;/strong&gt;（人工智能領域）&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;strong&gt;極光 JPush SDK&lt;/strong&gt;&lt;strong&gt;」&lt;/strong&gt;與&lt;strong&gt;「&lt;/strong&gt;&lt;strong&gt;EngageLab 平台&lt;/strong&gt;&lt;strong&gt;」&lt;/strong&gt;（市場營銷領域）&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;strong&gt;月狐數據&lt;/strong&gt;&lt;strong&gt;」&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;數據分析領域）&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//9accbfb8a37442c8de9306d6c2d6a000.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//07761ab79bab0b0190877922820061d6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//c3d721fc7cd55ed5c4753058b51c4e42.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//d3255e45078305103dc335c07ce2dc47.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;該全景圖旨在為數字化轉型需求方提供清晰、可靠的產品與服務選型參考，覆蓋 28 個細分領域，經多輪篩選從千餘家企業中最終評定，極光多產品同時入選，體現了其在跨領域數字化服務中的綜合能力。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//beca47f9164dc36f7a8d979641e12d80.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;二、四大解決方案獲評《高質量數字化轉型技術解決方案集（2025）》&lt;/strong&gt;極光在技術解決方案層面同樣表現突出，四項解決方案成功入選權威方案集，包括：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;•&amp;nbsp;&lt;strong&gt;極光數據要素及應用技術解決方案&lt;/strong&gt;該解決方案致力於釋放數據要素核心價值，提供從數據治理、分析到應用的一體化能力，幫助企業在合規前提下利用數據價值推動業務創新與決策智能化。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;•&amp;nbsp;&lt;strong&gt;GPTBots 企業級 AI 智能體平台技術解決方案&lt;/strong&gt;幫助企業快速、低成本、零代碼地構建部署定製化 AI 智能體，覆蓋智能客服、流程自動化、知識管理等高價值場景，驅動業務效率革命。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;•&amp;nbsp;&lt;strong&gt;EngageLab 全渠道客户互動平台技術解決方案&lt;/strong&gt;整合郵件、短信、APP 推送、社交媒體等 20+觸達通道，通過用户行為分析實現精準自動化營銷，提升轉化與留存。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;•&amp;nbsp;&lt;strong&gt;月狐數據全場景數據洞察與分析技術解決方案&lt;/strong&gt;憑藉全面穩定、安全合規的移動大數據根基以及專業精準的數據分析技術，幫助企業洞察市場增量，賦能商業精準決策。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//6736e7faa66591eccc7cb326bf562096.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//6a6e639e095ce0cec7b84d6f09f9f9c0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//7ca6f316c205a5fadeafa364b9d108e6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//bcea9326e3469a14543ac82781705139.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;這些方案從實際業務痛點出發，融合數據技術與智能應用，為企業實現高質量轉型提供了可落地、見實效的路徑支撐。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;strong&gt;AI+寵物情感互動&lt;/strong&gt;&lt;strong&gt;」&lt;/strong&gt;&lt;strong&gt;案例榮獲數字化轉型典型案例&lt;/strong&gt;由極光與陪寵 APP 基於 GPTBots 共同打造的「AI 賦能寵物陪伴」項目，成功入選「2025 鑄基計劃高質量數字化轉型典型案例集」。該案例通過人工智能技術構建情感化、擬人化的寵物交互新模式，是 AI 技術在垂直場景中創新應用的典範，也為情感計算與消費數字化的結合提供了行業參考。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e8e9de6920a825f5c71bffcaf1d3866d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;未來，極光將以此次榮譽為新的起點，繼續加強在數據技術、人工智能與營銷科技等領域的研發與創新，攜手行業協會、學術機構及企業夥伴，共同助力「十五五」時期數字生態的高質量建設與經濟社會可持續發展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373693</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373693</guid>
      <pubDate>Fri, 19 Sep 2025 06:13:00 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>再獲國際認可！GPTBots 斬獲 G2 2025 秋季三項大獎，穩居 AI 智能體賽道第一梯隊</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;再獲國際認可！&lt;/strong&gt;&lt;strong&gt;GPTBots&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;斬獲&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;G2 2025&lt;/strong&gt;&lt;strong&gt;秋季三項大獎，穩居&lt;/strong&gt;&lt;strong&gt;AI&lt;/strong&gt;&lt;strong&gt;智能體賽道第一梯隊&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;近日，全球最大、最受信賴的商業軟件評測平台 G2 發佈了備受矚目的 2025 秋季報告（G2 Fall 2025 Report）。企業級 AI 智能體平台 GPTBots.ai，憑藉其硬核的產品實力與卓越的客户口碑，強勢斬獲三項核心類別徽章，再次印證了其在 AI Agent 賽道的領先地位！&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;G2 的徽章完全基於全球真實用户的反饋和評分，被譽為 B2B 軟件領域的「用户之聲」。此次 GPTBots 榮獲的三項大獎，並非孤立的榮譽，而是對其三大核心價值的權威印證：&lt;strong&gt;卓越的產品體驗、專業的企業級服務能力和持續的創新增長動能。&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//06df8d7054eaab5fe89dbdee19d91d7a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;全球卓越表現者&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;(High Performer) -&lt;/strong&gt;&lt;strong&gt;卓越產品體驗，鑄就全球口碑&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;G2 的「卓越表現者」認證，源於全球用户的高滿意度評分。這背後是 GPTBots 始終秉持「讓企業更容易使用 AI」的使命，對產品易用性的極致追求。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;我們通過&lt;strong&gt;零代碼&lt;/strong&gt;&lt;strong&gt;/&lt;/strong&gt;&lt;strong&gt;低代碼開發工具與豐富的行業模板庫&lt;/strong&gt;，讓業務人員也能自主、快速地搭建 AI 智能體。無論是優化客户服務流程，還是通過 AI 驅動數據分析，我們始終與客户並肩，將複雜的 AI 技術轉化為人人可用的生產力工具，從而贏得了全球用户的真實口碑。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;企業級卓越表現者&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(High Performer - Enterprise) -&lt;/strong&gt;&lt;strong&gt;深耕企業級服務，贏得大型客户信賴&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;在針對大型企業的評選中脱穎而出，標誌着 GPTBots 的企業級服務能力獲得了頂級認可。我們深刻理解大型企業對&lt;strong&gt;數據安全、系統集成和私有化部署&lt;/strong&gt;的嚴苛要求。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;GPTBots 提供完備的&lt;strong&gt;企業級安全體系&lt;/strong&gt;，支持&lt;strong&gt;私有云和本地化部署&lt;/strong&gt;，保障數據隱私與合規。同時，平台可&lt;strong&gt;無縫對接&lt;/strong&gt;&lt;strong&gt;CRM&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;ERP&lt;/strong&gt;&lt;strong&gt;等核心業務系統&lt;/strong&gt;，並提供多組織、多角色的權限控制，確保 AI 解決方案在複雜的業務場景中穩定、高效、安全地運行。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;高增長領導者&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(Momentum Leader) -&lt;/strong&gt;&lt;strong&gt;持續技術創新，驅動強勁增長動能&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;位列細分領域全球前 25%，是市場對 GPTBots 技術創新與高速成長的最佳證明。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;通過行業領先的&lt;strong&gt;Multi-Agent&lt;/strong&gt;&lt;strong&gt;技術&lt;/strong&gt;，企業可靈活組建高效協作的 AI Agent 團隊。平台支持&lt;strong&gt;無縫對接並智能調度主流大語言模型（如&lt;/strong&gt;&lt;strong&gt;OpenAI&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Claude&lt;/strong&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;strong&gt;Llama&lt;/strong&gt;&lt;strong&gt;等）&lt;/strong&gt;，確保企業能以最優的成本和性能組合，快速響應市場需求，驅動業務高速增長。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;客户成功實踐，價值清晰可見&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;某頭部券商&lt;/strong&gt;使用 GPTBots 後，智能客服解決率提升至&lt;strong&gt;95%&lt;/strong&gt;，人工成本降低&lt;strong&gt;70%&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;某零售企業&lt;/strong&gt;通過 AI 營銷助手，線索轉化率提升&lt;strong&gt;300%&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;從「卓越表現」到「高增長領導者」，每一次認證都是客户信任的見證。GPTBots 將繼續深耕產品技術，為全球企業提供更智能、更可靠的 AI 轉型解決方案。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373692</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373692</guid>
      <pubDate>Fri, 19 Sep 2025 06:12:00 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>極光榮獲首批個人信息保護合規審計自審計能力（基礎級）評價證書</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;極光榮獲首批個人信息保護合規審計自審計能力（基礎級）評價證書&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;近日，2025 年國家網絡安全宣傳週在昆明成功舉辦。在本次網安周的網絡安全標準與產業促進座談會上，數安標準強基助力計劃（DSEP）正式發佈了「個人信息保護合規審計自審計能力評價（PCA-SC）」項目。該項目依據《數據安全技術，個人信息保護合規審計要求》（報批稿）及相關政策法規制定，旨在推動企業建立長效合規審計機制。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//8c20e4f397bf8bbc582cebdbf99d265c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;中國領先的客户互動和營銷科技服務商&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;極光 (Aurora&amp;nbsp;Mobile，納斯達克股票代碼：JG)&lt;/strong&gt;&lt;strong&gt;憑藉在個人信息保護合規審計方面的紮實實踐，榮獲第一批「個人信息保護合規審計自審計&lt;/strong&gt;&lt;strong&gt;能力基礎級」評價證書。&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;作為行業頭部企業，極光始終積極響應合規要求，系統推進自審計能力建設，重點開展了以下工作：&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;一、組建專業團隊，夯實審計基礎&lt;/strong&gt;極光成立了跨部門的個人信息保護合規審計專項團隊，匯聚法律合規、信息安全與內部審計等多領域核心骨幹。團隊不僅具備與公司個人信息處理規模相匹配的專業資質，更確保了審計執行過程中的專業性、客觀性和公正性。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;二、健全制度流程，規範審計標準&lt;/strong&gt;在現有合規管理體系基礎上，極光對個人信息處理全流程進行了系統梳理與優化，新增《個人信息保護合規審計管理制度》，將外部監管要求全面轉化為內部執行標準，構建起流程清晰、標準明確、操作規範的審計實施體系。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;三、開展實戰審計，輸出專業成果&lt;/strong&gt;極光主動選取典型業務場景開展合規審計實戰，通過系統排查與分析評估，順利完成全流程審計工作，形成內容完備的審計報告與底稿，為持續優化個人信息保護工作與防範合規風險提供了紮實依據。&lt;/p&gt; 
&lt;p style="color:#444444; margin-left:0; margin-right:0; text-align:left"&gt;獲得該證書，標誌着極光在個人信息保護合規審計方面已建立起符合國家標準要求自審計能力，並獲權威機構認可。這不僅是對極光現有合規工作的肯定，更為公司進一步提升合規治理水平奠定了堅實基礎。未來，極光將持續完善「外規內化」機制，建立法規動態跟蹤體系，不斷拓展審計場景、優化流程，以更高標準切實保障用户個人信息安全與合法權益。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373691</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373691</guid>
      <pubDate>Fri, 19 Sep 2025 06:12:00 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>捷豹路虎遭黑客攻擊致全球工廠停工，英國政府出手援助</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Fbusiness%2Fretail-consumer%2Fuk-working-closely-with-jaguar-land-rover-after-cyber-incident-2025-09-19%2F" target="_blank"&gt;據報道&lt;/a&gt;，針對捷豹路虎遭遇網絡攻擊，導致全球工廠停產一事。英國汽車製造商與貿易商協會聲明證實，政府正在協助捷豹路虎恢復內部系統，同時派遣網絡專家評估「對供應鏈的影響」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141536_gYmO_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Unite 工會週三警告，供應鏈已瀕臨崩潰。英國汽車製造商與貿易商協會聲明寫道：「近期網絡攻擊對捷豹路虎及整個汽車供應鏈造成嚴重影響。政府及網絡專家正在與公司密切合作，支持生產恢復，並評估供應鏈可能受到的衝擊。」&lt;/p&gt; 
&lt;p&gt;此前報道顯示，捷豹路虎在英國受到網絡攻擊，此次攻擊迫使捷豹路虎關閉了其信息技術網絡，導致全球範圍內生產線陷入癱瘓，捷豹路虎全球 33000 名員工被告知生產線受到影響。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141108_8gv3_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;公司稱已通知同事、供應商和合作夥伴，將目前的生產暫停時間延長至 2025 年 9 月 24 日。商業經濟學教授 David Bailey 上週告訴 Autocar，此次事件可能讓捷豹路虎每天損失達 500 萬英鎊。&lt;/p&gt; 
&lt;p&gt;&lt;img height="468" src="https://static.oschina.net/uploads/space/2025/0922/141125_TiMr_2720166.png" width="1024" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141202_bhBb_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;對於此次網絡攻擊，一個自稱 「Scattered Lapsus$ Hunters」 的黑客組織聲稱對這起網絡攻擊事件負責，但並未解釋實施網絡攻擊的訴求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373689</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373689</guid>
      <pubDate>Fri, 19 Sep 2025 06:12:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Valkey：對開源的投資</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Valkey 於一年前成立，旨在為開源社區保留高性能的鍵值存儲，避免被廠商鎖定或受限於限制性許可。項目得到了 AWS、Google Cloud、Ericsson、Oracle、Alibaba、Huawei、Tencent、Percona、Aiven、Heroku、Verizon、Chainguard 和 Canonical 等貢獻者的支持，展示了開源「免費」的背後，依賴於時間、人才和持續的資金投入。&lt;/p&gt; 
&lt;p&gt;&lt;img height="294" src="https://static.oschina.net/uploads/space/2025/0922/140921_eZvD_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;由開發者打造，Linux 基金會支持&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;Valkey 於 2024 年 3 月 28 日誕生，已成為支持緩存、消息隊列等多種工作負載的開源高性能鍵值數據庫，也可用作主數據庫。它由 2000 年成立的中立組織 Linux 基金會支持，後者幫助開發者和技術人員管理、擴展開源項目。Valkey 採用開放治理模式，專注於擴大社區貢獻和用户採納。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;一年回顧：成長與動力&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;僅用一年時間，項目發佈了兩次重要版本，企業參與者從 22 家增至 47 家，正在定義、創新並推進路線圖，用户規模不斷擴大。社區積極擁抱 Valkey，堅定致力於持續改進，惠及所有最終用户。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 新功能與應用場景&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;用 JSON 和 Bloom 過濾器解決實際問題&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的兩種數據類型——JSON 和 Bloom 過濾器，極大擴展了開發者在分佈式系統中對速度和數據結構的需求。它們簡化了應用邏輯，提升了邊緣數據處理效率。Valkey 聯合維護者 Madelyn Olson 表示：「添加 JSON 和 Bloom 過濾器，是為了給開發者提供實用工具，解決分佈式系統中的真實問題。」&lt;/p&gt; 
&lt;p&gt;JSON 支持讓開發者能直接處理豐富且結構化的數據，無需依賴自定義序列化或額外中間件。Olson 解釋：「JSON 讓你能直接在 Valkey 中操作複雜數據，簡化開發，減少膠水代碼。」&lt;/p&gt; 
&lt;p&gt;Bloom 過濾器則提供了一種緊湊且快速的存在性檢測方式。Olson 補充：「在需要快速且節省內存的存在性檢測時，比如防範欺詐或避免高流量服務中不必要的後端調用，Bloom 過濾器非常理想。」&lt;/p&gt; 
&lt;p&gt;Olson 還説：「我很期待看到用户用這些新數據類型解決什麼問題。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Valkey Search：為 AI 工作負載提供速度與規模&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Google 貢獻了 Valkey Search 模塊，支持向量相似度搜索。它響應速度快，延遲單毫秒級，能處理數十億向量，並保持 99% 以上召回率。&lt;/p&gt; 
&lt;p&gt;開發者可執行近似最近鄰（ANN，基於 HNSW）和精確最近鄰（KNN）搜索，支持使用 Hash 或 Valkey-JSON 類型建立索引。儘管當前重點為向量搜索，未來計劃擴展成支持全文檢索和更多索引選項的搜索引擎。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;性能、可靠性與安全性&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;過去一年，Ericsson、Oracle、Percona 等公司貢獻者致力於讓 Valkey 更快、更安全、更適合企業級生產環境。以下改進體現了 Valkey 在滿足大規模生產需求同時，兼顧用户體驗的演進。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;多線程改進&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;近期系統內部更新優化了多線程工作處理，減少鎖競爭，更好利用多核處理器。在高併發場景下顯著提升吞吐量，使項目更適合大規模生產。Ericsson 作為核心貢獻者，已感受到性能提升帶來的實際價值。&lt;/p&gt; 
&lt;p&gt;Ericsson 軟件技術工程師兼 Valkey 聯合維護者 Viktor Söderqvist 指出，核心效率是 Valkey 越來越適合生產的關鍵。「最近的哈希表重設計，結合 SIMD 技術，以及多線程和批量預取內存技術的持續改進，極大提升了 CPU 和內存的存儲效率與速度。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;SIMD 加速哈希表重設計&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;核心哈希表重構利用 SIMD 指令，實現並行處理多個操作，使鍵查找更高效。這些底層優化提升了延遲敏感環境的響應速度。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;批量內存預取&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的批量內存預取功能提前加載數據，減少緩存未命中，保證繁忙或順序訪問場景下性能更穩定流暢。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;LDAP 集成&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;LDAP 集成實現了集中身份認證和訪問控制，簡化了 Valkey 在企業已有身份系統中的部署。這解決了安全和合規要求較高組織的常見障礙。&lt;/p&gt; 
&lt;p&gt;Percona 聯合創始人 Vadim Tkachenko 表示：「很多客户已經依賴 LDAP 管理基礎設施訪問，把它引入 Valkey 很自然。它消除了摩擦，支持審計、基於組的權限，併兼容現有系統。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Rust 模塊&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Oracle 貢獻了基於 Rust 的模塊 SDK，旨在提升底層擴展的安全性和性能。Rust 提供了強大的內存與併發保障，有助於打造更安全、易維護的系統集成，特別適合生產環境高負載場景。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;開源成功背後的真正投資&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;對開源的投資和僱傭貢獻者，體現了技術創新的關鍵：無論是大企業還是小型團隊，都必須協作共贏。這意味着要投入推動項目發展的資源——開源的「免費」背後，是開發者、文檔編寫者、治理團隊和社區的共同努力。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 最新動態&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;2025 年 8 月 15 日，Valkey 發佈了 9.0 版本的第一個候選版本。該測試版展示了原子槽遷移、哈希字段過期、集羣模式下編號數據庫等新功能，幷包含大量性能優化和漏洞修復。後續將發佈更多候選版本，計劃於 2025 年秋初正式發佈 9.0。&lt;/p&gt; 
&lt;p&gt;更多詳情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvalkey.io%2Fblog%2Fvalkey-investment-in-open-source%2F" target="_blank"&gt;查看官方博客&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373688</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373688</guid>
      <pubDate>Fri, 19 Sep 2025 06:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>浙大聯合華為發佈開源安全大模型 DeepSeek-R1-Safe</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;浙江大學網絡空間安全學院與華為公司合作，共同發佈了 DeepSeek R1 模型的安全加強版——DeepSeek-R1-Safe。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-bb459dcf773ec50364dfe5aa3e9b53a0943.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，該模型利用華為的昇騰芯片和 MindSpeedLLM 等框架進行開發，訓練流程如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;訓練數據生成&lt;/strong&gt;：構建安全、合規的數據集&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全監督訓練&lt;/strong&gt;：在訓練過程中引入安全約束&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全強化學習&lt;/strong&gt;：通過 RLHF 等方法優化模型行為&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模型性能評測&lt;/strong&gt;：對安全性能和通用性能進行全面評估&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;其核心優勢在於顯著提升安全防護能力的同時，有效保持模型的通用性能，從而在安全性與可用性之間實現了理想的平衡。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2a6f34121c98b025fdf451a09d010b3fdc4.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;開源地址：&lt;em&gt;https://github.com/ZJUAISafety/DeepSeek-R1-Safe&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373666</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373666</guid>
      <pubDate>Fri, 19 Sep 2025 03:46:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>美團開源推理大模型 LongCat-Flash-Thinking</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美團發佈了一款基於混合專家架構的大型推理模型 LongCat-Flash-Thinking，總參數量達 5600 億，根據上下文需求動態激活 186 億至 313 億參數，平均激活約 270 億參數。&lt;/p&gt; 
&lt;p&gt;該模型在邏輯、數學、編程及 Agent 任務上表現出色，並聲稱在 AIME25 等任務上，使用原生工具可以減少 64.5% 的 token 消耗來達到頂級準確率。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-da818838364ff7d525f309404afcf2b2e39.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FMeituan_LongCat%2Fstatus%2F1969823529760874935" target="_blank"&gt;根據官方公佈的評測結果&lt;/a&gt;，LongCat-Flash-Thinking 在多個基準測試中與其他主流模型進行了對比，在數學推理（如 MATH500, AIME25）、通用推理（如 GPQA-Diamond）、代碼生成（如 LiveCodeBench, OJBench）、Agent 工具使用（如 SWE-Bench, τ²-Bench）以及形式化定理證明（如 MiniF2F-Test）等取得了接近領先模型的水平。&lt;/p&gt; 
&lt;p&gt;LongCat-Flash-Thinking 的模型權重已根據 MIT 許可證開源。官方提供了詳細的聊天模板，模型也已上線官方聊天網站。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://huggingface.co/meituan-longcat/LongCat-Flash-Thinking&lt;br&gt; https://longcat.chat/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373661</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373661</guid>
      <pubDate>Fri, 19 Sep 2025 03:35:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>甲骨文與 Meta 洽談價值 200 億美元的雲計算協議</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;甲骨文（Oracle）目前正在與 Meta 平台進行&lt;span&gt;高級&lt;/span&gt;別的談判，商討一項價值約 200 億美元的多年度雲計算協議。這項協議將使甲骨文能夠為 Meta 提供大量的計算能力，以支持其人工智能模型的訓練和部署，從而進一步補充 Meta 現有的雲基礎設施投資。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="213" src="https://static.oschina.net/uploads/space/2025/0922/112835_c6hS_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這一潛在的合作伙伴關係標誌着科技行業在人工智能基礎設施方面的快速變化。隨着人工智能開發的加速，科技巨頭們紛紛爭相鎖定大規模的計算資源。Meta 尤其在積極擴展其人工智能能力，尤其是其 Llama 大型語言模型，力求在雲服務供應商的選擇上實現多元化。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;甲骨文的戰略轉變也引人注目。曾經被視為數據庫軟件的&lt;span&gt;領導者&lt;/span&gt;，甲骨文現如今已迅速崛起為人工智能雲基礎設施的重要玩家。近期，甲骨文的雲基礎設施（OCI）業務實現了 55% 的收入增長，且剛剛與 OpenAI 簽署了一份價值 3000 億美元的多年度合同，這也顯示了其在人工智能領域的強勁實力。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得注意的是，這一消息推動甲骨文的股票在單日內上漲了 4%，並促使其 2025 年的股價上漲超過 80%。此外，甲骨文的剩餘業績承諾（一個未來收入的關鍵指標）在&lt;span&gt;最新&lt;/span&gt;一季度同比大幅增長 359%，達到 4550 億美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前，甲骨文與 Meta 的談判尚未最終敲定，協議的總價值可能在簽署前發生變化。甲骨文和 Meta 都尚未對此消息進行正式評論。此次談判不僅突顯了雲計算行業的市場動態，還顯示出傳統企業軟件公司與超大規模雲服務提供商在人工智能基礎設施領域的競爭加劇。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;為了滿足日益增長的需求，甲骨文正在加大投資計劃，預計今年資本支出將增加 65%，達到 350 億美元，主要用於新數據中心的建設。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;行業觀察人士對此高度關注：如果最終達成協議，甲骨文將進一步鞏固其作為人工智能領域基礎設施合作伙伴的地位。而對於 Meta 而言，這也是確保其在全球人工智能競爭中擁有足夠計算能力的重要策略。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373657</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373657</guid>
      <pubDate>Fri, 19 Sep 2025 03:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 自動化測試重塑金融軟件質量：Testin XAgent、愛測等平台解析</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//f02002fc292ddfa3c6db0869a069d419.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;在數字金融加速滲透的今天，軟件系統的穩定性與安全性直接關係到金融業務的正常運轉與用户資金安全。而測試作為軟件質量保障的核心環節，正隨着 AI 技術的突破迎來革命性變革。Gartner 發佈的行業數據顯示，2023 年全球自動化測試市場規模已達 281 億美元，預計到 2028 年將翻倍增長至 552 億美元，複合年增長率穩定保持在 14.5%，這一數據清晰地表明 AI 自動化已成為軟件測試領域不可逆轉的核心技術趨勢，尤其在對系統穩定性、安全性要求極高的金融行業，AI 自動化測試的價值愈發凸顯。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;目前，市場上已湧現出多款以 「AI + 自動化」 為核心的測試解決方案，其中不乏適配金融場景的代表性平台，下文將對國內三大主流平台的核心能力與金融行業應用價值進行深度解析，為金融企業選型提供參考。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;一、&lt;/strong&gt;&lt;strong&gt;Testin&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;雲測：以&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;AGI&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;技術破解金融複雜業務測試難題&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;作為國內最早將 AI 技術應用於測試領域的服務提供商，Testin 雲測在金融行業測試場景中積累了豐富經驗，其核心產品 Testin XAgent 智能測試系統更是首批接入 DeepSeek 大模型能力的測試平台，憑藉大語言模型、多模態、Agent 等前沿技術，構建起基於 AGI 的測試需求分析與案例設計能力，同時引入 RAG（檢索增強生成）技術，有效提升了測試用例生成結果的可用性，適配金融行業複雜的業務邏輯與嚴苛的測試要求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;在技術路徑上，Testin XAgent 打破了傳統測試依賴應用視圖樹的模式，建立起基於視覺識別和自然語言理解的測試體系，這一創新不僅大幅降低了腳本維護成本，還降低了技術使用門檻，讓非技術背景的金融業務人員也能參與到測試工作中。具體來看，其核心優勢集中在三個方面：一是 RAG 賦能的領域知識增強系統，該系統能融合金融企業內部的業務文檔、交易數據、風控規則等信息，增強大模型對金融業務的感知能力，生成符合金融業務邏輯的高覆蓋率、高準確率測試用例，尤其適用於跨系統的複雜金融業務測試，如銀行的信貸審批流程、支付結算系統等；二是基於意圖的自動化測試生成功能，金融業務人員只需通過自然語言描述測試需求，如 「驗證信用卡賬單分期還款金額計算準確性」，系統就能自動生成測試腳本，將測試工程師從重複的腳本編寫工作中解放出來，投入到高階的測試分析與策略制定中；三是多模態融合的視覺自愈引擎，該引擎結合視覺大模型 VLM 與 OCR 技術，能 「看懂」 不同終端的界面變化，如手機銀行 APP 的界面更新、網銀系統的頁面調整，實現測試元素的動態定位與腳本自修復，將 UI 自動化穩定性從傳統的 70% 提升至 95% 以上，有效解決了金融系統頻繁迭代導致的測試腳本失效問題。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;在實際應用中，某大型股份制銀行引入 Testin XAgent 後，實現了測試需求點與測試案例的自動化生成，生成結果的採納率達到約 60%，原本需要 3 天完成的信貸系統測試工作，現在 1 天內即可完成，顯著提升了內部測試效率，同時減少了因人工測試遺漏導致的業務風險，成為金融行業開展 AI 自動化測試的典型標杆案例。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;二、霍格沃茲測試開發：以知識圖譜築牢金融業務測試邏輯&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;霍格沃茲測試開發推出的愛測智能化測試平台，定位為企業級軟件質量保障解決方案，其核心功能覆蓋測試用例自動生成、自動執行、自動遍歷測試與知識圖譜構建，尤其在處理金融行業大量業務文檔與複雜邏輯測試場景中表現突出，為金融企業提供了從需求分析到測試執行的全流程自動化支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;金融行業的測試工作往往依賴大量的需求文檔、接口文檔與業務規則説明，愛測智能化測試平台針對這一特點，開發出強大的文檔解析能力，通過接入金融項目的需求文檔，能自動解析業務邏輯、提取測試點，構建起可視化的測試知識圖譜。例如，在銀行理財產品測試中，平台可解析產品説明書中的收益計算規則、風險等級劃分、申購贖迴流程等信息，生成完整的測試知識圖譜，並基於圖譜自動生成測試用例。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;此外，該平台的兩大核心功能進一步適配金融測試需求：一是手工用例 AI 自動化執行，金融企業中存在大量由業務人員編寫的手工測試用例，平台可通過自然語言理解這些用例，利用自動化測試智能體模擬用户操作，如模擬客户登錄手機銀行、申購理財產品、查詢收益等行為，並自動生成測試報告，大幅減少人工執行成本；二是智能遍歷與模型驅動測試，在金融系統新功能上線前，若尚未編寫預設測試用例，平台可通過 AI 自動生成測試場景，如模擬不同用户角色（普通客户、VIP 客户、客户經理）的操作流程，遍歷系統的各項功能，提高測試覆蓋度，避免因測試遺漏導致的業務風險。對於需要處理大量文檔、業務邏輯複雜的金融企業，如銀行、保險公司、證券公司等，愛測智能化測試平台能有效提升業務分析與測試設計效率，保障金融產品的質量與穩定性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;三、騰訊優測：以全鏈路能力保障金融系統高併發穩定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;騰訊雲優測憑藉騰訊在互聯網領域的技術積累，在金融系統高併發、高性能測試場景中展現出獨特優勢。金融行業的核心繫統，如支付系統、證券交易系統、銀行核心賬務系統等，往往需要面對海量用户的併發訪問，尤其是在節假日、電商促銷、證券交易日開盤收盤等高峯期，系統負載驟增，若性能不足，可能導致交易失敗、數據錯誤等嚴重問題，影響用户體驗與企業聲譽。騰訊優測提供的全鏈路壓力性能測試和全生命週期管理功能，能模擬大規模併發場景，精準識別系統瓶頸，提前發現系統在高負載下的響應延遲和性能問題，為金融系統的穩定運行提供保障。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;span&gt;從核心特點來看，騰訊優測的三大優勢高度適配金融行業需求：一是一站式測試解決方案，覆蓋 WebUI（如銀行網銀系統）、服務端 API（如支付接口、證券交易接口）、移動端（如手機銀行 APP、證券交易 APP）等多測試領域，同時支持與金融企業的 CI/CD 流水線集成，實現測試與開發、部署的無縫銜接，加速金融產品的迭代上線速度；二是低代碼設計，金融企業中測試人員的技術背景差異較大，平台在 API 測試中內置標準化步驟與邏輯控制器，測試人員無需編寫代碼，只需通過拖拽、配置等方式即可構建測試用例，如配置支付接口的參數驗證、交易金額校驗等測試邏輯，降低技術門檻，讓更多業務人員參與到測試工作中；三是國產化環境適配，在信創產業快速發展的背景下，金融行業作為關鍵領域，對國產化基礎軟硬件的適配要求日益嚴格。騰訊優測兼容鯤鵬 / 海光服務器、銀河麒麟 / 統信 UOS 操作系統、TDSQL / 達夢數據庫等國產基礎軟硬件，能滿足金融企業在信創轉型過程中的測試需求，保障系統在國產化環境下的穩定性與兼容性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373652</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373652</guid>
      <pubDate>Fri, 19 Sep 2025 03:19:00 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>AOMedia 宣佈在十週年之際推出下一代視頻編碼 AV2</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Alliance for Open Media（AOMedia）&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-nT35LyQcNdDNCnrvtJ1yQ" target="_blank"&gt;宣佈&lt;/a&gt;即將推出開放視頻編碼的下一代技術：AV2，計劃於年底發佈。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告稱，AV2 不僅是 AV1 的升級版，更是 AOMedia 未來技術體系的基礎。AV2 在開放視頻編碼方面實現了跨越式發展，應對全球不斷增長的流媒體需求，壓縮性能遠超 AV1。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;同時增強了對 AR/VR 應用的支持，支持多節目分屏傳輸，改進了屏幕內容處理，能在更廣泛的視覺質量範圍內運行。「AV2 標誌着邁向開放創新媒體體驗未來的重要里程碑。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="221" src="https://oscimg.oschina.net/oscnet/up-83d5dd8ec082a069cc799e9ee642cbaa931.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「AOMedia 相信創新源於開放」，AOMedia 執行董事 Pierre-Anthony Lemieux 表示。「我們的標準匯聚了全球創新者的智慧，並在免版税專利政策保障下開發，能更快地將下一代媒體體驗帶給更多人。我們很高興向世界推出 AV2，繼續通過開放合作引領媒體未來。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;值此十週年之際，AOMedia 還發布了一項會員調查結果。88% 的會員認為 AV1 對其當前或未來產品路線圖「極為關鍵」或「重要」。展望未來，53% 的受訪會員計劃在今年 AV2 最終定稿後 12 個月內採用，88% 預計兩年內實施。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373648</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373648</guid>
      <pubDate>Fri, 19 Sep 2025 03:06:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Sam Altman 預告將推出「計算密集型」新功能與產品</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenAI 首席執行官 Sam Altman 今日在社交平台 X 上發文&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fsama%2Fstatus%2F1969835407421374910" target="_blank"&gt;表示&lt;/a&gt;&lt;/u&gt;，未來幾周內將推出一系列「計算密集型」新功能與產品。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1cfc95cf17d72f801bdc6095775fdac1738.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;他表示，由於相關成本較高，這些功能初期將僅面向 Pro 訂閲用户開放，部分新產品亦將收取額外費用。&lt;/p&gt; 
&lt;p&gt;值得注意的是，Altman 並未透露具體功能細節或收費標準，外界推測此次更新或涉及多模態交互、個性化記憶系統等方向。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373646</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373646</guid>
      <pubDate>Fri, 19 Sep 2025 02:59:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>一文解碼百度地圖 ETA</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-3b1c47fc2aa68dab8d2daf6b89e8fac1ee1.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;你有沒有這樣的體驗？導航説 30 分鐘能到，結果真的一分不差？&lt;/p&gt; 
&lt;p&gt;有時候導航告訴你要繞行 5 分鐘的路，其實省下了 20 分鐘的堵車。&lt;/p&gt; 
&lt;p&gt;這些神奇的「預知能力」，就是我們常聽到的 ETA（Estimated Time of Arrival，預計到達時間），別看它們只是一個個數字，其實背後藏着一整套複雜又高效的技術體系。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;百度地圖 ETA&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;到底是怎麼精準計算出來的呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;【AI 地圖 Tech 説】第二期將為你揭開奧秘！&lt;/strong&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;01 基礎介紹&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;ETA 預測的本質，就是給定出發地、目的地和出發時間後，預測駕車所需的時間。例如，當你在某個時間 T 請求路線（如 Route = a→b→c→d→e）時，ETA 系統便開始計算駕車預計行駛的時長。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-28f94baeb8a2e2886b59ddef02164f01d8d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;百度地圖 ETA（未來出行）是地圖導航的基礎功能，其技術演進共經歷了四個發展階段。&lt;/p&gt; 
&lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 1.0 時代：靜態 ETA（2010 年前）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;最初，百度地圖 ETA 功能的計算方式極為簡單，僅通過距離除以限速得出。然而，這種方式計算出的結果誤差常常超過 30%，一旦遭遇交通擁堵狀況，更是完全無法應對，由此引發了用户的諸多吐槽。&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 2.0 時代：動態 ETA（2010-2015 年）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;百度地圖首次接入實時交通數據，能夠識別實時擁堵路段並提供基本繞行建議。然而，這種方法仍無法預測擁堵的進一步變化趨勢。&lt;/p&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 3.0 時代：個性化 ETA（2015-2021 年）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;通過引入機器學習與用户畫像，百度地圖開始分析駕駛習慣（如激進型或保守型司機）、車輛類型（如貨車或新能源車），實現了針對不同人羣的個性化路線推薦。&lt;/p&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 4.0 時代：預見性 ETA（2021 年至今）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;百度地圖融入 AI 技術，如預訓練大模型和時空預測技術，開始實現未來 30-60 分鐘的精準路況預測，甚至能準確量化天氣對行車速度的影響。&lt;/p&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;02 技術優勢&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;百度地圖 ETA 為何如此精準？背後的核心在於預訓練交通大模型與端到端路線通行時間預測兩大技術。&lt;/p&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 預訓練交通大模型：海量 AI 知識集成體&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;預訓練交通大模型通過地圖脱敏軌跡數據，建模城市交通規律，為智能交通提供底座能力。預訓練交通大模型基於千億公里駕駛數據，能夠精準捕捉不同城市在時段、天氣、區域上的交通規律，如北京週一比周五早高峯堵 12%、上海雨天車速下降 22%、深圳科技園晚高峯比早高峯堵 35%。同時，該模型還具備持續學習優化能力，每天都會結合最新觀察到的真實擁堵情況自動更新模型參數。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-4d11da294a17c976e3f8588cf43a468d3c5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;預訓練交通大模型整體框架&lt;/p&gt; 
&lt;p&gt;預訓練交通大模型的框架主要分為 3 個部分：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-2e10c2032b2def06f542a370b60ba3dd7c6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-877bb97f7d5893864d707d8d1c06b31a3be.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;交通大模型以及下游應用&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Large-Scale Traffic Corpus（大型交通語料數據）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;將原始的脱敏 GPS 軌跡點處理成路段粒度的交通時序信息和路線粒度的個性化導航行為。&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Pre-Train Model（預訓練模型）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基於歷史交通大數據充分訓練預訓練模型，表徵普適性的交通規律信息。&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Downstream Task（下游任務）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基於預訓練的交通圖嵌入，通過 Zero-Shot 或者 Fine-tune 應用於通行時間預估、交通流量預估、路線排序、智能信控等場景。&lt;/p&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 端到端路線通行時間預測：基於交通大模型 FineTune 的 ETA-GNN AI 仿真推演路線模型&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;在預訓練交通大模型基礎上，百度地圖進一步應用端到端路線通行時間預測，進行更細緻的 AI 仿真推演，不再侷限於逐路段的簡單計算，而是精確模擬紅綠燈等待時間、前方車輛匯入情況及施工路段的實際通行效率。同時通過動態概率模型實時評估，決策繞行還是等待，以達到最佳出行策略，預測準確率高達 92%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-c3af8afdeba713546288ccb7c875677960f.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;SFT-ETA 路線模型&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-84a14f312c065044fd4b8f84dad16cac53b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;ETA 路線模型預測 Pipeline&lt;/p&gt; 
&lt;p&gt;端到端路線預測體系涵蓋以下核心能力：&lt;/p&gt; 
&lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;長時流量預測能力（Supervised FineTune）&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;全天候預測能力：通過對歷史流量數據的監督微調，模型可實現對未來 24 小時路段流量變化趨勢的精準預測，適用於節假日、景區周邊等高動態場景。&lt;/p&gt; 
&lt;p&gt;零樣本遷移泛化：預訓練模型內置「早晚高峯模式庫」，可直接遷移至新城市路網，實現冷啓動場景下的預測精度顯著提升。&lt;/p&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;動態交通關係圖譜建模&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;時空圖表示學習：捕捉交通流隨時間與空間變化的普適規律。&lt;/p&gt; 
&lt;p&gt;路網級傳播效應建模：通過圖神經網絡（GNN）結構，量化不同路段之間的流量傳導影響，實現更高精度的區域級擁堵預測與調度模擬。&lt;/p&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;地理語義位置編碼（GeoEmbedding）&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;多維地理語義融合：將傳統經緯度轉換為包含道路等級、POI 密度、地形坡度等語義信息的向量表示。&lt;/p&gt; 
&lt;p&gt;跨模態建模能力：融合天氣、熱度等環境信息，實現對不同條件下相同路段的動態編碼與差異化建模，例如「暴雨下立交橋」和「晴天立交橋」的通行效率差異。&lt;/p&gt; 
&lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;軌跡表示學習與個性化 ETA&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;行為建模：通過車輛歷史脱敏的軌跡聚類，區分不同駕駛風格（如保守型 vs 效率型），提供分羣精準 ETA 預測。&lt;/p&gt; 
&lt;p&gt;實時風格感知與動態修正：感知車輛當前駕駛狀態（如頻繁變道、急加速等），動態調整 ETA 和路徑建議，實現個性化自適應路線仿真與推薦。&lt;/p&gt; 
&lt;span id="OSC_h1_13"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;03 應用場景&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;百度地圖 ETA 廣泛應用於各類場景中：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;日常通勤&lt;/strong&gt;：準確預測早晚高峯路況，幫助通勤族合理安排出行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;機場接送：&lt;/strong&gt;精準判斷當前出發是否能趕上航班，解決旅途焦慮。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;重大活動預警：&lt;/strong&gt;如演唱會結束前提前提醒車主提前離場，避免擁堵。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;節假日旅遊&lt;/strong&gt;：提前預測旅遊景區附近的擁堵趨勢，提供更舒適的出遊體驗。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-5944e11566f599cfcec75ead77d34077afd.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;通過持續的技術進化和 AI 驅動的全面賦能，百度地圖的 ETA 精準度在短途、長途、擁堵、節假日等多個場景均已顯著領先行業水平，在用户感知層面更顯穩健和準確。更值得一提的是，在節假日（尤其「五一」這類與日常規律差異顯著的場景下），其表現尤為突出。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="圖片" src="https://oscimg.oschina.net/oscnet/up-23e482ef44354bc2995b984f5aecfd9e6d7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;出行從此告別盲目與焦慮&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;百度地圖將每一次的未知變成清晰的規劃&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;讓用户安心出發，自信抵達！&lt;/strong&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18692522</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18692522</guid>
      <pubDate>Fri, 19 Sep 2025 02:38:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>OpenMind 開源全球首個「AI 原生」機器人系統 OM1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenMind 現已推出一款號稱是全球首個「AI 原生」開源機器人系統，該系統旨在統一全平台生態，構建統一的開發基礎，讓不同類型的機器人在同一平台上實現感知、推理與行動，支持多種硬件與仿真環境。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6325062d4450079cac06d11cff78a0a6aad.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該系統強調「硬件中立」，可運行在四足、雙足、人形與輪式等不同平台上，並以 Docker 鏡像提供快速部署，兼容 AMD64 與 ARM64 架構，支持接入 OpenAI、Gemini、DeepSeek、xAI 等模型，原生支持宇樹 Unitree G1、Go2、TurtleBot 以及優必選等機器人產品，方便開發者快速上手。&lt;/p&gt; 
&lt;p&gt;OM1 整體架構如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-bc4a425e4784e9f570a7ab229b6690271ed.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模塊化架構：採用 Python 設計，旨在實現簡潔性和無縫集成。&lt;/li&gt; 
 &lt;li&gt;數據輸入：輕鬆處理新數據和傳感器。&lt;/li&gt; 
 &lt;li&gt;通過插件提供硬件支持：通過 API 端點的插件以及與 ROS2、Zenoh 和 CycloneDDS 的特定機器人硬件連接來支持新硬件（建議所有新開發項目都使用 Zenoh）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在自主導航與環境理解方面，OM1 集成了即時定位與地圖構建（SLAM）、LiDAR 傳感器與 Nav2 路徑規劃，讓機器人能夠在複雜環境中實現自主移動。開發者可先通過 Gazebo 仿真環境進行行為測試，再將配置部署至實際硬件，從而降低實驗成本與風險。&lt;/p&gt; 
&lt;p&gt;與此同時，OM1 還提供了名為 OM1 Avatar 的前端界面，基於 React 開發，可實時展示機器人的狀態與虛擬形象，方便觀察和交互。&lt;/p&gt; 
&lt;p&gt;開源地址：&lt;em&gt;https://github.com/OpenMind/OM1&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373637</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373637</guid>
      <pubDate>Fri, 19 Sep 2025 02:28:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里雲爆款雲服務器 68 元/年，2 核 2G 限時秒殺，超高性價比，立即搶購！</title>
      <description>覆蓋 90%+通用業務場景，組合購買「專享活動價」。</description>
      <link>https://click.aliyun.com/m/1000406832/</link>
      <guid isPermaLink="false">https://click.aliyun.com/m/1000406832/</guid>
      <pubDate>Fri, 19 Sep 2025 02:15:00 GMT</pubDate>
    </item>
    <item>
      <title>CNCF 與 Docker 達成合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;CNCF &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5t8eWP9JVkBarMiiitdWEw" target="_blank"&gt;宣佈&lt;/a&gt;與 Docker 達成新合作，進一步擴展對 CNCF 託管項目的安全、可擴展支持。通過此次合作，所有 CNCF 項目將直接接入 Docker 的贊助開源計劃（DSOS），該計劃通過開放高端註冊表、安保和支持服務，助力開源社區成長與成功。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「此次合作體現了 CNCF 對雲原生生態基礎設施的支持承諾，肯定了 Docker 在開源與企業工作流中的重要作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="247" src="https://oscimg.oschina.net/oscnet/up-e4f371307406d850d4cc10ec622363b4bba.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;通過 DSOS 計劃，CNCF 項目將享受：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Docker Hub 無限鏡像拉取 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;贊助開源身份，提升信任和曝光度 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;使用 Docker Scout 進行漏洞分析和策略執行 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;從源碼自動構建鏡像 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;獲取 Docker 使用數據和參與度洞察 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;通過開源渠道簡化支持流程 &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;對項目維護者而言，這意味着獲得更安全、更可擴展、貼近生產級開源項目需求的基礎設施支持；對用户來説，則保證了對雲原生工具的穩定可信訪問。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告稱，此次合作還強調了雙方共同加強開源軟件供應鏈安全的決心。Docker Scout 和 Docker Hardened Images 等工具將為 CNCF 項目帶來更多容器安全洞察與控制，符合現代 DevSecOps 最佳實踐。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Docker 領袖兼 CNCF 大使 James Spurin 補充道：「Docker Desktop 長期以來是我雲原生工作流的重要組成，DSOS 項目擴展到 CNCF 項目，將為維護者和貢獻者帶來重大利好。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Docker 也將成為 CNCF 項目服務頁面的官方服務提供商，提升 CNCF 維護者的發現和使用便利。&lt;span style="background-color:#ffffff"&gt;所有 CNCF 項目均可申請加入並在 Docker Hub 獲得 DSOS 徽章。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373630</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373630</guid>
      <pubDate>Fri, 19 Sep 2025 02:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
