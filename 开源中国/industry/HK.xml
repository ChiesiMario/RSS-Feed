<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-綜合資訊</title>
        <link>https://www.oschina.net/news/industry</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news/industry" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-綜合資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Thu, 27 Mar 2025 07:41:01 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>深度剖析 StarRocks 讀取 ORC 加密文件背後的技術</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互聯網大數據團隊 - Zheng Xiaofeng&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;本文介紹了 StarRocks 數據庫如何讀取 ORC 加密文件，包括基礎概念以及具體實現方案。深入探討了利用 ORC 文件的四層結構和三層索引機制，實現高效查詢加密數據。希望通過本文對 ORC 加密文件讀取功能的實現細節的剖析，讓讀者更加深刻理解 ORC 文件，同時瞭解 StarRocks 支持加解密數據分析的方案。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;為了提升對敏感數據的保護，需要對 Hive 表一些敏感數據進行加密存儲。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Spark 組件已經通過引入了 Apache ORC 項目（Java 版本）對 ORC 格式的 Hive 表的數據進行加解密。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;StarRocks 也使用了 Apache ORC 項目的 C++版本讀寫 ORC 文件，但是&lt;strong&gt;C++版本沒有實現加解密功能&lt;/strong&gt;，在使用 StarRocks 對 Hive 表進行即席分析時，無法對具有加密列的 Hive 表進行查詢，因此，需要對 StarRocks 的 Apache ORC 模塊進行改造，使其支持對 ORC 格式的 Hive 加密表數據讀取功能，數據架構圖如下圖所示：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//42662e0b81a83165a856f0c38387b668.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;希望通過本文對 ORC 加密文件讀取功能的實現細節的剖析，讓讀者更加深刻理解 ORC 文件，同時瞭解 StarRocks 支持加解密數據分析的方案。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、問題引入&lt;/h1&gt; 
&lt;p&gt;在正式開啓全文的閲讀之前，我們首先引入幾個問題，然後帶着這些問題去閲讀後面的內容，將會更有針對性與啓發性，通過深入解答這些問題，我們不僅能夠更好地理解相關的概念和技術，還能提升分析和解決問題的能力。問題如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;程序解壓某個文件時，是否需要一次性讀取整個文件後再進行解壓操作？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;ORC 文件究竟是如何做到在不掃描全文件的情況下就能精準查詢到想要的數據？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;當 SQL 查詢條件不符合最左前綴原則時，ORC 文件中的索引是否就會失效？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據加密、解密、解壓以及壓縮之間的關聯關係到底是怎樣的？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在寫 ORC 文件時為什麼是先壓縮後加密，而不是先加密後解壓？&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
&lt;/blockquote&gt; 
&lt;span id=&quot;OSC_h1_3&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、ORC 文件介紹&lt;/h1&gt; 
&lt;p&gt;ORC（Optimized Row Columnar）文件格式是一種高度優化的列式存儲格式，它主要用於 Hadoop 生態系統中的大數據處理和分析。ORC 文件結構的設計旨在提高 I/O 效率、減少數據讀取時間，並支持複雜的數據類型和壓縮算法。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 四層結構 File ,Stripe,Stream，Group&lt;/h2&gt; 
&lt;p&gt;一個 File 中包含多個 Stripe，一個 Stripe 包含多個 Steam，一個 Stream 包含多個 Group，每個 Group 默認存儲 1 萬行數據，如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//daf79f27d162699ca73e6745cd92b780.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_5&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.2&amp;nbsp;三層索引&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt; ：文件級別各列的統計信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;：Stripe 級別各列的統計信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;：每個 Stripe 內部各列的索引信息，用於判斷 SQL 條件是否下推。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在讀取文件中數據之前，會先讀取以上 3 類索引數據，根據 SQL 條件逐層進行比對，來決定是否跳過某些數據的讀取，減少數據掃描量，從而提升 SQL 查詢效率。&lt;/p&gt; 
&lt;p&gt;下表是隻包含 id 和 name 兩列的 ORC 文件的各層統計信息的案例：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;FileStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//18e323617df740616d0230aa1e15ae4c.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;StripeStat&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//0679ad98f36eaec4b8e50af132d4ee96.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;IndexData&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//a0ad1992999f1f653a589ab33cb184db.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.3 ORC 文件內部詳細結構&lt;/h2&gt; 
&lt;p&gt;前面已經大體介紹了 ORC 文件的結構，下面詳細介紹其內部結構，ORC 文件由多個邏輯層次組成，每個層次都有特定的作用和結構，下圖具體描述了包含 2 列（id，name）的 ORC 文件結構圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//51bb6963b452f9f0a51c7531681f452e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Tail&lt;/strong&gt;：存儲文件的元數據，如列的壓縮信息、統計信息、版本等，包含了三個部分：PostScript、Footer、MetaData。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Body&lt;/strong&gt;：實際存儲數據的部分，由多個 Stripe 組成。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下面分別介紹 Tail 和 Body 內部包含哪些結構：&lt;/p&gt; 
&lt;p&gt;Tail 文件尾部是讀取 ORC 文件的起點，它包含了文件關鍵信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;PostScript&lt;/strong&gt;：存儲文件的壓縮類型、壓縮塊大小、版本信息，Footer 和 MetaData 的長度等，這部分數據不會被壓縮。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Footer&lt;/strong&gt;：記錄了整個文件所有列的統計信息（FileStat），所有 Stripe 的元數據信息（stripesList），加密信息（encryption）以及文件 body 長度。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;MetaData&lt;/strong&gt;：存儲該文件所有 Stripe 的統計信息（StripeStat）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Body 實際存儲數據的部分，由多個 Stripe 組成，每個 Stripe 包含多個 Stream，先存儲索引相關的 Stream（index-Stream），後面存儲實際數據相關的 Stream（data-Stream），每一列包含多個 index-Stream 和 data-Stream，Stripe 是 ORC 文件中數據存儲的基本單元，每個 Stripe 數據大小一般不超過 200M，主要包含下面幾塊內容：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Stripe Footer&lt;/strong&gt;：包含所有 Stream 的元數據（streamsList）和加密信息（encryption）等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Index-Stream&lt;/strong&gt;：存儲索引相關數據的 Stream，按列存儲。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Data-Stream&lt;/strong&gt;：儲實際數據相關的 Stream，按列存儲。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;ORC 文件的讀取是從尾部最後一個字節開始的，得到 PostScript 的長度，讀取 PostScript，然後根據 PostScript 中的 FooteLength，MetaDataLength 信息讀取 MetaData 和 Footer，最後根據 Footer 中的 Stripe 信息讀取具體的數據 Stripe，上面的文字介紹可能不是很直觀，如果想更細節瞭解 ORC 文件結構內容可以參考（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.processon.com%2Fmindmap%2F6503c70803ab061eb31b80da&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件結構思維導圖&lt;/a&gt;，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Forc.apache.org%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;ORC 文件官網介紹&lt;/a&gt;）。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_7&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、相關概念的理解&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 對稱加解密&lt;/h2&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1c56a2f7a82e7f369cd1548d0ef7eb36.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;對稱加解密的要素包括密鑰、明文、密文和加密算法。以下是對這些要素關係的描述：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密鑰&lt;/strong&gt;：密鑰是加密和解密過程中的關鍵元素，它是由隨機數生成的，通常是固定長度的一串二進制數。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;明文&lt;/strong&gt;：明文是指原始的信息，可以是文本、圖片、音頻等各種形式的數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;密文&lt;/strong&gt;：密文是經過加密算法處理後的數據，只有知道密鑰的人才能解密還原成明文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密算法&lt;/strong&gt;：加密算法是將明文轉換成密文的過程，這個過程通常涉及到一系列的數學運算，比如 AEC，RSA 等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;注意：對稱加密的加密密鑰，和 解密密鑰是一樣的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.2 文件的壓縮和解壓縮&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.1&amp;nbsp;壓縮算法&lt;/h3&gt; 
&lt;p&gt;壓縮算法是用於減小文件大小的數學方法。它通過各種技術，如替換、重新編碼、差分編碼、運行長度編碼、字典編碼、變換編碼等，來減少數據的冗餘和實現數據的體積縮小。壓縮算法可以是無損的或有損的：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;無損壓縮&lt;/strong&gt;：意味着原始數據可以完全從壓縮文件中恢復，常用於文本和某些類型的數據文件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;有損壓縮&lt;/strong&gt;：為了獲得更高的壓縮率，允許丟失一些數據，常用於圖像、音頻和視頻文件。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h3_11&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.2 解壓算法&lt;/h3&gt; 
&lt;p&gt;解壓算法是壓縮算法的逆過程，它用於將壓縮文件恢復到其原始狀態。無損壓縮的解壓算法能夠完全恢復原始數據，而有損壓縮的解壓算法則可能無法完全恢復所有原始數據。&lt;/p&gt; 
&lt;p&gt;文件壓縮和解壓縮簡單流程圖如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3edcbf4fcc94f0f715892423538e2ded.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：數據的壓縮算法和解壓算法要一樣&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.2.3 壓縮塊&lt;/h3&gt; 
&lt;p&gt;文件壓縮塊是指對文件進行壓縮處理後生成的一組連續的數據塊。在文件壓縮過程中，文件被分割成多個塊，每個塊都經過壓縮算法處理。一般來説，文件壓縮塊的大小可配置。例如，ZIP 壓縮的每個壓縮塊的大小可以達到 64KB 或更大，而在其他壓縮格式如 7z 中，壓縮塊的大小可以更大，通常為數 MB。這些大小可以根據文件的特性和壓縮算法的性能進行調整，以達到更好的壓縮比和解壓性能。&lt;/p&gt; 
&lt;p&gt;注意：在解壓文件的過程中會從文件中讀取整個壓縮塊數據到內存之後再使用解壓算法進行解壓處理，所以壓縮塊越大每次解壓讀取到內存裏的數據會越大。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 加密壓縮文件讀寫大致流程&lt;/h2&gt; 
&lt;p&gt;在掌握了數據加密和壓縮的基礎知識之後，讓我們從宏觀的角度瞭解一下 ORC 加密文件讀寫流程，如下圖所示：在寫入時，內存中的數據首先被序列化，然後壓縮以減少體積，最後對數據加密。在讀取時，數據首先被解密以恢復原始格式，然後解壓數據得到原始數據，最後通過反序列化原始數據轉換為內存對象。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cd6b640a5a79817353e9bfb6a7fe81d5.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;詳細説明寫入和讀取過程中的各個步驟：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）寫入過程（序列化、壓縮、加密）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：在數據寫入存儲系統之前，首先需要將內存中的對象轉換成可以存儲或傳輸的格式，這個過程稱為序列化。序列化後的數據通常是一個二進制格式，便於後續的處理。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;壓縮&lt;/strong&gt;：序列化後的數據可能會佔用較大的空間。為了減少存儲需求和&lt;strong&gt;提升後續數據加密處理效率&lt;/strong&gt;，接下來對數據進行壓縮。壓縮算法會嘗試去除數據中的冗餘，從而減少數據的體積。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;加密&lt;/strong&gt;：壓縮後的數據需要進行加密，以確保數據的安全性。加密算法會使用密鑰對數據進行加密，生成密文。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;存入文件中&lt;/strong&gt;：加密後的密文被存儲在文件中，等待後續的讀取或傳輸。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;（2）讀取過程（解密、解壓、反序列化）&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解密&lt;/strong&gt;：當需要讀取文件中的數據時，首先需要使用正確的密鑰和加密算法對密文進行解密，恢復為壓縮前的數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解壓&lt;/strong&gt;：解密後，應用解壓算法對數據進行解壓，恢復到序列化前的狀態。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;反序列化&lt;/strong&gt;：解壓後的數據是一個二進制格式，需要進行反序列化，將其轉換為內存中的對象。反序列化是序列化的逆過程，它將二進制數據轉換為可讀可操作的數據結構。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;內存對象&lt;/strong&gt;：經過解密、解壓和反序列化之後，數據最終以內存對象的形式被程序處理。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h1_14&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、StarRocks 讀取 ORC 加密文件實現方案&lt;/h1&gt; 
&lt;span id=&quot;OSC_h2_15&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.1 ORC 文件內部數據加密關係&lt;/h2&gt; 
&lt;p&gt;首先，介紹幾個密鑰的含義：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;statKey&lt;/strong&gt;：用於解密加密列的 FileStat，StripeStat 的密鑰，每個列一個，加密存儲在文件 Footer 裏。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;dataKey&lt;/strong&gt;：用於解密加密列的 IndexData 和 RowData，每個 Stripe 的每一列都有一個，加密存儲在 Stripe 的 Footer 裏。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;masterKey&lt;/strong&gt;：文件的根密鑰，用於解密 ORC 文件中被加密的 statKey 和 dataKey，該密鑰沒有存儲在文件中，一般存儲在 Hive 表屬性上。要解密 ORC 文件中的數據，首先需要獲取這個 masterKey。然而，masterKey 本身也是加密的，因此在讀取 Hive 表之前，必須先從表屬性中提取出加密的 masterKey,訪問密鑰管理服務（Key Management Service, KMS），對加密的 masterKey 進行解密，從而獲得可用於實際解密操作的明文 masterKey 密鑰，一旦獲得了 masterKey 的明文形式，就可以用它來解密 ORC 文件中的 dataKey 和 statKey。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//3f858f3c7fc6ed6c7e5dcdb8f10d2253.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下圖是描述了 masterKey、statKey，dataKey 之間的關係，灰色部分代表是存儲在文件中被加密的數據，綠色部分則是解密之後的數據，包括我們解密後的 statKey，dataKey。獲得這兩個密鑰之後分別用於解密統計信息和文件中的真實數據。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.2 StarRocks 讀取 ORC 加密文件流程&lt;/h2&gt; 
&lt;p&gt;在深入掌握了 ORC 文件中密鑰的相互關係和功能後，我們現在轉向探討 StarRocks 是如何讀取 ORC 加密表的數據。這個過程如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b39f8da7c9f25c2316cbbb845730a54b.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）提交 SQL 查詢&lt;/strong&gt;：用户首先通過 SQL 客户端向 StarRocks FE 節點提交查詢請求。這通常涉及到對 Hive 表下存儲的 ORC 加密文件進行讀取操作。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）獲取解密的 masterKey&lt;/strong&gt;：查詢提交後，系統首要根據 SQL 獲取 Hive 表中的 ORC 文件所需的 masterKey。這個 masterKey 一般存儲在表屬性裏，並且是加密存儲的，必須調用 KMS 服務來解密，得到密鑰明文。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）傳遞 masterKey 明文&lt;/strong&gt;：解密後的 masterKey，以明文形式傳遞給 StarRocks BE 節點。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）讀取並解密密鑰&lt;/strong&gt;：BE 拿到已解密的 masterKey 之後，讀取並解密 ORC 文件中的 statKey 和 dataKey，這兩個密鑰分別用於解密統計信息（FileStat，StripeStat）和實際數據內容，為接下來的統計信息和數據解密做準備。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）使用 statKey 和 dataKey 解密數據&lt;/strong&gt;：BE 使用 statKey 來解密文件的統計信息（fileStat 和 StripeStat）同時使用 dataKey 來解密實際的數據內容。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.3 讀取 ORC 加密文件的關鍵實現細節&lt;/h2&gt; 
&lt;p&gt;通過瞭解前文 StarRocks 讀取 ORC 加密文件流程，我們將深入探討讀取 ORC 加密文件的數據關鍵實現細節。首先，我們提出一個問題：在物理存儲中，文件存儲的是什麼內容？答案是二進制數據。這些二進制數據通常會經過壓縮處理。&lt;/p&gt; 
&lt;p&gt;ORC 文件的讀取流程是自外向內的，類似於&lt;strong&gt;剝洋葱的過程&lt;/strong&gt;，逐步深入到我們需要讀取的目標數據。讀取流程可以概括為：首先讀取文件元數據，通過元數據獲取目標數據的偏移量（offset）和數據長度如下圖所示，然後通過流的方式讀取目標數據。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//e9be4bd8a50aa1870bb661641f960c6e.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具體到 ORC 加密文件的讀取實現代碼，主要採用了設計模式中的裝飾模式方式來組織代碼的。在這個模式中，原始的文件流（SeekableFileInputStream）首先被解密流（DecryptionInputStream）所包裝，如果是非加密文件就沒有這一層，然後解密流又被解壓縮流（DecompressionStream）所包裝。每一層流都只負責向其包裝的流請求數據，並在接收到一定量數據後開始處理自己的邏輯。如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//97de9ae2095fa9576fac708b4fe83419.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這種分層的方法保證每一層都專注於自己的職責，共同協作完成 ORC 文件的讀取任務。通過這種方式，我們不僅能夠高效地讀取 ORC 文件，還能確保數據的安全性和完整性。綜上所述，ORC 文件的讀取流程是一個從文件元數據到具體數據內容的逐步深入過程。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;5.4 加密字段跳讀機制&lt;/h2&gt; 
&lt;p&gt;為了提升數據的查詢效率，查詢數據時會根據索引數據跳過不必要的數據讀取，下面我們介紹加密列跳讀機制，理解了這部分的內容，就能非常清晰的知道，讀取加密字段時，對數據解密與解壓是怎樣協作的。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.1 加密塊與壓縮塊的關係&lt;/h3&gt; 
&lt;p&gt;加密列的數據劃分了多個加密塊與壓縮塊，一個壓縮塊，包含多個加密塊，讀取數據時，先對每個加密塊進行解密，解密多個加密塊之後，把這些解密後的數據塊合併成一個完整的壓縮塊，然後對這個壓縮塊進行解壓得到原始數據下圖是加密塊與壓縮塊的關係圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cf9450e0def2e8eb5a9cbe6abbfde7fe.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_20&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.2 ORC 文件使用的加解密算法和模式&lt;/h3&gt; 
&lt;p&gt;下圖描述了具體的數據加解密過程中以及設計到整個過程中各種元素輸入輸出的關係：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//4f53e022e28a5159e3253e08d126e357.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：同一個數據塊（16 字節）加密過程和解密過程中的，密鑰、IV 值、加密算法和加密模式必須相同。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;明文塊&lt;/strong&gt;：我們對 ORC 文件加密使用的加密算法是 AES-128-CTR/NoPadding，該算法加密數據時 ，會把明文按照 16 個字節劃分多個塊，每個塊加密之後得到的數據就是加密塊。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密塊&lt;/strong&gt;：每個明文數據塊加密之後得到的數據就是加密塊。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;初始向量 IV&lt;/strong&gt;：初始向量 IV 的作用是使加密更加安全可靠（加鹽），我們使用 AES 加密時需要主動提供這個初始向量 IV，而且只需要提供一個初始向量就夠了，後面每個數據塊的加密向量由加密模式決定，所以每個數據塊的加密向量都不一樣。初始向量 IV 的長度規定為 128 位 16 個字節，ORC 文件解密參數 IV 的描述如下：總共 16 個字節，前面 8 個字節分別存儲：列 ID，Stream 類型，Stripe 的 ID ，後面 8 個字節用於填充 min_count，由於我們使用的是 CTR 加密模式，所以這個 min_count 就是加密塊在整個加密數據中的計數，iv 各個內容長度定義如下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//7a5939566e16aa553d81b75f3c0936fd.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;密鑰&lt;/strong&gt;：AES 要求密鑰的長度可以是 128 位 16 個字節、192 位或者 256 位，位數越高，加密強度自然越大，但是加密的效率自然會低一些，因此要做好權衡。我們開發通常採用 128 位 16 個字節的密鑰，我們使用 AES 加密時需要主動提供密鑰，而且只需要提供一個密鑰就夠了，每個數據塊加解密使用的都是同一個密鑰。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;加密模式&lt;/strong&gt;：有 5 種加密模式，這些加密模式的主要目的是為了&lt;strong&gt;不讓重複的明文加密之後得到的密文一樣&lt;/strong&gt;，提升數據安全性，我們使用的是 CTR 模式（計數器模式）對數據加密，那解密的時候也需要 CTR 模式對數據解密，計數器模式介紹請參考鏈接，CTR 模式，的 iv 參數，包含了，加密塊計數（min_count），所以，每次對一個加密塊解密時，需要知道，當前加密塊的初始計數值。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;5.4.3 舉例説明跳讀流程&lt;/h3&gt; 
&lt;p&gt;學習了前面讀取加密數據的關鍵細節之後，舉個例子説明跳讀 ORC 文件流程，假設根據索引數據和查詢條件確定需要讀取某個文件中第 1 個 Strip 中第 1 列的第 5 個 group 的數據，那麼我們知道 group5 數據的偏移量 offset，文件結構如下圖所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//84f4126e46e2dcc2d4149f24ffab44c2.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;具體邏輯大體流程如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//712c47a3adf74ce35e0044d5b87e8498.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;注意：解壓數據塊時，必須把當前解壓塊的所有數據讀出來才能使用對應的解壓算法解壓數據。&lt;/p&gt; 
&lt;p&gt;1）group5 數據的偏移量 group_offset 計算出 group5 數據在哪個壓縮塊裏,計算公式為：block_index = group_offset/zipBlockSize（壓縮塊大小），並得到該壓縮塊的起始位置 zip_head_offset 公式為：zip_head_offset = block_index*zipBlockSize。&lt;/p&gt; 
&lt;p&gt;2）獲取 zip_head_offset 位置對應的加密塊計數，加密塊計數值計算公式為：min_count = zip_head_offset/encrypted-size（加密塊大小） 更新 iv 向量的 min_count 值。&lt;/p&gt; 
&lt;p&gt;3）文件讀指針定位到 zip_head_offset，開始讀取壓縮塊的數據，這個壓縮塊的數據全部讀出之後，使用解壓算法進行解壓。&lt;/p&gt; 
&lt;p&gt;4）通過 group5 在解壓的數據上偏移量和長度，讀取 group5 數據，然後再對數據進行解碼。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_22&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;六、問題解答&lt;/h1&gt; 
&lt;p&gt;通過前面對相關內容的講解，下面我們來解答前文提出的問題：&lt;/p&gt; 
&lt;p&gt;1）文件解壓是否意味着一定是對整個文件進行解壓操作？&lt;/p&gt; 
&lt;p&gt;答：不需要，文件是按照一定大小劃分出若干個壓縮塊，只要讀出相應的壓縮塊進行解壓就行。&lt;/p&gt; 
&lt;p&gt;2）ORC 文件究竟是如何做到在不掃描全文件的情況下就能精準查詢到想要的數據？&lt;/p&gt; 
&lt;p&gt;答：ORC 文件有三層索引，在讀取文件數據之前先讀取各層級的索引信息，根據過濾條件過濾掉不必要的數據掃描，從而提升數據查詢效率。&lt;/p&gt; 
&lt;p&gt;3）當 SQL 查詢條件不符合最左前綴原則時，其索引效果是否就會失效呢？&lt;/p&gt; 
&lt;p&gt;答：不會失效，ORC 文件是列式存儲的，各列信息都是相互獨立的，有自己的索引信息，與行式數據庫的索引最左前綴規則不同。&lt;/p&gt; 
&lt;p&gt;4）數據加密、解密、解壓以及壓縮之間的關聯關係到底是怎樣的？&lt;/p&gt; 
&lt;p&gt;答：請參考本文：5.1 ORC 文件內部數據加密關係，內容。&lt;/p&gt; 
&lt;p&gt;5）在寫加密列數據時，為什麼不是先加密數據再壓縮，而是先壓縮後加密？&lt;/p&gt; 
&lt;p&gt;答：主要是為了提升加密效率，數據被壓縮處理之後，數據量變少了，加密效率就提升了。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_23&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;七、總結&lt;/h1&gt; 
&lt;p&gt;本文介紹了 StarRocks 數據庫如何讀取 ORC 文件的加密數據，包括相關概念理解、ORC 文件介紹、以及 StarRocks 讀取加密 ORC 文件的具體實現方案。闡述了出於數據安全的需要，對 Hive 表中的敏感數據進行加密存儲的必要性，介紹了對稱加密、文件壓縮與解壓、加密壓縮文件讀寫流程等概念，深入探討了 ORC 文件的三層結構和索引機制，以及如何利用這些特性實現高效查詢加密數據。還詳細描述了 StarRocks 讀取加密 ORC 文件的流程，包括獲取解密的 masterKey、使用 masterKey 解密 ORC 文件中的密鑰、以及使用這些密鑰解密數據。&lt;/p&gt; 
&lt;p&gt;希望通過本文對 ORC 加密文件讀取功能的實現細節，讓讀者對 ORC 文件的理解更深刻。最後如果想從代碼層面瞭解 ORC 文件解密過程可以參考&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FStarRocks%2Fstarrocks%2Fpull%2F46809&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;開源 PR&lt;/a&gt;。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18015502</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18015502</guid>
            <pubDate>Thu, 27 Mar 2025 07:23:58 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>AI 產品榜最新統計數據：夸克成國內唯一月活破億 AI 應用</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 產品榜最新統計數據顯示，2025 年 2 月份中國 AI 應用中僅夸克 MAU 破億。AI 產品榜認為，中國互聯網巨頭即將拉開 AI 超級應用爭奪戰，而阿里夸克憑藉 MAU 優勢取得領先身位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;355&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a4a2edf6a5ba93c9a47715cca6b9c4c06f7.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;AI 產品榜指出，以阿里、騰訊、字節為代表的中國互聯網巨頭紛紛將戰略重心轉向 AI，他們將重燃戰火，爭奪 AI 時代的超級應用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 13 日，阿里巴巴宣佈推出 AI 旗艦應用——新夸克。全新夸克基於阿里通義領先的推理及多模態大模型，宣佈告別傳統搜索，升級為一個 All in One 的「AI 超級框」，滿足用户工作、學習、生活的各類 AI 需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;夸克用户規模上的領先，很大程度上源於夸克對於產品價值的定位。阿里巴巴集團副總裁吳嘉近日在接受採訪時就指出，「夸克的核心定位還是希望成為一個服務廣大用户的有用的 AI 產品。我們的目標始終是成為 AI 時代體驗領先的「超級入口」，讓夸克通過‘AI 超級框’重構人與信息和任務的交互方式，成為覆蓋工作、學習、生活的‘全能助手’。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;知名投資人、金沙江創投董事總經理朱嘯虎前不久也在公開場合指出，AI 應用將迎來爆發，新的超級應用將不侷限於 Chat 形態，要做成 AI 超級應用要足夠易用、有產品創新。他提到像夸克就提供了一個好思路，通過一個「AI 超級框」連接用户與智能體。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，AIGCRank 最新一期發佈的《中國 AI 應用排行榜》亦顯示，在 2 月份的榜單中，夸克以日活用户 3429.8 萬，連續兩個月穩居行業第一。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341335</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341335</guid>
            <pubDate>Thu, 27 Mar 2025 07:20:58 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>DuckDB 路線圖發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 是一個高性能的分析型關係數據庫，旨在實現高效的數據分析，由非盈利組織 DuckDB 基金會管理。它易於安裝，運行速度非常快，並且可以在進程內 (in-process) 運行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;項目團隊發佈了最新的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fstable%2Fdev%2Froadmap.html&quot; target=&quot;_blank&quot;&gt;發展路線圖&lt;/a&gt;，具體內容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Planned Features (March 2025)&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;DuckDB 團隊計劃在來年開發的功能：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;background-color:#fafafa; color:#0d0d0d&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fextension-template-c&quot; target=&quot;_blank&quot;&gt;C extension API&lt;/a&gt;&amp;nbsp;的文檔&lt;/li&gt; 
 &lt;li&gt;Generic ODBC catalog，類似於現有的 PostgreSQL / MySQL / SQLite 集成&lt;/li&gt; 
 &lt;li&gt;支持 Go 和 Rust 擴展&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fduckdb.org%2Fdocs%2Fextensions%2Ficeberg&quot; target=&quot;_blank&quot;&gt;通過 iceberg 擴展&lt;/a&gt;改進了對 iceberg 格式的支持&lt;/li&gt; 
 &lt;li&gt;用於模式匹配的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3994&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MATCH RECOGNIZE&lt;/code&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用緩衝區管理器緩存遠程文件內容（例如，在 S3 上查詢 Parquet 文件時）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Future Work&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;計劃在未來的某個時間點完成以下實現：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;時間序列優化&lt;/li&gt; 
 &lt;li&gt;分區感知優化&lt;/li&gt; 
 &lt;li&gt;排序感知優化&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4512&quot; target=&quot;_blank&quot;&gt;數據庫文件加密&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用自動維護的 table samples 進行更好的&amp;nbsp;Filter Cardinality Estimation&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fissues%2F14817&quot; target=&quot;_blank&quot;&gt;Parallel Python UDF&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F4204&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;ALTER TABLE&lt;/code&gt;支持添加外鍵&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;查詢分析的改進（尤其是對於併發運行的查詢）&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F9547&quot; target=&quot;_blank&quot;&gt;XML 讀取支持&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3638&quot; target=&quot;_blank&quot;&gt;Materialized views&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F13396&quot; target=&quot;_blank&quot;&gt;&lt;code class=&quot;language-plaintext&quot;&gt;MERGE&lt;/code&gt;statement&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F3560&quot; target=&quot;_blank&quot;&gt;支持異步 I/O&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fduckdb%2Fduckdb%2Fdiscussions%2F8104&quot; target=&quot;_blank&quot;&gt;支持 PL/SQL 存儲過程&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341325/duckdb-roadmap</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341325/duckdb-roadmap</guid>
            <pubDate>Sun, 23 Mar 2025 06:37:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Ferrous Systems 向 Rust 項目捐贈 Ferrocene 語言規範</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Rust 基金會發文&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frustfoundation.org%2Fmedia%2Fferrous-systems-donates-ferrocene-language-specification-to-rust-project%2F&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;，Ferrous Systems 已同意將其 Ferrocene 語言規範 (FLS) 貢獻給 Rust 項目。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&quot;這筆慷慨的捐贈將為提供官方 Rust 規範提供更清晰的途徑。它還將使 Rust 項目能夠監督其持續發展，為已經依賴 FLS 的公司和個人提供信心，並標誌着 Rust 生態系統的一個重要里程碑。&quot;&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;245&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b43895946bbb58b8a614809fc729137ed7e.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;眾所周知，Rust 一直缺乏一份官方的語言規範。2022 年 12 月，Rust 項目提交了一份 RFC 以鼓勵 Rust 項目開始制定規範。該 RFC 於 2023 年 7 月獲得批准，並開始工作的推進。起初，Rust 項目規範團隊（t-spec）希望以 Rust Reference 為指導，從頭開始創建文檔。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但考慮到現有的一份被廣泛應用的外部 Rust 規範 -- FLS。為避免行業內存在兩種高度可見的 Rust 規範而造成的潛在混淆，t-spec 團隊決定嘗試將 FLS 與 Rust Reference 集成以創建官方 Rust 項目規範。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;FLS 是對 Rust 編程語言的描述，由 Ferrous Systems 於 2022 年 7 月開發，Ferrocene 是專為安全關鍵型和受監管行業設計的 Rust 編譯器和工具鏈。FLS 為 Rust 的語法、語義和行為提供了結構化和詳細的參考，可作為驗證、合規性和標準化工作的基礎。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在經過溝通後，Ferrous Systems 同意將其 FLS 貢獻給 Rust 項目，並允許 Rust 項目接管其開發和管理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告指出，FLS 集成到 Rust 項目會有一個過渡期。第一階段的工作將涉及將 FLS 整合到項目的工具和流程中，以符合現有的 Rust 項目目標。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「一旦集成完成，Ferrous Systems 將能夠依賴該項目的規範版本並停止使用自己的版本。更廣泛地説，這項工作將為其他需要 Rust 規範的人提供官方、權威的參考，幫助他們使用 Rust 編程語言。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341324/donates-ferrocene-language-specification-rust-project</guid>
            <pubDate>Sun, 23 Mar 2025 06:27:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>李想官宣開源整車操作系統</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;李想又拋了一個重磅核彈：&lt;strong&gt;理想汽車要開源汽車操作系統&lt;/strong&gt;！&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;450&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/140153_niCC_2720166.png&quot; width=&quot;850&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;理想汽車董事長兼 CEO 李想在今天上午舉辦的中關村論壇年會上宣佈理想汽車自研整車操作系統——&lt;strong&gt;「理想星環 OS」全面開源，4 月登陸開源社區，成為全球首個將整車操作系統開源的車企&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;563&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/140214_PaFU_2720166.png&quot; width=&quot;1000&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲理想星環 OS 架構&lt;/p&gt; 
&lt;p&gt;李想認為，智能汽車需要專用的操作系統，但每個企業都進行閉源開發會導致資源浪費，延緩行業發展。同時，李想指出，開源生態有助於車企節約研發成本，最終普惠終端消費者。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/140225_ublh_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲理想星環 OS 可有效節約硬件資源&lt;/p&gt; 
&lt;p&gt;長期以來，在汽車電子控制單元（ECU）的標準化軟件架構上，基於 AUTOSAR（AUTomotive Open System ARchitecture）架構的操作系統佔據行業主導地位。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/140237_0776_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;▲AUTOSAR 的作用&lt;/p&gt; 
&lt;p&gt;儘管該架構本身是開放標準，聯盟成員裏也有一汽、上汽、華為等國內公司深度參與，但裏面的核心大廠其實還是傳統歐美汽車產業巨頭在主導。&lt;/p&gt; 
&lt;p&gt;同時，使用該架構的工具鏈需要支付高額授權費，加之閉源系統適配一款新的芯片要 6 個月，耗費大量人力，不確定性強。&lt;/p&gt; 
&lt;p&gt;對此，理想汽車開源整車操作系統打破「黑盒化」技術壁壘，再加之開源能夠幫助企業降低基礎研發投入，避免資源浪費。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;em&gt;來源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fx--tVE4jRT3tOwmglULGwg&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/x--tVE4jRT3tOwmglULGwg&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341314</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341314</guid>
            <pubDate>Sun, 23 Mar 2025 06:02:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>英偉達計劃收購賈揚清的創企 Lepton AI</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;The Information 報道稱，英偉達正洽談收購初創公司 Lepton AI，此次交易價值數億美元。此舉被認為是英偉達進軍雲計算和企業軟件市場的一部分，旨在與亞馬遜和谷歌等主要雲計算提供商展開競爭。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;302&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-df08b6fc0c14edc200906b275dd01be2425.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Lepton AI 成立於 2023 年，由阿里雲前副總裁賈揚清創辦，是一家專注於構建高性能 AI 訓練與推理平台。2023 年 5 月，Lepton AI 完成了 1100 萬美元（摺合人民幣約 7900 萬元）天使輪融資，由 Fusion Fund 基金和 CRV 風投兩家機構投資。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，Lepton AI 主要發佈了兩款產品&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;FastGPU：2024 年 6 月上線的雲 GPU 解決方案，主打經濟高效和可靠。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;Lepton Search：2023 年 12 月推出的對話式搜索引擎，基於 Lepton AI 平台實現，代碼量不到 500 行。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341312/nvidia-advanced-talks-acquire-lepton</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341312/nvidia-advanced-talks-acquire-lepton</guid>
            <pubDate>Sun, 23 Mar 2025 05:50:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌將 Android OS 完全轉變為「內部開發」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Android Authority &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.androidauthority.com%2Fgoogle-android-development-aosp-3538503%2F&quot; target=&quot;_blank&quot;&gt;發佈獨家報道稱&lt;/a&gt;&lt;/u&gt;，谷歌調整了針對 Android OS 的開發策略，&lt;strong&gt;未來 Android OS 將完全轉變為「內部開發」&lt;/strong&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;谷歌已確認 Android OS 的開發將很快完全在「私有環境」中進行&lt;/li&gt; 
 &lt;li&gt;目前，谷歌會在公開的 AOSP Gerrit 上分享一些工作，但未來所有的工作都將在「私有環境」中進行&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;將&amp;nbsp;Android OS 將完全轉變為「內部開發」是為了簡化開發流程&lt;/strong&gt;，對外部開發者沒有影響，谷歌承諾在每次發佈新版操作系統後仍會將源代碼更新到 AOSP&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2390338a0fc5120e9ddaf4181dad39a2051.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;根據報道，谷歌正在從根本上改變未來開發 Android 的方式，將相關開發工作流程徹底轉向內部分支。&lt;strong&gt;這些內部分支僅供 Google 員工和擁有 Google 移動服務 (GMS) 許可的合作公司使用，例如三星和摩托羅拉&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;谷歌解釋稱，這一變化是為了簡化開發工作流程和軟件發佈。這是近期主幹開發趨勢的延續。該公司表示，他們花了多少工作來保持內部開發分支和公共 AOSP 分支之間的同步，而這些分支在功能和 API 支持上會有所不同。合併開發應該可以讓他們擺脱這些複雜性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;為了平衡 AOSP 的開源性質與產品開發策略，谷歌維護了兩個主要的 Android 分支：公開的 AOSP 分支和內部開發分支。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;AOSP 分支面向所有人開放，而谷歌的內部分支僅限於擁有谷歌移動服務（GMS）許可協議的公司訪問。雖然諸如 Android 藍牙協議棧等一些 OS 組件是在 AOSP 分支中公開開發的，但大多數組件，包括核心 Android OS 框架，都是在谷歌的內部分支中私下開發的。&lt;/p&gt; 
&lt;p&gt;現在，&lt;strong&gt;谷歌已確認將把所有 Android OS 開發轉移到其內部分支&lt;/strong&gt;，這一變化旨在簡化其開發流程。&lt;/p&gt; 
&lt;p&gt;雖然發生了這一轉變，但谷歌重申了其對開源的承諾。它繼續致力於在完成開發和準備發佈版本後將後續 Android 版本的最終源代碼發佈到 AOSP，堅持成品的開源性質。&lt;/p&gt; 
&lt;p&gt;谷歌很可能會在不久的將來宣佈有關這一開發流程變化的更多信息，這些變化可能會在一週內生效。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341310/google-android-development-aosp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341310/google-android-development-aosp</guid>
            <pubDate>Sun, 23 Mar 2025 05:37:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Warm-Flow 過去、現在和未來都不會有商業版</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;h1&gt;Warm-Flow 過去、現在和未來都不會有商業版&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Warm-Flow 從 24 年 2 月加入 Dromara 開源社區，也正是由於加入他，Warm-Flow 才等到更多人的關注和幫助。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同時吸引了不少貢獻者，有的也成為了 Warm-Flow 的成員。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;因此為了回饋大家，也是為了 Warm-Flow 更好的發展，再次申明&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;過去、現在和未來都不會有商業版！！！&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;所以還請大家不用擔心，該有的功能陸續都會加上去，敬請期待！&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;事件&lt;/li&gt; 
 &lt;li&gt;子流程&lt;/li&gt; 
 &lt;li&gt;會籤和票籤通過率策略，支持擴展&lt;/li&gt; 
 &lt;li&gt;重啓流程&lt;/li&gt; 
 &lt;li&gt;包容網關&lt;/li&gt; 
 &lt;li&gt;動態表單&lt;/li&gt; 
 &lt;li&gt;仿釘釘設計器&lt;/li&gt; 
 &lt;li&gt;取回&lt;/li&gt; 
 &lt;li&gt;撤銷&lt;/li&gt; 
 &lt;li&gt;實體類、dto、vo 等獨立成一個模塊，方便微服務接入&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;項目介紹&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Dromara Warm-Flow 國產工作流引擎，其特點簡潔輕量，五臟俱全，靈活擴展性強，是一個可通過 jar 引入設計器的工作流。&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;支持常見審批功能、監聽器與流程變量、條件表達式、辦理人變量表達式&lt;/li&gt; 
 &lt;li&gt;自帶流程圖、流程設計器、節點擴展屬性&lt;/li&gt; 
 &lt;li&gt;支持常見的 orm 框架&lt;/li&gt; 
 &lt;li&gt;支持不同的數據庫&lt;/li&gt; 
 &lt;li&gt;生態豐富可擴展，文檔全面&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;&lt;strong&gt;功能思維導圖&lt;/strong&gt;&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src=&quot;https://oscimg.oschina.net/oscnet//2e2cf041b103c7d70aa49f71b2eb2d72.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;流程圖&lt;/strong&gt;&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src=&quot;https://oscimg.oschina.net/oscnet//e7b50dfdeb4fac83b405024b890982da.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;演示地址&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.hhzai.top&quot; target=&quot;_blank&quot;&gt;http://www.hhzai.top&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;賬號密碼：admin/admin123&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;官網&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwarm-flow.dromara.org&quot; target=&quot;_blank&quot;&gt;https://warm-flow.dromara.org&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Warm-Flow 視頻&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1AWRGYEEVr%2F%3Fspm_id_from%3D333.1387.0.0%26vd_source%3D1be886ace16159801f6ed0106df215d9&quot; target=&quot;_blank&quot;&gt;Warm-Flow 初體驗&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341305</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341305</guid>
            <pubDate>Sun, 23 Mar 2025 04:27:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>OpenAI 將完成 400 億美元融資：軟銀領投、估值 3000 億美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-26%2Fopenai-close-to-finalizing-its-40-billion-softbank-led-funding&quot; target=&quot;_blank&quot;&gt;據知情人士透露&lt;/a&gt;&lt;/u&gt;，OpenAI 即將完成由軟銀集團領投的 400 億美元融資，包括 Magnetar Capital、Coatue Management、Founders Fund 和 Altimeter Capital Management 在內的投資者正在洽談參與。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/113653_D5HA_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;據多名知情人士透露，總部位於伊利諾伊州埃文斯頓的對沖基金 Magnetar Capital 可能會注資高達 10 億美元。由於信息屬於保密性質，這些知情人士均要求不具名。&lt;/p&gt; 
&lt;p&gt;OpenAI、Magnetar 和 Founders Fund 的代表拒絕就此輪融資發表評論。Coatue 和 Altimeter 尚未立即回應置評請求。&lt;/p&gt; 
&lt;p&gt;根據研究公司 PitchBook 彙編的數據，這家人工智能開發商的這輪融資將是有史以來規模最大的一輪融資。這筆交易將使該公司的估值達到 3000 億美元，幾乎是 ChatGPT 製造商去年 10 月融資時 1570 億美元的估值的兩倍。&lt;/p&gt; 
&lt;p&gt;據一位知情人士透露，作為交易的一部分，軟銀將向該公司投資 75 億美元，外加來自投資者財團的 25 億美元。這位知情人士表示，今年晚些時候還將有第二筆 300 億美元的投資，其中 225 億美元來自軟銀，75 億美元來自投資者財團。&lt;/p&gt; 
&lt;p&gt;軟銀拒絕置評。這家日本企業集團已向星際之門項目投入了數十億美元，該項目是與 OpenAI、甲骨文公司和 MGX 等合作伙伴在德克薩斯州阿比林成立的合資企業。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341284/openai-close-to-finalizing-its-40-billion-softbank-led-funding</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341284/openai-close-to-finalizing-its-40-billion-softbank-led-funding</guid>
            <pubDate>Sun, 23 Mar 2025 03:38:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>2024 年度「中國科學十大進展」發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2025 年 3 月 27 日，國家自然科學基金委員會&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FNE2935ZMmTN1Ixd04orn6w&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;了 2024 年度「中國科學十大進展」，分別為：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;嫦娥六號返回樣品揭示月背 28 億年前火山活動&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;實現大規模光計算芯片的智能推理與訓練&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;闡明單胺類神經遞質轉運機制及相關精神疾病藥物調控機理&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;實現原子級特徵尺度與可重構光頻相控陣的納米激光器&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;發現自旋超固態巨磁卡效應與極低温製冷新機制&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;異體 CAR-T 細胞療法治療自身免疫病&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;額外 X 染色體多維度影響男性生殖細胞發育&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;凝聚態物質中引力子模的實驗發現&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;高能量轉化效率錒系輻射光伏微核電池的創制&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;發現超大質量黑洞影響宿主星系形成演化的重要證據&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;302&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b9a7717267f93f463b0853bd1f6c5ae250f.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341273</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341273</guid>
            <pubDate>Sun, 23 Mar 2025 03:23:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>美圖 AI 素材生成器 WHEE 接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;美圖公司旗下的 AI 素材生成器 WHEE 近日&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9Sa0Q68P-74QR8WKhXg47Q&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;成功接入&amp;nbsp;DeepSeek R1 滿血版。此舉旨在將 DeepSeek 的專業提示詞設計能力與 WHEE 的易用性相結合，幫助用户在無專業背景的情況下輕鬆生成高質量的圖像內容。用户只需輸入簡單的詞彙，AI 便能一鍵生成專業提示詞，大大降低了使用門檻。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此次 WHEE 接入 DeepSeek R1，通過提示詞優化功能，能夠自動補全光影、構圖和風格等關鍵詞，從而生成更為豐富和完整的文案內容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;350&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-025674c89918714c860c2c35557502b8f99.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;WHEE 的相關負責人指出，DeepSeek 的接入不僅是功能上的疊加，更是一個 「翻譯器」 和 「靈感孵化器」，能通過多種方案的對比來激發創作者的靈感。藉助 DeepSeek 強大的語義理解和聯想能力，WHEE 希望降低創作者的使用門檻，助力創意的精準落地。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，美圖公司旗下的多款產品，如美圖設計室、開拍、WHEE、MOKI 等均已接入 DeepSeek R1。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341261</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341261</guid>
            <pubDate>Sun, 23 Mar 2025 03:02:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 預估 2025 年營收將達到 127 億美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-26%2Fopenai-expects-revenue-will-triple-to-12-7-billion-this-year&quot; target=&quot;_blank&quot;&gt;據彭博社今日報道&lt;/a&gt;&lt;/u&gt;，OpenAI 預估其 2025 年營收將達到 127 億美元（約合 923 億元人民幣），相比 2024 年 37 億美元（約合 269 億元人民幣）的營收翻了超三倍。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/103323_ghkE_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在該預估基礎上，OpenAI 預計其 2026 年營收將達到 294 億美元（約合 2,136.8 億元人民幣），2029 年更將超過 1,250 億美元（約合 9085.2 億元人民幣）。&lt;/p&gt; 
&lt;p&gt;報道指出，OpenAI 此前正與軟銀集團進行談判，軟銀計劃以 2600 億美元估值向 OpenAI 注資 400 億美元，部分資金將用於 OpenAI 與軟銀、甲骨文聯合成立的 Stargate 項目；此外，OpenAI 還一直在與監管機構談判，計劃從非營利組織轉變為更傳統的營利性公益公司。&lt;/p&gt; 
&lt;p&gt;產品迭代方面，&lt;a href=&quot;https://www.oschina.net/news/341240/openai-agents-sdk-mcp&quot;&gt;OpenAI 在今日凌晨對 Agent SDK 進行了重大更新&lt;/a&gt;：支持大模型上下文協議 MCP。&lt;/p&gt; 
&lt;p&gt;目前，OpenAI 已經在開源的 Agent SDK 中支持 MCP，API 和桌面版 ChatGPT 也將很快提供。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341252</guid>
            <pubDate>Sun, 23 Mar 2025 02:34:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>算力，並不是大模型廠商發展的護城河</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;p&gt;上個月，OpenAI CEO 山姆·奧爾特曼在社交媒體上表示，號稱 52 萬億參數量的 GPT-5 將在數月內發佈。相較於上一代 GPT-4 的 2 萬億參數，體量上足足增長了 26 倍，雖無公佈具體的訓練成本，但想必也一定是個天文數字，堪稱大模型領域的「力大磚飛」。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b5d3d49a58e00ea764875a0cd773ce57.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;反觀 LLM 界的「黑天鵝」，DeepSeek-V3 卻僅用了 2048 塊英偉達 H800 ，耗費了 557.6 萬美金就完成了訓練，一度引起硅谷恐慌，力證了：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;並非不可逾越的堡壘。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;一邊是暴力填鴨，一邊是技術深化，2025 年的大模型似乎走出了兩條截然不同的道路，也逐漸撕開了 AI 行業最殘酷的真相：&lt;strong&gt;早期以「&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;」建立護城河的大模型廠商們，在面對新一輪技術衝擊時，高成本的算力反而成為了其靈活發展的累贅。&lt;/strong&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_1&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;算力的必要性和侷限性&lt;/h3&gt; 
 &lt;p&gt;作為數字經濟的「新電力」，算力在大模型的訓練和推理過程中確實起到了不可或缺的作用。&lt;/p&gt; 
 &lt;p&gt;以 OpenAI 為例，早期在 GPT-4 的訓練中，大概就使用了 25000 個 A100 芯片。如果 OpenAI 雲計算的成本是差不多 1 美元/每 A100 小時的話，那麼在這樣的條件下，&lt;strong&gt;僅一次訓練的成本大約是 6300 萬美元&lt;/strong&gt;，同期還不乏實驗、試錯以及其他成本。OpenAI 的技術負責人直言：「每一次模型迭代都需要近乎天文數字的算力支撐。」&lt;/p&gt; 
 &lt;p&gt;而在推理成本方面，截至 2024 年 3 月，OpenAI 就已花費 40 億美元租用微軟的服務器集羣，該集羣相當於 35 萬個英偉達 A100 芯片，算力消耗不可謂不大。&lt;/p&gt; 
 &lt;p&gt;反觀國內，同樣印證了這一規律。2025 年初，南京智算中心聯合寒武紀，基於 7280 塊國產 AI 加速卡構建全國產化算力平台，以運行 DeepSeek 671B 大模型，在供應鏈優化、智能客服等零售場景實現毫秒級響應。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2f8b6f62899001ee832509d86ebb956b.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;南京智算中心機房，來源：南京智算中心&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;這二者的共性在於：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;始終是&lt;/strong&gt;&lt;strong&gt;大模型&lt;/strong&gt;&lt;strong&gt;研發的「基礎設施入場券」&lt;/strong&gt;，正如 DeepSeek 技術白皮書所言：大模型的競爭，首先是算力基礎設施的競爭。&lt;/p&gt; 
 &lt;p&gt;但其實，「算力」本質上是一種「商品化」資源，自帶經濟週期屬性，隨着硬件成本的下降和雲服務的普及，算力也逐漸脱離賣方市場，一些囤貨居奇的算力廠商更是很難轉型。&lt;/p&gt; 
 &lt;p&gt;比如，2023 年 AI 大模型熱潮期間，算力需求呈爆發式增長，英偉達 H100 8 卡節點年租金峯值達到 20 萬元，而隨着大模型從訓練階段轉向推理階段，算力需求驟減（訓練需千卡級，推理僅需單卡級），2024 年 H100 8 卡節點年租金跌至 6 萬，很多中小型企業也能依靠算力租用跑步入場。&lt;/p&gt; 
 &lt;p&gt;而在算力租賃市場，截至去年，很多算力中心都出現了出租率不高、回款週期長，甚至一些底子不深的廠商直接關停一半機房，以降低日常運營成本。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5fb3eacaa5d6decdecd8eaf02618394d.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;來源：《&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;算力&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;荒，自主化智算還有必要嗎？》-腦極體&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;可見，大模型廠商早期在硬件性能和算力中心上的建設，雖然能夠在短期內加速模型的訓練和推理，但並不意味着競爭對手無法通過硬件設施的「經濟逆週期」，以及技術優化實現彎道超車，這就是「算力」這一大模型發展的必要資源所刻在骨子裏的侷限性。&lt;/p&gt; 
 &lt;p&gt;直至 DeepSeek 的出現，「卡多模優」的大模型發展格局，徹底失去優勢。&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;護城河的重構：從「堆料」到「四維壁壘」&lt;/h3&gt; 
 &lt;p&gt;相較於單純的硬件「堆料」，模型創新、數據規模、算法工程及生態構建的四維能力矩陣，正成為越來越多大模型廠商穿越週期的關鍵壁壘。2025 年行業數據顯示，頭部廠商研發投入中，算法優化（ 38% ）與場景化工程（ 27% ）的佔比已超過硬件採購（ 25% ），書寫新競爭法則——&lt;strong&gt;效率優先於規模。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;以 DeepSeek 為例，通過「三維創新體系」重構行業範式：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;模型層，首創「神經元動態剪枝+混合精度訓練」架構，使 1.6 萬億參數模型體積壓縮 80% ，推理速度提升 500%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據層，構建金融/政務領域「知識-行為-反饋」三元數據閉環，標註成本降低 65%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;而在跟算力相關的工程層，其分佈式訓練調度系統，將千卡集羣利用率從 58% 提升至 92%。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//93414f30d7f61d6d5973d26012e11932.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;憑藉這套組合拳下來，DeepSeek 訓練成本降至同期競品的 17% ，這種「技術驅動型」增長，不僅是對思維鏈突破、數據處理、系統優化等技術的最佳詮釋，甚至使得 DeepSeek 利潤猛增。&lt;/p&gt; 
 &lt;p&gt;以行業具體實施來看。在算力的制約下，長足以來，業內很多人都不太看好 MaaS 這樣的商業模式，因為 MaaS 的核心成本是算力租賃，依賴 API 調用按 token 計費，本質上可以看作為「算力批發」——&lt;strong&gt;想要賺錢，你就得投入大量算力儲備，保證高併發和彈性伸縮，碰上 API 價格內卷，很多廠商根本負擔不起高額得硬件投入。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1ef35030fdc620a594a6096008472682.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;但隨着 DeepSeek 出現，通過大規模的並行（包括數據並行和專家並行），儘可能為每個 GPU 分配均衡的計算負載、可通信負載，以技術升級，提升算力效率。根據&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27181462601&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《DeepSeek-V3 / R1 推理系統概括》&lt;/a&gt;一文中闡述：以 24 小時計算，DeepSeek V3 和 R1 推理服務峯值佔用總和 278 個節點，平均佔用 226.75 個節點（每個節點為 8 個 H800 GPU ）。假定 GPU 租賃成本為 2 美金/小時，日成本為 87072 美元/天。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;而對比 24 小時所輸出的 tokens 全部按照 DeepSeek R1 的定價計算，理論上一天的總收入為 562027 美元/天，成本利潤率高達 545%&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//92f0b2c24548560677469843c4826cc8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;除此之外，&lt;strong&gt;開源生態&lt;/strong&gt;正加速成為模型創新的催化劑。Meta Llama 3 通過開源策略（免費使用、多平台支持）及訓練效率優化（預訓練數據擴展、後訓練技術），使中小企業模型部署成本顯著降低；智譜 GLM-4 依託 10 萬開發者社區的持續優化，在代碼生成等任務上實現同參數模型的性能超越，體現了開源協作對模型迭代的推動作用。&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;如此看來，這場產業革命的深層動因，不僅源於算力資源的成本週期，更源自於技術演進的內在規律：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;供給的週期調整&lt;/strong&gt;&lt;/span&gt;：2023-2025 年全球總算力複合增長率達 147%，但單位算力成本下降曲線（年降 68%）遠超規模擴張速度，標誌着算力正從「戰略資源」向「基礎建設」加速蜕變。簡言之，算力主導的大模型經濟，難以覆蓋早期硬件設備上的成本投入；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;價值創造的路徑遷移&lt;/strong&gt;&lt;/span&gt;：算法創新對模型效能的貢獻率從 2020 年的 38% 躍升至 2025 年的 67%。例如 DeepSeek 的算法優化、理論利潤，間接證明瞭&lt;strong&gt;算法創新才能撬動&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;效益，並也能實現很好的商業變現。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;站在 2025 年的時代座標回望，算力作為產業發展的「數字燃料」，已完成了它幫助早期模型廠商爬坡式發展的使命，隨着越來越多大模型應用的加速投產，模型廠商們能依仗的絕不是訓練、推理這些模型的算力規模，而是真正能讓這些算力產生乘積效應的技術創新、能力整合，以及市場洞察。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;之爭的終局，是通過技術讓算力不再成為問題。&lt;/strong&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/7819858/blog/18015313</link>
            <guid isPermaLink="false">https://my.oschina.net/u/7819858/blog/18015313</guid>
            <pubDate>Sun, 23 Mar 2025 02:31:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>騰訊元寶支持實時預覽 HTML 代碼</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 26 日，首發接入 DeepSeek V3-0324 最新模型後，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfYn2utj1aiJcuI58JuZ4zw&quot; target=&quot;_blank&quot;&gt;騰訊元寶再次發佈更新&lt;/a&gt;&lt;/u&gt;，&lt;strong&gt;支持實時預覽 HTML 代碼&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/102015_iEXO_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;目前，元寶的混元與 DeepSeek 兩大模型均支持代碼生成，覆蓋前端、腳本、數據處理等多種主流語言，適配多類開發場景，適合開發者和各類用户快速上手。結合元寶雙模型在代碼方面的表現，也還夠幫助用户代碼審查相關工作。&lt;/p&gt; 
&lt;p&gt;此外，使用 DeepSeek V3-0324 模型，除了網頁生成，還能完成更多類型的代碼生成任務，如生成 UI 組件、構建網頁、編寫小遊戲，甚至是生成 3D 動畫等。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;810&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/102200_dqsd_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;現在，用户在元寶選擇 DeepSeek，並關閉「深度思考」，便可使用最新的 V3-0324。該模型在代碼生成穩定性、邏輯控制精準度和響應速度上均有明顯提升，在數學、代碼類相關評測集上取得了超過 GPT-4.5、Claude Sonnet 3.7 的得分成績。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/341137/deepseek-v3-0324-detail&quot; target=&quot;news&quot;&gt;DeepSeek 官方詳解 V3 模型「小版本」升級，各項能力全面進階&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340789/deepseek-v3-0324&quot; target=&quot;news&quot;&gt;DeepSeek V3 模型更新，大幅提升編程能力&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341248</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341248</guid>
            <pubDate>Sun, 23 Mar 2025 02:22:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>萬字長文解讀 MCP 框架，讓你掌握 mark3labs/mcp-go</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、引言&lt;/h1&gt; 
&lt;div&gt;
  在 
 &lt;a href=&quot;https://my.oschina.net/qiangmzsx/blog/17987222&quot;&gt;《萬字長文，帶你讀懂 Anthropic MCP》&lt;/a&gt;中我們介紹了 MCP 的基本框架和組件，並初步説了在 golang 中的框架 metoro-io/mcp-golang 和 mark3labs/mcp-go。本文將通過實踐和源碼的方式先解讀 mark3labs/mcp-go。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;298&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-803fb33e305fbbb839a0166e62ed0c18111.jpg&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、MCP-Server 的簡述&lt;/h1&gt; 
&lt;div&gt;
  MCP Server 一般為輕量的服務端程序，通過一種標準的協議 (MCP) 暴露出特定資源的一些特定的能力。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.1 連接生命週期&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 初始化連接&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img height=&quot;1104&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-71f5896875ced4bfcd504e32c61489dd750.png&quot; width=&quot;1250&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客户端發送帶有協議版本和功能 initialize 請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    服務器以其協議版本和功能進行響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客户端發送 initialized 通知作為確認 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    開始正常信息交換 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 信息交換&lt;/h3&gt; 
&lt;div&gt;
  初始化後，支持以下模式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    請求-響應：客户端或服務器發送請求，對方響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通知：任何一方發送單向消息 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.3 終止&lt;/h3&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}&lt;/code&gt;&lt;/pre&gt; 任何一方都可以終止連接： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通過 close() 乾淨關閉 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    傳輸斷開 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    錯誤情況 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      請求的錯誤響應 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      傳輸中的錯誤事件 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      協議級錯誤處理程序 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  常見錯誤碼： 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_7&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.2 MCP Server 的業務能力&lt;/h2&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Request Method&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發起方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;響應方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;initialized&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;初始化會話&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;tools-list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;tools/call&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;調用工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的資源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/read&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;獲取資源內容&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/templates&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的參數化資源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/subscribe&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;訂閲特定資源，監聽其變化事件&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;prompts/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的提示詞&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;prompts/get&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;獲取特定提示詞&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;roots/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;列出服務器有權訪問的客户端文件系統根節點（暴露目錄和文件）&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;sampling/create&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;啓用服務器的 AI 生成能力（ sampling creation ）&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_8&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、mark3labs/mcp-go 示例&lt;/h1&gt; 
&lt;div&gt;
  我們就以框架中的官方示例代碼為引子一步步解讀流程和框架代碼。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;context&quot;
    &quot;errors&quot;
    &quot;fmt&quot;

    &quot;github.com/mark3labs/mcp-go/mcp&quot;
    &quot;github.com/mark3labs/mcp-go/server&quot;
)

func main() {
    // 創建 MCP 服務器
    s := server.NewMCPServer(
       &quot;Demo 🚀&quot;, // 服務器名稱
       &quot;1.0.0&quot;,  // 服務器版本
    )

    // 添加工具
    tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名稱
       mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
       mcp.WithString(&quot;name&quot;, // 參數名稱
          mcp.Required(), // 參數是必需的
          mcp.Description(&quot;Name of the person to greet&quot;), // 參數描述
       ),
    )

    // 為工具添加處理器
    s.AddTool(tool, helloHandler)

    // 啓動標準輸入輸出服務器
    if err := server.ServeStdio(s); err != nil {
       fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服務器錯誤
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // 從請求參數中獲取名字參數，並斷言為字符串類型
    name, ok := request.Params.Arguments[&quot;name&quot;].(string)
    if !ok {
       // 如果斷言失敗，返回錯誤
       return nil, errors.New(&quot;name must be a string&quot;)
    }

    // 返回包含問候語的結果
    return mcp.NewToolResultText(fmt.Sprintf(&quot;Hello, %s!&quot;, name)), nil
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 搭建一個聯調環境&lt;/h2&gt; 
&lt;div&gt;
  就以上面的代碼為例，將上面的代碼編譯為二進制命令： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;$ go build -v -o server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;再啓動 mcp inspetor：&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;$ npx -y @modelcontextprotocol/inspector ./server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;img height=&quot;701&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7c0fba487d16433005ebd394b937e30063b.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  這樣一個簡單的 MCP Client 和 MCP Server 就搭建好了，後續也為我們開發測試構建好了環境。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_10&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、源碼解讀&lt;/h1&gt; 
&lt;div&gt;
  在上面的代碼中 main 函數中的第一個代碼就是 server.NewMCPServer，那我們就從 MCPServer 這個結構體入手。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_11&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 MCPServer 結構體&lt;/h2&gt; 
&lt;div&gt;
  代碼地址：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/server.go#L135 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type MCPServer struct {
    mu                   sync.RWMutex                       // 用於保護共享資源，確保併發訪問時的數據一致性
    name                 string                             // 服務器的名稱，用於標識服務器
    version              string                             // 服務器的版本，用於跟蹤和管理服務器的不同版本
    instructions         string                             // 服務器的指令，通常在初始化響應中返回給客户端，提供使用指南或幫助信息
    resources            map[string]resourceEntry           // 存儲服務器支持的資源及其處理函數
    resourceTemplates    map[string]resourceTemplateEntry   // 存儲資源模板及其處理函數，支持 URI 模板匹配多類似資源
    prompts              map[string]mcp.Prompt              // 存儲服務器支持的提示，用於與用户交互
    promptHandlers       map[string]PromptHandlerFunc       // 存儲處理提示請求的函數，每個提示對應一個處理函數
    tools                map[string]ServerTool              // 存儲服務器支持的工具及其處理函數
    notificationHandlers map[string]NotificationHandlerFunc // 存儲處理傳入通知的函數，接收客户端通知並處理
    capabilities         serverCapabilities                 // 定義服務器支持的功能特性，包括資源、提示、工具和日誌記錄等
    sessions             sync.Map                           // 存儲當前活躍的客户端會話，用於跟蹤用户交互
    initialized          atomic.Bool                        // 使用原子操作標記服務器是否已初始化，確保線程安全
    hooks                *Hooks                             // 存儲服務器鈎子，允許在請求處理前後或返回錯誤前執行自定義邏輯
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCPServer 是 Model Control Protocol (MCP) 服務器的實現，用於處理包括資源、提示和工具在內的各種類型的請求。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; height:30px; width:1111px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_12&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#333333&quot;&gt;4.2 MCPServer 初始化&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt;
  看看如何創建一個 MCPServer 對象。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewMCPServer(
    name, version string,
    opts ...ServerOption,
) *MCPServer {
    s := &amp;amp;MCPServer{
       resources:            make(map[string]resourceEntry),
       resourceTemplates:    make(map[string]resourceTemplateEntry),
       prompts:              make(map[string]mcp.Prompt),
       promptHandlers:       make(map[string]PromptHandlerFunc),
       tools:                make(map[string]ServerTool),
       name:                 name,
       version:              version,
       notificationHandlers: make(map[string]NotificationHandlerFunc),
       capabilities: serverCapabilities{
          tools:     nil,
          resources: nil,
          prompts:   nil,
          logging:   false,
       },
    }

    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;在 NewMCPServer() 方法中，我們需要關注的 opts ...ServerOption，進一步看看 ServerOption 有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;選項&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置資源相關的服務器功能，如訂閲和資源列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities(subscribe, listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;添加鈎子函數，用於在請求處理前後執行特定邏輯&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks(hooks *Hooks)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置提示相關的服務器功能，如提示列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置工具相關的服務器功能，如工具列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;啓用服務器日誌記錄功能&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging()&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置服務器指令，用於在初始化響應中返回給客户端&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions(instructions string)&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  它接受一個 Hooks 類型的指針作為參數。允許在創建 MCPServer 實例時，為服務器添加自定義的鈎子函數，這些鈎子函數可以在請求處理前後或返回錯誤給客户端之前執行。 
&lt;/div&gt; 
&lt;div&gt;
  hooks 機制對開發和流程是非常有效的。框架中給的 hooks 能力有： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;字段名&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;類型&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeAny&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]BeforeAnyHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求被解析後但方法調用前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnSuccess&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnSuccessHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求成功生成結果但結果尚未發送給客户端之前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnError&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnErrorHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求解析或方法執行過程中發生錯誤時執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理初始化請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理初始化請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforePing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforePingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理 Ping 請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterPing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterPingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理 Ping 請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源模板請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源模板請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理讀取資源請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理讀取資源請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出提示請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出提示請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理獲取提示請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理獲取提示請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出工具請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出工具請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理調用工具請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理調用工具請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  現在模擬創建一個完整的 MCPServer： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;hooks := &amp;amp;server.Hooks{}

hooks.AddBeforeAny(func(id any, method mcp.MCPMethod, message any) {
    fmt.Printf(&quot;beforeAny: %s, %v, %v\n&quot;, method, id, message)
})
hooks.AddOnSuccess(func(id any, method mcp.MCPMethod, message any, result any) {
    fmt.Printf(&quot;onSuccess: %s, %v, %v, %v\n&quot;, method, id, message, result)
})
hooks.AddOnError(func(id any, method mcp.MCPMethod, message any, err error) {
    fmt.Printf(&quot;onError: %s, %v, %v, %v\n&quot;, method, id, message, err)
})
hooks.AddBeforeInitialize(func(id any, message *mcp.InitializeRequest) {
    fmt.Printf(&quot;beforeInitialize: %v, %v\n&quot;, id, message)
})
hooks.AddAfterInitialize(func(id any, message *mcp.InitializeRequest, result *mcp.InitializeResult) {
    fmt.Printf(&quot;afterInitialize: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddAfterCallTool(func(id any, message *mcp.CallToolRequest, result *mcp.CallToolResult) {
    fmt.Printf(&quot;afterCallTool: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddBeforeCallTool(func(id any, message *mcp.CallToolRequest) {
    fmt.Printf(&quot;beforeCallTool: %v, %v\n&quot;, id, message)
})
// 創建 MCP 服務器
s := server.NewMCPServer(
    &quot;Demo 🚀&quot;, // 服務器名稱
    &quot;1.0.0&quot;,  // 服務器版本
    server.WithLogging(),
    server.WithToolCapabilities(true),
    server.WithResourceCapabilities(true, true),
    server.WithPromptCapabilities(true),
    server.WithInstructions(&quot;initialized&quot;),
    server.WithHooks(hooks),
)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 Tools 模塊&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_14&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.1 創建 Tool&lt;/h3&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架中創建 Tool 有兩個方式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewTool(name string, opts ...ToolOption) Tool 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewToolWithRawSchema(name, description string, schema json.RawMessage) Tool 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  下面通過一段代碼進行對比： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;方式一：mcp.NewTool()
tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名稱
    mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
    mcp.WithString(&quot;name&quot;, // 參數名稱
       mcp.Required(), // 參數是必需的
       mcp.Description(&quot;Name of the person to greet&quot;), // 參數描述
    ),
)

方式二：mcp.NewToolWithRawSchema()
rawSchema := json.RawMessage(`{
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
       &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Name of the person to greet&quot;}
    },
    &quot;required&quot;: [&quot;name&quot;]
}`)

// Create a tool with raw schema
toolRS := mcp.NewToolWithRawSchema(&quot;hello_world_1&quot;, &quot;Say hello to someone&quot;, rawSchema)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中 rawSchema 的結構需要符合 ToolInputSchema 結構體：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ToolInputSchema struct {
    Type       string                 `json:&quot;type&quot;`
    Properties map[string]interface{} `json:&quot;properties,omitempty&quot;`
    Required   []string               `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;需要注意的是 Properties 來源於 jsonSchema，所以具備的需要校驗屬性，比如 default、maximum、minimum、maxLength、minLength、enum 等等。其中 key 為請求傳入的參數字段，interface{}為對 key 的各種屬性校驗。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;更建議使用方式一：mcp.NewTool() 更加符合編碼方式，也更好控制器生成的&lt;/strong&gt; 
 &lt;strong&gt;jsonSchema&lt;/strong&gt; 
 &lt;strong&gt;。&lt;/strong&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_15&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.2 存放 Tool&lt;/h3&gt; 
&lt;div&gt;
  創建好 Tool 值之後，調用 server 的方法 AddTool() 將 Tool 添加進入，相當於 web 框架中的添加路由與相關 handle 的關係。相關代碼如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// AddTool registers a new tool and its handler
func (s *MCPServer) AddTool(tool mcp.Tool, handler ToolHandlerFunc) {
    s.AddTools(ServerTool{Tool: tool, Handler: handler})
}

// AddTools registers multiple tools at once
func (s *MCPServer) AddTools(tools ...ServerTool) {
    // 檢查工具
    if s.capabilities.tools == nil {
       s.capabilities.tools = &amp;amp;toolCapabilities{}
    }

    // 加鎖
    s.mu.Lock()
    // 遍歷工具
    for _, entry := range tools {
       s.tools[entry.Tool.Name] = entry
    }
    // 獲取初始化狀態
    initialized := s.initialized.Load()
    s.mu.Unlock()

    // 發送通知
    if initialized {
       s.sendNotificationToAllClients(&quot;notifications/tools/list_changed&quot;, nil)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以看出 Tool 是放入到 MCPServer 的 tools 字段中，使用 name 作為 key，ServerTool 作為 value，其中 ServerTool 結構如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ServerTool struct {
    Tool    mcp.Tool
    Handler ToolHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架還提供了：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    DeleteTools(names... string) 作為刪除 Tool 關聯的方法。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SetTools(tools ...ServerTool) 可以設置當前所有的 Tool 列表。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.4 Resource 模塊&lt;/h2&gt; 
&lt;div&gt;
  老規矩先來一個 demo，再看器源碼實現： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Static resource example - exposing a README file
resource := mcp.NewResource(
    &quot;docs://readme&quot;,
    &quot;Project README&quot;,
    mcp.WithResourceDescription(&quot;The project&#39;s README file&quot;),
    mcp.WithMIMEType(&quot;text/markdown&quot;),
)

// Add resource with its handler
s.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    content, err := os.ReadFile(&quot;main.go&quot;)
    if err != nil {
       return nil, err
    }

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      &quot;docs://readme&quot;,
          MIMEType: &quot;text/markdown&quot;,
          Text:     string(content),
       },
    }, nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在 MCP 中 Resource 是指允許 Server 公開可供客户端讀取並用作交互上下文的數據和內容。有很多類型的 Resource： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    File contents 文件內容 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Database records 數據庫記錄 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    API responses API 響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Live system data 實時系統數據 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    images 圖像 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Log files 日誌文件 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    等等... ... 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  框架中 Resource 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
type Resource struct {
    Annotated // 包含可選註解，用於告知客户端如何使用或顯示對象

    // 資源的 URI
    URI string `json:&quot;uri&quot;` // 資源的唯一標識符，用於定位和訪問資源

    // 資源的可讀名稱
    //
    // 客户端可以使用此名稱來填充 UI 元素
    Name string `json:&quot;name&quot;` // 資源的顯示名稱，便於用户理解和界面展示

    // 對此資源所代表內容的描述
    //
    // 客户端可以使用此描述來幫助大型語言模型（LLM）理解可用資源
    // 這可以看作是對模型的「提示」
    Description string `json:&quot;description,omitempty&quot;` // 資源的詳細描述，為模型提供上下文信息

    // 如果已知，此資源的 MIME 類型
    MIMEType string `json:&quot;mimeType,omitempty&quot;` // 資源的媒體類型，如 text/plain、image/jpeg 等，用於指示資源的內容格式
}

type Annotated struct {
    Annotations *struct {
       // 描述此對象或數據的預期客户是誰
       //
       // 它可以包含多個條目，以指示對多個受眾有用的內容（例如，`[&quot;user&quot;, &quot;assistant&quot;]`）
       Audience []Role `json:&quot;audience,omitempty&quot;` // 受眾羣體，指示數據對哪些角色或用户羣體有用

       // 描述此數據對服務器操作的重要性
       //
       // 值為 1 表示「最重要」，並指示數據實際上是必需的，而 0 表示「最不重要」，並指示數據完全是可選的
       Priority float64 `json:&quot;priority,omitempty&quot;` // 優先級，表示數據對服務器操作的重要程度，範圍從 0（最不重要）到 1（最重要）
    } `json:&quot;annotations,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    URI 用於定位一個具體資源的標識，場景的有 http://、file://、postgres://等等還可以去 https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 看看。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    MIMEType 表示文件的類型，常見的有 text/html、image/png，這裏也可以查看到更多：https://www.iana.org/assignments/media-types/media-types.xhtml。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *MCPServer) AddResource(
    resource mcp.Resource,
    handler ResourceHandlerFunc,
) {
    // 檢查資源
    if s.capabilities.resources == nil {
       s.capabilities.resources = &amp;amp;resourceCapabilities{}
    }

    // 加鎖
    s.mu.Lock()
    // 解鎖（defer）
    defer s.mu.Unlock()

    // 存儲資源
    s.resources[resource.URI] = resourceEntry{
       resource: resource,
       handler:  handler,
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;resource 是放入到 MCPServer 的 resources 字段中，使用 URI 作為 key，resourceEntry 作為 value，其中 resourceEntry 結構如下：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type resourceEntry struct {
    resource mcp.Resource
    handler  ResourceHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架還提供了添加 Resource templates 的功能，主要是針對動態資源，服務器可以公開 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc6570&quot; target=&quot;_blank&quot;&gt;URI 模板 &lt;/a&gt;，客户端可以使用它來構建有效的資源 URI。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Dynamic resource example - user profiles by ID
template := mcp.NewResourceTemplate(
    &quot;users://{id}/profile&quot;,
    &quot;User Profile&quot;,
    mcp.WithTemplateDescription(&quot;Returns user profile information&quot;),
    mcp.WithTemplateMIMEType(&quot;application/json&quot;),
)

// Add template with its handler
s.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract ID from the URI using regex matching
    // The server automatically matches URIs to templates
    userID := extractIDFromURI(request.Params.URI)

    profile := fmt.Sprintf(&quot;Hello %s&quot;, userID) // Your DB/API call here

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      request.Params.URI,
          MIMEType: &quot;application/json&quot;,
          Text:     profile,
       },
    }, nil
})

// extractIDFromURI 從給定的 URI 中提取用户 ID。
// 假設 URI 的格式為 &quot;users://{id}/profile&quot;。
func extractIDFromURI(uri string) string {
    // 定義正則表達式來匹配 URI 中的 ID
    re := regexp.MustCompile(`users://([^/]+)/profile`)

    // 使用正則表達式查找匹配項
    matches := re.FindStringSubmatch(uri)

    // 如果找到了匹配項，並且匹配項的數量正確，則返回 ID
    if len(matches) == 2 {
       return matches[1]
    }

    // 如果沒有找到匹配項，或者匹配項的數量不正確，則返回空字符串
    return &quot;&quot;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.5 Prompts 添加&lt;/h2&gt; 
&lt;div&gt;
  Prompts 創建可重複使用的提示模板和工作流程，提示使服務器能夠定義可重複使用的提示模板和工作流程。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Simple greeting prompt
s.AddPrompt(mcp.NewPrompt(&quot;greeting&quot;,
    mcp.WithPromptDescription(&quot;A friendly greeting prompt&quot;),
    mcp.WithArgument(&quot;name&quot;,
       mcp.ArgumentDescription(&quot;Name of the person to greet&quot;),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    name := request.Params.Arguments[&quot;name&quot;]
    if name == &quot;&quot; {
       name = &quot;friend&quot;
    }

    return mcp.NewGetPromptResult(
       &quot;A friendly greeting&quot;,
       []mcp.PromptMessage{
          mcp.NewPromptMessage(
             mcp.RoleAssistant,
             mcp.NewTextContent(fmt.Sprintf(&quot;Hello, %s! How can I help you today?&quot;, name)),
          ),
       },
    ), nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Prompt 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Prompt 表示服務器提供的提示或提示模板。
// 如果 Arguments 非空且包含元素，則表示該提示是一個模板，
// 在調用 prompts/get 時需要提供參數值。
// 如果 Arguments 為空或為 nil，則這是一個不需要參數的靜態提示。
type Prompt struct {
    // 提示或提示模板的名稱。
    Name string `json:&quot;name&quot;`
    // 提示提供內容的可選描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 用於模板化提示的參數列表。
    // 參數的存在表明這是一個模板提示。
    Arguments []PromptArgument `json:&quot;arguments,omitempty&quot;`
}

// PromptArgument 描述提示模板可以接受的參數。
// 當提示包含參數時，客户端在發出 prompts/get 請求時
// 必須為所有必需參數提供值。
type PromptArgument struct {
    // 參數的名稱。
    Name string `json:&quot;name&quot;`
    // 參數的可讀描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 此參數是否必須提供。
    // 如果為 true，則客户端在調用 prompts/get 時必須包含此參數。
    Required bool `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以通過 mcp.NewPrompt 方法來生成 Prompt 對象：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewPrompt(name string, opts ...PromptOption) Prompt {
    prompt := Prompt{
       Name: name,
    }

    for _, opt := range opts {
       opt(&amp;amp;prompt)
    }

    return prompt
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;又見到了 opts ...PromptOption，看看有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithPromptDescription 用於設置 description； 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithArgument 用於設置 arguments； 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.6 選擇傳輸方式&lt;/h2&gt; 
&lt;div&gt;
  現在代碼已經來到了： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 啓動標準輸入輸出服務器
if err := server.ServeStdio(s); err != nil {
    fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服務器錯誤
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCP 當前主要提供兩類 Stdio transport 和 HTTP with SSE transport 。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.1 Stdio&lt;/h3&gt; 
&lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;創建 StdioServer&lt;/h4&gt; 
&lt;div&gt;
  StdioServer 的結構體： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type StdioServer struct {
    server      *MCPServer
    errLogger   *log.Logger
    contextFunc StdioContextFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中在，重要的字段有 server 和 contextFunc，給 MCPServer 進來就是為了具備 MCP 的能力，只是使用 stdio 的傳輸方式。contextFunc 是為了讓外部自定義的 context 可以進入到 StdioServer，可以用於結束服務和控制超時.&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
// 為 MCP Server 啓用 stdio
func ServeStdio(server *MCPServer, opts ...StdioOption) error {
    // 創建 Stdio 服務器
    s := NewStdioServer(server)
    // 設置錯誤日誌
    s.SetErrorLogger(log.New(os.Stderr, &quot;&quot;, log.LstdFlags))

    // 應用選項
    for _, opt := range opts {
       opt(s)
    }

    // 創建上下文
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // 設置信號通道
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

    // 監聽信號
    go func() {
       &amp;lt;-sigChan
       cancel()
    }()

    // 開始監聽
    return s.Listen(ctx, os.Stdin, os.Stdout)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中最關鍵的是 Listen 方法，它是 StdioServer 類型的一個關鍵方法，用於監聽標準輸入輸出的 JSON-RPC 消息。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Listen 啓動監聽，從提供的輸入讀取 JSON-RPC 消息，並將響應寫入提供的輸出。
// 它將持續運行，直到上下文被取消或發生錯誤。
// 如果在讀取輸入或寫入輸出時遇到問題，將返回錯誤。
func (s *StdioServer) Listen(
    ctx context.Context, // 監聽過程的上下文，用於控制生命週期和傳遞請求範圍的信息
    stdin io.Reader, // 標準輸入流，用於讀取客户端發送的 JSON-RPC 消息
    stdout io.Writer, // 標準輸出流，用於將響應寫回客户端
) error {
    // 由於標準輸入輸出只有一個客户端，因此設置一個靜態客户端上下文，SessionId 為 stdio
    if err := s.server.RegisterSession(&amp;amp;stdioSessionInstance); err != nil {
       // 如果會話註冊失敗，返回錯誤
       return fmt.Errorf(&quot;register session: %w&quot;, err)
    }
    // 確保在函數結束時註銷會話
    defer s.server.UnregisterSession(stdioSessionInstance.SessionID())
    // 更新上下文，將會話信息加入
    ctx = s.server.WithContext(ctx, &amp;amp;stdioSessionInstance)

    // 如果存在自定義上下文函數，則應用該函數修改上下文
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx)
    }

    // 創建一個帶緩衝的讀取器，用於從標準輸入流高效讀取數據
    reader := bufio.NewReader(stdin)

    // 啓動一個協程專門處理通知
    go func() {
       for {
          select {
          case notification := &amp;lt;-stdioSessionInstance.notifications:
             // 收到通知時，調用 writeResponse 方法將通知寫入標準輸出
             err := s.writeResponse(notification, stdout)
             if err != nil {
                // 如果寫入通知時出錯，記錄錯誤日誌
                s.errLogger.Printf(&quot;Error writing notification: %v&quot;, err)
             }
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，退出協程
             return
          }
       }
    }()

    // 主循環，用於處理輸入消息
    for {
       select {
       case &amp;lt;-ctx.Done():
          // 如果上下文完成，返回上下文錯誤
          return ctx.Err()
       default:
          // 使用協程使讀取操作可取消
          readChan := make(chan string, 1) // 用於接收讀取到的行
          errChan := make(chan error, 1)   // 用於接收讀取錯誤

          go func() {
             line, err := reader.ReadString(&#39;\n&#39;) // 讀取一行輸入
             if err != nil {
                errChan &amp;lt;- err // 發送讀取錯誤
                return
             }
             readChan &amp;lt;- line // 發送讀取到的行
          }()

          select {
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，返回上下文錯誤
             return ctx.Err()
          case err := &amp;lt;-errChan:
             // 處理讀取錯誤
             if err == io.EOF {
                // 如果是文件結束符，表示輸入結束，返回 nil
                return nil
             }
             // 其他錯誤則記錄日誌並返回
             s.errLogger.Printf(&quot;Error reading input: %v&quot;, err)
             return err
          case line := &amp;lt;-readChan:
             // 處理讀取到的行
             if err := s.processMessage(ctx, line, stdout); err != nil {
                // 如果處理消息時出錯
                if err == io.EOF {
                   // 如果是文件結束符，返回 nil
                   return nil
                }
                // 其他錯誤則記錄日誌並返回
                s.errLogger.Printf(&quot;Error handling message: %v&quot;, err)
                return err
             }
          }
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.2 SSE&lt;/h3&gt; 
&lt;div&gt;
  SSE 模式憑藉其分佈式能力、實時性和架構靈活性，成為 MCP 在 
 &lt;strong&gt;企業級應用、雲端協作、動態數據流處理&lt;/strong&gt;等場景的首選。所以對 SSE 的支持程度和易用程度，對於一個 MCP 框架而言是非常重要的。 
&lt;/div&gt; 
&lt;div&gt;
  mark3labs/mcp-go 如何支持 SSE 呢？看看如下代碼： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mcpServer := NewMCPServer()
sseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(&quot;http://localhost:8080&quot;))
log.Printf(&quot;SSE server listening on :8080&quot;)
if err := sseServer.Start(&quot;:8080&quot;); err != nil {
    log.Fatalf(&quot;Server error: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;現在已經知道如何在 mark3labs/mcp-go 中啓用 SSE 了，現在來分析一下，它是如何實現的。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;創建 SSEServer&lt;/h4&gt; 
&lt;div&gt;
  SSEServer 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// SSEServer implements a Server-Sent Events (SSE) based MCP server.
// It provides real-time communication capabilities over HTTP using the SSE protocol.
type SSEServer struct {
    server          *MCPServer       // MCPServer 實例，用於處理實際的消息傳遞和通信邏輯
    baseURL         string           // SSE 服務器的基礎 URL，用於構建完整的端點路徑
    basePath        string           // SSE 服務器的基礎路徑，通常用於區分不同的服務或版本
    messageEndpoint string           // 消息端點的路徑，客户端通過此端點發送 JSON-RPC 消息
    sseEndpoint     string           // SSE 端點的路徑，客户端通過此端點建立 SSE 連接
    sessions        sync.Map         // 存儲活動 SSE 會話的同步映射，用於跟蹤和管理客户端連接
    srv             *http.Server     // 內部的 HTTP 服務器實例，用於處理 HTTP 請求和響應
    contextFunc     SSEContextFunc   // 可選的上下文函數，用於根據請求內容自定義上下文
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;與之前的 StdioServer 相比，SSEServer 多了用於 http 中使用的 URI、path，還有 srv 這是一個 httpServer 的類型，用於支持 HTTP 請求和響應。繼續查看如何構建 SSEServer：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// NewSSEServer creates a new SSE server instance with the given MCP server and options.
func NewSSEServer(server *MCPServer, opts ...SSEOption) *SSEServer {
    s := &amp;amp;SSEServer{
       server:          server,
       sseEndpoint:     &quot;/sse&quot;,
       messageEndpoint: &quot;/message&quot;,
    }

    // Apply all options
    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;還是採用的才是經典 Option 模式，繼續看看 SSEOption 有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;名稱&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 服務器的基礎 URL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL(&quot;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fexample.com&quot; target=&quot;_blank&quot;&gt;https://example.com&lt;/a&gt;&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 服務器的基礎路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath(&quot;/v1&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置消息端點的路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint(&quot;/custom-message&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 端點的路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint(&quot;/custom-sse&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 HTTP 服務器實例（通常用於測試或自定義服務器配置）&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer(customHttpServer)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置一個函數，用於根據請求內容自定義上下文&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc(func(ctx context.Context, r *http.Request) context.Context { ... })&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  WithHTTPServer 適用於需要自定義服務器配置的場景，為後續替換更好性能的 http 服務實例打下基礎，也體現了 mark3labs/mcp-go 擴展性。 
&lt;/div&gt; 
&lt;div&gt;
  剩下的 Start() 就是常見的啓動 http 服務實例的功能了。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) Start(addr string) error {
    s.srv = &amp;amp;http.Server{
       Addr:    addr,
       Handler: s,
    }

    return s.srv.ListenAndServe()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;還可以調用 Shutdown() 實現對服務器的關閉。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_23&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.3 集成到 gin 框架&lt;/h3&gt; 
&lt;div&gt;
  在實際開發中，很多公司內部的業務有自己的框架，集成了許許多多的獨特功能。總不能為了使用 MCP 重寫一套 Web 框架，此時就需要使用到 mark3labs/mcp-go 集成到 Web 框架的能力了。下面以 gin 框架為例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 創建一個新的 Gin 引擎
r := gin.Default()

// 創建一個新的 MCPServer 實例（假設這是 SSEServer 所需的）
mcpServer := server.NewMCPServer(&quot;gin-mcp-server&quot;, &quot;1.0.0&quot;) // 根據你的實際代碼調整
// mcpServer 新加 Tool、Resource、Prompt
// ... ...
// 創建一個新的 SSEServer 實例，並傳入 MCPServer
sseServer := server.NewSSEServer(mcpServer)

// 將 SSEServer 的 SSE 端點和處理函數集成到 Gin 路由中
r.GET(sseServer.CompleteSsePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 將 SSEServer 的消息端點和處理函數集成到 Gin 路由中
r.POST(sseServer.CompleteMessagePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 啓動 Gin 服務器
if err := r.Run(&quot;localhost:8081&quot;); err != nil {
    log.Fatalf(&quot;Gin server startup failed: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;上述的代碼會生成兩個路由：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; border:none; table-layout:fixed; width:500px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       路由 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       方法 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       作用 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       實例 
     &lt;/div&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /sse 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       GET 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         獲取 SessionID 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         接受 Server 響應 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;請求：
curl &#39;http://localhost:3000/sse?transportType=sse&amp;amp;url=http%3A%2F%2Flocalhost%3A8081%2Fsse&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; 
  
  響應：
  event: endpoint
data: /message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /message 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       POST 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         使用 SessionID 保持會話 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         發起功能請求 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;請求：
curl &#39;http://localhost:3000/message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; \
  -H &#39;content-type: application/json&#39; 
  --data-raw &#39;{&quot;method&quot;:&quot;initialize&quot;,&quot;params&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;sampling&quot;:{},&quot;roots&quot;:{&quot;listChanged&quot;:true}},&quot;clientInfo&quot;:{&quot;name&quot;:&quot;mcp-inspector&quot;,&quot;version&quot;:&quot;0.7.0&quot;}},&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0}&#39;
 
/message 的響應：
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}

/sse 收到的響應：
event: message
data: {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_24&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.7 處理請求&lt;/h2&gt; 
&lt;div&gt;
  之前的內容，解析瞭如何構建 MCP Server 的實踐和背後的實現。下面我們還需要了解 mark3labs/mcp-go 如何接受請求並進行響應的。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_25&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.1 路由入口&lt;/h3&gt; 
&lt;div&gt;
  從 SSEServer 結構體中已經知道使用的 http.Server，所以其接受請求的入口為 ServeHTTP 方法，實現了 http.Handler 接口，用於處理 HTTP 請求。根據請求的路徑，它會將請求分發到不同的處理方法（handleSSE 或 handleMessage），或者返回 404 未找到。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 獲取請求的路徑
    path := r.URL.Path

    // 使用精確路徑匹配，而不是模糊包含
    ssePath := s.CompleteSsePath() // 獲取完整的 SSE 路徑
    if ssePath != &quot;&quot; &amp;amp;&amp;amp; path == ssePath {
       // 如果請求路徑與 SSE 路徑匹配，則處理 SSE 請求
       s.handleSSE(w, r)
       return // 處理完成後直接返回，不再繼續後續邏輯
    }

    // 獲取消息處理的完整路徑
    messagePath := s.CompleteMessagePath()
    if messagePath != &quot;&quot; &amp;amp;&amp;amp; path == messagePath {
       // 如果請求路徑與消息處理路徑匹配，則處理消息請求
       s.handleMessage(w, r)
       return // 處理完成後直接返回，不再繼續後續邏輯
    }

    // 如果請求路徑不匹配任何已知路徑，則返回 404 未找到
    http.NotFound(w, r)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SSE 路徑為：s.baseURL + s.basePath + s.sseEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Message 路徑為：s.baseURL + s.basePath + s.messageEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  這些信息都是可以在 NewSSEServer() 方法中設置。 
&lt;/div&gt; 
&lt;div&gt;
  需要詳細查看的是 s.handleSSE(w, r) 和 s.handleMessage(w, r) 方法，他們分別處理/see 和/message 的請求。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_26&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.2 handleSSE&lt;/h3&gt; 
&lt;div&gt;
  handleSSE 實現了一個處理服務器發送事件（SSE）的 HTTP 處理器。SSE 是一種允許服務器向客户端發送自動更新的技術。主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;請求方法檢查&lt;/strong&gt;：只允許 GET 請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;設置響應頭&lt;/strong&gt;：設置適當的 SSE 響應頭。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;創建會話&lt;/strong&gt;：為每個客户端創建一個新的 SSE 會話。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;註冊和註銷會話&lt;/strong&gt;：在服務器中註冊會話，並在處理完成後註銷。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;通知處理器&lt;/strong&gt;：啓動一個 goroutine 處理來自通知通道的事件，並將其發送到客户端。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;主事件循環&lt;/strong&gt;：處理來自事件隊列的事件，並將其發送到客户端。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 它設置適當的頭信息併為客户端創建一個新的會話。
func (s *SSEServer) handleSSE(w http.ResponseWriter, r *http.Request) {
    // 1. 檢查請求方法是否為 GET，如果不是，返回 405 Method Not Allowed 錯誤
    if r.Method != http.MethodGet {
       http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
       return
    }

    // 2. 設置 SSE 相關的響應頭
    w.Header().Set(&quot;Content-Type&quot;, &quot;text/event-stream&quot;) // 設置內容類型為 text/event-stream
    w.Header().Set(&quot;Cache-Control&quot;, &quot;no-cache&quot;)         // 禁用緩存
    w.Header().Set(&quot;Connection&quot;, &quot;keep-alive&quot;)          // 保持連接活躍
    w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)  // 允許所有域跨域請求

    // 檢查 ResponseWriter 是否支持 Flush，如果不支持，返回 500 Internal Server Error 錯誤
    flusher, ok := w.(http.Flusher)
    if !ok {
       http.Error(w, &quot;Streaming unsupported&quot;, http.StatusInternalServerError)
       return
    }

    // 3. 創建一個新的會話 ID 和會話對象
    sessionID := uuid.New().String() // 生成唯一的會話 ID
    session := &amp;amp;sseSession{
       writer:              w,                          // 響應寫入器
       flusher:             flusher,                    // 刷新器
       done:                make(chan struct{}),        // 用於通知會話結束的通道
       eventQueue:          make(chan string, 100),     // 事件隊列，緩衝區大小為 100
       sessionID:           sessionID,                  // 會話 ID
       notificationChannel: make(chan mcp.JSONRPCNotification, 100), // 通知通道，緩衝區大小為 100
    }

    // 4. 將會話存儲到會話存儲中，並在處理完成後刪除
    s.sessions.Store(sessionID, session)
    defer s.sessions.Delete(sessionID)

    // 在服務器中註冊會話，如果註冊失敗，返回 500 Internal Server Error 錯誤
    if err := s.server.RegisterSession(session); err != nil {
       http.Error(w, fmt.Sprintf(&quot;Session registration failed: %v&quot;, err), http.StatusInternalServerError)
       return
    }
    // 在處理完成後註銷會話
    defer s.server.UnregisterSession(sessionID)

    // 5. 啓動一個 goroutine 處理通知通道中的事件
    go func() {
       for {
          select {
          case notification := &amp;lt;-session.notificationChannel: // 從通知通道接收通知
             eventData, err := json.Marshal(notification) // 將通知序列化為 JSON
             if err == nil {
                select {
                case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData): // 將事件發送到事件隊列
                   // 事件成功入隊
                case &amp;lt;-session.done: // 如果會話結束，退出 goroutine
                   return
                }
             }
          case &amp;lt;-session.done: // 如果會話結束，退出 goroutine
             return
          case &amp;lt;-r.Context().Done(): // 如果請求上下文被取消，退出 goroutine
             return
          }
       }
    }()

    // 生成消息端點 URL 併發送初始的 endpoint 事件
    messageEndpoint := fmt.Sprintf(&quot;%s?sessionId=%s&quot;, s.CompleteMessageEndpoint(), sessionID)
    fmt.Fprintf(w, &quot;event: endpoint\ndata: %s\r\n\r\n&quot;, messageEndpoint) // 發送 endpoint 事件
    flusher.Flush() // 刷新響應，確保事件立即發送到客户端

    // 6. 主事件循環，運行在 HTTP 處理器 goroutine 中
    for {
       select {
       case event := &amp;lt;-session.eventQueue: // 從事件隊列接收事件
          fmt.Fprint(w, event) // 將事件寫入響應
          flusher.Flush()      // 刷新響應，確保事件立即發送到客户端
       case &amp;lt;-r.Context().Done(): // 如果請求上下文被取消，關閉會話並退出
          close(session.done)
          return
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;第三階段又看到 Session 了，與之前的 stdioSession 相比，sseSession 明顯複雜多了，它們都實現接口 ClientSession：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ClientSession interface {
    // NotificationChannel provides a channel suitable for sending notifications to client.
    NotificationChannel() chan&amp;lt;- mcp.JSONRPCNotification
    // SessionID is a unique identifier used to track user session.
    SessionID() string
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;sseSession 是專門用於表示一個基於服務器發送事件（Server-Sent Events, SSE）協議的活躍連接。sseSession 負責管理客户端與服務器之間的單向實時數據推送，並保持會話。其結構體如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type sseSession struct {
    writer              http.ResponseWriter // HTTP 響應寫入器，用於向客户端發送數據
    flusher             http.Flusher       // HTTP 刷新器，用於刷新響應緩衝區，確保數據立即發送給客户端
    done                chan struct{}      // 用於通知會話結束的通道
    eventQueue          chan string        // 用於排隊事件的通道，存儲待發送給客户端的事件
    sessionID           string             // 會話的唯一標識符
    notificationChannel chan mcp.JSONRPCNotification // 用於接收 JSON-RPC 通知的通道
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_27&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;4.7.3 handleMessage&lt;/h3&gt; 
&lt;/div&gt; 
&lt;div&gt;
  handleMessage 方法是 SSEServer 類型的一個方法，用於處理傳入的 JSON-RPC 消息，並通過 SSE 連接和 HTTP 響應返回結果。其主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    請求驗證：檢查請求方法 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      檢查請求方法：方法首先檢查請求方法是否為 HTTP POST。如果不是，返回 &quot;Method not allowed&quot; 錯誤，並終止處理。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      驗證 sessionId 參數：從請求的 URL 查詢參數中獲取 sessionId。如果缺失，返回 &quot;Missing sessionId&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      加載會話：使用 sessionId 從會話存儲中加載會話。如果會話不存在，返回 &quot;Invalid session ID&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    設置上下文 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      調用 s.server.WithContext 方法，將請求上下文和會話信息合併，生成新的上下文。如果提供了 contextFunc，則進一步處理上下文。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    解析 JSON-RPC 消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      使用 json.NewDecoder 解析請求體中的原始 JSON 消息。如果解析失敗，返回 &quot;Parse error&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將解析後的消息傳遞給 s.server.HandleMessage 方法進行處理，並獲取響應結果。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    發送響應 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 返回了響應（非通知），則： 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 沒有返回響應（通知），則僅設置 HTTP 響應狀態碼為 202 Accepted，不發送響應體。 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將響應編碼為 JSON 格式。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將響應事件加入會話的事件隊列，供 SSE 連接發送。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      設置 HTTP 響應頭為 application/json，狀態碼為 202 Accepted，併發送響應體。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    事件隊列處理 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  嘗試將事件加入會話的事件隊列。如果隊列已滿或會話已關閉，則丟棄事件。 
&lt;/div&gt; 
&lt;div&gt;
  那麼 handleSSE 和 handleMessage 的關係是怎樣的呢？使用一張圖來説明： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;729&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7cab372d06266dac5b06a8959d2df0382ea.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// handleMessage 處理來自客户端的 JSON-RPC 消息，並通過 SSE 連接和 HTTP 響應返回結果
func (s *SSEServer) handleMessage(w http.ResponseWriter, r *http.Request) {
    // 1. 如果請求方法不是 POST，則返回 JSON-RPC 錯誤響應，表示方法不允許
    if r.Method != http.MethodPost {
       s.writeJSONRPCError(w, nil, mcp.INVALID_REQUEST, &quot;Method not allowed&quot;)
       return
    }

    // 從請求的 URL 查詢參數中獲取 sessionId
    sessionID := r.URL.Query().Get(&quot;sessionId&quot;)
    // 如果 sessionId 為空，則返回 JSON-RPC 錯誤響應，表示缺少 sessionId 參數
    if sessionID == &quot;&quot; {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Missing sessionId&quot;)
       return
    }

    // 從 session 存儲中加載與 sessionId 對應的 session
    sessionI, ok := s.sessions.Load(sessionID)
    // 如果 session 不存在，則返回 JSON-RPC 錯誤響應，表示無效的 session ID
    if !ok {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Invalid session ID&quot;)
       return
    }
    session := sessionI.(*sseSession)

    // 在處理消息之前設置客户端上下文
    ctx := s.server.WithContext(r.Context(), session)
    // 如果提供了自定義的上下文函數，則應用它
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx, r)
    }

    // 將請求體解析為原始 JSON 消息
    var rawMessage json.RawMessage
    if err := json.NewDecoder(r.Body).Decode(&amp;amp;rawMessage); err != nil {
       // 如果解析失敗，則返回 JSON-RPC 錯誤響應，表示解析錯誤
       s.writeJSONRPCError(w, nil, mcp.PARSE_ERROR, &quot;Parse error&quot;)
       return
    }

    // 通過 MCPServer 處理消息
    response := s.server.HandleMessage(ctx, rawMessage)

    // 如果存在響應（非通知），則發送響應
    if response != nil {
       // 將響應編碼為 JSON 格式
       eventData, _ := json.Marshal(response)

       // 將事件排隊以通過 SSE 發送
       select {
       case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData):
          // 事件成功排隊
       case &amp;lt;-session.done:
          // 會話已關閉，不嘗試排隊
       default:
          // 隊列已滿，可以記錄此情況
       }

       // 發送 HTTP 響應
       w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
       w.WriteHeader(http.StatusAccepted)
       json.NewEncoder(w).Encode(response)
    } else {
       // 對於通知，只發送 202 Accepted 狀態碼，無響應體
       w.WriteHeader(http.StatusAccepted)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  需要注意的是 HandleMessage 方法，這是通過 server/internal/gen/request_handler.go.tmpl 生成的，也根據 MCP 協議實現的模版，其流程如下： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    嘗試將原始消息解析為對應請求類型。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果解析失敗，記錄錯誤信息。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    執行請求前的鈎子函數。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    調用對應的處理函數處理請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果處理過程中發生錯誤，執行錯誤鈎子函數並返回錯誤響應。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    執行請求後的鈎子函數。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    返回成功響應。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  以 initialize 請求為例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 根據消息方法進行分情況處理
switch baseMessage.Method {
// 初始化請求處理
case mcp.MethodInitialize:
    var request mcp.InitializeRequest
    var result *mcp.InitializeResult
    // 嘗試將原始消息解析為初始化請求類型
    if unmarshalErr := json.Unmarshal(message, &amp;amp;request); unmarshalErr != nil {
       // 如果解析失敗，記錄錯誤信息
       err = &amp;amp;requestError{
          id:   baseMessage.ID,
          code: mcp.INVALID_REQUEST,
          err:  &amp;amp;UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
       }
    } else {
       // 執行初始化請求前的鈎子函數
       s.hooks.beforeInitialize(baseMessage.ID, &amp;amp;request)
       // 處理初始化請求
       result, err = s.handleInitialize(ctx, baseMessage.ID, request)
    }
    // 如果處理過程中發生錯誤
    if err != nil {
       // 執行錯誤鈎子函數
       s.hooks.onError(baseMessage.ID, baseMessage.Method, &amp;amp;request, err)
       // 返回錯誤響應
       return err.ToJSONRPCError()
    }
    // 執行初始化請求後的鈎子函數
    s.hooks.afterInitialize(baseMessage.ID, &amp;amp;request, result)
    // 返回成功響應
    return createResponse(baseMessage.ID, *result)

// 其他方法處理邏輯類似，省略...

// 如果方法不匹配任何已知方法，返回方法未找到錯誤響應
default:
    return createErrorResponse(
       baseMessage.ID,
       mcp.METHOD_NOT_FOUND,
       fmt.Sprintf(&quot;Method %s not found&quot;, baseMessage.Method),
    )
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;代碼比較多，可以自行查看：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/request_handler.go#L12&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_28&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、總結&lt;/h1&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架是一個簡單易用的 MCP 框架，基本上實現了 MCP 協議，提供對 MCP 核心規範的完整支持，包括資源（Resources）、工具（Tools）、提示（Prompts）等核心組件，確保與主流 LLM 客户端（如 Claude、Cline）的兼容性。尤其是 mark3labs/mcp-go 提供的 hooks 機制，可以讓開發者更好的使用類似 gin 空間一樣的中間件能力，比如實現統一鑑權等能力。除此之外，還可以與主流的 Web 框架，如 gin 框架進行集成，進一步擴展了 mark3labs/mcp-go 的適用性。 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/qiangmzsx/blog/18014540</link>
            <guid isPermaLink="false">https://my.oschina.net/qiangmzsx/blog/18014540</guid>
            <pubDate>Sun, 23 Mar 2025 02:15:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>阿里通義千問開源端到端多模態模型 Qwen2.5-Omni</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 27 日，通義千問&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqwenlm.github.io%2Fzh%2Fblog%2Fqwen2.5-omni%2F&quot; target=&quot;_blank&quot;&gt;宣佈推出&lt;/a&gt;&lt;/u&gt;新一代端到端多模態旗艦模型 Qwen2.5-Omni。該模型現已在 Hugging Face、ModelScope、DashScope 和 GitHub 上開源開放。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e620efb7beda14c716812fb6f4a8ed2f17f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Qwen2.5-Omni 是一種端到端多模態模型，旨在感知各種模態，包括文本，圖像，音頻和視頻，同時以流式方式生成文本和自然語音響應。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;關鍵特點&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Omni 和新穎的架構：我們提出 Thinker-Talker 架構，這是一種端到端多模態模型，旨在感知各種模式，包括文本，圖像，音頻和視頻，同時以流式方式生成文本和自然語音響應。 我們提出了一種新的位置嵌入，稱為 TMRoPE (時間對齊多模態 RoPE), 以將視頻輸入的時間戳與音頻同步。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;實時語音和視頻聊天：專為完全實時交互而設計的架構，支持分塊輸入和即時輸出。&lt;/li&gt; 
 &lt;li&gt;自然和強大的語音生成：超越許多現有的流媒體和非流媒體替代方案，在語音生成中表現出卓越的魯棒性和自然性。&lt;/li&gt; 
 &lt;li&gt;跨模式的強大性能：在與類似規模的單模式模型進行基準測試時，在所有模式中表現出卓越的性能。 Qwen2.5-Omni 在音頻功能方面優於類似尺寸的 Qwen2-Audio, 並實現與 Qwen2.5-VL-7B 相當的性能。&lt;/li&gt; 
 &lt;li&gt;優秀的端到端語音指令：Qwen2.5-Omni 在端到端語音指令中表現出性能，這與文本輸入的有效性相媲美，MMLU 和 GSM8K 等基準測試就證明瞭這一點。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;模型架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8eac4f9ca743454cd238cfa11a6319f1710.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ac3ad0960351e7733a1cfb5cabf05690d01.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型下載&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前只開源了 7B 尺寸的模型&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FQwen%2FQwen2.5-Omni-7B&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/Qwen/Qwen2.5-Omni-7B&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341243/qwen2-5-omni-7b</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341243/qwen2-5-omni-7b</guid>
            <pubDate>Sun, 23 Mar 2025 02:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI Agents SDK 已支持大模型上下文協議 MCP</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;OpenAI &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAIDevs%2Fstatus%2F1904957755829481737&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;其智能體——OpenAI Agents SDK 已支持大模型上下文協議 MCP，並表示稱&lt;strong&gt;正在為 OpenAI API 和 ChatGPT 桌面應用程序開發 MCP 支持&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1052&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/095628_d79a_2720166.png&quot; width=&quot;1278&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/100304_ckel_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;OpenAI Agents SDK 支持 MCP 對於開發複雜的智能體具有巨大幫助。例如，在開發一個需要同時進行文件處理、數據查詢和網絡信息收集的智能體時，開發者可以通過 MCP 服務器分別集成文件系統工具、數據庫查詢工具和網絡爬蟲工具，更高效地完成任務。&lt;/p&gt; 
&lt;p&gt;參考文檔&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.github.io%2Fopenai-agents-python%2Fmcp%2F&quot; target=&quot;_blank&quot;&gt;https://openai.github.io/openai-agents-python/mcp/&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenai%2Fopenai-agents-python&quot; target=&quot;_blank&quot;&gt;https://github.com/openai/openai-agents-python&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341240/openai-agents-sdk-mcp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341240/openai-agents-sdk-mcp</guid>
            <pubDate>Sun, 23 Mar 2025 02:04:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>張一鳴登頂中國首富</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 27 日，彭博億萬富豪指數及福布斯富豪榜均顯示，字節跳動創始人張一鳴登頂中國富豪榜榜首，成為中國首富。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;福布斯預估張一鳴身家為 655 億美元（約合 4760.67 億元人民幣），在全球富豪榜位列第 23 位，馬化騰與鍾睒睒分別以 535 億美元、531 億美元的身家分列富豪榜第 27 和 28 位。彭博億萬富豪指數預估張一鳴身家為 575 億美元，位居全球富豪榜第 24 位，馬化騰和鍾睒睒分列第 25 和 26 位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另外根據彭博億萬富豪指數，張一鳴目前是亞洲第三大富豪，僅次於印度的 Mukesh Ambani 和 Gautam Adani。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;309&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-63eb3fc9dc2e64506bf7afcc27af90e9d51.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341239</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341239</guid>
            <pubDate>Sun, 23 Mar 2025 02:00:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>商湯科技：2024 年生成式 AI 收入佔比達 63.7%</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商湯集團&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPBkhEy84piWtkBHwY8nDYA&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;截至 2024 年 12 月 31 日經審核全年業績。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年，商湯集團總體收入同比增長 10.8%，達到 37.7 億元人民幣；其中，生成式 AI 業務收入突破 24 億元，同比大幅增長 103.1%，這是生成式 AI 連續兩年保持三位數增速，佔總收入比例進一步提升至 63.7%，已成為集團最大業務。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年集團毛利為 16.2 億元人民幣，毛利率為 42.9%，虧損同比收窄 33.7%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商湯集團董事會執行主席兼首席執行官徐立博士表示：「大模型算法與基礎設施軟件系統的聯合優化已成為生成式 AI 飛速發展的核心驅動力。商湯秉承的‘大裝置-大模型-應用’三位一體、聯合優化的戰略與此趨勢契合，正在迎來高速發展階段。商湯以‘1+X’組織架構重組推動資源的戰略聚焦，以可持續增長與盈利能力為核心，增強商湯作為行業標杆的競爭力。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;3808&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-60709661fa23c67ebe39f9c529b30ba38ec.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341237</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341237</guid>
            <pubDate>Sun, 23 Mar 2025 01:56:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>英偉達正在洽談收購賈揚清創業公司 Lepton AI</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fnvidia-nears-deal-buy-gpu-reseller-several-hundred-million-dollars&quot; target=&quot;_blank&quot;&gt;根據 The Information 的報道&lt;/a&gt;&lt;/u&gt;，英偉達即將收購成立兩年的 AI 創業公司 Lepton AI。據稱這筆交易的金額達數億美元。&lt;/p&gt; 
&lt;p&gt;Lepton AI 創始人賈揚清是開源深度學習框架 Caffe 創始人、TensorFlow 作者之一、也是 PyTorch 1.0 的共同創始人。他在創立 Lepton AI 之前在阿里巴巴擔任技術副總裁。&lt;/p&gt; 
&lt;p&gt;2023 年 3 月，賈揚清離職創立了 Lepton AI，主做 AI 底層架構方向的事情，希望通過產品的方式來降低 AI 應用開發的門檻，幫助開發者更容易地完成創建、部署和擴展任務。&lt;/p&gt; 
&lt;p&gt;2023 年 5 月，Lepton AI 完成了首輪天使輪融資，由 Fusion Fund 基金和 CRV 風投兩家機構投資。創始團隊成員還包括 ONNX 的聯合創始人以及 etcd 的創始人。&lt;/p&gt; 
&lt;p&gt;成立至今，Lepton AI 主要發佈了兩款產品：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;FastGPU：2024 年 6 月上線的雲 GPU 解決方案，主打經濟高效和可靠。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Lepton Search：2023 年 12 月推出的對話式搜索引擎，基於 Lepton AI 平台實現，代碼量不到 500 行。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Lepton AI 的基本思路是提供大模型訓練、部署和應用時所需的基礎設施，諸如提供 Python SDK 和雲計算平台，支持 HuggingFace 模型集成和從 GitHub 倉庫創建 AI 模型，以降低了 AI 應用開發的門檻。&lt;/p&gt; 
&lt;p&gt;而 NVIDIA 目前也正致力於擴展其 AI 能力和基礎設施，為其客户更全面的解決方案。這是促成此次收購的核心戰略邏輯。&lt;/p&gt; 
&lt;p&gt;英偉達正感受到來自其最大客户——主要雲服務提供商，如亞馬遜和谷歌的壓力，這些客户試圖通過開發和低價租賃替代芯片來削弱英偉達的市場地位，因此英偉達考慮進行多元化發展，直接下場做 Lepton AI 做的事情。&lt;/p&gt; 
&lt;p&gt;Lepton AI 的一個主要競爭對手是 Together AI，這同樣是一家初創公司，儘管僅比 Lepton AI 早成立一年左右，但已籌集了超過 5 億美元的風險投資。另外還有一個競爭對手是 Fireworks，由前 Meta PyTorch 團隊成員創立，去年完成了 B 輪融資，英偉達也有參與跟投。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340005/nvidia-gretel-acquisition-synthetic-training-data&quot; target=&quot;news&quot;&gt;英偉達收購合成數據初創公司 Gretel&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/287935&quot; target=&quot;news&quot;&gt;賈揚清評價李彥宏對大模型行業趨勢的預測：非常對&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/276738/search-with-lepton-opensource&quot; target=&quot;news&quot;&gt;賈揚清最新開源項目 —— 500 行代碼構建的 AI 搜索工具&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341235</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341235</guid>
            <pubDate>Sun, 23 Mar 2025 01:46:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>