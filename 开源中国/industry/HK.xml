<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - industry - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/industry</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news/industry" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Tue, 23 Sep 2025 02:41:50 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>DeepSeek-V3.1-Terminus 發佈，緩解偶發異常字符情況</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DeepSeek-V3.1 現已更新至 DeepSeek-V3.1-Terminus 版本。&lt;/p&gt; 
&lt;p&gt;此次更新在保持模型原有能力的基礎上，針對用户反饋的問題進行了改進，包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;語言一致性&lt;/strong&gt;：緩解了中英文混雜、偶發異常字符等情況；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Agent 能力&lt;/strong&gt;：進一步優化了 Code Agent 與 Search Agent 的表現。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;DeepSeek-V3.1-Terminus 的輸出效果相比前一版本更加穩定，新模型各領域測評結果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height="1228" src="https://static.oschina.net/uploads/space/2025/0923/103852_Czrh_2720166.jpg" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;注：Search Agent 的工具集與上一版有所不同，具體工具細節請查看 HuggingFace 文檔&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;目前，官方 App、網頁端、小程序與 DeepSeek API 模型&lt;strong&gt;均已&lt;strong&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/strong&gt;更新為 DeepSeek-&lt;strong&gt;&lt;strong&gt;V&lt;/strong&gt;&lt;/strong&gt;3.1-Terminus。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;開源版本下載地址如下：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Hugging Face：&lt;/strong&gt;&lt;em&gt;https://huggingface.co/deepseek-ai/DeepSeek-V3.1-Terminus&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;ModelScope：&lt;/strong&gt;&lt;em&gt;https://modelscope.cn/models/deepseek-ai/DeepSeek-V3.1-Terminus&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373848</guid>
      <pubDate>Tue, 23 Sep 2025 02:39:48 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 三巨頭慘遭滑鐵盧：最新編程測試正確率全線跌破 25%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="background-color:#ffffff; color:#242424"&gt;Scale AI 全新推出的 SWE-BENCH PRO 編程測評結果顯示，GPT-5、Claude Opus4.1 和 Gemini2.5 沒有一個模型能夠突破 25% 的解決率大關。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#242424"&gt;其中，GPT-5 僅僅取得了 23.3% 的成績，Claude Opus4.1 緊隨其後拿到 22.7%，而 Google 的 Gemini2.5 則是跌至 13.5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="321" src="https://oscimg.oschina.net/oscnet/up-dfae69c1c66d54d084fab4cdc88f34f243c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#242424"&gt;前 OpenAI 研究員 Neil Chowdhury 解析稱，GPT-5 在那些它選擇嘗試解決的任務中，實際準確率高達 63%，這個數字遠遠甩開了 Claude Opus4.1 的 31%。這意味着，雖然 GPT-5 在整體表現上看似平庸，但在其擅長的領域內，這個模型仍然保持着相當的競爭優勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="166" src="https://oscimg.oschina.net/oscnet/up-47abcd9a8138cdbd16ea5a63f6e9980dbe0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;與過去那些動輒 70% 正確率的 SWE-Bench-Verified 測試相比，SWE-BENCH PRO 的測試團隊刻意規避了那些可能已經被用於模型訓練的數據，徹底杜絕了數據污染這一長期困擾 AI 評測的頑疾。這樣做的結果就是，模型們再也無法依靠記憶中的答案來矇混過關，必須展現出真正的推理和解決問題的能力。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;SWE-BENCH PRO 的測試範圍涵蓋了 1865 個來自商業應用和開發者工具的真實問題。這些題目被分為公共集、商業集和保留集三個層次，確保每一個模型在接受評測時都面臨着全新的挑戰。研究團隊還在測試過程中引入了人工增強機制，進一步提升了任務的複雜性和真實性。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="239" src="https://oscimg.oschina.net/oscnet/up-80693f5dcc5bd88019c2c4e4c67e087c2bc.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;因此，&lt;span style="background-color:#ffffff; color:#242424"&gt;測試結果也暴露了當前 AI 模型的軟肋。在解決實際商業問題時，這些模型的能力仍然存在明顯侷限性。特別是在 JavaScript 和 TypeScript 等主流編程語言的處理上，各模型的解決率呈現出令人困惑的劇烈波動。研究人員通過深入分析發現，不同模型在理解和處理同類任務時展現出了顯著的差異化表現，這種差異背後反映的是各家技術路線和訓練策略的根本性分歧。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="413" src="https://oscimg.oschina.net/oscnet/up-3049b6943f05de6adb600f2441c0dfe886e.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373847</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373847</guid>
      <pubDate>Tue, 23 Sep 2025 02:31:48 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>英偉達將逐步向 OpenAI 投資最多 1000 億美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;當地時間 9 月 22 日，OpenAI 與英偉達&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Findex%2Fopenai-nvidia-systems-partnership%2F" target="_blank"&gt;宣佈&lt;/a&gt;建立合作伙伴關係的意向書。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0923/101657_HTH6_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;英偉達有意將逐步向 OpenAI 投資最多 1000 億美元，用於支持數據中心及相關基礎設施建設。雙方合作將為 OpenAI 的下一代人工智能基礎設施部署至少 10 吉瓦的英偉達系統，首批吉瓦級英偉達系統將於 2026 年下半年部署。這一耗電量相當於 800 萬户美國家庭的用電量。&lt;/p&gt; 
&lt;p&gt;英偉達 CEO 黃仁勳週一在接受採訪時表示，10 吉瓦相當於 400 萬至 500 萬塊圖形處理器（GPU），約等於英偉達今年的出貨總量，是去年的兩倍。「這是一個龐大的項目」，黃仁勳與 OpenAI 首席執行官奧爾特曼以及總裁布羅克曼一同接受採訪時表示。&lt;/p&gt; 
&lt;p&gt;據知情人士透露，英偉達首筆 100 億美元投資將在第一個吉瓦數據中心建成時投入。投資將按當時的估值進行。雙方表示，英偉達將隨着每一吉瓦數據中心上線逐步投資，首個階段預計在 2026 年下半年啓用，基於英偉達的 Vera Rubin 平台。合作細節將在未來數週敲定。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373841/openai-nvidia-systems-partnership</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373841/openai-nvidia-systems-partnership</guid>
      <pubDate>Tue, 23 Sep 2025 02:17:48 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>文遠知行與 Grab 攜手推出新加坡首個面向消費者的自動駕駛出行服務</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; text-align:left"&gt;9 月 22 日，「全球 Robotaxi 第一股」文遠知行宣佈，東南亞超級應用 Grab 與其合作將在新加坡推出 Grab 首個面向消費者的自動駕駛出行服務——Ai.R（Autonomously Intelligent Ride）項目。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;Ai.R 項目由新加坡陸路交通管理局（LTA）選定，將是新加坡首次在居民區開展自動駕駛接駁服務，將在榜鵝（Punggol）沿兩條指定路線為居民提供服務。Ai.R 是唯一入選在榜鵝服務兩條路線的自動駕駛接駁項目，初期將投入 11 輛自動駕駛車輛。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//f4573532830d2b5878114083f3692a77.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;Ai.R 車隊將採用文遠知行的兩款產品：可坐 5 名乘客的 Robotaxi GXR 與可坐 8 名乘客的 Robobus。這兩款產品均已通過新加坡嚴格的 Milestone 1（M1）認證，是首批獲得該認證的專為榜鵝服務的自動駕駛車輛。M1 認證旨在驗證車輛在遵守新加坡交通規則的前提下，以自動駕駛模式在公共道路上安全運行的能力。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;項目初期，每輛 Ai.R 自動駕駛車輛將配備一名經專業培訓的 Grab 安全員。這些安全員均由資深 Grab 網約車及出租車司機轉型而來，擁有良好的安全駕駛記錄和乘客評分。今年 8 月起，文遠知行與 Grab Academy 聯合開展了安全員相關培訓。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//865cb9e4044cb29d2d4dd7e5c03ce680.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;目前，已有超過 10 名 Grab 司機正在接受培訓，以參與 Grab 的自動駕駛出行服務項目。自動駕駛安全員培訓課程由文遠知行和 Grab Academy 合作提供，結合了理論知識與 Ai.R 車輛實踐，學員將學習自動駕駛系統的工作原理，包括攝像頭、激光雷達及軟件系統，練習人為駕駛與自動駕駛之間的無縫切換。培訓還涵蓋應急預案與故障排查。通過所有課程及實操考核的學員，將獲證成為自動駕駛安全員，主要職責是監測車輛運行狀態。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;本週起，Ai.R 車輛將在配備安全員的情況下，在榜鵝展開大規模「路線熟悉」測試。車輛將詳細學習路線細節，包括紅綠燈、人行橫道、限速標誌等，從而能夠在指定線路上自動完成接駁服務。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//78d4a577194b1c7591b5c3bfcce65dcd.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;此次 Ai.R 項目的穩步推進，離不開文遠知行此前在新加坡開展的聖淘沙 Robobus、市中心 Robosweeper 項目——通過這些項目，文遠知行已對當地乘客需求和路線運營有了較深瞭解。這為文遠知行後續在新加坡的發展打下了堅實的基礎。希望文遠知行能以 Ai.R 項目為新的起點，繼續優化自動駕駛技術，讓車輛更適應新加坡的道路環境和交通狀況。同時，把自動駕駛服務範圍慢慢擴大，覆蓋更多區域，讓更多新加坡居民用上這種便捷的出行方式。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373839</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373839</guid>
      <pubDate>Tue, 23 Sep 2025 02:00:48 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>​阿里雲推出全球首個全模態 AI 模型 Qwen3-Omni</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;阿里雲發佈了 Qwen3-Omni，標誌着全球首個原生端到端全模態 AI 模型的問世，並且該模型現已開源。Qwen3-Omni 具備處理文本、圖像、音頻和視頻等多種輸入類型的能力，能夠實現實時流式輸出，無論是通過文本還是自然語音，均能快速響應。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="402" src="https://oscimg.oschina.net/oscnet/up-eda85cbd0ae3ed8d5d6460d1ed258132ed9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Qwen3-Omni 模型在多個領域展現出跨模態的先進表現。通過早期以文本為核心的預訓練和混合多模態訓練，該模型具備了強大的多模態能力。在音頻和視頻的性能上尤為出色，同時在文本和圖像的效果上也能保持高標準。根據 36 項音頻和視頻的基準測試，Qwen3-Omni 在 22 項中達到了&lt;span&gt;最新&lt;/span&gt;的領先水平，尤其是在自動語音識別和音頻理解等領域的表現已與同行業的 Gemini2.5Pro 不相上下。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Qwen3-Omni 支持 119 種文本語言和 19 種語音輸入語言，另外還有 10 種語音輸出語言，包括英語、中文、法語和德語等多種語言。此項功能讓它能夠更好地服務於全球用户。其創新的架構設計基於 MoE（專家混合）系統，結合了 AuT 預訓練，從而使模型具有強大的通用表徵能力。同時，多碼本設計確保了低延遲的實時音頻和視頻交互，支持自然對話的流暢進行。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;除了 Qwen3-Omni，阿里雲還發布了 Qwen3-TTS，一個支持 17 種音色選擇的文本轉語音模型。該模型在多項評估基準中表現出色，超越了多款競品，尤其在語音穩定性和音色相似度方面尤為突出。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Qwen-Image-Edit-2509 是另一個新發布的工具，專注於圖像編輯的多圖像支持，顯著提升了編輯的一致性和效果。它不僅能夠處理單圖像，還支持多圖像的拼接編輯，能夠滿足更復雜的編輯需求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373838</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373838</guid>
      <pubDate>Tue, 23 Sep 2025 01:59:48 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OPPO 官宣「繁星編譯器」，Android 首個跨級融合編譯技術</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OPPO ColorOS 16 流暢技術溝通會今天在深圳舉辦，宣佈了 Android 首個無縫架構「極光引擎」、「潮汐引擎」和跨級融合編譯技術「繁星編譯器」等。&lt;/p&gt; 
&lt;p&gt;據介紹，OPPO 繁星編譯器是 ColorOS 16 中推出的全新自研編譯技術，號稱「安卓首個跨級融合編譯技術」。&lt;/p&gt; 
&lt;p&gt;&lt;img height="720" src="https://static.oschina.net/uploads/space/2025/0922/183302_kKl7_2720166.jpg" width="1280" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;它從底層重構 Java 代碼與專屬硬件的編譯鏈路，實現硬件級優化，提升整體編譯效率。該技術可顯著提升系統流暢度，尤其在 API 性能、應用啓動速度和響應效率方面優化明顯，使千元機等中低端設備也能獲得接近旗艦的流暢體驗。&lt;/p&gt; 
&lt;p&gt;繁星編譯器與極光引擎、潮汐引擎協同工作，共同提升全場景、全機型的持久流暢性。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373766</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373766</guid>
      <pubDate>Thu, 18 Sep 2025 10:35:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Notion 3.0 AI 代理爆出嚴重漏洞，惡意 PDF 可誘導其泄露敏感數據</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;隨着 Notion 3.0 的發佈，其全新的自主 AI 代理功能備受關注，該功能旨在幫助用户自動完成起草文檔、更新數據庫和管理工作流程等任務。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;然而，網絡安全公司 CodeIntegrity&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;最新&lt;/span&gt;的一份&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthe-decoder.com%2Fnotion-3-0s-new-ai-agents-can-be-tricked-into-leaking-data-through-a-malicious-pdf%2F" target="_blank"&gt;報告&lt;/a&gt;揭示了這些 AI 代理存在一個嚴重的安全漏洞，即惡意文件（如 PDF）可被利用，誘導代理繞過安全防護並竊取敏感數據。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="307" src="https://oscimg.oschina.net/oscnet/up-49f90bdfdd15f490191d906671de07a4b28.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;CodeIntegrity 將這一漏洞歸因於 AI 代理的「致命三重奏：&lt;strong&gt;大型語言模型（LLM）&lt;/strong&gt;、&lt;strong&gt;工具訪問權限&lt;/strong&gt;和&lt;strong&gt;長期記憶&lt;/strong&gt;的結合。研究人員指出，傳統的訪問控制措施（如基於角色的訪問控制 RBAC）在這種複雜環境中無法提供足夠保護。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;該漏洞的核心是 Notion3.0 的內置網絡搜索工具&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;functions.search&lt;/code&gt;。儘管其初衷是幫助 AI 代理獲取外部信息，但該工具卻極易被操縱以竊取數據。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;為了證明這一點，CodeIntegrity 團隊進行了一次演示攻擊:他們創建了一份看似無害的 PDF 文件，其中包含一條隱藏的惡意指令，指示 AI 代理通過網絡搜索工具將敏感客户數據上傳到攻擊者控制的服務器。一旦用户將該 PDF 上傳至 Notion 並要求代理「總結報告」，代理便會忠實地執行隱藏指令，提取並傳輸數據。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得注意的是，該攻擊在使用了&lt;span&gt;最先&lt;/span&gt;進的語言模型 Claude Sonnet4.0 的情況下依然成功，表明即使是先進的防護措施也未能阻止這一漏洞。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;報告同時警告，這一問題不僅限於 PDF 文件。Notion3.0 的 AI 代理能夠連接到 GitHub、Gmail 或 Jira 等第三方服務，任何集成都有可能成為間接提示注入的載體，惡意內容可以藉此潛入，誘導 AI 代理執行不當行為，從而違背用户的初衷。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373764</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373764</guid>
      <pubDate>Thu, 18 Sep 2025 10:20:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>pyproc - 無需 CGO 或微服務即可從 Go 調用 Python</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;pyproc 允許你從 Go 調用 Python 函數，就像它們是本地函數一樣，使用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;零網絡開銷&amp;nbsp;&lt;/strong&gt;- 使用 Unix 域套接字進行 IPC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;進程隔離&amp;nbsp;&lt;/strong&gt;- Python 崩潰不會影響你的 Go 服務&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真正的並行性&lt;/strong&gt;- 多個 Python 進程繞過 GIL&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;簡單部署&amp;nbsp;&lt;/strong&gt;- 只需 Go 二進制文件 + Python 腳本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;連接池&lt;/strong&gt; -&amp;nbsp;重用連接以實現高吞吐量&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目標受眾和用例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;非常適合需要執行以下操作的團隊：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;將現有的 Python ML 模型（PyTorch、TensorFlow、scikit-learn）集成到 Go 服務中&lt;/li&gt;
&lt;li&gt;使用 Go 應用程序中的 Python 庫（pandas、numpy）處理數據&lt;/li&gt;
&lt;li&gt;處理 1-5k RPS，JSON 有效負載低於 100KB&lt;/li&gt;
&lt;li&gt;部署在同一主機/pod 上，無需擔心網絡複雜性&lt;/li&gt;
&lt;li&gt;在保留 Python 邏輯的同時，逐步從 Python 微服務遷移到 Go&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;理想的部署場景：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kubernetes 同 Pod 部署，具有 UDS 共享卷&lt;/li&gt;
&lt;li&gt;具有共享套接字卷的 Docker 容器&lt;/li&gt;
&lt;li&gt;Linux/macOS 上的傳統服務器部署&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;非目標&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;pyproc&lt;strong&gt;不適&lt;/strong&gt;用於：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨主機通信&lt;/strong&gt;- 使用 gRPC/REST API 實現分佈式系統&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows UDS 支持&lt;/strong&gt;- 不支持 Windows 命名管道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU 管理&lt;/strong&gt;- 使用專用 ML 服務框架（TensorRT、Triton）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大規模 ML 服務&lt;/strong&gt;- 考慮使用 Ray Serve、MLflow 或 KServe 進行企業 ML&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;實時流&lt;/strong&gt;- 使用 Apache Kafka 或類似產品實現高吞吐量流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;數據庫操作&lt;/strong&gt;- 直接使用原生 Go 數據庫驅動程序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;div style="text-align:start"&gt;
&lt;h2&gt;Compatibility Matrix&lt;/h2&gt;
&lt;/div&gt;

&lt;table cellspacing="0" style="border-collapse:collapse; border-spacing:0px; box-sizing:border-box; display:block; font-variant:tabular-nums; margin-bottom:16px; margin-top:0px; max-width:100%; overflow:auto; width:max-content"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="border-color:#d1d9e0"&gt;Component&lt;/th&gt;
&lt;th style="border-color:#d1d9e0"&gt;Requirements&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Operating System&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Linux, macOS (Unix Domain Sockets required)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Go 版本&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;1.22+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Python 版本&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;3.9+ (建議 3.12)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Same host/pod only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Container Runtime&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Docker, containerd, any OCI-compatible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Orchestration&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Kubernetes (same-pod), Docker Compose, systemd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Architecture&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;amd64, arm64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;特點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;無需 CGO&lt;/strong&gt;&amp;nbsp;- 使用 Unix 域套接字的純 Go 實現&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;繞過 Python GIL&lt;/strong&gt;&amp;nbsp;- 並行運行多個 Python 進程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;類似函數的 API&lt;/strong&gt;&amp;nbsp;- 調用 Python 函數就像&lt;code&gt;pool.Call(ctx, "predict", input, &amp;amp;output)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小開銷&lt;/strong&gt;- 45μs p50 延遲，8 個 worker 每秒 200,000+ 個請求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生產就緒&lt;/strong&gt;——健康檢查、正常關機、自動重啓&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易於部署&lt;/strong&gt;- 單個二進制文件 + Python 腳本，無需服務網格&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/pyproc</link>
      <guid isPermaLink="false">https://www.oschina.net/p/pyproc</guid>
      <pubDate>Thu, 18 Sep 2025 10:03:00 GMT</pubDate>
    </item>
    <item>
      <title>Windows 11 任務欄將增加 AI 功能「Taskbar Companion」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微軟正在&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.windowslatest.com%2F2025%2F09%2F19%2Fmicrosoft-is-testing-ai-agents-and-assistants-for-windows-11s-taskbar%2F" target="_blank"&gt;測試&lt;/a&gt;Windows 11 任務欄的幾個新功能，其中包括名為「Taskbar Companion」（任務欄伴侶）的 AI 功能，允許用户與「AI 智能體和助手」進行交互。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-9727545f6fd7516d59dc1f0bf25886f2f14.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在幾周前就發現了關於該實驗性功能的提及，如今 Phantom 又發現了關於該功能新信息，其中有一個名為「 任務欄上的 Composer 功能，可與助手和智能體集成」的新條目，以及與 Taskbar.view.dll 關聯的 AI 模塊。&lt;/p&gt; 
&lt;p&gt;雖然「任務欄伴侶」的具體用途目前並不清楚，但可以推測它將為任務欄增加更多的流暢性，幫助用户從一堆圖標中找到應用程序，甚至在不需要任何輸入的情況下完成操作。&lt;/p&gt; 
&lt;p&gt;它可能還會根據用户的使用習慣推薦應用程序，或者帶來一些管理任務欄設置並提出提高生產力的建議，另一種可能是，它會成為一個僅詢問問題並僅顯示一些信息助手。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373752</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373752</guid>
      <pubDate>Thu, 18 Sep 2025 09:40:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬斯克：到 11 月 X 的算法將完全由 AI 驅動</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;X 平台產品主管 Nikita Bier 的發帖表示，該平台正試圖幫助用户擺脱「主流算法和政治運動」，找到屬於自己的獨特領域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;對此，馬斯克轉帖回應稱：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;「到 11 月時，算法將完全由 AI 驅動，並且在此過程中會取得重大進展。我們每隔兩週左右就會公開算法的源代碼。到 11 月或者最晚 12 月，你只需向 Grok 發出指令，就能動態地調整你的信息流了。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-c1f9b321f78f012ea893c09b30c51e63e21.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373750</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373750</guid>
      <pubDate>Thu, 18 Sep 2025 09:33:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Luma AI 發佈首款具備「推理」能力的視頻生成模型 Ray3</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 公司 Luma 日前宣佈推出全新視頻生成模型&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flumalabs.ai%2Fray" target="_blank"&gt; Ray3&lt;/a&gt;，並在 X 上發佈演示影片。官方稱該模型為「全球首款具備推理能力的視頻模型」，並首次實現了原生 16bit 高動態範圍（HDR）輸出。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/173029_Yrwo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，Ray3 引入了全新的「Draft」模式，支持創意流程中的快速迭代，並具備先進的物理模擬與一致性表現。&lt;/p&gt; 
&lt;p&gt;Luma 表示，Ray3 能夠理解複雜指令、進行視覺與語言標記的推理，並自主評估生成結果，從而提升內容質量與創作效率。&lt;/p&gt; 
&lt;p&gt;Ray3 核心能力包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;生產級保真度與高動態表現&lt;/li&gt; 
 &lt;li&gt;推理驅動的多步驟動作生成與場景理解&lt;/li&gt; 
 &lt;li&gt;支持圖像塗鴉式註釋，實現無提示的精確控制&lt;/li&gt; 
 &lt;li&gt;交互式光照、衍射、運動模糊與照片級真實感&lt;/li&gt; 
 &lt;li&gt;Hi-Fi 擴散通道，支持 4K HDR 視頻輸出，迭代速度提升 5 倍，成本降低 5 倍&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Luma 強調，Ray3 的推理能力使其不僅能「看懂」創作者的意圖，還能「思考」如何優化鏡頭表現，為高端創意製作流程提供更強大的工具支持。&lt;/p&gt; 
&lt;p&gt;目前，Ray3 已在 Luma AI 的 Dream Machine 平台上線，用户可立即免費試用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373749</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373749</guid>
      <pubDate>Thu, 18 Sep 2025 09:30:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>純白電競房最後一塊拼圖，技嘉 M27UP ICE 與 M27Q2 QD ICE 顯示器來襲</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; text-align:left"&gt;近年來，以純白顏色為主題的電競房整機風格越來越受到歡迎，而技嘉作為 PC DIY 領域的知名品牌之一，早早就在主板、顯卡、機箱散熱等領域部署了冰雕、雪鷹等系列產品，現在技嘉補上了打造純白電競房的最後一步：純白電競房顯示器。據悉，即將到來的新品型號為技嘉技嘉 M27UP ICE 與 M27Q2 QD ICE，主打兩千元價位高性價比、高顏值、高性能的」純白小金剛「，一起來瞭解下吧。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;&lt;strong&gt;320H&lt;/strong&gt;&lt;strong&gt;z&lt;/strong&gt;&lt;strong&gt;刷新+雙模電競：&lt;/strong&gt;&lt;strong&gt;M27UP ICE&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;技嘉 M27UP ICE 顯示器採用 27 英寸 SS IPS 面板，最大的特點是支持「1080P 320Hz「與」4K 160Hz」分辨率刷新率自由切換，僅需通過物理按鍵或軟件設置調整分辨率與刷新率，方便玩家在 PC 遊戲和主機遊戲（如 PS5）等設備之間靈活搭配，同時兼顧了一定的辦公家用屬性，實用性特別高。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//12d7bfb26f101cb5922880b0b651c463.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;在屏幕素材方面，M27UP ICE 色域覆蓋範圍達 95% DCI-P3 與 125% sRGB，同時兼容 HDR10 標準並通過 VESA DisplayHDR 400 認證；其典型亮度為 350 尼特，峯值亮度最高可至 450 尼特，靜態對比度則為 1000:1，能為用户帶來豐富的色彩層次與清晰的明暗細節。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;此外針對 FPS 玩家的核心需求，技嘉 M27UP ICE 顯示器設計了多項專屬功能：&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;戰術鍵 2.0 物理旋鈕：用户可一鍵切換至 24 英寸 4:3 或 5:4 比例畫面，既能提升目標鎖定的精準度，又能減少無關畫面的幹擾；智能 OD 技術：智能檢測屏幕刷新率，自動調整過沖強度，自動減少動態模糊與白色拖影，呈現更鋭利的視覺效果和更流暢的動態畫面。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;黑平衡 2.0 技術：通過動態拓展暗部細節，再搭配夜視模式，可進一步強化低光照環境下敵人的輪廓特徵，降低敵人「隱身」概率；&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//ccdbebdcf84d795ee7e2f87050125344.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;接口配置上，技嘉 M27UP ICE 顯示器擁有雙 HDMI 2.1 接口、一個 DisplayPort 1.4 接口及一個支持 18W 供電的 USB-C 接口，同時具備 KVM 切換與畫中畫功能；其 USB 3.2 Gen1 集線器還提供三個擴展接口，可外接鍵盤、鼠標、耳機等外設，提升使用便利性。音頻方面，顯示器內置兩個 5W 功率揚聲器，滿足玩家基礎的影音播放需求。&lt;/p&gt; 
&lt;h4&gt;2K 畫質專業色彩體驗：M27Q2 QD ICE&lt;/h4&gt; 
&lt;p style="color:#000000; text-align:left"&gt;如果你對顯示器的畫質色彩有更高要求，那麼技嘉 M27Q2 QD ICE 顯示器更值得關注。採用 27 英寸 SS IPS 面板，內置 QD 量子點顯示技術，色彩呈現效果接近 OLED 的鮮活色彩和寬廣色域，同時還具備穩定耐用的特點。M27Q2 QD ICE 實現了 99% DCI-P3、99% Adobe RGB 與 150% sRGB 的廣色域覆蓋，能呈現栩栩如生的真實色彩細節，同時支持 2K@210Hz 超高刷新率及 1ms GTG 響應時間，並且保留了 M27UP ICE 上特色的戰術鍵 2.0 物理旋鈕、智能 OD 和黑平衡 2.0 功能，因此無論是追求沉浸 3A 遊戲體驗的玩家，還是對色彩精度有高要求的創作者，均可獲得需求滿足。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:center"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//23448ec5069bc43717302a902432d562.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;在實用性上，技嘉 M27Q2 QD ICE 顯示器採用 2mm 超薄金屬底座，既展現時尚外觀，又兼具安靜使用體驗與穩固支撐性能。不僅如此，該顯示器還支持 KVM 多設備切換功能，方便多設備用户輕鬆切換使用場景，進一步提升工作與娛樂場景的使用效率。憑藉接近 OLED 級別的色彩表現、出色的電競性能與貼心的護眼設計，技嘉 M27Q2 QD ICE 顯示器成為兼顧娛樂與創作需求的優選。&lt;/p&gt; 
&lt;p style="color:#000000; text-align:left"&gt;值得一提的是，以上兩款顯示器技嘉都提供三年質保承諾和技嘉個人送保服務支持，覆蓋顯示器主體及核心部件（如面板、驅動板等），在質保期內若出現非人為因素導致的性能故障，用户可享受官方免費維修或更換服務，大幅降低用户售後成本與流程複雜度。總之，如果你希望選擇一款純白高顏值、性能強勁的顯示器的話，那麼技嘉 M27UP ICE 與 M27Q2 QD ICE 相信會是你的不二之選。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373748</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373748</guid>
      <pubDate>Thu, 18 Sep 2025 09:24:00 GMT</pubDate>
      <author>作者: 開源科技</author>
    </item>
    <item>
      <title>​OpenAI 計劃未來五年追加 1000 億美元服務器投資</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;The Information&amp;nbsp;援引公司高管與股東的討論報道稱，OpenAI 計劃在未來五年內追加 1000 億美元用於租用備用服務器。這一雄心勃勃的投資計劃將使得到 2030 年，OpenAI 在租賃服務器上的支出預計將達到 3500 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-54156111f077faf6354c4f1f14dd20629e5.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在高盛的一場會議上，OpenAI 的首席財務官 Sarah Friar 指出，由於可用計算能力嚴重受限，OpenAI 經常需要推遲產品發佈或限制功能的上線。為了應對用户需求的突發增長，並支持未來模型的訓練，額外的服務器投資顯得尤為重要。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根據預測，OpenAI 每年將在服務器上花費大約 850 億美元，這幾乎相當於 2024 年亞馬遜、微軟、谷歌和甲骨文四大科技公司總收入的一半。這項投資的總額使得 OpenAI 預計在 2029 年前的現金流出量達到 1150 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;隨着人工智能技術的迅速發展和應用場景的日益擴大，OpenAI 正面臨着更大的挑戰和機遇。為了保持其技術領先地位和市場競爭力，額外的服務器資源不僅可以幫助 OpenAI 應對當前的計算需求，也為未來的創新打下堅實的基礎。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373741</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373741</guid>
      <pubDate>Thu, 18 Sep 2025 09:06:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 編程工具 Cursor 上線全新文檔中心</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 編程工具 Cursor&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fcursor_ai%2Fstatus%2F1968486162625937849" target="_blank"&gt;宣佈&lt;/a&gt;其新版官方文檔中心正式上線，域名已指向 cursor.com/docs。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-60f7f656229822bc096cc0f5ec222340fff.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;用户可以通過該入口系統地學習 Cursor 的使用方法並瞭解各種功能細節。中文文檔也已同步更新：&lt;em&gt;https://cursor.com/zh/docs&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;此外同步發佈的預告圖顯示，全新的品牌官網也將「很快上線」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373740</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373740</guid>
      <pubDate>Thu, 18 Sep 2025 09:05:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>喬布斯 1984 年的前瞻：電腦的下一步是「Agent」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在 1984 年的一次罕見訪談中，年僅 29 歲的史蒂夫·喬布斯提出了一個頗具前瞻性的觀點 —— 電腦的未來將不再只是工具，而是成為用户的 「Agent」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/164934_CfkC_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;喬布斯在接受《Access》雜誌採訪時表示：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我們今天擁有的電腦是工具是「回應者」（responders）：你讓它做什麼，它就做什麼。下一個階段，計算機將成為「代理者」（agents）。&lt;/p&gt; 
 &lt;p&gt;換句話説，就好像那個盒子裏住着一個小人，開始預判你的需求。他進一步描繪了一個願景：電腦將不只是幫助用户完成任務，而是主動引導用户穿越海量信息，甚至像朋友一樣陪伴左右。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;他設想了一種便攜式設備，用户從 10 歲開始使用，它會逐步瞭解用户的習慣與情緒，甚至在關鍵時刻給予提醒與建議。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;有一天你 18 歲，剛剛和女朋友分手，它會説：「你知道，史蒂夫，這已經是你第三次遇到這種情況了。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;這一構想在當時看來或許天馬行空，但如今看來卻與 AI 通用大模型的發展路徑驚人契合。從 Siri 到 ChatGPT、DeepSeek，從語音識別到個性化推薦，喬布斯所描繪的「Agent」願景正在逐步成為現實。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/165200_IV5g_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，這場訪談發生在 Macintosh 首次亮相之後不久，喬布斯正處於事業的上升期。他不僅在技術層面展現出敏鋭洞察，也在人機交互的未來上留下了深遠的思考。&lt;/p&gt; 
&lt;p&gt;如今回望這段歷史，不禁令人感嘆：有些預言，不是因為它們準確，而是因為它們激發了整個行業未來的想象。喬布斯的「Agent」願景，或許正是其中之一。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373733</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373733</guid>
      <pubDate>Thu, 18 Sep 2025 08:52:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>基於「老鄉雞」的開源菜譜登頂 GitHub Trending</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;近日，一個名為「CookLikeHOC」的 GitHub 倉庫因收錄《老鄉雞菜品溯源報告》內容並進行整理編輯，迅速登上 GitHub Trending 榜單首位。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/163105_jHdg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/Gar-b-age/CookLikeHOC&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;該倉庫並非老鄉雞官方項目&lt;/strong&gt;，而是由網友整理發佈。倉庫所有者在 README 文件中寫道：「像老鄉雞那樣做飯」。&lt;/p&gt; 
&lt;p&gt;事件發酵後，老鄉雞官方回應稱已向倉庫作者贈送一張價值 1000 元的儲值卡以示感謝。&lt;/p&gt; 
&lt;p&gt;令人意外的是，官方在公開致謝時，竟將儲值卡的密碼一併「開源」。&lt;/p&gt; 
&lt;p&gt;此後，官方在該倉庫的 Issue #89 中發起「程序員福利」活動，稱上一次的儲值卡「沒有被作者本人領走😭」，並表示新卡將直接發送至作者郵箱。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/162949_pQPm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/Gar-b-age/CookLikeHOC/issues/81&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;為了回饋更多喜愛老鄉雞的程序員，官方決定額外發放多張儲值卡，但這次設置了「小小門檻」—— 密鑰被藏在一段音頻文件中，需解密才能領取。網友很快破解出音頻中的摩斯密碼「77A53B68」，不過卡內餘額很快被領空。&lt;/p&gt; 
&lt;p&gt;評論區熱鬧非凡，有人調侃「來晚力（悲）」，有人建議將活動做成定期 CTF 挑戰，甚至在 1024 程序員節發放更多獎品，以趣味解謎的方式持續吸引流量與關注。&lt;/p&gt; 
&lt;p&gt;目前，該倉庫已收穫超過 1 萬顆 Star 和 1.2k 次 Fork。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;相關閲讀&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/288577/lxjchina-oschina-gitee-interview" target="_blank"&gt;雖然老鄉雞開源的不是代碼，但背後的原因卻讓人很暖心&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/286890" target="_blank"&gt;老鄉雞「開源」了&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373730</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373730</guid>
      <pubDate>Thu, 18 Sep 2025 08:27:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>字節跳動推出多語言翻譯模型 Doubao-Seed-Translation</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;字節跳動旗下火山引擎近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.volcengine.com%2Fdocs%2F82379%2F1820188" target="_blank"&gt;發佈&lt;/a&gt;了自研的多語言翻譯模型 —— Doubao-Seed-Translation，支持數十種語言互譯。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官方宣稱，Doubao-Seed-Translation 的中英翻譯效果逼近 Deepseek-R1，通用多語言翻譯效果超越或持平 GPT-4o / Gemini-2.5-Pro，能精準適配辦公和娛樂等多場景需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;模型價格&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" class="volc-viewer-table" style="-webkit-tap-highlight-color:rgba(255, 255, 255, 0); -webkit-text-stroke-width:0px; appearance:none; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:rgba(23, 23, 23, 0.8); display:block; font-family:PingFangSC,&amp;quot;helvetica neue&amp;quot;,&amp;quot;hiragino sans gb&amp;quot;,arial,&amp;quot;microsoft yahei ui&amp;quot;,&amp;quot;microsoft yahei&amp;quot;,simsun,&amp;quot;sans-serif&amp;quot;; font-size:14px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:0px 0px 14px; orphans:2; outline:none; overflow:auto; padding:0px; table-layout:fixed; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:840.667px; word-break:break-word; word-spacing:0px"&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸入&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸入命中緩存&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸出單價&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;緩存存儲&lt;br&gt; (元/百萬 token*小時)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸入單價[批量]&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸入命中緩存單價[批量]&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;輸出單價[批量]&lt;br&gt; (元/百萬 token)&lt;/p&gt; &lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;1.20&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;-&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;3.60&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;-&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;0.60&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;0.24&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;1.80&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;blockquote&gt; 
 &lt;p style="margin-left:0; margin-right:0"&gt;下面是計費項的簡單説明，具體可參閲&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.volcengine.com%2Fdocs%2F82379%2F1544106" target="_blank"&gt;模型服務價格&lt;/a&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;ul style="margin-left:0; margin-right:0"&gt; 
  &lt;li&gt;使用在線推理的上下文緩存能力，產生命中緩存的輸入折後費用、創建的緩存存儲費用。&lt;/li&gt; 
  &lt;li&gt;使用批量推理，產生輸入[批量]費用、命中透明緩存的輸入折後費用、輸出[批量]費用。&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373725</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373725</guid>
      <pubDate>Thu, 18 Sep 2025 08:07:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌深度學習專家 Dustin Tran 跳槽至 xAI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 宣佈從 Google DeepMind 跳槽至馬斯克的 xAI，成為公司研發新一代 Grok 模型的重要成員。此消息在他於社交媒體上正式官宣後不久，馬斯克便迅速轉發，確認了這一人事變動的真實性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="290" src="https://oscimg.oschina.net/oscnet/up-c6df198a66d14d96ac0ff58b9bdfb7a14c0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 是 Gemini 項目的核心開發者，自項目誕生以來，他在多個關鍵階段發揮了重要作用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;從 2014 年在加州大學伯克利畢業，取得數學與統計本科學位後，Tran 繼續攻讀哈佛大學的統計學博士，並最終在哥倫比亞大學獲得計算機科學博士學位。他在學術界的貢獻也頗為顯著，其論文總引用量超過 2.4 萬次，曾榮獲包括 Google 博士獎學金在內的多個獎項。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在離開 Google DeepMind 的長文中，Tran 深情回顧了自己在該公司的 8 年旅程，他參與了多個重要項目的開發，尤其是 Gemini 的成長過程。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他提到，最初人們對 Google 在 AI 領域的未來持悲觀態度，但隨着 Gemini 在用户偏好上佔據領先地位以及在科研突破上的不斷進展，這種看法逐漸改變。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;加入 xAI 的原因，他提到的是這裏的巨大算力和數據優勢。Tran 對 xAI 的信心滿滿，認為這是研發前沿級語言模型的必備條件。尤其是 Colossus 2 的強大算力，使他意識到 xAI 在行業中的競爭力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373709</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373709</guid>
      <pubDate>Thu, 18 Sep 2025 07:14:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>2TB 新 iPhone 導入 85GB 微信聊天記錄提示空間不足；微信員工稱代碼存在 Bug</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;iPhone 17 系列手機日前已開售，很多拿到新機的用户第一時間就是轉移數據。&lt;/p&gt; 
&lt;p&gt;不過有微信用户發現，在向新 iPhone 導入聊天記錄時，微信提示設備空間不足，但手機明明還有 1.29TB 可用容量，而導入的聊天記錄最多隻需 85.16GB 空間。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1354" src="https://static.oschina.net/uploads/space/2025/0922/150216_L3bN_2720166.png" width="744" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e5044091cab39969380f84c9693480a6030.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;對此，微信員工「客村小蔣」&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7876775013%2FQ5Ct4vIjM" target="_blank"&gt;回應稱&lt;/a&gt;，微信的代碼存在 Bug 導致無法獲取系統的真實剩餘空間，將很快修復。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我們們有個獲取剩餘空間的通用工具接口，這個接口內部有個緩存，在獲取間隔不超過 5 分鐘的時候，不會向系統獲取真實的剩餘空間，本意是為了避免頻繁讀取系統接口導致性能問題，但在新手機上，有概率會造成這種情況，因為該邏輯會在開機 5 分鐘內返回數據是 0。&lt;strong&gt;開機後用個 5 分鐘，接口就能獲取到真實的剩餘空間，就正常了&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/150356_WJpx_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373705</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373705</guid>
      <pubDate>Thu, 18 Sep 2025 07:04:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>從 Java 到 Go：面向對象的巨人與雲原生的輕騎兵</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;Go 語言在 2009 年被 Google 推出，在創建之初便明確提出了「少即是多（Less is more）」的設計原則，強調「以工程效率為核心，用極簡規則解決複雜問題」。它與 Java 語言生態不同，Go 通過編譯為 &lt;strong&gt;單一靜態二進制文件實現快速啓動和低內存開銷&lt;/strong&gt;，&lt;strong&gt;以 25 個關鍵字強制代碼簡潔性&lt;/strong&gt;，&lt;strong&gt;用接口組合替代類繼承&lt;/strong&gt;，&lt;strong&gt;以顯式返回 error 取代異常機制&lt;/strong&gt; 和 &lt;strong&gt;輕量級併發模型（Goroutine/Channel）&lt;/strong&gt; 在 &lt;strong&gt;雲原生基礎設施領域&lt;/strong&gt; 佔據主導地位，它也是 Java 開發者探索雲原生技術棧的關鍵補充。本文將對 Go 語言和 Java 語言在一些重要特性上進行對比，為 Java 開發者在閲讀和學習 Go 語言相關技術時提供參考。&lt;/p&gt; 
  &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
  &lt;h3&gt;代碼組織的基本單元&lt;/h3&gt; 
  &lt;p&gt;在 Java 中，我們會創建 &lt;code&gt;.java&lt;/code&gt; 文件作為 &lt;strong&gt;類&lt;/strong&gt;（類名與文件名相同），並在該類中定義相關的字段或方法等（OOP），如下定義 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相關的內容便需要聲明兩個 &lt;code&gt;.java&lt;/code&gt; 文件（&lt;code&gt;User.java&lt;/code&gt;, &lt;code&gt;Address.java&lt;/code&gt;）定義類：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; city&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 語言中，它是通過 &lt;strong&gt;「包」&lt;/strong&gt; 來組織代碼的：每個目錄下的所有 &lt;code&gt;.go&lt;/code&gt; 文件共享同一個 &lt;strong&gt;包&lt;/strong&gt;，在包內可以定義多個結構體、接口、函數或變量。它並不要求文件名與聲明的內容一致，比如創建 &lt;code&gt;User&lt;/code&gt; 「結構體」並不會要求 &lt;code&gt;.go&lt;/code&gt; 文件也命名為 &lt;code&gt;User.go&lt;/code&gt;，而是任何命名都可以（命名為 &lt;code&gt;user.go&lt;/code&gt; 甚至 &lt;code&gt;a.go&lt;/code&gt; 這種無意義的命名），而且同一個包下可以創建多個 &lt;code&gt;.go&lt;/code&gt; 文件。如下為在 &lt;code&gt;user&lt;/code&gt; 包下定義 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相關的內容，它們都被聲明在一個 &lt;code&gt;user.go&lt;/code&gt; 文件中：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;type&lt;/span&gt; Address &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   city &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;City&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;city
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;city &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   a&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;相比來説，Java 代碼組織的基本單元是類，作為面向對象的語言更側重對象定義，而 Go 代碼組織的基本單元是包，並更側重功能模塊的聚合。&lt;/p&gt; 
  &lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
  &lt;h4&gt;可見性控制&lt;/h4&gt; 
  &lt;p&gt;在 Java 中通過 &lt;code&gt;public/protected/private&lt;/code&gt; 關鍵字控制成員的可見性，而在 Go 語言中，通過 &lt;strong&gt;首字母大小寫&lt;/strong&gt; 控制「包級別的導出」（大寫字母開頭為 &lt;code&gt;public&lt;/code&gt;），&lt;strong&gt;包的導出成員對其他包可見&lt;/strong&gt;。以 user 包下 &lt;code&gt;User&lt;/code&gt; 類型的定義為例，在 main 包下測試可見性如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;// user package 的全路徑&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
   &lt;span&gt;// 不能導入未使用到的包&lt;/span&gt;
   &lt;span&gt;//"math"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; u user&lt;span&gt;.&lt;/span&gt;User
&lt;span&gt;// 在這裏是不能訪問未導出的字段 name&lt;/span&gt;
&lt;span&gt;// fmt.Println(u.name)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言不能導入未使用到的包，並且函數是基於包的一部分。比如 &lt;code&gt;fmt.Println&lt;/code&gt; 函數，這個函數是在 &lt;code&gt;fmt&lt;/code&gt; 包下的，調用時也是以包名為前綴。&lt;/p&gt; 
  &lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
  &lt;h3&gt;變量的聲明&lt;/h3&gt; 
  &lt;p&gt;在 Java 語言中，對變量（靜態變量或局部變量）的聲明只有一種方式，「採用 = 運算符賦值」顯式聲明（在 Jdk 10+支持 var 變量聲明），如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 語言中，變量聲明有兩種主要方式：&lt;strong&gt;短聲明（&lt;code&gt;:=&lt;/code&gt; 運算符）&lt;/strong&gt; 和 &lt;strong&gt;長聲明（&lt;code&gt;var&lt;/code&gt; 聲明）&lt;/strong&gt;，它們的適用場景和限制有所不同，以下是詳細區分：&lt;/p&gt; 
  &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
  &lt;h4&gt;短聲明（&lt;code&gt;:=&lt;/code&gt;）&lt;/h4&gt; 
  &lt;p&gt;只能在函數（包括 &lt;code&gt;main&lt;/code&gt;、自定義函數或方法、&lt;code&gt;if/for&lt;/code&gt; 塊等）內部使用，不能在包級別（全局作用域）使用，並且 &lt;strong&gt;聲明的局部變量必須被使用&lt;/strong&gt;，不被使用的局部變量不能被聲明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 正確&lt;/span&gt;
x &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 未被使用，不能被聲明&lt;/span&gt;
&lt;span&gt;// y := 20&lt;/span&gt;
&lt;span&gt;// 不賦值也不能被聲明&lt;/span&gt;
&lt;span&gt;// z :=            &lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 錯誤：不能在包級別使用短聲明&lt;/span&gt;
&lt;span&gt;// y := 20          &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這種短聲明直接根據右側值自動推斷變量類型，無需顯式指定類型，並且可以一次性聲明多個變量，但至少有一個變量是 &lt;strong&gt;新聲明的&lt;/strong&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 同時聲明 a 和 b&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
&lt;span&gt;// c 是新變量，b 被重新賦值&lt;/span&gt;
c&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"def"&lt;/span&gt;
&lt;span&gt;// 無新變量無法再次對已聲明的變量再次聲明&lt;/span&gt;
&lt;span&gt;//a, b := 4, "error"&lt;/span&gt;

fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; c&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
  &lt;h4&gt;長聲明（&lt;code&gt;var&lt;/code&gt; 聲明）&lt;/h4&gt; 
  &lt;p&gt;在全局作用域聲明變量必須使用 &lt;code&gt;var&lt;/code&gt;；在需要延遲初始化時也需要採用長聲明；顯示指定類型也需要使用長聲明&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; global &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// a = 0&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;// s = ""&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;// 未被初始化值會默認為「零」值，a 為 0，s 為空字符串&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;函數內部的局部變量，尤其是需要類型推斷和簡潔代碼時優先用短聲明；在包級別聲明變量，需要顯式指定類型或聲明變量但不立即賦值（零值初始化）時，使用長聲明。&lt;/p&gt; 
  &lt;p&gt;在 Go 語言中還有一點需要注意：&lt;strong&gt;聲明變量時，應確保它與任何現有的函數、包、類型或其他變量的名稱不同&lt;/strong&gt;。如果在封閉範圍內存在同名的東西，變量將對它進行覆蓋，也就是説，優先於它，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 這個變量會把導入的 fmt 包覆蓋掉&lt;/span&gt;
fmt &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fmt&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;那麼我們導入的 &lt;code&gt;fmt&lt;/code&gt; 包在被局部變量覆蓋後便不能再被使用了。&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;常量的聲明&lt;/h4&gt; 
  &lt;p&gt;Go 語言中對常量的聲明採用 &lt;code&gt;const&lt;/code&gt; 關鍵字，並且在聲明時便需要被賦值，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// DaysInWeek const 變量名，類型 = 具體的值&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; DaysInWeek &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;const&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
   fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; DaysInWeek&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 語言中對常量的聲明會使用 &lt;code&gt;static final&lt;/code&gt; 引用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Constants&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;DAYS_IN_WEEK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
  &lt;h3&gt;方法/函數的聲明&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中，方法的聲明遵循 &lt;strong&gt;func (接收器) 方法名 (入參) 返回值&lt;/strong&gt; 的格式，無返回值可以不寫（無需 void 聲明），通過 &lt;strong&gt;接收器（Receiver）&lt;/strong&gt; 將方法綁定到結構體上，如下為 &lt;code&gt;User&lt;/code&gt; 結構體方法的聲明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// Name (u *User) 即為接收器，表示該方法綁定在了 User 類型上&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而「函數」的聲明不需要定義接收器，遵循的是 &lt;strong&gt;func 方法名 (入參) 返回值&lt;/strong&gt; 的格式。Go 語言中的函數類似於 Java 語言中的靜態方法，以下是聲明將整數擴大兩倍的函數：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;並且，在 Go 語言中，方法/函數支持多返回值（常用於錯誤處理），並且如果並不需要全部的返回值，可以用 &lt;code&gt;_&lt;/code&gt; 對返回值進行忽略，因為 Go 語言不允許定義未使用的局部變量，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 忽略掉了第三個返回值&lt;/span&gt;
s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;"1"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;此外，接收器參數和函數的形參支持傳入指針，用 &lt;code&gt;*&lt;/code&gt; 符號表示。在 Go 語言中有指針的概念，我們在這裏説明一下：Go 語言是 &lt;strong&gt;「值傳遞」&lt;/strong&gt; 語言，方法/函數的形參（或接收器）如果不標記指針的話，接收的實際上都是 &lt;strong&gt;實參的副本&lt;/strong&gt;，那麼 &lt;strong&gt;在方法/函數中的操作並不會對原對象有影響&lt;/strong&gt;。如果想對原對象進行操作，便需要通過指針獲取到原對象才行（因為值傳遞會對原對象和形參對象都劃分空間，所以針對較大的對象都推薦使用指針以節省內存空間）。在如下示例中，如果我們將上文中 &lt;code&gt;double&lt;/code&gt; 方法的形參修改為值傳遞，這樣是不能將變量 a 擴大為兩倍的，因為它操作的是 a 變量的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要獲取 10，但打印 5&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;想要實現對原對象 a 的操作，便需要使用指針操作，將方法的聲明中傳入指針變量 &lt;code&gt;*int&lt;/code&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;// &amp;amp; 為取址運算符&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要獲取 10，實際獲取 10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// *int 表示形參 a 傳入的是指針&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// *a 表示從地址中獲取變量 a 的值&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;再回到 &lt;code&gt;User&lt;/code&gt; 類型的聲明中，如果我們將接收器修改成 &lt;code&gt;User&lt;/code&gt;，那麼 &lt;code&gt;SetName&lt;/code&gt; 方法是不會對原變量進行修改的，它的修改實際上只針對的是 &lt;code&gt;User&lt;/code&gt; 的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// SetName 指定為值接收器&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這樣 &lt;code&gt;SetName&lt;/code&gt; 方法便不會修改原對象，&lt;code&gt;SetName&lt;/code&gt; 的操作也僅僅對副本生效了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u &lt;span&gt;:=&lt;/span&gt; user&lt;span&gt;.&lt;/span&gt;User&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"abc"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 實際輸出為 {}，並沒有對原對象的 name 字段完成賦值&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 中並沒有指針的概念，Java 中除了基本數據類型是值傳遞外，其他類型在方法間傳遞的都是「引用」，對引用對象的修改也是對原對象的修改。&lt;/p&gt; 
  &lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
  &lt;h3&gt;接口&lt;/h3&gt; 
  &lt;p&gt;Go 語言也支持接口的聲明，不過相比於 Java 語言它更追求 &lt;strong&gt;「靈活與簡潔」&lt;/strong&gt;。Go 的接口實現是「隱式地」，&lt;strong&gt;只要類型實現了接口的所有方法，就自動滿足該接口&lt;/strong&gt;，無需顯式聲明。如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;type&lt;/span&gt; Writer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// File 無需聲明實現 Writer，實現了接口所有的方法便自動實現了該接口&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; File &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;f &lt;span&gt;*&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Java 語言則必須通過 &lt;code&gt;implements&lt;/code&gt; 關鍵字聲明類對接口的實現：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;File&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  &lt;span&gt;// 必須顯式聲明&lt;/span&gt;
   &lt;span&gt;@Override&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;它們對類型的判斷也是不同的，在 Go 語言中採用如下語法：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt; w Writer &lt;span&gt;=&lt;/span&gt; File&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
   &lt;span&gt;// 判斷是否為 File 類型，如果是的話 ok 為 true&lt;/span&gt;
   f&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Java 語言中則採用 &lt;code&gt;instanceof&lt;/code&gt; 和強制類型轉換：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Writer&lt;/span&gt; w &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;File&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; w&lt;span&gt;;&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言還採用空接口 &lt;code&gt;interface{}&lt;/code&gt; 來表示任意類型，作為方法入參時則支持任意類型方法的傳入，類似 Java 中的 &lt;code&gt;Object&lt;/code&gt; 類型：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ProcessData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;除此之外，Go 語言在 1.18+ 版本引入了泛型，採用 &lt;code&gt;[T any]&lt;/code&gt; 方括號語法定義類型約束，&lt;code&gt;any&lt;/code&gt; 表示任意類型，如果採用具體類型限制則如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;// Stringer 定義約束：要求類型支持 String() 方法&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; Stringer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; ToString&lt;span&gt;[&lt;/span&gt;T Stringer&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;通過類型的限制便能使用類型安全替代空接口 &lt;code&gt;interface{}&lt;/code&gt;，避免運行時類型斷言：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 舊方案：空接口 + 類型斷言&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OldMax&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 需要手動斷言類型，易出錯&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 新方案：泛型&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; NewMax&lt;span&gt;[&lt;/span&gt;T Ordered&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b T&lt;span&gt;)&lt;/span&gt; T &lt;span&gt;{&lt;/span&gt; &lt;span&gt;/* 直接比較 */&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;泛型還在通用數據結構上有廣泛的應用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Stack&lt;span&gt;[&lt;/span&gt;T any&lt;span&gt;]&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    items &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;T
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;s &lt;span&gt;*&lt;/span&gt;Stack&lt;span&gt;[&lt;/span&gt;T&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;item T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
  &lt;h3&gt;基本數據類型&lt;/h3&gt; 
  &lt;p&gt;Go 的基本數據類型分為 &lt;strong&gt;4 大類&lt;/strong&gt;，相比於 Java 更簡潔且明確：&lt;/p&gt; 
  &lt;table&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;th&gt;類別&lt;/th&gt; 
     &lt;th&gt;具體類型&lt;/th&gt; 
     &lt;th&gt;説明&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;數值型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;Go 的 &lt;code&gt;int&lt;/code&gt; 長度由平台決定（32 位系統為 4 字節，64 位為 8 字節），有符號整數（位數明確，如 &lt;code&gt;int8&lt;/code&gt; 佔 1 字節）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;uintptr&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;無符號整數（&lt;code&gt;uintptr&lt;/code&gt; 用於指針運算）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;浮點數（默認 &lt;code&gt;float64&lt;/code&gt;）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;複數（實部和虛部分別為 &lt;code&gt;float32&lt;/code&gt; 或 &lt;code&gt;float64&lt;/code&gt;，Java 無此類型）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;布爾型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;僅 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;（不可用 0/1 替代）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;不可變的 UTF-8 字符序列&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;派生型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;byte&lt;/code&gt;（=&lt;code&gt;uint8&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;1 字節數據&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;rune&lt;/code&gt;（=&lt;code&gt;int32&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;Go 語言的字符（rune）使用 Unicode 來存儲，而並不是字符本身，如果把 rune 傳遞給 &lt;code&gt;fmt.Println&lt;/code&gt; 方法，會在控制枱看到數字。雖然 Java 語言同樣以 Unicode 保存字符（char），不過它會在控制枱打印字符信息&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;p&gt;Go 和 Java 同樣都是 &lt;strong&gt;靜態類型語言&lt;/strong&gt;，要求在 &lt;strong&gt;編譯期&lt;/strong&gt; 確定所有變量的類型，且類型不可在運行時動態改變。Go 不允許任何隱式類型轉換（如 &lt;code&gt;int32&lt;/code&gt; 到 &lt;code&gt;int64&lt;/code&gt;），但是在 Java 中允許基本類型隱式轉換（如 &lt;code&gt;int&lt;/code&gt; → &lt;code&gt;long&lt;/code&gt;），除此之外，Go 語言會嚴格區分類型別名（如 &lt;code&gt;int&lt;/code&gt; 與 &lt;code&gt;int32&lt;/code&gt; 不兼容）。在 Go 語言中如果需要將不同類型的變量進行計算，需要進行類型轉換：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2.2&lt;/span&gt;
&lt;span&gt;// 如果不類型轉換則不能通過編譯&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
  &lt;h3&gt;「引用類型」&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中，&lt;strong&gt;嚴格來説並沒有「引用類型」這一官方術語&lt;/strong&gt;，但在 Go 語言社區中通常將 &lt;strong&gt;Slice（切片）、Map（映射）、Channel（通道）&lt;/strong&gt; 稱為「引用語義類型」（或簡稱引用類型），因為它們的行為與傳統的引用類型相似，在未被初始化時為 &lt;code&gt;nil&lt;/code&gt;，並無特定的「零值」。除了這三種類型之外，Go 的其他類型（如結構體、數組、基本類型等）都是 &lt;strong&gt;值類型&lt;/strong&gt;。&lt;/p&gt; 
  &lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
  &lt;h4&gt;Slice&lt;/h4&gt; 
  &lt;p&gt;Go 的 &lt;strong&gt;Slice&lt;/strong&gt; 本質上是動態數組的抽象，基於底層數組實現自動擴容。它類似於 Java 中的 &lt;code&gt;ArrayList&lt;/code&gt;，採用 &lt;code&gt;var s []int&lt;/code&gt; 或 &lt;code&gt;s := make([]int, 5)&lt;/code&gt; 聲明，如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;// 初始化到小為 0 的切片&lt;/span&gt;
  s &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 動態追加元素&lt;/span&gt;
  s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 子切片，左閉右開區間 sub = {2, 3}&lt;/span&gt;
  sub &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sub&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 修改子切片值會影響到 s 原數組&lt;/span&gt;
  sub&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;99&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;切片的底層數組並不能增長大小。如果數組沒有足夠的空間來保存新的元素，所有的元素會被拷貝至一個新的更大的數組，並且切片會被更新為引用這個新的數組。但是由於這些場景都發生在 &lt;code&gt;append&lt;/code&gt; 函數內部，所發知道返回的切片和傳入 &lt;code&gt;append&lt;/code&gt; 函數的切片是否為相同的底層數組，所以如果保留了兩個切片，那麼這一點需要注意。&lt;/p&gt; 
  &lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
  &lt;h4&gt;Map&lt;/h4&gt; 
  &lt;p&gt;Go 的 Map 本質上是無序鍵值對集合，基於哈希表實現。它的鍵必須支持 &lt;code&gt;==&lt;/code&gt; 操作（如基本類型、結構體、指針），聲明方式為 &lt;code&gt;m := make(map[string]int)&lt;/code&gt; 或 &lt;code&gt;m := map[string]int{"a": 1}&lt;/code&gt;，它與 Java 中的 &lt;code&gt;HashMap&lt;/code&gt; 類似，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;learnMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;// 安全的讀取&lt;/span&gt;
  value&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
  &lt;h4&gt;Channel&lt;/h4&gt; 
  &lt;p&gt;Go 的 Channel 是用於 &lt;strong&gt;協程（goroutine，Go 語言中的併發任務類似 Java 中的線程）間通信&lt;/strong&gt; 的管道，支持同步或異步數據傳輸。無緩衝區通道會阻塞發送/接收操作，直到另一端就緒。它的聲明方式為 &lt;code&gt;channel := make(chan string)&lt;/code&gt;（無緩衝）或 &lt;code&gt;channel := make(chan string, 3)&lt;/code&gt;（有緩衝，緩衝區大小為 3），創建無緩存區的 channel 示例如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// 創建沒有緩衝區的 channel，如果向其中寫入值後而沒有其他協程從中取值，&lt;/span&gt;
&lt;span&gt;// 再向其寫入值的操作則會被阻塞，也就是説「發送操作會阻塞發送 goroutine，直到另一個 goroutine 在同一 channel 上執行了接收操作」&lt;/span&gt;
&lt;span&gt;// 反之亦然&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// 啓動一個協程很簡單，即 go 關鍵字和要調用的函數&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// &amp;lt;- 標識符指出 channel 表示從協程中取值，輸出一直都會是 adbecf&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// &amp;lt;- 標識符指向 channel 表示向 channel 中發送值&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"b"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"c"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"d"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"e"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"f"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;如果創建有緩衝的 channel，在我們的例子中，那麼就可以實現寫入協程不必等待 main 協程的接收操作了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channelNoBlocked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 表示創建緩衝區大小為 3 的 channel，並且 channel 傳遞的類型為 string&lt;/span&gt;
channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;// 輸出一直都會是 adbecf&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;在 Go 中創建上述三種引用類型的對象時，都使用了 &lt;code&gt;make&lt;/code&gt; 函數，它是專門用於初始化這三種引用類型的，如果不使用該函數，直接聲明（如&lt;code&gt;var m map[string]int&lt;/code&gt;）會得到 &lt;code&gt;nil&lt;/code&gt; 值，而無法直接操作。它與 Java 中的 &lt;code&gt;new&lt;/code&gt; 關鍵字操作有很大的區別，&lt;code&gt;new&lt;/code&gt; 關鍵字會為對象分配內存 &lt;strong&gt;並調用構造函數&lt;/strong&gt;（初始化邏輯在構造函數中），而在 Go 的設計中是沒有構造函數的，Go 語言除了這三種引用類型，均為值類型，直接聲明即可，聲明時便會直接分配內存並初始化為零值。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
  &lt;h3&gt;從失敗中恢復&lt;/h3&gt; 
  &lt;p&gt;在 Go 語言中 &lt;strong&gt;沒有傳統「異常」概念&lt;/strong&gt;，它不依賴 &lt;code&gt;try/catch&lt;/code&gt;，而是通過 &lt;strong&gt;顯式返回錯誤值&lt;/strong&gt; 和 &lt;code&gt;panic/recover&lt;/code&gt; 機制處理。它的錯誤（error）也是普通的數據，能夠作為值傳遞。在多數方法中能看到如下類似的實現：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
data&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 處理錯誤&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;path &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 成功返回 data, nil&lt;/span&gt;
    &lt;span&gt;// 失敗返回 nil, error&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 語言使用 &lt;code&gt;panic&lt;/code&gt; 來處理不可恢復的或程序無法繼續運行的錯誤（如數組越界、空指針），這類似於 Java 語言中的 &lt;code&gt;throw&lt;/code&gt; 異常，它會中斷方法或函數的執行，向上拋出直到遇到 &lt;code&gt;defer&lt;/code&gt; 和 &lt;code&gt;recover()&lt;/code&gt; 函數的聲明捕獲或者程序崩潰：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 初始化失敗時觸發 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;checkDatabaseConnection&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;panic&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Database connection failed!"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 通過 recover 捕獲 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 延遲函數的執行&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 使用 recover() 函數嘗試捕獲異常 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; r &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;recover&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; r &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Recovered from panic:"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; r&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 正常邏輯...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 關鍵字 &lt;strong&gt;必須修飾的函數或方法&lt;/strong&gt;，而且被這個關鍵字修飾的函數或方法 &lt;strong&gt;一旦註冊&lt;/strong&gt; 無論如何都會被執行（類似於 Java 中的 &lt;code&gt;finally&lt;/code&gt;），但如果 &lt;code&gt;defer&lt;/code&gt; 聲明在函數尾部，但函數在運行到該 &lt;code&gt;defer&lt;/code&gt; 語句之前就退出（例如中途 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;panic&lt;/code&gt;），則 &lt;code&gt;defer&lt;/code&gt; &lt;strong&gt;不會註冊，也不會執行&lt;/strong&gt;。&lt;strong&gt;所以該關鍵字在資源被初始化之後應該立即使用，而非像 Java 一樣聲明在方法的尾部&lt;/strong&gt;。而且 &lt;code&gt;defer&lt;/code&gt; 支持聲明多個，但執行的順序是逆序的。&lt;/p&gt; 
  &lt;p&gt;&lt;code&gt;revocer()&lt;/code&gt; 函數與 &lt;code&gt;defer&lt;/code&gt; 關鍵字搭配使用，它會返回函數執行過程中拋出的 &lt;code&gt;panic&lt;/code&gt;（未發生 &lt;code&gt;panic&lt;/code&gt; 時會為 &lt;code&gt;nil&lt;/code&gt;），可以幫助開發者恢復或提供有用的異常信息。&lt;/p&gt; 
  &lt;p&gt;以下是在文件讀取場景 Go 和 Java 語言在語法上的不同：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Go&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    file&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 處理文件內容&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// try-with-resources&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;FileReader&lt;/span&gt; file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FileReader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 處理文件內容&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;err&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Error: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;問：我看到其他編程語言有 &lt;code&gt;exception&lt;/code&gt;。&lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 函數似乎以類似的方式工作。我可以把它們當作 &lt;code&gt;exception&lt;/code&gt; 來使用嗎？&lt;/p&gt; 
   &lt;p&gt;答：Go 語言維護者強烈建議不要這樣做。甚至可以説，語言本身的設計不鼓勵使用 &lt;code&gt;panic&lt;/code&gt;和 &lt;code&gt;recover&lt;/code&gt;。在 2012 年的一次主題會議上，RobPike（Go 的創始人之一）把 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 描述為「故意笨拙」。這意味着，在設計 Go 時，創作者們沒有試圖使 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 被容易或愉快地使用，因此它們會很少使用。這是 Go 設計者對 &lt;code&gt;exception&lt;/code&gt; 的一個主要弱點的回應：它們可以使程序流程更加複雜。相反，Go 開發人員被鼓勵以處理程序其他部分的方式處理錯誤：使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 語句，以及 &lt;code&gt;error&lt;/code&gt; 值。當然，直接在函數中處理錯誤會使函數的代碼變長，但這比根本不處理錯誤要好得多。（Go 的創始人發現，許多使用 &lt;code&gt;exception&lt;/code&gt; 的開發人員只是拋出一個 &lt;code&gt;exception&lt;/code&gt;，之後並沒有正確地處理它。）直接處理錯誤也使錯誤的處理方式一目瞭然，你不必查找程序的其他部分來查看錯誤處理代碼。所以不要在 Go 中尋找等同於 &lt;code&gt;exception&lt;/code&gt; 的東西。這個特性被故意省略了。對於習慣了使用 &lt;code&gt;exception&lt;/code&gt; 的開發人員來説，可能需要一段時間的調整，但 Go 的維護者相信，這最終會使軟件變得更好。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
  &lt;h3&gt;for 和 if&lt;/h3&gt; 
  &lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
  &lt;h4&gt;for&lt;/h4&gt; 
  &lt;p&gt;Go 語言的循環語法只有 &lt;code&gt;for&lt;/code&gt;，沒有 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do-while&lt;/code&gt;，但可實現所有循環模式：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1. 經典三段式（類似 Java 的 for 循環）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2. 類似 while 循環（條件在前）&lt;/span&gt;
sum &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; sum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    sum &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3. 無限循環（省略條件）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Infinite loop"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;// 需手動退出&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 4. 遍歷集合，採用 range 關鍵字，index 和 value 分別表示索引和值&lt;/span&gt;
arr &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; arr &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Index: %d, Value: %d\n"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_17"&gt;&lt;/span&gt; 
  &lt;h4&gt;if&lt;/h4&gt; 
  &lt;p&gt;Go 語言的 &lt;code&gt;if&lt;/code&gt; 語法相比於 Java 支持聲明 + 條件的形式，並且強制要求大括號（即使是單行語句也必須使用 &lt;code&gt;{}&lt;/code&gt;）：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 支持簡短聲明（聲明 + 條件）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// 簡單判斷&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
  &lt;h3&gt;巨人的肩膀&lt;/h3&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;《Head First Go 語言程序設計》&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18691874</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18691874</guid>
      <pubDate>Thu, 18 Sep 2025 06:58:00 GMT</pubDate>
      <author>原創</author>
    </item>
  </channel>
</rss>
