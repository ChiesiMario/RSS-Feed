<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 22 Sep 2025 07:42:12 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Go 多微信号 SDK , gowe 1.2.0 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;gowe,Go 多微信号 SDK&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;感谢&amp;nbsp;&lt;a href="https://gitee.com/xiaochengtech/wechat"&gt;https://gitee.com/xiaochengtech/wechat&lt;/a&gt;&amp;nbsp;提供的基础代码&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;span style="color:#6f42c1"&gt;&lt;span style="color:#6f42c1"&gt;go&lt;/span&gt;&lt;/span&gt; &lt;span style="color:#032f62"&gt;&lt;span style="color:#032f62"&gt;get gitee.com/chunanyong/gowe &lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持境内普通商户和境内服务商 (境外和银行服务商没有条件测试)&lt;/li&gt; 
 &lt;li&gt;全部参数和返回值均使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;struct&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;类型传递&lt;/li&gt; 
 &lt;li&gt;缓存前置，使用项目现有的缓存体系&lt;/li&gt; 
 &lt;li&gt;原生支持多微信号&lt;/li&gt; 
 &lt;li&gt;支持跳板请求微信 API 服务。例如内网服务器没有网络出口权限，可以使用 Nginx 跳板请求微信 API 服务&lt;/li&gt; 
 &lt;li&gt;原生支持集群部署&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;更新内容如下：&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;感谢 @mxiaoxun 实现微信支付 V3&lt;/li&gt; 
 &lt;li&gt;方法加入 ctx 参数&lt;/li&gt; 
 &lt;li&gt;完善文档,注释&lt;/li&gt; 
&lt;/ol&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373710</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373710</guid>
      <pubDate>Mon, 22 Sep 2025 07:18:11 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>谷歌深度学习专家 Dustin Tran 跳槽至 xAI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 宣布从 Google DeepMind 跳槽至马斯克的 xAI，成为公司研发新一代 Grok 模型的重要成员。此消息在他于社交媒体上正式官宣后不久，马斯克便迅速转发，确认了这一人事变动的真实性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="290" src="https://oscimg.oschina.net/oscnet/up-c6df198a66d14d96ac0ff58b9bdfb7a14c0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 是 Gemini 项目的核心开发者，自项目诞生以来，他在多个关键阶段发挥了重要作用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;从 2014 年在加州大学伯克利毕业，取得数学与统计本科学位后，Tran 继续攻读哈佛大学的统计学博士，并最终在哥伦比亚大学获得计算机科学博士学位。他在学术界的贡献也颇为显著，其论文总引用量超过 2.4 万次，曾荣获包括 Google 博士奖学金在内的多个奖项。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在离开 Google DeepMind 的长文中，Tran 深情回顾了自己在该公司的 8 年旅程，他参与了多个重要项目的开发，尤其是 Gemini 的成长过程。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他提到，最初人们对 Google 在 AI 领域的未来持悲观态度，但随着 Gemini 在用户偏好上占据领先地位以及在科研突破上的不断进展，这种看法逐渐改变。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;加入 xAI 的原因，他提到的是这里的巨大算力和数据优势。Tran 对 xAI 的信心满满，认为这是研发前沿级语言模型的必备条件。尤其是 Colossus 2 的强大算力，使他意识到 xAI 在行业中的竞争力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373709</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373709</guid>
      <pubDate>Mon, 22 Sep 2025 07:15:10 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>2TB 新 iPhone 导入 85GB 微信聊天记录提示空间不足；微信员工称代码存在 Bug</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;iPhone 17 系列手机日前已开售，很多拿到新机的用户第一时间就是转移数据。&lt;/p&gt; 
&lt;p&gt;不过有微信用户发现，在向新 iPhone 导入聊天记录时，微信提示设备空间不足，但手机明明还有 1.29TB 可用容量，而导入的聊天记录最多只需 85.16GB 空间。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1354" src="https://static.oschina.net/uploads/space/2025/0922/150216_L3bN_2720166.png" width="744" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e5044091cab39969380f84c9693480a6030.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;对此，微信员工「客村小蒋」&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7876775013%2FQ5Ct4vIjM" target="_blank"&gt;回应称&lt;/a&gt;，微信的代码存在 Bug 导致无法获取系统的真实剩余空间，将很快修复。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我们们有个获取剩余空间的通用工具接口，这个接口内部有个缓存，在获取间隔不超过 5 分钟的时候，不会向系统获取真实的剩余空间，本意是为了避免频繁读取系统接口导致性能问题，但在新手机上，有概率会造成这种情况，因为该逻辑会在开机 5 分钟内返回数据是 0。&lt;strong&gt;开机后用个 5 分钟，接口就能获取到真实的剩余空间，就正常了&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/150356_WJpx_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373705</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373705</guid>
      <pubDate>Mon, 22 Sep 2025 07:05:10 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>从 Java 到 Go：面向对象的巨人与云原生的轻骑兵</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;Go 语言在 2009 年被 Google 推出，在创建之初便明确提出了「少即是多（Less is more）」的设计原则，强调「以工程效率为核心，用极简规则解决复杂问题」。它与 Java 语言生态不同，Go 通过编译为 &lt;strong&gt;单一静态二进制文件实现快速启动和低内存开销&lt;/strong&gt;，&lt;strong&gt;以 25 个关键字强制代码简洁性&lt;/strong&gt;，&lt;strong&gt;用接口组合替代类继承&lt;/strong&gt;，&lt;strong&gt;以显式返回 error 取代异常机制&lt;/strong&gt; 和 &lt;strong&gt;轻量级并发模型（Goroutine/Channel）&lt;/strong&gt; 在 &lt;strong&gt;云原生基础设施领域&lt;/strong&gt; 占据主导地位，它也是 Java 开发者探索云原生技术栈的关键补充。本文将对 Go 语言和 Java 语言在一些重要特性上进行对比，为 Java 开发者在阅读和学习 Go 语言相关技术时提供参考。&lt;/p&gt; 
  &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
  &lt;h3&gt;代码组织的基本单元&lt;/h3&gt; 
  &lt;p&gt;在 Java 中，我们会创建 &lt;code&gt;.java&lt;/code&gt; 文件作为 &lt;strong&gt;类&lt;/strong&gt;（类名与文件名相同），并在该类中定义相关的字段或方法等（OOP），如下定义 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相关的内容便需要声明两个 &lt;code&gt;.java&lt;/code&gt; 文件（&lt;code&gt;User.java&lt;/code&gt;, &lt;code&gt;Address.java&lt;/code&gt;）定义类：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; city&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 语言中，它是通过 &lt;strong&gt;「包」&lt;/strong&gt; 来组织代码的：每个目录下的所有 &lt;code&gt;.go&lt;/code&gt; 文件共享同一个 &lt;strong&gt;包&lt;/strong&gt;，在包内可以定义多个结构体、接口、函数或变量。它并不要求文件名与声明的内容一致，比如创建 &lt;code&gt;User&lt;/code&gt; 「结构体」并不会要求 &lt;code&gt;.go&lt;/code&gt; 文件也命名为 &lt;code&gt;User.go&lt;/code&gt;，而是任何命名都可以（命名为 &lt;code&gt;user.go&lt;/code&gt; 甚至 &lt;code&gt;a.go&lt;/code&gt; 这种无意义的命名），而且同一个包下可以创建多个 &lt;code&gt;.go&lt;/code&gt; 文件。如下为在 &lt;code&gt;user&lt;/code&gt; 包下定义 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相关的内容，它们都被声明在一个 &lt;code&gt;user.go&lt;/code&gt; 文件中：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;type&lt;/span&gt; Address &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   city &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;City&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;city
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;city &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   a&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;相比来说，Java 代码组织的基本单元是类，作为面向对象的语言更侧重对象定义，而 Go 代码组织的基本单元是包，并更侧重功能模块的聚合。&lt;/p&gt; 
  &lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
  &lt;h4&gt;可见性控制&lt;/h4&gt; 
  &lt;p&gt;在 Java 中通过 &lt;code&gt;public/protected/private&lt;/code&gt; 关键字控制成员的可见性，而在 Go 语言中，通过 &lt;strong&gt;首字母大小写&lt;/strong&gt; 控制「包级别的导出」（大写字母开头为 &lt;code&gt;public&lt;/code&gt;），&lt;strong&gt;包的导出成员对其他包可见&lt;/strong&gt;。以 user 包下 &lt;code&gt;User&lt;/code&gt; 类型的定义为例，在 main 包下测试可见性如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;// user package 的全路径&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
   &lt;span&gt;// 不能导入未使用到的包&lt;/span&gt;
   &lt;span&gt;//"math"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; u user&lt;span&gt;.&lt;/span&gt;User
&lt;span&gt;// 在这里是不能访问未导出的字段 name&lt;/span&gt;
&lt;span&gt;// fmt.Println(u.name)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言不能导入未使用到的包，并且函数是基于包的一部分。比如 &lt;code&gt;fmt.Println&lt;/code&gt; 函数，这个函数是在 &lt;code&gt;fmt&lt;/code&gt; 包下的，调用时也是以包名为前缀。&lt;/p&gt; 
  &lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
  &lt;h3&gt;变量的声明&lt;/h3&gt; 
  &lt;p&gt;在 Java 语言中，对变量（静态变量或局部变量）的声明只有一种方式，「采用 = 运算符赋值」显式声明（在 Jdk 10+支持 var 变量声明），如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 语言中，变量声明有两种主要方式：&lt;strong&gt;短声明（&lt;code&gt;:=&lt;/code&gt; 运算符）&lt;/strong&gt; 和 &lt;strong&gt;长声明（&lt;code&gt;var&lt;/code&gt; 声明）&lt;/strong&gt;，它们的适用场景和限制有所不同，以下是详细区分：&lt;/p&gt; 
  &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
  &lt;h4&gt;短声明（&lt;code&gt;:=&lt;/code&gt;）&lt;/h4&gt; 
  &lt;p&gt;只能在函数（包括 &lt;code&gt;main&lt;/code&gt;、自定义函数或方法、&lt;code&gt;if/for&lt;/code&gt; 块等）内部使用，不能在包级别（全局作用域）使用，并且 &lt;strong&gt;声明的局部变量必须被使用&lt;/strong&gt;，不被使用的局部变量不能被声明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 正确&lt;/span&gt;
x &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 未被使用，不能被声明&lt;/span&gt;
&lt;span&gt;// y := 20&lt;/span&gt;
&lt;span&gt;// 不赋值也不能被声明&lt;/span&gt;
&lt;span&gt;// z :=            &lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 错误：不能在包级别使用短声明&lt;/span&gt;
&lt;span&gt;// y := 20          &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;这种短声明直接根据右侧值自动推断变量类型，无需显式指定类型，并且可以一次性声明多个变量，但至少有一个变量是 &lt;strong&gt;新声明的&lt;/strong&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 同时声明 a 和 b&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
&lt;span&gt;// c 是新变量，b 被重新赋值&lt;/span&gt;
c&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"def"&lt;/span&gt;
&lt;span&gt;// 无新变量无法再次对已声明的变量再次声明&lt;/span&gt;
&lt;span&gt;//a, b := 4, "error"&lt;/span&gt;

fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; c&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
  &lt;h4&gt;长声明（&lt;code&gt;var&lt;/code&gt; 声明）&lt;/h4&gt; 
  &lt;p&gt;在全局作用域声明变量必须使用 &lt;code&gt;var&lt;/code&gt;；在需要延迟初始化时也需要采用长声明；显示指定类型也需要使用长声明&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; global &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// a = 0&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;// s = ""&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;// 未被初始化值会默认为「零」值，a 为 0，s 为空字符串&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;函数内部的局部变量，尤其是需要类型推断和简洁代码时优先用短声明；在包级别声明变量，需要显式指定类型或声明变量但不立即赋值（零值初始化）时，使用长声明。&lt;/p&gt; 
  &lt;p&gt;在 Go 语言中还有一点需要注意：&lt;strong&gt;声明变量时，应确保它与任何现有的函数、包、类型或其他变量的名称不同&lt;/strong&gt;。如果在封闭范围内存在同名的东西，变量将对它进行覆盖，也就是说，优先于它，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 这个变量会把导入的 fmt 包覆盖掉&lt;/span&gt;
fmt &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fmt&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;那么我们导入的 &lt;code&gt;fmt&lt;/code&gt; 包在被局部变量覆盖后便不能再被使用了。&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;常量的声明&lt;/h4&gt; 
  &lt;p&gt;Go 语言中对常量的声明采用 &lt;code&gt;const&lt;/code&gt; 关键字，并且在声明时便需要被赋值，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// DaysInWeek const 变量名，类型 = 具体的值&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; DaysInWeek &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;const&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
   fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; DaysInWeek&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 语言中对常量的声明会使用 &lt;code&gt;static final&lt;/code&gt; 引用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Constants&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;DAYS_IN_WEEK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
  &lt;h3&gt;方法/函数的声明&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中，方法的声明遵循 &lt;strong&gt;func (接收器) 方法名 (入参) 返回值&lt;/strong&gt; 的格式，无返回值可以不写（无需 void 声明），通过 &lt;strong&gt;接收器（Receiver）&lt;/strong&gt; 将方法绑定到结构体上，如下为 &lt;code&gt;User&lt;/code&gt; 结构体方法的声明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// Name (u *User) 即为接收器，表示该方法绑定在了 User 类型上&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而「函数」的声明不需要定义接收器，遵循的是 &lt;strong&gt;func 方法名 (入参) 返回值&lt;/strong&gt; 的格式。Go 语言中的函数类似于 Java 语言中的静态方法，以下是声明将整数扩大两倍的函数：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;并且，在 Go 语言中，方法/函数支持多返回值（常用于错误处理），并且如果并不需要全部的返回值，可以用 &lt;code&gt;_&lt;/code&gt; 对返回值进行忽略，因为 Go 语言不允许定义未使用的局部变量，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 忽略掉了第三个返回值&lt;/span&gt;
s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;"1"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;此外，接收器参数和函数的形参支持传入指针，用 &lt;code&gt;*&lt;/code&gt; 符号表示。在 Go 语言中有指针的概念，我们在这里说明一下：Go 语言是 &lt;strong&gt;「值传递」&lt;/strong&gt; 语言，方法/函数的形参（或接收器）如果不标记指针的话，接收的实际上都是 &lt;strong&gt;实参的副本&lt;/strong&gt;，那么 &lt;strong&gt;在方法/函数中的操作并不会对原对象有影响&lt;/strong&gt;。如果想对原对象进行操作，便需要通过指针获取到原对象才行（因为值传递会对原对象和形参对象都划分空间，所以针对较大的对象都推荐使用指针以节省内存空间）。在如下示例中，如果我们将上文中 &lt;code&gt;double&lt;/code&gt; 方法的形参修改为值传递，这样是不能将变量 a 扩大为两倍的，因为它操作的是 a 变量的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要获取 10，但打印 5&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;想要实现对原对象 a 的操作，便需要使用指针操作，将方法的声明中传入指针变量 &lt;code&gt;*int&lt;/code&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;// &amp;amp; 为取址运算符&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要获取 10，实际获取 10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// *int 表示形参 a 传入的是指针&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// *a 表示从地址中获取变量 a 的值&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;再回到 &lt;code&gt;User&lt;/code&gt; 类型的声明中，如果我们将接收器修改成 &lt;code&gt;User&lt;/code&gt;，那么 &lt;code&gt;SetName&lt;/code&gt; 方法是不会对原变量进行修改的，它的修改实际上只针对的是 &lt;code&gt;User&lt;/code&gt; 的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// SetName 指定为值接收器&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;这样 &lt;code&gt;SetName&lt;/code&gt; 方法便不会修改原对象，&lt;code&gt;SetName&lt;/code&gt; 的操作也仅仅对副本生效了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u &lt;span&gt;:=&lt;/span&gt; user&lt;span&gt;.&lt;/span&gt;User&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"abc"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 实际输出为 {}，并没有对原对象的 name 字段完成赋值&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 中并没有指针的概念，Java 中除了基本数据类型是值传递外，其他类型在方法间传递的都是「引用」，对引用对象的修改也是对原对象的修改。&lt;/p&gt; 
  &lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
  &lt;h3&gt;接口&lt;/h3&gt; 
  &lt;p&gt;Go 语言也支持接口的声明，不过相比于 Java 语言它更追求 &lt;strong&gt;「灵活与简洁」&lt;/strong&gt;。Go 的接口实现是「隐式地」，&lt;strong&gt;只要类型实现了接口的所有方法，就自动满足该接口&lt;/strong&gt;，无需显式声明。如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;type&lt;/span&gt; Writer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// File 无需声明实现 Writer，实现了接口所有的方法便自动实现了该接口&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; File &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;f &lt;span&gt;*&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Java 语言则必须通过 &lt;code&gt;implements&lt;/code&gt; 关键字声明类对接口的实现：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;File&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  &lt;span&gt;// 必须显式声明&lt;/span&gt;
   &lt;span&gt;@Override&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;它们对类型的判断也是不同的，在 Go 语言中采用如下语法：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt; w Writer &lt;span&gt;=&lt;/span&gt; File&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
   &lt;span&gt;// 判断是否为 File 类型，如果是的话 ok 为 true&lt;/span&gt;
   f&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Java 语言中则采用 &lt;code&gt;instanceof&lt;/code&gt; 和强制类型转换：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Writer&lt;/span&gt; w &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;File&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; w&lt;span&gt;;&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言还采用空接口 &lt;code&gt;interface{}&lt;/code&gt; 来表示任意类型，作为方法入参时则支持任意类型方法的传入，类似 Java 中的 &lt;code&gt;Object&lt;/code&gt; 类型：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ProcessData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;除此之外，Go 语言在 1.18+ 版本引入了泛型，采用 &lt;code&gt;[T any]&lt;/code&gt; 方括号语法定义类型约束，&lt;code&gt;any&lt;/code&gt; 表示任意类型，如果采用具体类型限制则如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;// Stringer 定义约束：要求类型支持 String() 方法&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; Stringer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; ToString&lt;span&gt;[&lt;/span&gt;T Stringer&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;通过类型的限制便能使用类型安全替代空接口 &lt;code&gt;interface{}&lt;/code&gt;，避免运行时类型断言：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 旧方案：空接口 + 类型断言&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OldMax&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 需要手动断言类型，易出错&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 新方案：泛型&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; NewMax&lt;span&gt;[&lt;/span&gt;T Ordered&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b T&lt;span&gt;)&lt;/span&gt; T &lt;span&gt;{&lt;/span&gt; &lt;span&gt;/* 直接比较 */&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;泛型还在通用数据结构上有广泛的应用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Stack&lt;span&gt;[&lt;/span&gt;T any&lt;span&gt;]&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    items &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;T
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;s &lt;span&gt;*&lt;/span&gt;Stack&lt;span&gt;[&lt;/span&gt;T&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;item T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
  &lt;h3&gt;基本数据类型&lt;/h3&gt; 
  &lt;p&gt;Go 的基本数据类型分为 &lt;strong&gt;4 大类&lt;/strong&gt;，相比于 Java 更简洁且明确：&lt;/p&gt; 
  &lt;table&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;th&gt;类别&lt;/th&gt; 
     &lt;th&gt;具体类型&lt;/th&gt; 
     &lt;th&gt;说明&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;数值型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;Go 的 &lt;code&gt;int&lt;/code&gt; 长度由平台决定（32 位系统为 4 字节，64 位为 8 字节），有符号整数（位数明确，如 &lt;code&gt;int8&lt;/code&gt; 占 1 字节）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;uintptr&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;无符号整数（&lt;code&gt;uintptr&lt;/code&gt; 用于指针运算）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;浮点数（默认 &lt;code&gt;float64&lt;/code&gt;）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;复数（实部和虚部分别为 &lt;code&gt;float32&lt;/code&gt; 或 &lt;code&gt;float64&lt;/code&gt;，Java 无此类型）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;布尔型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;仅 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;（不可用 0/1 替代）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;不可变的 UTF-8 字符序列&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;派生型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;byte&lt;/code&gt;（=&lt;code&gt;uint8&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;1 字节数据&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;rune&lt;/code&gt;（=&lt;code&gt;int32&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;Go 语言的字符（rune）使用 Unicode 来存储，而并不是字符本身，如果把 rune 传递给 &lt;code&gt;fmt.Println&lt;/code&gt; 方法，会在控制枱看到数字。虽然 Java 语言同样以 Unicode 保存字符（char），不过它会在控制枱打印字符信息&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;p&gt;Go 和 Java 同样都是 &lt;strong&gt;静态类型语言&lt;/strong&gt;，要求在 &lt;strong&gt;编译期&lt;/strong&gt; 确定所有变量的类型，且类型不可在运行时动态改变。Go 不允许任何隐式类型转换（如 &lt;code&gt;int32&lt;/code&gt; 到 &lt;code&gt;int64&lt;/code&gt;），但是在 Java 中允许基本类型隐式转换（如 &lt;code&gt;int&lt;/code&gt; → &lt;code&gt;long&lt;/code&gt;），除此之外，Go 语言会严格区分类型别名（如 &lt;code&gt;int&lt;/code&gt; 与 &lt;code&gt;int32&lt;/code&gt; 不兼容）。在 Go 语言中如果需要将不同类型的变量进行计算，需要进行类型转换：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2.2&lt;/span&gt;
&lt;span&gt;// 如果不类型转换则不能通过编译&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
  &lt;h3&gt;「引用类型」&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中，&lt;strong&gt;严格来说并没有「引用类型」这一官方术语&lt;/strong&gt;，但在 Go 语言社区中通常将 &lt;strong&gt;Slice（切片）、Map（映射）、Channel（通道）&lt;/strong&gt; 称为「引用语义类型」（或简称引用类型），因为它们的行为与传统的引用类型相似，在未被初始化时为 &lt;code&gt;nil&lt;/code&gt;，并无特定的「零值」。除了这三种类型之外，Go 的其他类型（如结构体、数组、基本类型等）都是 &lt;strong&gt;值类型&lt;/strong&gt;。&lt;/p&gt; 
  &lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
  &lt;h4&gt;Slice&lt;/h4&gt; 
  &lt;p&gt;Go 的 &lt;strong&gt;Slice&lt;/strong&gt; 本质上是动态数组的抽象，基于底层数组实现自动扩容。它类似于 Java 中的 &lt;code&gt;ArrayList&lt;/code&gt;，采用 &lt;code&gt;var s []int&lt;/code&gt; 或 &lt;code&gt;s := make([]int, 5)&lt;/code&gt; 声明，如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;// 初始化到小为 0 的切片&lt;/span&gt;
  s &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 动态追加元素&lt;/span&gt;
  s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 子切片，左闭右开区间 sub = {2, 3}&lt;/span&gt;
  sub &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sub&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 修改子切片值会影响到 s 原数组&lt;/span&gt;
  sub&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;99&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;切片的底层数组并不能增长大小。如果数组没有足够的空间来保存新的元素，所有的元素会被拷贝至一个新的更大的数组，并且切片会被更新为引用这个新的数组。但是由于这些场景都发生在 &lt;code&gt;append&lt;/code&gt; 函数内部，所发知道返回的切片和传入 &lt;code&gt;append&lt;/code&gt; 函数的切片是否为相同的底层数组，所以如果保留了两个切片，那么这一点需要注意。&lt;/p&gt; 
  &lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
  &lt;h4&gt;Map&lt;/h4&gt; 
  &lt;p&gt;Go 的 Map 本质上是无序键值对集合，基于哈希表实现。它的键必须支持 &lt;code&gt;==&lt;/code&gt; 操作（如基本类型、结构体、指针），声明方式为 &lt;code&gt;m := make(map[string]int)&lt;/code&gt; 或 &lt;code&gt;m := map[string]int{"a": 1}&lt;/code&gt;，它与 Java 中的 &lt;code&gt;HashMap&lt;/code&gt; 类似，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;learnMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;// 安全的读取&lt;/span&gt;
  value&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
  &lt;h4&gt;Channel&lt;/h4&gt; 
  &lt;p&gt;Go 的 Channel 是用于 &lt;strong&gt;协程（goroutine，Go 语言中的并发任务类似 Java 中的线程）间通信&lt;/strong&gt; 的管道，支持同步或异步数据传输。无缓冲区通道会阻塞发送/接收操作，直到另一端就绪。它的声明方式为 &lt;code&gt;channel := make(chan string)&lt;/code&gt;（无缓冲）或 &lt;code&gt;channel := make(chan string, 3)&lt;/code&gt;（有缓冲，缓冲区大小为 3），创建无缓存区的 channel 示例如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// 创建没有缓冲区的 channel，如果向其中写入值后而没有其他协程从中取值，&lt;/span&gt;
&lt;span&gt;// 再向其写入值的操作则会被阻塞，也就是说「发送操作会阻塞发送 goroutine，直到另一个 goroutine 在同一 channel 上执行了接收操作」&lt;/span&gt;
&lt;span&gt;// 反之亦然&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// 启动一个协程很简单，即 go 关键字和要调用的函数&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// &amp;lt;- 标识符指出 channel 表示从协程中取值，输出一直都会是 adbecf&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// &amp;lt;- 标识符指向 channel 表示向 channel 中发送值&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"b"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"c"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"d"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"e"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"f"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;如果创建有缓冲的 channel，在我们的例子中，那么就可以实现写入协程不必等待 main 协程的接收操作了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channelNoBlocked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 表示创建缓冲区大小为 3 的 channel，并且 channel 传递的类型为 string&lt;/span&gt;
channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;// 输出一直都会是 adbecf&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;在 Go 中创建上述三种引用类型的对象时，都使用了 &lt;code&gt;make&lt;/code&gt; 函数，它是专门用于初始化这三种引用类型的，如果不使用该函数，直接声明（如&lt;code&gt;var m map[string]int&lt;/code&gt;）会得到 &lt;code&gt;nil&lt;/code&gt; 值，而无法直接操作。它与 Java 中的 &lt;code&gt;new&lt;/code&gt; 关键字操作有很大的区别，&lt;code&gt;new&lt;/code&gt; 关键字会为对象分配内存 &lt;strong&gt;并调用构造函数&lt;/strong&gt;（初始化逻辑在构造函数中），而在 Go 的设计中是没有构造函数的，Go 语言除了这三种引用类型，均为值类型，直接声明即可，声明时便会直接分配内存并初始化为零值。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
  &lt;h3&gt;从失败中恢复&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中 &lt;strong&gt;没有传统「异常」概念&lt;/strong&gt;，它不依赖 &lt;code&gt;try/catch&lt;/code&gt;，而是通过 &lt;strong&gt;显式返回错误值&lt;/strong&gt; 和 &lt;code&gt;panic/recover&lt;/code&gt; 机制处理。它的错误（error）也是普通的数据，能够作为值传递。在多数方法中能看到如下类似的实现：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
data&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 处理错误&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;path &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 成功返回 data, nil&lt;/span&gt;
    &lt;span&gt;// 失败返回 nil, error&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言使用 &lt;code&gt;panic&lt;/code&gt; 来处理不可恢复的或程序无法继续运行的错误（如数组越界、空指针），这类似于 Java 语言中的 &lt;code&gt;throw&lt;/code&gt; 异常，它会中断方法或函数的执行，向上抛出直到遇到 &lt;code&gt;defer&lt;/code&gt; 和 &lt;code&gt;recover()&lt;/code&gt; 函数的声明捕获或者程序崩溃：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 初始化失败时触发 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;checkDatabaseConnection&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;panic&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Database connection failed!"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 通过 recover 捕获 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 延迟函数的执行&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 使用 recover() 函数尝试捕获异常 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; r &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;recover&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; r &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Recovered from panic:"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; r&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 正常逻辑...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 关键字 &lt;strong&gt;必须修饰的函数或方法&lt;/strong&gt;，而且被这个关键字修饰的函数或方法 &lt;strong&gt;一旦注册&lt;/strong&gt; 无论如何都会被执行（类似于 Java 中的 &lt;code&gt;finally&lt;/code&gt;），但如果 &lt;code&gt;defer&lt;/code&gt; 声明在函数尾部，但函数在运行到该 &lt;code&gt;defer&lt;/code&gt; 语句之前就退出（例如中途 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;panic&lt;/code&gt;），则 &lt;code&gt;defer&lt;/code&gt; &lt;strong&gt;不会注册，也不会执行&lt;/strong&gt;。&lt;strong&gt;所以该关键字在资源被初始化之后应该立即使用，而非像 Java 一样声明在方法的尾部&lt;/strong&gt;。而且 &lt;code&gt;defer&lt;/code&gt; 支持声明多个，但执行的顺序是逆序的。&lt;/p&gt; 
  &lt;p&gt;&lt;code&gt;revocer()&lt;/code&gt; 函数与 &lt;code&gt;defer&lt;/code&gt; 关键字搭配使用，它会返回函数执行过程中抛出的 &lt;code&gt;panic&lt;/code&gt;（未发生 &lt;code&gt;panic&lt;/code&gt; 时会为 &lt;code&gt;nil&lt;/code&gt;），可以帮助开发者恢复或提供有用的异常信息。&lt;/p&gt; 
  &lt;p&gt;以下是在文件读取场景 Go 和 Java 语言在语法上的不同：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Go&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    file&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 处理文件内容&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// try-with-resources&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;FileReader&lt;/span&gt; file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FileReader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 处理文件内容&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;err&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Error: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;问：我看到其他编程语言有 &lt;code&gt;exception&lt;/code&gt;。&lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 函数似乎以类似的方式工作。我可以把它们当作 &lt;code&gt;exception&lt;/code&gt; 来使用吗？&lt;/p&gt; 
   &lt;p&gt;答：Go 语言维护者强烈建议不要这样做。甚至可以说，语言本身的设计不鼓励使用 &lt;code&gt;panic&lt;/code&gt;和 &lt;code&gt;recover&lt;/code&gt;。在 2012 年的一次主题会议上，RobPike（Go 的创始人之一）把 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 描述为「故意笨拙」。这意味着，在设计 Go 时，创作者们没有试图使 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 被容易或愉快地使用，因此它们会很少使用。这是 Go 设计者对 &lt;code&gt;exception&lt;/code&gt; 的一个主要弱点的回应：它们可以使程序流程更加复杂。相反，Go 开发人员被鼓励以处理程序其他部分的方式处理错误：使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 语句，以及 &lt;code&gt;error&lt;/code&gt; 值。当然，直接在函数中处理错误会使函数的代码变长，但这比根本不处理错误要好得多。（Go 的创始人发现，许多使用 &lt;code&gt;exception&lt;/code&gt; 的开发人员只是抛出一个 &lt;code&gt;exception&lt;/code&gt;，之后并没有正确地处理它。）直接处理错误也使错误的处理方式一目了然，你不必查找程序的其他部分来查看错误处理代码。所以不要在 Go 中寻找等同于 &lt;code&gt;exception&lt;/code&gt; 的东西。这个特性被故意省略了。对于习惯了使用 &lt;code&gt;exception&lt;/code&gt; 的开发人员来说，可能需要一段时间的调整，但 Go 的维护者相信，这最终会使软件变得更好。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
  &lt;h3&gt;for 和 if&lt;/h3&gt; 
  &lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
  &lt;h4&gt;for&lt;/h4&gt; 
  &lt;p&gt;Go 语言的循环语法只有 &lt;code&gt;for&lt;/code&gt;，没有 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do-while&lt;/code&gt;，但可实现所有循环模式：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1. 经典三段式（类似 Java 的 for 循环）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2. 类似 while 循环（条件在前）&lt;/span&gt;
sum &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; sum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    sum &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3. 无限循环（省略条件）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Infinite loop"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;// 需手动退出&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 4. 遍历集合，采用 range 关键字，index 和 value 分别表示索引和值&lt;/span&gt;
arr &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; arr &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Index: %d, Value: %d\n"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_17"&gt;&lt;/span&gt; 
  &lt;h4&gt;if&lt;/h4&gt; 
  &lt;p&gt;Go 语言的 &lt;code&gt;if&lt;/code&gt; 语法相比于 Java 支持声明 + 条件的形式，并且强制要求大括号（即使是单行语句也必须使用 &lt;code&gt;{}&lt;/code&gt;）：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 支持简短声明（声明 + 条件）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// 简单判断&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
  &lt;h3&gt;巨人的肩膀&lt;/h3&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;《Head First Go 语言程序设计》&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18691874</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18691874</guid>
      <pubDate>Mon, 22 Sep 2025 06:58:10 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>华为将投入 150 亿元发展软件生态</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在日前举行的 HUAWEI CONNECT 2025 大会上，华为&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0QXbEjdebh0-U_HCk9-w3A" target="_blank"&gt;宣布&lt;/a&gt;搭载鸿蒙 5 的终端设备数量已突破 1700 万台，开源鸿蒙兼容软硬件产品超过 1300 款。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143528_t8rk_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="216" src="https://static.oschina.net/uploads/space/2025/0922/143332_rUYk_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;华为同时公布，将投入 150 亿元用于生态发展，并为开源社区提供 1500 PFLOPS 算力支持及 15000 人的开发团队资源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="213" src="https://static.oschina.net/uploads/space/2025/0922/143401_RhmV_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;华为提出‘四个坚定’，即坚定开源开放、坚定发展人才、坚定全球合作、坚定战略投入：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先，坚定开源开放&lt;/strong&gt;。华为既是开源的使用者、受益者，也是坚定的支持者与践行者，坚持将长期积累的软件能力持续回馈开源社区。华为是全球 20 多个开源基金会的创始成员或顶级成员，并在 300 多个上游社区中成为核心代码贡献者。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鸿蒙智联万物，成为 AI 原生的全场景终端操作系统&lt;/strong&gt;。OpenHarmony 开源 5 年，汇聚了 9200 多名社区贡献者，贡献了 1.3 亿行代码，孵化了 1100 多个三方组件库，支撑手机、平板、PC 等复杂设备的应用开发。当前，已有 1300 多软硬件产品通过兼容性测评，并在金融、交通、能源、航天等行业落地，有 60 多款、1700 多万台华为终端设备搭载了基于 OpenHarmony 开发的鸿蒙 5。鸿蒙版应用全面启动以来，将碰一碰、扫码、安全访问、意图框架等系统创新能力不断开放出来，超过 9000 个应用基于这些能力开发出了 70 多种体验创新。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鲲鹏升腾全面开源开放，为世界提供算力底座&lt;/strong&gt;。在通用计算领域，华为相继开源了鲲鹏全系列软件，包括 openEuler 操作系统、openGauss 数据库、openUBMC 固件管理、openFuyao 算力集群软件、BoostKit 鲲鹏应用使能套件，助力开发者灵活自主地应用创新。未来，华为将围绕通智融合向 openEuler 贡献更多的组件和能力。在 AI 领域，升腾基础软件全面开源开放，今年新增开源 CANN、Mind 系列应用使能套件、openPangu 等，支持用户深度挖掘升腾潜力，加快自主创新。同时，升腾优先支持业界主流的开源社区和开源项目，升腾新特性、组件和开发计划等都将在 PyTorch、vLLM、VeRL、SGLang、Triton 等开源社区上首发。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;华为云做智能世界「黑土地」，加速千行万业智能化&lt;/strong&gt;。过去一年，华为云开发者新增 200 万，累计达 850 万。开发者空间迎来全面升级，带来更多免费的使用时长、函数调用和 Token 资源，让开发者「每人一台云主机」。开发者可直接从代码仓拉起云开发环境，使用开发者自己偏好的 IDE 和工具，从本地直接使用鲲鹏和升腾算力，实现代码实时存储和调试。&lt;/p&gt; 
&lt;p&gt;此外，在本次大会上华为还一并宣布正式启动「天工计划」，未来将投入 10 亿元人民币支持鸿蒙 AI 生态创新。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143548_9AUB_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方表示，此举旨在进一步完善鸿蒙生态体系，推动更多合作伙伴加入，共同加速软硬件适配与创新应用落地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373695</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373695</guid>
      <pubDate>Fri, 19 Sep 2025 06:37:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>中科院推出类脑大模型 SpikingBrain：以 2% 数据实现百倍速度突破</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;中国科学院自动化研究所的李国齐与徐波团队联合发布了全球&lt;span&gt;首款&lt;/span&gt;大规模类脑脉冲大模型 —— SpikingBrain1.0。该模型在处理长文本时展现出惊人的速度，能够以超过当前主流 Transformer 模型 100 多倍的速度处理 400 万 token 的超长文本，且仅需 2% 的数据量。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="471" src="https://oscimg.oschina.net/oscnet/up-431a043f8506ca3fef9a4fa56c443b1c610.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;当前主流的大语言模型，如 GPT 系列，普遍基于 Transformer 架构。尽管 Transformer 以其强大的自注意力机制而闻名，但其计算复杂度却是一个致命的短板。在文本长度增加时，计算量呈现出平方级别的暴涨，使得长文本的处理变得异常耗时和耗能。这一现象让 AI 在分析长篇小说或法律文书时显得力不从心。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了寻求新的解决方案，研究团队将目光投向了自然界最为高效的智能系统 —— 人脑。人脑由千亿神经元构成，功耗却仅为 20 瓦。团队提出了 「基于内生复杂性」 的理念，旨在提升模型内部单元的效率与智能。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;SpikingBrain 模型通过全新的架构模拟了人脑神经元的工作方式，分为两个版本：SpikingBrain-7B（70 亿参数）和 SpikingBrain-76B(760 亿参数)。首先，该模型抛弃了传统 Transformer 的二次方复杂度自注意力机制，采用了 「混合线性注意力架构」，将计算复杂度降至线性 (O (n))，显著提高了处理长文本的效率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;其次，SpikingBrain 引入了 「自适应阈值脉冲神经元」，使神经元的激活与否取决于接收到的信号强度。通过动态调整阈值，模型确保神经元在高效能状态下工作，这种事件驱动的机制显著节省了能耗，计算稀疏度高达 69.15%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，团队还开发了一套高效的模型转换技术，能够将现有的 Transformer 模型直接转化为 SpikingBrain 架构，降低了训练成本。所有技术细节和代码已在 GitHub 及魔搭平台上开源，供全球研究人员使用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373694</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373694</guid>
      <pubDate>Fri, 19 Sep 2025 06:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>捷豹路虎遭黑客攻击致全球工厂停工，英国政府出手援助</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Fbusiness%2Fretail-consumer%2Fuk-working-closely-with-jaguar-land-rover-after-cyber-incident-2025-09-19%2F" target="_blank"&gt;据报道&lt;/a&gt;，针对捷豹路虎遭遇网络攻击，导致全球工厂停产一事。英国汽车制造商与贸易商协会声明证实，政府正在协助捷豹路虎恢复内部系统，同时派遣网络专家评估「对供应链的影响」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141536_gYmO_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Unite 工会周三警告，供应链已濒临崩溃。英国汽车制造商与贸易商协会声明写道：「近期网络攻击对捷豹路虎及整个汽车供应链造成严重影响。政府及网络专家正在与公司密切合作，支持生产恢复，并评估供应链可能受到的冲击。」&lt;/p&gt; 
&lt;p&gt;此前报道显示，捷豹路虎在英国受到网络攻击，此次攻击迫使捷豹路虎关闭了其信息技术网络，导致全球范围内生产线陷入瘫痪，捷豹路虎全球 33000 名员工被告知生产线受到影响。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141108_8gv3_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;公司称已通知同事、供应商和合作伙伴，将目前的生产暂停时间延长至 2025 年 9 月 24 日。商业经济学教授 David Bailey 上周告诉 Autocar，此次事件可能让捷豹路虎每天损失达 500 万英镑。&lt;/p&gt; 
&lt;p&gt;&lt;img height="468" src="https://static.oschina.net/uploads/space/2025/0922/141125_TiMr_2720166.png" width="1024" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141202_bhBb_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;对于此次网络攻击，一个自称 「Scattered Lapsus$ Hunters」 的黑客组织声称对这起网络攻击事件负责，但并未解释实施网络攻击的诉求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373689</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373689</guid>
      <pubDate>Fri, 19 Sep 2025 06:12:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Valkey：对开源的投资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Valkey 于一年前成立，旨在为开源社区保留高性能的键值存储，避免被厂商锁定或受限于限制性许可。项目得到了 AWS、Google Cloud、Ericsson、Oracle、Alibaba、Huawei、Tencent、Percona、Aiven、Heroku、Verizon、Chainguard 和 Canonical 等贡献者的支持，展示了开源「免费」的背后，依赖于时间、人才和持续的资金投入。&lt;/p&gt; 
&lt;p&gt;&lt;img height="294" src="https://static.oschina.net/uploads/space/2025/0922/140921_eZvD_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;由开发者打造，Linux 基金会支持&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;Valkey 于 2024 年 3 月 28 日诞生，已成为支持缓存、消息队列等多种工作负载的开源高性能键值数据库，也可用作主数据库。它由 2000 年成立的中立组织 Linux 基金会支持，后者帮助开发者和技术人员管理、扩展开源项目。Valkey 采用开放治理模式，专注于扩大社区贡献和用户采纳。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;一年回顾：成长与动力&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;仅用一年时间，项目发布了两次重要版本，企业参与者从 22 家增至 47 家，正在定义、创新并推进路线图，用户规模不断扩大。社区积极拥抱 Valkey，坚定致力于持续改进，惠及所有最终用户。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 新功能与应用场景&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;用 JSON 和 Bloom 过滤器解决实际问题&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的两种数据类型——JSON 和 Bloom 过滤器，极大扩展了开发者在分布式系统中对速度和数据结构的需求。它们简化了应用逻辑，提升了边缘数据处理效率。Valkey 联合维护者 Madelyn Olson 表示：「添加 JSON 和 Bloom 过滤器，是为了给开发者提供实用工具，解决分布式系统中的真实问题。」&lt;/p&gt; 
&lt;p&gt;JSON 支持让开发者能直接处理丰富且结构化的数据，无需依赖自定义序列化或额外中间件。Olson 解释：「JSON 让你能直接在 Valkey 中操作复杂数据，简化开发，减少胶水代码。」&lt;/p&gt; 
&lt;p&gt;Bloom 过滤器则提供了一种紧凑且快速的存在性检测方式。Olson 补充：「在需要快速且节省内存的存在性检测时，比如防范欺诈或避免高流量服务中不必要的后端调用，Bloom 过滤器非常理想。」&lt;/p&gt; 
&lt;p&gt;Olson 还说：「我很期待看到用户用这些新数据类型解决什么问题。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Valkey Search：为 AI 工作负载提供速度与规模&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Google 贡献了 Valkey Search 模块，支持向量相似度搜索。它响应速度快，延迟单毫秒级，能处理数十亿向量，并保持 99% 以上召回率。&lt;/p&gt; 
&lt;p&gt;开发者可执行近似最近邻（ANN，基于 HNSW）和精确最近邻（KNN）搜索，支持使用 Hash 或 Valkey-JSON 类型建立索引。尽管当前重点为向量搜索，未来计划扩展成支持全文检索和更多索引选项的搜索引擎。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;性能、可靠性与安全性&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;过去一年，Ericsson、Oracle、Percona 等公司贡献者致力于让 Valkey 更快、更安全、更适合企业级生产环境。以下改进体现了 Valkey 在满足大规模生产需求同时，兼顾用户体验的演进。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;多线程改进&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;近期系统内部更新优化了多线程工作处理，减少锁竞争，更好利用多核处理器。在高并发场景下显著提升吞吐量，使项目更适合大规模生产。Ericsson 作为核心贡献者，已感受到性能提升带来的实际价值。&lt;/p&gt; 
&lt;p&gt;Ericsson 软件技术工程师兼 Valkey 联合维护者 Viktor Söderqvist 指出，核心效率是 Valkey 越来越适合生产的关键。「最近的哈希表重设计，结合 SIMD 技术，以及多线程和批量预取内存技术的持续改进，极大提升了 CPU 和内存的存储效率与速度。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;SIMD 加速哈希表重设计&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;核心哈希表重构利用 SIMD 指令，实现并行处理多个操作，使键查找更高效。这些底层优化提升了延迟敏感环境的响应速度。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;批量内存预取&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的批量内存预取功能提前加载数据，减少缓存未命中，保证繁忙或顺序访问场景下性能更稳定流畅。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;LDAP 集成&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;LDAP 集成实现了集中身份认证和访问控制，简化了 Valkey 在企业已有身份系统中的部署。这解决了安全和合规要求较高组织的常见障碍。&lt;/p&gt; 
&lt;p&gt;Percona 联合创始人 Vadim Tkachenko 表示：「很多客户已经依赖 LDAP 管理基础设施访问，把它引入 Valkey 很自然。它消除了摩擦，支持审计、基于组的权限，并兼容现有系统。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Rust 模块&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Oracle 贡献了基于 Rust 的模块 SDK，旨在提升底层扩展的安全性和性能。Rust 提供了强大的内存与并发保障，有助于打造更安全、易维护的系统集成，特别适合生产环境高负载场景。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;开源成功背后的真正投资&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;对开源的投资和雇佣贡献者，体现了技术创新的关键：无论是大企业还是小型团队，都必须协作共赢。这意味着要投入推动项目发展的资源——开源的「免费」背后，是开发者、文档编写者、治理团队和社区的共同努力。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 最新动态&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;2025 年 8 月 15 日，Valkey 发布了 9.0 版本的第一个候选版本。该测试版展示了原子槽迁移、哈希字段过期、集群模式下编号数据库等新功能，幷包含大量性能优化和漏洞修复。后续将发布更多候选版本，计划于 2025 年秋初正式发布 9.0。&lt;/p&gt; 
&lt;p&gt;更多详情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvalkey.io%2Fblog%2Fvalkey-investment-in-open-source%2F" target="_blank"&gt;查看官方博客&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373688</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373688</guid>
      <pubDate>Fri, 19 Sep 2025 06:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>浙大联合华为发布开源安全大模型 DeepSeek-R1-Safe</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;浙江大学网络空间安全学院与华为公司合作，共同发布了 DeepSeek R1 模型的安全加强版——DeepSeek-R1-Safe。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-bb459dcf773ec50364dfe5aa3e9b53a0943.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，该模型利用华为的升腾芯片和 MindSpeedLLM 等框架进行开发，训练流程如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;训练数据生成&lt;/strong&gt;：构建安全、合规的数据集&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全监督训练&lt;/strong&gt;：在训练过程中引入安全约束&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全强化学习&lt;/strong&gt;：通过 RLHF 等方法优化模型行为&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模型性能评测&lt;/strong&gt;：对安全性能和通用性能进行全面评估&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;其核心优势在于显著提升安全防护能力的同时，有效保持模型的通用性能，从而在安全性与可用性之间实现了理想的平衡。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2a6f34121c98b025fdf451a09d010b3fdc4.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/ZJUAISafety/DeepSeek-R1-Safe&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373666</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373666</guid>
      <pubDate>Fri, 19 Sep 2025 03:46:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>美团开源推理大模型 LongCat-Flash-Thinking</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美团发布了一款基于混合专家架构的大型推理模型 LongCat-Flash-Thinking，总参数量达 5600 亿，根据上下文需求动态激活 186 亿至 313 亿参数，平均激活约 270 亿参数。&lt;/p&gt; 
&lt;p&gt;该模型在逻辑、数学、编程及 Agent 任务上表现出色，并声称在 AIME25 等任务上，使用原生工具可以减少 64.5% 的 token 消耗来达到顶级准确率。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-da818838364ff7d525f309404afcf2b2e39.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FMeituan_LongCat%2Fstatus%2F1969823529760874935" target="_blank"&gt;根据官方公布的评测结果&lt;/a&gt;，LongCat-Flash-Thinking 在多个基准测试中与其他主流模型进行了对比，在数学推理（如 MATH500, AIME25）、通用推理（如 GPQA-Diamond）、代码生成（如 LiveCodeBench, OJBench）、Agent 工具使用（如 SWE-Bench, τ²-Bench）以及形式化定理证明（如 MiniF2F-Test）等取得了接近领先模型的水平。&lt;/p&gt; 
&lt;p&gt;LongCat-Flash-Thinking 的模型权重已根据 MIT 许可证开源。官方提供了详细的聊天模板，模型也已上线官方聊天网站。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://huggingface.co/meituan-longcat/LongCat-Flash-Thinking&lt;br&gt; https://longcat.chat/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373661</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373661</guid>
      <pubDate>Fri, 19 Sep 2025 03:35:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>甲骨文与 Meta 洽谈价值 200 亿美元的云计算协议</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;甲骨文（Oracle）目前正在与 Meta 平台进行&lt;span&gt;高级&lt;/span&gt;别的谈判，商讨一项价值约 200 亿美元的多年度云计算协议。这项协议将使甲骨文能够为 Meta 提供大量的计算能力，以支持其人工智能模型的训练和部署，从而进一步补充 Meta 现有的云基础设施投资。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="213" src="https://static.oschina.net/uploads/space/2025/0922/112835_c6hS_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这一潜在的合作伙伴关系标志着科技行业在人工智能基础设施方面的快速变化。随着人工智能开发的加速，科技巨头们纷纷争相锁定大规模的计算资源。Meta 尤其在积极扩展其人工智能能力，尤其是其 Llama 大型语言模型，力求在云服务供应商的选择上实现多元化。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;甲骨文的战略转变也引人注目。曾经被视为数据库软件的&lt;span&gt;领导者&lt;/span&gt;，甲骨文现如今已迅速崛起为人工智能云基础设施的重要玩家。近期，甲骨文的云基础设施（OCI）业务实现了 55% 的收入增长，且刚刚与 OpenAI 签署了一份价值 3000 亿美元的多年度合同，这也显示了其在人工智能领域的强劲实力。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得注意的是，这一消息推动甲骨文的股票在单日内上涨了 4%，并促使其 2025 年的股价上涨超过 80%。此外，甲骨文的剩余业绩承诺（一个未来收入的关键指标）在&lt;span&gt;最新&lt;/span&gt;一季度同比大幅增长 359%，达到 4550 亿美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前，甲骨文与 Meta 的谈判尚未最终敲定，协议的总价值可能在签署前发生变化。甲骨文和 Meta 都尚未对此消息进行正式评论。此次谈判不仅突显了云计算行业的市场动态，还显示出传统企业软件公司与超大规模云服务提供商在人工智能基础设施领域的竞争加剧。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了满足日益增长的需求，甲骨文正在加大投资计划，预计今年资本支出将增加 65%，达到 350 亿美元，主要用于新数据中心的建设。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;行业观察人士对此高度关注：如果最终达成协议，甲骨文将进一步巩固其作为人工智能领域基础设施合作伙伴的地位。而对于 Meta 而言，这也是确保其在全球人工智能竞争中拥有足够计算能力的重要策略。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373657</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373657</guid>
      <pubDate>Fri, 19 Sep 2025 03:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AOMedia 宣布在十周年之际推出下一代视频编码 AV2</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Alliance for Open Media（AOMedia）&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F-nT35LyQcNdDNCnrvtJ1yQ" target="_blank"&gt;宣布&lt;/a&gt;即将推出开放视频编码的下一代技术：AV2，计划于年底发布。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告称，AV2 不仅是 AV1 的升级版，更是 AOMedia 未来技术体系的基础。AV2 在开放视频编码方面实现了跨越式发展，应对全球不断增长的流媒体需求，压缩性能远超 AV1。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;同时增强了对 AR/VR 应用的支持，支持多节目分屏传输，改进了屏幕内容处理，能在更广泛的视觉质量范围内运行。「AV2 标志着迈向开放创新媒体体验未来的重要里程碑。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="221" src="https://oscimg.oschina.net/oscnet/up-83d5dd8ec082a069cc799e9ee642cbaa931.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「AOMedia 相信创新源于开放」，AOMedia 执行董事 Pierre-Anthony Lemieux 表示。「我们的标准汇聚了全球创新者的智慧，并在免版税专利政策保障下开发，能更快地将下一代媒体体验带给更多人。我们很高兴向世界推出 AV2，继续通过开放合作引领媒体未来。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;值此十周年之际，AOMedia 还发布了一项会员调查结果。88% 的会员认为 AV1 对其当前或未来产品路线图「极为关键」或「重要」。展望未来，53% 的受访会员计划在今年 AV2 最终定稿后 12 个月内采用，88% 预计两年内实施。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373648</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373648</guid>
      <pubDate>Fri, 19 Sep 2025 03:06:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Sam Altman 预告将推出「计算密集型」新功能与产品</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenAI 首席执行官 Sam Altman 今日在社交平台 X 上发文&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fsama%2Fstatus%2F1969835407421374910" target="_blank"&gt;表示&lt;/a&gt;&lt;/u&gt;，未来几周内将推出一系列「计算密集型」新功能与产品。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1cfc95cf17d72f801bdc6095775fdac1738.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;他表示，由于相关成本较高，这些功能初期将仅面向 Pro 订阅用户开放，部分新产品亦将收取额外费用。&lt;/p&gt; 
&lt;p&gt;值得注意的是，Altman 并未透露具体功能细节或收费标准，外界推测此次更新或涉及多模态交互、个性化记忆系统等方向。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373646</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373646</guid>
      <pubDate>Fri, 19 Sep 2025 02:59:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>一文解码百度地图 ETA</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-3b1c47fc2aa68dab8d2daf6b89e8fac1ee1.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;你有没有这样的体验？导航说 30 分钟能到，结果真的一分不差？&lt;/p&gt; 
&lt;p&gt;有时候导航告诉你要绕行 5 分钟的路，其实省下了 20 分钟的堵车。&lt;/p&gt; 
&lt;p&gt;这些神奇的「预知能力」，就是我们常听到的 ETA（Estimated Time of Arrival，预计到达时间），别看它们只是一个个数字，其实背后藏着一整套复杂又高效的技术体系。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;百度地图 ETA&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;到底是怎么精准计算出来的呢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;【AI 地图 Tech 说】第二期将为你揭开奥秘！&lt;/strong&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;01 基础介绍&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;ETA 预测的本质，就是给定出发地、目的地和出发时间后，预测驾车所需的时间。例如，当你在某个时间 T 请求路线（如 Route = a→b→c→d→e）时，ETA 系统便开始计算驾车预计行驶的时长。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-28f94baeb8a2e2886b59ddef02164f01d8d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;百度地图 ETA（未来出行）是地图导航的基础功能，其技术演进共经历了四个发展阶段。&lt;/p&gt; 
&lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 1.0 时代：静态 ETA（2010 年前）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;最初，百度地图 ETA 功能的计算方式极为简单，仅通过距离除以限速得出。然而，这种方式计算出的结果误差常常超过 30%，一旦遭遇交通拥堵状况，更是完全无法应对，由此引发了用户的诸多吐槽。&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 2.0 时代：动态 ETA（2010-2015 年）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;百度地图首次接入实时交通数据，能够识别实时拥堵路段并提供基本绕行建议。然而，这种方法仍无法预测拥堵的进一步变化趋势。&lt;/p&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 3.0 时代：个性化 ETA（2015-2021 年）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;通过引入机器学习与用户画像，百度地图开始分析驾驶习惯（如激进型或保守型司机）、车辆类型（如货车或新能源车），实现了针对不同人群的个性化路线推荐。&lt;/p&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 4.0 时代：预见性 ETA（2021 年至今）&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;百度地图融入 AI 技术，如预训练大模型和时空预测技术，开始实现未来 30-60 分钟的精准路况预测，甚至能准确量化天气对行车速度的影响。&lt;/p&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;02 技术优势&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;百度地图 ETA 为何如此精准？背后的核心在于预训练交通大模型与端到端路线通行时间预测两大技术。&lt;/p&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 预训练交通大模型：海量 AI 知识集成体&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;预训练交通大模型通过地图脱敏轨迹数据，建模城市交通规律，为智能交通提供底座能力。预训练交通大模型基于千亿公里驾驶数据，能够精准捕捉不同城市在时段、天气、区域上的交通规律，如北京周一比周五早高峰堵 12%、上海雨天车速下降 22%、深圳科技园晚高峰比早高峰堵 35%。同时，该模型还具备持续学习优化能力，每天都会结合最新观察到的真实拥堵情况自动更新模型参数。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-4d11da294a17c976e3f8588cf43a468d3c5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;预训练交通大模型整体框架&lt;/p&gt; 
&lt;p&gt;预训练交通大模型的框架主要分为 3 个部分：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-2e10c2032b2def06f542a370b60ba3dd7c6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-877bb97f7d5893864d707d8d1c06b31a3be.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;交通大模型以及下游应用&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Large-Scale Traffic Corpus（大型交通语料数据）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将原始的脱敏 GPS 轨迹点处理成路段粒度的交通时序信息和路线粒度的个性化导航行为。&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Pre-Train Model（预训练模型）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基于历史交通大数据充分训练预训练模型，表征普适性的交通规律信息。&lt;/p&gt; 
&lt;p&gt;■ &lt;strong&gt;Downstream Task（下游任务）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基于预训练的交通图嵌入，通过 Zero-Shot 或者 Fine-tune 应用于通行时间预估、交通流量预估、路线排序、智能信控等场景。&lt;/p&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;▎ 端到端路线通行时间预测：基于交通大模型 FineTune 的 ETA-GNN AI 仿真推演路线模型&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;在预训练交通大模型基础上，百度地图进一步应用端到端路线通行时间预测，进行更细致的 AI 仿真推演，不再局限于逐路段的简单计算，而是精确模拟红绿灯等待时间、前方车辆汇入情况及施工路段的实际通行效率。同时通过动态概率模型实时评估，决策绕行还是等待，以达到最佳出行策略，预测准确率高达 92%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-c3af8afdeba713546288ccb7c875677960f.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;SFT-ETA 路线模型&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-84a14f312c065044fd4b8f84dad16cac53b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;ETA 路线模型预测 Pipeline&lt;/p&gt; 
&lt;p&gt;端到端路线预测体系涵盖以下核心能力：&lt;/p&gt; 
&lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;长时流量预测能力（Supervised FineTune）&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;全天候预测能力：通过对历史流量数据的监督微调，模型可实现对未来 24 小时路段流量变化趋势的精准预测，适用于节假日、景区周边等高动态场景。&lt;/p&gt; 
&lt;p&gt;零样本迁移泛化：预训练模型内置「早晚高峰模式库」，可直接迁移至新城市路网，实现冷启动场景下的预测精度显著提升。&lt;/p&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;动态交通关系图谱建模&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;时空图表示学习：捕捉交通流随时间与空间变化的普适规律。&lt;/p&gt; 
&lt;p&gt;路网级传播效应建模：通过图神经网络（GNN）结构，量化不同路段之间的流量传导影响，实现更高精度的区域级拥堵预测与调度模拟。&lt;/p&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;地理语义位置编码（GeoEmbedding）&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;多维地理语义融合：将传统经纬度转换为包含道路等级、POI 密度、地形坡度等语义信息的向量表示。&lt;/p&gt; 
&lt;p&gt;跨模态建模能力：融合天气、热度等环境信息，实现对不同条件下相同路段的动态编码与差异化建模，例如「暴雨下立交桥」和「晴天立交桥」的通行效率差异。&lt;/p&gt; 
&lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
&lt;h4&gt;■ &lt;strong&gt;轨迹表示学习与个性化 ETA&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;行为建模：通过车辆历史脱敏的轨迹聚类，区分不同驾驶风格（如保守型 vs 效率型），提供分群精准 ETA 预测。&lt;/p&gt; 
&lt;p&gt;实时风格感知与动态修正：感知车辆当前驾驶状态（如频繁变道、急加速等），动态调整 ETA 和路径建议，实现个性化自适应路线仿真与推荐。&lt;/p&gt; 
&lt;span id="OSC_h1_13"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;03 应用场景&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;百度地图 ETA 广泛应用于各类场景中：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;日常通勤&lt;/strong&gt;：准确预测早晚高峰路况，帮助通勤族合理安排出行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;机场接送：&lt;/strong&gt;精准判断当前出发是否能赶上航班，解决旅途焦虑。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;重大活动预警：&lt;/strong&gt;如演唱会结束前提前提醒车主提前离场，避免拥堵。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;节假日旅游&lt;/strong&gt;：提前预测旅游景区附近的拥堵趋势，提供更舒适的出游体验。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-5944e11566f599cfcec75ead77d34077afd.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;通过持续的技术进化和 AI 驱动的全面赋能，百度地图的 ETA 精准度在短途、长途、拥堵、节假日等多个场景均已显著领先行业水平，在用户感知层面更显稳健和准确。更值得一提的是，在节假日（尤其「五一」这类与日常规律差异显著的场景下），其表现尤为突出。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/up-23e482ef44354bc2995b984f5aecfd9e6d7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;出行从此告别盲目与焦虑&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;百度地图将每一次的未知变成清晰的规划&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;让用户安心出发，自信抵达！&lt;/strong&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18692522</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18692522</guid>
      <pubDate>Fri, 19 Sep 2025 02:38:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>OpenMind 开源全球首个「AI 原生」机器人系统 OM1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenMind 现已推出一款号称是全球首个「AI 原生」开源机器人系统，该系统旨在统一全平台生态，构建统一的开发基础，让不同类型的机器人在同一平台上实现感知、推理与行动，支持多种硬件与仿真环境。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6325062d4450079cac06d11cff78a0a6aad.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该系统强调「硬件中立」，可运行在四足、双足、人形与轮式等不同平台上，并以 Docker 镜像提供快速部署，兼容 AMD64 与 ARM64 架构，支持接入 OpenAI、Gemini、DeepSeek、xAI 等模型，原生支持宇树 Unitree G1、Go2、TurtleBot 以及优必选等机器人产品，方便开发者快速上手。&lt;/p&gt; 
&lt;p&gt;OM1 整体架构如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-bc4a425e4784e9f570a7ab229b6690271ed.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模块化架构：采用 Python 设计，旨在实现简洁性和无缝集成。&lt;/li&gt; 
 &lt;li&gt;数据输入：轻松处理新数据和传感器。&lt;/li&gt; 
 &lt;li&gt;通过插件提供硬件支持：通过 API 端点的插件以及与 ROS2、Zenoh 和 CycloneDDS 的特定机器人硬件连接来支持新硬件（建议所有新开发项目都使用 Zenoh）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在自主导航与环境理解方面，OM1 集成了即时定位与地图构建（SLAM）、LiDAR 传感器与 Nav2 路径规划，让机器人能够在复杂环境中实现自主移动。开发者可先通过 Gazebo 仿真环境进行行为测试，再将配置部署至实际硬件，从而降低实验成本与风险。&lt;/p&gt; 
&lt;p&gt;与此同时，OM1 还提供了名为 OM1 Avatar 的前端界面，基于 React 开发，可实时展示机器人的状态与虚拟形象，方便观察和交互。&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/OpenMind/OM1&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373637</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373637</guid>
      <pubDate>Fri, 19 Sep 2025 02:28:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里云爆款云服务器 68 元/年，2 核 2G 限时秒杀，超高性价比，立即抢购！</title>
      <description>覆盖 90%+通用业务场景，组合购买「专享活动价」。</description>
      <link>https://click.aliyun.com/m/1000406832/</link>
      <guid isPermaLink="false">https://click.aliyun.com/m/1000406832/</guid>
      <pubDate>Fri, 19 Sep 2025 02:15:00 GMT</pubDate>
    </item>
    <item>
      <title>CNCF 与 Docker 达成合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;CNCF &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F5t8eWP9JVkBarMiiitdWEw" target="_blank"&gt;宣布&lt;/a&gt;与 Docker 达成新合作，进一步扩展对 CNCF 托管项目的安全、可扩展支持。通过此次合作，所有 CNCF 项目将直接接入 Docker 的赞助开源计划（DSOS），该计划通过开放高端注册表、安保和支持服务，助力开源社区成长与成功。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「此次合作体现了 CNCF 对云原生生态基础设施的支持承诺，肯定了 Docker 在开源与企业工作流中的重要作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="247" src="https://oscimg.oschina.net/oscnet/up-e4f371307406d850d4cc10ec622363b4bba.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;通过 DSOS 计划，CNCF 项目将享受：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Docker Hub 无限镜像拉取 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;赞助开源身份，提升信任和曝光度 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;使用 Docker Scout 进行漏洞分析和策略执行 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;从源码自动构建镜像 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;获取 Docker 使用数据和参与度洞察 &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;通过开源渠道简化支持流程 &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;对项目维护者而言，这意味着获得更安全、更可扩展、贴近生产级开源项目需求的基础设施支持；对用户来说，则保证了对云原生工具的稳定可信访问。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告称，此次合作还强调了双方共同加强开源软件供应链安全的决心。Docker Scout 和 Docker Hardened Images 等工具将为 CNCF 项目带来更多容器安全洞察与控制，符合现代 DevSecOps 最佳实践。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Docker 领袖兼 CNCF 大使 James Spurin 补充道：「Docker Desktop 长期以来是我云原生工作流的重要组成，DSOS 项目扩展到 CNCF 项目，将为维护者和贡献者带来重大利好。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Docker 也将成为 CNCF 项目服务页面的官方服务提供商，提升 CNCF 维护者的发现和使用便利。&lt;span style="background-color:#ffffff"&gt;所有 CNCF 项目均可申请加入并在 Docker Hub 获得 DSOS 徽章。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373630</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373630</guid>
      <pubDate>Fri, 19 Sep 2025 02:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>xAI 发布 Grok4Fast，效率提升 40%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;xAI 推出了 Grok4Fast，这是一款轻量级的旗舰模型，据该公司称，其性能可媲美 Grok4，但计算量减少了 40%。这一显著的效率提升使得每项任务的成本最多可降低 98%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="253" src="https://oscimg.oschina.net/oscnet/up-db02c45f1f0e208a6d9cdeef278da590ac5.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;性能与效率的平衡&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Grok4Fast 在多个基准测试中表现出色，例如在 GPQA Diamond 中得分高达 85.7%，在 AIME2025 中得分为 92.0%，这些成绩与 Grok4 甚至 GPT-5 等&lt;span&gt;顶尖&lt;/span&gt;模型不相上下。xAI 强调，该模型通过减少「思考标记」实现了这一成就，平均使用比 Grok4 少 40% 的标记就能获得相似的结果。在处理需要复杂推理的问题时，这种效率优势尤为突出。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;集成架构与外部工具&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;与依赖单独模型处理不同任务的早期版本不同，Grok4Fast 将两种方法整合到一个架构中，并通过系统提示进行行为控制，体现了混合模型的&lt;span&gt;最新&lt;/span&gt;趋势。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该模型还具备强大的外部工具使用能力，包括网页浏览和代码执行。在 BrowseComp 和 X Bench Deepsearch 等基准测试中，Grok4Fast 的表现均优于 Grok4。在 LMArena-Search 基准测试中，它甚至超越了此前领先的 OpenAI o3-websearch 模型。在 Text Arena 排名中，Grok4Fast 暂列第八，领先于其他同等规模的模型。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;可用性与定价&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Grok4Fast 提供了两个版本，一个针对推理密集型任务优化，另一个则专注于快速解答。两个版本都支持 200 万个令牌的上下文窗口。该模型可通过 grok.com、iOS 和 Android 应用程序以及 xAI API 获取。其定价为每百万个令牌 0.05 美元至 1.00 美元，具体取决于令牌类型。目前，用户也可以通过 OpenRouter 和 Vercel 免费使用 Grok4Fast。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373628</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373628</guid>
      <pubDate>Fri, 19 Sep 2025 02:00:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Skyeye 云智能制造办公系统 - Saas v3.17.5 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="background-color:#ffffff; color:#6a737d"&gt;&lt;span&gt;Skyeye 云智能制造，&lt;/span&gt;智能制造一体化，采用 SpringBoot+ UNI-APP + Ant Design Vue 的低代码平台开发模式。包含 50 多种电子流程，CRM、PM、ERP、MES、ADM、OA、EHR、AI、项目、商城、财务、多班次考勤、薪资、招聘、云售后、论坛、问卷、报表设计、工作流、Saas 等功能。打造全网首套低代码、功能最全的智能制造行业供应链一体化管理软件&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fip.makerview.cn%3A30003%2FskyPortal" target="_blank"&gt;官方网站&lt;/a&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Farticles.zsxq.com%2Fid_xi3xhacte72g.html" target="_blank"&gt;开发文档&lt;/a&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fspace.bilibili.com%2F87396008%2Fchannel%2Fseries" target="_blank"&gt;视频教程&lt;/a&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/strong&gt;&lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fkdocs.cn%2Fl%2Fcbf2cgCLrUyz" target="_blank"&gt;功能点&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Skyeye&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;云【源代码】针对 {Skyeye 会员} 开源。拿到源码后可进行学习、毕设、企业等使用。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;Skyeye 云智能制造 v3.17.5 发布 ，发布内容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span&gt;Skyeye 云已加入 Dromara 社区&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;业务对象适配 Saas 进展 100%&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;VUE 版开发&lt;/strong&gt; 
  &lt;ul&gt; 
   &lt;li&gt;开发文档管理系统中，文件下载新增权限校验&lt;/li&gt; 
   &lt;li&gt;新增 APP 版本发布功能，目前已完成 50%，后续会适配多家应用商店&lt;/li&gt; 
   &lt;li&gt;开发管理端 APP 论坛模块，目前已完成 70%&lt;/li&gt; 
   &lt;li&gt;修复上个版本得 bug&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;新增&lt;strong&gt;React&lt;/strong&gt;版本项目，用于开发&lt;strong&gt;React&lt;/strong&gt;语言得 Skyeye 云管理端&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span&gt;源代码只对 Skyeye 会员开放&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;Skyeye 具备&lt;/span&gt;&lt;strong&gt;&lt;span&gt;低代码、快捷开发、可视化设计、微服务&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;等特点，方便客户二次开发，极大的提高了开发效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;项目地址：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;Gitee：&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;https://gitee.com/doc_wei01/skyeye&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;https://gitee.com/dromara/skyeye&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;GitCode：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;https://gitcode.com/doc_wei/erp-pro&lt;/li&gt; 
 &lt;li&gt;https://gitcode.com/doc_wei/skyeye-oa&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;PC 端效果图&lt;/strong&gt;&lt;/p&gt; 
&lt;table cellspacing="0" style="--darkreader-inline-bgcolor:#181a1b; --darkreader-inline-border-bottom:currentcolor; --darkreader-inline-border-left:currentcolor; --darkreader-inline-border-right:currentcolor; --darkreader-inline-border-top:currentcolor; --darkreader-inline-color:#bdb7af; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:1px; border:medium none; box-sizing:border-box; color:#444444; display:block; font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif; font-size:14px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; line-height:inherit; margin:0px; max-width:100%; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:776px; word-break:keep-all; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th style="text-align:center"&gt;效果图&lt;/th&gt; 
   &lt;th style="text-align:center"&gt;效果图&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-35a653b1c873ab9501f7187b0901a27cc64.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1919" src="https://oscimg.oschina.net/oscnet/up-f571611575c569395f75d2766052fab6120.png" width="3840" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-50138b38c37d750b93db5b37493f71bf4ca.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1911" src="https://oscimg.oschina.net/oscnet/up-c281a05f7ef637b7a7686865dd36493f1ff.png" width="3843" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-6499d74ddcfe9a99997d8c797aae7b7f0b0.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-e97af4a2caccb199b76d906ecbb339a7575.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1919" src="https://oscimg.oschina.net/oscnet/up-be4cfd4da0048b3fbe82e830fab3aae132c.png" width="3840" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-9eb76f53a99358fdf1ce532dc711baec41a.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-ce7c58e9fe940d58b2cb9cec441176b3481.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="919" src="https://oscimg.oschina.net/oscnet/up-ca685ab278a861067f5850e12470e155e59.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1919" src="https://oscimg.oschina.net/oscnet/up-ec6e551aca1cae85af43a94d3e2061445b1.png" width="3840" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1837" src="https://oscimg.oschina.net/oscnet/up-0bebb255d3c79c13a69bfa0fbb7fcd80836.png" width="3839" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1837" src="https://oscimg.oschina.net/oscnet/up-90cde5042c0effeea9e85761ff8dc7283d5.png" width="3839" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1837" src="https://oscimg.oschina.net/oscnet/up-47ccf76ab671effc6142727caf066d67071.png" width="3839" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;移动端效果图&lt;/strong&gt;&lt;/p&gt; 
&lt;table border="1" cellpadding="1" cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:1px; border:none; box-sizing:border-box; color:#444444; display:block; font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif; font-size:14px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; line-height:inherit; margin:0px; max-width:100%; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:776px; word-break:keep-all; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1637" src="https://oscimg.oschina.net/oscnet/up-6850576a0a01188e6b2a9d1ecce58ed7455.png" width="755" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1266" src="https://oscimg.oschina.net/oscnet/up-b5a18816a9e0e785ec5efcbd5baaac89d91.png" width="585" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1266" src="https://oscimg.oschina.net/oscnet/up-df25b57cc822bc730f41ca85c69caee46b6.png" width="588" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1637" src="https://oscimg.oschina.net/oscnet/up-d7707ebc67ddf3842adbb54fdc0c062a2a1.png" width="755" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="1269" src="https://oscimg.oschina.net/oscnet/up-8bff9dc60bdbf9fd632676cccab7b0b4ea6.png" width="582" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&amp;nbsp;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373618</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373618</guid>
      <pubDate>Fri, 19 Sep 2025 00:32:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>🔥🔥🔥高质量代码 SmartAdmin 发布 V3.28.2</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;strong&gt;SmartAdmin&lt;/strong&gt;&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;「高质量代码、简洁、高效、安全」的快速开发平台&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;v3.28.2 版本，重磅更新，发布，&lt;/strong&gt;更新如下：&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
  &lt;li&gt;【优化】海量 VastBase、神通，适配&lt;/li&gt; 
  &lt;li&gt;【优化】前端代码生成，字段类型适配前端组件 &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;hr&gt; 
   &lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3c3c43"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;SmartAdmin&lt;/strong&gt;&amp;nbsp;由&amp;nbsp;&lt;strong&gt;中国・洛阳&lt;/strong&gt;&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.1024lab.net%2F" target="_blank"&gt;1024 创新实验室&lt;/a&gt;&amp;nbsp;基于 SpringBoot2/3+Sa-Token+Mybatis-Plus 和 Vue3+Ant Design Vue+Uni-App+Uni-UI，并以&amp;nbsp;&lt;span style="color:#dc143c"&gt;&lt;strong&gt;「高质量代码」为核心，「简洁、高效、安全」&lt;/strong&gt;&lt;/span&gt;的快速开发平台。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3c3c43"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;国内首个满足《网络安全 - 三级等保》、《数据安全》&lt;/span&gt;&lt;/strong&gt;&amp;nbsp;功能要求，支持登录限制、接口国产加解密、数据脱敏等一系列安全要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3c3c43"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前端提供&amp;nbsp;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;JavaScript 和 TypeScript 双版本&lt;/span&gt;&lt;/strong&gt;，后端提供&amp;nbsp;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;Java8+SpringBoot2.X 和 Java17+SpringBoot3.X 双版本&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;支持&lt;span style="color:#dc143c"&gt;&lt;strong&gt;国产数据库：【达梦、金仓、南大通用、OceanBase、GaussDB 高斯、阿里 PolarDB、GoldenDB 】&lt;/strong&gt;&lt;/span&gt;等，主流数据库：&lt;strong&gt;&lt;span style="color:#dc143c"&gt;【Mysql，PostgreSQL 】等&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3c3c43"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;同时&amp;nbsp;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;重磅开源&lt;/span&gt;&lt;/strong&gt;&amp;nbsp;开源六年来&amp;nbsp;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;千余家企业验证过且正在使用&lt;/span&gt;&lt;/strong&gt;&amp;nbsp;的代码规范:&amp;nbsp;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;《高质量代码思想》、《Vue3 规范》、《Java 规范》&lt;/span&gt;&lt;/strong&gt;&amp;nbsp;，让大家在这浮躁的世界里感受到一股把代码写好的清流！同时又能节省大量时间，减少加班，快乐工作，保持谦逊，保持学习，&lt;strong&gt;&lt;span style="color:#dc143c"&gt;热爱代码，更热爱生活&lt;/span&gt;&lt;/strong&gt;&amp;nbsp;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;技术体系&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;前端：Vue3 + Vite5 + Vue-Router + Pinia + Ant Design Vue 4.X&lt;/li&gt; 
 &lt;li&gt;移动端：uniapp (vue3 版本) + uni-ui + （同时支持 APP、小程序、H5）&lt;/li&gt; 
 &lt;li&gt;后端：SpringBoot2/3 + Sa Token + Mybatis-plus + 主流数据库 / 国产数据库&lt;/li&gt; 
 &lt;li&gt;电脑在线预览：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpreview.smartadmin.vip" target="_blank"&gt;https://preview.smartadmin.vip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;官方文档：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsmartadmin.vip" target="_blank"&gt;https://smartadmin.vip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;移动端在线预览：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapp.smartadmin.vip%2F%23%2Fpages%2Flogin%2Flogin" target="_blank"&gt;https://app.smartadmin.vip&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;理念与思想&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;我们分享的不是徒劳无功的各种功能，而是必须有的功能，如：网络安全、数据变动记录、系统说明文档、版本更新记录、意见反馈、日志、心跳、单号生成器等等。&lt;/li&gt; 
 &lt;li&gt;我们分享的还有经过上百家公司验证过的前端、后端、vue3 等代码规范，好的规范能让我们敲下的每行代码更铿锵有力！&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;我们推崇高质量的代码，身为开发，代码即利剑，键盘上一套行云流水，宛如侠客，事了拂衣去，深藏身与名。&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;我们推崇团队的高度配合默契、互相帮助，从不加班，而不是一看到别人的代码就头皮发麻，留其&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F996.ICU" target="_blank"&gt;996.ICU&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;加班。&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;功能亮点图&lt;/strong&gt;&lt;/h3&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:1px; border:none; box-sizing:border-box; color:#444444; display:block; font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif; font-size:14px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; line-height:inherit; margin:0px 0px 20px; max-width:100%; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:776px; word-break:keep-all; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//b1071e517f1d71298d012c71e6f98a7c.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//15cfa4d262087c2b83dd40411f05a230.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//c9d856ba2697b9e39c3616f6de2c58e2.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//12eb4611701abae810e3331ae3e560a2.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e87bc020c32c09f8c19f870d00ca01ff.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//deb88775a4b1a4e2d65e7812e2932bbc.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//e0ea9cf13fb5029642c57ea603f65d01.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//81df44014813a2fce9447aecb33ac119.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//25c33dbfcf930dbf2ab060e453f146dc.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
   &lt;td style="border-color:#dddddd; border-style:solid; border-width:1px"&gt;&lt;img src="https://oscimg.oschina.net/oscnet//feedbc7cec172f3a14c21998a0d9b361.png" referrerpolicy="no-referrer"&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;&lt;strong&gt;功能亮点&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;安全体系&lt;/span&gt;&lt;/strong&gt;：&lt;span style="background-color:#ffffff; color:#3c3c43"&gt;满足国家三级等保要求，如双因子登录、密码加密、密码复杂度要求、登录错误次数锁定、登录超时退出、数据脱敏等网络安全和数据安全功能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span style="color:#dc143c"&gt;接口加解密&lt;/span&gt;&lt;/strong&gt;：支持请求参数和返回内容进行加解密操作，支持国产加密算法和其他国外加密算法&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;表格自定义列&lt;/strong&gt;：支持用户自定义列，并能将用户自定义列持久化到数据库&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;数据变更记录&lt;/strong&gt;：支持基于 git diff 插件的数据变更记录，查看数据变化更直观方便&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;在线文档&lt;/strong&gt;：支持右侧帮助文档（类似阿里云控制枱右侧帮助文档效果）、支持意见反馈、版本记录，等功能&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;OA 办公&lt;/strong&gt;：公司信息（发票、银行、员工等）、通知公告（阅读记录、次数等）&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;日志、监控&lt;/strong&gt;：服务器心跳日志、登录日志、操作日志（IP、浏览器、操作系统等设备信息）&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;系统功能&lt;/strong&gt;：员工、部门、角色、权限、菜单、水印、文件管理、系统参数、数据字典、单号生成，等&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;代码生成&lt;/strong&gt;： 基于每个表的配置、在线预览代码、下载，等&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;以上只是一些举例，更多灿若繁星的惊喜和细节，等待着你的发现！&lt;/strong&gt;：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsmartadmin.vip" target="_blank"&gt;SmartAdmin 业内独有功能亮点&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;代码亮点&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - 双版本】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;提供 js 和 ts 双版本，目录结构及其清晰&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - 常量维护】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;vue-enum，拒绝出现魔法数字，常量枚举不可维护的现象&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - 命名】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内最好的 api、常量等命名和写法&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - 多环境支持】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;独有的本地、开发、测试、预发布、生产 5 个 env 环境配置文件&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - layout 代码】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内代码最清晰的 layout 布局写法，小白都能看懂&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【前端 - main.js】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内可能只有我们把 main.js 中的 router 加载方式写对了&lt;/li&gt; 
 &lt;li&gt;---- 华丽前后端分割线 ----&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 独有目录结构】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内独有的高质量的 Java 代码分包结构，适合大、中、小型项目，结构非常清晰&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 公共配置文件】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内独有的共用配置文件维护，简化共同配置&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 返回码维护】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;业内独创的请求返回码维护，非常值得一看&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 四层架构】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;四层架构（controller, service, manager, dao），为什么要有四层&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 多环境】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;maven 多环境：开发、测试、预发布、生产，环境配置&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;【后端 - 系统钩子】：&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;smart-reload，为系统预留钩子，动态加载，在不重启程序前提下执行一些代码&lt;/li&gt; 
 &lt;li&gt;以上只是沧海一粟，更多的细节等待你的发现！&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsmartadmin.vip" target="_blank"&gt;去查看&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373586</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373586</guid>
      <pubDate>Thu, 18 Sep 2025 14:44:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
  </channel>
</rss>
