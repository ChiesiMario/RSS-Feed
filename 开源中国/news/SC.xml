<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 13 Jul 2025 21:42:16 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>PTerm —— 可以制作漂亮 CLI 的现代 Go 框架</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;PTerm 是一个现代的 Go 模块，用于轻松美化控制枱输出。它具有图表、进度条、表格、树形结构、文本输入、选择菜单等诸多功能。它完全可配置，并且 100% 兼容跨平台。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要特点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;易于使用 PTerm 强调易用性，并配有示例和一致的组件设计。&lt;/li&gt;
&lt;li&gt;跨平台 PTerm 可在各种操作系统和终端上运行，包括 Windows CMD、，macOS iTerm2 以及像 GitHub Actions 这样的 CI 系统。&lt;/li&gt;
&lt;li&gt;经过充分测试，高测试覆盖率和 28774 项自动化测试确保了 PTerm 的可靠性。&lt;/li&gt;
&lt;li&gt;一致的颜色 PTerm 使用 ANSI 配色方案以保持一致性，并为高级终端提供 TrueColor 支持。&lt;/li&gt;
&lt;li&gt;组件系统 PTerm 的灵活性 Printers 可以单独使用，也可以组合使用以生成漂亮的控制枱输出。&lt;/li&gt;
&lt;li&gt;可配置 PTerm 无需配置即可使用，但可以轻松定制独特的终端输出。&lt;/li&gt;
&lt;li&gt;文档，访问&lt;span style="background-color:#ffffff; color:#1f2328"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://pkg.go.dev/github.com/pterm/pterm#section-documentation"&gt;pkg.go.dev&lt;/a&gt;&amp;nbsp;上的综合文档并在示例部分查看&lt;a href="https://github.com/pterm/pterm#-examples"&gt;实际示例&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img height="348" src="https://static.oschina.net/uploads/space/2025/0605/161415_KReV_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/pterm</link>
      <guid isPermaLink="false">https://www.oschina.net/p/pterm</guid>
      <pubDate>Fri, 11 Jul 2025 10:57:00 GMT</pubDate>
    </item>
    <item>
      <title>解码鸿蒙生态及核心技术 + 2025 HarmonyOS 创新赛，携手共创万物互联新未来</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;7 月 8 日晚，一场聚焦 HarmonyOS 应用开发的线上技术交流会成功举行。本次活动由开源中国（OSCHINA）《数智漫谈》栏目主办，以「三步上手鸿蒙开发：工具·能力·进阶」为主题，旨在帮助开发者高效掌握鸿蒙应用开发核心技能，把握万物互联时代的创新机遇。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;直播吸引了大量开发者关注，观看人次超过 1.45 万，全网累计曝光量达 740 万。&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img height="960" src="https://oscimg.oschina.net/oscnet/up-3b3809a860224eb959066196672471a33d8.png" width="2560" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;交流会上，三位来自鸿蒙生态的技术专家进行了深入分享。&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#2980b9"&gt;&lt;strong&gt;华为云 HCDE、鸿蒙应用认证开发者姚圣伟&lt;/strong&gt;&lt;/span&gt;介绍了鸿蒙操作系统的最新进展。截至 2025 年 6 月，鸿蒙生态设备突破 10 亿台，中国市场占有率 17%，超越 iOS 成为中国市场的第二大移动操作系统。 鸿蒙的核心能力包括分布式架构、跨端开发、AI 集成等，支持一次开发多端部署。鸿蒙 6.0 版本强化了分布式软总线技术，提供更高带宽、更低时延、更安全可靠的设备间通信能力，支持更流畅、更强大的多设备协同体验。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;专家特别提到，相比&lt;/strong&gt; &lt;strong&gt;Web 应用，鸿蒙元服务具备独特的核心优势。&lt;/strong&gt;在用户体验上的提升，元服务实现了「原子化」场景渗透，无需打开完整载体，可直接嵌入系统场景（如负一屏卡片、日历提醒），实现 「服务找用户」，而 Web 需依赖浏览器跳转，体验割裂。另外，得益于系统级深度协同，元服务能直接调用系统底层能力（如本地计算、状态响应），Web 应用受沙箱限制无法做到。它重构了服务触达方式，以轻量化、场景化打破传统应用壁垒，推动生态从 「下载安装」 向 「按需流转」 升级，这是 Web 应用难以替代的生态级突破。&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#2980b9"&gt;&lt;strong&gt;华为开发者专家（HDE）张一弛&lt;/strong&gt;&lt;/span&gt;详细演示了鸿蒙官方开发工具 DevEco Studio。他表示，DevEco Studio 的安装与项目创建流程十分便捷，集成 SDK、模拟器，支持 Stage 模型；同时具备构建加速（并行/增量编译）、AI 辅助编程、3D UI 视图分析复杂组件层级、AI 性能分析优化、以及创新的多屏模拟器实现单窗口多设备联调等诸多亮点。&lt;/p&gt; 
&lt;p&gt;专家指出，相比安卓开发环境，DevEco Studio 更加轻量，更加高效。DevEco Studio 基于 IntelliJ IDEA 精简打造，剔除冗余组件，安装包更小，专注鸿蒙开发时资源占用更低。其&amp;nbsp;AI 辅助编程（CodeGenie）功能可快速生成代码、修复问题；Hvigor 构建工具优化流程，编译更快；支持多端实时预览，远程真机测试便捷，大幅提升开发效率。而安卓开发常用的 Android Studio 因需要兼容的安卓 SDK 广泛，且需集成大量组件，资源占用较高，且操作复杂。&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#2980b9"&gt;&lt;strong&gt;上海杉达学院副教授、华为开发者专家（HDE）祝欣蓉&lt;/strong&gt;&lt;/span&gt;则针对开发者成长路径提出建议。她提出三步路径：一是要提高对鸿蒙技术演进趋势和生态发展的认知；二是高效学习：以官网知识地图为纲，从行业白皮书切入，快速入门，分阶段学习，并推荐了「代码工坊」和「开发案例」两个实用工具。三是积极参与生态：活用新工具（如智能体框架）开发智能体，积极参与开源，抓住鸿蒙生态爆发期的机遇。&lt;/p&gt; 
&lt;p&gt;活动同时重点介绍了正在进行的「2025 HarmonyOS 创新赛」。该赛事由华为发起，是鸿蒙生态规模最大的官方开发者赛事，面向全球开发者。赛事设立专项奖金，总激励近千万（包含 450 万元人民币及 450 万耀星券），鼓励开发者基于 HarmonyOS 6 开发者 Beta 版本，调用其创新 Kit 能力，开发具有创新性和极致体验的应用或解决方案。&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;img height="3508" src="https://oscimg.oschina.net/oscnet/up-37b1f3dd2c128d26fe03b30f4282474a458.jpg" width="2481" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;专家在解读赛事时指出，评审注重创新性、技术实现和用户体验，建议参赛团队紧扣六大方向赛题，明确分工，善用 AI 工具，并关注社会关怀与跨设备协同等加分项。冲击高奖项的作品需融合技术创新、商业潜力和社会价值。&lt;/p&gt; 
&lt;p&gt;本次技术交流会通过场景化演示与案例拆解，为开发者提供了实用的开发指导和生态洞察。与会专家表示，鸿蒙操作系统的快速发展及其构建的万物互联生态，为全球开发者提供了广阔的创新舞台。活动的成功举办，将进一步激发开发者的创新热情，推动鸿蒙生态的繁荣发展。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;微信扫码，观看直播回放：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="4480" src="https://oscimg.oschina.net/oscnet/up-5426237e33bbcf93dda59aa74a9e482ad0c.png" width="3800" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3859945/blog/18684360</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/18684360</guid>
      <pubDate>Fri, 11 Jul 2025 10:33:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Mistral AI 发布 Devstral2507 系列</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Mistral AI 与 All Hands AI 合作，推出了针对开发者的大型语言模型 Devstral2507 系列，包含两款新模型：Devstral Small1.1 和 Devstral Medium2507。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这些模型旨在支持基于智能代理的代码推理、程序合成和结构化任务执行，适用于大型软件代码库的实际应用。这次发布在性能和成本上进行了优化，使其在开发工具和代码自动化系统中具有广泛的应用潜力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="334" src="https://oscimg.oschina.net/oscnet/up-c447bd09a61245b75a244d3bea9665c071a.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Devstral Small1.1 是一款开源模型，基于 Mistral-Small-3.1 基础模型，拥有约 240 亿个参数。该模型支持 128k 的上下文窗口，能够处理多文件代码输入和复杂的长提示，符合软件工程工作流程的特点。此版本特别针对结构化输出进行微调，包括 XML 和函数调用格式，使其与 OpenHands 等代理框架兼容，适合程序导航、多步骤编辑和代码搜索等任务。Devstral Small1.1 的许可为 Apache2.0，支持研究和商业用途。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在性能测试方面，Devstral Small1.1 在 SWE-Bench Verified 基准测试中获得 53.6% 的成绩，证明其在为真实的 GitHub 问题生成正确补丁方面表现优异。虽然其性能不及大型商业模型，但在大小、推理成本和推理能力之间找到了一个平衡点，适合多种编码任务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，该模型以多种格式发布，包括可以在高内存 GPU（如 RTX4090）或 32GB RAM 以上的 Apple Silicon 机器上进行本地推理的量化版本。同时，Mistral 还通过其推理 API 提供模型，当前的收费标准与 Mistral-Small 系列模型相同。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Devstral Medium2507 则仅通过 Mistral API 或企业部署协议提供，并不开放源代码。该模型在 SWE-Bench Verified 基准测试中得分为 61.6%，在长上下文的推理能力上表现出色，能够超越一些商业模型，如 Gemini2.5Pro 和 GPT-4.1。此模型的 API 收费标准高于 Small 版本，但其强大的推理能力使其非常适合在大型代码库中执行任务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Devstral Small 更适合本地开发、实验或集成到客户端开发工具中，而 Devstral Medium 则在结构化代码编辑任务中提供更高的准确性和一致性，适合需要高性能的生产服务。两款模型的设计都支持与代码代理框架的集成，使其能够简化测试生成、重构和错误修复的自动化工作流程。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359903</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359903</guid>
      <pubDate>Fri, 11 Jul 2025 10:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Snow 编程语言 v0.4.2 发布: 实现类型间全转换能力</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h3&gt;更新内容&lt;/h3&gt; 
&lt;h4&gt;新增功能&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;增加 IR 对类型转换指令的支持，补充基本数值类型转换相关指令，实现类型间全转换能力（如 long64/float32/double64/short16/byte8 等互转）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;性能和稳定性改进&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;优化函数调用指令逻辑，支持 void 类型函数调用，修复空函数、非 void 函数缺失 return 的判断与报错。&lt;/li&gt; 
 &lt;li&gt;修正比较操作的错误提示信息，增强容错和反馈能力。&lt;/li&gt; 
 &lt;li&gt;修复函数参数重名、空函数不生成代码、比较跳转等边界问题，提升稳定性。&lt;/li&gt; 
 &lt;li&gt;修正 CmpJumpGenerator 逻辑以适配新 VMOpCode。&lt;/li&gt; 
 &lt;li&gt;统一修复类型转换相关注释与文档错误，提升类型转换的准确性和一致性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;开发者体验提升&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;优化 CallInstruction 类设计与实现，提升结构清晰度与可维护性。&lt;/li&gt; 
 &lt;li&gt;重构 AST 节点位置信息表示方式，便于调试与错误定位。&lt;/li&gt; 
 &lt;li&gt;提取和统一类型提升逻辑至 TypePromoteUtils 工具类，简化代码结构。&lt;/li&gt; 
 &lt;li&gt;同步 VMOpCode 指令到 OpHelper 工具类，提升代码一致性。&lt;/li&gt; 
 &lt;li&gt;优化 IDEA 配置和 Demo 运行配置，调整 Demo 文件结构，减少根目录污染。&lt;/li&gt; 
 &lt;li&gt;统一代码风格，实现代码规范化。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;Bug 修复&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;修复函数参数重名导致的语义冲突。&lt;/li&gt; 
 &lt;li&gt;修复空函数不生成代码、非 void 函数缺少 return 等边界问题。&lt;/li&gt; 
 &lt;li&gt;修复类型转换、比较指令、函数调用等相关细节 bug。&lt;/li&gt; 
 &lt;li&gt;修复拼写和注释错误，提升文档质量。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;文档改进&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;完善 Snow-Lang 语法文档，新增 Snow-Lang-Syntax 相关文档。&lt;/li&gt; 
 &lt;li&gt;补充并修正类型转换指令（byte8、short16、long64、float32、double64 等）相关说明。&lt;/li&gt; 
 &lt;li&gt;优化 FunctionParser、L2I、ExpressionUtils、TypePromoteUtils、ComparisonUtils、CmpJumpGenerator 等核心类与方法的注释说明。&lt;/li&gt; 
 &lt;li&gt;统一优化类型转换相关文档，消除歧义，提升可读性。&lt;/li&gt; 
 &lt;li&gt;丰富类和方法的 JavaDoc 注释，解释用途和使用方式。&lt;/li&gt; 
 &lt;li&gt;修改 README，优化项目说明。&lt;/li&gt; 
 &lt;li&gt;优化测试用例及测试配置。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;如遇到使用问题，欢迎及时 &lt;a href="https://gitee.com/jcnc-org/snow/issues"&gt;提交 Issue&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359896</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359896</guid>
      <pubDate>Fri, 11 Jul 2025 09:41:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>AigcPanel v0.14.0 发布，开源 AI 数字人系统</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AigcPanel v0.14.0 已经发布，开源 AI 数字人系统。&lt;/p&gt; 
&lt;p&gt;此版本更新内容包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;新增：直播视频内容增加开关，默认关闭&lt;/li&gt; 
 &lt;li&gt;新增：直播用户重复进入重复忽略可设置&lt;/li&gt; 
 &lt;li&gt;新增：GPT-SoVITS 模型一键运行包&lt;/li&gt; 
 &lt;li&gt;新增：CosyVoice-300M 模型（优化版）&lt;/li&gt; 
 &lt;li&gt;新增：Heygem 一键运行包（调优版）v0.2.0&lt;/li&gt; 
 &lt;li&gt;新增：LatentSync 模型一键运行包 v0.4.0&lt;/li&gt; 
 &lt;li&gt;新增：CosyVoice-300M 模型一键运行包 v0.7.0&lt;/li&gt; 
 &lt;li&gt;优化：程序退出模型运行检测提示优化&lt;/li&gt; 
 &lt;li&gt;优化：音色选择组件支持播放互斥，关闭弹窗自动停止播放&lt;/li&gt; 
 &lt;li&gt;优化：视频合成界面显示对齐方式&lt;/li&gt; 
 &lt;li&gt;修复：新版本检测文字翻译异常问题&lt;/li&gt; 
 &lt;li&gt;修复：多语言参数为 0 时异常问题&lt;/li&gt; 
 &lt;li&gt;修复：数据库自增字段重复问题&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;详情查看：&lt;a href="https://gitee.com/modstart-lib/aigcpanel/releases/v0.14.0"&gt;https://gitee.com/modstart-lib/aigcpanel/releases/v0.14.0&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359880</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359880</guid>
      <pubDate>Fri, 11 Jul 2025 09:01:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>从 Python 演进探寻 AI 与云对编程语言的推动</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：孤弋&lt;/p&gt; 
&lt;h2&gt;引言&lt;/h2&gt; 
&lt;p&gt;Python 作为当今最受欢迎的编程语言之一，从 2008 年 Python 3.0 的发布到 2024 年 Python 3.13 的正式发布，以及 2025 年计划发布的 Python 3.14，十六年的演进过程不仅见证了编程语言技术的进步，更反映了整个软件行业的深刻变化。从人工智能的兴起到云计算的普及，从微服务架构的流行到开发者体验的重视，多重因素共同推动着 Python 语言的持续发展。&lt;/p&gt; 
&lt;h3&gt;近十六年版本演进图&lt;/h3&gt; 
&lt;p&gt;先给下面这张图从版本发布的时间上先给大家一个直观的印象。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b53f869abba56459700db4ef23ebfbcd1b9.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Python 3 从 2008 年推出，起初的核心目标是解决 Python 2 中积累的语言设计缺陷和一致性问题。以牺牲向前兼容为代价，来修复语言设计中的根本缺陷。其中包括字符串与编码的混乱、类型安全的不足、标准库的臃肿等。但是随着云计算、AI 等新兴技术的兴起，Python 3 逐渐开始追求更现代的编程风格和体验、更极致的性能等。写这篇文章的目的，主要是想从编程风格、类库能力、性能优化、虚拟机技术、开发工具链等多个维度，阐明 Python 语言的各个版本间的能力变化，为大家呈现一个尽量完整的 Python 演进视图。&lt;/p&gt; 
&lt;h2&gt;一、编程风格的现代化转型&lt;/h2&gt; 
&lt;h3&gt;1.1 语法层面的革命性变化&lt;/h3&gt; 
&lt;p&gt;这些版本的迭代，给程序员的编程风格带来了深刻的变化。根据 Python 官方文档的统计，这些变化不仅体现在语法层面，更体现在编程范式和开发理念的根本转变。&lt;/p&gt; 
&lt;h4&gt;变化一：字符串处理的演进&lt;/h4&gt; 
&lt;p&gt;Python 2.7 时代，字符串处理是开发者的一大痛点，需要显式处理 Unicode 和字节串的区别：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 2.7 - 字符串处理复杂
# -*- coding: utf-8 -*-
name = u"EDAS 用户"  # Unicode 字符串
message = u"Hello, %s!" % name
print message.encode('utf-8')
# 字符串格式化方式有限
template = u"用户{name}在{timestamp} 登录了 EDAS 应用管理平台"
result = template.format(name=name, timestamp="2023-01-01")
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Python 3.0 的发布标志着字符串处理的重大改进，字符串默认为 Unicode：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.0+ - 字符串处理简化
name = "EDAS 用户"  # 默认 Unicode
message = "Hello, {}!".format(name)
print(message)  # print 变为函数
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Python 3.6 引入的 f-string 彻底革命了字符串格式化，根据官方性能测试，f-string 在多数场景中比传统格式化方法快 20-30%：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.6+ - f-string 革命 
name = "EDAS 用户"
timestamp = "2023-01-01"
message = f"Hello, {name}!"
complex_message = f"用户{name}在{timestamp}登录了 EDAS 应用管理平台"
# 支持表达式和格式化
price = 123.456
formatted = f"价格: {price:.2f}元"  # 价格: 123.46 元
# 支持调试模式（Python 3.8+）
debug_info = f"{name=}, {timestamp=}"  
# name='世界', timestamp='2023-01-01'
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;性能对比测试结果：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-30278ff5db0358f8f0e2c6043e4274568a4.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;基于 10,000 次字符串格式化操作后的平均时间得出。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;变化二：异步编程语法的演进&lt;/h4&gt; 
&lt;p&gt;异步编程是 Python 演进过程中最重要的变化之一。从基于生成器的复杂模式到直观的 async/await 语法，这一变化的推动力来自现代 Web 应用对高并发处理的需求。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.4 - 基于生成器的异步编程 - for Python in EDAS
import asyncio
@asyncio.coroutine
def fetch_data(url):
    response = yield from aiohttp.get(url)
    data = yield from response.text()
    return data
@asyncio.coroutine
def main():
    tasks = []
    for url in urls:
        task = asyncio.ensure_future(fetch_data(url))
        tasks.append(task)
    results = yield from asyncio.gather(*tasks)
    return results
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Python 3.5 引入的 async/await 语法使异步编程更加直观：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.5+ - async/await 语法 - for Python in EDAS
import asyncio
import aiohttp
async def fetch_data(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()
async def main():
    urls = ['http://edas.console.aliyun.com', 
            'http://www.aliyun.com/product/edas' ]
    tasks = [fetch_data(url) for url in urls]
    results = await asyncio.gather(*tasks)
    return results
# Python 3.7+ - 更简洁的运行方式
asyncio.run(main())
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;异步性能基准测试：&lt;/p&gt; 
&lt;p&gt;同时处理 1000 个 HTTP 请求&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-df35a7afcee57806a5f1966027c074f90fe.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;模拟 1000 个并发 HTTP 请求，每个请求延迟 100ms 。值得注意的是大家看到的 "同步处理总耗时"小幅下降得益于解释器整体优化。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;1.2 类型系统的建立与完善&lt;/h3&gt; 
&lt;p&gt;Python 类型系统的发展是编程风格现代化的重要体现。从 Python 3.5 引入 PEP 484 类型提示开始，Python 逐步建立了功能完整的类型系统。&lt;/p&gt; 
&lt;h4&gt;类型提示的演进历程&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.5 - 基础类型提示 - for Python in EDAS
from typing import List, Dict, Optional, Union
def process_users(users: List[str]) -&amp;gt; Dict[str, int]:
    result = {}
    for user in users:
        result[user] = len(user)
    return result
def find_user(user_id: int) -&amp;gt; Optional[str]:
    # 可能返回 None
    return database.get_user(user_id)
# 联合类型
def handle_input(value: Union[str, int]) -&amp;gt; str:
    return str(value)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Python 3.9 简化了泛型语法，减少了从 typing 模块的导入需求：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.9+ - 内置集合泛型
def process_data(items: list[str]) -&amp;gt; dict[str, int]:
    return {item: len(item) for item in items}
def merge_lists(list1: list[int], list2: list[int]) -&amp;gt; list[int]:
    return list1 + list2
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Python 3.10 引入联合类型操作符，进一步简化语法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.10+ - 联合类型语法糖
def handle_input(value: str | int) -&amp;gt; str:
    return str(value)
def process_result(data: dict[str, str | int | None]) -&amp;gt; str:
    # 处理混合类型字典
    return json.dumps(data)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在这之后 python 也有了更多的类型检查工具，如 mypy、pyright、pyre 等。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-63073fc70aa7d3e5d24ddc0b90f8e22b295.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;二、类库生态的战略性调整&lt;/h2&gt; 
&lt;h3&gt;2.1 标准库的精简与优化&lt;/h3&gt; 
&lt;p&gt;Python 标准库的演进体现了从"已包含"到"精选"的战略转变。根据 PEP 594 的统计，Python 3.13 移除了 19 个过时的标准库模块，这一变化体现了 Python 社区对代码质量和维护性的重视。&lt;/p&gt; 
&lt;h4&gt;标准库模块的变迁&lt;/h4&gt; 
&lt;p&gt;下表展示了 Python 标准库的重要变化：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ab7604d25a59043fd51cc77e2be43112ee5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;新模块的实际应用示例&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;pathlib 模块的现代化路径操作（Python 3.4+）：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 传统方式 vs pathlib 方式 - for Python in EDAS
import os
import os.path
from pathlib import Path
# 传统方式
old_way = os.path.join(os.path.expanduser("~"), "documents", "EDAS-python-file.txt")
if os.path.exists(old_way):
    with open(old_way, 'r') as f:
        content = f.read()
# pathlib 方式
new_way = Path.home() / "documents" / "EDAS-python-file.txt"
if new_way.exists():
    content = new_way.read_text()
# 更多 pathlib 优势
config_dir = Path.home() / ".config" / "myapp"
config_dir.mkdir(parents=True, exist_ok=True)
for py_file in Path(".").glob("**/*.py"):
    print(f"Python 文件: {py_file}")
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;性能对比测试：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-4187629c93667852e476abfc2dcb4d6d86e.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注：除目录遍历外，pathlib 在大多数场景下性能相当或更优，Pathlib 牺牲少量性能换取 API 现代化。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;2.2 第三方生态的爆发式增长&lt;/h3&gt; 
&lt;p&gt;虽然标准库趋于精简，但 Python 的第三方生态却经历了爆发式增长。根据 PyPI 统计数据，截至 2024 年，PyPI 上的包数量已超过 500,000 个，相比 2015 年的约 60,000 个包，增长了 8 倍以上。&lt;/p&gt; 
&lt;p&gt;数据科学库性能对比：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-fbeb7b699de037b89c01edf8b2b4c5d1bfe.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;测试环境：1GB CSV 数据处理，包括读取、过滤、聚合操作。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;三、性能优化的突破性进展&lt;/h2&gt; 
&lt;h3&gt;3.1 Faster CPython 项目的革命性影响&lt;/h3&gt; 
&lt;p&gt;Python 3.11 引入的 Faster CPython 项目是 Python 性能优化历史上的重要里程碑。根据官方文档，这一项目通过多个层面的系统性优化，实现了显著的性能提升。&lt;/p&gt; 
&lt;h4&gt;官方性能数据验证&lt;/h4&gt; 
&lt;p&gt;根据 Python 官方文档的明确声明：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;"CPython 3.11 is an average of 25% faster than CPython 3.10 as measured with the pyperformance benchmark suite, when compiled with GCC on Ubuntu Linux. Depending on your workload, the overall speedup could be 10-60%."&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;验证测试结果：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b01518d712716654789451c496be7bf907b.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;数据来源：Python 官方 pyperformance 基准测试结果。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;启动性能的优化实例&lt;/h4&gt; 
&lt;p&gt;根据官方文档，Python 3.11 的启动时间改进了 10-15%：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 测试启动性能的脚本 - for Python in EDAS
# 标准启动时间测试
time python3 -c "import sys; print('Python', sys.version_info[:2])"
# 模块导入性能测试
time python3 -c "import json, os, re, datetime, pathlib"
# 应用启动模拟测试
time python3 -c "
import sys
import json
import os
from pathlib import Path
config = {'app': 'test', 'version': '1.0'}
log_dir = Path('logs')
log_dir.mkdir(exist_ok=True)
print('Application started')
"
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;启动时间测试结果（官方验证）：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1cedc3189210fcf45d637d02704e6f32f2e.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.2 JIT 编译技术的前瞻性布局&lt;/h3&gt; 
&lt;p&gt;Python 3.13 引入的 JIT 编译器标志着 Python 性能优化进入新阶段。根据 PEP 744 和官方文档，这一技术仍处于实验阶段。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9b7d7a73607cb96baf80c0efba1f999aefb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;JIT 编译器在不同基准测试中的预期性能提升（实验性数据）&lt;/p&gt; 
&lt;h4&gt;JIT 编译器的官方状态&lt;/h4&gt; 
&lt;p&gt;根据 Python 3.13 官方文档：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;"When CPython is configured and built using the --enable-experimental-jit option, a just-in-time (JIT) compiler is added which may speed up some Python programs."&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;JIT 编译器测试环境：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 编译启用 JIT 的 Python 3.13
./configure --enable-experimental-jit
make -j4
# 运行 JIT 性能测试
python3.13 --jit benchmark_script.py
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;保守性能估算（基于实验数据）：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9daf7a2687a0ac193a082fb546a86a5a8cf.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注：以上数据为实验性估算，实际效果可能因工作负载而显著不同。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;3.3 内存管理的系统性改进&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-09a9f3aa3172d648ae792672cb2cd951afe.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Python 内存管理的优化效果。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;内存使用优化示例&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;# 内存使用优化对比示例 - for Python in EDAS
import sys
import gc
from memory_profiler import profile  # 需要安装: pip install memory-profiler
class OldStyleClass:
    """传统类定义 - 内存使用较多"""
    def __init__(self, name, data):
        self.name = name
        self.data = data
        self.metadata = {}
        self.cache = {}
class OptimizedClass:
    """优化后的类定义 - 使用__slots__"""
    __slots__ = ['name', 'data', '_metadata']
    def __init__(self, name, data):
        self.name = name
        self.data = data
        self._metadata = None
@profile
def memory_comparison():
    """内存使用对比测试"""
    # 创建大量对象测试内存使用
    old_objects = [OldStyleClass(f"obj_{i}", list(range(10))) for i in range(1000)]
    print(f"传统类对象内存使用: {sys.getsizeof(old_objects)} bytes")
    optimized_objects = [OptimizedClass(f"obj_{i}", list(range(10))) for i in range(1000)]
    print(f"优化类对象内存使用: {sys.getsizeof(optimized_objects)} bytes")
    # 手动垃圾回收
    del old_objects
    del optimized_objects
    gc.collect()
memory_comparison()
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上述脚本执行结果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-822b55758fafbb0b18c1c403534a4c9742f.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;其他内存优化测试结果：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-88c8c9d615e1a1f4b7a171dbff6b7d93ede.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;以上对比表格由 100,000 个对象的批量创建得出。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;四、虚拟机技术的前沿探索&lt;/h2&gt; 
&lt;h3&gt;4.1 GIL 问题的历史性突破&lt;/h3&gt; 
&lt;p&gt;全局解释器锁（GIL）一直是 Python 并发性能的最大瓶颈。Python 3.13 引入的自由线程模式是解决这一历史性问题的重要尝试。不过根据 PEP 703 来看，这一特性目前处于实验阶段，但是的确令人期待。&lt;/p&gt; 
&lt;h4&gt;官方自由线程模式状态&lt;/h4&gt; 
&lt;p&gt;根据 Python 3.13 官方文档：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;"CPython now has experimental support for running in a free-threaded mode, with the global interpreter lock (GIL) disabled. This is an experimental feature and therefore is not enabled by default."&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;启用自由线程模式：&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 编译支持自由线程的 Python
./configure --disable-gil
make -j4
# 或使用预编译版本
python3.13t  # 't'表示 free-threaded 版本
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;GIL 影响实验测试结果：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-5409dc3f6bf367d3c9d4f2e3a5d37334b2b.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;在 4C8G 的机器中，批量执行对应任务一百万次计算操作得出。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;4.2 字节码系统的智能化演进&lt;/h3&gt; 
&lt;p&gt;Python 的字节码系统在演进过程中变得越来越智能化。Python 3.11 引入的自适应字节码技术是这一演进的重要成果。&lt;/p&gt; 
&lt;h4&gt;字节码优化的实际效果&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;# 字节码分析示例 - for Python in EDAS
# -*- coding: utf8
import dis
import time
def simple_function(x, y):
    """简单函数 - 用于字节码分析"""
    result = x + y
    if result &amp;gt; 10:
        return result * 2
    else:
        return result
def complex_function(data):
    """复杂函数 - 展示字节码优化"""
    total = 0
    for item in data:
        if isinstance(item, (int, float)):
            total += item ** 2
        elif isinstance(item, str):
            total += len(item)
    return total
print("简单函数字节码:")
dis.dis(simple_function)
print("\n 复杂函数字节码:")
dis.dis(complex_function)
# 将以上的文件保存成 dis.py 之后，
# 分别以 python2 dis.py 与 python3.13 dis.py 执行完之后查看字节码优化的对比效果
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;字节码优化效果测试：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-4bcbff340de08294d63beac5bb1090c845c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;复杂函数执行 100,000 次迭代。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;五、演进背后的核心推动力&lt;/h2&gt; 
&lt;h3&gt;5.1 AI 与机器学习带来的生态繁荣&lt;/h3&gt; 
&lt;p&gt;Python 在 AI 和机器学习领域的成功是其演进的最重要推动力。根据 Stack Overflow 2024 年开发者调查，Python 连续第四年成为最受欢迎的编程语言，其中 AI/ML 应用占据了重要地位。&lt;/p&gt; 
&lt;h4&gt;数据科学革命的量化影响&lt;/h4&gt; 
&lt;p&gt;根据 GitHub 统计数据，与 AI/ML 相关的 Python 项目数量从 2015 年的约 50,000 个增长到 2024 年的超过 800,000 个，增长了 16 倍。&lt;/p&gt; 
&lt;h4&gt;主要 AI/ML 框架的发展时间线：&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6028fd335feaacbb7a0cd598b5e45550227.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;以上数据截止至 2025 年 6 月整理。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;企业级 AI 应用场景直接受益&lt;/h4&gt; 
&lt;p&gt;数据分析样例代码&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;# 现代机器学习工作流示例  - for Python in EDAS
# requirement.txt 内容
pandas&amp;gt;=2.0
numpy&amp;gt;=1.24
matplotlib&amp;gt;=3.7
seaborn&amp;gt;=0.12
scikit-learn&amp;gt;=1.2
# 脚本内容：for Python in EDAS
# -*- coding: utf-8 -*-
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report
# 1️⃣ 加载数据并查看基本信息
def load_data(file_path='EDAS.csv'):
    """
    加载原始数据，并展示前几行和基础信息。
    """
    df = pd.read_csv(file_path)
    print("数据前几行：")
    print(df.head())
    print("\n 数据基本信息：")
    print(df.info())
    return df
# 2️⃣ 特征工程：日期解析 + 滚动窗口特征
def feature_engineering(df):
    """
    将 'date' 列转为 datetime 类型，并构造滚动窗口平均值作为新特征。
    """
    df['processed_date'] = pd.to_datetime(df['date'])
    df['feature_engineered'] = df['value'].rolling(window=7).mean()
    return df
# 3️⃣ 可视化：时间序列趋势图
def visualize_time_series(df):
    plt.figure(figsize=(14, 6))
    sns.lineplot(data=df, x='processed_date', y='feature_engineered')
    plt.title('时间序列特征工程结果 - 滚动窗口平均值 (Window=7)')
    plt.xlabel('日期')
    plt.ylabel('滚动均值')
    plt.tight_layout()
    plt.show()
# 4️⃣ 准备建模数据
def prepare_model_data(df):
    X = df[['feature1', 'feature2', 'feature_engineered']].fillna(0)
    y = df['target']
    return train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
# 5️⃣ 构建模型并训练
def train_model(X_train, y_train):
    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    return model
# 6️⃣ 模型评估
def evaluate_model(model, X_test, y_test):
    predictions = model.predict(X_test)
    print("模型评估报告：")
    print(classification_report(y_test, predictions))
    # 显示特征重要性
    feat_names = X_test.columns
    importances = model.feature_importances_
    plt.figure(figsize=(10, 6))
    sns.barplot(x=importances, y=feat_names)
    plt.title('随机森林模型特征重要性')
    plt.xlabel('重要性得分')
    plt.ylabel('特征名称')
    plt.show()
# 7️⃣ 超参数调优（可选）
def hyperparameter_tuning(X_train, y_train):
    param_grid = {
        'n_estimators': [50, 100, 200],
        'max_depth': [None, 10, 20],
        'min_samples_split': [2, 5]
    }
    grid_search = GridSearchCV(
        estimator=RandomForestClassifier(random_state=42),
        param_grid=param_grid,
        scoring='f1_weighted',
        cv=5,
        n_jobs=-1
    )
    grid_search.fit(X_train, y_train)
    best_params = grid_search.best_params_
    print("最佳超参数组合：", best_params)
    return grid_search.best_estimator_
# 主函数：执行整个流程
def main():
    df = load_data()
    df = feature_engineering(df)
    visualize_time_series(df)
    X_train, X_test, y_train, y_test = prepare_model_data(df)
    model = train_model(X_train, y_train)
    print("使用默认参数训练模型：")
    evaluate_model(model, X_test, y_test)
    print("\n 开始超参数调优：")
    tuned_model = hyperparameter_tuning(X_train, y_train)
    print("使用调优后的模型重新评估：")
    evaluate_model(tuned_model, X_test, y_test)
if __name__ == '__main__':
    main()
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注：以上代码片段内容由 tongyi 生成。以下是 Prompt:&lt;/p&gt; 
&lt;p&gt;你是一位专业的数据科学家，擅长使用 Python 进行端到端的数据分析和机器学习建模。请根据以下代码示例，帮我完成/解释/优化一个用于 EDAS 数据集的数据分析流水线：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;数据预处理部分包括：日期解析、滚动窗口特征构建；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用 matplotlib 和 seaborn 对时间序列数据进行可视化；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;构建了一个基于 RandomForestClassifier 的分类模型，并输出 classification_report。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;请根据这个流程，提供清晰的步骤说明、代码注释、潜在改进点或可扩展方向（例如特征选择、超参数调优、交叉验证等）。要求代码规范、逻辑清晰，适合在实际项目中使用。&lt;/p&gt; 
&lt;h3&gt;5.2 云技术的推动和影响&lt;/h3&gt; 
&lt;p&gt;云计算的普及深刻改变了 Python 的发展方向。根据 CNCF 2024 年调查报告，Python 是容器化应用开发中第二受欢迎的语言，仅次于 Go。云技术的不断向前演进，也在催生着 Python 的不断变化。其中云厂商中推动的事件驱动模型的应用架构，直接推动 Python 3.4 引入 asyncio 标准库，async/await 语法进一步优化了协程可读性，gevent 等第三方库的协程方案也被纳入标准生态。&lt;/p&gt; 
&lt;p&gt;弹性和容器等主流云的场景下，对于应用程序的冷启动有着极致诉求，从 Python 3.11 中 Faster CPython 项目的诞生，之后引入的 Frame Caching、Zero-Cost Exception、专用系统 LOAD 操作码、隔离堆等内存技术的引入，对冷启动的优化有着立竿见影的效果。&lt;/p&gt; 
&lt;p&gt;同时云函数 (Function) 的高频触发、瞬时生命周期、事件多样性等特性，迫使 Python 在语言层面对异步范式进行深度重构。这种压力传导机制，正是 Python 从"脚本工具"蜕变为"云原生核心语言"的技术动力源。未来随着事件总线架构的深化以及 AI 协同推理等新场景出现，Python 的响应式编程能力将持续进化。&lt;/p&gt; 
&lt;h2&gt;六、未来展望与发展趋势&lt;/h2&gt; 
&lt;h3&gt;6.1 性能优化的持续深化&lt;/h3&gt; 
&lt;p&gt;基于当前的发展趋势和官方路线图，Python 在性能优化方面将继续深化，也相当令人期待。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;预期的性能改进路线图&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-e5f2f0a9e6fbe505c019c9c2e5802342e17.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注：以上时间表和性能数据为基于当前趋势的预测，实际情况可能有所不同。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;6.2 类型系统的进一步完善&lt;/h3&gt; 
&lt;p&gt;Python 的类型系统将继续向着更强大、更易用的方向发展。根据 Typing Council 的路线图，未来的重点包括：&lt;/p&gt; 
&lt;h4&gt;高级类型特性展望举例&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;# Python 3.14+ 预期类型系统改进 - For Python in EDAS
from typing import TypeVar, Generic, Protocol, runtime_checkable
# typing_extensions module 为潜在的类型系统改进能力
from typing_extensions import Self, TypedDict, Required, NotRequired
# 更强大的泛型支持
T = TypeVar('T', bound='Comparable')
class Comparable(Protocol):
    def __lt__(self, other: Self) -&amp;gt; bool: ...
    def __eq__(self, other: object) -&amp;gt; bool: ...
class SortedContainer(Generic[T]):
    """类型安全的排序容器"""
    def __init__(self) -&amp;gt; None:
        self._items: list[T] = [ ]
    def add(self, item: T) -&amp;gt; Self:
        """添加元素并保持排序"""
        # 二分插入
        left, right = 0, len(self._items)
        while left &amp;lt; right:
            mid = (left + right) // 2
            if self._items[mid] &amp;lt; item:
                left = mid + 1
            else:
                right = mid
        self._items.insert(left, item)
        return self
    def get_items(self) -&amp;gt; list[T]:
        """获取所有元素"""
        return self._items.copy()
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;结语&lt;/h2&gt; 
&lt;p&gt;Python 从 2.7 到 3.13 的演进历程展现了一个编程语言如何在快速变化的技术环境中保持活力和竞争力。从编程风格的现代化到性能优化的突破，从类库生态的战略调整到虚拟机技术的前沿探索，Python 的演进是多重推动力协同作用的结果。AI 与机器学习的浪潮、云计算和 DevOps 的影响、编程语言竞争的压力，这些因素共同塑造了 Python 的发展轨迹。Python 的故事还在继续，这一演进历程将为整个编程语言领域的发展提供重要启示，也将继续推动软件技术的进步和创新。&lt;/p&gt; 
&lt;p&gt;这里我们也提前做一个预告，阿里云 EDAS 产品即将于 7 月初推出针对 Python 应用的托管、微服务、可观测的一站式应用治理的能力，敬请进群关注（钉钉群： 21958624）。&lt;/p&gt; 
&lt;h2&gt;数据来源与参考文献&lt;/h2&gt; 
&lt;p&gt;本文所有技术声明和性能数据均基于以下权威来源：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;Python 11 官方文档 - What's New in Python 3.11：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Fwhatsnew%2F3.11.html" target="_blank"&gt;https://docs.python.org/3/whatsnew/3.11.html&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="2"&gt; 
 &lt;li&gt;pyperformance 基准测试套件：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpython%2Fpyperformance" target="_blank"&gt;https://github.com/python/pyperformance&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="3"&gt; 
 &lt;li&gt;Python 3.13 移除模块列表：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Fwhatsnew%2F3.13.html%5B%23removed%5D" target="_blank"&gt;https://docs.python.org/3/whatsnew/3.13.html[#removed]&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="4"&gt; 
 &lt;li&gt;PyPI 统计数据：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpypistats.org%2F" target="_blank"&gt;https://pypistats.org/&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="5"&gt; 
 &lt;li&gt;Python 3.11 Faster CPython 项目：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Fwhatsnew%2F3.11.html" target="_blank"&gt;https://docs.python.org/3/whatsnew/3.11.html&lt;/a&gt;&lt;a href=""&gt;#whatsnew311&lt;/a&gt;-faster-cpython&lt;/p&gt; 
&lt;ol start="6"&gt; 
 &lt;li&gt;Python 3.13 JIT 编译器：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Fwhatsnew%2F3.13.html" target="_blank"&gt;https://docs.python.org/3/whatsnew/3.13.html&lt;/a&gt;&lt;a href=""&gt;#whatsnew313&lt;/a&gt;-jit-compiler&lt;/p&gt; 
&lt;ol start="7"&gt; 
 &lt;li&gt;PEP 703 - Making the Global Interpreter Lock Optional：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpeps.python.org%2Fpep-0703%2F" target="_blank"&gt;https://peps.python.org/pep-0703/&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="8"&gt; 
 &lt;li&gt;自由线程模式文档：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.python.org%2F3%2Fhowto%2Ffree-threading-python.html" target="_blank"&gt;https://docs.python.org/3/howto/free-threading-python.html&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="9"&gt; 
 &lt;li&gt;Stack Overflow 2024 开发者调查：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsurvey.stackoverflow.co%2F2024%2F" target="_blank"&gt;https://survey.stackoverflow.co/2024/&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="10"&gt; 
 &lt;li&gt;GitHub 统计数据：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsearch%3Fq%3Dmachine%2Blearning%2Blanguage%3Apython" target="_blank"&gt;https://github.com/search?q=machine+learning+language:python&lt;/a&gt;&lt;/p&gt; 
&lt;ol start="11"&gt; 
 &lt;li&gt;Typing Council 路线图：&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftyping.readthedocs.io%2Fen%2Flatest%2F" target="_blank"&gt;https://typing.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3874284/blog/18684302</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3874284/blog/18684302</guid>
      <pubDate>Fri, 11 Jul 2025 08:32:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Manus 清空国内社交平台账号内容，前员工透露「不会继续推进」中文版</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;网友发现，通用 AI 智能体公司「Manus」的官方微博和小红书账号的内容今日均已清空。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-85bd05e3a02aa43e5707cbefe10364949bd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;与此同时，打开 Manus 的官网发现，其官网首页显示&lt;strong&gt;「Manus 在你所在的地区不可用」&lt;/strong&gt;，而此前为「Manus 中文版本正在开发中」。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-0ff951397f8da8a43d06253d76df2ada848.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Manus 近期因大规模裁员的传闻而再度引发外界关注。据澎湃新闻 7 月 8 日报道，Manus 方面对此回应记者表示：「&lt;strong&gt;基于公司自身经营效率考量，我们决定对部分业务团队进行调整。公司将继续专注核心业务发展，提升整体运营效率。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;另据蓝鲸新闻 7 月 10 日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1837269038810525490%26wfr%3Dspider%26for%3Dpc" target="_blank"&gt;报道&lt;/a&gt;，Manus 将与阿里通义千问合作开发中文版一事，&lt;strong&gt;Manus 一员工称「不会继续推进」&lt;/strong&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359869</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359869</guid>
      <pubDate>Fri, 11 Jul 2025 08:24:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Apache Seata v2.3.0 发布，支持 Saga 注解模式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Apache Seata v2.3.0 已发布，此版本是 Seata 进入 Apache 基金会的重要里程碑版本。此次发布将带来了大家期待已久的 Saga 注解模式，同时支持 Kingbase 和 ShenTong 国产数据库。&lt;/p&gt; 
&lt;p&gt;Apache Seata (incubating) 是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;发布概览&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;功能特性方面，2.3.0 支持了大家期待已久的 Saga 注解模式，支持 Kingbase 和 ShenTong 国产化数据库，支持 gRPC 协议，支持 SSL 加密通信，支持 FastJson2 序列化。另外，本次发布共通过了 115 组 JDK_(8/11/17/21)&amp;nbsp;&lt;em&gt;+ Spring 版本 + OS&lt;/em&gt;(x86/arm64)&amp;nbsp;_+ Druid 主要版本的严格交叉兼容测试，可放心平滑升级。&lt;/p&gt; 
&lt;p&gt;本次发布共修改文件数：341，累计提交代码 +19669−3374，合并 PR 数 87 个，共 28 人参与代码 Commit。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2.3.0 milestone：&lt;/strong&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fincubator-seata%2Fmilestone%2F36%3Fclosed%3D1" target="_blank"&gt;https://github.com/apache/incubator-seata/milestone/36?closed=1&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;seata-server &amp;amp; namingserver：&lt;/strong&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.apache.org%2Fdyn%2Fcloser.lua%2Fincubator%2Fseata%2F2.3.0%2Fapache-seata-2.3.0-incubating-src.tar.gz%3Faction%3Ddownload" target="_blank"&gt;https://www.apache.org/dyn/closer.lua/incubator/seata/2.3.0/apache-seata-2.3.0-incubating-src.tar.gz?action=download&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;docker image：&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Frepository%2Fdocker%2Fapache%2Fseata-server" target="_blank"&gt;https://hub.docker.com/repository/docker/apache/seata-server&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;部署指南：&lt;/strong&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fseata.apache.org%2Fzh-cn%2Fdocs%2Fops%2Fdeploy-guide-beginner" target="_blank"&gt;https://seata.apache.org/zh-cn/docs/ops/deploy-guide-beginner&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;升级指南：&lt;/strong&gt;&lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fseata.apache.org%2Fzh-cn%2Fdocs%2Fops%2Fupgrade" target="_blank"&gt;https://seata.apache.org/zh-cn/docs/ops/upgrade&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;版本更新&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Feature&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;[#6973] support saga annotation&lt;/li&gt; 
 &lt;li&gt;[#6876] support kingbase&lt;/li&gt; 
 &lt;li&gt;[#6881] support grpc&lt;/li&gt; 
 &lt;li&gt;[#6864] support shentong database&lt;/li&gt; 
 &lt;li&gt;[#6974] support fastjson2 undolog parser&lt;/li&gt; 
 &lt;li&gt;[#6992] support grpc serializer&lt;/li&gt; 
 &lt;li&gt;[#6904] add fastjson2 serializer support&lt;/li&gt; 
 &lt;li&gt;[#6926] support ssl communication for raft nodes&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Bugfix&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;[#6899] fix file.conf read failed after package&lt;/li&gt; 
 &lt;li&gt;[#6890] fix designerJson to standardJson: subStateMachinecompensateState cannot be recognized&lt;/li&gt; 
 &lt;li&gt;[#6907] fix the issue of Codecov not generating reports&lt;/li&gt; 
 &lt;li&gt;[#6923] enhance 401 Error Handling by Refreshing Token&lt;/li&gt; 
 &lt;li&gt;[#6925] fix the issue in Raft model a follower's crash may leadto the continued use of expired tokens&lt;/li&gt; 
 &lt;li&gt;[#6932] when enabling local transactions, the lock contentionfailure in file &amp;amp; raft mode does not exit, leading to a lingering lock&lt;/li&gt; 
 &lt;li&gt;[#6940] fix NacosRegistry lookup behaviortransactionServiceGroup is empty causing NPE error&lt;/li&gt; 
 &lt;li&gt;[#6943] fix the conversion error for convertBranchSession in concurrent environment.&lt;/li&gt; 
 &lt;li&gt;[#6948] fix the CI build issue on the ARM64 platform&lt;/li&gt; 
 &lt;li&gt;[#6947] fix npe for nacos registry when look up address&lt;/li&gt; 
 &lt;li&gt;[#6984] support building docker image on openjdk23&lt;/li&gt; 
 &lt;li&gt;[#6994] fix the problem of building undoLog exception whenupdate join does not update data&lt;/li&gt; 
 &lt;li&gt;[#7005] fix the Raft NPE issue caused by two-phase concurrency&lt;/li&gt; 
 &lt;li&gt;[#7010] fix error while the "context" is key word in DM8 whendelete undolog&lt;/li&gt; 
 &lt;li&gt;[#7022] fix store.mode propertyin application.raft.example.yml&lt;/li&gt; 
 &lt;li&gt;[#7025] fix vGroupMappingManager is not init&lt;/li&gt; 
 &lt;li&gt;[#7044] fix tableMeta refresh after closed&lt;/li&gt; 
 &lt;li&gt;[#7117] fix prefix: seata.server.raft.ssl should not be null&lt;/li&gt; 
 &lt;li&gt;[#7127] fix branchType server decode error&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Optimize&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;[#6826] remove the branch registration operation of the XAread-only transaction&lt;/li&gt; 
 &lt;li&gt;[#6892] upgrade npmjs version in console module&lt;/li&gt; 
 &lt;li&gt;[#6883] remove write only object&lt;/li&gt; 
 &lt;li&gt;[#6892] upgrade npmjs version&lt;/li&gt; 
 &lt;li&gt;[#6889] correct word spelling errors&lt;/li&gt; 
 &lt;li&gt;[#6898] upgrade npmjs version in saga module&lt;/li&gt; 
 &lt;li&gt;[#6879] fix log argument mismatch issue&lt;/li&gt; 
 &lt;li&gt;[#6902] optimize readme docs&lt;/li&gt; 
 &lt;li&gt;[#6807] splitting MergedWarpMessage enhances the serverparallel processing capability&lt;/li&gt; 
 &lt;li&gt;[#6905] remove incompatible licenses at build time&lt;/li&gt; 
 &lt;li&gt;[#6906] h2 dependency adds test scope&lt;/li&gt; 
 &lt;li&gt;[#6911] fix some typos in project&lt;/li&gt; 
 &lt;li&gt;[#6918] use the openjdk image of eclipse-temurin as the baseimage&lt;/li&gt; 
 &lt;li&gt;[#6938] update online chat information in &lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2FREADME.md" target="_blank"&gt;README.md&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[#6950] remove JVM parameter &lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fapp.id" target="_blank"&gt;app.id&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[#6959] update the naming and description forthe seata-http-jakarta module&lt;/li&gt; 
 &lt;li&gt;[#6991] gRPC serialization default to Protobuf&lt;/li&gt; 
 &lt;li&gt;[#6993] optimize transaction metrics&lt;/li&gt; 
 &lt;li&gt;[#6995] upgrade outdate npmjs dependencies&lt;/li&gt; 
 &lt;li&gt;[#6996] optimize lock release logic in AT transaction mode&lt;/li&gt; 
 &lt;li&gt;[#7023] optimize fail fast, when all server not available&lt;/li&gt; 
 &lt;li&gt;[#7027] raft mode maintains the reload logic consistent withthe file&lt;/li&gt; 
 &lt;li&gt;[#6891] add StateType Enum&lt;/li&gt; 
 &lt;li&gt;[#7040] optimize the print info in ConfigurationFactory&lt;/li&gt; 
 &lt;li&gt;[#7046] remove the dependency conflict for spring-webmvc&lt;/li&gt; 
 &lt;li&gt;[#7043] finish rollback if sendResult/msg not found&lt;/li&gt; 
 &lt;li&gt;[#7051] add namingserver jib&lt;/li&gt; 
 &lt;li&gt;[#7054] In file mode when the lock cannot be acquired outputthe holder's xid&lt;/li&gt; 
 &lt;li&gt;[#7154] remove unused dependencies&lt;/li&gt; 
 &lt;li&gt;[#7153] upgrade tomcat-embed to 9.0.98&lt;/li&gt; 
 &lt;li&gt;[#7152] remove org.eclipse.jetty dependency&lt;/li&gt; 
 &lt;li&gt;[#7151] upgrade xstream to 1.4.21&lt;/li&gt; 
 &lt;li&gt;[#7017] remove dependency on seata-server module&lt;/li&gt; 
 &lt;li&gt;[#7155] refactor the code that does not comply with license requirements&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Test&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;[#6869] add unit tests for the seata-core module&lt;/li&gt; 
 &lt;li&gt;[#6927] add unit tests for the seata-rocketmq module&lt;/li&gt; 
 &lt;li&gt;[#7018] add unit tests for the seata-tm module&lt;/li&gt; 
 &lt;li&gt;[#7030] add unit tests for the seata-common module&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359857/seata-2-3-0</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359857/seata-2-3-0</guid>
      <pubDate>Fri, 11 Jul 2025 07:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>工信部将在 2025 世界人工智能大会上发布《国际人工智能开源合作倡议》</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;7 月 10 日，上海市政府新闻办举行 2025 世界人工智能大会暨人工智能全球治理高级别会议新闻发布会，介绍大会筹备进展情况。&lt;/p&gt; 
&lt;p&gt;工业和信息化部科技司副司长杜广达表示，本届大会上，工信部将总结国家人工智能产业发展和赋能应用的趋势和成果，推动国际交流合作。积极倡导全球人工智能的开源合作。以 DeepSeek 为代表的中国大模型，为全球用户提供了高质价比的人工智能产品服务，有力推动人工智能技术在全球的普及应用，向世界贡献了中国智慧。&lt;/p&gt; 
&lt;p&gt;为进一步推动全球共建开源生态，&lt;span style="color:#0000cc"&gt;&lt;strong&gt;工信部&lt;/strong&gt;&lt;/span&gt;将推动中国—金砖国家人工智能发展与合作中心建设，&lt;strong&gt;联合开放原子开源基金会、中国开发者网络、开源中国等机构&lt;/strong&gt;，在大会上发布&lt;strong&gt;&lt;span style="color:#0000cc"&gt;《国际人工智能开源合作倡议》&lt;/span&gt;&lt;/strong&gt;，号召全球以开源为纽带，共商技术创新路线，共促技术成果赋能，共建开放包容社区，共享时代发展红利。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;来源：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.thepaper.cn%2FnewsDetail_forward_31147953" target="_blank"&gt;澎湃新闻&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359852</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359852</guid>
      <pubDate>Fri, 11 Jul 2025 07:23:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Gitee Pipe：关键领域 DevSecOps 的核心引擎</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;blockquote&gt; 
 &lt;p&gt;作者：Gitee DevSecOps 团队，李颖萍，吴茂佳&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;软件工厂的核心是高效、安全，而关键领域行业的特殊性决定了软件工厂必须将安全与保密放在首位。Gitee Pipe 提供标准化的 CI/CD 流水线，通过自动化技术精准控制开发各环节，确保关键领域软件从代码提交到最终交付的全路安全、高效、稳定。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;关键领域软件交付的挑战&lt;/h2&gt; 
&lt;p&gt;关键领域软件关系国家安全与国防策略，对保密性、质量安全、合规性和期限成本等方面有极高要求，任何环节的缺陷都可能造成难以估量的损失。传统 CI/CD 流程难以完全应对这些复杂要求，需要更加系统、可控、可应对的方案。&lt;/p&gt; 
&lt;p&gt;Gitee Pipe 作为新一代自动化引擎，通过「安全左移、合规内建、智能协同」三位一体的技术架构，灵活编排和管理代码扫描、功能测试、编译构建、发布部署等工具类任务，实现软件从代码提交到产品部署的全流程自动化，助力企业实现高效、安全、智能的软件交付，成为解决关键领域软件交付难题的有力工具。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;Gitee Pipe：从标准化到智能化&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;标准化、自动化软件生产过程，实现合规计算&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Gitee Pipe 内置的检查模板培基于关键领域特殊需求，对软件开发过程进行精精细的模型化维护，包括代码质量、依赖管控、部署参数等各环节的规范设置，降低了人为操作风险，确保交付的稳定性。&lt;/p&gt; 
&lt;p&gt;&lt;img height="707" src="https://static.oschina.net/uploads/space/2025/0711/151512_UpCS_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;通过模块化脚本和工具，Gitee Pipe 可实现代码编译、单元测试、集成测试等重复性工作的全路封装。系统可自动引擎流水线，生成测试报告并反馈质量问题，同时节约人力成本，推动交付同步进入高效环节。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;生产过程安全可控，打造可跟踪生产设备&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Gitee Pipe 培基于 Gitee 代码库与制品库的安全能力，封共从代码评审、依赖拉取到制品部署全链路。通过 BuildData 体系，每次构建都有明确的代码、环境、依赖、压缩包、发布记录等数据支持，实现全链路可查可跟踪，减少调试或惊魂问题排查成本。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0711/151539_Io7V_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;智能协同交付，打通需求、代码、制品、部署&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Gitee Pipe 支持与需求管理、质量管理等第三方系统打通，实现信息得以流通，支撑团队高效协同。同时，通过系统合成，完成需求、代码、制品、部署的八连相接，打造四维跟踪体系，确保软件交付过程真正可精准控制。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;Pipe+AI：通向智能交付的新时代&lt;/h2&gt; 
&lt;p&gt;Gitee Pipe 添入自然语言处理技术后，支持开发人员通过自然语言指令操作流水线，例如输入「检查最近提交代码是否存在安全漏洞」，系统可自动启动代码扫描工作流程并给出结果。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0711/151553_izjT_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AI 还可根据正在执行的流水线情况，自动分析执行错误，给出修复建议；培基于历史执行数据，生成最佳模板和流程设置建议，推动流水线持续优化。未来还可改善安全防护设施，创建智能化安全运维体系，推动关键领域软件交付全链路向更智能、更安全、更高效方向发展。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0711/151604_RDas_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;Gitee DevSecOps 的现代化研发生态&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Gitee DevSecOps 是一站式国产化研发与交付平台，集成了代码托管（Code）、项目协作（Team）、持续集成（CI）、持续部署（CD）、代码安全（Scan）、数据洞察（Insight）等多项能力，致力于打造具备全生命周期管控能力的现代软件工厂。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0523/174619_MpFL_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitee.cn%2Ffactory" target="_blank"&gt;https://gitee.cn/factory&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;平台设计充分考虑关键领域行业对安全性、可控性、合规性的极高要求，具备以下核心特征：&lt;/p&gt; 
&lt;ul style="list-style-type:disc; margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;国产化适配与私有化部署能力：全面兼容国产操作系统与基础设施，支持灵活部署于内网环境，保障数据主权；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;全流程 DevSecOps 管控体系：代码从提交、审核、构建、扫描、部署到发布全流程可视、可追溯、安全可控；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;模块化产品结构：各能力模块（如 Code、Team、Repo、Pipe、Scan、Insight 等）可灵活组合、渐进集成，适配多样化团队与流程要求；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;深度可观测与度量体系：内置研发效能度量与数据洞察引擎，支撑管理者宏观掌控项目态势与交付健康度。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0516/162046_MD15_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;在多个国家级重大项目与关键领域单位落地实践中，Gitee DevSecOps 已成为构建「自主、可控、高效、安全」的软件工程体系的重要基石。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-825957ffbed1798ea7b6a37079fd6c99d18.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359849</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359849</guid>
      <pubDate>Fri, 11 Jul 2025 07:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>欧盟公布最终版《通用人工智能行为准则》</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;欧盟委员会 10 日公布《通用人工智能行为准则》最终版本，旨在帮助企业遵守欧盟《人工智能法案》的相关规定。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;该准则为通用人工智能模型提供透明度、版权及安全与保障三方面的自律指导，适用于包括美国开放人工智能研究中心的 ChatGPT、谷歌的 Gemini、「元」公司的 Llama 以及 xAI 公司推出的 Grok 等主流通用人工智能模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据欧盟《人工智能法案》，通用人工智能模型是指能执行广泛任务并可被集成至下游应用系统的人工智能模型。这类模型通常基于大规模、多样化的数据集进行训练，是语言生成、多模态内容创作等人工智能服务的核心。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;欧盟委员会表示，最终版本的准则由 13 位独立专家起草，采纳了包括人工智能开发者、学术界、民间组织、版权持有者以及安全专家等 1000 多位利益相关方的意见和建议。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;据悉，该准则仍需获得欧盟成员国及欧盟委员会批准。欧盟称届时企业可自愿签署，以减少行政负担并获得更大的法律确定性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;欧盟的《人工智能法案》于去年正式生效，其中有关通用人工智能的治理与合规条款将于今年 8 月 2 日起正式实施。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359848</guid>
      <pubDate>Fri, 11 Jul 2025 07:17:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源流存储项目 Fluss 正式加入 Apache 孵化器</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;由阿里巴巴开源并捐赠的新一代流存储 Fluss 项目，顺利通过了投票，正式成为全球最大的开源基金会 Apache 软件基金会（ASF）的孵化项目！这是 Fluss 社区发展的重要里程碑，标志着项目迈入更加开放、中立和规范的新阶段。未来，Fluss 将依托 Apache 生态，加速构建全球化的开发者社区，持续推动新一代实时数据基础设施的创新与落地。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//d6c9e868f11150ce9ea8e7b7d7dbc218.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Fluss 社区已于近日完成了所有捐赠的流程，并将 Fluss 项目正式移交到了 Apache 软件基金会名下。在 7 月 3 日于新加坡举办的 Flink Forward Asia 2025 的主题演讲中，项目发起人，伍翀（云邪）正式宣布了这一激动的消息，并分享了新仓库地址（https://github.com/apache/fluss/）和官方网站域名（https://fluss.apache.org/）。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//3e3dddc4fea638df872e33210fbe0e3b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;什么是 Fluss？&lt;/h2&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//8f73383e6304d7500811bc429a200f70.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Fluss 是一款面向实时分析场景设计的下一代流存储引擎，致力于解决传统流存储技术在流计算、Lakehouse 等分析场景中面临的高成本与低效率问题。它具备以下核心特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;列式流存储：支持毫秒级延迟的实时流读流写能力，以 Apache Arrow 列存格式存储实时流数据，通过列裁剪、分区裁剪等查询下推技术，可提升 10 倍读取性能并降低网络成本。&lt;/li&gt; 
 &lt;li&gt;实时更新与点查：创新性地将实时更新能力引入流存储中。通过高性能流式更新、部分列更新、binlog、维表点查以及 DeltaJoin 等特性，高效协同 Flink 构建低成本流式实时数仓。&lt;/li&gt; 
 &lt;li&gt;湖流一体：湖与流一体化存储，实现数据共享。Lakehouse 为流存储提供低成本的历史数据支持，而流存储则为 Lakehouse 注入实时数据能力，带来实时数据分析的体验，构建流批一体秒级湖仓。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;Fluss 的发展历史与现状&lt;/h2&gt; 
&lt;p&gt;2023 年 7 月，阿里云智能 Flink 团队正式启动了 Fluss 项目。项目名称源自 "&lt;strong&gt;Fl&lt;/strong&gt;ink&lt;strong&gt;U&lt;/strong&gt;nified&lt;strong&gt;S&lt;/strong&gt;treaming&lt;strong&gt;S&lt;/strong&gt;torage"的缩写，寓意为 Apache Flink 打造统一的流式存储底座。巧合的是，"Fluss"在德语中意为" 河流 "，正如源源不断的数据流。&lt;/p&gt; 
&lt;p&gt;经过一年多的内部孵化与打磨，2024 年 11 月 29 日，在上海举办的 Flink Forward Asia 2024 大会主题演讲中，阿里巴巴正式宣布&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU3Mzg4OTMyNQ%3D%3D%26mid%3D2247512139%26idx%3D2%26sn%3D43f5f39c8b78ac340b5b2486e9aab82a%26scene%3D21%23wechat_redirect" target="_blank"&gt;开源 Fluss 项目&lt;/a&gt;。自此，Fluss 迎来了多元化的国际化发展，吸引了来自全球的 60 多位开发者贡献代码，社区活跃度持续提升，平均每三个月发布一个重大版本。&lt;/p&gt; 
&lt;p&gt;与此同时，Fluss 在阿里巴巴集团内部也实现了大规模落地应用。目前，已支持超过 3 PB 数据规模，集群吞吐峰值达 40 GB/s，最大单表点查 QPS 达到 50 万次 / 秒，单表数据量最高可达 5000 亿条。在日志流量分析、搜索推荐、实时数仓等关键业务场景，Fluss 展现出卓越的性能与能力。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//858f7e5fbeedce0ed1d8a419a7806f3f.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;为什么加入 ASF 孵化器？&lt;/h2&gt; 
&lt;p&gt;Apache 软件基金会是全球开源大数据技术的摇篮，孕育了众多改变世界的项目：Hadoop, Spark, Iceberg, Kafka, Flink 等。Fluss 期待加入 ASF，成为改变未来实时基础设施的一员。与此同时，Fluss 与这些 Apache 项目之间有着深度集成的需求，加入 ASF 能够加速与生态集成的进程。更重要的是，ASF 所倡导的 "开放、协作、中立" 理念，与 Fluss 的发展愿景高度契合。通过加入 Apache 孵化器，Fluss 不仅延续这一开源精神，也将融入更广阔的开发者社区，获得更完善的治理机制与可持续发展的坚实保障。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359845</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359845</guid>
      <pubDate>Fri, 11 Jul 2025 06:52:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MiniCPM 端侧客户端正式发布并开源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniCPM 端侧客户端已正式&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0J_CpJpvaKAP61oK1RjnGg" target="_blank"&gt;发布&lt;/a&gt;。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;全面支持 Intel Core Ultra 系列处理器本地部署，低延迟、高效率、隐私更安全。&lt;/li&gt; 
 &lt;li&gt;基于 OpenVINO 推理框架深度优化，推理速度至高可达每秒 80 tokens！&lt;/li&gt; 
 &lt;li&gt;专为开发者、研究人员与 AI 爱好者打造的本地大模型新体验。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0711/144320_ZE4E_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;主要功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持，与模型进行文本&amp;amp;图片对话&lt;/li&gt; 
 &lt;li&gt;支持，调用 Intel 集成显卡加速&lt;br&gt; 支持模型： 
  &lt;ul&gt; 
   &lt;li&gt;MiniCPM 4.0 8B &amp;amp; 0.5B&lt;/li&gt; 
   &lt;li&gt;MiniCPM 3.0 4B&lt;/li&gt; 
   &lt;li&gt;MiniCPM-V 2.6 8B（多模态）&lt;/li&gt; 
   &lt;li&gt;MiniCPM-V 2.0 2.8B（多模态）&lt;/li&gt; 
   &lt;li&gt;MiniCPM-2B-128K&lt;/li&gt; 
   &lt;li&gt;MiniCPM-1B-SFT-BF16&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;配置要求：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;建议使用英特尔酷睿 ultra7 及以上移动端处理器&lt;/li&gt; 
 &lt;li&gt;建议运行内存 32GB 及以上&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下载地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenBMB%2FMiniCPM%2Freleases%2Ftag%2F2.4.2" target="_blank"&gt;https://github.com/OpenBMB/MiniCPM/releases/tag/2.4.2&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359843</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359843</guid>
      <pubDate>Fri, 11 Jul 2025 06:46:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>vivo Pulsar 万亿级消息处理实践（3）-KoP 指标异常修复</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互联网大数据团队- Chen Jianbo&lt;/p&gt; 
 &lt;p&gt;本文是《vivo Pulsar 万亿级消息处理实践》系列文章第 3 篇。&lt;/p&gt; 
 &lt;p&gt;Pulsar 是 Apache 基金会的开源分布式流处理平台和消息中间件，它实现了 Kafka 的协议，可以让使用 Kafka API 的应用直接迁移至 Pulsar，这使得 Pulsar 在 Kafka 生态系统中更加容易被接受和使用。KoP 提供了从 Kafka 到 Pulsar 的无缝转换，用户可以使用 Kafka API 操作 Pulsar 集群，保留了 Kafka 的广泛用户基础和丰富生态系统。它使得 Pulsar 可以更好地与 Kafka 进行整合，提供更好的消息传输性能、更强的兼容性及可扩展性。vivo 在使用 Pulsar KoP 的过程中遇到过一些问题，本篇主要分享一个分区消费指标缺失的问题。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;系列文章：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247501335%26idx%3D1%26sn%3D3701be0b8b7b789e29c1ca53ba142e9d%26scene%3D21%23wechat_redirect" target="_blank"&gt;vivo Pulsar 万亿级消息处理实践（1）-数据发送原理解析和性能调优&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247501426%26idx%3D1%26sn%3D76c04879cfa2c6b38a731b5c49f19d3a%26scene%3D21%23wechat_redirect" target="_blank"&gt;vivo Pulsar 万亿级消息处理实践（2）-从 0 到 1 建设 Pulsar 指标监控链路&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;文章太长？1 分钟看图抓住核心观点👇&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//9cc55a5274f293b9c0ef2789a68fa19c.gif" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h1&gt;一、问题背景&lt;/h1&gt; 
&lt;p&gt;在一次版本灰度升级中，我们发现某个使用 KoP 的业务 topic 的消费速率出现了显著下降，具体情况如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7459cc8dccb2e8b05af39aa90db0851bbe7.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;什么原因导致正常的升级重启服务器会出现这个问题呢？直接查看上报采集的数据报文：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;kop_server_MESSAGE_OUT{group="",partition="0",tenant="kop",topic="persistent://kop-tenant/kop-ns/service-raw-stats"} 3
kop_server_BYTES_OUT{group="",partition="0",tenant="kop",topic="persistent://kop-tenant/kop-ns/service-raw-stats"} 188
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我们看到，KoP 消费指标 kop_server_MESSAGE&lt;/p&gt; 
&lt;p&gt;_OUT、kop_server_BYTES_OUT 是有上报的，但指标数据里的 group 标签变成了空串（缺少消费组名称），分区的消费指标就无法展示了。是什么原因导致了消费组名称缺失？&lt;/p&gt; 
&lt;h1&gt;二、问题分析&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;1、找到问题代码&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;我们去找下这个消费组名称是在哪里获取的，是否逻辑存在什么问题。根据 druid 中的 kop_subscription 对应的消费指标 kop_server_&lt;/p&gt; 
&lt;p&gt;MESSAGE_OUT、kop_server_BYTES_OUT，找到相关代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private void handleEntries(final List&amp;lt;Entry&amp;gt; entries,
                               final TopicPartition topicPartition,
                               final FetchRequest.PartitionData partitionData,
                               final KafkaTopicConsumerManager tcm,
                               final ManagedCursor cursor,
                               final AtomicLong cursorOffset,
                               final boolean readCommitted) {
....
        // 处理消费数据时，获取消费组名称
        CompletableFuture&amp;lt;String&amp;gt; groupNameFuture = requestHandler
                .getCurrentConnectedGroup()
                .computeIfAbsent(clientHost, clientHost -&amp;gt; {
                    CompletableFuture&amp;lt;String&amp;gt; future = new CompletableFuture&amp;lt;&amp;gt;();
                    String groupIdPath = GroupIdUtils.groupIdPathFormat(clientHost, header.clientId());
                    requestHandler.getMetadataStore()
                            .get(requestHandler.getGroupIdStoredPath() + groupIdPath)
                            .thenAccept(getResultOpt -&amp;gt; {
                                if (getResultOpt.isPresent()) {
                                    GetResult getResult = getResultOpt.get();
                                    future.complete(new String(getResult.getValue() == null
                                            ? new byte[0] : getResult.getValue(), StandardCharsets.UTF_8));
                                } else {
                                    // 从 zk 节点 /client_group_id/xxx 获取不到消费组，消费组就是空的
                                    future.complete("");
                                }
                            }).exceptionally(ex -&amp;gt; {
                                future.completeExceptionally(ex);
                                return null;
                            });
                    returnfuture;
                });

        // this part is heavyweight, and we should not execute in the ManagedLedger Ordered executor thread
        groupNameFuture.whenCompleteAsync((groupName, ex) -&amp;gt; {
            if (ex != null) {
                log.error("Get groupId failed.", ex);
                groupName = "";
            }
.....
            // 获得消费组名称后，记录消费组对应的消费指标
            decodeResult.updateConsumerStats(topicPartition,
                    entries.size(),
                    groupName,
                    statsLogger);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;代码的逻辑是，从 requestHandler 的 currentConnectedGroup(map) 中通过 host 获取 groupName，不存在则通过 MetadataStore（带缓存的 zk 存储对象）获取，如果 zk 缓存也没有，再发起 zk 读请求（路径为/client_group_id/host-clientId）。读取到消费组名称后，用它来更新消费组指标。从复现的集群确定走的是这个分支，即是从 metadataStore(带缓存的 zk 客户端) 获取不到对应 zk 节点/client_group_id/xxx。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、查找可能导致 zk 节点/client_group_id/xxx 节点获取不到的原因&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;有两种可能性：一是没写进去，二是写进去但是被删除了。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    @Override
    protected void handleFindCoordinatorRequest(KafkaHeaderAndRequest findCoordinator,
                                                CompletableFuture&amp;lt;AbstractResponse&amp;gt; resultFuture) {
...
        // Store group name to metadata store for current client, use to collect consumer metrics.
        storeGroupId(groupId, groupIdPath)
                .whenComplete((stat, ex) -&amp;gt; {
                    if (ex != null) {
                        // /client_group_id/xxx 节点写入失败
                        log.warn("Store groupId failed, the groupId might already stored.", ex);
                    }
                    findBroker(TopicName.get(pulsarTopicName))
                            .whenComplete((node, throwable) -&amp;gt; {
                                ....
                            });
                });
...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;从代码看到，clientId 与 groupId 的关联关系是通过 handleFindCoordinatorRequest（FindCoordinator）写进去的，而且只有这个方法入口。由于没有找到 warn 日志，排除了第一种没写进去的可能性。看看删除的逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;protected void close(){
    if (isActive.getAndSet(false)) {
        ...
        currentConnectedClientId.forEach(clientId -&amp;gt; {
            String path = groupIdStoredPath + GroupIdUtils.groupIdPathFormat(clientHost, clientId);
            // 删除 zk 上的 /client_group_id/xxx 节点
            metadataStore.delete(path, Optional.empty())
                    .whenComplete((__, ex) -&amp;gt; {
                        if (ex != null) {
                            if (ex.getCause() instanceof MetadataStoreException.NotFoundException) {
                                if (log.isDebugEnabled()) {
                                    log.debug("The groupId store path doesn't exist. Path: [{}]", path);
                                }
                                return;
                            }
                            log.error("Delete groupId failed. Path: [{}]", path, ex);
                            return;
                        }
                        if (log.isDebugEnabled()) {
                            log.debug("Delete groupId success. Path: [{}]", path);
                        }
                    });
        });
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;删除是在 requsetHandler.close 方法中执行，也就是说连接断开就会触发 zk 节点删除。&lt;/p&gt; 
&lt;p&gt;但有几个&lt;strong&gt;疑问：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;/client_group_id/xxx 到底是干嘛用的？消费指标为什么要依赖它&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;为什么要在 handleFindCoordinatorRequest 写入？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;节点/client_group_id/xxx 为什么要删除，而且是在连接断开时删除，删除时机是否有问题？&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;首先回答第 1 个问题，通过阅读代码可以知道，/client_group_id/xxx 这个 zk 节点是用于在不同 broker 实例间交换数据用的 (相当 redis cache)，用于临时存放 IP+clientId 与 groupId 的映射关系。由于 fetch 接口（拉取数据）的 request 没有 groupId 的，只能依赖加入 Group 过程中的元数据，在 fetch 消费时才能知道当前拉数据的 consumer 是哪个消费组的。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ffc0dfd7d8ea6675518bf1a2621d6f9be67.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3、复现&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;若要解决问题，最好能够稳定地复现出问题，这样才能确定问题的根本原因，并且确认修复是否完成。&lt;/p&gt; 
&lt;p&gt;因为节点是在 requsetHandle.close 方法中执行删除，broker 节点关闭会触发连接关闭，进而触发删除。假设：客户端通过 brokerA 发起 FindCoordinator 请求，写入 zk 节点/client_group&lt;/p&gt; 
&lt;p&gt;_id/xxx，同时请求返回 brokerB 作为 Coordinator，后续与 brokerB 进行 joinGroup、syncGroup 等交互确定消费关系，客户端在 brokerA、brokerB、brokerC 都有分区消费。这时重启 brokerA，分区均衡到 BrokerC 上，但此时/client_group_id/xxx 因关闭 broker 而断开连接被删除，consumer 消费刚转移到 topic1-partition-1 的分区就无法获取到 groupId。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-9beb2b836116dbb5a58a6e794e16d006de7.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;按照假设，有 3 个 broker，开启生产和消费，通过在 FindCoordinator 返回前获取 node.leader() 的返回节点 BrokerB，关闭 brokerA 后，brokerC 出现断点复现，再关闭 brokerC，brokerA 也会复现（假设分区在 brokerA 与 brokerC 之间转移）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//48e469db783cf92252e89bf874a31591.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;复现要几个条件：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;broker 数量要足够多 (不小于 3 个）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;broker 内部有 zk 缓存 metadataCache 默认为 5 分钟，可以把时间调小为 1 毫秒，相当于没有 cache&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;findCoordinator 返回的必须是其他 broker 的 IP&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;重启的必须是接收到 findCoordinator 请求那台 broker，而不是真正的 coordinator，这时会从 zk 删除节点&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;分区转移到其他 broker，这时新的 broker 会重新读取 zk 节点数据&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;到此，我们基本上清楚了问题原因：连接关闭导致 zk 节点被删除了，别的 broker 节点需要时就读取不到了。那怎么解决？&lt;/p&gt; 
&lt;h1&gt;三、问题解决&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;既然知道把消费者与 FindCoordinator 的连接进行绑定不合适的，那么是否应该把 FindCoordinator 写入 zk 节点换成由 JoinGroup 写入，断连即删除。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e408f5ca0dd6d8ce1dacd59b9e1d1067.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;consumer 统一由 Coordinator 管理，由于 FindCoordinator 接口不一定是 Coordinator 处理的，如果换成由 Coordinator 处理的 JoinGroup 接口是否就可以了，这样 consumer 断开与 Coordinator 的连接就应该删除数据。但实现验证时却发现，客户端在断连后也不会再重连，所以没法重新写入 zk，不符合预期。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;还是由 FindCoordinator 写入 zk 节点，但删除改为 GroupCoordinator 监听 consumer 断开触发。&lt;/p&gt; 
&lt;p&gt;因为 consumer 统一由 Coordinator 管理，它能监听到 consumer 加入或者离开。GroupCoordinator 的 removeMemberAndUpdateGroup 方法是 coordinator 对 consumer 成员管理。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private void removeMemberAndUpdateGroup(GroupMetadata group,
                                        MemberMetadata member) {
    group.remove(member.memberId());
    switch (group.currentState()) {
        case Dead:
        case Empty:
            return;
        case Stable:
        case CompletingRebalance:
            maybePrepareRebalance(group);
            break;
        case PreparingRebalance:
            joinPurgatory.checkAndComplete(new GroupKey(group.groupId()));
            break;
        default:
            break;
    }
    // 删除 /client_group_id/xxx 节点
    deleteClientIdGroupMapping(group, member.clientHost(), member.clientId());
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;调用入口有两个，其中 handleLeaveGroup 是主动离开，onExpireHeartbeat 是超时被动离开，客户端正常退出或者宕机都可以调用 removeMemberAndUpdateGroup 方法触发删除。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public CompletableFuture&amp;lt;Errors&amp;gt; handleLeaveGroup(
    String groupId,
    String memberId
) {
    return validateGroupStatus(groupId, ApiKeys.LEAVE_GROUP).map(error -&amp;gt;
        CompletableFuture.completedFuture(error)
    ).orElseGet(() -&amp;gt; {
        return groupManager.getGroup(groupId).map(group -&amp;gt; {
            return group.inLock(() -&amp;gt; {
                if (group.is(Dead) || !group.has(memberId)) {
                    return CompletableFuture.completedFuture(Errors.UNKNOWN_MEMBER_ID);
                } else {
                    ...
                
                    // 触发删除消费者 consumer
                    removeMemberAndUpdateGroup(group, member);
                    return CompletableFuture.completedFuture(Errors.NONE);
                }
            });
        })
        ....
    });
}

void onExpireHeartbeat(GroupMetadata group,
                       MemberMetadata member,
                       long heartbeatDeadline) {
    group.inLock(() -&amp;gt; {
        if (!shouldKeepMemberAlive(member, heartbeatDeadline)) {
            log.info("Member {} in group {} has failed, removing it from the group",
                member.memberId(), group.groupId());
            // 触发删除消费者 consumer
            removeMemberAndUpdateGroup(group, member);
        }
        return null;
    });
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;但这个方案有个问题是，日志运维关闭 broker 也会触发一个 onExpireHeartbeat 事件删除 zk 节点，与此同时客户端发现 Coordinator 断开了会马上触发 FindCoordinator 写入新的 zk 节点，但如果删除晚于写入的话，会导致误删除新写入的节点。我们干脆在关闭 broker 时，使用 ShutdownHook 加上 shuttingdown 状态防止关闭 broker 时删除 zk 节点，只有客户端断开时才删除。&lt;/p&gt; 
&lt;p&gt;这个方案修改上线半个月后，还是出现了一个客户端的消费指标无法上报的情况。后来定位发现，如果客户端因 FullGC 出现卡顿情况，客户端可能会先于 broker 触发超时，也就是先超时的客户端新写入的数据被后监听到超时的 broker 误删除了。因为写入与删除并不是由同一个节点处理，所以无法在进程级别做并发控制，而且也无法判断哪次删除对应哪次的写入，所以用 zk 也是很难实现并发控制。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;方案三&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;其实这并不是新的方案，只是在方案二基础上优化：数据一致性检查。&lt;/p&gt; 
&lt;p&gt;既然我们很难控制好写入与删除的先后顺序，我们可以做数据一致性检查，类似于交易系统里的对账。因为 GroupCoordinator 是负责管理 consumer 成员的，维护着 consumer 的实时状态，就算 zk 节点被误删除，我们也可以从 consumer 成员信息中恢复，重新写入 zk 节点。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;private void checkZkGroupMapping(){  
    for (GroupMetadata group : groupManager.currentGroups()) {  
        for (MemberMetadata memberMetadata : group.allMemberMetadata()) {  
            String clientPath = GroupIdUtils.groupIdPathFormat(memberMetadata.clientHost(), memberMetadata.clientId());  
            String zkGroupClientPath = kafkaConfig.getGroupIdZooKeeperPath() + clientPath;  
            // 查找 zk 中是否存在节点
            metadataStore.get(zkGroupClientPath).thenAccept(resultOpt -&amp;gt; {  
                if (!resultOpt.isPresent()) {  
                    // 不存在则进行补偿修复
                    metadataStore.put(zkGroupClientPath, memberMetadata.groupId().getBytes(UTF\_8), Optional.empty())  
                            .thenAccept(stat -&amp;gt; {  
                                log.info("repaired clientId and group mapping: {}({})",  
                                        zkGroupClientPath, memberMetadata.groupId());  
                            })  
                            .exceptionally(ex -&amp;gt; {  
                                log.warn("repaired clientId and group mapping failed: {}({})",  
                                        zkGroupClientPath, memberMetadata.groupId());  
                                return null;  
                            });  
                }  
            }).exceptionally(ex -&amp;gt; {  
                log.warn("repaired clientId and group mapping failed: {} ", zkGroupClientPath, ex);  
                return null;  
            });  
        }  
    }  
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;经过方案三的优化上线，即使是历史存在问题的消费组，个别分区消费流量指标缺少 group 字段的问题也得到了修复。具体效果如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//67385096ca5f780cc62269343e58cde7.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h1&gt;四、总结&lt;/h1&gt; 
&lt;p&gt;经过多个版本的优化和线上验证，最终通过方案三比较完美的解决了这个消费指标问题。在分布式系统中，并发问题往往难以模拟和复现，我们也在尝试多个版本后才找到有效的解决方案。如果您在这方面有更好的经验或想法，欢迎提出，我们共同探讨和交流。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/vivotech/blog/18684129</link>
      <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18684129</guid>
      <pubDate>Fri, 11 Jul 2025 03:47:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Visual Studio Code 1.102 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Visual Studio Code 1.102 现已&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102" target="_blank"&gt;发布&lt;/a&gt;&lt;span style="color:#000000"&gt;，此版本包含多项更新。具体更新内容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;span style="color:#333333"&gt;Chat&lt;/span&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;探索并为开源 GitHub Copilot Chat 扩展做出贡献（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fblogs%2F2025%2F06%2F30%2FopenSourceAIEditorFirstMilestone" target="_blank"&gt;阅读博客文章&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;生成反映项目惯例的自定义说明（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_generate-custom-instructions" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;使用自定义模式来定制聊天以适应规划或研究等任务（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_chat-mode-improvements" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;自动批准选定的终端命令（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_terminal-auto-approval-experimental" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;编辑并重新提交之前的聊天请求（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_edit-previous-requests-experimental" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;MCP&lt;/strong&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;MCP 支持现已在 VS Code 中普遍可用（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_mcp-support-in-vs-code-is-generally-available" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;使用 MCP 视图和图库轻松安装和管理 MCP 服务器（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_mcp-server-discovery-and-installation" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;MCP 服务器作为配置文件和 Settings Sync 中的一流资源（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_mcp-servers-as-first-class-resources" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;Editor experience&lt;/strong&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;将任务委托给 Copilot coding agent 并让其在后台处理（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_start-a-coding-agent-session-preview" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
   &lt;li&gt;单击鼠标中键滚动编辑器（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102%23_scroll-on-middle-click" target="_blank"&gt;显示更多&lt;/a&gt;）。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#333333"&gt;更多详情可&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.visualstudio.com%2Fupdates%2Fv1_102" target="_blank"&gt;查看官方公告&lt;/a&gt;&lt;span style="color:#333333"&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359807/vs-code-1-102-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359807/vs-code-1-102-released</guid>
      <pubDate>Fri, 11 Jul 2025 03:25:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>微软开源轻量级推理模型 Phi-4-mini-flash-reasoning</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软发布了一款专为受限环境设计、参数量仅为 3.8B 的轻量级开源模型 Phi-4-mini-flash-reasoning，其在数学推理任务上表现出色，且吞吐量大幅提升。&lt;/p&gt; 
&lt;p&gt;Phi-4-mini-flash-reasoning 专为在内存和计算资源受限的环境下执行高强度、多步骤的数学推理任务而设计。该模型采用了混合 SambaY 架构，结合了差分注意力、状态空间模型（SSM）和分组查询注意力（GQA），并支持 64K 的上下文长度。&lt;/p&gt; 
&lt;p&gt;Phi-4-mini-flash-reasoning 的训练数据完全由更强大的推理模型 Deepseek-R1 生成的合成数学内容构成，旨在从更强的模型中提炼知识。&lt;/p&gt; 
&lt;p&gt;在 AIME、Math500 和 GPQA Diamond 等多个数学推理基准测试中，Phi-4-mini-flash-reasoning 的表现与许多参数量远大于它的模型相当。与 Phi-4-mini-reasoning 相比，新模型在处理长序列生成任务时，吞吐量提升高达 10 倍，且延迟增长接近线性。&lt;/p&gt; 
&lt;p&gt;&lt;img height="787" src="https://static.oschina.net/uploads/space/2025/0711/111702_PrZL_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0711/111739_1PUS_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该模型已在 Hugging Face 上以 MIT 许可证发布，并可在 Azure AI Foundry 中使用。&lt;/p&gt; 
&lt;p&gt;https://huggingface.co/microsoft/Phi-4-mini-flash-reasoning&lt;br&gt; https://azure.microsoft.com/en-us/blog/reasoning-reimagined-introducing-phi-4-mini-flash-reasoning/&lt;br&gt; https://aka.ms/flashreasoning-paper&lt;br&gt; https://github.com/microsoft/PhiCookBook&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359805</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359805</guid>
      <pubDate>Fri, 11 Jul 2025 03:17:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>可灵 AI 上线可图 2.1 模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;可灵 AI 上线可图 2.1 模型，在指令遵循能力、响应能力等方面进行了升级，同时新模型还进一步增强了文字生成效果。新模型的推出让会员用户能够在 7 月 17 日之前免费体验，为用户提供了文生图、单图参考和多图参考等核心功能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="326" src="https://oscimg.oschina.net/oscnet/up-8e8dcbf6bf63f5ea25a5b01a05b97ae1da9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;可图 2.1 在理解复杂指令方面表现突出，可以准确捕捉提示词中的各种元素和逻辑关系。例如，当输入 「3D 微缩沙盘模型，展示其独特的横截面剖面，海底火山爆发的剧烈瞬间，史诗级灾难场景，CG 特效，光影对比，冷暖对比」 时，生成的图像清晰展现了宏大的灾难场景，并通过光影和色调的细腻处理，真实再现了火山爆发的震撼瞬间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在画面质量方面，模型在清晰度、元素丰富度和细节真实感等方面均取得了突破。特别是在展示人像时，无论是水下摄影中一位少女的光影效果，还是复古风格照片中女性的优雅姿态，均能细腻呈现。模型还具备生成电影质感图像的能力，能够通过高级构图与光影色彩运用，为画面赋予强烈的美学调性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，文字生成能力的提升使得用户可以快速生成清晰、设计感十足的中英文文字，这对制作海报、电影宣传和唱片封面等创意内容非常有帮助。可图 2.1 支持超过 180 种风格响应，涵盖特殊材质、数字艺术和绘画技法等类型。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359804</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359804</guid>
      <pubDate>Fri, 11 Jul 2025 03:17:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源 AI 客户端 Cherry Studio v1.4.9 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Cherry Studio 是一款支持多个大语言模型（LLM）服务商的开源桌面客户端，兼容 Windows、Mac 和 Linux 系统。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-23dab8c50bfcc8126ab84229b00dbc2115c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;该项目近日发布新版本 v1.4.9，并&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FRhP7FTPlU3KvCS8xoq-Lqg" target="_blank"&gt;宣布&lt;/a&gt;与 New API 团队已达成官方合作。&lt;/p&gt; 
&lt;p&gt;现在，当您通过服务商选项添加自托管的 New API 服务时，将能无缝获得&lt;strong&gt;OpenAI、Gemini、Claude 等模型的原生 API 特性，并已全面支持图像生成任务。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;本次更新还带来了以下核心升级：&lt;/p&gt; 
&lt;p&gt;🚀&amp;nbsp;&lt;strong&gt;流畅度与性能升级：&lt;/strong&gt;引入了先进的虚拟列表技术，针对&lt;strong&gt;代码预览、可拖动列表&lt;/strong&gt;等多个界面进行了深度优化。现在，即使在处理海量数据或长代码块时，应用也能保持如丝般顺滑的操作体验，告别卡顿。&lt;/p&gt; 
&lt;p&gt;🧩&amp;nbsp;&lt;strong&gt;MCP 功能优化：&lt;/strong&gt;为了让复杂的任务流程更加透明，此版本针对 MCP 优化了&lt;strong&gt;工具调用的进度处理和状态更新机制&lt;/strong&gt;。当模型执行长时间任务时，您将能看到清晰的进度反馈，对任务状态了如指掌。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;其他重要更新：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;新功能&lt;/strong&gt;： 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;数据备份&lt;/strong&gt;： 新增 S3 对象存储备份与本地云目录备份功能，数据安全再加码。&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;设置项&lt;/strong&gt;： 新增「禁用硬件加速」选项、API Key 显示/隐藏开关，并允许为服务商自定义 Header。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;问题修复与稳定性&lt;/strong&gt;： 
  &lt;ul&gt; 
   &lt;li&gt;全面修复了网络搜索、引用格式、快捷短语数据库错误等一系列问题。&lt;/li&gt; 
   &lt;li&gt;解决了 Linux 系统开机自启动失败及特定场景下窗口无法显示的问题。&lt;/li&gt; 
   &lt;li&gt;提升了 GLM-4、Qwen3 等模型的识别准确性及程序在各类场景下的健壮性。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下载地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCherryHQ%2Fcherry-studio%2Freleases%2Ftag%2Fv1.4.9" target="_blank"&gt;https://github.com/CherryHQ/cherry-studio/releases/tag/v1.4.9&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359796/cherry-studio-1-4-9</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359796/cherry-studio-1-4-9</guid>
      <pubDate>Fri, 11 Jul 2025 02:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智谱上线类似 Manus 的 PPT 生成功能 AI Slides，免费使用无限制</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智谱悄然上线了一项全新的 PPT 生成功能 ——AI Slides。该功能借助最新的 GLM-Experimental 模型，能够根据用户提供的研究主题或文档，快速生成高质量的 PPT 展示。这一新功能目前可以免费使用，并且没有使用限制。&lt;/p&gt; 
&lt;p&gt;&lt;img height="277" src="https://oscimg.oschina.net/oscnet/up-db9e3a332510563defec56f8b09fe2d4950.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在使用 AI Slides 时，用户只需输入相关的主题或文档，该功能便会首先分析内容，生成结构大纲。这一过程确保了 PPT 的逻辑性与条理性。随后，系统会根据大纲自动生成各个页面，极大地简化了传统 PPT 制作过程中需要投入的时间和精力。&lt;/p&gt; 
&lt;p&gt;在排版效果上，AI Slides 生成的 PPT 结构清晰，主次分明，便于观众理解。此外，系统会运用图表展示数据，让信息的传达更加直观。同时，通过色块和字体颜色的巧妙运用，突出重点信息，并适当留白，使得整体布局更加协调。这些设计理念都充分考虑了观众的阅读体验，旨在提升 PPT 的观赏性和实用性。&lt;/p&gt; 
&lt;p&gt;目前，GLM-Experimental 模型尚未正式发布，但用户可以在智谱的聊天界面中进行体验。为了使用这一新功能，用户只需访问 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchat.z.ai" target="_blank"&gt;https://chat.z.ai&lt;/a&gt;，登录后切换到 GLM-Experimental 模型，并点击 「AI Slides」 图标即可开始制作。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359795</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359795</guid>
      <pubDate>Fri, 11 Jul 2025 02:38:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Windows 11 最新「黑屏死机」界面现已推出</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软现在开始将其蓝屏死机 (BSOD) 更改为全新设计的黑色版本。这是自微软在 Windows 8 中添加悲伤表情以来对 BSOD 的首次重大更改，删除表情和二维码后转而采用更简化的黑色屏幕。&lt;/p&gt; 
&lt;p&gt;新的 BSOD 现已向 Windows 11 Release Preview 用户推出，这意味着它将在几周内出现在所有 Windows 11 用户面前。简化的 BSOD 看起来很像您在 Windows 更新期间通常会看到的黑屏。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b6af25fcf60b165d0c0e8ddd4c0be715da0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;它会列出停止代码和故障系统驱动程序，方便 Windows 用户和 IT 管理员追溯电脑蓝屏死机 (BSOD) 的根源。「这实际上是为了更清晰地提供更准确的信息，让我们和客户能够真正了解问题的核心，以便更快地解决问题」，微软企业和操作系统安全副总裁 David Weston 在 6 月份时表示。&lt;/p&gt; 
&lt;p&gt;微软在 2021 年 Windows 11 测试版中曾短暂地将 BSOD 改为黑屏，但这次是永久性的。BSOD 的改变是 Windows 11 更新的一部分，该更新还包含微软新的快速机器恢复 (QMR) 功能，该功能旨在快速恢复无法正常启动的机器。QMR 是微软在去年 CrowdStrike 事件后为提高 Windows 弹性而采取的更大努力的一部分。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/359790</link>
      <guid isPermaLink="false">https://www.oschina.net/news/359790</guid>
      <pubDate>Fri, 11 Jul 2025 02:22:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
