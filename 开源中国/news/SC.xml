<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 10 Sep 2025 07:42:18 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Redis 双向同步如何避免循环？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;在跨机房高可用、主备切换、混合云架构中，Redis 双向同步是一个常见需求。要实现数据库的双向同步，最大的挑战就是&lt;strong&gt;如何避免数据在两个实例之间无限循环&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;本文将从问题入手，带你了解双向同步防循环方案，并介绍一种更加高效、轻量的解决方式：基于事务标记的防循环模式，最后通过一个简单的实操演示，帮你快速上手。&lt;/p&gt; 
&lt;h2&gt;为什么双向同步会陷入循环&lt;/h2&gt; 
&lt;p&gt;我们以两个 Redis 实例 A 和 B 为例，同时配置了 A→B 和 B→A 的同步任务：&lt;/p&gt; 
&lt;p&gt;A 上的数据写入，会同步到 B。B 收到后，又会被同步回 A。如果没有循环检测机制，事件就会在 A、B 之间"打乒乓球"，循环往复。&lt;/p&gt; 
&lt;p&gt;在实现 MySQL、PostgreSQL 的双向同步功能中，CloudCanal 分别采用增量事件标记和事务记录实现循环事件过滤。任一方向的同步链路在收到新事件时都会判断事务中是否存在相应的标记，以此来选择是否&lt;strong&gt;过滤&lt;/strong&gt;这一事件，从而打破数据循环。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-eea1ad7acd5b9e77a7084fb451f515b94af.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;相较于 PostgreSQL 等传统数据库，Redis 本身的特点让其双向同步的实现变得复杂：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Redis 命令粒度小（如 &lt;code&gt;INCR key&lt;/code&gt;），并不总是事务&lt;/li&gt; 
 &lt;li&gt;Redis 的事务（&lt;code&gt;MULTI/EXEC&lt;/code&gt;）和传统关系型数据库事务不同，不具备完整的原子性&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;那么，该如何实现 Redis 的双向同步呢？&lt;/p&gt; 
&lt;h2&gt;方案一：辅助标记&lt;/h2&gt; 
&lt;p&gt;基于传统数据库双向同步的实现思路，在 Redis 双向同步的实践中，一种直观的防循环方案是&lt;strong&gt;通过辅助指令来进行循环判定&lt;/strong&gt;。当收到正常指令，计算其 hash 值，构建辅助指令 key，反向查询辅助指令是否存在，如果存在则为循环，过滤即可。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-870837336549833abec1778e8070d9ad6ce.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这种方式的优势是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;实现简洁&lt;/strong&gt;：逻辑清楚，能快速落地&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;适应性强&lt;/strong&gt;：无论 Redis 是单点部署还是集群部署，都能完成双向同步&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;但也存在不足：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;性能开销大&lt;/strong&gt;：对任意事件，理论上会将操作的命令数量放大为原来的 3 至 4 倍，增加了 Redis 的写压力&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;区分度有限&lt;/strong&gt;：在某些极端场景下，比如同时有应用在目标端执行了类似的写操作，反向任务很难区分这两条命令的来源，有可能导致误判，甚至丢失一次更新。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-87f7f998c24429071b3de02706397529e05.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;方案二：事务标记&lt;/h2&gt; 
&lt;p&gt;除了使用额外标记，另一种做法是&lt;strong&gt;借助 Redis 的事务机制&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;Redis 的事务（&lt;code&gt;MULTI ... EXEC&lt;/code&gt;）和关系型数据库的事务不同，它没有实现事务原子性中的回滚，但有一个关键特性：&lt;strong&gt;事务中的所有命令会按顺序执行，并且在执行期间不会插入执行来自其他客户端的命令&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;基于这个特性，对于正向任务，在接收到源端命令时，可将其包裹为事务，并在事务内第一条插入一条标记操作。反向任务发现这是一个事务，说明&lt;strong&gt;可能&lt;/strong&gt; 是来自正向任务的循环事件，通过判断事务内&lt;strong&gt;第一条事件&lt;/strong&gt;是否为标记即可。如果是，说明整个事务都是循环，直接过滤。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-21df555eab161f8fc23b73ae314b5ed99cb.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这种方式的优势是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;性能更优&lt;/strong&gt;：不需要为每条命令额外维护标记，系统开销小&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;逻辑简明&lt;/strong&gt;：通过检查事务开头即可快速判断，不必逐条比对&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Redis 压力小&lt;/strong&gt;:大多数过滤动作都在程序内执行，减少对数据库的压力&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b72918a9658e03d1e6f1de4ccd5b44a23cc.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;不过，需要注意的一点是：Redis 的事务在分片集群模式下有局限，不能跨分片执行，因此目前事务标记模式&lt;strong&gt;主要适用於单点或主从场景&lt;/strong&gt;。&lt;/p&gt; 
&lt;h2&gt;操作演示&lt;/h2&gt; 
&lt;p&gt;目前，CloudCanal 支持上述两种双向同步方案，可在控制枱通过设置参数&lt;code&gt;deCycleMode&lt;/code&gt;调整双向同步过滤事件模式。&lt;/p&gt; 
&lt;p&gt;感兴趣的话下面这个视频展示了使用 CloudCanal SaaS 版实操演示如何基于事务标记模式快速实现 Redis 的双向同步。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1VRYwzFEuw%2F%3Fvd_source%3D6c75624006c6c17e56e54da8ddbf6beb" title="Redis 双向同步实操：教你彻底解决数据循环问题" target="_blank"&gt;Redis 双向同步实操：教你彻底解决数据循环问题&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;效果验证&lt;/h2&gt; 
&lt;p&gt;成功进行双向同步后，可以进行防循环效果验证。&lt;/p&gt; 
&lt;p&gt;在源端数据库做数据变更，查看监控图表，可以看到，正向任务显示有变更，反向任务没有，即代表无数据循环。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0469326d32be6974251c96e4ee808952fa3.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-e9db4e8e9db5c351957deaea62681b6a1ce.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在目标端数据库做数据变更，查看监控图表，可以看到，反向任务显示有变更，正向任务没有，即代表无数据循环。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-817333477dd07fa886d1c58939e162d4e57.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-afdf83424d362a128beaad46a8e04c0376d.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;创建数据校验任务，可以看到，两端数据库的数据保持一致。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-66f2a6a4861d66c033616f559b2e8fa06fe.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;总结&lt;/h2&gt; 
&lt;p&gt;Redis 双向同步的最大难题，不在于能不能同步，而在于&lt;strong&gt;如何避免数据在两个实例之间无限循环&lt;/strong&gt; 。本文分析了辅助标记方案与事务标记方案，两种方案各有优劣势。对于大多数 &lt;strong&gt;单点或主从场景&lt;/strong&gt;，事务标记模式是更值得推荐的选择，既能保证正确性，也能兼顾系统开销。而对于分片集群场景，则可尝试辅助标记方案。&lt;/p&gt; 
&lt;p&gt;如果你正在规划设计 Redis 双向同步，欢迎使用 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.clougence.com%2F%3Fsrc%3Dcc-doc" target="_blank"&gt;CloudCanal SaaS 版&lt;/a&gt;快速上手体验。如果你对于数据双向同步有更多疑问，也欢迎留言讨论。&lt;/p&gt; 
&lt;p&gt;更多内容，欢迎关注公号：ClouGence&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5170379/blog/18691175</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5170379/blog/18691175</guid>
      <pubDate>Wed, 10 Sep 2025 07:35:11 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>微软 Office 365 计划采用 Anthropic AI 服务</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fmicrosoft-buy-ai-anthropic-shift-openai" target="_blank"&gt;根据 The Information 的独家报道&lt;/a&gt;，微软将向 AI 初创 Anthropic 购买技术。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-c44c4d3ec98f4093da7d304de222101ad4d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;报道称，微软旗下 Office 365 Copilot 软件将部分运行在 Anthropic 模型上，因为微软发现电子表格任务和 PowerPoint 简报在 Anthropic 模型上运行得比 OpenAI 模型更好。&lt;/p&gt; 
&lt;p&gt;这将打破 OpenAI 自 2023 年 1 月微软对其投资数十亿美元以来在微软内部的垄断地位。此前，OpenAI 的技术一直被用于微软生产力软件套件 (包括 Word、Excel、Outlook 和 PowerPoint) 的新功能开发。&lt;/p&gt; 
&lt;p&gt;AWS 是 Anthropic 模型的唯一提供商。报道称，作为协议的一部分，微软将向亚马逊 AWS 支付费用，以使用 Anthropic 的模型。&lt;/p&gt; 
&lt;p&gt;目前，微软 Azure 和 AWS 是全球最大的两家云计算服务提供商，其次是谷歌的 Cloud Platform。在生成式 AI 聊天机器人领域，OpenAI 的 ChatGPT 与 Anthropic 的 Claude 形成竞争。&lt;/p&gt; 
&lt;p&gt;微软与 OpenAI 在 OpenAI 拟重组其盈利部门的计划上，已经谈判数月。目前尚不清楚微软此次转向是否是一种谈判策略。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371330</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371330</guid>
      <pubDate>Wed, 10 Sep 2025 07:34:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Anthropic 官方确认 Claude 模型回复质量下降，现已修复</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Anthropic 官方&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fclaudeai%2Fstatus%2F1965208249399177655" target="_blank"&gt;宣布&lt;/a&gt;，已发现并成功解决了两个导致 Claude 系列模型回复质量下降的问题，并强调公司从未因需求或成本因素故意降低模型质量。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0910/151146_CDWO_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，第一个问题在 8 月 5 日至 9 月 4 日期间影响了少量 Claude Sonnet 4 的请求，并在 8 月 29 日后影响范围有所扩大。第二个问题则从 8 月 26 日至 9 月 5 日波及了部分 Claude Haiku 3.5 与 Claude Sonnet 4 的请求。&lt;/p&gt; 
&lt;p&gt;目前，针对这些问题的修复版本已全面部署。公司表示正持续监控包括 Claude Opus 4.1 在内的所有模型质量。&lt;/p&gt; 
&lt;p&gt;官方公告中提到，社区用户的详细反馈帮助团队迅速定位并隔离了缺陷。公告还直接回应了「降智省成本」的质疑，表示质量问题绝非有意为之。此次事件影响范围包括 claude.ai、console.anthropic.com、api.anthropic.com 以及 Claude Code 服务。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371326</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371326</guid>
      <pubDate>Wed, 10 Sep 2025 07:17:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>上海交大发布 MobiAgent：人人都能拥有自己的 AI 助手</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;上海交通大学的 IPADS 实验室团队推出了一款名为 MobiAgent 的全新移动端智能体工具链，打破了个人化智能助手的开发壁垒，声称其真实场景表现优于 GPT-5 和其他顶级闭源模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;em&gt;&lt;strong&gt;论文地址：&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2509.00531" target="_blank"&gt;https://arxiv.org/pdf/2509.00531&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;MobiAgent 的推出让每个人都有机会培养属于自己的 AI 助手。这个工具链支持用户从零开始构建移动端智能体，包括从收集操作数据到训练模型，再到将模型部署到手机上的完整流程。MobiAgent 的开源性质，意味着用户可以自主获取数据、训练模型，并在个人设备上实现智能助手的应用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="266" src="https://oscimg.oschina.net/oscnet/up-7cbc19225bd2276ffc019f279139d3d74d4.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;为了验证 MobiAgent 的实际能力，研究团队在国内 20 款热门应用中进行了测试，结果显示，7B 规模的 MobiAgent 模型在任务完成评分上，不仅超越了多款知名闭源大模型，甚至在同规模的开源 GUI 智能体中也处于领先地位。MobiAgent 独特的 「潜记忆加速器」 能够通过学习历史操作，帮助智能体快速完成重复任务，性能提升达到 2-3 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;MobiAgent 的核心在于其高效的数据收集和智能训练流程。它通过轻量级工具记录用户的手机操作，然后利用通用 VLM 模型生成高质量的训练数据。这些数据经过精炼调整，确保训练出的智能体具有出色的泛化能力。MobiAgent 的 「大脑」 被分为三部分:负责任务规划的 「规划师」、根据当前屏幕做出决策的 「决策者」 以及执行具体操作的 「执行者」。这样的架构让模型训练更加高效，反应速度大幅提升。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;通过创新的 AgentRR 加速框架，MobiAgent 能够借助以往的操作经验，大幅提升重复任务的执行效率，最高可实现 60%-85% 的动作复用率。这使得智能助手在处理日常事务时更加迅速、准确。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371325</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371325</guid>
      <pubDate>Wed, 10 Sep 2025 07:17:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>大神手把手教学丨 Windows 应用秒变玲珑包！完整攻略来了</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;今天，我们将为大家带来该系列的第二篇实战教程——&lt;/span&gt;
  &lt;strong&gt;&lt;strong&gt;如何利用「统信 Windows 应用兼容引擎」将应用打包成 deb，再转化成玲珑包。&lt;/strong&gt;&lt;/strong&gt;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;一、下载目标 Windows 应用&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;首先，选择您的目标 Windows 应用，并前往其官网下载官方 exe 安装包。本文我们以&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA5NzE0Mjg4Ng%3D%3D%26mid%3D2650457346%26idx%3D1%26sn%3Da305e17b663c13b5a1f6edfaf3b55594%26scene%3D21%23wechat_redirect" target="_blank"&gt;&lt;span&gt;「如意玲珑应用迁移与开发征募赛」&lt;/span&gt;&lt;/a&gt;&lt;span&gt;中定向编译应用列表中的「南财金融终端」应用为例。&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//dd8775200fa7174f66b6eeee94b3facf.jpg" width="115" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span&gt;二、运行并打包 Windows 应用&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;接下来需要在 deepin 上运行刚刚下载好的 exe 文件，此时我们可以借助官方所提供的 Windows 应用调试级打包工具——「统信 Windows 应用兼容引擎」来完成。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step1：安装「统信 Windows」应用兼容引擎&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;在 deepin 应用商店中搜索「统信 Windows 应用兼容引擎」并下载。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//d89ca0f067173309ede53c8b40e9ea57.jpg" width="1408" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step 2：安装目标 win 应用&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;使用兼容引擎，有两种方式安装 exe 文件：&lt;/span&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;strong&gt;直接双击 exe 文件，&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;系统将自动启动兼容引擎，根据提示完成安装即可；&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//99af44e560a6bf9258829de7a3e04f6d.jpg" width="723" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;或是打开兼容引擎&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;，进入「我的应用」 → 「添加应用」&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;，导入 exe 文件后安装并运行。&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//75e1c62443c014988271fdc9da6c772b.jpg" width="1187" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//564ade950d7d2f2f6ebaa572f2c8171f.jpg" width="1187" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;img height="875" src="https://oscimg.oschina.net/oscnet/up-33c7a2954106e356ab77736b184866ed9ba.png" width="1187" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step3：调试与 wine 版本设置&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;目前玲珑的 wine 版本仅支持 deepin-wine8-stable。若通过兼容引擎安装时默认使用了 deepin-wine10-stable，请进入「高级调试」页面，手动切换为 deepin-wine8-stable 并重新调试运行。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//b131b392af9323c2a6975978abc543e5.jpg" width="1205" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step4：打包为 deb 安装包&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;在「我的应用」中找到已安装的应用，选择「打包应用」，根据提示填写软件包信息。打包成功后，将在桌面生成对应的 deb 安装包。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//d92410bed9cf667a9960af48138487e4.jpg" width="1187" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//8d31e7864d99d6b021e5f6eb384a0d55.jpg" width="625" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span&gt;三、转换为玲珑包&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;有了 deb 安装包，接下来只需使用 linglong.yaml 模板进行简单修改，即可完成构建与转换。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step1：配置 linglong.yaml&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;根据上一期的教程，我们只需要对&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FmBI1nm4eRNs7d-v61Pe6Gw" target="_blank"&gt;&lt;span&gt;linglong.yaml(wine 转玲珑) 模板&lt;/span&gt;&lt;/a&gt;&lt;span&gt;进行两处修改。&lt;/span&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;使用文本批量替换方式一次性更改 id 和 name。例如在本次示例中，只需将模板中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;com.163.music.deepin&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 替换为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;com.sfccn.sfconnect&lt;/span&gt;&lt;/code&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//dd2698cfda485a928e4febcf4cb47ed6.jpg" width="1758" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;注意模板中的启动脚本名称，模板默认是 run.sh，我们需要根据 deb 包/opt/apps/com.sfccn.sfconnect/目录下的脚本名称保持一致。例如在本次示例中，脚本名称需使用&lt;/span&gt;&lt;span&gt;&lt;span&gt;run.com&lt;/span&gt;&lt;/span&gt;&lt;span&gt;.sfccn.sfconnect.sh。&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//e29322bb99d7dd1974e8494a2bf91216.jpg" width="1762" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//bf9756ddb82f0b7d78ee8727cb462f58.jpg" width="594" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Step2：组织文件目录&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;随后将 deb 包和 linlong.yaml 文件放入同一文件夹下，并在当前目录下打开终端输入以下命令&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;mkdir -p linglong/sources 
mv *.deb ./linglong/sources&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;这里我用通配符移动当前目录的 deb 安装包到 linglong/sources 目录下&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//5f08cf3f6649c2dd163521e0e5414c9f.jpg" width="501" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;Step3：构建与导出&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;随后进行构建与导出，在当前终端输入以下命令：&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;ll-builder build&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//0c3ecdae44ea7b822db2c1f8f6dfb5ae.jpg" width="1045" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//c8cd21c3b6c492bce5ca55488d07604c.jpg" width="1045" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;如果终端显示「Build completed successfully！」则说明构建成功！接下来执行以下命令导出所构建的玲珑包。&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;ll-builder export --layer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//d9cc6c2e8870ca473b9ace8a32911164.jpg" width="973" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;命令执行完成后，所生成对应的 &lt;/span&gt;&lt;code&gt;&lt;strong&gt;&lt;strong&gt;.layer&lt;/strong&gt;&lt;/strong&gt;&lt;/code&gt;&lt;span&gt; 文件就是我们需要的玲珑包。&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371323</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371323</guid>
      <pubDate>Wed, 10 Sep 2025 07:14:11 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>Claude 支持「创建与编辑」真正文件</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Anthropic &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fcreate-files" target="_blank"&gt;宣布&lt;/a&gt; Claude AI（通过 Claude.ai 平台及其桌面应用）现已具备直接创建和编辑 Excel 表格、Word 文档、PowerPoint 演示文稿以及 PDF 文件的能力，不再仅限于聊天回复或图片生成，而是生成可以下载和使用的真实文件。&lt;/p&gt; 
&lt;p&gt;目前，这项「文件创建」功能处于功能预览阶段，对 &lt;strong&gt;Max、Team 以及 Enterprise&lt;/strong&gt; 用户开放，&lt;strong&gt;Pro&lt;/strong&gt; 用户将在未来几周内获得访问权限。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-08281a63169ef2eb8318b2682a22becda9c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Claude 可以处理多种任务场景，例如：从原始数据生成图表与分析结果；构建带有公式的电子表格（如预算模板、项目追踪器、财务模型等）；实现文件之间的跨格式转换（如：PDF → PPT，会议记录 → 格式化文档，发票 → 有计算功能的表格）等。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;启用方式&lt;/strong&gt;：用户需在界面中开启「Upgraded file creation and analysis」，然后可以上传文件或用自然语言描述需求，即可让 Claude 生成所需输出。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全提示&lt;/strong&gt;：由于 Claude 会访问互联网并执行代码，存在潜在的数据风险。建议用户开启该功能后密切监控 Claude 的操作流程，并对其行为保持审查。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Claude 的文件功能背后运行于一个私有沙盒式计算环境，具备编程执行能力，可自动执行代码以生产文件。这使得它不再是「顾问」，而更像是「动手的协作者」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371321</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371321</guid>
      <pubDate>Wed, 10 Sep 2025 07:00:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Apache Doris 3.1 正式发布：半结构化分析全面升级，湖仓一体能力再跃新高</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;亲爱的社区小伙伴们，我们很高兴地向大家宣布，近期我们迎来了 Apache Doris 3.1 版本的正式发布，欢迎大家下载使用体验。&lt;/p&gt; 
&lt;p&gt;3.1 版本是 Apache Doris 在&lt;strong&gt;半结构化分析&lt;/strong&gt;上的一个里程碑版本。在 VARIANT 类型上，3.1 版本新增了稀疏列能力，使得 VARIANT 可以轻松应对数万子列的场景。同时，在 VARIANT 类型上引入了模板化 schema 能力，让 VARIANT 类型在关键路径上，查询更快、索引更稳、成本可控，同时不丢失灵活性。在倒排索引能力上，3.1 版本引入了 index v3 版本的索引格式，相比较于 v2 版本存储空间节省可达 20%。同时，支持了更为丰富的分词手段，提供了三种全新的分词器：ICU Tokenizer、IK Tokenizer 和 Basic Tokenizer。还进一步支持了自定义分词器，可以突破内置分词器的局限性，根据业务场景定制，显著提升搜索召回率。&lt;/p&gt; 
&lt;p&gt;3.1 版本同样在&lt;strong&gt;湖仓一体&lt;/strong&gt;上有了显著的增强。在 3.1 版本中，Apache Doris 将异步物化视图中的分区构建和透明改写分区补偿，这两项重要能力引入数据湖中，在湖和仓中间架起一座重要的桥梁。3.1 版本还扩充了对 iceberg 和 paimon 特性的支持范围。另外，通过引入动态分区裁剪和批量分片执行在特定场景下提升了数据湖查询的性能多达 40%，并显著降低了 FE 的内存占用。同时 3.1 版本还重构了各个数据源的连接属性，不仅能够以更加清晰的方式对接各类元数据服务和数据存储系统，同时还支持了更加丰富的连接能力。&lt;/p&gt; 
&lt;p&gt;3.1 版本 Apache Doris 持续打磨&lt;strong&gt;存储引擎&lt;/strong&gt;。提供了全新的数据更新方式 —— 灵活列更新。在部分列更新的基础上，进一步放开限制。在一次导入中对于每一行可以更新不同的列。另外，在存算分离场景下，优化了 MOW 表部分链路的锁获取逻辑和使用范围，提升高并发导入场景的使用体验。&lt;/p&gt; 
&lt;p&gt;在性能方面，3.1 着重优化了&lt;strong&gt;分区裁剪的能力和规划性能&lt;/strong&gt;。在数万分区和复杂分区过滤表达式的场景下，能够显著提升查询性能并降低资源消耗。同时，3.1 还在优化器中全面引入了基于数据特征的优化手段，在特定场景下可以获得超过 10 倍的性能提升。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在 3.1 版本的研发过程中，有超过 90 名贡献者为 Apache Doris 提交了 1000+ 个优化与修复。&lt;/strong&gt; 在此向所有参与版本研发、测试和需求反馈的贡献者们表示最衷心的感谢。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fdoris%2Freleases" target="_blank"&gt;GitHub 下载&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdownload" target="_blank"&gt;官网下载&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;一、VARIANT 半结构化查询华丽变身&lt;/h2&gt; 
&lt;h3&gt;存储能力质变：稀疏列与子列 Vertical Compaction，轻松支持数万子列&lt;/h3&gt; 
&lt;p&gt;传统 OLAP 面对「超宽表/超多列」（上千到上万）常遇到元数据膨胀、合并放大与查询退化；Doris 3.1 通过 VARIANT 的稀疏子列与子列级 Vertical Compaction，将可维护的列数上限抬升到数万级。&lt;/p&gt; 
&lt;p&gt;通过对存储层的深入优化，Variant 给用户带来以下收益：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;稳定支撑「上千 - 数万」子列（列式存储），查询/合并延迟更平滑。&lt;/li&gt; 
 &lt;li&gt;元数据与索引可控，避免指数级膨胀。&lt;/li&gt; 
 &lt;li&gt;实测可进行 10,000+ 子列提取（列式存储），Compaction 效率顺畅。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;超多列的适用场景：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;车联网/IoT 遥测：设备型号多、传感器维度动态增减。&lt;/li&gt; 
 &lt;li&gt;营销自动化/CRM：事件/用户属性持续扩展（如自定义 event/property）。&lt;/li&gt; 
 &lt;li&gt;广告/埋点事件：海量可选 properties，字段稀疏且不断演进。&lt;/li&gt; 
 &lt;li&gt;安全审计/日志：不同源日志字段各异，需按模式聚合检索。&lt;/li&gt; 
 &lt;li&gt;电商商品属性：类目跨度大，商品属性高度可变。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;稀疏子列（Sparse Subcolumns）：按 JSON Key 频次排序，只提取 Top-N 高频子列入「真列式」；长尾保持在稀疏列存储，避免无序扩张。&lt;/li&gt; 
 &lt;li&gt;子列级 Vertical Compaction：对 VARIANT 子列应用 Vertical Compaction，分组合并、内存占用更小；合并时动态识别并固化热点路径，进一步降低合并开销。&lt;/li&gt; 
 &lt;li&gt;优化值填充默认值效率，按 batch 的方式进行批量填充（减少虚函数开销）。&lt;/li&gt; 
 &lt;li&gt;通过 LRU 机制减少内存中列存储相关元数据缓存内存开销。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;如何开启与使用&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;新增列级别控制 Variant 参数，列属性（Properties）：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;variant_max_subcolumns_count&lt;/code&gt;：默认是&lt;code&gt;0&lt;/code&gt;，表明不开启稀疏列能力，设置成特定值后将会提取 Top-N 高频的 JSON key 作为列式存储，余下的列进入稀疏列存储。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- Enable sparse subcolumns and cap hot subcolumn count
CREATE TABLE IF NOT EXISTS tbl (
  k BIGINT,
  v VARIANT&amp;lt;
      properties("variant_max_subcolumns_count" = "2048") -- pick top-2048 hot keys
  &amp;gt;
) DUPLICATE KEY(k);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;模板化 Schema（Schema Template） - 变化中的不变量&lt;/h3&gt; 
&lt;p&gt;一句话总结：模板化 Schema 让「常变」的 JSON 在关键路径上「变得可预期」：查询更快、索引更稳、成本可控，同时不丢失灵活性。&lt;/p&gt; 
&lt;p&gt;使用模板化的 Schema，将会给使用 Variant 数据类型带来以下收益：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;类型稳定：关键子路径类型可在 DDL 中固定，避免类型漂移引发的查询报错、索引失效与隐式转换开销。&lt;/li&gt; 
 &lt;li&gt;检索更快更准：为不同子路径定制倒排策略（分词/非分词、解析器、短语搜索等），常用查询延迟更低、命中更稳定。&lt;/li&gt; 
 &lt;li&gt;索引与成本可控：不再「整列统一继承索引」（2.1 的做法易膨胀），而是「按子路径精细化配置」，显著降低索引数量、写放大与存储成本。&lt;/li&gt; 
 &lt;li&gt;可维护/可协作：等同给 JSON 加「数据契约」，跨团队语义一致；类型与索引状态更可观测，问题更易定位。&lt;/li&gt; 
 &lt;li&gt;演进友好：核心高频路径模板化并可选建索引，长尾字段继续保持灵活扩展，不牺牲可扩展性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;如何开启与使用&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;显式声明结构，指定类型：在&lt;code&gt;VARIANT&amp;lt;...&amp;gt;&lt;/code&gt;中预定义常用子路径与类型（含通配），例如&lt;code&gt;'a' : int, 'c.d' : text, 'array_int_*' : array&amp;lt;int&amp;gt;&lt;/code&gt;。&lt;/li&gt; 
 &lt;li&gt;配置索引，针对同一 VARIANT 列的不同子路径配置不同索引策略（field_pattern、解析器、分词、短语搜索等），差异化提升检索效率，可用通配符批量匹配。&lt;/li&gt; 
 &lt;li&gt;新增列级别控制 Variant 参数，列属性（Properties）:&lt;code&gt;variant_enable_typed_paths_to_sparse&lt;/code&gt;：默认是&lt;code&gt;false&lt;/code&gt;，表明预定义的列不会进入稀疏列， &lt;code&gt;true&lt;/code&gt; 开启后预定义类型路径也会进入稀疏存储（用于避免匹配过多列后导致的列数膨胀）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;示例 1：schema 定义 + 单列多索引&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- Common properties: field_pattern (target subpath), analyzer, parser, support_phrase, etc.
CREATE TABLE IF NOT EXISTS tbl (
    k BIGINT,
    v VARIANT&amp;lt;'content' : STRING&amp;gt;, -- specify concrete type for subcolumn 'content'
    INDEX idx_tokenized(v) USING INVERTED PROPERTIES("parser" = "english", "field_pattern" = "content"), -- tokenized inverted index for 'content' with english parser
    INDEX idx_v(v) USING INVERTED PROPERTIES("field_pattern" = "content") -- non-tokenized inverted index for 'content'
);

-- v.content will have both a tokenized (english) inverted index and a non-tokenized inverted index

-- Use tokenized index
SELECT * FROM tbl WHERE v['content'] MATCH 'Doris';

-- Use non-tokenized index
SELECT * FROM tbl WHERE v['content'] = 'Doris';
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;示例 2：通配符批量处理符合模式的列&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- Use wildcard-typed subpaths with per-pattern indexes
CREATE TABLE IF NOT EXISTS tbl2 (
  k BIGINT,
  v VARIANT&amp;lt;
      'pattern1_*' : STRING, -- batch-typing: all subpaths matching pattern1_* are STRING
      'pattern2_*' : BIGINT, -- batch-typing: all subpaths matching pattern2_* are BIGINT
      properties("variant_max_subcolumns_count" = "2048") -- enable sparse subcolumns; keep top-2048 hot keys
  &amp;gt;,
  INDEX idx_p1 (v) USING INVERTED
    PROPERTIES("field_pattern"="pattern1_*", "parser" = "english"), -- tokenized inverted index for pattern1_* with english parser
  INDEX idx_p2 (v) USING INVERTED
    PROPERTIES("field_pattern"="pattern2_*") -- non-tokenized inverted index for pattern2_*
) DUPLICATE KEY(k);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;示例 3：允许预定义类型的列进入稀疏列&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- Allow predefined typed paths to participate in sparse extraction
CREATE TABLE IF NOT EXISTS tbl3 (
  k BIGINT,
  v VARIANT&amp;lt;
    'message*' : STRING, -- batch-typing: all subpaths matching prefix 'message*' are STRING
    properties(
      "variant_max_subcolumns_count" = "2048",              -- enable sparse subcolumns; keep top-2048 hot keys
      "variant_enable_typed_paths_to_sparse" = "true"       -- include typed (predefined) paths as sparse candidates (default: false)
    )
  &amp;gt;
) DUPLICATE KEY(k);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;二、索引架构全面进化&lt;/h2&gt; 
&lt;h3&gt;倒排索引存储格式 V3 - 性能和功能的双重提升&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;相比 V2 进一步优化存储&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;索引文件更小，减少磁盘占用和 I/O 开销，以 httplogs 与 logsbench 两个测试集测试结果来看，存储空间最大可以通过 V3 节省 20%，适合大规模文本数据、日志分析场景。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="index-optimization-1.PNG" src="https://oscimg.oschina.net/oscnet//52bd3f73925297fad698a51fb6c828cf.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心改进&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;引入倒排索引 ZSTD 词典压缩&lt;/strong&gt;：采用 ZSTD 压缩算法对倒排索引内的词典文件进行压缩，通过 index properties 中的 &lt;code&gt;dict_compression&lt;/code&gt; 开启。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增倒排索引位置信息压缩&lt;/strong&gt;：支持对倒排索引中为每个 term 即词元记录的位置信息进行编码压缩，进一步减少倒排索引空间占用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- 建表时启用 V3 格式
CREATE TABLE example_table (
    content TEXT,
    INDEX content_idx (content) USING INVERTED
    PROPERTIES("parser" = "english", "dict_compression" = "true")
) ENGINE=OLAP
PROPERTIES ("inverted_index_storage_format" = "V3");
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;倒排索引 - 分词器灵活多样好用易用&lt;/h3&gt; 
&lt;h4&gt;新增三种常用分词器&lt;/h4&gt; 
&lt;p&gt;进一步提升用户在不同场景下的分词需求：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;ICU Tokenizer&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：ICU（International Components for Unicode）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：包含复杂文字系统的国际化文本，特别适合多语言混合文档。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT TOKENIZE('مرحبا بالعالم Hello 世界', '"parser"="icu"');
-- 结果：["مرحبا", "بالعالم", "Hello", "世界"]

SELECT TOKENIZE('มนไมเปนไปตามความตองการ', '"parser"="icu"');
-- 结果：["มน", "ไมเปน", "ไป", "ตาม", "ความ", "ตองการ"]
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;IK Tokenizer&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：IK Analyzer（中文分词器），基于算法的高级中文分词，结合词典和统计模型&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：对分词质量要求较高的中文文本处理&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;ik_smart&lt;/strong&gt;：智能模式，词少且更长，语义集中，适合精确搜索&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;ik_max_word&lt;/strong&gt;：最细粒度模式，更多短词，覆盖更全面，适合召回搜索&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;-- 智能模式
SELECT TOKENIZE('中华人民共和国国歌', '"parser"="ik","parser_mode"="ik_smart"');
-- 结果：["中华人民共和国", "国歌"]

-- 最细粒度模式
SELECT TOKENIZE('中华人民共和国国歌', '"parser"="ik","parser_mode"="ik_max_word"');
-- 结果：["中华人民共和国", "中华人民", "中华", "华人", "人民共和国", "人民", "共和国", "共和", "国歌"]
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Basic Tokenizer&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;：简单规则的自定义分词器，基础分词，采用字符类型识别进行分词&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：简单场景、对性能要求极高的场景&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;分词规则&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;连续的字母数字字符作为一个词（word tokens）&lt;/li&gt; 
   &lt;li&gt;中文字符单独分词（每个汉字一个 token）&lt;/li&gt; 
   &lt;li&gt;忽略标点符号、空格和特殊符号&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;-- 英文文本分词
SELECT TOKENIZE('Hello World! This is a test.', '"parser"="basic"');
-- 结果：["hello", "world", "this", "is", "a", "test"]

-- 中文文本分词
SELECT TOKENIZE('你好世界', '"parser"="basic"');
-- 结果：["你", "好", "世", "界"]

-- 混合语言分词
SELECT TOKENIZE('Hello 你好 World 世界', '"parser"="basic"');
-- 结果：["hello", "你", "好", "world", "世", "界"]

-- 包含数字和特殊字符
SELECT TOKENIZE('GET /images/hm_bg.jpg HTTP/1.0', '"parser"="basic"');
-- 结果：["get", "images", "hm", "bg", "jpg", "http", "1", "0"]

-- 处理长数字序列
SELECT TOKENIZE('12345678901234567890', '"parser"="basic"');
-- 结果：["12345678901234567890"]
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;自定义分词&lt;/h4&gt; 
&lt;p&gt;推出自定义分词功能，方便用户根据自身分词需求，进行 DIY 组合，进一步提高文本检索召回率。自定义分词可以突破内置分词的局限，根据特定需求组合字符过滤器、分词器和词元过滤器，精细定义文本如何被切分成可搜索的词项，这直接决定了搜索结果的相关性与数据分析的准确性。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="index-optimization-2.PNG" src="https://oscimg.oschina.net/oscnet//dc0f51266ee161f7031d39e645c8b225.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;使用场景举例&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;使用默认 unicode 分词器时，电话号码"13891972631"被当作完整 token，无法支持前缀搜索如"138"。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;创建分词器（tokenizer）&lt;/strong&gt;&lt;/li&gt; 
   &lt;li&gt;使用 Edge N-gram 自定义分词器：&lt;/li&gt; 
  &lt;/ul&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;   CREATE INVERTED INDEX TOKENIZER IF NOT EXISTS edge_ngram_phone_tokenizer
    PROPERTIES
    (
        "type" = "edge_ngram",
        "min_gram" = "3",
        "max_gram" = "10",
        "token_chars" = "digit"
    );
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;创建分析器（analyzer）&lt;/strong&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;  CREATE INVERTED INDEX ANALYZER IF NOT EXISTS phone_prefix_analyzer
    PROPERTIES
    (
        "tokenizer" = "edge_ngram_phone_tokenizer"
    );
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;创建表指定 analyzer&lt;/strong&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;CREATE TABLE customer_contacts (
    id bigint NOT NULL AUTO_INCREMENT(1),
    phone text NULL,
    INDEX idx_phone (phone) USING INVERTED PROPERTIES(
        "analyzer" = "phone_prefix_analyzer"
    )
) ENGINE=OLAP
DUPLICATE KEY(id)
DISTRIBUTED BY RANDOM BUCKETS 1
PROPERTIES ("replication_allocation" = "tag.location.default: 1");
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;查看分词效果&lt;/strong&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;  SELECT tokenize('13891972631', '"analyzer"="phone_prefix_analyzer"');
  +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tokenize('13891972631', '"analyzer"="phone_prefix_analyzer"')                                                                                                                                                                                                                                |
  +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | [{
          "token": "138"
      }, {
          "token": "1389"
      }, {
          "token": "13891"
      }, {
          "token": "138919"
      }, {
          "token": "1389197"
      }, {
          "token": "13891972"
      }, {
          "token": "138919726"
      }, {
          "token": "1389197263"
      }] |
  +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;文本搜索效果&lt;/strong&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;pre&gt;&lt;code class="language-SQL"&gt;  SELECT * FROM customer_contacts_optimized WHERE phone MATCH '138';
  +------+-------------+
  | id   | phone       |
  +------+-------------+
  |    1 | 13891972631 |
  |    2 | 13812345678 |
  +------+-------------+
  SELECT * FROM customer_contacts_optimized WHERE phone MATCH '1389';
  +------+-------------+
  | id   | phone       |
  +------+-------------+
  |    1 | 13891972631 |
  |    2 | 13812345678 |
  +------+-------------+
  2 rows in set (0.043 sec)
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;通过 Edge N-gram 分词器，一个电话号码被拆分成多个前缀 token，实现了灵活的前缀匹配搜索。&lt;/p&gt; 
&lt;h2&gt;三、湖仓一体能力再跃新高&lt;/h2&gt; 
&lt;h3&gt;异步物化视图全面支持数据湖&lt;/h3&gt; 
&lt;p&gt;在 3.1 版本中，异步物化视图再次进化，现在可以完整支持 Paimon / Iceberg / Hudi 的分区增量构建和分区透明改写。Doris 自 2.1 版本支持异步物化视图功能开始。经过多个版本的迭代。已经支持了非常多有价值的特性。包括：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="lakehouse.PNG" src="https://oscimg.oschina.net/oscnet//8b9ea94aa4532f2abd02eb830a14ebf4.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;3.1 版本则重点打磨湖仓一体方向上的功能，全面支持主流的数据湖表格式 Paimon / Iceberg / Hudi 的分区刷新，和透明改写时的外部数据源分区补偿。使其成为联通湖和仓之间的高速公路。具体支持范围详见下表：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="lakehouse-2.PNG" src="https://oscimg.oschina.net/oscnet//f186dc9cba936323728be249dd42bdc3.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;Iceberg / Paimon 能力全面扩充&lt;/h3&gt; 
&lt;h4&gt;Iceberg&lt;/h4&gt; 
&lt;p&gt;3.1.0 版本针对 Iceberg 表格式上做出多项优化和能力增强，紧密推进与 Iceberg 最新特性的融合。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;支持 Branch / Tag 完整生命周期管理&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;从 3.1.0 开始，Doris 原生支持 Iceberg Branch &amp;amp; Tag 的创建、删除、读取与写入操作。该功能能够让用户像 Git 一样操作和管理 Iceberg 表数据。这一能力为 Iceberg 表格式的多版本并行管理、灰度测试、环境隔离等业务场景提供了原生的支持，无需额外引擎或自定义逻辑。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- 创建分支
ALTER TABLE iceberg_tbl CREATE BRANCH b1;
-- 写入数据到指定分支
INSERT INTO iceberg_tbl@branch(b1) values(1, 2);
-- 查询指定分支
SELECT * FROM iceberg_tbl@branch(b1);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;丰富的 Iceberg 系统表支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1.0 新增对 Iceberg &lt;code&gt;$entries&lt;/code&gt;， &lt;code&gt;$files&lt;/code&gt;， &lt;code&gt;$history&lt;/code&gt;， &lt;code&gt;$manifests&lt;/code&gt;， &lt;code&gt;$refs&lt;/code&gt;， &lt;code&gt;$snapshots&lt;/code&gt; 等系统表的支持，可用 &lt;code&gt;SELECT * FROM iceberg_table$history&lt;/code&gt;、&lt;code&gt;…$refs&lt;/code&gt; 等语句直接查询 Iceberg 的底层 metadata、snapshot 列表、分支/标签信息等，从而深入了解数据文件的组织结构、快照的变更历史以及分支的映射情况。这种能力大大提升了 Iceberg 元数据的可观测性，使得问题定位、调优分析和治理决策更加直观、透明。&lt;/p&gt; 
&lt;p&gt;如通过系统表查看 delete file 数量：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT
  CASE
    WHEN content = 0 THEN 'DataFile'
    WHEN content = 1 THEN 'PositionDeleteFile'
    WHEN content = 2 THEN 'EqualityDeleteFile'
    ELSE 'Unknown'
  END AS ContentType,
  COUNT(*) AS FileNum,
  SUM(file_size_in_bytes) AS SizeInBytes,
  SUM(record_count) AS Records
FROM
  iceberg_table$files
GROUP BY
  ContentType;

+--------------------+---------+-------------+---------+
| ContentType        | FileNum | SizeInBytes | Records |
+--------------------+---------+-------------+---------+
| EqualityDeleteFile |    2787 |     1432518 |   27870 |
| DataFile           |    2787 |     4062416 |   38760 |
| PositionDeleteFile |      11 |       36608 |   10890 |
+--------------------+---------+-------------+---------+
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;Iceberg 视图查询&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1.0 版本新增对 Iceberg 逻辑视图的访问和查询。该功能进一步提升了 Doris 对 Iceberg 功能的完善程度。在后续 3 位版本迭代中，我们将进一步支持 Iceberg View 的 SQL 方言转换能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;通过 ALTER 语句修改 Iceberg 表结构&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1.0 支持通过 &lt;code&gt;ALTER TABLE&lt;/code&gt; 语句对 Iceberg 表进行字段的新增、删除、重命名和重排序操作。该功能进一步完善了 Doris 对 Iceberg 表的管理能力，无需再借助 Spark 等第三方引擎进行 Iceberg 表管理。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;ALTER TABLE iceberg_table
ADD COLUMN new_col int;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;同时，在 3.1.0 版本中，Iceberg 的依赖版本升级到 1.9.2，以便更好的支持 Iceberg 的新的功能。在后续 3.1 的迭代版本中，我们将进一步增强 Iceberg 的表管理能力，包括数据合并、分支演进等能力。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fcatalogs%2Ficeberg-catalog" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;h4&gt;Paimon&lt;/h4&gt; 
&lt;p&gt;3.1.0 版本针对 Paimon 表格式，结合用户实际场景，进行了多项功能更新和能力增强。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;支持 Paimon Batch Incremental Query&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1.0 版本支持读取 Paimon 表指定的两个快照之间的增量数据。该功能增强了用户对 Paimon 表增量数据的访问能力。尤其是在增量物化视图构建方面，基于此功能实现了 Paimon 表的增量聚合物化视图能力。详见物化视图方面的说明。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT * FROM paimon_tbl@incr('startSnapshotId'='2', 'endSnapshotId'='5');
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;支持 Branch / Tag 读取&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;从 3.1.0 开始，Doris 支持对 Paimon 表的 Branch / Tag 进行读取，帮助用户更灵活的访问多版本的 Paimon 数据。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT * FROM paimon_tbl@branch(branch1);
SELECT * FROM paimon_tbl@tag(tag1);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;丰富的 Paimon 系统表支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;同 Iceberg 一样，3.1.0 新增对 Paimon &lt;code&gt;$files&lt;/code&gt;， &lt;code&gt;$partitions&lt;/code&gt;， &lt;code&gt;$manifests&lt;/code&gt;， &lt;code&gt;$tags&lt;/code&gt;， &lt;code&gt;$snapshots&lt;/code&gt; 等系统表的支持，可用 &lt;code&gt;SELECT * FROM partition_table$files&lt;/code&gt; 等语句直接查询 Paimon 的底层元数据信息。更方便用户对 Paimon 表进行探测、调试和优化。&lt;/p&gt; 
&lt;p&gt;如我们可以通过系统表统计分区新增数据文件：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT
  partition,
  COUNT(*) AS new_file_count,
  SUM(file_size_in_bytes)/1024/1024 AS new_total_size_mb
FROM my_table$files
WHERE creation_time &amp;gt;= DATE_SUB(NOW(), INTERVAL 3 DAY)
GROUP BY partition
ORDER BY new_total_size_mb DESC;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在 3.1.0 版本中，Paimon 的依赖版本升级到 1.1.1，以便更好的支持 Paimon 的新的功能。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fcatalogs%2Fpaimon-catalog" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;h3&gt;数据湖查询性能更上一层楼&lt;/h3&gt; 
&lt;p&gt;3.1.0 版本，针对数据湖表格式的查询性能进行了多项深度优化，旨在实际生产环境下，为用户提供更加稳定、高效的数据湖分析能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;动态分区裁剪&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;动态分区裁剪功能，能够在多表关联查询场景下，根据右表数据生成分区列谓词，并对左表数据进行运行时的分区剪枝，从而减少数据 IO，提升查询性能。在 3.0 版本中，Doris 已经支持了 Hive 表的动态分区裁剪功能。在 3.1.0 版本中，这个功能进一步扩充到了 Iceberg、Paimon 和 Hudi 表上。在测试场景下，针对选择率较高的查询，&lt;strong&gt;可以提升 30%-40% 的性能。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;批量分片执行&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当湖表的数据分片较多时，如果 FE 进行规划并将所有分片信息一次性组装完成发送给 BE，那么可能造成 FE 内存消耗过大以及处理实际过长的问题。尤其是在查询大数据量表时，会导致规划部分的资源开销大耗时长。批量分片执行功能，通过分批次生产数据分片信息，并且边生产变执行，能够有效缓解 FE 的内存开销，同时能够让分片信息的生产和执行并行执行，提升整体的执行效率。在 3.0 版本中，Doris 已经支持了 Hive 表上的该功能。在 3.1.0 版本中，进一步增加了对 Iceberg 表的批量分片执行支持。在大数据量测试场景下，可以显著降低 FE 的内存开销和查询规划时间。&lt;/p&gt; 
&lt;h3&gt;联邦分析 - 连接器更好用更多样&lt;/h3&gt; 
&lt;p&gt;3.1 版本重构了各个数据源的连接属性，不仅能够以更加清晰的方式对接各类元数据服务和数据存储系统，同时还支持了更加丰富的连接能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Iceberg Rest Catalog&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1 版本进一步增强了对 Iceberg Rest Catalog 的支持。不仅支持了包括 Unity、Polaris、Gravitino、Glue 等多种 Iceberg Rest Catalog 后端实现，同时支持了 vended credentials 功能，能够更加安全、灵活的管理访问凭证。目前支持 AWS 平台，后续小版本迭代中将陆续支持 GCP、Azure 等云平台的凭证管理。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fmetastores%2Ficeberg-rest" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;支持 Paimon Rest Catalog&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1.0 版本中支持基于阿里云 DLF 的 Paimon Rest Catalog，可以直接访问新版本 DLF 管理的 Paimon 表数据。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fbest-practices%2Fdoris-dlf-paimon" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;多 Kerberos 环境支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3.1 版本允许用户在同一个 Doris 集群内访问不同的 Kerberos 认证环境。不同的 Kerberos 环境可能采用不同的 KDC 服务、Principal 以及对应的 Keytab。新版本允许针对不同的 Catalog，配置不同的 Kerberos 认证信息，并且相互之间不受干扰。该功能极大的方便了拥有多套 Kerberos 认证环境的用户，可以使用 Doris 进行统一的访问管理。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fstorages%2Fhdfs%23kerberos-authentication" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;多 Hadoop 环境支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在之前的版本中，Doris 只允许用户在 conf 目录下放置一套 hadoop 集群的配置文件（hive-site.xml，hdfs-site.xml 等）。如果用户有多套不同的 Hadoop 环境和配置，则无法支持。新版本运行用户为不同的 Catalog 指定不同的 Hadoop 配置文件，帮助用户更灵活的管理外部数据源。&lt;/p&gt; 
&lt;p&gt;详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fstorages%2Fhdfs%23kerberos-authentication" target="_blank"&gt;文档&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;四、存储层构持续打磨&lt;/h2&gt; 
&lt;p&gt;在 3.1 版本中，我们对存储层也进行了持续的打磨，性能和稳定性都有了显著的提升。&lt;/p&gt; 
&lt;h3&gt;灵活列更新 - 数据更新全新体验&lt;/h3&gt; 
&lt;p&gt;此前 Doris 的部分列更新功能要求一次导入中每一行必须更新相同的列。在一些场景下，源端系统输出的记录往往只包含主键和被更新的列，不同行更新的列可能不同。为了解决这种需求，Doris 引入了 &lt;strong&gt;灵活列更新&lt;/strong&gt; 功能，使用灵活列更新可以大幅简化用户侧按列攒数据的工作以及提升写入性能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;创建 &lt;strong&gt;Merge-on-Write Unique 表&lt;/strong&gt; 时，在表属性中开启：&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;"enable_unique_key_skip_bitmap_column" = "true"&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;在导入时指定导入模式：&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;unique_key_update_mode: UPDATE_FLEXIBLE_COLUMNS&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;Doris 会自动完成灵活列更新与数据补齐。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt; 支持在一次导入中对不同记录更新不同的列，例如：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;删除某行（&lt;code&gt;DORIS_DELETE_SIGN&lt;/code&gt;）&lt;/li&gt; 
 &lt;li&gt;更新部分列（如 &lt;code&gt;v1&lt;/code&gt;、&lt;code&gt;v2&lt;/code&gt;、&lt;code&gt;v5&lt;/code&gt; 等）&lt;/li&gt; 
 &lt;li&gt;插入新行（仅提供主键和被更新列，其他列使用默认值或补齐历史值）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在测试环境下（1 FE + 4 BE，16C 64GB，3 亿行 101 列数据，3 副本行存表）： 
  &lt;ul&gt; 
   &lt;li&gt;每次导入 20,000 行，仅更新 1 列（需补齐 99 列）&lt;/li&gt; 
   &lt;li&gt;单并发导入性能可达 &lt;strong&gt;10.4k 行/s&lt;/strong&gt;&lt;/li&gt; 
   &lt;li&gt;单机资源占用：CPU ～60%，内存 ～30GB，读 IOPS ～7.5k/s，写 IOPS ～5k/s&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;存算分离 mow 锁优化&lt;/h3&gt; 
&lt;p&gt;在存算分离场景下，MOW 表更新 Delete Bitmap 需要获取分布式锁 &lt;code&gt;delete_bitmap_update_lock&lt;/code&gt;。原有实现中，导入、Compaction 和 Schema Change 会竞争该锁，容易在高并发导入场景下导致长时间等待甚至失败。&lt;/p&gt; 
&lt;p&gt;本次优化包括两方面：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;减少 Compaction 持锁时间&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;通过引入新的 &lt;code&gt;mow_tablet_compaction_key&lt;/code&gt;，避免多个 Compaction/Schema Change 任务在更新 &lt;code&gt;initiators&lt;/code&gt; 列表时产生不必要的事务冲突。&lt;/li&gt; 
 &lt;li&gt;在多 Tablet 高并发导入测试中，导入提交事务的 &lt;strong&gt;p99 平均耗时从 1.68 分钟降低到 49.4 秒&lt;/strong&gt;，大幅降低了事务提交延迟。&lt;/li&gt; 
 &lt;li&gt;新增配置项 &lt;code&gt;delete_bitmap_lock_v2_white_list&lt;/code&gt;，支持为指定仓库开启该优化。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;降低导入事务长尾延迟&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;增加 FE 配置 &lt;code&gt;mow_load_force_take_ms_lock_threshold_ms&lt;/code&gt;，当导入事务等待锁超过阈值时，将强制获取分布式锁，避免长时间饥饿。&lt;/li&gt; 
 &lt;li&gt;在高并发导入测试下，该优化显著减少了导入事务的长尾延迟。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;五、查询性能提升&lt;/h2&gt; 
&lt;h3&gt;分区裁剪性能和适用范围提升&lt;/h3&gt; 
&lt;p&gt;Doris 支持数据按照分区组织，这些分区可以独立存储、独立查询、独立管理。通过分区，可以提升查询性能、优化数据管理，并降低资源消耗。在查询过程中，通过使用过滤条件，提前过滤无需查询的分区，可以显著提升查询性能，降低系统资源消耗。在日志数据分析系统，风控系统等使用场景中，单表可能存在万级别甚至十万级别的分区数量，而通常单词查询，只会命中百级别以下的分区数据。对于在这类数据上的查询，能否分区裁剪，对于查询性能的影响十分显著。&lt;/p&gt; 
&lt;p&gt;在 3.1 版本中，Doris 通过引入一系列的优化，显著提升了分区裁剪的性能和适用范围，包括&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;分区裁剪二分查找。对于在时间列上的分区，通过将分区按照列值排序，将分区裁剪的计算从线性遍历，改为二分查找。在使用 DATETIME 类型作为分区字段，13.6 万分区数的场景下。实测分区裁剪的耗时，从 724ms 提升到 43ms。提升超过 16 倍。&lt;/li&gt; 
 &lt;li&gt;增加大量单调函数参与分区裁剪。在实际的使用场景中，在时间分区列上的过滤条件，通常不是简单的逻辑比较，而是在分区列上包含时间函数计算的复杂表达式。如：&lt;code&gt;to_date(time_stamp) &amp;gt; '2022-12-22&lt;/code&gt;'，&lt;code&gt;date_format(timestamp,'%Y-%m-%d %H:%i:%s') &amp;gt; '2022-12-22 11:00:00'&lt;/code&gt;等。Doris 在 3.1 版本中引入了函数单调特性描述，当函数为单调函数时，可以通过计算分区边界值是否可以被裁剪得知整个分区是否可以被裁剪。在 3.1 版本中，已经支持了 CAST 和 25 个常见的时间相关的函数。可以覆盖绝大多数常见的时间类型分区列上的过滤条件。&lt;/li&gt; 
 &lt;li&gt;此外，3.1 版本中，还对分区裁剪的全路径代码做了许多代码级别的详细优化，减少了不必要开销。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;洞察数据特征 - 获得性能 10 倍的潜力&lt;/h3&gt; 
&lt;p&gt;在 3.1 中，优化器可以更聪明的使用数据特征对查询进行优化。优化器会执行计划树种各个节点的收集唯一性（Unique）、均一性（Uniform），等值集（Equal Set）等数据特征，并推导列之间的函数依赖关系。当在特定的节点，数据符合特定特征时，可以移除不必要的连接、聚合或排序计算，显著提升查询性能。&lt;/p&gt; 
&lt;p&gt;在针对特定优化构建的测试用例下，利用数据特征可以获得超过 10 倍的性能提升，详见下表：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="query-performance.PNG" src="https://oscimg.oschina.net/oscnet//3bf8bd362c3e994af570eda7aa49c09b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;六、功能改进&lt;/h2&gt; 
&lt;h3&gt;半结构化&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;VARIANT&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;新增 &lt;code&gt;variant_type(x)&lt;/code&gt;函数：返回 Variant 子 field 对应的「当前实际类型」。&lt;/li&gt; 
 &lt;li&gt;新增 ComputeSignature/Helper，增强函数参数/返回类型推断能力。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;STRUCT&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持使用 Schema Change 为 STRUCT 类型增加子列&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;湖仓一体&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持在 Catalog 级别设置元数据缓存策略，如缓存过期时间等。帮助用户根据需求灵活调整数据时效性和元数据访问性能。详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoris.apache.org%2Fdocs%2Flakehouse%2Fmeta-cache" target="_blank"&gt;文档&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;支持 &lt;code&gt;FILE()&lt;/code&gt; 表函数（Table Valued Function），该表函数是原有的 &lt;code&gt;S3()&lt;/code&gt;，&lt;code&gt;HDFS()&lt;/code&gt;，&lt;code&gt;LOCAL()&lt;/code&gt;表函数的集合，方便用户使用和理解。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;聚合算子能力增强&lt;/h3&gt; 
&lt;p&gt;在 3.1 版本中，优化器重点增强了聚合算子。支持了两个使用较为广泛的能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;非标 GROUP BY 支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;对于标准的聚合查询，要求聚合输出的标量表达式，其本身或其子树必须是聚合键。但在 MySQL 中，当设置了 SQL_MODE 不包含 "ONLY_FULL_GROUP_BY" 时，则没有次限制。详见 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.4%2Fen%2Fsql-mode.html%23sqlmode_only_full_group_by" target="_blank"&gt;MySQL 文档&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;此时，此列输出的值为聚合键对应多行中的任意一行计算的值。举例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;-- 非标 GROUP BY
SELECT c1, c2 FROM t GROUP BY c1
-- 等价于
SELECT c1, any_value(c2) FROM t GROUP BY c1
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在 3.1 版本中。Doris 在 SQL_MODE 中默认开启 "ONLY_FULL_GROUP_BY" ，即和之前的行为保持一致。如果需要使用非标 GROUP BY 功能。则可以通过如下设置开启：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;set sql_mode = replace(@@sql_mode, 'ONLY_FULL_GROUP_BY', '');
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;多 distinct 聚合支持&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在之前的版本中，如果聚合查询中，包含多个 distinct 聚合函数，且他们的参数不一致。同时聚合函数的 distinct 语义和非 distinct 语义不一致，且不是以下之一，则 Doris 无法执行查询：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;单参数的 COUNT&lt;/li&gt; 
 &lt;li&gt;SUM&lt;/li&gt; 
 &lt;li&gt;AVG&lt;/li&gt; 
 &lt;li&gt;GROUP_CONCAT&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在 3.1 版本中，Doris 对此方面进行了加强。现在这些查询可以正常执行并获取结果。例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT count(DISTINCT c1,c2), count(DISTINCT c2,c3), count(DISTINCT c3) FROM t;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;连接协议增强&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;开启 Proxy Protocol 协议后，依然可以通过非该协议的客户端连接。该改进在负载均衡 IP 透传场景下，方便用户更灵活的连接 Doris。&lt;/li&gt; 
 &lt;li&gt;查询 VIEW 时，JDBC 的元数据接口 ResultSetMetaData#getColumnName 可以正确的返回 VIEW 中的列名&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;七、行为变更&lt;/h2&gt; 
&lt;h3&gt;VARIANT&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;variant_max_subcolumns_count&lt;/code&gt; 约束 
  &lt;ul&gt; 
   &lt;li&gt;同一张表中，所有 Variant 列的 &lt;code&gt;variant_max_subcolumns_count&lt;/code&gt; 必须「要么全为 0，要么全为 &amp;gt; 0」。混用会在建表 / Schema Change 时报错。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;新的 Variant 读写/serde 与 Compaction 路径对旧数据兼容。老版本 Variant 升级上来查询格式会产生差异（比如多一些空格、或是&lt;code&gt;。&lt;/code&gt;分隔符导致层级构建，产生额外的层级）&lt;/li&gt; 
 &lt;li&gt;创建 Variant 倒排索引，如果数据中所有字段不符合索引条件也会生成空索引文件，属预期行为&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;权限&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;show transcation 的权限需求从拥有 ADMIN_PRIV 权限，变更为拥有导入对应数据库的 LOAD_PRIV 权限&lt;/li&gt; 
 &lt;li&gt;统一了 SHOW FRONTENDS / BACKENDS 和 NODE Restful API 的权限。现在这些接口的权限需求为拥有 information_schema 库的 SELECT_PRIV 权限。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;立刻开启 3.1&lt;/h2&gt; 
&lt;p&gt;在 3.1 版本正式发布之前，半结构化和数据湖的多个能力已经经过真实线上场景的验证，并获得了符合预期的性能提升。推荐有相应能力需求的用户下载尝鲜。&lt;/p&gt; 
&lt;h2&gt;致谢&lt;/h2&gt; 
&lt;p&gt;在此，再次向所有参与版本研发、测试和需求反馈的贡献者们表示最衷心的感谢：&lt;/p&gt; 
&lt;p&gt;@924060929 @airborne12 @amorynan @BePPPower @BiteTheDDDDt @bobhan1 @CalvinKirs @cambyzju @cjj2010 @csun5285 @DarvenDuan @dataroaring @deardeng @dtkavin @dwdwqfwe @eldenmoon @englefly @feifeifeimoon @feiniaofeiafei @felixwluo @freemandealer @Gabriel39 @gavinchou @ghkang98 @gnehil @gohalo @HappenLee @heguanhui @hello-stephen @HonestManXin @htyoung @hubgeter @hust-hhb @jacktengg @jeffreys-cat @Jibing-Li @JNSimba @kaijchen @kaka11chen @KeeProMise @koarz @liaoxin01 @liujiwen-up @liutang123 @luwei16 @MoanasDaddyXu @morningman @morrySnow @mrhhsg @Mryange @mymeiyi @nsivarajan @qidaye @qzsee @Ryan19929 @seawinde @shuke987 @sollhui @starocean999 @suxiaogang223 @SWJTU-ZhangLei @TangSiyang2001 @Vallishp @vinlee19 @w41ter @wangbo @wenzhenghu @wumeibanfa @wuwenchi @wyxxxcat @xiedeyantu @xinyiZzz @XLPE @XnY-wei @XueYuhai @xy720 @yagagagaga @Yao-MR @yiguolei @yoock @yujun777 @Yukang-Lian @Yulei-Yang @yx-keith @Z-SWEI @zclllyybb @zddr @zfr9527 @zgxme @zhangm365 @zhangstar333 @zhaorongsheng @zhiqiang-hhhh @zy-kkk @zzzxl1993&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371320</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371320</guid>
      <pubDate>Wed, 10 Sep 2025 06:58:10 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>阿联酋推出低成本 AI 推理模型，宣称「性价比」超同行 20 倍</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿联酋穆罕默德·本·扎耶德人工智能大学（MBZUAI）在官网&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmbzuai.ac.ae%2Fnews%2Fmbzuai-and-g42-launch-k2-think-a-leading-open-source-system-for-advanced-ai-reasoning%2F" target="_blank"&gt;宣布&lt;/a&gt;，其与 G42 共同推出了一款低成本的推理模型「K2 Think」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;新闻稿声称，K2 Think 仅需 320 亿个参数，却能超越其他公司的、规模大 20 倍的推理模型。该模型基于阿里巴巴开源 Qwen 2.5 模型构建，并在 Cerebras 提供的硬件上运行和测试。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="278" src="https://oscimg.oschina.net/oscnet/up-9d10147988ff989c22d01948ef175f5af80.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;MBZUAI 基础模型研究所所长 Hector Liu 告诉媒体，团队通过多种方法实现了高性能表现，包括：长链式思维监督微调（CoT） —— 一种逐步推理的方法；推理阶段扩展（test-time scaling） —— 在推理阶段分配更多计算资源来提升表现。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Liu 表示：「特别之处在于，我们把它当作一个系统来对待，而不仅仅是一个模型。和普通的开源模型仅仅‘发布’不同，我们会实际部署该模型，并观察如何随着时间的推移改进模型。」「如果问哪一步最关键，很难单独指出。这更像是一整套方法的组合，才得出了最终结果。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;新闻稿写道，&lt;strong&gt;「K2 Think 不仅仅是一项技术成就，更是阿联酋人工智能领域的一个决定性时刻。」&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;近年来，阿联酋也试图将自己定位为 AI 全球领导者，以提升地缘政治影响力，并减少对原油的依赖。阿联酋的 AI 企业 G42 就是其突围的例子。但其竞争对手包括邻国沙特，后者今年 5 月通过主权基金成立 Humain，致力于打造全栈 AI 能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;更宏观来看，阿联酋 AI 产业要追赶中美仍有很长路要走。美国的 OpenAI 和科技巨头已占据先机，中国也早已把 AI 列为战略重点。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;尽管 K2 Think 的表现可与 OpenAI 相媲美，开发者强调，他们的目标并不是打造另一个 ChatGPT。MBZUAI 基础模型研究所总经理 Richard Morton 解释说，这个模型是为数学、科学等特定应用领域而设计。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;他说：「人类大脑的基本推理能力是所有思维过程的基石。这个应用能把原本需要 1000 到 2000 人耗费五年时间才能完成的问题思考或临床实验，大大缩短周期。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，它还能让缺乏美国那样资本与基础设施的地区，也能使用先进 AI 技术。Morton 总结道：「我们正在发现，用更少的资源，其实可以做到更多。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371311</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371311</guid>
      <pubDate>Sun, 07 Sep 2025 06:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Arm 发布 Lumex CSS 移动端计算子系统</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Arm 正式发布 Lumex CSS (Compute Subsystem, CSS) 移动端计算子系统，这是专为旗舰级智能手机及下一代个人电脑设计的先进计算平台，旨在加速端侧 AI 体验并提升整体性能。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0910/142857_6HGj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Lumex CSS 平台集成了搭载第二代可伸缩矩阵扩展 (SME2) 技术的最高性能 Arm CPU、GPU 及系统 IP，支持桌面级移动游戏、实时翻译、智能助手及个性化应用等多样的丰富体验。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0910/142924_kfT6_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;全新 Arm Lumex 平台包含以下核心组件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;新一代搭载 SME2 技术的 Armv9.3 CPU 集群：包括 Arm C1-Ultra 和 Arm C1-Pro，为旗舰设备提供支持；&lt;/li&gt; 
 &lt;li&gt;Arm C1-Premium：专为次旗舰市场打造，可提供一流的面积效率；&lt;/li&gt; 
 &lt;li&gt;Arm Mali G1-Ultra GPU：配备新一代光线追踪技术，在实现先进的图形和游戏体验同时，还可提升整体 AI 性能；&lt;/li&gt; 
 &lt;li&gt;Arm C1-DSU：Arm 迄今为止最灵活、高能效且具多种电源模式的 DynamIQ Shared Unit (DSU)；&lt;/li&gt; 
 &lt;li&gt;针对 3 纳米工艺节点优化的物理实现；跨软件栈的深度集成，为使用 Arm KleidiAI 软件库的开发者提供无缝的 AI 加速体验。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Arm 表示，Arm Lumex 不仅是 Arm 面向消费计算市场的最先进 CSS 平台，更是开启新时代智能 AI 体验的基石。无论是 OEM 厂商还是开发者，Lumex 均可提供所需工具，助力其在关键端侧场景实现兼具个性化、隐私保障与高性能的 AI 体验。作为专为 AI 时代打造平台， Arm Lumex 将成为未来移动创新的全新起点。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371310</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371310</guid>
      <pubDate>Sun, 07 Sep 2025 06:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌云披露储备订单达到 1060 亿美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;「目前谷歌云已签订但尚未履行的现有客户合同中，承诺金额累计高达 1060 亿美元。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;当地时间 9 月 9 日，谷歌云 CEO Thomas Kurian 在一场高盛会议上透露，在 1060 亿美元的储备订单中，预计超过一半在未来两年内转化为收入，「它的增长速度超过了我们的收入」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-1decfc361f571dca2f976d227d621dacff1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据谷歌母公司 Alphabet 发布的 2025 年第二季度财报，分业务来看，谷歌的两大核心业务是广告业务和云业务，第二季度增长提速，营收从去年同期的 103.47 亿美元增长至 136.24 亿美元，同比增长 32%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;云业务的强劲增长主要得益于人工智能处理需求的激增。Alphabet 首席执行官桑达尔·皮查伊（Sundar Pichai）还提到，AI 正在积极推动所有业务发展，带来强劲动能。鉴于公司云产品及服务面对强劲且持续增长的市场需求，公司计划在 2025 年将资本支出增加至约 850 亿美元，并对未来的发展机遇感到振奋。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;按照 Kurian 的说法，未来两年内，谷歌云将获得约 580 亿美元的新收入，将成为这家科技巨头更加核心的组成部分。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Kurian 称，上述数字只考虑了现有的承诺，而不是新的合同或预期的客户。该部门的新客户环比增长了 28%。排名前十的人工智能实验室中有 9 个目前均为谷歌云客户，这包括谷歌的人工竞争对手，如 ChatGPT 开发商 OpenAI，以及估值 1830 亿美元的 Anthropic。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Kurian 在本次大会上介绍了谷歌云在快速扩张的云计算和人工智能市场中的战略。他强调，该部门的专有芯片开发和软件专业知识是谷歌云在人工智能基础设施、生成人工智能模型和数据处理能力方面的优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;有媒体评价认为，尽管谷歌云落后于亚马逊股份有限公司和微软公司提供的云服务，排名第三，但随着这家科技巨头的主要搜索业务的成熟，谷歌云仍然被视为 Alphabet 最强劲的增长来源之一。该部门受益于谷歌在人工智能方面的巨额支出，其在新兴技术方面的专业知识帮助谷歌云赢得了客户，尤其是在人工智能初创公司中。（澎湃新闻）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371308</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371308</guid>
      <pubDate>Sun, 07 Sep 2025 06:15:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>美团 C 端 AI 智能体服务将于一周内发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美团&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9109ITAZ4GS-UoYjGkdPrA" target="_blank"&gt;宣布&lt;/a&gt;，大众点评将正式「重启」品质外卖服务，将通过 B 端自研大模型，结合海量真实评价数据分析用户需求，进一步剔除非真实点评数据，以「AI+真实高分」为用户提供可靠决策。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;此外，美团 C 端 AI 智能体服务也将于一周内发布，目前正在「封楼测试」阶段&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;就在 9 月 1 日，&lt;a href="https://www.oschina.net/news/369581" target="_blank"&gt;美团正式发布 LongCat-Flash-Chat（中文名：龙猫）&lt;/a&gt;，在 GitHub、Hugging Face 开源，并同步上线官网。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0910/140959_bZBu_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;今年美团 AI 进展频传，先后发布了 AI Coding Agent 工具 NoCode、AI 经营决策助手「袋鼠参谋」、酒店经营的垂类 AI Agent「美团既白」等多款应用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371307</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371307</guid>
      <pubDate>Sun, 07 Sep 2025 06:07:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>大众汽车豪掷 10 亿欧元布局人工智能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;华尔街日报报道称，在德国慕尼黑国际车展首日，大众汽车宣布至 2030 年，将累计投入高达 10 亿欧元用于人工智能（AI）技术的全链条应用开发，覆盖从研发到生产的核心环节。这一举措被视为大众应对全球汽车产业电动化、智能化转型的关键落子。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;大众汽车预计，到 2035 年，AI 技术将为公司创造高达 40 亿欧元的效率提升与成本优化效益。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="374" src="https://oscimg.oschina.net/oscnet/up-f6df16ad1343ec3fbfc097c0d33b2277838.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据大众汽车官方声明，10 亿欧元投资将集中于三大战略方向：AI 辅助车辆研发、工业场景应用以及高性能 IT 基础设施扩建。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;大众集团首席信息官 Hauke Stars 强调：「AI 将贯穿从概念车到量产的全流程，成为提升研发速度与质量的‘数字引擎’。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;大众首席执行官 Oliver Blume 透露，AI 赋能的下一代车型将搭载自研 Unified Cell 电池技术与 L4 级自动驾驶系统，而入门级纯电 SUV ID. CROSS（起售价约 2.5 万欧元）更将直击中欧市场「红海区间」，挑战特斯拉 Model 3 等竞品。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;大众的激进布局折射出全球汽车产业的深层变革。当前，欧洲车企正面临多重压力：美国对欧汽车关税虽从 27.5% 降至 15%，但仍高于历史水平；中国电动车品牌凭借成本与智能化优势快速崛起，2025 年欧洲市场份额已突破 18%。Blume 在车展上直言：「竞争如同体育比赛，对手越强，我们越需突破自我。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371303</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371303</guid>
      <pubDate>Sun, 07 Sep 2025 06:02:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 视频生成公司「爱诗科技」完成 B 轮融资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXT3NSiqh3Z8mivmQECKncQ" target="_blank"&gt;根据《智能涌现》的独家报道&lt;/a&gt;，AI 视频生成公司 「爱诗科技」 近日完成 B 轮融资，总金额超过 6000 万美元。 该轮融资由阿里巴巴领投，达晨财智、深创投、北京市 AI 基金、湖南电广、巨人网络和 Antler 跟投。据了解，这也是国内视频生成领域单次最大融资额。&lt;/p&gt; 
&lt;p&gt;上月底，爱诗科技&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FHmT0FiG9IcTfCzzrKK3VSw" target="_blank"&gt;宣布&lt;/a&gt;PixVerse V5 模型全球同步上线，并且拍我 AI（PixVerse）用户规模突破 1 亿。就在 4 个月前，这个数字还是 6000 万。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0910/120029_Myi5_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:#333333"&gt;据介绍，基于 V5 动态效果、视觉质量、一致性保持、指令遵循等方面的综合提升，根据权威独立测评平台 Artificial Analysis 最新测试结果，PixVerse V5 在图生视频（Image to Video）项目中排名全球 Top2，在文生视频（Text to Video）项目中位列 Top3，保持在全球第一梯队。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371286</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371286</guid>
      <pubDate>Sun, 07 Sep 2025 04:01:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马斯克脑机公司 Neuralink：已为全球 12 人植入芯片</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#2a3840; margin-left:.2rem; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;据路透社报道，埃隆·马斯克 (Elon Musk) 旗下脑机接口公司 Neuralink 周二表示，该公司已经在全球范围内为 12 人植入其芯片。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#2a3840; margin-left:.2rem; margin-right:0; text-align:justify"&gt;&lt;img height="366" src="https://oscimg.oschina.net/oscnet/up-92dd64d9e9d887301a303ccc531b27af99b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#2a3840; margin-left:.2rem; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;这较 6 月份时宣布的数字有所增长。今年 6 月，Neuralink 合作伙伴巴罗神经学研究所称，已有 7 名严重瘫痪的患者接受了 Neuralink 的植入物，并正在使用它们通过意念控制数字设备和物理设备。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#2a3840; margin-left:.2rem; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;Neuralink 公司周二在社交平台 X 上表示，这些患者累计使用其设备达 2000 天，总使用时长超过 1.5 万小时。今年 7 月，Neuralink 宣布将在英国启动芯片临床试验，并与伦敦大学学院医院和纽卡斯尔医院合作开展研究。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#2a3840; margin-left:.2rem; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;今年 6 月，Neuralink 在一轮融资中获得了 6.5 亿美元的资金支持。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371279</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371279</guid>
      <pubDate>Sun, 07 Sep 2025 03:27:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 训练初创公司 Mercor 欲争取超 100 亿美元估值</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Mercor 是一家成立仅两年的初创公司，专注于为像 OpenAI 和 Meta 这样的企业提供所需的领域专家，以帮助训练和优化其基础 AI 模型。根据 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F09%2F09%2Fsources-ai-training-startup-mercor-eyes-10b-valuation-on-450-million-run-rate%2F" target="_blank"&gt;TechCrunch&lt;/a&gt; 获取的一份市场文件和知情人士的说法，Mercor 目前正在与投资者讨论进行第三轮融资（Series C）。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该公司目前的目标是将估值提升至 100 亿美元或以上，较几个月前讨论的 80 亿美元估值有所上升。尽管最终交易条款仍可能变化，但 Mercor 向潜在投资者透露，他们已经收到多份出价，其中一些的估值甚至高达 100 亿美元。此外，Mercor 还通过特殊目的工具（SPVs）引入了至少两位新投资者以为潜在交易筹集资金。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="235" src="https://oscimg.oschina.net/oscnet/up-92ca9e29d9459031238d3de4cc4e1550f83.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Mercor 在 2 月份宣布的上一轮融资为一轮 1 亿美元的 B 轮融资，估值为 20 亿美元。根据知情人士的消息，Mercor 的年化收入（ARR）接近 4.5 亿美元。早在 2 月，Mercor 就曾对外宣布其年收入达到 7500 万美元，而其首席执行官 Brendan Foody 在 3 月时通过社交媒体表示 ARR 已达 1 亿美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该公司表示，预计将比另一家初创公司 Anysphere 更快地达到 5 亿美元的年收入里程碑。Anysphere 以其 AI 编码助手 Cursor 而知名，并在推出产品后约一年才实现 5 亿美元的年收入。与仍在烧钱的 Anysphere 不同，Mercor 在上半年的利润达到了 600 万美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Mercor 的收入来源于为企业提供专业领域专家以执行 AI 模型训练，比如科学家、医生和律师等，按小时收费。这家公司声称为包括亚马逊、谷歌、Meta、微软、OpenAI 等在内的五大 AI 实验室提供数据标注承包商。根据消息人士的透露，Mercor 的部分收入来自于这些品牌中的 OpenAI。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了进一步多样化业务模式，Mercor 正在向投资者表示，他们计划增加更多用于强化学习的软件基础设施。这种训练方法能够让模型的决策经过验证或反驳，从而融入反馈并持续改善。公司还打算最终建立一个 AI 驱动的招聘市场。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尽管 Mercor 面临来自 Surge AI 等公司的竞争，后者也在谈判以 250 亿美元的估值筹集资金，Mercor 仍然保持乐观。Co-founder Foody 表示:「我们并没有努力进行融资」，并且每月都会拒绝投资者的多项出价。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Mercor 的三位联合创始人均为哈佛大学辍学生，都是二十出头，近期还聘请了前 Uber 首席产品官 Sundeep Jain 担任首任总裁，以助力公司发展。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;不过，Mercor 也正面临来自竞争对手 Scale AI 的诉讼，后者指控其侵犯商业秘密，称一名前员工在加入 Mercor 前 「窃取了超过 100 份关于 Scale 客户策略和其他专有信息的机密文件」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371277</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371277</guid>
      <pubDate>Sun, 07 Sep 2025 03:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>前端日志回捞系统的性能优化实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、前言&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;在现代前端应用中，日志回捞系统是排查线上问题的重要工具。然而，传统的日志系统往往面临着包体积过大、存储无限膨胀、性能影响用户体验等问题。本文将深入分析我们在&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;@dw/log&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;和&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;@dw/log-upload&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;两个库中实施的关键性能优化，以及改造过程中遇到的技术难点和解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;核心优化策略概览：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们的优化策略主要围绕三个核心问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;存储膨胀问题&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt; - 通过智能清理策略控制本地存储大小&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;包体积问题&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt; - 通过异步模块加载实现按需引入&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;性能影响问题&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt; - 通过队列机制和节流策略提升用户体验&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、核心性能优化&lt;/h1&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;优化一：智能化数据库清理机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;问题背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;传统日志系统的一个重大痛点是本地存储无限膨胀。用户长期使用后，IndexedDB 可能积累数万条日志记录，不仅占用大量存储空间，更拖慢了所有数据库查询和写入操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;解决方案：双重清理策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们实现了一个智能清理机制，它结合了两种策略，并只在浏览器空闲时执行，避免影响正常业务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;双重清理&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;：&lt;/span&gt;&lt;/span&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;按时间清理&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 删除&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;N&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;天前的所有日志。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;按数量清理&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 当日志总数超过阈值时，删除最旧的日志，直到数量达标。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;/**
 * 综合清理日志（同时处理过期和数量限制）
 * @param retentionDays 保留天数
 * @param maxLogCount 最大日志条数
 */
async cleanupLogs(retentionDays?: number, maxLogCount?: number): Promise&amp;lt;void&amp;gt; {
  if (!this.db) {
    throw new Error('Database not initialized')
  }
  
  try {
    // 先清理过期日志
    if (retentionDays &amp;amp;&amp;amp; retentionDays &amp;gt; 0) {
      await this.clearExpiredLogs(retentionDays)
    }
    
    // 再清理超出数量限制的日志
    if (maxLogCount &amp;amp;&amp;amp; maxLogCount &amp;gt; 0) {
      await this.clearExcessLogs(maxLogCount)
    }
  } catch (error) {
    // 日志清理失败不应该影响主流程
    console.warn('日志清理失败:', error)
  }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;智能调度&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;：&lt;/span&gt;&lt;/span&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;节流&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 保证清理操作在短时间内（如 5 分钟）最多执行一次。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;空闲执行&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 将清理任务调度到浏览器主线程空闲时执行，确保不与用户交互或页面渲染争抢资源。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;/**
 * 检查并执行清理（节流版本，避免频繁清理）
 */
private checkAndCleanup = (() =&amp;gt; {
  let lastCleanup = 0
  const CLEANUP_INTERVAL = 5 * 60 * 1000 // 5 分钟最多清理一次
  
  return () =&amp;gt; {
    const now = Date.now()
    if (now - lastCleanup &amp;gt; CLEANUP_INTERVAL) {
      lastCleanup = now
      executeWhenIdle(() =&amp;gt; {
        this.performCleanup()
      }, 1000)
    }
  }
})()&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;优化二：上传模块的异步加载架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=NWRiNTYyZGZkOGM4ODczZWUxYjAxZTc0YTgxNzNlODcsMTc1NzM5NjY0MzgxMw==" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;问题背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;日志上传功能涉及 OSS 上传、文件压缩等重型依赖，如果全部打包到主库中，会显著增加包体积。更重要的是，大部分用户可能永远不会触发日志上传功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;解决方案：动态模块加载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;189KB 的包体积是不可接受的。分析发现，包含文件压缩（JSZip）和 OSS 上传的 &lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;@dw/log-upload&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;模块是体积元凶，但 99% 的用户在正常浏览时根本用不到它。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们采取了「核心功能+插件化」的设计思路，将非核心的上传功能彻底分离。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;上传模块分离&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 将上传逻辑拆分为独立的&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;@dw/log-upload&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;库，并通过 CDN 托管。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;动态加载实现&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 仅在用户手动触发「上传日志」时，才通过动态创建&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;script&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;标签的方式，从 CDN 异步加载上传模块。我们设计了一个单例加载器确保模块只被请求一次。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;/**
 * OSS 上传模块的远程 URL
 */
const OSS_UPLOADER_URL = 'https://cdn-jumper.dewu.com/sdk-linker/dw-log-upload.js'


/**
 * 动态加载远程模块
 * 使用单例模式确保模块只加载一次
 */
const loadRemoteModule = async (): Promise&amp;lt;LogUploadModule&amp;gt; =&amp;gt; {
  if (!moduleLoadPromise) {
    moduleLoadPromise = (async () =&amp;gt; {
      try {
        await loadScript(OSS_UPLOADER_URL)
        return window.DWLogUpload
      } catch (error) {
        moduleLoadPromise = null
        throw error
      }
    })()
  }
  return moduleLoadPromise
}


/**
 * 上传文件到 OSS
 */
export const uploadToOss = async (file: File, curEnv?: string, appId?: string): Promise&amp;lt;string&amp;gt; =&amp;gt; {
  try {
    // 懒加载上传函数
    if (!ossUploader) {
      const module = await loadRemoteModule()
      ossUploader = module.uploadToOss
    }
    
    const result = await ossUploader(file, curEnv, appId)
    return result
  } catch (error) {
    console.info('Failed to upload file to OSS:', error)
    return ''
  }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;优化三：JSZip 库的动态引入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们避免将 JSZip 打包到主库中，从主包中移除，改为在上传模块内部动态引入，优先使用业务侧可能已加载的全局&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;window.JSZip&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;/**
 * 获取 JSZip 实例
 */
export const getJSZip = async (): Promise&amp;lt;JSZip | null&amp;gt; =&amp;gt; {
  try {
    if (!JSZipCreator) {
      const module = await loadRemoteModule()
      JSZipCreator = module.JSZipCreator
    }
    
    zipInstance = new window.JSZip()
    return zipInstance
  } catch (error) {
    console.info('Failed to create JSZip instance:', error)
    return null
  }
}


// 在上传模块中实现灵活的 JSZip 加载
export const JSZipCreator = async () =&amp;gt; {
  // 优先使用全局 JSZip（如果页面已经加载了）
  if (window.JSZip) {
    return window.JSZip
  }
  return JSZip
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;优化四：日志队列与性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=ZjcxZDc1N2ExYjgzZTJhNDE3N2YzZjJlMzY3MTllN2MsMTc1NzM5NjY0MzgxMw==" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;在某些异常场景下，日志会短时间内高频触发（如循环错误），密集的&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;IndexedDB.put()&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;操作会阻塞主线程，导致页面卡顿。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们引入了一个日志队列，将所有日志写入请求「缓冲」起来，再由队列控制器进行优化处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 设置每秒最多处理的日志条数（如 50 条），超出部分直接丢弃。&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;错误（Error）级别的日志拥有最高优先级，不受此限制&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;，确保关键信息不丢失。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;批处理与空闲执行&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;： 将队列中的日志打包成批次，利用&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;requestIdleCallback&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;在浏览器空闲时一次性写入数据库，极大减少了 I/O 次数和对主线程的占用。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;export class LogQueue {
  private readonly MAX_LOGS_PER_SECOND = 50
  
  /**
   * 检查限流逻辑
   */
  private checkRateLimit(entry: LogEntry): boolean {
    // 错误日志总是被接受
    if (entry.level === 'error') {
      return true
    }
    
    const now = Date.now()
    if (now - this.lastResetTime &amp;gt; 1000) {
      this.logCount = 0
      this.lastResetTime = now
    }
    
    if (this.logCount &amp;gt;= this.MAX_LOGS_PER_SECOND) {
      return false
    }
    
    this.logCount++
    return true
  }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;空闲时间处理机制：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;export function executeWhenIdle(callback: () =&amp;gt; void, timeout: number = 2000): void {
  if (typeof window !== 'undefined' &amp;amp;&amp;amp; 'requestIdleCallback' in window) {
    window.requestIdleCallback(() =&amp;gt; {
      callback()
    }, { timeout })
  } else {
    setTimeout(callback, 50)
  }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、打包构建中的技术难点与解决方案&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;在改造过程中，我们遇到了许多与打包构建相关的技术难题。这些问题往往隐藏较深，但一旦出现就会阻塞整个开发流程。以下是我们遇到的主要问题和解决方案：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;难点一：异步加载 import()&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;打包失败问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;await import('./module')&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;语法在 Rollup 打包为 UMD 格式时会直接报错，因为 UMD 规范本身不支持代码分割。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 这样的代码会导致 UMD 打包失败
const loadModule = async () =&amp;gt; {
  const module = await import('./upload-module')
  return module
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;错误信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Error: Dynamic imports are not supported in UMD builds
[!] (plugin commonjs) RollupError: "import" is not exported by "empty.js"&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;解决方案：inlineDynamicImports 配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;通过在 Rollup 配置中设置&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;inlineDynamicImports: true&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;来解决这个问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// rollup.config.js
export default {
  input: 'src/index.ts',
  output: [
    {
      file: 'dist/umd/dw-log.js',
      format: 'umd',
      name: 'DwLog',
      // 关键配置：内联动态导入
      inlineDynamicImports: true,
    },
    {
      file: 'dist/cjs/index.js',
      format: 'cjs',
      // CJS 格式也需要这个配置
      inlineDynamicImports: true,
    }
  ],
  plugins: [
    typescript(),
    resolve({ browser: true }),
    commonjs(),
  ]
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;配置说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;inlineDynamicImports: true&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;会将所有动态导入的模块内联到主包中&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;这解决了 UMD 格式不支持动态导入的问题&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;难点二：process 对象未定义问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;打包后的代码在浏览器环境中运行时出现&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;process is not defined&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;错误：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ReferenceError: process is not defined
    at Object.&amp;lt;anonymous&amp;gt; (dw-log.umd.js:1234:56)&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;这通常是因为某些 Node.js 模块或工具库在代码中引用了 process 对象，而浏览器环境中并不存在。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;解决方案：插件注入 process 对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;我们使用&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;@rollup/plugin-inject&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;插件，在打包时向代码中注入一个模拟的&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;process&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt; 对象，以满足这些库的运行时需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;创建&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;process-shim.js&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;文件提供浏览器端的&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;process&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;实现。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;在&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;rollup.config.js&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;中配置插件：&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;// rollup.config.js
import inject from '@rollup/plugin-inject'
import path from 'path'


export default {
  // ... 其他配置
  plugins: [
    // 注入 process 对象
    inject({
      // 使用文件导入方式注入 process 对象
      process: path.join(__dirname, 'process-shim.js'),
    }),
    typescript(),
    resolve({ browser: true }),
    commonjs(),
  ]
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;创建 &lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#d6d6d6"&gt;process-shim.js&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt; 文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// process-shim.js
// 为浏览器环境提供 process 对象的基本实现
export default {
  env: {
    NODE_ENV: 'production'
  },
  browser: true,
  version: '',
  versions: {},
  platform: 'browser',
  argv: [],
  cwd: function() { return '/' },
  nextTick: function(fn) {
    setTimeout(fn, 0)
  }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;高级解决方案：条件注入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;为了更精确地控制注入，我们还可以使用条件注入：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;inject({
  // 只在需要的地方注入 process
  process: {
    id: path.join(__dirname, 'process-shim.js'),
    // 可以添加条件，只在特定模块中注入
    include: ['**/node_modules/**', '**/src/utils/**']
  },
  // 同时处理 global 对象
  global: 'globalThis',
  // 处理 Buffer 对象
  Buffer: ['buffer', 'Buffer'],
})&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;难点三：第三方依赖的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;ESM/CJS 兼容性问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;问题描述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;某些第三方库（如 JSZip、@poizon/upload）在不同模块系统下的导入方式不同，导致打包后出现导入错误：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;TypeError: Cannot read property 'default' of undefined&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;解决方案：混合导入处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 处理 JSZip 的兼容性导入
let JSZipModule: any
try {
  // 尝试 ESM 导入
  JSZipModule = await import('jszip')
  // 检查是否有 default 导出
  JSZipModule = JSZipModule.default || JSZipModule
} catch {
  // 降级到全局变量
  JSZipModule = (window as any).JSZip || require('jszip')
}


// 处理 @poizon/upload 的导入
import PoizonUploadClass from '@poizon/upload'


// 兼容不同的导出格式
const PoizonUpload = PoizonUploadClass.default || PoizonUploadClass&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;在 Rollup 配置中加强兼容性处理：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;export default {
  plugins: [
    resolve({
      browser: true,
      preferBuiltins: false,
      // 解决模块导入问题
      exportConditions: ['browser', 'import', 'module', 'default']
    }),
    commonjs({
      // 处理混合模块
      dynamicRequireTargets: [
        'node_modules/jszip/**/*.js',
        'node_modules/@poizon/upload/**/*.js'
      ],
      // 转换默认导出
      defaultIsModuleExports: 'auto'
    }),
  ]
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、性能测试与效果对比&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;打包优化效果对比：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=M2FhYzI1ODFiNTk1YWUwZTdmMmE4OTAzMGQ2ZTdmNmMsMTc1NzM5NjY0MzgxMw==" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、总结&lt;/h1&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;通过解决这些打包构建中的技术难点，我们不仅成功完成了日志系统的性能优化，还积累了工程化经验。这些实践不仅带来了日志系统本身的轻量化与高效化，其经验对于任何追求高性能和稳定性的前端项目都有部分参考价值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1. 得物灵犀搜索推荐词分发平台演进 3.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2. R8 疑难杂症分析实战：外联优化设计缺陷引起的崩溃｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3. 可扩展系统设计的黄金法则与 Go 语言实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4. 营销会场预览直通车实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5. 基于 TinyMce 富文本编辑器的客服自研知识库的技术探索和实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;文 / 沸腾&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18691140</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18691140</guid>
      <pubDate>Sun, 07 Sep 2025 03:13:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>腾讯混元图像模型 2.1 上新并开源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXAs9XzcbhF6HDDjK1iPg4w" target="_blank"&gt;宣布&lt;/a&gt;&lt;strong&gt;混元图像模型 2.1（HunyuanImage-2.1）&lt;/strong&gt;上新并开源。该模型支持原生 2K 生图，能输出更清晰、细节更丰富的图像，满足专业设计与创作需求。同时，其支持中英文原生输入，解决语言限制问题，拓宽全球用户使用范围。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1736" src="https://static.oschina.net/uploads/space/2025/0910/104600_eFCx_2720166.png" width="2754" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://hunyuan.tencent.com/image/zh&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;混元图像模型 2.1 还支持长达 1k tokens 的复杂语义超长 prompt，对图像中文字渲染和场景细节把控更稳定。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0910/104649_SwuS_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，混元文生图大模型 HunyuanImage-2.1 的参数规模达到 17B，该模型采用了双流 DiT 架构，配备了 MLLM+ByT5 双文本编码器和 32×32 的高压缩 VAE。官方提供了 base、refine 以及 meanflow 蒸馏版，推理步数可从 100 步压缩至 8 步，同时保持高质量画质。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-3a41674af41bb75394bc59dcacf3f4f85f6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;HunyuanImage-2.1 在复杂语义理解、多主体分别控制、中英文字体生成、连环画与海报等场景下表现出色。它支持最长 1000 tokens 的提示词，能够精准还原人物的表情、动作以及图文混排的细节。同时，官方还开源了配套的 PromptEnhancer 文本改写模型，用于结构化地优化用户输入的指令。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://huggingface.co/tencent/HunyuanImage-2.1&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371265</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371265</guid>
      <pubDate>Sun, 07 Sep 2025 02:47:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>首款 AI Agent 浏览器 Fellou CE 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;硅谷公司 Fellou 近日推出了一款名为 Fellou CE（概念版）的 AI 浏览器。该浏览器并不仅仅是一个信息获取工具，而是一个可以执行复杂任务的智能助手，旨在提升用户的工作效率和创造力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;Fellou 的创始人兼 CEO Dominic Xie 指出，现今科技界普遍关注 AI 节省时间的能力，但他认为这种思维是有误的。他表示，AI 的真正价值在于它能作为 「认知杠杆」，帮助人们更好地思考、创造和解决复杂问题。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="293" src="https://oscimg.oschina.net/oscnet/up-10703979e17b41a08a1f20297519d4e33e0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Fellou 的设计理念是希望用户从繁重的手动操作中解放出来，将工作流程自动化，转而专注于更高层次的创造性思维。比如，用户只需告诉 Fellou：「请分析我的 LinkedIn 个人资料，并找出 10 个适合我的产品负责人职位，然后用我桌面上的定制简历申请。」Fellou 会自动完成这一过程，包括浏览多个网站、分析职位要求，并将用户的简历发送出去。用户在此过程中仍可保持对每一步操作的实时控制。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Fellou 的创新在于其 「无缝体验连续体」 的构建，涵盖三个主要方面:交互连续体、任务连续体和记忆连续体。通过自然对话的方式，Fellou 能够理解用户的意图并主动提供帮助，而不是单纯等待用户的指令。此外，Fellou 通过整合不同应用的记忆，帮助用户建立一个完整的数字思维导图，以便更好地进行决策。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-85129da5335441e4e19fc7ed4d3ca167894.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在与 Fellou CE 的交互中，用户会发现任务处理变得更加连贯。Fellou CE 打破了传统浏览器的割裂体验，让人机交互更加自然。用户只需用自然语言下达指令，Fellou CE 便会理解并执行，无需繁琐的手动操作。同时，它还具备记忆功能，能够根据用户的历史操作和偏好，智能优化信息推荐，让每次使用都更为高效。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Fellou CE 的 Deep Search 和 Visual Report 功能现已免费开放，用户可以精准获取所需信息，并将零散的数据转化为可视化的报告。此外，Fellou CE 在信息安全方面也表现优异，用户的隐私和数据得到了有效保护。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371264</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371264</guid>
      <pubDate>Sun, 07 Sep 2025 02:47:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>DCloud 发布并开源 uni-ai x，全平台支持的原生 AI 聊天套件</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DCloud 发布并开源了 uni-ai x，这是一个开源、免费、全平台支持的原生 AI 聊天套件，基于 DCloud 的新一代跨平台原生框架 uni-app x 开发，支持 Android、iOS、鸿蒙、Web、微信小程序，一套代码、多端运行。&lt;/p&gt; 
&lt;p&gt;据介绍，uni-ai x 功能上参考 deepseek 的客户端设计，并扩展了更多平台。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;多端支持与主题适配，支持 Web/H5、iOS、Android、鸿蒙 App、微信小程序。Web 端采用响应式布局，适配 PC 宽屏和移动设备，并提供浅色和暗黑两种主题模式&lt;/li&gt; 
 &lt;li&gt;丰富的 AI 服务集成与高级功能，集成多家主流 AI 服务商，用户可灵活切换不同 AI 模型，部分模型支持"深度思考"和"联网搜索"等高级能力&lt;/li&gt; 
 &lt;li&gt;消息与会话管理&lt;br&gt; 支持多轮对话和历史会话管理，具备会话切换、删除、自动创建等功能，提供完整的 AI 聊天体验&lt;/li&gt; 
 &lt;li&gt;高级渲染与输出特性，支持 AI 回复内容的流式输出和原生 Markdown 格式渲染，内置高性能解析器，支持代码高亮和复杂文本结构展示&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img height="863" src="https://static.oschina.net/uploads/space/2025/0910/103753_tGh3_2720166.png" width="1269" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="977" src="https://static.oschina.net/uploads/space/2025/0910/103817_QkOd_2720166.png" width="1267" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="588" src="https://static.oschina.net/uploads/space/2025/0910/103812_0wvP_2720166.png" width="538" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/dcloudio/uni-ai-x&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371259</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371259</guid>
      <pubDate>Sun, 07 Sep 2025 02:39:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>TIOBE 9 月榜单：Perl 重回前十</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#333333"&gt;TIOBE 公布了 2025&amp;nbsp;年 9 月的&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank"&gt;编程语言排行榜&lt;/a&gt;&lt;span style="color:#333333"&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="75" src="https://oscimg.oschina.net/oscnet/up-467a097bee60dd5d6fc612336b75c07031b.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Perl 在本月重回榜单前十，而就在一年前，Perl 还排在第 27 位。TIOBE CEO&amp;nbsp;Paul Jansen 表示，&lt;/span&gt;&lt;span style="color:#24292e"&gt;尽管 Perl 鼎盛时期（2005 年 3 月）也曾排在第 3 位，但其目前的复苏仍然引人注目，值得探讨。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#24292e"&gt;他认为，技术层面上，Perl 能获得如此高的排名主要归功于其在亚马逊平台上庞大的书籍数量 —— 是 PHP 的 4 倍，更是 Rust 的 7 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style="color:#24292e"&gt;「至于 Perl 人气飙升的'真正'原因，我并不清楚。我能想到的唯一可能性是，Perl 5 现在逐渐被认为是真正的 Perl。Larry Wall 于 2000 年前后宣布开发全新的 Perl 6。Perl 6 的实现耗时数十年，甚至导致该语言被重新命名为 Raku。在这几十年里，Perl 5 的旧开发基本停滞，这导致 Perl 社区充满了不确定性。与此同时，一个不错的替代方案 Python 逐渐成熟，许多 Perl 程序员转向了 Python。如今，25 年过去了，Perl 6/Raku 在 TIOBE 指数中排名第 129 位，在编程世界中几乎毫无存在感。另一方面，Perl 5 近期发布频率显著提升，正重新获得关注。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong style="color:#333333"&gt;TIOBE 9 月 TOP 20 编程语言&lt;/strong&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img height="412" src="https://oscimg.oschina.net/oscnet/up-63ab2073a52c7f2f78056dc95f146d32acf.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;TOP 10 编程语言 TIOBE 指数走势（2002-2024）&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="224" src="https://oscimg.oschina.net/oscnet/up-e0ef170acb26b1390f1c24ea262620f389a.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;第 21-50 名编程语言排行&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="417" src="https://oscimg.oschina.net/oscnet/up-40f53b5cf7207bc809e1433eebc5d0cd25f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;第 51-100 名如下，由于它们之间的数值差异较小，仅以文本形式列出（按字母排序）：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;ActionScript, Algol, Alice, Apex, Awk, B4X, CLIPS, Clojure, D, Eiffel, Elm, F#, Forth, Groovy, Hack, Icon, Inform, Io, J, JScript, Logo, Modula-2, Mojo, MQL5, NATURAL, Nim, Oberon, OCaml, Occam, OpenCL, OpenEdge ABL, PL/I, Q, Racket, REXX, Ring, RPG, Scheme, Simulink, Smalltalk, SPARK, Stata, Structured Text, SystemVerilog, Tcl, Vala/Genie, VHDL, Wolfram, X++, Xojo&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;TIOBE 编程社区指数（The TIOBE Programming Community index）是一个衡量编程语言受欢迎程度的指标，该指数每月更新一次。评判的依据来自世界范围内的工程师、课程和第三方供应商，包括流行的搜索引擎，如 Google、必应、雅虎、维基百科、亚马逊、YouTube 和百度都被用于指数计算。值得注意的是，TIOBE 指数并不代表编程语言的好坏或编写代码的多少。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;该指数可以用来检查你的编程技能是否还能跟上时代的步伐，或者在开始建立一个新的软件系统时，基于指数对采用何种编程语言做出决策。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2Fprogramminglanguages_definition%2F" target="_blank"&gt;TIOBE 指数&lt;/a&gt;&lt;span style="color:#000000"&gt;的定义方式，以及详细榜单信息&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tiobe.com%2Ftiobe-index%2F" target="_blank"&gt;均可查看官网&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/371255/tiobe-index-202509</link>
      <guid isPermaLink="false">https://www.oschina.net/news/371255/tiobe-index-202509</guid>
      <pubDate>Sun, 07 Sep 2025 02:19:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
