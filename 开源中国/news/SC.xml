<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 03 Sep 2025 02:46:00 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>OpenAI 收购产品测试初创公司 Statsig</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenAI &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1962943308935864793" target="_blank"&gt;宣布&lt;/a&gt;将以全股票交易方式收购产品测试初创公司&amp;nbsp;Statsig。此次交易基于 OpenAI 当前 3000 亿美元（现汇率约合 2.14 万亿元人民币）的估值，交易金额约为 11 亿美元（现汇率约合 78.48 亿元人民币）。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1430" src="https://static.oschina.net/uploads/space/2025/0903/103919_Da3c_2720166.png" width="1278" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据 OpenAI 安排，Statsig 首席执行官 Vijaye Raji 加盟后将出任 OpenAI 应用技术负责人，负责推动公司在人工智能产品上的发展。Vijaye Raji 将领导 ChatGPT 和代码生成工具 Codex 的产品工程工作，涵盖核心系统及包括基础设施在内的产品线。&lt;/p&gt; 
&lt;p&gt;OpenAI 表示，Statsig 将继续独立运营，并在西雅图办公室为其客户群提供服务。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369990</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369990</guid>
      <pubDate>Wed, 03 Sep 2025 02:41:59 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>系统梳理 RAG 系统的 21 种分块策略</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;编者按：&lt;/strong&gt; 我们今天为大家带来的文章，作者的观点是：分块（chunking）才是决定 RAG 系统成败的真正关键因素，不同场景需要匹配相应的分块策略。&lt;/p&gt; 
 &lt;p&gt;本文系统梳理了从基础到进阶的 21 种分块策略，涵盖了基础分块法、定长分块法、滑动窗口分块等传统方法，以及语义分块、上下文增强分块、多模态分块等前沿技术。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;作者 | Anjolaoluwa Ajayi&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;编译 | 岳扬&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;检索增强生成（RAG）是许多 AI 工程师又爱又恨的技术（包括我）。&lt;/p&gt; 
&lt;p&gt;没错，因为从理论上看，它简单极了："从你的定制数据中检索正确的上下文，然后让大语言模型基于此生成回答"。&lt;/p&gt; 
&lt;p&gt;但在实践中，你不得不面对海量杂乱无章的数据 ------ 这些数据以你见过的最混乱随机的格式存储，接着就是数日绞尽脑汁的试错：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;调整文本块（tweaking chunks）&lt;/li&gt; 
 &lt;li&gt;切换嵌入模型（switching embedding models）&lt;/li&gt; 
 &lt;li&gt;替换检索器（swapping out retrievers）&lt;/li&gt; 
 &lt;li&gt;微调排序器（fine-tuning rankers）&lt;/li&gt; 
 &lt;li&gt;重写提示词（rewriting prompts）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;而模型依然回复："我找不到足够的信息来回答你的问题"。&lt;/p&gt; 
&lt;p&gt;更糟糕的是，它还会一本正经地输出完全错误的答案（产生幻觉）。&lt;/p&gt; 
&lt;p&gt;毋庸置疑，RAG 系统中存在许多复杂的组件，但真正默默决定整个系统是否能正常运行的关键因素其实是分块（chunking）。&lt;/p&gt; 
&lt;p&gt;不同的数据类型、文件格式、内容结构、文档长度和使用场景，都需要匹配不同的分块策略。&lt;/p&gt; 
&lt;p&gt;一旦出错，你的模型要么抓不住重点，要么... 好吧，还是抓不住重点。&lt;/p&gt; 
&lt;p&gt;本文将解析 21 种分块策略（从基础到进阶），并说明何时该用何种策略，让你的 RAG 系统不再...掉链子。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）基础分块法（按换行符分割）Naive chunking (split by newline)&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;遇到换行符就分割文本。仅此而已。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-aac59a23bc7029033fcf8a11d14813466fe.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基础分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理由换行符统一分隔的文本：笔记、项目列表、FAQ、聊天记录或每一行都包含完整语义的文字转录稿。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;注意：如果内容行过长，可能超出 LLM 的词元限制。如果内容行过短，模型可能遗漏上下文或产生幻觉。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）定长分块法 Fixed-size/ fixed window chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;按固定字符数/单词数切割文本（即便这样会切断完整句子或语义单元）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a45e305daade3d1a01c0e9203e2945c6887.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;定长分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;适用于原始的、杂乱的文本数据，如扫描文档、质量较差的转录文本，或无标点、无标题、无其他结构的大型文本文件。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;3）滑动窗口分块法 Sliding window chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;类似定长分块，但每个文本块会与前块内容重叠，以保持跨块上下文之间的关联。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7444ed4446a7b18972e69873268f49ce6b5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;滑动窗口分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理需要保持长句间逻辑连贯性的文本类型：议论文、敍述性报告、自由形式的写作等。&lt;/li&gt; 
 &lt;li&gt;与定长分块法类似，适用于无结构的文本（无标题、无标点、无框架等），但需注意词元消耗与上下文连贯性间的平衡。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;4）按句分块法 Sentence-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在句子结尾处分割文本（通常以句号、问号或感叹号为标记）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b367665f0d9c3ed62a9947f840b2a432e02.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;按句分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;适用于语义清晰的规整文本，每句话都承载着完整的语义，如技术博客、内容摘要或文档。&lt;/li&gt; 
 &lt;li&gt;可作为初级的分块手段产出小而聚焦的文本块，便于后续通过更复杂的分块技术重新组合或重排序这些文本块。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;5）按段分块法 Paragraph-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;依据段落分割文本（通常以双换行符为界），使每块均包含完整的语义单元。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-2c7a17ffc9900413bee4e4876e63a3d2313.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;按段分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;当按句分块所得内容过于零碎时&lt;/li&gt; 
 &lt;li&gt;处理已具备段落结构的文档，如议论文、博客文章或研究报告&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;6）按页分块法 Page-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将每个物理页面视为一个独立文本块。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d3d5ed6036f56381e294776b0278b592f91.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;按页分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理含固定页面的文档，如扫描版 PDF、演示文稿或书籍。&lt;/li&gt; 
 &lt;li&gt;需保留页面布局的检索场景（如在检索时需要引用页码）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;7）按预定结构分块法 Structured chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;依据预定结构（如具有固定格式的系统日志记录、结构化数据中的预定义字段、HTML 标签或 Markdown 元素）分割文本。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-026219009a535dc1fab3f2c997e8008d992.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;按预定结构分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理结构化/半结构化数据，如系统日志、JSON 记录、CSV 文件或 HTML 文档。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;8）基于文档层级的分块法 Document-Based Chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基于文档固有结构分块（按标题/小标题/章节划分）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b84c5944054dae03b472a53b5755357c6ec.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于文档层级的分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;当源文件具备清晰的章节结构时，如在技术文章、操作手册、教材或学术论文中。&lt;/li&gt; 
 &lt;li&gt;可作为进阶分块技术（如按层级分块（hierarchical chunking））的预处理步骤。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;9）基于关键词的分块法 Keyword-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在预设关键词出现处分割文本，将其视为逻辑断点。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-52342e4376cd9af58f38aebe5ce5b67fe76.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于关键词的分块法示例（关键词为"Note"）| 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;文档无标题结构但含标志性的关键词（且这些关键词可稳定标记新主题的起始）时使用&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;10）基于实体的分块法 Entity-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;使用命名实体识别（NER）模型检测人物、地点、产品等实体，将相关文本围绕每个实体分组形成区块。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-97102370a8e5e20777eb3c82de6f1cdd4c3.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于实体的分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理特定类型的实体（人物/地点/组织等）对文档理解起决定性作用的文件，如新闻报道、法律合同、案例研究或电影剧本。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;11）基于词元数的分块法 Token-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过 tokenizer（分词器）按词元数量分割文本。&lt;/p&gt; 
&lt;p&gt;建议结合按句分块法（sentence chunking）等技术使用，避免破坏句子完整性导致上下文被破坏。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;无标题/无段落结构的非结构化文档。&lt;/li&gt; 
 &lt;li&gt;使用低词元限制的 LLM 时（避免响应被强制截断或长文本输入被丢弃）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;12）基于主题的分块法 Topic-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当文本主题发生变化时，可以通过以下方式对文本进行分块：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先，将文本拆分为小单元（句子/段落）&lt;/li&gt; 
 &lt;li&gt;然后，使用主题建模或聚类算法将相关单元合并为区块&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-4952968eff24cefc81394f3cc90f7f6ed29.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于主题的分块法示例（使用聚类算法） | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;当文档涵盖多个主题，且需保持语义焦点时。&lt;/li&gt; 
 &lt;li&gt;适用于主题转变较为平缓但未通过明确的标题或关键词标注的文本。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;13）表格感知分块法 Table-aware chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;独立识别表格内容，并按 JSON 或 Markdown 格式分块（可逐行/逐列/整表处理）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-eb4793bfb1b79b9c3a4b4315e76de7c52be.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;表格感知分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;含表格元素的文档。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;14）内容感知分块法 Content-aware chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;根据内容类型动态调整分块策略（为段落/表格/列表等内容适配不同规则）。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;混合格式的文档（含多种文本结构）。&lt;/li&gt; 
 &lt;li&gt;需保持原生格式完整性的场景（表格不分割/段落不截断等）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;15）上下文增强分块法 Contextual chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;通过 LLM 实现：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;分析知识库的部分或全部内容。&lt;/li&gt; 
 &lt;li&gt;在嵌入前为每个文本块注入简短且相关的上下文&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1d6d9025312ebbe29eaf51b4b6b34cd9500.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上下文增强分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;知识库的全部内容或部分内容在 LLM 的词元限额内。&lt;/li&gt; 
 &lt;li&gt;处理复杂文档（如财报/合同等）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;16）语义分块法 Semantic chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;基于嵌入相似度聚合主题相关的句子/段落，保持语义聚焦性。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;当按段分块法或定长分块法失效时&lt;/li&gt; 
 &lt;li&gt;处理含混杂主题的长文档。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;17）递归分块法 Recursive chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;首先使用大粒度的分隔符（如段落）分割文本。&lt;/p&gt; 
&lt;p&gt;如果任何生成的分块超过预设的分块大小限制，对这些区块递归使用小粒度分隔符（如句子或单词）进行分割，直至所有分块都符合所需大小。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;处理句子长度不规则或不可预测的文本，如访谈记录、演讲内容、自由形式的写作内容。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;18）嵌入优先分块法 Embedding chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;常规流程是先分块后嵌入，但此方法先将所有句子全部嵌入，再按顺序逐一处理，若相邻句的相似度高于设定阈值则合并为一组，低于阈值则进行拆分。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;无结构（无句子分隔/标题/章节符/标记等）的文档&lt;/li&gt; 
 &lt;li&gt;当基础技术（如滑动窗口分块法）效果不佳时&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;19）基于大模型/智能体的分块法 Agentic / LLM-based chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将分块的决策权完全交由 LLM，由其自主决定文本的分割方式。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;当内容复杂或结构不明确，需要类似人类的判断力来确定分块边界时&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;注意：该方法计算成本较高。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;20）分层分块法 Hierarchical chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将文本按照多个层次（如章节、子章节、段落）进行分块，以便用户能够以不同详细程度检索信息。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-df9847bbe55d72931ed01a97cd9733e3296.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;具备清晰层次结构的文档，如技术文章、手册、教材、研究论文等&lt;/li&gt; 
 &lt;li&gt;希望用户在不丢失上下文的情况下，同时探索整体概述和详细信息。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;21）多模态分块法 Modality-Aware Chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;针对不同内容类型（文本、图像、表格）实施差异化的分块策略。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-5307d62e093d2da55f11a7312ab574d1830.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;多模态分块法示例 | 此图片由原文作者制作&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;BONUS：混合分块法 Hybrid chunking&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;融合多种分块技术、启发式规则、嵌入模型以及 LLM 来提升分块过程的可靠性。&lt;/p&gt; 
&lt;p&gt;适用场景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;单一分块方法效果不足时，需组合方案应对复杂的数据结构。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本期互动内容 🍻&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;❓在处理特定类型文档（如法律合同或学术论文）时，您有哪些独特的分块技巧可以分享？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.gopubby.com%2F21-chunking-strategies-for-rag-f28e4382d399" target="_blank"&gt;https://ai.gopubby.com/21-chunking-strategies-for-rag-f28e4382d399&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/IDP/blog/18690430</link>
      <guid isPermaLink="false">https://my.oschina.net/IDP/blog/18690430</guid>
      <pubDate>Wed, 03 Sep 2025 02:33:03 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>开源 AI 客户端 Cherry Studio 1.5.9 发布：免费 GLM 4.5 flash、集成 Nano banana</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cherry Studio 是一款跨平台的 AI 桌面应用，支持 Windows、macOS 和 Linux 系统。Cherry Studio 1.5.9 版本&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FqDfrjOkXZPAy-wJos-lsAg" target="_blank"&gt;现已正式发布&lt;/a&gt;，本次更新带来了三大重要更新，更在细节和效率工具上进行了全面进化。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h3&gt;✨ 亮点一：零门槛开箱，免费畅享国产顶尖模型！&lt;/h3&gt; 
&lt;p&gt;为了让每一位用户都能零成本、无障碍地体验顶尖大模型的魅力，我们与两家国内领先的 AI 公司达成官方合作，为您带来真正「开箱即用」的免费模型体验！&lt;/p&gt; 
&lt;p&gt;&lt;img height="1908" src="https://static.oschina.net/uploads/space/2025/0903/102732_TmfF_2720166.png" width="3140" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;携手智谱 AI，首发免费 GLM-4.5-flash！&lt;/strong&gt; 
  &lt;ul&gt; 
   &lt;li&gt;Cherry Studio 与智谱 AI 达成官方合作，现在您&lt;strong&gt;无需登录、无需配置 API Key&lt;/strong&gt;，即可免费使用最新的&amp;nbsp;&lt;strong&gt;GLM-4.5-flash&lt;/strong&gt;&amp;nbsp;模型。&lt;/li&gt; 
   &lt;li&gt;该模型以 106B 的总参数和 12B 的激活参数，实现了国产模型的重大突破。在权威的 Artificial Analysis 推理基准测试中，其性能&lt;strong&gt;超越了 Gemini 1.5 Flash、Claude 3 Opus&lt;/strong&gt; 等国际知名模型，稳居国产模型性能前三甲！&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0903/102809_YNAj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;联合硅基流动，免费使用 Qwen3 8B！&lt;/strong&gt; 
  &lt;ul&gt; 
   &lt;li&gt;我们同样与硅基流动深度合作，为您带来了广受欢迎的&amp;nbsp;&lt;strong&gt;Qwen3 8B&lt;/strong&gt;&amp;nbsp;模型的免费使用权。&lt;/li&gt; 
   &lt;li&gt;这两款内置免费模型的加入，将&lt;strong&gt;彻底消除您首次使用 Cherry Studio 的所有障碍&lt;/strong&gt;，为您提供无与伦比的开箱体验。下载、安装、即刻对话！&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0903/102826_gOvP_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;✨ 亮点二：绝佳图像编辑，指令遵循与一致性的新标杆！&lt;/h3&gt; 
&lt;p&gt;图像创作与编辑从未如此简单！新版本正式支持备受期待的&amp;nbsp;&lt;strong&gt;nano banana 图像生成模型（即 Gemini 1.5 Flash Image）&lt;/strong&gt;&amp;nbsp;，它将彻底改变您与图像交互的方式。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;超强指令遵循&lt;/strong&gt;：您可以像与设计师对话一样，通过自然语言下达复杂的修改指令，例如「把这只猫的颜色换成蓝色，并让它戴上一顶牛仔帽」，模型都能精准理解并执行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;惊人的一致性保持&lt;/strong&gt;：在多次修改和迭代过程中，模型能出色地保持图像主体、风格和构图的一致性，让连续创作和精细调整变得轻而易举。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;轻松改图体验&lt;/strong&gt;：无论是调整细节、变换风格，还是增删元素，nano banana 都将为您带来行云流水般的创作自由度。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="1344" src="https://static.oschina.net/uploads/space/2025/0903/102849_5C1d_2720166.jpg" width="768" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;✨ 亮点三：灵感随时记录，全新笔记功能上线！&lt;/h3&gt; 
&lt;p&gt;好的想法和关键信息，值得被永久珍藏。Cherry Studio 1.5.9 带来了全新的&lt;strong&gt;笔记功能&lt;/strong&gt;&amp;nbsp;，让您的知识管理更上一层楼。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1908" src="https://static.oschina.net/uploads/space/2025/0903/102918_OdZ9_2720166.png" width="3140" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;一键保存对话&lt;/strong&gt;：在任何对话中，您可以轻松选中重要内容，或将整段对话一键保存到笔记中。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;告别信息丢失&lt;/strong&gt;：无论是模型的精彩回答、一段关键代码，还是一个突如其来的灵感，都能被安全地收纳和整理。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;便捷回溯查阅&lt;/strong&gt;：通过独立的笔记侧边栏，您可以随时回顾、搜索和管理您的知识库，让回溯关键内容变得前所未有地便捷。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="1908" src="https://static.oschina.net/uploads/space/2025/0903/102930_MM0T_2720166.png" width="3140" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;更多内容查看&amp;nbsp;&lt;em&gt;https://github.com/CherryHQ/cherry-studio/releases/tag/v1.5.9&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369987</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369987</guid>
      <pubDate>Wed, 03 Sep 2025 02:31:17 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>苹果 AI 团队持续「失血」：首席机器人研究员被 Meta 挖走</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;苹果的首席 AI 机器人研究员 Jian Zhang 已跳槽至 Meta 的机器人工作室 Meta Robotics Studio。Meta 周二已确认 Zhang 加入。这是近期苹果 AI 团队又一重要人员流失的消息。&lt;/p&gt; 
&lt;p&gt;同时媒体获悉，苹果还有三名大语言模型（LLM）的研究员——John Peebles、Nan Du 和 Zhao Meng 离职。&lt;/p&gt; 
&lt;p&gt;媒体指出，最新一轮离职潮发生在过去一周内，上述三人均来自苹果基础模型团队，该团队是 Apple Intelligence 平台的核心开发团队，但近几周已流失约 10 名成员，包括团队负责人。将近两个月前传出过，Meta 以 2 亿美元高薪挖走苹果 AI 模型团队的负责人 Ruoming Pang。&lt;/p&gt; 
&lt;p&gt;上述媒体还再次提到了此前的媒体消息，即苹果内部正在讨论是否更多依赖外部技术，而非仅使用自研模型。&lt;/p&gt; 
&lt;p&gt;传出 AI 人员变动的消息后，苹果股价本周二盘中跌幅扩大，一度跌逾 2.2%，最终收跌约 1%。&lt;/p&gt; 
&lt;p&gt;苹果在 AI 领域的追赶努力面临挫折，Apple Intelligence 产品反响不佳，加上公司可能转向第三方模型的策略调整，进一步影响了团队士气。知情人士透露，预计还会有更多员工离职，多名员工正在其他公司面试。&lt;/p&gt; 
&lt;h2&gt;核心人才接连出走&lt;/h2&gt; 
&lt;p&gt;Jian Zhang 离职是苹果机器人研发的重大损失。他此前领导一个专注于自动化技术和 AI 应用的小规模学术团队，该团队隶属于苹果人工智能和机器学习部门。Meta 周二确认，Zhang 已加入 Meta 的机器人工作室，隶属于 Reality Labs 部门。&lt;/p&gt; 
&lt;p&gt;这并非苹果机器人团队的首次人员流失。Zhang 的下属 Mario Srouji 今年 4 月已离职，前往 Archer Aviation 担任 AI 产品负责人。苹果的机器人研究团队与产品开发团队相互独立，后者今年早些时候已转入硬件工程部门。&lt;/p&gt; 
&lt;p&gt;在与 Zhang 同一批离职的三名基础模型团队研究员中，Peebles 和 Du 将前往 OpenAI，Zhao Meng 则加入 OpenAI 的劲敌 Anthropic。这些离职进一步削弱了苹果自研 AI 能力的核心团队。苹果和 OpenAI 的发言人拒绝就人事变动置评，Anthropic 暂未回应置评请求。&lt;/p&gt; 
&lt;h2&gt;Meta 高薪挖角策略奏效&lt;/h2&gt; 
&lt;p&gt;Meta 通过提供巨额薪酬成功吸引苹果 AI 人才。此前离职的苹果模型团队负责人 Ruoming Pang 获得了一份价值 2 亿美元的多年期薪酬方案。Meta 的这一策略已吸引多名苹果员工跳槽，许多基础模型团队成员此前已投靠 Meta。&lt;/p&gt; 
&lt;p&gt;华尔街见闻曾提到，8 月 22 日的媒体报道称，Meta 挖走了负责苹果 AI 团队云基础设施、训练和搜索业务的 Frank Chu，他是至少第六位跳槽 Meta 的苹果 AI 员工，也是自大模型团队负责人 Ruoming Pang 离职后，苹果最重要的一次人才流失。&lt;/p&gt; 
&lt;p&gt;不过上月一些的报道披露，Meta 的招聘策略并非一帆风顺，一些新近聘用的 AI 研究员已经离职。尽管如此，Meta 仍在大力投资机器人技术，除了智能眼镜和 AI 功能外，据此前报道，Meta 正大力投资人形机器人的操作系统和硬件组件。&lt;/p&gt; 
&lt;p&gt;苹果在机器人领域的布局同样雄心勃勃。将近三周前媒体称，苹果计划推出一系列机器人设备，包括配备移动屏幕的桌面设备，以及用于零售店和制造业的机械臂。机器人技术已成为苹果未来产品线的关键组成部分。&lt;/p&gt; 
&lt;h2&gt;AI 策略调整掀起的离职潮将持续&lt;/h2&gt; 
&lt;p&gt;苹果 AI 团队的人才流失与公司战略调整密切相关。面对在生成式 AI 领域的落后局面，苹果正考虑是否更多依赖外部技术供应商，而非完全依靠自研能力。这一潜在转向引发了内部团队的不安。&lt;/p&gt; 
&lt;p&gt;上月媒体称，苹果近期已与谷歌接洽，探讨为预计明年上线的新版 Siri 打造一款定制 AI 模型的可能性。谷歌已开始训练一款可在苹果服务器上运行的模型。这标志着苹果在外包 AI 技术方面迈出关键一步。&lt;/p&gt; 
&lt;p&gt;媒体本周二援引知情人士预计，苹果 AI 领域员工的离职潮预计将持续，还有多名员工在积极面试其他公司的工作。Apple Intelligence 产品的市场反响不佳，以及苹果可能采用第三方模型的策略转变，都对团队士气造成负面影响。&lt;/p&gt; 
&lt;p&gt;苹果在 AI 领域仍落后竞争对手数年，这迫使管理层考虑多种应对方案。公司必须在保持创新能力和快速追赶市场之间找到平衡，而核心人才的持续流失无疑增加了这一挑战的难度。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369983</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369983</guid>
      <pubDate>Wed, 03 Sep 2025 02:21:03 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>美国法院裁定谷歌无需出售 Chrome 浏览器</title>
      <description/>
      <link>https://www.oschina.net/news/369982</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369982</guid>
      <pubDate>Wed, 03 Sep 2025 02:09:03 GMT</pubDate>
    </item>
    <item>
      <title>AI 公司 Anthropic 完成 130 亿美元融资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Anthropic&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fanthropic-raises-series-f-at-usd183b-post-money-valuation"&gt;宣布&lt;/a&gt;完成 130 亿美元 F 轮融资，投后估值达 1830 亿美元，创下科技行业私募融资规模第二高纪录，仅次于 OpenAI 同年 3 月的 400 亿美元融资。&lt;/p&gt; 
&lt;p&gt;本轮融资由 Iconiq Capital、富达管理研究公司和光速创投领投，贝莱德、黑石、高盛等数十家知名机构参与。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0903/095936_gVgg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 介绍称，其 2025 年初年化收入为 10 亿美元，8 个月后飙升至 50 亿美元，成为历史上增长最快的科技公司之一。&lt;/p&gt; 
&lt;p&gt;此外，Anthropic 目前为超过 30 万家企业客户提供服务，对应营收超 10 万美元的大型客户数量在过去一年间增长了近 7 倍；Claude Code 编程助手在正式推出仅三个月后就创造了 5 亿美元收入，使用量增长了 10 倍以上。&lt;/p&gt; 
&lt;p&gt;Anthropic 表示该公司的此轮融资将扩大其满足日益增长的企业需求的能力，深化安全研究，并在继续构建可靠、可解释、可控的 AI 系统的同时支持国际扩张。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369981/anthropic-raises-series-f-at-usd183b-post-money-valuation</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369981/anthropic-raises-series-f-at-usd183b-post-money-valuation</guid>
      <pubDate>Wed, 03 Sep 2025 02:02:03 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>RuleGo v0.33.0 发布：国产轻量级、全场景、新一代组件编排规则引擎</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;code&gt;RuleGo&lt;/code&gt; 是一个基于 &lt;code&gt;Go&lt;/code&gt; 语言的轻量级、高性能、嵌入式、组件编排新一代规则引擎。它可以帮助你快速构建低耦合、灵活的系统，实现复杂的业务逻辑。RuleGo 还提供大量可复用的组件，支持对数据进行聚合、过滤、分发、转换、丰富和执行各种动作，也能和各种协议、系统进行联动和集成。让你快人一步实现自动化营销、物联网、应用集成等解决方案。&lt;/p&gt; 
&lt;p&gt;该项目在低代码、业务代码编排、数据集成、工作流、大模型智能体、边缘计算、自动化、IoT 等多种场景具有广泛的应用潜力。&lt;/p&gt; 
&lt;h4&gt;典型使用场景&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;边缘计算：&lt;/strong&gt; 可以在边缘服务器部署 &lt;code&gt;RuleGo&lt;/code&gt;，对数据进行预处理，筛选、聚合或者计算后再上报到云端。数据的处理规则和分发规则可以通过规则链动态配置和修改，而不需要重启系统。&lt;span style="background-color:#ffffff; color:#080808"&gt;国产替代&lt;/span&gt;&lt;code&gt;node-red&lt;/code&gt;&lt;span style="background-color:#ffffff; color:#080808"&gt;系统。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;物联网：&lt;/strong&gt; 收集设备数据上报，经过规则链的规则判断，触发一个或者多个动作，例如：发邮件、发告警、和其他设备或者系统联动。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;数据分发：&lt;/strong&gt; 可以根据不同的消息类型，调用 HTTP、MQTT 或者 gRPC 把数据分发到不同系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;应用集成：&lt;/strong&gt; 把 &lt;code&gt;RuleGo&lt;/code&gt; 当做胶水连接各种系统或者协议，例如：gRPC、ssh、webhook、kafka、消息队列、数据库、chatGPT、第三方应用系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;异构系统数据集中处理：&lt;/strong&gt; 从不同的数据源（如 MQTT、HTTP、WS、MQ、gRPC、TCP/UDP 等）接收数据，然后对数据进行过滤、格式转换、然后分发到数据库、业务系统或者仪表板。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;高度定制化业务：&lt;/strong&gt; 把高度定制化或者经常变化的业务解耦出来，交给 &lt;code&gt;RuleGo&lt;/code&gt; 规则链进行管理。业务需求变化而不需要重启主程序。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;复杂业务编排：&lt;/strong&gt; 把业务封装成自定义组件，通过 &lt;code&gt;RuleGo&lt;/code&gt; 编排和驱动这些自定义的组件，业务逻辑并支持动态调整和替换。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;微服务编排：&lt;/strong&gt; 通过 &lt;code&gt;RuleGo&lt;/code&gt; 编排和驱动微服务，或者动态调用第三方服务处理业务，并返回结果。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;业务代码和业务逻辑解耦：&lt;/strong&gt; 例如：用户积分计算系统、风控系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;自动化：&lt;/strong&gt; 例如：CI/CD 系统、流程自动化系统、营销自动化系统、量化系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;低代码：&lt;/strong&gt; 例如：低代码平台、iPaaS 系统、ETL、类 &lt;code&gt;Langflow&lt;/code&gt; 、dify 系统（对接&lt;code&gt;大模型&lt;/code&gt;提取用户意图，然后触发规则链与其他系统进行联动或者进行业务处理）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;MCP 服务：&lt;/strong&gt;自动把规则链（工作流）、组件、API 自动注册成 MCP 工具，提供给 AI 智能体调用。企业应用可以很容易通过 RuleGo 的桥接，实现和 AI 智能体的联动，打通 AI 与企业应用的 「最后一公里」。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;架构图&lt;/h3&gt; 
&lt;p&gt;&lt;img alt="" height="1536" src="https://oscimg.oschina.net/oscnet/up-64da4b87a62dbe96e2cda29fe1e7ba01878.png" width="2149" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;可视化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;风格 1：&lt;/p&gt; 
&lt;p&gt;&lt;img height="999" src="https://oscimg.oschina.net/oscnet/up-9997e9e4807b438912b9685ab3409eee505.png" width="1557" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;风格 2：&lt;/p&gt; 
&lt;p&gt;&lt;img height="836" src="https://oscimg.oschina.net/oscnet/up-4f6b078c8d34ae752d5cae28e8b8c366850.png" width="1898" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;本次更新&lt;/strong&gt;&lt;/h3&gt; 
&lt;h3&gt;rulego-core&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;feat: 完善组件配置表达式取值系统，支持跨节点取值，例如:${node1.msg.xx}&lt;/li&gt; 
 &lt;li&gt;feat: 增加 end 节点组件&lt;/li&gt; 
 &lt;li&gt;feat: 增加跨节点取值节点组件&lt;/li&gt; 
 &lt;li&gt;feat: 节点组件配置表单生成，跳过不可导出和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;json:-&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;字段&lt;/li&gt; 
 &lt;li&gt;perf: 完善 mqtt 客户端重连机制&lt;/li&gt; 
 &lt;li&gt;perf: 优化 js 引擎超时处理&lt;/li&gt; 
 &lt;li&gt;perf: 优化表达式引擎混合字符串场景性能&lt;/li&gt; 
 &lt;li&gt;perf: 使用 el.NewTemplate 代替 str.NewTemplate&lt;/li&gt; 
 &lt;li&gt;perf: 完善 net endpoint 组件数据竞争问题&lt;/li&gt; 
 &lt;li&gt;fix: js 节点组件，dataType 字段类型转换错误&lt;/li&gt; 
 &lt;li&gt;fix: Reload engine chainCtx lost&lt;/li&gt; 
 &lt;li&gt;fix: 修复 js 脚本部分场景会读写错误&lt;/li&gt; 
 &lt;li&gt;refactor: 重构 ctx.TellFlow 入参&lt;/li&gt; 
 &lt;li&gt;refactor: 增加公共组件分类，重新调整部分组件分类&lt;/li&gt; 
 &lt;li&gt;chore: expr 升级到 1.17.6&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;rulego-components&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;feat: 增加 pulsar 发布和订阅节点组件&lt;/li&gt; 
 &lt;li&gt;feat: 增加 nsq 发布和订阅节点组件&lt;/li&gt; 
 &lt;li&gt;feat: 增加流式计算转换节点组件&lt;/li&gt; 
 &lt;li&gt;feat: 增加流式聚合运算节点组件&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;rulego-server&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;fix: 完善 mqtt 客户端重连机制&lt;/li&gt; 
 &lt;li&gt;fix: add defer resp.Body.Close() for GetComponentsFromMarketplace&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;rulego-editor&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;feat: 默认【输入】节点可以删除&lt;/li&gt; 
 &lt;li&gt;feat: 增加最新节点组件支持&lt;/li&gt; 
 &lt;li&gt;feat: 如果节点没配置，首次添加到画布，不弹出属性配置表单&lt;/li&gt; 
 &lt;li&gt;feat: 增加新型画布节点，应用于 for、节点组等分组组件展示效果&lt;/li&gt; 
 &lt;li&gt;feat: 增加 sql 编辑器表单组件&lt;/li&gt; 
 &lt;li&gt;fix:左边栏高度适配&lt;/li&gt; 
 &lt;li&gt;chore: 升级最新的依赖&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;本次重点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;完善表达式取值系统，支持跨节点取值，如：${node1.msg.xx}&lt;/li&gt; 
 &lt;li&gt;增加【结束节点组件】可以更加精准地控制流程的结束&lt;/li&gt; 
 &lt;li&gt;优化表达式引擎和 js 引擎性能&lt;/li&gt; 
 &lt;li&gt;增加 pulsar 和 nsq 这两个发布/订阅组件&lt;/li&gt; 
 &lt;li&gt;增加流式聚合计算组件，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frulego.cc%2Fpages%2Fstreamsql-overview%2F" target="_blank"&gt;StreamSQL&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;其他信息&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;欢迎在&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/rulego/rulego" target="_blank"&gt;Gitee&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;或者&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Frulego%2Frulego" target="_blank"&gt;Github&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;上提交反馈或建议&lt;/li&gt; 
 &lt;li&gt;如果喜欢这个项目，请给我们点个 Star&lt;/li&gt; 
 &lt;li&gt;文档官网：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frulego.cc%2F" target="_blank"&gt;rulego.cc&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;RuleGo-Editor：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feditor.rulego.cc" target="_blank"&gt;editor.rulego.cc&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F8.134.32.225%3A9090%2Feditor%2F" target="_blank"&gt;体验地址 1&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F8.134.32.225%3A9090%2Fui%2F" target="_blank"&gt;体验地址 2&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369968/rulego-0-33-0-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369968/rulego-0-33-0-released</guid>
      <pubDate>Mon, 01 Sep 2025 15:08:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>AI 提升的是下限，而非上限</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;近期，AI 提醒助手项目「Elroy」在其官网发布了一篇名为&lt;em&gt;《AI 提升的是下限，而非上限》（&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Felroy.bot%2Fblog%2F2025%2F07%2F29%2Fai-is-a-floor-raiser-not-a-ceiling-raiser.html" target="_blank"&gt;AI is a Floor Raiser, not a Ceiling Raiser&lt;/a&gt;）&lt;/em&gt;的博客，探讨了 AI 对于提升自我的一些利与弊。&lt;/p&gt; 
&lt;p&gt;文中提到，AI 能够根据每个人的理解水平进行响应，解决了传统教学内容「不能精准匹配学习者」这一痛点。它能随时回答问题，甚至替用户完成重复性任务，为初学者提供更友好的学习起点。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-783b1d370ee54c428e48a0d6a2a0124bb4e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b120252a3f52bb1aa8937f2f2bd1ee69923.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;但同时，像「OpenAI 学习模式（Study Mode）」这样的工具可能助长依赖性，因为学习者直接通过 AI 获取答案，而不是真正理解知识结构，这样的人最终可能止步于 AI 能覆盖的水平。&lt;/p&gt; 
&lt;p&gt;对此，Elroy 的文章也指出，AI 带来的影响，取决于「做出有影响力产品需要的精通程度」，其举出了一点例子来更好分析这一情况：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;对工程管理者而言，AI 能快速帮助他们上手不熟悉的框架或平台，让想法迅速变为可运行产品。&lt;/li&gt; 
 &lt;li&gt;然而对于在复杂系统中工作的开发者，AI 缺乏对现有架构的深度理解和上下文感知，实际辅助有限。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;同时，文中也提到了 AI 与艺术创意的关联。虽然 AI 可以大量生成文本、图像、音频等，但因表现往往缺乏新意，在竞争激烈、创意要求高的领域（如小说、电影）难以取得成功。&lt;/p&gt; 
&lt;p&gt;文章强调，大众容易识别雷同，例如因 4o 图像生成器而流行一时的「吉卜力风」头像，也未能影响《哈尔的移动城堡》的地位。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369939</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369939</guid>
      <pubDate>Mon, 01 Sep 2025 11:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>校方怀疑学生使用 AI 作弊，要求全员重考并接受现场答辩</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;新西兰林肯大学一门研究生课程近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.stuff.co.nz%2Fnz-news%2F360802436%2Fone-slip-and-youre-guilty-universitys-unusual-ai-crackdown-rattles-students" target="_blank"&gt;引发了热议&lt;/a&gt;&lt;strong&gt;：因怀疑部分学生在作业中使用了生成式 AI 工具，授课教师要求全班 115 名学生必须参加线下答辩重新考核&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/191258_4zKr_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据了解，该课程聚焦「大数据与人工智能」，教师发现作业中出现大量「高水准代码」，怀疑学生不当使用生成式 AI 工具。&lt;/p&gt; 
&lt;p&gt;尽管承认个别学生可能具备编程能力，但大规模出现此类情况概率极低，因此决定让全班重考：学生需现场编写代码、解释作业思路，并接受即兴问答，全程录像。教师称此举为「保证公平性」，并强调「若代码是自己写的，就能解释清楚；解释不了则可能作弊」。&lt;/p&gt; 
&lt;p&gt;对于校方的处理方案，学生认为重考营造了「人人有嫌疑」的紧张氛围，担心因答错一句被认定作弊。部分学生表示从未使用 AI，却被迫参与重考，认为处理方式「反应过度」。&lt;/p&gt; 
&lt;p&gt;校方称处理符合学术规范，课程大纲已明确 AI 使用规则，且政策允许在怀疑作弊时要求学生重新验证。教务长强调重视学术诚信，目标是确保学生成果代表自身努力。&lt;/p&gt; 
&lt;p&gt;维多利亚大学 AI 专家认为，AI 普及是不可逆趋势，高校需调整教学和考核方式，如增加面对面讲解作业、设置阶段性检查点，而非单纯依赖线下考试。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369937</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369937</guid>
      <pubDate>Mon, 01 Sep 2025 11:13:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Solon 权限认证之 Sa-Token 的使用与详解</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#24292e; text-align:start"&gt;本文详细介绍了 Sa-Token 在 Java 项目中的使用方法，包括 Sa-Token 的基本概念、与其他权限框架的比较、基本语法和高级用法，并通过实例讲解了如何在项目中集成和使用 Sa-Token 。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;作为一款轻量级 Java 权限认证框架，Sa-Token 在简化权限管理、提高开发效率方面发挥了重要作用。本文还将深入探讨 Sa-Token 的核心原理，通过内部代码展示其工作机制。最后，总结了 Sa-Token 的优缺点及其在实际开发中的应用场景，为开发者提供全面的指导。&lt;/p&gt; 
&lt;h2&gt;一、Sa-Token 介绍&lt;/h2&gt; 
&lt;h3&gt;1. Sa-Token 简介&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 是一款轻量级 Java 权限认证框架，旨在解决 Java Web 系统中常见的登录认证、权限验证、Session 会话、单点登录等问题。其核心目标是以最简洁的方式，实现强大的权限控制功能，帮助开发者快速完成权限系统的搭建。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 具有如下优势：&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#24292e; display:block; font-family:-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Segoe UI&amp;quot;,Helvetica,Arial,sans-serif,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:960px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;优势&lt;/th&gt; 
   &lt;th&gt;描述&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;简单易用&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;API 设计简洁明了，易于集成和使用，上手快，学习成本低。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;功能丰富&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;支持多种权限控制需求，满足复杂业务场景。支持登录认证、权限验证、角色验证、Session 会话、多账号体系等功能。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高性能&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;轻量级设计，对系统性能影响小。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高度可扩展&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;提供丰富的扩展接口，与 Spring、SpringBoot、Solon 等常用框架高度兼容，支持自定义持久化、注解方式验证、单点登录等高级特性。&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;社区活跃&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;有良好的社区支持和文档资源。&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;2. Sa-Token 原理解析&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 的核心原理是通过 Token 机制实现用户的身份认证和权限校验。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;其主要工作流程如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;登录认证：用户登录成功后，服务器生成一个全局唯一的 Token，并将其返回给客户端。&lt;/li&gt; 
 &lt;li&gt;Token 存储：Token 与用户身份信息的映射关系保存在服务器的会话中（如 Redis、内存等）。&lt;/li&gt; 
 &lt;li&gt;权限验证：客户端请求时携带 Token，服务器根据 Token 获取用户信息，验证其权限是否满足要求。&lt;/li&gt; 
 &lt;li&gt;会话管理：支持 Session 会话管理，可以获取和操作当前会话的属性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;流程图例如下：&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//164ae7fe8293ac6902b135fd89299bdf.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3. Sa-Token 与其他权限框架比较&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 与其他常见权限框架在学习成本、集成难度上有显著优势：&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#24292e; display:block; font-family:-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Segoe UI&amp;quot;,Helvetica,Arial,sans-serif,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:960px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;特性&lt;/th&gt; 
   &lt;th&gt;Sa-Token&lt;/th&gt; 
   &lt;th&gt;Solon Auth&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;学习成本&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;低&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;低&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;功能丰富度&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;低&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;集成难度&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;低&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;低&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;性能表现&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;社区支持&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;活跃&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;一般&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;扩展性&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;高&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px"&gt;中&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h2&gt;二、Sa-Token 的基本语法&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;在实际项目中，Sa-Token 通过简单的配置和 API 调用，即可实现完整的权限管理功能。以下将通过一个完整的 Solon 示例，演示如何集成和使用 Sa-Token。&lt;/p&gt; 
&lt;h3&gt;1. 创建 Solon Web 项目&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;首先，创建一个新的 Solon 项目，可以使用 IDEA 的项目向导或&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2Fstart%2F" target="_blank"&gt;Solon Initializr&lt;/a&gt;。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;引入必要的依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;em&gt;&amp;lt;!-- Solon  Web --&amp;gt;&lt;/em&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.noear&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;solon-web&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

    &lt;em&gt;&amp;lt;!-- Sa-Token 核心依赖 --&amp;gt;&lt;/em&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cn.dev33&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sa-token-solon-plugin&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.44.0&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 配置 Sa-Token：app.yml&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;em&gt;# Sa-Token 配置，可根据需要进行调整&lt;/em&gt;
&lt;span style="color:#986801"&gt;sa-token:&lt;/span&gt;
  &lt;em&gt;# token 有效期，单位秒，默认 30 天&lt;/em&gt;
  &lt;span style="color:#986801"&gt;timeout:&lt;/span&gt; &lt;span style="color:#986801"&gt;2592000&lt;/span&gt;

  &lt;em&gt;# 是否打开二级登录校验&lt;/em&gt;
  &lt;span style="color:#986801"&gt;open-safe:&lt;/span&gt; &lt;span style="color:#0184bb"&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. 配置拦截器&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;创建配置类，添加 Sa-Token 的拦截器，以拦截请求并进行权限验证。SaTokenConfig.java&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.solon.integration.SaTokenInterceptor;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Configuration;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Managed;

&lt;span style="color:#4078f2"&gt;@Configuration&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;SaTokenConfig&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Managed(index = -100)&lt;/span&gt; &lt;em&gt;//-100，是顺序位（低值优先）&lt;/em&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; SaTokenInterceptor &lt;span style="color:#4078f2"&gt;saTokenInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;SaTokenInterceptor&lt;/span&gt;(); &lt;em&gt;//用于支持规划处理及注解处理&lt;/em&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;4. 登录认证&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;创建登录接口，实现用户登录功能。LoginController.java&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.stp.StpUtil;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Controller;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Mapping;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Param;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Post;

&lt;span style="color:#4078f2"&gt;@Controller&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;LoginController&lt;/span&gt; {

    &lt;span style="color:#4078f2"&gt;@Post&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Mapping("/login")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; String &lt;span style="color:#4078f2"&gt;login&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Param&lt;/span&gt; String username, &lt;span style="color:#4078f2"&gt;@Param&lt;/span&gt; String password)&lt;/span&gt; {
        &lt;em&gt;// 1. 校验用户名和密码（这里模拟一个简单的校验）&lt;/em&gt;
        &lt;span style="color:#a626a4"&gt;if&lt;/span&gt; (&lt;span style="color:#50a14f"&gt;"admin"&lt;/span&gt;.equals(username) &amp;amp;&amp;amp; &lt;span style="color:#50a14f"&gt;"123456"&lt;/span&gt;.equals(password)) {
            &lt;em&gt;// 2. 登录，保存用户 ID 为 10001&lt;/em&gt;
            StpUtil.login(&lt;span style="color:#986801"&gt;10001&lt;/span&gt;);
            &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"登录成功，Token："&lt;/span&gt; + StpUtil.getTokenValue();
        }
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"用户名或密码错误"&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;说明：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;调用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;StpUtil.login(10001)&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;方法，实现登录操作，参数为用户的唯一标识 ID。&lt;/li&gt; 
 &lt;li&gt;登录成功后，可以通过&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;StpUtil.getTokenValue()&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;获取当前会话的 Token。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;5. 权限验证&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;创建需要权限验证的接口，例如获取用户信息的接口。UserController.java&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.annotation.SaCheckPermission;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.stp.StpUtil;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Controller;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Get;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Mapping;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Post;

&lt;span style="color:#4078f2"&gt;@Controller&lt;/span&gt;
&lt;span style="color:#4078f2"&gt;@Mapping("/user")&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;UserController&lt;/span&gt; {

    &lt;em&gt;// 查询用户信息，需登录&lt;/em&gt;
    &lt;span style="color:#4078f2"&gt;@Get&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Mapping("/info")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; String &lt;span style="color:#4078f2"&gt;getUserInfo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        &lt;em&gt;// 校验是否登录&lt;/em&gt;
        StpUtil.checkLogin();
        &lt;em&gt;// 获取用户 ID&lt;/em&gt;
        &lt;span style="color:#986801"&gt;int&lt;/span&gt; &lt;span style="color:#986801"&gt;userId&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; StpUtil.getLoginIdAsInt();
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"当前用户信息，ID："&lt;/span&gt; + userId;
    }

    &lt;em&gt;// 修改用户信息，需有权限"user:update"&lt;/em&gt;
    &lt;span style="color:#4078f2"&gt;@SaCheckPermission("user:update")&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Post&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Mapping("/update")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; String &lt;span style="color:#4078f2"&gt;updateUser&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"用户信息更新成功"&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;说明：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;StpUtil.checkLogin()&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;方法手动校验登录状态。&lt;/li&gt; 
 &lt;li&gt;使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;@SaCheckPermission("user:update")&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;注解，声明该接口需要权限 user:update。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;6. 角色验证&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;如果需要基于角色进行权限控制，可以使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;@SaCheckRole&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;注解。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.annotation.SaCheckRole;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Controller;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Get;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Mapping;

&lt;span style="color:#4078f2"&gt;@Controller&lt;/span&gt;
&lt;span style="color:#4078f2"&gt;@Mapping("/admin")&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;AdminController&lt;/span&gt; {

    &lt;em&gt;// 仅管理员角色可访问&lt;/em&gt;
    &lt;span style="color:#4078f2"&gt;@SaCheckRole("admin")&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Get&lt;/span&gt;
    &lt;span style="color:#4078f2"&gt;@Mapping("/dashboard")&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; String &lt;span style="color:#4078f2"&gt;adminDashboard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"欢迎进入管理员控制枱"&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;7. 自定义权限验证逻辑&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;需要自定义获取用户权限和角色的逻辑，可以实现&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;StpInterface&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;接口。StpInterfaceImpl.java&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.stp.StpInterface;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Managed;

&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.ArrayList;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; java.util.List;

&lt;span style="color:#4078f2"&gt;@Managed&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;StpInterfaceImpl&lt;/span&gt; &lt;span style="color:#a626a4"&gt;implements&lt;/span&gt; &lt;span style="color:#c18401"&gt;StpInterface&lt;/span&gt; {

    &lt;em&gt;// 返回一个用户所拥有的权限码集合&lt;/em&gt;
    &lt;span style="color:#4078f2"&gt;@Override&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span style="color:#4078f2"&gt;getPermissionList&lt;/span&gt;&lt;span&gt;(Object loginId, String loginKey)&lt;/span&gt; {
        &lt;em&gt;// 模拟从数据库获取权限&lt;/em&gt;
        List&amp;lt;String&amp;gt; permissionList = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();
        &lt;span style="color:#a626a4"&gt;if&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"10001"&lt;/span&gt;.equals(loginId.toString())) {
            permissionList.add(&lt;span style="color:#50a14f"&gt;"user:update"&lt;/span&gt;);
            permissionList.add(&lt;span style="color:#50a14f"&gt;"user:delete"&lt;/span&gt;);
        }
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; permissionList;
    }

    &lt;em&gt;// 返回一个用户所拥有的角色标识集合 (权限与角色可分开校验)&lt;/em&gt;
    &lt;span style="color:#4078f2"&gt;@Override&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span style="color:#4078f2"&gt;getRoleList&lt;/span&gt;&lt;span&gt;(Object loginId, String loginKey)&lt;/span&gt; {
        &lt;em&gt;// 模拟从数据库获取角色&lt;/em&gt;
        List&amp;lt;String&amp;gt; roleList = &lt;span style="color:#a626a4"&gt;new&lt;/span&gt; &lt;span style="color:#c18401"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();
        &lt;span style="color:#a626a4"&gt;if&lt;/span&gt;(&lt;span style="color:#50a14f"&gt;"10001"&lt;/span&gt;.equals(loginId.toString())) {
            roleList.add(&lt;span style="color:#50a14f"&gt;"admin"&lt;/span&gt;);
        }
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; roleList;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;说明：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;实现&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;getPermissionList&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;方法，返回指定用户的权限列表。&lt;/li&gt; 
 &lt;li&gt;实现&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;getRoleList&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;方法，返回指定用户的角色列表。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;8. 会话管理&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 提供了会话管理功能，可以在 Session 中存储和获取数据。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.session.SaSession;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.stp.StpUtil;

&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;void&lt;/span&gt; &lt;span style="color:#4078f2"&gt;sessionDemo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {
    &lt;em&gt;// 获取当前会话的 Session&lt;/em&gt;
    &lt;span style="color:#986801"&gt;SaSession&lt;/span&gt; &lt;span style="color:#986801"&gt;session&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; StpUtil.getSession();

    &lt;em&gt;// 存储数据&lt;/em&gt;
    session.set(&lt;span style="color:#50a14f"&gt;"name"&lt;/span&gt;, &lt;span style="color:#50a14f"&gt;"张三"&lt;/span&gt;);
    session.set(&lt;span style="color:#50a14f"&gt;"email"&lt;/span&gt;, &lt;span style="color:#50a14f"&gt;"zhangsan@example.com"&lt;/span&gt;);

    &lt;em&gt;// 获取数据&lt;/em&gt;
    &lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;name&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; session.getString(&lt;span style="color:#50a14f"&gt;"name"&lt;/span&gt;);
    &lt;span style="color:#986801"&gt;String&lt;/span&gt; &lt;span style="color:#986801"&gt;email&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; session.getString(&lt;span style="color:#50a14f"&gt;"email"&lt;/span&gt;);

    &lt;em&gt;// 输出&lt;/em&gt;
    System.out.println(&lt;span style="color:#50a14f"&gt;"姓名："&lt;/span&gt; + name);
    System.out.println(&lt;span style="color:#50a14f"&gt;"邮箱："&lt;/span&gt; + email);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;9. 踢人下线&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;可以通过用户 ID 强制用户下线。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 将用户 ID 为 10001 的用户踢下线&lt;/em&gt;
StpUtil.logoutByLoginId(&lt;span style="color:#986801"&gt;10001&lt;/span&gt;);

&lt;em&gt;// 检查用户是否已被踢下线&lt;/em&gt;
&lt;span style="color:#986801"&gt;boolean&lt;/span&gt; &lt;span style="color:#986801"&gt;isLogout&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; StpUtil.isLogin();
System.out.println(&lt;span style="color:#50a14f"&gt;"用户是否登录："&lt;/span&gt; + isLogout);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;10. 注销登录&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;用户主动注销登录，可以调用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;StpUtil.logout()&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;方法。&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 注销登录&lt;/em&gt;
StpUtil.logout();

&lt;em&gt;// 检查登录状态&lt;/em&gt;
&lt;span style="color:#986801"&gt;boolean&lt;/span&gt; &lt;span style="color:#986801"&gt;isLogin&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; StpUtil.isLogin();
System.out.println(&lt;span style="color:#50a14f"&gt;"用户是否登录："&lt;/span&gt; + isLogin);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;三、Sa-Token 的高级用法&lt;/h2&gt; 
&lt;h3&gt;1. 自定义持久化&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 默认使用内存来存储 Token 信息，在分布式环境中，可以使用 Redis 作为持久化介质。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;引入 Redis 依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cn.dev33&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sa-token-redisx&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.44.0&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cn.dev33&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sa-token-snack3&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.44.0&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置 Redis Dao 连接信息：app.yml&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;sa-token:&lt;/span&gt;  &lt;em&gt;# 不同的扩展插件，配置可能会不同&lt;/em&gt;
  &lt;span style="color:#986801"&gt;dao:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;server:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;"localhost:6379"&lt;/span&gt;
    &lt;span style="color:#986801"&gt;password:&lt;/span&gt; &lt;span style="color:#986801"&gt;123456&lt;/span&gt;
    &lt;span style="color:#986801"&gt;db:&lt;/span&gt; &lt;span style="color:#986801"&gt;1&lt;/span&gt;
    &lt;span style="color:#986801"&gt;maxTotal:&lt;/span&gt; &lt;span style="color:#986801"&gt;200&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置 Redis 持久化：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.dao.SaTokenDao;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; cn.dev33.satoken.dao.SaTokenDaoForRedisx;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Configuration;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Inject;
&lt;span style="color:#a626a4"&gt;import&lt;/span&gt; org.noear.solon.annotation.Managed;

&lt;span style="color:#4078f2"&gt;@Configuration&lt;/span&gt;
&lt;span style="color:#a626a4"&gt;public&lt;/span&gt; &lt;span style="color:#a626a4"&gt;class&lt;/span&gt; &lt;span style="color:#c18401"&gt;SaTokenDaoConfig&lt;/span&gt; {
    &lt;span style="color:#4078f2"&gt;@Managed&lt;/span&gt;
    &lt;span style="color:#a626a4"&gt;public&lt;/span&gt; SaTokenDao &lt;span style="color:#4078f2"&gt;saTokenDaoInit&lt;/span&gt;&lt;span&gt;(&lt;span style="color:#4078f2"&gt;@Inject("${sa-token.dao}")&lt;/span&gt; SaTokenDaoForRedisx saTokenDao)&lt;/span&gt; {
        &lt;span style="color:#a626a4"&gt;return&lt;/span&gt; saTokenDao;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2. 单点登录（SSO）&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 提供了 SSO 模块，可以快速实现单点登录功能。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;引入 SSO 依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cn.dev33&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sa-token-sso&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.44.0&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置 SSO 相关参数：app.yml&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;&lt;span style="color:#986801"&gt;sa-token:&lt;/span&gt;
  &lt;span style="color:#986801"&gt;sso-client:&lt;/span&gt;
    &lt;span style="color:#986801"&gt;client:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;demo-app&lt;/span&gt;
    &lt;span style="color:#986801"&gt;server-url:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;http://sso-server.com&lt;/span&gt;
    &lt;span style="color:#986801"&gt;is-http:&lt;/span&gt; &lt;span style="color:#0184bb"&gt;true&lt;/span&gt;
    &lt;span style="color:#986801"&gt;secret-key:&lt;/span&gt; &lt;span style="color:#50a14f"&gt;SSO-C3-kQwIOrYvnXmSDkwEiFngrKidMcdrgKor&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;3. OAuth2.0 支持&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;&lt;code&gt;Sa-Token&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;也支持&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;OAuth2.0&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;协议，可以实现与第三方平台的对接。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;引入&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;OAuth2.0&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;依赖：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-xml"&gt;&lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;cn.dev33&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;sa-token-oauth2&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.44.0&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;span style="color:#e45649"&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;配置&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;OAuth2.0&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;参数和实现授权流程（此处略，具体可参考官方文档）。&lt;/p&gt; 
&lt;h3&gt;4. 多账号体系&lt;/h3&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;如果系统中存在多种身份的用户，例如普通用户、管理员、商家等，可以使用多账号体系进行区分。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;登录指定账号体系：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 管理员登录，loginKey 为"admin"&lt;/em&gt;
StpUtil.login(&lt;span style="color:#986801"&gt;10001&lt;/span&gt;, &lt;span style="color:#50a14f"&gt;"admin"&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;检查登录状态：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 检查当前账号体系下是否登录&lt;/em&gt;
&lt;span style="color:#986801"&gt;boolean&lt;/span&gt; &lt;span style="color:#986801"&gt;isLogin&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; StpUtil.isLogin(&lt;span style="color:#50a14f"&gt;"admin"&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;权限验证：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-java"&gt;&lt;em&gt;// 在指定账号体系下进行权限验证&lt;/em&gt;
StpUtil.checkPermission(&lt;span style="color:#50a14f"&gt;"user:update"&lt;/span&gt;, &lt;span style="color:#50a14f"&gt;"admin"&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;四、Sa-Token 使用总结&lt;/h2&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;Sa-Token 是一款轻量级的 Java 权限认证框架，因其简单易用和功能丰富而备受开发者青睐。它以简洁明了的 API 设计，使得集成和使用变得非常方便，开发者可以快速上手，降低了学习成本。Sa-Token 支持多种权限控制需求，满足复杂业务场景，包括登录认证、权限验证、角色验证、Session 会话、多账号体系等功能，全面覆盖了权限管理的各个方面。其轻量级的设计对系统性能影响小，适用于高并发的应用环境。此外，Sa-Token 提供了丰富的扩展接口，与 Spring、SpringBoot、Solon 等常用框架高度兼容，支持自定义持久化、注解方式验证、单点登录等高级特性，方便开发者根据项目需求进行定制开发。活跃的社区支持和丰富的文档资源也使得开发者能够轻松获取帮助和指导。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;由于这些优势，Sa-Token 非常适 Web 项目的快速开发和微服务架构下的权限管理。当项目需要快速搭建权限系统时，选择 Sa-Token 是一个理想的方案。然而，在使用过程中需要注意 Token 的安全性，防止泄露带来风险；对于高并发场景，建议使用 Redis 等持久化介质来提高系统性能和扩展性；同时，关注 Sa-Token 的版本更新，及时获取新功能和安全补丁，以确保系统的安全性和稳定性。&lt;/p&gt; 
&lt;p style="color:#24292e; text-align:start"&gt;此文参考自：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fliuguangzhi%2Farticles%2F18415627" target="_blank"&gt;https://www.cnblogs.com/liuguangzhi/articles/18415627&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369936</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369936</guid>
      <pubDate>Mon, 01 Sep 2025 11:12:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>快手发布工业级规模强化学习 (RL) 训练框架 SeamlessFlow</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;快手 Kwaipilot 团队近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_pewU-ZtVhhEpJVebwKysQ" target="_blank"&gt;发布&lt;/a&gt;了 SeamlessFlow 技术报告，SeamlessFlow 是该团队所使用的工业级规模强化学习（RL）训练框架。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1436" src="https://static.oschina.net/uploads/space/2025/0902/184001_9a1i_2720166.png" width="2762" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，该框架通过创新的数据平面架构，对 RL 的训练逻辑和 Agent 做了彻底解耦，用以支持多智能体、在线强化学习训练等复杂场景。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/184245_Kuc6_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;更进一步，针对 RL 计算资源分配问题，团队提出了「标签分配机制」，统一了该领域最广泛的两种设计模式（训推共卡、训推分离）。以标签分配的思路为出发点，在业界首个提出「时空复用 pipeline」，实现了在训推分离的异构集群上彻底消除 Pipeline Bubble 的效果。&lt;/p&gt; 
&lt;p&gt;在实际测试中，SeamlessFlow 的端到端 token 吞吐量相比基线提升 100%，整体训练时间减少 62%。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/184306_P1R7_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/184325_U9bF_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;详细内容查看技术报告：&lt;em&gt;https://arxiv.org/abs/2508.11553&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369933</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369933</guid>
      <pubDate>Mon, 01 Sep 2025 10:45:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Salesforce 裁员 4000 人，引入 AI 代理</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;作为一家知名的客户关系管理（CRM）平台，Salesforce 近日宣布其客户支持团队从 9000 人减少至约 5000 人。这一变化是由于公司推出了新的代理服务和支持产品。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="325" src="https://oscimg.oschina.net/oscnet/up-7cb3d84925fce813c55404c48eaee49bc24.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Salesforce 的首席执行官马克・贝尼奥夫（Marc Benioff）在最近的一次播客中透露，公司自称为该工具的 「客户零」(customer zero)，并表示这一系统已经成功处理了约 150 万次客户对话，而在相同的时间段内，人工支持代理的对话数量大致相同。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;贝尼奥夫强调，人工智能的引入不仅仅是为了降低成本，更是为了提高公司的收入。他指出，Salesforce 在过去 26 年中积累了超过 1 亿个未处理的潜在客户，主要是由于人员不足。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;现在，借助新的代理销售系统，Salesforce 能够联系到每一个潜在客户，每周进行超过 1 万次的对话。这一措施使得 Salesforce 的市场响应能力显著提高，同时为公司创造了新的商机。未来，Salesforce 希望能通过不断优化和改进其 AI 系统，进一步增强公司的竞争力，实现更大的商业成功。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369931</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369931</guid>
      <pubDate>Mon, 01 Sep 2025 10:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>把 DolphinScheduler 搬进 K8s：奇虎 360 商业化 900 天踩坑全记录</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/qi-hu.png" alt="奇虎" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;👋 大家好，我是远朋。过去 3 年，我们团队把部分调度任务从 Azkaban 逐步迁移到 DolphinScheduler，并开展了 K8s 容器化。今天把踩过的坑、攒下的经验一次性覆盘，建议收藏！&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;作者介绍&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/wang-yuan-peng.jpg" alt="王远朋" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;王远朋&lt;/strong&gt; 上海奇虎科技有限公司，数据专家，商业化 SRE &amp;amp; 大数据团队核心成员，长期负责 DolphinScheduler 在生产环境的部署与优化，具备丰富的容器化与大数据调度经验。&lt;/p&gt; 
&lt;p&gt;在大数据任务调度的日常工作中，Apache DolphinScheduler 已经成为我们团队最核心的工具之一。过去我们一直依赖物理机进行部署，例如 3.1.9 版本仍运行在&lt;strong&gt;物理机&lt;/strong&gt;环境中，但这种方式在弹性扩展、资源隔离和运维效率上逐渐暴露出问题。随着公司整体的云原生战略推进，我们最终在 2025 年将 DolphinScheduler 升级到 3.2.2，并部分迁移到 &lt;strong&gt;Kubernetes 平台&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;迁移的动机非常明确：首先是&lt;strong&gt;弹性扩容&lt;/strong&gt;，K8S 可以根据任务高峰快速扩展 Worker 节点；其次是&lt;strong&gt;资源隔离&lt;/strong&gt;，避免不同任务相互影响；再者是&lt;strong&gt;自动化部署与回滚&lt;/strong&gt;，大幅降低维护成本；最后，也是最重要的一点，这一切符合公司在技术层面的&lt;strong&gt;云原生方向&lt;/strong&gt;。&lt;/p&gt; 
&lt;h3&gt;镜像构建：从源码到模块&lt;/h3&gt; 
&lt;p&gt;在迁移过程中，镜像构建是第一步。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563633473102.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我们先准备了一个包含 Hadoop、Hive、Spark、Flink、Python 等环境的基础镜像，然后在此基础上构建 DolphinScheduler 的基础镜像，将重新编译的各个模块和 MySQL 驱动打包其中。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563634307756.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;这里需要注意的是，MySQL 被用作 DolphinScheduler 的元数据存储，因此驱动包必须软链到每一个模块，包括 &lt;code&gt;dolphinscheduler-tools&lt;/code&gt;、&lt;code&gt;dolphinscheduler-master&lt;/code&gt;、&lt;code&gt;dolphinscheduler-worker&lt;/code&gt;、&lt;code&gt;dolphinscheduler-api&lt;/code&gt; 和 &lt;code&gt;dolphinscheduler-alert-server&lt;/code&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563635065036.jpg" alt="" referrerpolicy="no-referrer"&gt; Worker 镜像&lt;/p&gt; 
&lt;p&gt;模块镜像则是在 DS 基础镜像之上进行定制，主要修改端口和配置。为了减少后续配置文件的改动，我们尽量保持模块镜像的名称与官方一致。构建时既可以单独构建某个模块，例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;./build.sh worker-server
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563634594536.jpg" alt="" referrerpolicy="no-referrer"&gt; 单独构建镜像&lt;/p&gt; 
&lt;p&gt;也可以批量构建所有模块：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;./build-all.sh
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563634803090.jpg" alt="" referrerpolicy="no-referrer"&gt; 批量构建镜像&lt;/p&gt; 
&lt;p&gt;这一步里我们遇到的典型问题包括：&lt;strong&gt;基础镜像过大导致构建时间过长，源码改造后的 jar 包没有覆盖旧文件，甚至不同模块的端口配置和启动脚本不一致。&lt;/strong&gt; 这些细节如果处理不当，就会在后续部署阶段带来一系列棘手的问题。&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;问题&lt;/th&gt; 
   &lt;th&gt;解决方案&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;基础镜像过大、构建慢&lt;/td&gt; 
   &lt;td&gt;把公共软件层拆成多阶段构建缓存&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;MySQL 驱动找不到&lt;/td&gt; 
   &lt;td&gt;建软链到所有模块 &lt;code&gt;lib/&lt;/code&gt; 目录&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;自编译 Jar 没覆盖旧包&lt;/td&gt; 
   &lt;td&gt;build.sh 里加 &lt;code&gt;find -name "*.jar" -delete&lt;/code&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;部署方案：从自制 YAML 到官方 Helm Chart&lt;/h3&gt; 
&lt;p&gt;在部署初期，我们是手写 YAML 文件来完成部署的，但这种方式在配置分散和升级维护上成本极高。后来我们改用了官方提供的 Helm Chart，这样配置集中管理，升级也更方便。&lt;/p&gt; 
&lt;p&gt;我们使用的 K8S 集群版本是 v1.25，部署时需要先创建命名空间 &lt;code&gt;dolphinscheduler&lt;/code&gt;，然后拉取 helm 包，例如：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;helm pull oci://registry-1.docker.io/apache/dolphinscheduler-helm --version 3.2.2
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在真正落地过程中，&lt;code&gt;values.yaml&lt;/code&gt; 是最核心的文件，我们在这里踩过很多坑。下面贴出几个关键配置片段，供大家参考：&lt;/p&gt; 
&lt;h4&gt;1. 镜像配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;image:
  registry: my.private.repo
  repository: dolphinscheduler
  tag: 3.2.2
  pullPolicy: IfNotPresent
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 提示：一些前置的工具镜像最好提前 push 到私有仓库，避免因网络或镜像源问题导致部署失败。&lt;/p&gt; 
&lt;h4&gt;2. 外置数据库配置（MySQL）&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;mysql:
  enabled: false   # 关闭内置 MySQL
externalMysql:
  host: mysql.prod.local
  port: 3306
  username: ds_user
  password: ds_password
  database: dolphinscheduler
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 内置数据库务必关闭，生产环境统一接入外部 MySQL（未来我们将切换到 PostgreSQL）。&lt;/p&gt; 
&lt;h4&gt;3. LDAP 登录认证&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;ldap:
  enabled: true
  url: ldap://ldap.prod.local:389
  userDn: cn=admin,dc=company,dc=com
  password: ldap_password
  baseDn: dc=company,dc=com
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 我们接入了公司 LDAP，统一用户认证，方便权限管理。&lt;/p&gt; 
&lt;h4&gt;4. 共享存储配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;sharedStoragePersistence:
  enabled: true
  storageClassName: nfs-rwx
  size: 100Gi
  mountPath: /dolphinscheduler/shared
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 注意：storageClassName 必须支持 &lt;code&gt;ReadWriteMany&lt;/code&gt;，否则多个 Worker 节点无法同时访问共享目录。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563644421212.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h4&gt;5. HDFS 配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;hdfs:
  defaultFS: hdfs://hdfs-nn:8020
  path: /dolphinscheduler
  rootUser: hdfs
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 所有大数据相关组件路径需要提前准备好，例如 &lt;code&gt;/opt/soft&lt;/code&gt;。&lt;/p&gt; 
&lt;h4&gt;6. Zookeeper 配置&lt;/h4&gt; 
&lt;pre&gt;&lt;code class="language-yaml"&gt;zookeeper:
  enabled: false   # 关闭内置 ZK
externalZookeeper:
  quorum: zk1.prod.local:2181,zk2.prod.local:2181,zk3.prod.local:2181
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;👉 使用外置 Zookeeper 时，记得关闭内置配置，同时确认 ZK 版本符合官方最低要求。&lt;/p&gt; 
&lt;h3&gt;踩坑经验与维护挑战&lt;/h3&gt; 
&lt;p&gt;在整个迁移过程中，我们踩过的坑不少。比如，镜像制作问题、Helm values.yaml 修改的坑，以及定制化升级和维护成本过高等。&lt;/p&gt; 
&lt;h4&gt;镜像制作相关问题&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像制作时因为基础镜像太大，导致构建过程漫长；&lt;/li&gt; 
 &lt;li&gt;模块依赖差异导致重复安装；&lt;/li&gt; 
 &lt;li&gt;有时候 MySQL 驱动包路径不正确，模块启动时报错；&lt;/li&gt; 
 &lt;li&gt;源码改造后的 jar 包忘记覆盖旧文件，也曾造成过运行时异常，不同模块端口与启动脚本不一致，导致启动不顺利。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;Helm values.yaml 注意点&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;sharedStoragePersistence.storageClassName 必须支持 ReadWriteMany 存储类&lt;/li&gt; 
 &lt;li&gt;storage 大小&lt;/li&gt; 
 &lt;li&gt;mountPath 与配置文件不一致&lt;/li&gt; 
 &lt;li&gt;配置项路径缩进&lt;/li&gt; 
 &lt;li&gt;关闭默认配置以及一些不需要的配置，例如 Zookeeper 外置时需关闭内置选项，同时注意 zk 需要的版本&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;维护升级成本&lt;/h4&gt; 
&lt;p&gt;更大的挑战来自后续维护。因为我们对源码和镜像做过定制化修改，所以每当 DolphinScheduler 发布新版本，我们都需要重新对比修改点，重新构建并测试全部模块镜像。&lt;/p&gt; 
&lt;p&gt;同时，由于不同版本之间配置项差异较大，升级和回滚的过程都容易出错。这些问题导致我们的升级周期变长，维护难度加大，团队人力成本也显著上升。&lt;/p&gt; 
&lt;h3&gt;未来规划与思考&lt;/h3&gt; 
&lt;p&gt;为了降低长期的运维成本，我们已经在逐步推进标准化。未来计划包括： 将 DolphinScheduler 的元数据库从 MySQL 切换到 PostgreSQL，全面采用社区官方镜像而非自研镜像，生产任务也会逐步迁移到 K8S 环境中。&lt;/p&gt; 
&lt;p&gt;同时，我们会引入 CI/CD 流程，并结合 Prometheus 与 Grafana 做可观测性建设，提升部署效率与监控能力。&lt;/p&gt; 
&lt;p&gt;总的来说，K8S 部署让 DolphinScheduler 在扩展性、弹性和迁移性上具备了远超物理机的优势。虽然镜像定制化和配置修改带来了不小的挑战，但随着我们逐渐回归社区版本和标准化运维，维护成本会越来越低，部署效率会越来越高。&lt;/p&gt; 
&lt;p&gt;我们的长期目标，是构建一个高可用、易扩展、统一化的调度平台，真正释放云原生的价值。如果你也在考虑把调度系统搬上 K8s，欢迎评论区交流，或加入 DolphinScheduler 社区一起搬砖！&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://openwrite-whaleops.oss-cn-zhangjiakou.aliyuncs.com/2025/08/28/17563644922397.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/dailidong/blog/18690374</link>
      <guid isPermaLink="false">https://my.oschina.net/dailidong/blog/18690374</guid>
      <pubDate>Mon, 01 Sep 2025 10:27:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Kuscia - 基于 K3s 的轻量级隐私计算任务编排框架</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="color:rgba(0, 0, 0, 0.88); margin-left:0; margin-right:0; text-align:start"&gt;Kuscia（Kubernetes-based Secure Collaborative InfrA）是一款基于 K3s 的轻量级隐私计算任务编排框架，旨在屏蔽异构基础设施和协议，并提供统一的隐私计算底座。&lt;/p&gt;

&lt;p style="color:rgba(0, 0, 0, 0.88); margin-left:0; margin-right:0; text-align:start"&gt;通过 Kuscia：&lt;/p&gt;

&lt;ul style="margin-left:0; margin-right:0"&gt;
&lt;li&gt;轻量化部署：你可以用最低 1C2G 的资源完成 100W 级数据隐私求交 (PSI)。&lt;/li&gt;
&lt;li&gt;跨域网络安全通信：可以实现多隐私计算任务并发执行时的端口复用（仅需一个公网端口）与安全通信。&lt;/li&gt;
&lt;li&gt;统一的 API 接口：可以使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;a href="https://www.secretflow.org.cn/zh-CN/docs/kuscia/main/reference/apis/summary_cn"&gt;HTTP/GRPC API 接口&lt;/a&gt;&lt;/span&gt;集成隐私计算能力。&lt;/li&gt;
&lt;li&gt;互联互通：可以与行业内多种隐私计算系统进行互联互通。&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:rgba(0, 0, 0, 0.88); margin-left:0; margin-right:0; text-align:start"&gt;更多 Kuscia 的能力介绍，可参考&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;a href="https://www.secretflow.org.cn/zh-CN/docs/kuscia/main/reference/overview"&gt;Kuscia 概述&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" height="377" src="https://static.oschina.net/uploads/space/2025/0829/154436_QAD6_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/kuscia</link>
      <guid isPermaLink="false">https://www.oschina.net/p/kuscia</guid>
      <pubDate>Mon, 01 Sep 2025 10:18:00 GMT</pubDate>
    </item>
    <item>
      <title>清华与东北大学联合推出 UltraRAG 2.0</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;清华大学 THUNLP 实验室、东北大学 NEUIR 实验室与 OpenBMB 及 AI9Stars 联合发布了 UltraRAG2.0，这是首个基于 Model Context Protocol（MCP）架构设计的检索增强生成 (RAG) 框架。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该框架致力于简化 RAG 系统的构建过程，使科研人员可以在短时间内实现复杂的多阶段推理系统。UltraRAG2.0 的亮点在于用户只需通过编写 YAML 文件，即可轻松声明复杂的逻辑，如串行、循环和条件分支，从而显著减少代码量，降低实现的门槛。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在当前的 RAG 发展趋势中，许多系统逐渐融入了自适应知识组织、多轮推理及动态检索等复杂特性，代表项目包括 DeepResearch 和 Search-o1。然而，这些复杂特性也给开发者带来了高昂的工程成本，制约了新想法的快速迭代与复现。UltraRAG2.0 应运而生，它通过将 RAG 的核心组件封装为独立的 MCP 服务器，实现了功能的灵活调用和扩展。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;具体而言，与以往的实现方式相比，UltraRAG2.0 在代码量上大幅减少。例如，经典方法 IRCoT 的官方实现需要近 900 行代码，而使用 UltraRAG2.0 只需约 50 行代码就能完成同等功能。其中一半的代码是用于流程编排的 YAML 伪代码，极大降低了开发门槛。框架支持通过简洁的声明式方式来构建多阶段推理流程，使得复杂的推理逻辑不再需要冗长的手动编码。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="316" src="https://oscimg.oschina.net/oscnet/up-8ffdf7ae1633d0f30510d1cb66672338fbe.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;UltraRAG2.0 还支持动态检索、条件判断及多轮交互等&lt;span&gt;高级&lt;/span&gt;功能，科研人员可以在短时间内搭建出高性能的实验平台，满足复杂多跳问题的需求。其性能较传统的 Vanilla RAG 提升约 12%。该系统的设计旨在让研究者在工程实现方面节省时间和精力，将更多的注意力放在算法创新和实验设计上。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，UltraRAG2.0 的 MCP 架构允许不同模块间的无缝复用，并支持模块的灵活扩展和接入，方便科研人员快速适配新的模型和算法。这一设计极大提升了系统开发的效率和可复现性。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369915</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369915</guid>
      <pubDate>Mon, 01 Sep 2025 09:36:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>这款全新的 Linux 桌面发行版几乎与 OS X 如出一辙</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Gershwin 是一款正在开发中的全新开源 Linux 桌面环境，目标是在 BSD 与 Arch Linux 上带来类似 macOS 的使用体验。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-86d4824b0345ee3351031cb07530c092dda.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5f1b49d23ae230a85b749ebeb383dd209f8.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/gershwin-desktop/gershwin-desktop&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;Gershwin 基于 GnuStep，而 GnuStep 本身源自 NeXTStep（macOS 的前身），因此界面风格自然与 OS X 十分接近。不过，由于 GnuStep 的老派设计，&lt;strong&gt;Gershwin 更像是「复古版 macOS」，看起来更接近早期的 OS X&lt;/strong&gt;，而非现代的 macOS。&lt;/p&gt; 
&lt;p&gt;目前 Gershwin 仍处于早期 alpha 阶段，功能有限：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;应用程序通过 Dock 管理，而非桌面图标；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;应用启动器尚不稳定，运行程序常需手动调用；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;最稳定的体验方式是通过 GhostBSD 运行，也能在 Arch Linux 上安装，但不推荐。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;虽然现阶段实用性不足，但 Gershwin 展现了独特潜力：一个兼具怀旧感与现代性，的桌面环境。如果开发顺利推进，它有望成为 BSD/Linux 用户的另类选择。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369912</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369912</guid>
      <pubDate>Mon, 01 Sep 2025 09:31:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>宇树科技宣布将在四季度提交 IPO 申请</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;宇树科技在社交媒体上发帖称，预计将在 2025 年 10 月至 12 月期间向证券交易所提交上市申请文件，届时公司的相关运营数据将正式披露。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="652" src="https://oscimg.oschina.net/oscnet/up-adeb6b500a9f884cfa342d939c1ffff851d.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;宇树科技表示，以 2024 年为例，四足机器人、人形机器人和组件产品的销售额分别占约 65%、30% 和 5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其中，约 80% 的四足机器人被应用于研究、教育和消费领域，而剩余的 20% 则被用于工业领域，如检查与消防。人形机器人完全用于研究、教育和消费领域。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369909</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369909</guid>
      <pubDate>Mon, 01 Sep 2025 09:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Linux 文件系统 Btrfs 长期贡献者退出内核项目，加入 Anthropic</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Josef Bacik 是长期参与 Btrfs 文件系统开发的资深工程师，他在 2025 年 8 月 29 日宣布离开 Meta（原 Facebook），选择加入 AI 公司 Anthropic，投身 AI 基础设施事业，并不再将 Linux 内核开发作为主要职业方向。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b2d57c0b86cc532363c44a3c1f2bebc2583.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Josef Bacik 说道，下周我将开启新篇章，加入 Anthropic，协助其扩展基础设施；&lt;strong&gt;这也是我职业生涯中第一次不再以内核开发为主的工作&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「Next week I start a new chapter, I will be joining Anthropic to help them scale out their infrastructure … I will be stepping back from kernel development as my primary job for the first time in my career.」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Josef Bacik 对曾经所在团队表达了高度认可，也坦言时间到了该进入新阶段，他希望运用自己在内核与系统方面的多年经验，协助 Anthropic 扩展基础设施。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369907</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369907</guid>
      <pubDate>Mon, 01 Sep 2025 09:03:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Meta 与 Scale AI 合作现裂痕</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;自今年 6 月以来，尽管 Meta 向数据标注公司 Scale AI 投资了高达 143 亿美元，并聘请其首席执行官 Alexandr Wang 等高管加盟 Meta Superintelligence Labs （MSL），但双方的关系似乎正面临挑战。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;核心问题源于数据质量的争议。尽管进行了巨额投资，但消息人士透露，Meta 核心 AI 部门 TBD Labs 的研究人员普遍认为 Scale AI 的数据质量不佳，更倾向于与 Scale AI 的主要竞争对手 Mercor 和 Surge 合作。Meta 的 TBD Labs 在成立前就已与这两家公司有合作，但向一家数据供应商投入如此巨资后，仍然依赖其竞争对手的情况十分罕见。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="282" src="https://oscimg.oschina.net/oscnet/up-949f1f529dd7a49117f6b1fcb77a8d33a02.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;这种现象背后反映出数据标注行业的变化。早期，Scale AI 的众包模式依赖低成本劳动力处理简单任务，但随着 AI 模型复杂化，需要医生、律师等高技能领域专家来提供高质量数据。尽管 Scale AI 推出了 Outlier 平台，但像 Mercor 和 Surge 这样从一开始就建立在高薪人才模式上的竞争对手正迅速崛起。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;除了商业合作上的紧张，双方的人事整合也遭遇挫折。Scale AI 前高管 Ruben Mayer 在加入 Meta 仅两个月后便离职，进一步引发外界关注。尽管 Mayer 表示是因「个人原因」离开，且对在 Meta 的工作经历感到满意，但他对自己在 Meta 的职责定位与内部消息人士的说法存在分歧。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;此外，Meta 的 AI 部门也面临人才流失问题。有前员工和现任员工透露，自从引入 Alexandr Wang 和一批来自 OpenAI 等公司的人才后，Meta 的 AI 部门变得混乱。新加入的人员对大公司的官僚作风感到沮丧，而 Meta 原有的 GenAI 团队则感到能力受限。MSL AI 研究员 Rishabh Agarwal 等多名核心员工近期相继离职，这给 Meta 的 AI 发展前景蒙上阴影。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;这次投资被普遍认为是 Meta CEO 扎克伯格在 Llama4 发布平淡后，为追赶 OpenAI 和谷歌而采取的紧急举措。他不仅吸纳了 Alexandr Wang，还积极从 OpenAI、谷歌 DeepMind 等公司招募顶尖人才。然而，鉴于部分新员工的迅速离职以及内部团队的混乱，Meta 能否稳定其 AI 运营并留住人才，仍是一个悬而未决的问题。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369898</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369898</guid>
      <pubDate>Mon, 01 Sep 2025 08:54:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源操作系统框架 Genode OS 发布 25.08 版本</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源操作系统框架 Genode OS 发布了 25.08 版本，引入了新的内核调度器以实现公平性和低延迟，探索了 XML 的替代方案，优化了块存储堆栈，并将所有基于 Linux 的 PC 驱动程序更新至内核版本 6.12。&lt;/p&gt; 
&lt;p&gt;此外，该版本还为最新版本 13.0 的 seL4 微内核解锁了更多动态场景。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-843a3a17acca0079fa8555dc66189112455.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;核心调度器（Kernel Scheduler）重构：优化公平性与延迟&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;新版本对 Genode OS 中的内核调度器进行了全面重构，尤其为其通用操作系统 Sculpt OS 考量了动态工作负载的需求，优化了任务调度的公平性与响应延迟。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;块存储层（Block Layer）改进&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;对块存储子系统进行了多项优化，包括精简数据路径、提升 I/O 性能。这些改进通过整体优化块存储栈，减少中间组件（如分区管理模块）的参与，增强了多队列硬件支持能力。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Linux 驱动更新至 Kernel 6.12 LTS&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Genode 的 Linux 驱动组件——在其 Linux 驱动环境中使用的驱动程序均已升级，基于 Linux 6.12 LTS 源代码，对硬件兼容性和稳定性进行了增强。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;兼容 seL4 微内核：支持 seL4 版本 13.0&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Genode 持续扩展其对 seL4 微内核的支持。此版本中，已将 seL4 内核更新到最新 13.0 版本，并解决了先前存在的可扩展性瓶颈，尤其改善了动态场景（如插拔式驱动加载）下的表现。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;探索 XML 的替代语法&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为了改进配置与报告流程，新版本引入了对 XML 的替代语法支持，允许配置文件逐步从 XML 切换到更轻量的形式，并支持与 XML 之间的互操作性，这一思路已规划超过两年，本次进入实用评估阶段。&lt;/p&gt; 
&lt;p&gt;详情查看&amp;nbsp;&lt;em&gt;https://genode.org/documentation/release-notes/25.08&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369887</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369887</guid>
      <pubDate>Mon, 01 Sep 2025 08:28:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
