<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 Sep 2025 07:49:05 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>自由职业服务市场 ​Fiverr 裁员 30%，转型为 「AI 优先」 公司</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;自由职业服务市场 Fiverr 近日宣布将裁员约 250 名员工，约占其总员工的 30%。公司创始人兼首席执行官米哈伊・考夫曼在社交平台 X 上表示，AI 技术的引入将促使 Fiverr 进行根本性的重塑，重新回到 「初创模式」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他强调，这一转型将需要痛苦的重置过程，因此将与来自不同部门的员工分道扬镳，最终形成一个更小、更扁平化的组织结构。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="339" src="https://oscimg.oschina.net/oscnet/up-3afbc6b00ea5d0d1596fad055e3e436158c.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;考夫曼指出，AI 的应用可以 「解放人类，使其摆脱繁琐的手动任务」，并 「开启历史上不可能或成本过高的能力」。为了缓解离职员工的压力，他承诺将提供遣散费和延长的健康保险。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;由于对 AI 技术的担忧，许多企业已在此领域投入了近 400 亿美元的资金。与此同时，其他科技公司也面临着因 AI 而导致的大规模裁员，如印度服务巨头塔塔咨询服务（TCS）最近裁减了超过 10000 名员工，并提高了留任员工的工资。Fiverr 的最新举措也似乎意在提升公司的股价。在 2021 年 2 月，Fiverr 的市场资本一度达到 110 亿美元，但如今的股价仅徘徊在 23 美元附近，在裁员消息公布后稍有下滑。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;考夫曼早在今年 5 月就已向员工发出警告，表示 AI 正在侵袭每个人的工作。他鼓励员工利用 AI 替代工作中的繁琐任务，甚至希望他们实现 「100% 自动化」。他表示，管理层的期望是每个员工在单位时间内的输出和质量都要翻倍或三倍提升。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;最后，考夫曼提到，AI 实际上迫使我们重新发现人性，强调每个人独特的价值和特殊属性。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372760</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372760</guid>
      <pubDate>Wed, 17 Sep 2025 07:40:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马斯克宣布将在数周后开始训练 Grok 5 模型，并称有机会实现 AGI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;马斯克社交平台&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1968196086193066365" target="_blank"&gt;预告&lt;/a&gt;了 xAI 下一代大模型的消息，表示将在几周后开始训练 Grok 5。他上个月曾说过 Grok 5 将在今年年底前推出。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/151342_o1bd_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;马斯克还说道，「&lt;strong&gt;我现在认为 xAI 有机会通过 Grok 5 实现 AGI，此前从未有过这种想法。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/151300_lnoo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;今年 7 月，&lt;span style="background-color:#ffffff; color:#333333"&gt;&lt;a href="https://www.oschina.net/news/359656/xai-grok4" target="_blank"&gt;马斯克正式发布了 Grok 4&lt;/a&gt;，声称是全球最强 AI 模型，在处理学术问题上的表现已达到博士级别。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0710/145628_93z7_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Grok 4 系列包括两个版本：Grok 4 和 Grok 4 Heavy。两者都是纯推理模型，没有非推理模式。Grok 4 是单代理（single agent）版本，而 Grok 4 Heavy 是多代理版本（multi agents），支持四个代理同时工作。上下文窗口最高支持 256k tokens。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372757</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372757</guid>
      <pubDate>Wed, 17 Sep 2025 07:19:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源 BI 工具 DataEase v2.10.13 LTS 发布，AI 智能问数能力全面升级</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;2025 年 9 月 16 日，人人可用的开源 BI 工具 DataEase 正式发布 v2.10.13 LTS 版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;重要更新：AI 智能问数能力全面升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase v2.10.13 LTS 版本重磅引入全新的开源智能问数系统 SQLBot（&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;https://github.com/dataease/SQLBot&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;），完全替代 DataEase 原有的 Copilot 功能。SQLBot 是基于大语言模型和 RAG（Retrieval Augmented Generation，检索增强生成）的开源智能问数系统，帮助用户实现数据的即问即答，有效提升数据查询的智能化水平。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;与同类产品相比，SQLBot 的优势体现在以下方面：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;更快速：通过自然语言即可快速生成复杂的 SQL 查询；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;更精准：智能理解业务意图，大幅减少查询错误；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;更开放：基于开源架构，支持社区贡献和自定义扩展。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase 嵌入 SQLBot 后将全面升级用户的智能问数体验，辅助用户高效挖掘数据价值，让数据分析变得更加简单和直观。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img alt="" height="624" src="https://oscimg.oschina.net/oscnet/up-f64c3442dd72aa8d64c1f32e10f15f7c206.png" width="1189" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;span&gt;▲图 1 SQLBot 智能问数工作原理&lt;/span&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="632" src="https://oscimg.oschina.net/oscnet/up-e4fe0c4f7f4af508eb1087d48ee26a0b6e6.png" width="1230" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;span&gt;▲图 2 DataEase 嵌入 SQLBot 智能问数系统&lt;/span&gt; 
&lt;/div&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase v2.10.13 LTS 版本的其他功能变动包括：&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;查询组件&lt;/span&gt;&lt;/strong&gt;方面，日期查询组件增加快捷选项；&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;仪表板/数据大屏&lt;/span&gt;&lt;/strong&gt;方面，通用配色增加斑马纹配色；&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;系统设置&lt;/span&gt;&lt;/strong&gt;方面，系统变量值支持设置别名。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;X-Pack 增强包&lt;/span&gt;&lt;/strong&gt;的功能变动包括：&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;数据填报&lt;/span&gt;&lt;/strong&gt;方面，内置数据源增加支持数据填报功能配置。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;新增功能&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（系统参数）：支持 SQLBot 嵌入设置；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（仪表板、数据大屏）：通用配色增加斑马纹配色；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（查询组件）：日期查询组件增加快捷选项；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（系统设置）：系统变量值支持设置别名（#16713）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（X-Pack，数据填报）：内置数据源增加支持数据填报功能配置。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;功能优化&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（图表）：优化移动端跳转问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（数据大屏、仪表板）：资源发布时，清理无用数据（#16749）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，定时报告）：定时报告页面增加额外等待时间设置；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，用户管理）：创建用户 API 接口返回数据增加用户 ID（#16825）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，同步管理）：使用 Quartz 统一管理任务调度；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：对 Elasticsearch 数据源时间类型字段进行优化，默认映射为 Doris 的 String 类型；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：优化任务状态刷新机制；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：优化同步日志提示信息；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：优化同步配置参数传递逻辑；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor：更新移动端样式。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;Bug 修复&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复放大 Tab 中图表并执行导出图片操作后，轮播提示显示异常的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复明细表合并单元格后，维度存在空值时导出失败的问题（#16777）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复明细表基础样式勾选「自动换行」选项后，表头会出现部分信息不显示的问题（#16804）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复明细表字段全都是维度时，导出的 Excel 文件中单元格合并失效的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复水波图标签被裁剪的问题（#16798）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复查询组件首选项会影响跳转条件的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复透视表列维度为空时，带格式导出会失败的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：开启轮播提示的图表启用缩略轴时，禁用轮播提示；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复透视表自定义汇总时，通过搜索添加字段会报错的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复地图中福州与福清、平潭的连线出现多余连接线的问题（#16877）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：字段自定义排序去除空值（#16307）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（图表）：修复明细表隐藏列后，导出数据出现错乱的问题（#16785）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复设置默认值和必填项，同时隐藏查询按钮时，输入任意值回车后均会重置为默认值的问题（#16750）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复手动输入型选项值在查看时，默认值显示为未勾选状态的问题（#16709）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复开启首选项时未关闭查询按钮，导致查询按钮失效的问题（#16894）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复文本搜索需两次回车才能返回结果，首次触发显示「暂无数据」的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复时间范围组件默认值提示「超出日期筛选范围」的问题（#16914）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查询组件）：修复行权限与过滤组件「首项」默认值同时使用时，会导致过滤功能失效的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（仪表板）：修复手动输入型查询组件出现样式错位的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（仪表板）：修复仪表板缩放模式切换为「按组件比例缩放」后，保存发布再次查看不生效问题（#16885）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（数据大屏）：修复 Tab 及内部组件的右键菜单定位偏移问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（仪表板、数据大屏）：修复设置图表背景图时出现多余滚动条问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复调整浏览器窗口大小时，Excel 字段选择器的选中状态被隐藏的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复无数据源时点击「创建数据集」按钮，页面卡死且控制枱报错的问题（#16831）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复飞书渠道查看更新记录提示异常的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复 SQL Server 数据过滤异常的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复 Calcite 转 SQL Server 时 CONCAT 函数异常的问题（#16860）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据源）：修复 SQL Server 下拉树组件报错问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据集）：修复字段表达式引用新建计算参数失效的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（数据集）：修复自定义 SQL 未保存直接关闭时缺少提示信息的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（系统设置）：修复三方嵌入配置仅保存不验证时，错误触发应用状态变更的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（系统设置）：修复弹窗层级显示异常的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修复 SQL 查询验证错误；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修复 SQL Server 表名含@符号时任务创建失败的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修复下次执行时间计算错乱问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修复数据源异常时同步日志丢失的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修复 SQL Server uniqueidentifier 字段导致定时任务创建失败的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修复字段数量过多导致任务创建失败的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修复「权限配置」→「按用户配置」时，用户量过大导致页面卡顿的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修复移动仪表板后，后台缓存未即时刷新的问题；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修复在「组织管理」模块中修改名称需刷新浏览器才能生效的问题（#16751）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（漏洞）：修复 DB2 LDAP 存在的 SSRF 漏洞（CVE-2025-58045）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（漏洞）：修复 Impala 数据源 JDBC 攻击漏洞（CVE-2025-58046）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（漏洞）：修复 Redshift JDBC 绕过漏洞（CVE-2025-58748）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：修复模板市场地址提示错误（#16858）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：统一数据大屏与仪表板事件触发规则，编辑状态下禁止触发；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：修复存储单位判断脚本中非 GB 单位的处理问题。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4736111/blog/18692091</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/18692091</guid>
      <pubDate>Wed, 17 Sep 2025 07:03:11 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>香港已预留十亿港元，于明年成立「香港人工智能研发院」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;香港特区行政长官李家超今日（9 月 17 日）在香港特区立法会综合大楼会议厅发表《行政长官 2025 年施政报告》，这是李家超任期内的第四份施政报告。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李家超表示，香港具备科研、资金、数据、人才的优势，并有丰富应用场景，有望成为全球 AI（人工智能）发展枢纽。特区政府会加大推动 AI 作为香港未来发展的核心产业，以「加强基建，推动应用导向」为策略，在重视防范安全风险的意识下，推进 AI+发展，促进 AI 在各行业广泛深度融合，实现「AI 产业化、产业 AI 化」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;据介绍，香港已预留 10 亿港元，于 2026 年成立「香港人工智能研发院」，促进 AI 上游研发、中下游成果转化及开拓应用场景。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="285" src="https://oscimg.oschina.net/oscnet/up-b76eed8addde7663069b00ddc554f15d3f3.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李家超还称，继数码港设立人工智能超算中心及特区政府推出「人工智能资助计划」后，今年内香港还会推出北区沙岭约 10 公顷数据园区发展用地作市场招标，提供先进算力设施，推动数据及 AI 相关产业发展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;香港金融管理局与数码港推出的第二期 AI 沙盒计划将推广至更多金融机构。据悉，香港金融管理局亦正建立 AI 模型评估方法，强化金融系统安全测试。香港特区发展局将资助私营工程应用 AI。香港律政司亦将成立跨部门工作小组，检视更广泛应用 AI 所需的法律配套。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372748</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372748</guid>
      <pubDate>Wed, 17 Sep 2025 07:00:11 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>甲骨文 MySQL 团队大规模裁员，引发创始人和社区担忧</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2025%2F09%2F11%2Foracle_slammed_for_mysql_job%2F" target="_blank"&gt;根据 The Register 的报道&lt;/a&gt;，甲骨文近日对其 MySQL 团队进行了大规模裁员，约有 70 名员工受到影响，其中不乏核心和资深开发者。&lt;/p&gt; 
&lt;p&gt;MySQL 联合创始人 Monty Widenius 表示对此「感到悲伤」，虽然对 Oracle 走向商业化和云端产品并不意外，但仍担心 MySQL 社区版未来受到威胁。&lt;/p&gt; 
&lt;p&gt;Widenius 还提到，当初创建 MariaDB 的目的之一就是「为下一代 MySQL」提供一个更稳定、更可持续的开源未来。现在这些事件被视为验证了他的担忧。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-7999b55d49242e1ba5dbcd77f53a7f88d75.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;曾在 MySQL 担任性能工程师的知名社区成员 Peter Zaitsev 也对裁员&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linkedin.com%2Fposts%2Fpeterzaitsev_mysql-opensource-activity-7370819205702664193-5gPl" target="_blank"&gt;表示强烈批评&lt;/a&gt;，担忧这是 Oracle 在削弱 MySQL 社区版（Community Edition）的影响力，甚至可能在「慢慢地杀掉」 MySQL 社区版本。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/144156_3NuF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;消息称 MySQL 团队已被并入 Oracle Heatwave 业务单元，未来开发重点将转向云端分析和 AI 相关功能，而非传统的社区版本迭代&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;业内担心，这可能意味着 Oracle 正在边缘化 MySQL 社区版，鼓励用户转向其商业产品。Widenius 也借机提醒用户关注 MariaDB 等替代方案，以保障 MySQL 的开源精神得以延续。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372738</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372738</guid>
      <pubDate>Sun, 14 Sep 2025 06:33:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里巴巴推出端到端语音识别大模型 FunAudio-ASR</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里巴巴通义实验室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7l5EPTU7cpz7GSN4RP91rg" target="_blank"&gt;宣布&lt;/a&gt;正式推出 FunAudio-ASR —— 一款专为解决企业落地难题而生的端到端语音识别大模型。它不仅拥有高精度的通用识别能力，还通过创新的 Context 增强模块，针对性优化了「幻觉」、「串语种」等工业场景中的关键问题。&lt;/p&gt; 
&lt;p&gt;这个模型的最大亮点在于它的创新 「Context 模块」，让高噪声环境下的语音识别准确率得到了显著提升，幻觉率从 78.5% 大幅降低至 10.7%，降幅近乎 70%。这一技术突破为语音识别行业树立了新的标杆，尤其适用于嘈杂的场合，如会议、公共场所等。&lt;/p&gt; 
&lt;p&gt;FunAudio-ASR 模型在训练过程中使用了数千万小时的音频数据，并将大语言模型的语义理解能力融入其中，使其在远场、嘈杂和多说话人等复杂条件下的表现，已经超越了诸如 Seed-ASR、KimiAudio-8B 等众多主流语音识别系统。通过这一技术的应用，用户在进行语音识别时，能够享受到更清晰、更精准的识别效果。&lt;/p&gt; 
&lt;p&gt;&lt;img height="362" src="https://oscimg.oschina.net/oscnet/up-29ceac6995b94410187f31d4aaa6288579d.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了完整版本外，阿里还推出了轻量化版本 FunAudio-ASR-nano。该版本在保持高识别准确率的同时，降低了推理成本，适合那些对资源要求较高的部署环境。无论是大企业还是小型团队，都能找到适合自己的解决方案。&lt;/p&gt; 
&lt;p&gt;&lt;img height="202" src="https://oscimg.oschina.net/oscnet/up-b13a7f60c07f8b458e99b254fcfe6ec0b29.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前，FunAudio-ASR 已经在钉钉的 「AI 听记」 功能、视频会议以及 DingTalk A1 硬件中得到了实际应用。此外，其 API 也已在阿里云百炼平台上正式上线，方便开发者进行集成和使用。对于企业用户而言，这意味着他们可以利用这一先进技术提升会议效率，增强沟通效果。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372731</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372731</guid>
      <pubDate>Sun, 14 Sep 2025 06:14:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Java 25 的新特性</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&amp;gt;Java 语言特性系列&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417288" target="_blank"&gt;Java5 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417536" target="_blank"&gt;Java6 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417830" target="_blank"&gt;Java7 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004419611" target="_blank"&gt;Java8 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIsm1CvP9swYtkQzH_EYQ4A" target="_blank"&gt;Java9 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FMUyTbO2M68-TfCt1CFTHHA" target="_blank"&gt;Java10 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFBoIM3eP-iqhquizlOETYw" target="_blank"&gt;Java11 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FoXMNQcy7mi_GaZEdm6l8Yw" target="_blank"&gt;Java12 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrN8RYiN-mKnju1riM2yKuA" target="_blank"&gt;Java13 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQjs4MiT0MRTj5QkeNNB66A" target="_blank"&gt;Java14 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBO7fYDQjK_00CGZJ8JQGjA" target="_blank"&gt;Java15 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhVRTYsiKPU8Nz_mbzSTU0Q" target="_blank"&gt;Java16 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3FZOUqZcFqd-1n1NSooERA" target="_blank"&gt;Java17 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fanrq5HzNW5FCvnSv2cyiEg" target="_blank"&gt;Java18 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUS9on700dYcZOfO2JX8-qA" target="_blank"&gt;Java19 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FCmpz2KCyW9HyOpz_I9Zkww" target="_blank"&gt;Java20 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FuuXx5e1XuAaTECaXCUf-rg" target="_blank"&gt;Java21 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQBy-xWcYOCvx8e7540Y-RA" target="_blank"&gt;Java22 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Ftc5t_OgsspUMBjMpbX9X6Q" target="_blank"&gt;Java23 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FvAzN3WueWUSJQ5Q69kBFkQ" target="_blank"&gt;Java24 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfaMVnVP5Hwyil2-qmGCv7A" target="_blank"&gt;Java25 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://my.oschina.net/go4it/blog/%60%E5%BE%85%E8%A1%A5%E5%85%85%60"&gt;Java26 的新特性&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;序&lt;/h1&gt; 
&lt;p&gt;本文主要讲述一下 Java25 的新特性&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;版本号&lt;/h1&gt; 
&lt;pre&gt;&lt;code&gt;openjdk version "25" 2025-09-16
OpenJDK Runtime Environment (build 25+36-3489)
OpenJDK 64-Bit Server VM (build 25+36-3489, mixed mode, sharing)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;从 version 信息可以看出是 build 25+36&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;特性列表&lt;/h1&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F470" target="_blank"&gt;JEP 470: PEM Encodings of Cryptographic Objects (Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性为 Java 平台引入了一套简洁、易用且线程安全的 API(Preview 版本)，用于在 PEM（Privacy-Enhanced Mail）文本与各类密码学对象（密钥、证书、CRL 等）之间进行双向转换，解决开发者长期需要手写解析/格式化逻辑的痛点。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;DEREncodable 标记接口，统一标识可参与 PEM 编解码的已有类型： AsymmetricKey、X509Certificate、X509CRL、KeyPair、EncryptedPrivateKeyInfo、PKCS8EncodedKeySpec、X509EncodedKeySpec 以及新引入的 PEMRecord。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;PEMEncoder / PEMDecoder 不可变、可复用、线程安全。 支持直接编解码字符串或字节流，提供 encode(DerEncodable) / decode(String/InputStream) 等便捷方法。 通过 withEncryption(char[] password) / withDecryption(...) 一键加解密私钥；默认算法可在安全属性文件中配置（当前为 PBEWithHmacSHA256AndAES_128）。 通过 withFactory(Provider) 可指定特定加密提供者。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;PEMRecord 记录类，用于处理平台暂无对应 API 的 PEM 类型（如 PKCS#10 请求）或需要保留 PEM 首部前导数据的场景。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;EncryptedPrivateKeyInfo 增强，新增静态工厂方法 encryptKey(...) 与实例方法 getKey(...)，方便先加密成 EncryptedPrivateKeyInfo 再编码为 PEM，或解码后直接解密拿到 PrivateKey。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PEMEncoding {
    public static void main() throws NoSuchAlgorithmException {
        // Enable preview features: --enable-preview --release 25

        // 1. Generate an EC key pair
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC");
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // 2. Encode public key to PEM
        String publicKeyPEM = PEMEncoder.of()
                .encodeToString(keyPair.getPublic());
        System.out.println("Public Key PEM:\n" + publicKeyPEM);

        // 3. Encode a private key to encrypted PEM
        char[] password = "secret".toCharArray();
        String privateKeyPEM = PEMEncoder.of()
                .withEncryption(password)
                .encodeToString(keyPair.getPrivate());
        System.out.println("Encrypted Private Key PEM:\n" + privateKeyPEM);

        // 4. Decode a public key
        PublicKey decodedPubKey = PEMDecoder.of()
                .decode(publicKeyPEM, PublicKey.class);
        System.out.println("Decoded Public Key Algo: " + decodedPubKey.getAlgorithm());

        // 5. Decode encrypted private key
        PrivateKey decodedPrivateKey = PEMDecoder.of()
                .withDecryption(password)
                .decode(privateKeyPEM, PrivateKey.class);
        System.out.println("Decoded Private Key Algo: " + decodedPrivateKey.getAlgorithm());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;编译及运行&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;javac --release 25 --enable-preview PEMEncoding.java
java  --enable-preview PEMEncoding
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F502" target="_blank"&gt;JEP 502: Stable Values (Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了一种名为 Stable Values（稳定值） 的 API，用于支持延迟初始化的不可变数据持有者对象。这一特性在 JDK 25 中以预览功能形式提供，旨在提升 Java 应用的启动性能与并发安全性，同时保留 final 字段的优化能力（如常量折叠）。 Stable Values 填补了 final 字段与可变字段之间的空白，在保持不可变性和线程安全的同时，支持按需初始化，特别适用于启动时需要延迟加载资源的大型应用场景。&lt;/p&gt; 
&lt;p&gt;使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class OrderController {

    // OLD:
    // private Logger logger = null;

    // NEW:
    private final StableValue&amp;lt;logger&amp;gt; logger = StableValue.of();

    Logger getLogger() {
        return logger.orElseSet(() -&amp;amp;gt; Logger.create(OrderController.class));
    }

    void submitOrder(User user, List&amp;lt;product&amp;gt; products) {
        getLogger().info("order started");
        ...
        getLogger().info("order submitted");
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;由于是预览版本，所以需要&lt;code&gt;--enable-preview&lt;/code&gt;启用&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;javac --release 25 --enable-preview Main.java
java --enable-preview Main
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F503" target="_blank"&gt;JEP 503: Remove the 32-bit x86 Port&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F449" target="_blank"&gt;JEP 449: Deprecate the Windows 32-bit x86 Port for Removal&lt;/a&gt;已经废弃了对 Windows 32 位 x86 的移植，在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F479" target="_blank"&gt;JEP 479: Remove the Windows 32-bit x86 Port&lt;/a&gt;删除了相关源代码、移除了对 windows 32 位相关构建支持，在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F501" target="_blank"&gt;JEP 501: Deprecate the 32-bit x86 Port for Removal&lt;/a&gt;废弃了对 32 位 x86 的移植，但是可以通过&lt;code&gt;--enable-deprecated-ports=yes&lt;/code&gt;来启用构建，在 JDK25Z 则删除了相关源代码、移除了相关构建支持&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F505" target="_blank"&gt;JEP 505: Structured Concurrency (Fifth Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F428" target="_blank"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;作为第一次 incubator &amp;gt;JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F437" target="_blank"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;作为第二次 incubator &amp;gt;JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F453" target="_blank"&gt;JEP 453: Structured Concurrency (Preview)&lt;/a&gt;作为首次 preview &amp;gt;JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F462" target="_blank"&gt;JEP 462: Structured Concurrency (Second Preview)&lt;/a&gt;作为第二次 preview &amp;gt;JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F480" target="_blank"&gt;JEP 480: Structured Concurrency (Third Preview)&lt;/a&gt;作为第三次 preview &amp;gt;JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F499" target="_blank"&gt;JEP 499: Structured Concurrency (Fourth Preview)&lt;/a&gt;作为第四次 preview &amp;gt;JDK25 作为第五次 preview&lt;/p&gt; 
&lt;p&gt;使用示例如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Response handle() throws InterruptedException {

    try (var scope = StructuredTaskScope.open()) {

        Subtask&amp;lt;string&amp;gt; user = scope.fork(() -&amp;amp;gt; findUser());
        Subtask&amp;lt;integer&amp;gt; order = scope.fork(() -&amp;amp;gt; fetchOrder());

        scope.join();   // Join subtasks, propagating exceptions

        // Both subtasks have succeeded, so compose their results
        return new Response(user.get(), order.get());

    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F506" target="_blank"&gt;JEP 506: Scoped Values&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F428" target="_blank"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;作为第一次 incubator JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F437" target="_blank"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;作为第二次 incubator JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F453" target="_blank"&gt;JEP 453: Structured Concurrency (Preview)&lt;/a&gt;作为首次 preview JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F462" target="_blank"&gt;JEP 462: Structured Concurrency (Second Preview)&lt;/a&gt;作为第二次 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F480" target="_blank"&gt;JEP 480: Structured Concurrency (Third Preview)&lt;/a&gt;作为第三次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F487" target="_blank"&gt;JEP 487: Scoped Values (Fourth Preview)&lt;/a&gt;作为第四次 preview，与 JDK23 不同的是 callWhere 以及 runWhere 方法从 ScopedValue 类中移除，可以使用 ScopedValue.where() 再链式调用 run(Runnable) 或者 call(Callable)&lt;/p&gt; 
&lt;p&gt;JDK25 作为第五次 preview，有个改动就是 ScopedValue.orElse 方法不再接受 null 作为参数&lt;/p&gt; 
&lt;p&gt;示例：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class Framework {

    private static final ScopedValue&amp;lt;frameworkcontext&amp;gt; CONTEXT
                        = ScopedValue.newInstance();    // (1)

    void serve(Request request, Response response) {
        var context = createContext(request);
        where(CONTEXT, context)                         // (2)
                   .run(() -&amp;amp;gt; Application.handle(request, response));
    }
    
    public PersistedObject readKey(String key) {
        var context = CONTEXT.get();                    // (3)
        var db = getDBConnection(context);
        db.readKey(key);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;在 (1) 中，框架声明了一个作用域值，而不是一个 thread local 变量。在 (2)，serve 方法调用 where ... run 而不是 thread local 的 set 方法。run 方法提供了数据的单向共享 serve 方法到 readKey 方法。(3) 读取的值是由 Framework.serve 的时候写入的。&lt;/p&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F507" target="_blank"&gt;JEP 507: Primitive Types in Patterns, instanceof, and switch (Third Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F405" target="_blank"&gt;JEP 405: Record Patterns (Preview)&lt;/a&gt;将 Record 的模式匹配作为第一次 preview JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F432" target="_blank"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt;作为 Record 模式匹配第二次 preview JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F440" target="_blank"&gt;JEP 440: Record Patterns&lt;/a&gt;则将 Record 模式匹配正式发布 JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F455" target="_blank"&gt;JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview)&lt;/a&gt;将原始类型的匹配作为第一次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F488" target="_blank"&gt;JEP 488: Primitive Types in Patterns, instanceof, and switch (Second Preview)&lt;/a&gt;作为第二次 preview JDK25 作为第三次 preview&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;record Point(int x, int y) {}

// As of Java 21
static void printSum(Object obj) {
    if (obj instanceof Point(int x, int y)) {
        System.out.println(x+y);
    }
}

enum Color { RED, GREEN, BLUE }
record ColoredPoint(Point p, Color c) {}
record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}
// As of Java 21
static void printUpperLeftColoredPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint ul, ColoredPoint lr)) {
         System.out.println(ul.c());
    }
}

static void printColorOfUpperLeftPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),
                               ColoredPoint lr)) {
        System.out.println(c);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;但是这个只是支持 Record 类型&lt;/p&gt; 
&lt;p&gt;在 JDK14&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F305" target="_blank"&gt;JEP 305: Pattern Matching for instanceof (Preview)&lt;/a&gt;作为 preview 在 JDK15&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F375" target="_blank"&gt;JEP 375: Pattern Matching for instanceof (Second Preview)&lt;/a&gt;作为第二轮的 preview 在 JDK16&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F394" target="_blank"&gt;JEP 394: Pattern Matching for instanceof&lt;/a&gt;转正 JDK17 引入&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F406" target="_blank"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt; JDK18 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F420" target="_blank"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt;则作为第二轮 preview JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F427" target="_blank"&gt;JEP 427: Pattern Matching for switch (Third Preview)&lt;/a&gt;作为第三轮 preview JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F433" target="_blank"&gt;JEP 433: Pattern Matching for switch (Fourth Preview)&lt;/a&gt;作为第四轮 preview JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F441" target="_blank"&gt;JEP 441: Pattern Matching for switch&lt;/a&gt;将 Pattern Matching for switch 作为正式版本发布，示例如下&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// Prior to Java 21
static String formatter(Object obj) {
    String formatted = "unknown";
    if (obj instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (obj instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (obj instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (obj instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}

// As of Java 21
static String formatterPatternSwitch(Object obj) {
    return switch (obj) {
        case Integer i -&amp;amp;gt; String.format("int %d", i);
        case Long l    -&amp;amp;gt; String.format("long %d", l);
        case Double d  -&amp;amp;gt; String.format("double %f", d);
        case String s  -&amp;amp;gt; String.format("String %s", s);
        default        -&amp;amp;gt; obj.toString();
    };
}

// As of Java 21
static void testFooBarNew(String s) {
    switch (s) {
        case null         -&amp;amp;gt; System.out.println("Oops");
        case "Foo", "Bar" -&amp;amp;gt; System.out.println("Great");
        default           -&amp;amp;gt; System.out.println("Ok");
    }
}

// As of Java 21
static void testStringEnhanced(String response) {
    switch (response) {
        case null -&amp;amp;gt; { }
        case "y", "Y" -&amp;amp;gt; {
            System.out.println("You got it");
        }
        case "n", "N" -&amp;amp;gt; {
            System.out.println("Shame");
        }
        case String s
        when s.equalsIgnoreCase("YES") -&amp;amp;gt; {
            System.out.println("You got it");
        }
        case String s
        when s.equalsIgnoreCase("NO") -&amp;amp;gt; {
            System.out.println("Shame");
        }
        case String s -&amp;amp;gt; {
            System.out.println("Sorry?");
        }
    }
}

// As of Java 21
static void exhaustiveSwitchWithBetterEnumSupport(CardClassification c) {
    switch (c) {
        case Suit.CLUBS -&amp;amp;gt; {
            System.out.println("It's clubs");
        }
        case Suit.DIAMONDS -&amp;amp;gt; {
            System.out.println("It's diamonds");
        }
        case Suit.HEARTS -&amp;amp;gt; {
            System.out.println("It's hearts");
        }
        case Suit.SPADES -&amp;amp;gt; {
            System.out.println("It's spades");
        }
        case Tarot t -&amp;amp;gt; {
            System.out.println("It's a tarot");
        }
    }
}

// As of Java 21
sealed interface Currency permits Coin {}
enum Coin implements Currency { HEADS, TAILS } 

static void goodEnumSwitch1(Currency c) {
    switch (c) {
        case Coin.HEADS -&amp;amp;gt; {    // Qualified name of enum constant as a label
            System.out.println("Heads");
        }
        case Coin.TAILS -&amp;amp;gt; {
            System.out.println("Tails");
        }
    }
}

static void goodEnumSwitch2(Coin c) {
    switch (c) {
        case HEADS -&amp;amp;gt; {
            System.out.println("Heads");
        }
        case Coin.TAILS -&amp;amp;gt; {    // Unnecessary qualification but allowed
            System.out.println("Tails");
        }
    }
}

// As of Java 21
static void testNew(Object obj) {
    switch (obj) {
        case String s when s.length() == 1 -&amp;amp;gt; ...
        case String s                      -&amp;amp;gt; ...
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;但是 JDK21 还不支持原始类型的匹配&lt;/p&gt; 
&lt;p&gt;而支持原始类型的匹配使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;switch (x.getStatus()) {
    case 0 -&amp;amp;gt; "okay";
    case 1 -&amp;amp;gt; "warning";
    case 2 -&amp;amp;gt; "error";
    default -&amp;amp;gt; "unknown status: " + x.getStatus();
}

switch (x.getStatus()) {
    case 0 -&amp;amp;gt; "okay";
    case 1 -&amp;amp;gt; "warning";
    case 2 -&amp;amp;gt; "error";
    case int i -&amp;amp;gt; "unknown status: " + i;
}

switch (x.getYearlyFlights()) {
    case 0 -&amp;amp;gt; ...;
    case 1 -&amp;amp;gt; ...;
    case 2 -&amp;amp;gt; issueDiscount();
    case int i when i &amp;amp;gt;= 100 -&amp;amp;gt; issueGoldCard();
    case int i -&amp;amp;gt; ... appropriate action when i &amp;amp;gt; 2 &amp;amp;amp;&amp;amp;amp; i &amp;amp;lt; 100 ...
}

long v = ...;
switch (v) {
    case 1L              -&amp;amp;gt; ...;
    case 2L              -&amp;amp;gt; ...;
    case 10_000_000_000L -&amp;amp;gt; ...;
    case 20_000_000_000L -&amp;amp;gt; ...;
    case long x          -&amp;amp;gt; ... x ...;
}

if (roomSize instanceof byte) { // check if value of roomSize fits in a byte
    ... (byte) roomSize ... // yes, it fits! but cast is required
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;另外针对 instanceof 示例如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;byte b = 42;
b instanceof int;         // true (unconditionally exact)

int i = 42;
i instanceof byte;        // true (exact)

int i = 1000;
i instanceof byte;        // false (not exact)

int i = 16_777_217;       // 2^24 + 1
i instanceof float;       // false (not exact)
i instanceof double;      // true (unconditionally exact)
i instanceof Integer;     // true (unconditionally exact)
i instanceof Number;      // true (unconditionally exact)

float f = 1000.0f;
f instanceof byte;        // false
f instanceof int;         // true (exact)
f instanceof double;      // true (unconditionally exact)

double d = 1000.0d;
d instanceof byte;        // false
d instanceof int;         // true (exact)
d instanceof float;       // true (exact)

Integer ii = 1000;
ii instanceof int;        // true (exact)
ii instanceof float;      // true (exact)
ii instanceof double;     // true (exact)

Integer ii = 16_777_217;
ii instanceof float;      // false (not exact)
ii instanceof double;     // true (exact)
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F508" target="_blank"&gt;JEP 508: Vector API (Tenth Incubator)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK16 引入了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F338" target="_blank"&gt;JEP 338: Vector API (Incubator)&lt;/a&gt;提供了 jdk.incubator.vector 来用于矢量计算 JDK17 进行改进并作为第二轮的 incubator&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F414" target="_blank"&gt;JEP 414: Vector API (Second Incubator)&lt;/a&gt; JDK18 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F417" target="_blank"&gt;JEP 417: Vector API (Third Incubator)&lt;/a&gt;进行改进并作为第三轮的 incubator JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F426" target="_blank"&gt;JEP 426:Vector API (Fourth Incubator)&lt;/a&gt;作为第四轮的 incubator JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F438" target="_blank"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;作为第五轮的 incubator JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F448" target="_blank"&gt;JEP 448: Vector API (Sixth Incubator)&lt;/a&gt;作为第六轮的 incubator JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F460" target="_blank"&gt;JEP 460: Vector API (Seventh Incubator)&lt;/a&gt;作为第七轮的 incubator JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F469" target="_blank"&gt;JEP 469: Vector API (Eighth Incubator)&lt;/a&gt;作为第八轮 incubator JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F489" target="_blank"&gt;JEP 489: Vector API (Ninth Incubator)&lt;/a&gt;则作为第九轮 incubator，与 JDK23 相比做了一些变动：比如引入了一个新的基于值的类 Float16，用于表示 IEEE 754 二进制 16 格式的 16 位浮点数。&lt;/p&gt; 
&lt;p&gt;JDK25 作为第十轮 incubator，主要变化是：VectorShuffle 现在支持访问和访问 MemorySegment，该实现是通过 Foreign Function &amp;amp; Memory API (JEP 454) 而不是通过 HotSpot 内部的 C++代码，提高了可维护性，另外对 Float16 值的加法、减法、除法、乘法、平方根和 fused 乘法/加法运算现在支持 x64 cpu 自动矢量化&lt;/p&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F509" target="_blank"&gt;JEP 509: JFR CPU-Time Profiling (Experimental)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了实验版的 CPU-Time Profiling，可以捕获更准确的 CPU 时间分析信息，使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true,filename=profile.jfr ...
$ jfr view cpu-time-hot-methods profile.jfr
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;配合 jcmd 使用如下&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;jcmd &amp;lt;pid&amp;gt; JFR.start settings=/tmp/cpu_profile.jfc duration=4m
jcmd &amp;lt;pid&amp;gt; JFR.stop
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F510" target="_blank"&gt;JEP 510: Key Derivation Function API&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK 21 中包含的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F452" target="_blank"&gt;KEM API（JEP 452）&lt;/a&gt;是 HPKE 的一个组成部分，标志着 Java 朝着 HPKE 迈出的第一步，并为后量子挑战做好了准备。 在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F478" target="_blank"&gt;JEP 478: Key Derivation Function API (Preview)&lt;/a&gt;中提出了 HPKE 的另一个组成部分，作为这一方向上的下一步：密钥派生函数（KDFs）的 API，作为预览版本，在 JDK25 转为正式版，无需&lt;code&gt;--enable-preview&lt;/code&gt;参数&lt;/p&gt; 
&lt;p&gt;使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// Create a KDF object for the specified algorithm
KDF hkdf = KDF.getInstance("HKDF-SHA256"); 

// Create an ExtractExpand parameter specification
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

// Derive a 32-byte AES key
SecretKey key = hkdf.deriveKey("AES", params);

// Additional deriveKey calls can be made with the same KDF object
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F511" target="_blank"&gt;JEP 511: Module Import Declarations&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;gt;与&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F477" target="_blank"&gt;JEP 477: Implicitly Declared Classes and Instance Main Methods (Third Preview)&lt;/a&gt;类似，本特性主要是为了简化语法方便新手使用，通过新引入 module 的 import，来一次性导入 module 下所有 package 底下的类&lt;/p&gt; 
&lt;p&gt;JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F476" target="_blank"&gt;JEP 476: Module Import Declarations (Preview)&lt;/a&gt;作为第一个 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F494" target="_blank"&gt;JEP 494: Module Import Declarations (Second Preview)&lt;/a&gt;作为第二次 preview，与 JDK23 不同的是取消了模块不允许声明对 java.base 模块传递依赖的限制，并修订了 java.se 模块声明，使其传递性地依赖于 java.base 模块。这些变化意味着导入 java.se 模块将按需导入整个 Java SE API。此外，现在允许按需声明的类型导入声明复盖模块导入声明。 JDK25 作为正式版，没有变化&lt;/p&gt; 
&lt;p&gt;示例:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import module java.base;  // 包含了 import java.io.*; import java.util.*;

import module java.base;      // exports java.util, which has a public Date class
import module java.sql;       // exports java.sql, which has a public Date class

import java.sql.Date;         // resolve the ambiguity of the simple name Date!

...
Date d = ...                  // Ok!  Date is resolved to java.sql.Date
...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;由于是正式版，不再需要使用&lt;code&gt;--enable-preview&lt;/code&gt;参数来开启&lt;/p&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F512" target="_blank"&gt;JEP 512: Compact Source Files and Instance Main Methods&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F445" target="_blank"&gt;JEP 445: Unnamed Classes and Instance Main Methods (Preview)&lt;/a&gt;作为首次 preview，引入了未命名的类和实例 main 方法特性可以简化 hello world 示例，方便 java 新手入门 JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F463" target="_blank"&gt;JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview)&lt;/a&gt;作为第二次的 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F477" target="_blank"&gt;JEP 477: Implicitly Declared Classes and Instance Main Methods (Third Preview)&lt;/a&gt;作为第三次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F495" target="_blank"&gt;JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)&lt;/a&gt;则作为第四次 preview JDK25 作为正式版本，有些改动：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;console I/O 的新 IO 类现在位于 java.lang，而不是 java.io 包，现在隐式导入到每个源文件&lt;/li&gt; 
 &lt;li&gt;IO 类的静态方法不再隐式导入 compact source files，需要显示导入&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxn--IOSystem-k20m619e5ejyy6e4xh1wv.xn--outSystem-dc8o.in" target="_blank"&gt;IO 类的实现基于 System.out 及 System.in&lt;/a&gt;，而非 java.io.Console 类&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;void main() {
    String name = IO.readln("Please enter your name: ");
    IO.print("Pleased to meet you, ");
    IO.println(name);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F513" target="_blank"&gt;JEP 513: Flexible Constructor Bodies&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F447" target="_blank"&gt;JEP 447: Statements before super(...) (Preview)&lt;/a&gt;作为第一次 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F482" target="_blank"&gt;JEP 482: Flexible Constructor Bodies (Second Preview)&lt;/a&gt;作为第二次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F492" target="_blank"&gt;JEP 492: Flexible Constructor Bodies (Third Preview)&lt;/a&gt;作为第三次 preview JDK25 作为正式版本，没有变化&lt;/p&gt; 
&lt;p&gt;比如在 JEP 447 之前的代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PositiveBigInteger extends BigInteger {

    public PositiveBigInteger(long value) {
        super(value);               // Potentially unnecessary work
        if (value &amp;amp;lt;= 0)
            throw new IllegalArgumentException(non-positive value);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在 JEP 447 之后代码可以如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PositiveBigInteger extends BigInteger {

    public PositiveBigInteger(long value) {
        if (value &amp;amp;lt;= 0)
            throw new IllegalArgumentException(non-positive value);
        super(value);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F514" target="_blank"&gt;JEP 514: Ahead-of-Time Command-Line Ergonomics&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F483" target="_blank"&gt;JEP 483: Ahead-of-Time Class Loading &amp;amp; Linking&lt;/a&gt;支持了通过 Ahead-of-Time Cache 来存储已经读取、解析、加载和链接的类，在 JDK25 则通过简化常见用例所需的命令来加速 java 应用程序的启动。&lt;/p&gt; 
&lt;p&gt;在 JDK24 时分两步创建 AOT 缓存：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先运行 application 来记录 AOT 配置:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;接着使用该配置来创建 AOT 缓存：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf -XX:AOTCache=app.aot -cp app.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;最后使用 AOT 缓存启动：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;AOT 缓存将读取、解析、加载和链接（通常在程序执行期间即时完成）的任务提前到缓存创建的早期阶段。因此，在执行阶段，程序启动速度更快，因为其类可以从缓存中快速访问。其性能提升可以高达 42%。 &amp;gt;但是需要运行 2 次来创建 AOT 缓存。留下 AOT 配置文件也很不方便，它只是一个临时文件，生产运行不需要，可以删除。&lt;/p&gt; 
&lt;p&gt;JDK25 通过引入&lt;code&gt;AOTCacheOutput&lt;/code&gt;将两步合为一步，它实际上将其调用拆分为两个子调用: 第一个执行训练运行 (AOTMode=record)，然后第二个创建 AOT 缓存 (AOTMode=create)，可以通过新的环境变量 JDK_AOT_VM_OPTIONS 来覆盖传递给 cache create 这个子过程的 VM 命令。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;当以这种方式操作时，JVM 为 AOT 配置创建临时文件，并在完成时删除该文件。&lt;/p&gt; 
&lt;p&gt;使用的时候一样：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_17"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F515" target="_blank"&gt;JEP 515: Ahead-of-Time Method Profiling&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F483" target="_blank"&gt;JEP 483: Ahead-of-Time Class Loading &amp;amp; Linking&lt;/a&gt;支持了通过 Ahead-of-Time Cache 来存储已经读取、解析、加载和链接的类 JVM 可以识别执行最频繁或消耗最多 CPU 时间的代码，并通过将其编译为本机代码来优化此代码。此过程称为分析。简单来说，配置文件是与方法相关的有用信息的集合，例如已执行的次数。当应用程序以通常的方式 (没有 AOT 缓存) 运行时，这些配置文件在应用程序执行开始时收集。这个 JEP 背后的概念是，我们可以在训练运行期间收集配置文件，然后在后续运行中重复使用它们。这意味着在以后的执行中，无需在启动后收集配置文件，从而可以立即开始代码编译。训练运行的质量会显着影响应用程序预热时间的改善。训练跑得越好，在随后的跑中获得的性能增强就越大。 本特性将生产环境做的 Method Profiling 挪到了 Ahead-of-Time Cache 阶段，使得生产环境启动的时候就读取这些数据，JIT 立即对真正的热点方法进行编译，无需边跑边收集。&lt;/p&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F518" target="_blank"&gt;JEP 518: JFR Cooperative Sampling&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性提高 JFR 异步采样 Java 线程堆栈时的稳定性，通过仅在安全点处遍历调用堆栈来实现此目的，同时最大程度地减少安全点偏差。&lt;/p&gt; 
&lt;span id="OSC_h2_19"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F519" target="_blank"&gt;JEP 519: Compact Object Headers&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F450" target="_blank"&gt;JEP 450: Compact Object Headers (Experimental)&lt;/a&gt;特性中，在 64 位架构上，将 HotSpot JVM 中的对象标头大小从 96 到 128 位减少到 64 位。在 SPECjbb2015 的测试中减少了 22% 的堆空间和 8% 的 CPU 时间，完成的垃圾收集数量为减少 15%，一个高度并行的 JSON 解析器基准运行时间减少 10%。 在 JDK25 转为正式版，无需&lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;命令&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-XX:+UseCompactObjectHeaders
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_20"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F520" target="_blank"&gt;JEP 520: JFR Method Timing &amp;amp; Tracing&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了两个新的 JFR 事件，jdk.MethodTiming 和 jdk.MethodTrace，通过字节码织入来追踪方法，使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ java -XX:StartFlightRecording:jdk.MethodTrace#filter=java.util.HashMap::resize,filename=recording.jfr ...
$ jfr print --events jdk.MethodTrace --stack-depth 20 recording.jfr
jdk.MethodTrace {
    startTime = 00:39:26.379 (2025-03-05)
    duration = 0.00113 ms
    method = java.util.HashMap.resize()
    eventThread = "main" (javaThreadId = 3)
    stackTrace = [
      java.util.HashMap.putVal(int, Object, Object, boolean, boolean) line: 636
      java.util.HashMap.put(Object, Object) line: 619
      sun.awt.AppContext.put(Object, Object) line: 598
      sun.awt.AppContext.&amp;lt;init&amp;gt;(ThreadGroup) line: 240
      sun.awt.SunToolkit.createNewAppContext(ThreadGroup) line: 282
      sun.awt.AppContext.initMainAppContext() line: 260
      sun.awt.AppContext.getAppContext() line: 295
      sun.awt.SunToolkit.getSystemEventQueueImplPP() line: 1024
      sun.awt.SunToolkit.getSystemEventQueueImpl() line: 1019
      java.awt.Toolkit.getEventQueue() line: 1375
      java.awt.EventQueue.invokeLater(Runnable) line: 1257
      javax.swing.SwingUtilities.invokeLater(Runnable) line: 1415
      java2d.J2Ddemo.main(String[]) line: 674
    ]
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_21"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F521" target="_blank"&gt;JEP 521: Generational Shenandoah&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F404" target="_blank"&gt;JEP 404: Generational Shenandoah (Experimental)&lt;/a&gt;提供了一个实验性的分代模式，与其他分代收集器一样分为年轻代和年老代，在 JDK25 转为正式版本，不再需要&lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;命令&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h1_22"&gt;&lt;/span&gt; 
&lt;h1&gt;细项解读&lt;/h1&gt; 
&lt;p&gt;上面列出的是大方面的特性，除此之外还有一些 api 的更新及废弃，主要见&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2F25%2Frelease-notes" target="_blank"&gt;JDK 25 Release Notes&lt;/a&gt;，这里举几个例子。&lt;/p&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt; 
&lt;h2&gt;添加项&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Support for reading all remaining characters from a Reader (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8354724" target="_blank"&gt;JDK-8354724&lt;/a&gt;) &amp;gt;java.io.Reader 新增了方法 readAllAsString 可以读取剩余字符到 String，新增 readAllLines 读取剩余字符到&lt;code&gt;List&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;New connectionLabel Method in java.net.http.HttpResponse to Identify Connections (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350279" target="_blank"&gt;JDK-8350279&lt;/a&gt;) &amp;gt;对 HttpResponse 新增了 connectionLabel 方法用于关联 connection&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;New Property to Construct ZIP FileSystem as Read-only (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350880" target="_blank"&gt;JDK-8350880&lt;/a&gt;) &amp;gt;新增 readOnly 支持 FileSystems.newFileSystem(pathToZipFile, Map.of("accessMode","readOnly"))&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Updates to ForkJoinPool and CompletableFuture (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8319447" target="_blank"&gt;JDK-8319447&lt;/a&gt;) &amp;gt;ForkJoinPool 做了更新以实现 ScheduledExecutorService，新增了 submitWithTimeout 方法支持 timeout 参数&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Thread Dumps Generated by HotSpotDiagnosticMXBean.dumpThreads and jcmd Thread.dump_to_file Updated to Include Lock Information (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8356870" target="_blank"&gt;JDK-8356870&lt;/a&gt;) &amp;gt;com.sun.management.HotSpotDiagnosticMXBean.dumpThreads 以及 jcmd &amp;lt;pid&amp;gt; Thread.dump_to_file 生成的线程堆栈现在包含了锁信息&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;G1 Reduces Remembered Set Overhead by Grouping Regions into Shared Card Sets (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8343782" target="_blank"&gt;JDK-8343782&lt;/a&gt;) &amp;gt;以前每个 Region 都维护自己的 G1CardSet，导致内存占用高，新设计在 Remark 阶段之后，把预计会一起被清空的 Region 归为一组，并分配同一个共享的 G1CardSet，省去了它们之间逐一跟踪引用的开销。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_24"&gt;&lt;/span&gt; 
&lt;h2&gt;移除项&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;java.net.Socket Constructors Can No Longer Be Used to Create a Datagram Socket (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8356154" target="_blank"&gt;JDK-8356154&lt;/a&gt;) &amp;gt;java.net.Socket 废弃了两个构造器，不再支持创建 datagram sockets，需要改为 java.net.DatagramSocket 替代&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Removal of PerfData Sampling (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8241678" target="_blank"&gt;JDK-8241678&lt;/a&gt;) &amp;gt;-XX:PerfDataSamplingInterval 这个被移除了&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_25"&gt;&lt;/span&gt; 
&lt;h2&gt;废弃项&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Deprecate the Use of java.locale.useOldISOCodes System Property (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8353118" target="_blank"&gt;JDK-8353118&lt;/a&gt;) &amp;gt;java.locale.useOldISOCodes 这个属性被废弃了&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;The UseCompressedClassPointers Option is Deprecated (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350753" target="_blank"&gt;JDK-8350753&lt;/a&gt;) &amp;gt;UseCompressedClassPointers 这个参数被废弃了，接下来将默认开启压缩类指针&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Various Permission Classes Deprecated for Removal (JDK-8348967, JDK-8353641, JDK-8353642, JDK-8353856, JDK-8347985, JDK-8351224, JDK-8351310) 以下这些 Permission 相关的类被标记废弃&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java.security.UnresolvedPermission
javax.net.ssl.SSLPermission
javax.security.auth.AuthPermission
javax.security.auth.PrivateCredentialPermission
javax.security.auth.kerberos.DelegationPermission
javax.security.auth.kerberos.ServicePermission
com.sun.security.jgss.InquireSecContextPermission
java.lang.RuntimePermission
java.lang.reflect.ReflectPermission
java.io.FilePermission
java.io.SerializablePermission
java.nio.file.LinkPermission
java.util.logging.LoggingPermission
java.util.PropertyPermission
jdk.jfr.FlightRecorderPermission
java.net.NetPermission
java.net.URLPermission
jdk.net.NetworkPermission
com.sun.tools.attach.AttachPermission
com.sun.jdi.JDIPermission
java.lang.management.ManagementPermission
javax.management.MBeanPermission
javax.management.MBeanTrustPermission
javax.management.MBeanServerPermission
javax.management.remote.SubjectDelegationPermission
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_26"&gt;&lt;/span&gt; 
&lt;h2&gt;已知问题修复&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;ZGC Now Avoids String Deduplication for Short-Lived Strings (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8347337" target="_blank"&gt;JDK-8347337&lt;/a&gt;) &amp;gt;ZGC 将避免对一些生命周期短的 String 进行 Deduplication，避免不必要的开销&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;G1 Reduces Pause Time Spikes by Improving Region Selection (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8351405" target="_blank"&gt;JDK-8351405&lt;/a&gt;) &amp;gt;G1 在 Mixed GC 的时候会引起 pause time 飙升，此次通过 region 选择进行了优化&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;No More OutOfMemoryErrors Due to JNI in Serial/Parallel GC (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8192647" target="_blank"&gt;JDK-8192647&lt;/a&gt;) &amp;gt;修复了 Serial/Parallel GC 因为 JNI 导致的 OOM&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_27"&gt;&lt;/span&gt; 
&lt;h2&gt;已知问题&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Regression in Serialization of LocalDate Class Objects (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8367031" target="_blank"&gt;JDK-8367031&lt;/a&gt;) 在 java.time 包中，若干类的序列化 Class 对象在 JDK 25 与早期版本之间不再兼容。受影响的具体类包括：LocalDate、YearMonth、MonthDay、HijrahDate 兼容性规则：如果把上述某个类的 Class 对象在早期版本序列化，再到 JDK 25 反序列化，或者反向操作，都会抛出 InvalidClassException，例如&lt;code&gt;writeObject(LocalDate.class)&lt;/code&gt; 但如果是序列化实例，则不受影响&lt;code&gt;writeObject(LocalDate.now())&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Performance Regression in java.lang.ClassValue::get (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8358535" target="_blank"&gt;JDK-8358535&lt;/a&gt;) 在 JDK 25 中，为了增强 ClassValue 在各种并发场景下的健壮性，JDK-8351996 对其进行了更新。 然而，这次改动导致：在调用 ClassValue.remove 之后，ClassValue.get 的执行速度明显变慢。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;大多数应用不会直接使用 ClassValue，因此不会感知到这一退化。&lt;/li&gt; 
   &lt;li&gt;但若某个库同时调用 ClassValue.get 与 remove（例如 Scala 2.12 的标准库），就可能受到性能影响。 该性能回退已在 JDK-8358535 中被修复。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;-XX:+UseTransparentHugePages Fails to Enable Huge Pages for G1 (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8366434" target="_blank"&gt;JDK-8366434&lt;/a&gt;) 在把 Transparent Huge Pages（THP）模式设置为 madvise 的系统上， 即使启动参数里加了 -XX:+UseTransparentHugePages，默认垃圾回收器 G1 也不会实际启用大页。临时解决办法：把 THP 模式改成 always，即可让 G1 正常使用 Transparent Huge Pages：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;# echo always &amp;amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;其他事项&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;Disabled SHA-1 in TLS 1.2 and DTLS 1.2 Handshake Signatures (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8340321" target="_blank"&gt;JDK-8340321&lt;/a&gt;)&lt;/li&gt; 
 &lt;li&gt;Compact Object Headers CDS Archive Generation and jlink Instruction (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350457" target="_blank"&gt;JDK-8350457&lt;/a&gt;)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_29"&gt;&lt;/span&gt; 
&lt;h1&gt;小结&lt;/h1&gt; 
&lt;p&gt;Java25 主要有如下几个特性，其中核心库改动有 JEP 502、JEP 505、JEP 506、JEP 508，语言规范类的有 JEP507、JEP 511、JEP 512、JEP 513。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F470" target="_blank"&gt;JEP 470: PEM Encodings of Cryptographic Objects (Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F502" target="_blank"&gt;JEP 502: Stable Values (Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F503" target="_blank"&gt;JEP 503: Remove the 32-bit x86 Port&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F505" target="_blank"&gt;JEP 505: Structured Concurrency (Fifth Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F506" target="_blank"&gt;JEP 506: Scoped Values&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F507" target="_blank"&gt;JEP 507: Primitive Types in Patterns, instanceof, and switch (Third Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F508" target="_blank"&gt;JEP 508: Vector API (Tenth Incubator)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F509" target="_blank"&gt;JEP 509: JFR CPU-Time Profiling (Experimental)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F510" target="_blank"&gt;JEP 510: Key Derivation Function API&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F511" target="_blank"&gt;JEP 511: Module Import Declarations&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F512" target="_blank"&gt;JEP 512: Compact Source Files and Instance Main Methods&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F513" target="_blank"&gt;JEP 513: Flexible Constructor Bodies&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F514" target="_blank"&gt;JEP 514: Ahead-of-Time Command-Line Ergonomics&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F515" target="_blank"&gt;JEP 515: Ahead-of-Time Method Profiling&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F518" target="_blank"&gt;JEP 518: JFR Cooperative Sampling&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F519" target="_blank"&gt;JEP 519: Compact Object Headers&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F520" target="_blank"&gt;JEP 520: JFR Method Timing &amp;amp; Tracing&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F521" target="_blank"&gt;JEP 521: Generational Shenandoah&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;gt;此次发布了 18 个 JEP，整体概括如下： &amp;gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;JEP&lt;/th&gt; 
   &lt;th&gt;Title&lt;/th&gt; 
   &lt;th&gt;Status&lt;/th&gt; 
   &lt;th&gt;Project&lt;/th&gt; 
   &lt;th&gt;Feature Type&lt;/th&gt; 
   &lt;th&gt;Changes since Java 24&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;470&lt;/td&gt; 
   &lt;td&gt;PEM Encodings of Cryptographic Objects&lt;/td&gt; 
   &lt;td&gt;Preview&lt;/td&gt; 
   &lt;td&gt;Security Libs&lt;/td&gt; 
   &lt;td&gt;Security&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;502&lt;/td&gt; 
   &lt;td&gt;Stable Values&lt;/td&gt; 
   &lt;td&gt;Preview&lt;/td&gt; 
   &lt;td&gt;Core Libs&lt;/td&gt; 
   &lt;td&gt;New API&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;503&lt;/td&gt; 
   &lt;td&gt;Remove the 32-bit x86 Port&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot&lt;/td&gt; 
   &lt;td&gt;Deprecation&lt;/td&gt; 
   &lt;td&gt;Removal&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;505&lt;/td&gt; 
   &lt;td&gt;Structured Concurrency&lt;/td&gt; 
   &lt;td&gt;Fifth Preview&lt;/td&gt; 
   &lt;td&gt;Loom&lt;/td&gt; 
   &lt;td&gt;Concurrency&lt;/td&gt; 
   &lt;td&gt;Major&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;506&lt;/td&gt; 
   &lt;td&gt;Scoped Values&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Loom&lt;/td&gt; 
   &lt;td&gt;Concurrency&lt;/td&gt; 
   &lt;td&gt;Minor&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;507&lt;/td&gt; 
   &lt;td&gt;Primitive Types in Patterns, instanceof, and switch&lt;/td&gt; 
   &lt;td&gt;Third Preview&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;508&lt;/td&gt; 
   &lt;td&gt;Vector API&lt;/td&gt; 
   &lt;td&gt;Tenth Incubator&lt;/td&gt; 
   &lt;td&gt;Panama&lt;/td&gt; 
   &lt;td&gt;New API&lt;/td&gt; 
   &lt;td&gt;Minor&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;509&lt;/td&gt; 
   &lt;td&gt;JFR CPU-Time Profiling&lt;/td&gt; 
   &lt;td&gt;Experimental&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;510&lt;/td&gt; 
   &lt;td&gt;Key Derivation Function API&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Security Libs&lt;/td&gt; 
   &lt;td&gt;Security&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;511&lt;/td&gt; 
   &lt;td&gt;Module Import Declarations&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;512&lt;/td&gt; 
   &lt;td&gt;Compact Source Files and Instance Main Methods&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;Major&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;513&lt;/td&gt; 
   &lt;td&gt;Flexible Constructor Bodies&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;514&lt;/td&gt; 
   &lt;td&gt;Ahead-of-Time Command-Line Ergonomics&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Leyden&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;515&lt;/td&gt; 
   &lt;td&gt;Ahead-of-Time Method Profiling&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Leyden&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;518&lt;/td&gt; 
   &lt;td&gt;JFR Cooperative Sampling&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;519&lt;/td&gt; 
   &lt;td&gt;Compact Object Headers&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;520&lt;/td&gt; 
   &lt;td&gt;JFR Method Timing &amp;amp; Tracing&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;521&lt;/td&gt; 
   &lt;td&gt;Generational Shenandoah&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / GC&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;Stability and performance improvements&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;span id="OSC_h1_30"&gt;&lt;/span&gt; 
&lt;h1&gt;doc&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fprojects%2Fjdk%2F25%2F" target="_blank"&gt;JDK 25 Features&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2F25%2Frelease-notes" target="_blank"&gt;JDK 25 Release Notes&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2F25all-relnotes.html" target="_blank"&gt;Consolidated JDK 25 Release Notes&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcr.openjdk.org%2F%7Eiris%2Fse%2F25%2FlatestSpec%2Fapi%2Fdeprecated-list.html" target="_blank"&gt;Java SE 25 deprecated-list&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fjava%2Fpost%2Fthe-arrival-of-java-25" target="_blank"&gt;The Arrival of Java 25&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoq.com%2Fnews%2F2025%2F09%2Fjava25-released%2F" target="_blank"&gt;Java 25, the Next LTS Release, Delivers Finalized Features and Focus on Performance and Runtime&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoq.com%2Fnews%2F2025%2F08%2Fjava-25-so-far%2F" target="_blank"&gt;JDK 25 and JDK 26: What We Know So Far&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjavaalmanac.io%2Fjdk%2F25%2F" target="_blank"&gt;The Java Version Almanac Java25&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffoojay.io%2Ftoday%2Fheres-java-25-ready-to-perform-to-the-limit%2F" target="_blank"&gt;Here’s Java 25, Ready to Perform to the Limit&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsoftwaremill.com%2Fwhats-new-in-project-leyden-jep-514-and-jep-515-explained%2F" target="_blank"&gt;What's New in Project Leyden - JEP 514 and JEP 515 Explained&lt;/a&gt;&amp;lt;/pid&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/init&amp;gt;&amp;lt;/pid&amp;gt;&amp;lt;/pid&amp;gt;&amp;lt;/frameworkcontext&amp;gt;&amp;lt;/integer&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/product&amp;gt;&amp;lt;/logger&amp;gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/go4it/blog/18692176</link>
      <guid isPermaLink="false">https://my.oschina.net/go4it/blog/18692176</guid>
      <pubDate>Sun, 14 Sep 2025 05:58:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>OpenAI 聘请前 xAI 财务主管，强化算力预算管理</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.google.com%2Furl%3Fsa%3Di%26url%3Dhttps%253A%252F%252Fwww.reuters.com%252Fbusiness%252Fopenai-hires-former-xai-cfo-mike-liberatore-business-finance-officer-2025-09-16%252F%26psig%3DAOvVaw1QknnG70qRnWga8gudvwQg%26ust%3D1758167915712000%26source%3Dimages%26cd%3Dvfe%26opi%3D89978449%26ved%3D0CBkQjhxqFwoTCMCGror03o8DFQAAAAAdAAAAABAL" target="_blank"&gt;据报道&lt;/a&gt;，OpenAI 已任命 Mike Liberatore 为新任业务财务主管。他曾担任埃隆·马斯克旗下 AI 初创公司 xAI 的首席财务官，在任期间主导了 xAI 100 亿美元融资，并推动数据中心规模扩张，于今年 7 月离职。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-d159e90d3a3da5826eaed3a33d5930373f1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据 OpenAI 透露，Liberatore 将向首席财务官 Sarah Friar 汇报，负责统筹公司数据中心与基础设施的快速增长预算，并与 Greg Brockman 团队紧密协作，管理算力战略相关的合同与投资。&lt;/p&gt; 
&lt;p&gt;当前 OpenAI 估值已达 5000 亿美元，此前刚与甲骨文签署价值 3000 亿美元的云服务协议，此次人事任命被视为强化算力资源财务规划的重要举措。行业分析指出，随着 AI 算力竞争加剧，具备大型算力项目资金运作经验的人才愈发成为科技公司争抢的焦点。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372713</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372713</guid>
      <pubDate>Sun, 14 Sep 2025 03:59:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>迪士尼、环球影业和华纳兄弟起诉 MiniMax 涉嫌侵权</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;据《好莱坞报道者》消息，迪士尼、华纳兄弟探索公司和环球影业已在加州联邦法院正式起诉中国 AI 公司 MiniMax，指控其图像与视频生成服务「海螺 AI」大规模侵权，未经授权使用经典影视 IP 训练模型并输出作品。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;诉状称，MiniMax 以「口袋里的好莱坞」自居，允许用户输入「达斯·维德」或「小黄人」等知名角色生成画面甚至短视频，部分生成结果还带有 MiniMax 水印。三大工作室指控，若无大规模盗用版权内容，MiniMax 无法实现此等输出能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-a50b6ad55409cec1a43fbd40a0ba4474079.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;这起诉讼被视为好莱坞对生成式 AI 公司的一次高调反击。近年来，从作家、唱片公司到新闻机构，多家版权方指控 AI 企业在未支付费用的情况下抓取、训练、再创作，侵蚀了原有内容需求。就在本月初，华纳、迪士尼和环球还共同起诉 Midjourney 涉嫌用影视作品训练 AI 模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;美国电影协会（MPA）首席执行官 Charles Rivkin 在声明中表示：「无论这些 AI 公司位于何处，我们都将让其为侵犯美国创作者权益负责。若放任不管，版权侵权将威胁整个美国电影产业。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;诉状中警告，随着技术进步，「海螺 AI」未来可能生成与完整电影或剧集时长相当的未经授权视频，构成对好莱坞的「生存威胁」。三大工作室要求法院判令 MiniMax 停止使用其知识产权并交出非法所得。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372711</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372711</guid>
      <pubDate>Sun, 14 Sep 2025 03:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>人形机器人公司 Figure 新一轮融资金额超 10 亿美元，投后估值 390 亿美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;人工智能机器人公司 Figure&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.figure.ai%2Fnews%2Fseries-c" target="_blank"&gt;宣布&lt;/a&gt;其 C 轮融资已获超 10 亿美元承诺资本，投后估值达 390 亿美元。这笔资金将加速该公司将通用人形机器人大规模应用于现实环境的进程。&lt;/p&gt; 
&lt;p&gt;本轮融资由 Parkway Venture Capital 领投，博枫、英伟达、麦格理资本、英特尔资本、Salesforce 等公司参投。&lt;/p&gt; 
&lt;p&gt;Figure 成立于 2022 年，2023 年 3 月发布首款通用人形机器人 Figure 01，曾获 OpenAI、微软、英伟达、英特尔以及亚马逊创始人贝佐斯等投资，并在今年初终止了与 OpenAI 合作。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/112541_zLm4_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;本轮融资将推动公司 AI 平台 Helix 和 BotQ 制造体系的规模化扩张，推动人形机器人进入家庭和商业运营、建设新一代 GPU 基础设施加速训练与仿真，以及启动先进数据收集计划。&lt;/p&gt; 
&lt;p&gt;Figure 表示，此次融资将用于三个核心领域：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;将人形机器人扩展到家庭和商业运营。其正在扩大 BotQ 的生产制造和实际部署，使机器人能够协助完成家庭和商业工作。&lt;/li&gt; 
 &lt;li&gt;构建下一代 GPU 基础架构，加速训练和模拟。该计算基础将为 Helix 的感知、推理和控制核心模型提供支持。&lt;/li&gt; 
 &lt;li&gt;启动先进的数据收集工作。这些工作包括收集人类视频和多模态传感输入的数据，以提升机器人在复杂动态环境中的理解和操作能力，这些真实世界的数据集对于扩展 Helix 的功能至关重要。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;公开信息显示，Figure 已经推出了两款机器人产品，分别是 2023 年 10 月推出的 Figure01 以及 2024 年 8 月推出的 Figure02。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372709/figure-ai-series-c</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372709/figure-ai-series-c</guid>
      <pubDate>Sun, 14 Sep 2025 03:27:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Anthropic 的 Claude AI 正式上线 Xcode 26</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Anthropic &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fclaude-in-xcode" target="_blank"&gt;宣布&lt;/a&gt;其 AI 助手 Claude 现已在 Xcode 中正式发布。Xcode 是 Apple 的集成开发环境 (IDE)，提供开发、测试和分发 Apple 平台 app 所需的工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此集成使开发者能够直接在其工作流程中使用 Claude 的编码功能，从而加速 Apple 平台 app 的开发。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-f1b1f259b122dd9bb17e50753c081ef8e97.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;当用户在 Xcode 中登录其 Claude 帐户时，将可以访问由 Claude Sonnet 4 提供支持的编码智能功能，包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;编码助手：使用自然语言与你的代码交互。Claude 会自动收集您项目中的上下文，并支持对话历史记录和文件附件，以帮助调试、重构和构建功能。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;编码工具：为代码生成文档，获取高亮显示部分的解释，创建 SwiftUI 预览和游乐场，并直接在编辑器中进行内联代码更改&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Claude 在 Xcode 中的上线与现有订阅计划紧密相连，使用限制在各个平台间共享，并为 Xcode 集成分配了一部分额度。该功能对 Pro 和 Max 计划用户开放，同时也适用于拥有 Claude Code 的 Team 和 Enterprise 客户的高级座位。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:auto; margin-right:auto; text-align:start"&gt;&lt;span style="color:#000000"&gt;要在 Xcode 中开始使用 Claude：&lt;/span&gt;&lt;/p&gt; 
&lt;ol style="margin-left:auto; margin-right:auto"&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;从 Mac App Store 下载&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapps.apple.com%2Fus%2Fapp%2Fxcode%2Fid497799835%3Fmt%3D12" target="_blank"&gt;Xcode 26&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;打开 Xcode 首选项设置并导航至 Intelligence 设置&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;使用你的 Claude 帐户登录&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372706/claude-in-xcode</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372706/claude-in-xcode</guid>
      <pubDate>Sun, 14 Sep 2025 03:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MySQL 单表为何别超 2000 万行？揭秘 B + 树与 16KB 页的生死博弈</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、前，言&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;本文核心介绍，为何业界会有这样的说法？—— 「MySQL 单表存储数据量最好别超过千万级别」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;当然这里是有前提条件的，也是我们最常使用到的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;InnoDB 存储引擎；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用的是默认索引数据结构——B+树;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;正常普通表数据（列数量控制在几个到一二十个，普通字段类型及长度）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;接下来咱们就探究一下原因，逐步揭开答案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、MySQL 是如何存储数据的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心结构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：B+树 + 16KB 数据页&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这里如下，建一张普通表 user：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;TABLE&amp;nbsp;`user` (
&amp;nbsp; `id`&amp;nbsp;int(10) unsigned&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;AUTO_INCREMENT COMMENT&amp;nbsp;'主键',
&amp;nbsp; `name`&amp;nbsp;varchar(100)&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;DEFAULT&amp;nbsp;''&amp;nbsp;COMMENT&amp;nbsp;'名字',
&amp;nbsp; `age`&amp;nbsp;int(11)&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;DEFAULT&amp;nbsp;'0'&amp;nbsp;COMMENT&amp;nbsp;'年龄',
&amp;nbsp;&amp;nbsp;PRIMARY&amp;nbsp;KEY (`id`),
&amp;nbsp; KEY `idx_age` (`age`)
) ENGINE=InnoDB AUTO_INCREMENT=1&amp;nbsp;DEFAULT&amp;nbsp;CHARSET=utf8;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;数据页（Page）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;介绍&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;InnoDB 存储的最小单位，固定为 16KB 。每页存储表数据（行记录）、索引、元信息等。数据加载到内存时以页为单位，减少磁盘 I/O 次数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;页的结构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设我们有这么一张 user 数据表。其中 id 是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;唯一主键&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。这看起来的一行行数据，为了方便，我们后面就叫它们&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;record&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;吧。这张表看起来就跟个 excel 表格一样。excel 的数据在硬盘上是一个 xx.excel 的文件。而上面 user 表数据，在硬盘上其实也是类似，放在了 user.&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ibd&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文件下。含义是 user 表的 innodb data 文件，又叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;表空间&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。虽然在数据表里，它们看起来是挨在一起的。但实际上在 user.ibd 里他们被分成很多小份的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;数据页&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，每份大小 16k。类似于下面这样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9b9aed13809533763885cd45c2c3c452.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ibd 文件内部有大量的页，我们把视角聚焦一下，放到页上面。整个页 16k，不大，但 record 这么多，一页肯定放不下，所以会分开放到很多页里。并且这 16k，也不可能全用来放 record 对吧。因为 record 们被分成好多份，放到好多页里了，为了唯一标识具体是哪一页，那就需要引入&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;页号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（其实是一个表空间的地址偏移量）。同时为了把这些数据页给关联起来，于是引入了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前后指针&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，用于指向前后的页。这些都被加到了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;页头&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;里。页是需要读写的，16k 说小也不小，写一半电源线被拔了也是有可能发生的，所以为了保证数据页的正确性，还引入了校验码。这个被加到了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;页尾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。那剩下的空间，才是用来放我们的 record 的。而 record 如果行数特别多的话，进入到页内时挨个遍历，效率也不太行，所以为这些数据生成了一个&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;页目录&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，具体实现细节不重要。只需要知道，它可以通过&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;二分查找&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的方式将查找效率&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从 O(n) 变成 O(lgn)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5644e7c12d54b5405bdbc8af995203e7.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;从页到索引—B+树索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果想查一条 record，我们可以把表空间里每一页都捞出来（全表扫描），再把里面的 record 捞出来挨个判断是不是我们要找的。行数量小的时候，这么操作也没啥问题。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行数量大了，性能就慢了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，于是为了加速搜索，我们可以在每个数据页里选出&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主键 id 最小&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的 record，而且只需要它们的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主键 id 和所在页的页号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。组成&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新的 record&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，放入到一个新生成的一个数据页中，这个&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新数据页跟之前的页结构没啥区别，而且大小还是 16k&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。但为了跟之前的数据页进行区分。数据页里加入了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;页层级（page level）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的信息，从 0 开始往上算。于是页与页之间就有了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上下层级&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的概念，就像下面这样。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d641ebd9ddee61101bb3edff7f27edf2.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;突然页跟页之间看起来就像是一棵倒过来的树了。也就是我们常说的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;树索引。最下面那一层，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;page level 为 0&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，也就是所谓的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;叶子结点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，其余都叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非叶子结点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。上面展示的是两层的树，如果数据变多了，我们还可以再通过类似的方法，再往上构建一层。就成了三层的树。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;聚簇索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：数据按主键组织成一棵 B+树。叶子节点存储完整行数据 ，非叶子节点存储主键值+指向子页的指针（类似目录）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;二级索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：叶子节点存储主键值，查询时需回表（根据主键回聚簇索引查数据）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行格式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;COMPACT&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;格式，行数据包含&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;事务 ID&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;回滚指针&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;列值&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等信息。&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;行大小影响单页存储的行数&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;存入数据如下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;比如表数据已存在 id 为 1-10 的数据存储，简单比方如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b4d13ed1425d3f157f13749219d2aba9.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;然后需要插入 id=11 的数据：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;加载 1 号数据页入内存，分析判定；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;id=11 的数据大于 id=10，那么锁定页号 5，判定 5 号页是否还可以存下数据 11；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以存下，将 id=11 的数据写入到 5 号页中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5b6dacd1a27fdcf9e5b876addc310822.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;关键原理总结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;所有数据通过 B+树有序组织，数据存储在数据页上，页与页之间以双向链表连接，非叶子节点提供快速定位路径，叶子节点存储实际的数据。&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、MySQL 是如何查询到数据的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上面我们已经介绍了 MySQL 中使用页存储数据，以及 B+树索引数据的结构，那现在我们就可以通过这样一棵 B+树加速查询。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;举个例子：select *&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;from table where id = 5&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;比方说我们想要查找行数据 5。会先从顶层页的 record 们入手。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;record 里包含了主键 id 和页号（页地址）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如下图所示，左边 2 号页最小 id 是 1，向右 3 号页最小 id 是 4，然后 4 号页最小是 7，最后 5 号页最小是 10。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c8994b6f3c261d86ffb79ee6e1aab7c6.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那 id=5 的数据如果存在，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;5 大于 4 小于 7，那必定在 3 号页里面&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。于是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;顺着的 record 的页地址就到了 3 号数据页里&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，于是加载 3 号数据页到内存。在数据页里找到 id=5 的数据行，完成查询。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;另外需要注意的是，上面的页的页号并不是连续的，它们在磁盘里也不一定是挨在一起的。这个过程中查询了 2 个页（1 号跟 3 号），如果这三个页都在磁盘中（没有被提前加载到内存中），那么&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最多&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要经历两次&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盘 IO 查询&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，它们才能被加载到内存中。（如果考虑 1 号如果是 root 常驻内存，那么需要磁盘 IO 一次即可定位到）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//0183a1e293ff7baff192716d58a437d0.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;查询步骤总结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;以聚簇索引搜索为例（假设 id 是主键）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从根页开始搜索 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;加载根页（常驻内存）到 Buffer Pool，根据指针找到下一层节点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;逐层定位叶子节点 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在非叶子节点页（存储主键+指针）中二分查找 ，定位 id=5 所在范围的子页（如页 A）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;重复此过程，直到叶子节点页。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;叶子节点二分查找 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在叶子页内通过主键二分查找定位到行记录，返回完整数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;I/O 次数分析 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;树高为 3 时：根页 + 中间页 + 叶子页 = 3 次磁盘 I/O （若页不在内存中）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树矮胖特性 ：3 层即可支撑千万级数据（接下来分析），是高效查询的基础。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、2000 万这个上限值如何算出来的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在我们清楚了 MySQL 是如何存储及查询数据后，那么 2000 万这个数值又是如何得来的呢？超过 2000 万比如存储一亿数据会如何？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;B+树承载的记录数量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从上面的结构里可以看出 B+树的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最末级叶子结点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;里放了 record 数据。而&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非叶子结点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;里则放了用来加速查询的索引数据。也就是说同样一个 16k 的页，非叶子节点里每一条数据都指向一个新的页，而新的页有两种可能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是末级叶子节点的话，那么里面放的就是一行行 record 数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是非叶子节点，那么就会循环继续指向新的数据页。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非叶子节点内指向其他内存页的指针数量为 x（非叶子节点指针扇出值）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;叶子节点内能容纳的 record 数量为 y（叶子节点单页行数）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树的层数为 z（树高）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那这棵 B+树放的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行数据总量等于 (x ^ (z-1)) * y&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心公式：&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;单表最大行数 = 非叶节点扇出指针数 ^ (树高-1) × 单页行数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;非叶子节点指针扇出值—x 怎么算？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们回去看数据页的结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b0e2c5fe5bd7722205025f6d096c4165.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主键假设是 bigint（8Byte），而页号在源码里叫 FIL_PAGE_OFFSET（4Byte），那么非叶子节点里的一条数据是 12Byte 左右。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;整个数据页 16k， 页头页尾那部分数据全加起来大概 128Byte，加上页目录毛估占 1k 吧。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那剩下的 15k 除以 12Byte，等于 1280，也就是可以指向 x=1280 页。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们常说的二叉树指的是一个结点可以发散出两个新的结点。m 叉树一个节点能指向 m 个新的结点。这个指向新节点的操作就叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;扇出（fanout）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。而上面的 B+树，它能指向 1280 个新的节点，恐怖如斯，可以说&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;扇出非常高&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;单页行数—y 的计算&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;叶子节点和非叶子节点的数据结构是一样的，所以也假设剩下 15kb 可以发挥。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;叶子节点里放的是真正的行数据。假设一条行数据 1kb，所以一页里能放&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;y=15 行&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;行总数计算&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;回到 (x ^ (z-1)) * y 这个公式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;已知 x=1280，y=15。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设 B+树是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;两层&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，那 z=2。则是 (1280 ^ (2-1)) * 15 ≈ 2w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设 B+树是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;三层&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，那 z=3。则是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;(1280 ^ (3-1)) * 15 ≈ 2.5kw&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这个 2.5kw，就是我们常说的单表建议最大行数 2kw 的由来。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘 IO，也比较合理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;临界点 ：当行数突破约 2000 万时，树高可能从 3 层变为 4 层：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;树高=4 时：最大行数 ≈ 1280^3 × 15 结果已超过百亿（远大于 2000 万）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;性能断崖 ：树高从 3→4，查询 I/O 次数从 3 次增至 4 次 （多一次磁盘寻址），尤其在回表查询、高并发、深分页时性能骤降。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;行数超一亿就慢了吗？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上面假设单行数据用了 1kb，所以一个数据页能放个 15 行数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果我单行数据用不了这么多，比如只用了 250byte。那么单个数据页能放 60 行数据。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那同样是三层 B+树，单表支持的行数就是 (1280 ^ (3-1)) * 60 ≈ 1 个亿。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;你看我一个亿的数据，其实也就三层 B+树，在这个 B+树里要查到某行数据，最多也是三次磁盘 IO。所以并不慢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;B 树承载的记录数量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们都知道，现在 MySQL 的索引都是 B+树，而有一种树，跟 B+树很像，叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B 树，也叫 B-树&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;它跟 B+树最大的区别在于，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树只在末级叶子结点处放数据表行数据，而 B 树则会在叶子和非叶子结点上都放。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;于是，B 树的结构就类似这样：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//0e4feea3dedf77739c444c8427ea9bcf.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B 树将行数据都存在非叶子节点上，假设每个数据页还是 16kb，掐头去尾每页剩 15kb，并且一条数据表行数据还是占 1kb，就算不考虑各种页指针的情况下，也只能放个 15 条数据。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;数据页扇出明显变少了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;计算可承载的总行数的公式也变成了一个&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;等比数列&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;15 + 15^2 +15^3 + ... + 15^z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;其中&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;z 还是层数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的意思。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;能放 2kw 左右的数据，需要 z&amp;gt;=6&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。也就是树需要有 6 层，查一次要访问 6 个页。假设这 6 个页并不连续，为了查询其中一条数据，最坏情况需要进行&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;6 次磁盘 IO&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;而 B+树同样情况下放 2kw 数据左右，查一次最多是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;3 次磁盘 IO&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盘 IO 越多则越慢，这两者在性能上差距略大。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为此，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树比 B 树更适合成为 MySQL 的索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、总结：生死博弈的核心&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树叶子和非叶子结点的数据页都是 16k，且数据结构一致，区别在于叶子节点放的是真实的行数据，而非叶子结点放的是主键和下一个页的地址。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+树一般有两到三层，由于其高扇出，三层就能支持 2kw 以上的数据，且一次查询最多 1~3 次磁盘 IO，性能也还行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;存储同样量级的数据，B 树比 B+树层级更高，因此磁盘 IO 也更多，所以 B+树更适合成为 MySQL 索引。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;索引结构不会影响单表最大行数，2kw 也只是推荐值，超过了这个值可能会导致 B+树层级更高，影响查询性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;单表最大值还受主键大小和磁盘大小限制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;16KB 页与 B+树的平衡 ：页大小限制了单页行数和指针数，B+树通过多阶平衡确保低树高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;2000 万不是绝对 ：若行小于 1KB（如只存 ID），上限可到 5000 万+；若行较大（如含大字段），可能 500 万就性能下降。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优化建议：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;控制单行大小（避免&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;TEXT/BLOB&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;直接入表）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;分库分表：单表接近千万级时提前规划。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;冷热分离：历史数据归档。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;本质：通过页大小和 B+树结构，MySQL 在磁盘 I/O 和内存效率之间取得平衡。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;超出平衡点时，性能从「平缓下降」变为「断崖下跌」。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;六、拓展问题&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为啥设计单页大小 16k?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;MySQL 索引采用的是 B+树数据结构，每个叶子节点（叶子块）存储一个索引条目的信息。而 MySQL 使用的是页式存储（Paged storage）技术，将磁盘上的数据划分为一个个固定大小的页面，每个页面包含若干个索引条目。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了提高索引查询效率和降低磁盘 I/O 的频率，MySQL 设置了 16KB 的单页大小。这是因为在 MySQL 中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;内存大小限制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：MySQL 的索引需要放在内存中进行查询，如果页面过大，将导致索引无法完全加载到内存中，从而影响查询效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盘 I/O 限制：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;当需要查询一个索引时，MySQL 需要把相关的页面加载到内存中进行处理，如果页面过大，将增加磁盘 I/O 的开销，降低查询效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;索引效率限制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：在 B+树数据结构中，每个叶子节点存储着一个索引条目，因此如果每个页面能够存放更多索引条目，就可以减少 B+树结构的深度，从而提高索引查询效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;综上所述，MySQL 索引单页大小设置为 16KB 可以兼顾内存大小、磁盘 I/O 和索引查询效率等多方面因素，是一种比较优化的方案。需要注意的是，对于某些特殊的应用场景，可能需要根据实际情况对单页大小进行调整。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;字符串怎么做索引?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 MySQL 中，可以通过 B+树索引结构对字符串类型的列进行排序。具体来说，当使用 B+树索引进行排序时，MySQL 会根据字符串的字典序（Lexicographic Order）进行排序。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;字典序是指将字符串中的每个字符依次比较，直到找到不同的字符为止。如果两个字符串在相同的位置上具有不同的字符，则以这两个字符的 ASCII 码值比较大小，并按照升序或降序排列。例如，字符串"abc"和"def"比较大小时，先比较'a'和'd'的 ASCII 码，因为'd'的 ASCII 码大于'a'，所以"def"大于"abc"。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，如果对长字符串进行排序，可能会影响索引查询的性能，因此可以考虑使用前缀索引或全文索引来优化。同时，在实际开发中，还需要注意选择适当的字符集和排序规则，以确保排序结果正确和稳定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;中文字符串怎么做索引?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;中文字符串排序在 MySQL 中可以使用多种方式，最常见的有以下两种：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;按拼音排序：对于中文字符串，可以按照拼音进行排序。可以使用拼音排序插件，如 pinyin 或 zhuyin 插件，来实现中文字符串按照拼音进行排序。这些插件会将中文字符串转换为拼音或注音后，再进行排序。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如，先安装 pinyin 插件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;INSTALL&amp;nbsp;PLUGIN pinyin SONAME&amp;nbsp;'ha_pinyin.so';&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;然后创建对应的索引并按拼音排序：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;INDEX idx_name_pinyin&amp;nbsp;ON&amp;nbsp;mytable(name)&amp;nbsp;USING&amp;nbsp;BTREE&amp;nbsp;WITH&amp;nbsp;PARSER pinyin;
SELECT&amp;nbsp;*&amp;nbsp;FROM&amp;nbsp;mytable&amp;nbsp;ORDER&amp;nbsp;BY&amp;nbsp;name&amp;nbsp;COLLATE&amp;nbsp;pinyin;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;按 Unicode 码点排序：可以使用 UTF-8 字符集，并选择 utf8mb4_unicode_ci 排序规则，在使用此排序规则时，MySQL 会按照 Unicode 码点进行排序，适合于较为通用的中文字符串排序需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;INDEX idx_name_unicode&amp;nbsp;ON&amp;nbsp;mytable(name)&amp;nbsp;USING&amp;nbsp;BTREE;
SELECT&amp;nbsp;*&amp;nbsp;FROM&amp;nbsp;mytable&amp;nbsp;ORDER&amp;nbsp;BY&amp;nbsp;name&amp;nbsp;COLLATE&amp;nbsp;utf8mb4_unicode_ci;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，不同的排序方式可能会对性能产生影响，因此需要根据具体需求选择合适的排序方式，并进行必要的测试和验证。同时，在进行中文字符串排序时，还需要考虑到中文字符的复杂性，例如同音字、繁简体等问题，以确保排序结果正确和稳定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;索引字段的长度有限制吗?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 MySQL 中，索引的长度通常是由三个因素决定的：数据类型、字符集和存储引擎。不同的数据类型、字符集和存储引擎所支持的最大索引长度也有所不同。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;一般情况下，索引的长度不应该超过存储引擎所支持的最大索引长度。在 InnoDB 存储引擎中，单个索引所能包含的最大字节数为 767 个字节（前缀索引除外）。如果索引的长度超过了最大长度，则会导致创建索引失败。因此，在设计表结构时，需要根据索引列的数据类型和字符集等因素，合理设置索引长度，以充分利用索引的优势。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;对于字符串类型的索引，还需要注意以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;对于 UTF-8 字符集，每个字符占用 1-4 个字节，因此索引长度需要根据实际情况进行计算。例如，一个 VARCHAR(255) 类型的列在 utf8mb4 字符集下的最大长度为 255*4=1020 个字节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以使用前缀索引来减少索引的大小，提高索引查询效率。在创建前缀索引时需要指定前缀长度。例如，可以在创建索引时使用 name(10) 来指定 name 列的前 10 个字符作为索引。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在使用全文索引对字符串进行搜索时，MySQL 会将文本内容分割成单个词汇后建立倒排索引。在建立索引时需要考虑到中英文分词的问题，以确保全文索引的准确性和查询效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;综上所述，索引的长度需要根据数据类型、字符集和存储引擎等多个因素进行综合考虑，并合理设置索引长度，以提高索引查询效率和利用率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1. 0 基础带你精通 Java 对象序列化--以 Hessian 为例｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2. 前端日志回捞系统的性能优化实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3. 得物灵犀搜索推荐词分发平台演进 3.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4. R8 疑难杂症分析实战：外联优化设计缺陷引起的崩溃｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5. 可扩展系统设计的黄金法则与 Go 语言实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;文 / 太空&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18691996</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18691996</guid>
      <pubDate>Sun, 14 Sep 2025 03:02:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>全球首个 AI Agent 交易市场「MuleRun」正式上线</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fmulerun_ai%2Fstatus%2F1967623169180852241" target="_blank"&gt;据 Mulerun 官方消息&lt;/a&gt;，全球首个 AI Agent 交易市场 MuleRun（骡子快跑）正式上线，为 AI 数字劳动力提供一站式交易服务，链接全球 Agent 创作者与用户。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f576ceaaa2d77e9886ceed60e1de842ad4e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://mulerun.com/&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;自 8 月 14 日内测以来，平台已涌现多款热门 Agent 产品，涵盖游戏自动化、3D 建模、美股研报生成、社交媒体内容创作等场景。中国创作者 Laughing 的游戏任务助手、芋头小宝的 3D 建模工具等已实现商业化变现。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0917/104332_mrJD_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;为扶持全球创作者，MuleRun 推出三重支持计划：现金激励最高达 1 万美元，配套全球社交媒体流量曝光，并提供从开发到上架的全流程技术工具。新用户注册可获 1000 积分，邀请好友再得 500 积分，可用于体验平台内 Agent 服务。该平台的上线标志着 AI 数字劳动力进入规模化商用阶段。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372699</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372699</guid>
      <pubDate>Sun, 14 Sep 2025 02:44:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>粤港澳大湾区生成式人工智能安全发展联合实验室正式成立</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;粤港澳大湾区生成式人工智能安全发展联合实验室（以下简称「联合实验室」）揭牌仪式 15 日在深圳举行。&lt;/p&gt; 
&lt;p&gt;该实验室将通过制定行业安全发展标准、搭建粤语语料库资源平台、支撑模型备案安全评估、举办前沿技术成果发布等多元形式，服务企业发展、推动产业落地、加强安全监管，助力大湾区成为智能技术创新的策源地、智能产业融合的增长极、智能安全治理的先行区。&lt;/p&gt; 
&lt;p&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-852af8bd4285a36f57b575c545439f8a231.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;联合实验室是一个适应人工智能时代敏捷、弹性、高效的创新治理联合体，由国家互联网应急中心作为指导单位，广东省委网信办和国家互联网应急中心广东分中心联合牵头，粤港澳大湾区相关部门、企业、高校、科研机构、媒体等共同参与建设，运行主体常设在河套深港科技创新合作区，并视情在香港、澳门、广州、珠海、东莞等地设立地方服务站。&lt;/p&gt; 
&lt;p&gt;「这两年人工智能发展日新月异，在产业快速发展的同时，安全和可控的重要性也日益凸显。」联合实验室理事、广州云蝶科技有限公司创始人田雪松表示，联合实验室的建设，将进一步提升广东省内人工智能和大模型企业的软实力，在全国乃至全球的竞争中形成差异化优势，助力广东人工智能和大模型产业发展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372698</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372698</guid>
      <pubDate>Sun, 14 Sep 2025 02:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>龙芯首款 GPGPU 芯片 9A1000 预计在三季度内交付流片</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;龙芯科技 9A1000 显卡于 2023 年开始研发，如今距离最终定稿又近了一步。龙芯中科近日在互动平台回复称，龙芯首款 GPGPU 芯片 9A1000 的研发基本完成，三季度内会交付流片。成功与否需待流片回来后的测试结果。&lt;/p&gt; 
&lt;p&gt;9A1000 是龙芯的首款显卡，对于这家此前主要专注于处理器的中国制造商来说，这是一个重要的里程碑。该公司将 9A1000 定位为支持 AI 加速的入门级显卡。因此，它与另一款据称可与 GeForce RTX 4060 匹敌的中国显卡 Lisuan G100 并不在同一细分市场竞争。&lt;/p&gt; 
&lt;p&gt;依据此前的官方资料报道，龙芯 9A1000 显卡芯片的一大亮点在于对 PCIe 4.0 系统总线的支持，并且适配 128-bit LPDDR4X 高速显存。尽管具体的计算核数、显存规模、运作频率及功耗数据尚未公布，但从已曝光的结构图中可窥见其布局了八大计算集群，辅以片上互联网络与二级缓存机制，预示着不俗的内部架构设计。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-cabb7c2678084d3f57350c795c9369bf4b7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在软件兼容层面，龙芯 9A1000 全面拥抱 OpenGL 4.0、OpenCL 3.0 等行业主流图形与计算 API，内置专业级视频处理组件，硬解码能力覆盖 H.264、H.265 编解码标准，同时支持 HDMI 2.1、DisplayPort 1.4 以及经典的 VGA 等多种显示输出协议。&lt;/p&gt; 
&lt;p&gt;深入剖析其性能规格，龙芯 9A1000 拥有高达 16GP/s（每秒 160 亿个像素点）的像素填充速率，纹理填充速率为 32GT/s（每秒 320 亿个纹理元素），浮点运算能力可达 FP32 精度下 1TFLOPS（每秒 1 万亿次）、FP64 精度下 64GFLOPs（每秒 640 亿次），而在 INT8 整数运算环境下则飙升至 32TFLOPS（每秒 32 万亿次）。这些指标共同描绘了一个兼顾图形渲染与深度学习加速的强大计算平台轮廓。&lt;/p&gt; 
&lt;p&gt;9A1000 的最新更新表明，龙芯已将流处理器的面积缩小了 20%。制造商还声称，9A1000 的工作频率提高了 25%，同时轻负载下的功耗优化了 70%。在功能方面，9A1000 支持 OpenGL 4.0 和 OpenCL ES 3.2 API。&lt;/p&gt; 
&lt;p&gt;龙芯表示，9A1000 的速度比 2K3000 处理器内置的集成显卡 LG200 快 4 倍。9A1000 还提供高达 40 TOPS 的 AI 计算能力，略低于 AMD Ryzen AI Max+（代号 Strix Halo）芯片内置的 XDNA 2 NPU（高达 50 TOPS）。&lt;/p&gt; 
&lt;p&gt;9A1000 并非龙芯唯一的显卡产品。该公司还在研发 9A2000，据称其速度比 9A1000 快 10 倍，性能水平堪比 GeForce RTX 2080。此外，龙芯还计划推出 9A3000，作为 9A2000 的后续产品，但目前尚不清楚具体规格。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372696</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372696</guid>
      <pubDate>Sun, 14 Sep 2025 02:39:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通义推出开源 Web Agent：Tongyi DeepResearch</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通义实验室发布并开源了 Tongyi DeepResearch，据称是首个性能对标 OpenAI Deep Research 的开源 Web Agent。&lt;/p&gt; 
&lt;p&gt;这是一款采用 30B 总参数、每 token 仅激活 3B 的 MoE 结构的模型。它拥有 128K 的上下文长度，并支持 ReAct 与 IterResearch 两种推理范式。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-c92bc06df52b3f054ac8a570b944b55cf72.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Tongyi DeepResearch 作为完全开源的 Web Agent。该项目的核心贡献不仅在于模型本身，更在于一套完整的、端到端的智能体训练方法论 。其关键技术包括：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;全流程数据合成：不依赖昂贵的人工标注，通过创新的数据合成方案，为智能体的持续预训练（CPT）、监督微调（SFT）和强化学习（RL）提供海量高质量数据 。&lt;/li&gt; 
 &lt;li&gt;端到端训练框架：建立了一个从「智能体持续预训练」到「智能体强化学习」的无缝训练循环，并采用定制化的在策略（on-policy）强化学习算法（GRPO）来对齐模型行为 。&lt;/li&gt; 
 &lt;li&gt;创新的推理模式：除了标准的 ReAct 模式，还开发了基于 IterResearch 范式的「重模式」（Heavy Mode），通过解构任务和重组工作区来克服长程任务中的「认知窒息」问题，从而最大化模型的推理和规划潜力 。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;该模型及其全套解决方案已在 GitHub、HuggingFace 与 ModelScope 上线。配套的 Python 3.10 环境、JSONL 评测脚本以及 benchmark 评估工具也已一并开源，方便开发者使用和评估。&lt;/p&gt; 
&lt;p&gt;首页：https://tongyi-agent.github.io&amp;nbsp;&lt;br&gt; 博客: https://tongyi-agent.github.io/blog/introdung-tongyi-deep-research/&amp;nbsp;&lt;br&gt; GitHub 仓库: https://github.com/Alibaba-NLP/DeepResearch&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372685/tongyi-deep-research</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372685/tongyi-deep-research</guid>
      <pubDate>Sun, 14 Sep 2025 02:18:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>国内首个 AI 大模型众测结果出炉，发现 281 个安全漏洞</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在第 22 届中国网络安全年会（暨国家网络安全宣传周网络安全协同防御分论坛）上，国内&lt;span&gt;首次&lt;/span&gt;针对 AI 大模型的众测结果揭晓。此次活动由中央网信办网络安全协调局指导，国家计算机网络应急技术处理协调中心主办，吸引了 559 名白帽子安全专家参与，对 15 款 AI 大模型和应用产品进行了全面的安全漏洞测试。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这项测试涵盖了从基础大模型到智能体和模型开发平台等多种产品，旨在从攻击者的角度发掘潜在的安全隐患。结果显示，共发现各类安全漏洞高达 281 个，其中大模型特有漏洞就有 177 个，比例超过 60%。这说明，AI 大模型在安全性方面面临着传统安全领域之外的许多新兴风险。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;测试中揭示的典型漏洞风险包括:部分产品存在严重的输出不当漏洞，信息泄露类漏洞频发，提示注入类漏洞也是一种普遍风险。此外，尽管一些大模型产品已经具备一定的防护能力，但对抗无限制消耗攻击的措施仍需加强。值得注意的是，传统的安全漏洞依然普遍，必须引起足够的重视。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在参与测试的主流大模型产品中，腾讯的混元大模型、百度的文心一言和阿里巴巴的通义 App 等，发现的漏洞相对较少，显示出较高的安全防护水平。这一结果为广大用户和开发者带来了信心。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;活动最后，官方提出了四项 AI 大模型安全治理工作要求，强调了未来的防护措施和漏洞管理的重要性，包括加强安全防护、制定漏洞分类标准、鼓励社会白帽力量的参与，以及在 AI 系统全生命周期中融入安全管理。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372683</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372683</guid>
      <pubDate>Sun, 14 Sep 2025 02:06:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>第二届「AI 宁波」人工智能赋能产业大赛火热报名中</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;为推动人工智能技术与产业深度融合，赋能产业创新发展，第二届 「AI 宁波」 人工智能赋能产业大赛正式向全球发出邀请 —— 诚邀人工智能领域的精英团队、科研人才踊跃报名，共赴这场 AI 赋能产业的创新盛宴！&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0917/095632_fuFY_2720166.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372679</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372679</guid>
      <pubDate>Sun, 14 Sep 2025 01:56:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>🚀 效率革命！AI 低代码引擎发布 0.13.25 版本，设计师和开发者终于能说同一种</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;blockquote&gt; 
 &lt;p style="margin-left:0; margin-right:0"&gt;一键复制粘贴跨页面，17 个快捷键让开发效率飙升 50%&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;业内领先的开源 AI 低代码开发引擎&lt;strong&gt;VTJ.PRO&lt;/strong&gt;再次带来重磅更新！最新发布的 0.13.25 版本中，编辑器正式&lt;strong&gt;支持快捷键操作&lt;/strong&gt;和&lt;strong&gt;跨页面复制粘贴&lt;/strong&gt;功能，这将彻底改变企业级应用开发的协作方式。&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//4ec53c4f836fdfc9cd097cd2be744ba9.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;设计师的流畅感，开发者的高效率&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;想象一下：在使用 Figma 或 Sketch 设计时，那种行云流水的快捷键操作体验，现在终于在应用开发领域实现了！&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;VTJ.PRO 此次更新包含了 17 个精心设计的快捷键，覆盖了从基础操作到复杂交互的全场景：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;全局操作快捷键&lt;/strong&gt;让保存（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;S&lt;/code&gt;）、预览（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;P&lt;/code&gt;）、撤销（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;）、重做（&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;）等高频操作触手可及，不再需要频繁点击工具栏。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;组件操作快捷键&lt;/strong&gt;更是精妙：删除、复制、剪切、粘贴这些操作与常用设计软件保持一致，大大降低了学习成本。方向键选择组件的设计让精准选择变得异常简单。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;最令人惊喜的是&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↑&lt;/code&gt;/&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;快捷键，允许开发者在同级组件中快速调整顺序，这在进行精细布局调整时尤其有用。&lt;br&gt; &lt;br&gt; &lt;img alt="" height="1055" src="https://oscimg.oschina.net/oscnet/up-d4c83ed961f4790fe3c75e0b4173459ac09.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;跨页面复制粘贴：打破界限的创新&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;此次更新中最具革命性的功能非&lt;strong&gt;跨页面复制粘贴&lt;/strong&gt;莫属。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;以往开发过程中，在不同页面间复用组件需要多次导出导入，或者重新编写代码。现在，只需简单的&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;C&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;和&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;V&lt;/code&gt;，就能将组件甚至整个模块从一个页面复制到另一个页面，&lt;strong&gt;真正实现了资源的无缝流动&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;这项功能对于大型项目尤其有价值：设计系统的一致性得到了保证，开发效率大幅提升，维护成本显著降低。&lt;/p&gt; 
&lt;h2&gt;实际效益：数字说话&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;早期测试数据显示，使用快捷键和跨页面复制功能后：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;常规操作时间减少约 50%&lt;/li&gt; 
 &lt;li&gt;组件复用效率提升 60%&lt;/li&gt; 
 &lt;li&gt;整体开发周期缩短 30%&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;某金融科技公司的前端团队负责人表示："这不仅仅是增加了几个快捷键，而是真正理解了开发者的工作流程和痛点。我们现在可以在不同项目间快速迁移组件，建立统一的设计语言系统，这是以前难以想象的。"&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//8dceb323f7088c0225a1c00ccdc23bea.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;低代码领域的又一次飞跃&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;VTJ.PRO&lt;/strong&gt;一直秉持"降低复杂度，不降低自由度"的理念，这次更新再次证明了这一点。快捷键功能的加入没有牺牲任何灵活性，反而让开发者既能享受可视化开发的便捷，又能保持代码级控制的精确度。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;随着企业数字化进程加速，对应用开发效率的要求越来越高。&lt;strong&gt;VTJ.PRO&lt;/strong&gt;通过这次更新，进一步巩固了其在企业级低代码开发领域的领先地位。&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//3e9b48348a4313be44affbe6ab83bebc.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;立即体验&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;VTJ.PRO&lt;/strong&gt;完全开源且无商业限制，开发者现在就可以通过以下方式体验新功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;访问在线设计器：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2F" target="_blank"&gt;https://vtj.pro&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用脚手架创建本地项目：&lt;code&gt;npm create vtj@latest&lt;/code&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;此次更新只是 VTJ.PRO roadmap 中的一步，开发团队表示未来将继续深化 AI 辅助开发能力，进一步打通设计与开发之间的壁垒。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;开发者的效率革命已经到来，你准备好了吗？&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;快捷键清单&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;任意时机&lt;/strong&gt;： 
  &lt;ul&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;S&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;保存&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;P&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;预览&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;撤销&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;重做&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;R&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;刷新&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;A&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;选中组件根节点&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;选择任意组件后：&lt;/strong&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;code&gt;Backspace&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;删除组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;C&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;复制组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;V&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;粘贴组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;X&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;剪切组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;↑&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向外层选择组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向内层选择组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;←&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向同级左向选择组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;→&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向同级右向选择组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;Escape&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;取消选择组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↑&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;同级向上/左移动组件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;同级向下/右移动组件&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372664</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372664</guid>
      <pubDate>Sun, 14 Sep 2025 01:00:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>🔥httpsok-v1.18.2-SSL 证书自动续签</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;&lt;span&gt;🔥httpsok-v1.18.2-SSL 证书自动续签&lt;/span&gt;&lt;/h1&gt; 
&lt;h2&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;httpsok&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 是一个便捷的 HTTPS 证书自动续签工具，专为 Nginx 、OpenResty 服务器设计。已服务众多中小企业，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;稳定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一行命令，一分钟轻松搞定 SSL 证书自动续期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;&lt;code&gt;v1.18.2&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 版本新特性&lt;/span&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;📚支持 docker 镜像快速部署&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;🤖DNS 异步检测，支持 &lt;/span&gt;&lt;span&gt;&lt;code&gt;西部数码&lt;/code&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;🌐nginx 支持单域名申请&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;span&gt;docker 证书自动续期&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;我们以 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnginx%2Fdocker-nginx%2F" target="_blank"&gt;&lt;span&gt;nginx 官方镜像&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 为基础，制作了集成 httpsok 的 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fhttpsok%2Fnginx" target="_blank"&gt;&lt;span&gt;nginx 自动续签镜像&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;快速开始&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;设置环境变量：&lt;/span&gt;&lt;span&gt;&lt;code&gt;HTTPSOK_TOKEN&lt;/code&gt;&lt;/span&gt;&lt;span&gt;，从 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2F" target="_blank"&gt;&lt;span&gt;httpsok.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 控制枱获取（点击【复制脚本】按钮）&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;compose.yml &lt;/span&gt;&lt;/h3&gt; 
&lt;pre&gt;&lt;span&gt;&lt;span style="color:#221199"&gt;services&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt;  httpsok-nginx&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  container_name&lt;/span&gt;&lt;span style="color:#555555"&gt;: &lt;/span&gt;httpsok-nginx&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  image&lt;/span&gt;&lt;span style="color:#555555"&gt;: &lt;/span&gt;httpsok/nginx&lt;span style="color:#555555"&gt;:&lt;/span&gt;1.28.0-alpine&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  ports&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;&lt;span style="color:#22a2c9"&gt;"80:80"&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;&lt;span style="color:#22a2c9"&gt;"443:443"&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  volumes&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./conf.d:/etc/nginx/conf.d&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./html:/var/html/&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./certs:/etc/nginx/certs&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  environment&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;TZ=Asia/Shanghai&lt;/span&gt;
&lt;span&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style="color:#aa5500"&gt;# 设置 TOKEN，从 httpsok.com 控制枱获取&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;HTTPSOK_TOKEN=&lt;/span&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;span&gt;支持的镜像版本&lt;/span&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.28.0-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.28.0&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.27.5-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.27.5&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.26.2-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.26.2&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.25.5-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.25.5&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.24.0-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.24.0&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;span&gt;成功示例&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;img alt="image-20250917021634188" src="https://oscimg.oschina.net/oscnet//80aeb7a2b848e13a1990c10d85c19098.png" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhttpsok%2Fhttpsok" target="_blank"&gt;&lt;span&gt;仓库地址-github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://gitee.com/httpsok/httpsok"&gt;&lt;span&gt;仓库地址-gitee.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fquickstart.html" target="_blank"&gt;&lt;span&gt;nginx 证书一键自动续期&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fapply.html" target="_blank"&gt;&lt;span&gt;免费申请 SSL 通配符证书&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fcdn.html" target="_blank"&gt;&lt;span&gt;CDN 证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Foss.html" target="_blank"&gt;&lt;span&gt;OSS（对象存储）证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Flb.html" target="_blank"&gt;&lt;span&gt;LB（负载均衡）证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;span&gt;结束&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;如果您觉得 &lt;/span&gt;&lt;span&gt;&lt;code&gt;httpsok&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 对您带来了帮助，还请动动 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;您的发财小手&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 给项目点点 &lt;/span&gt;&lt;span&gt;&lt;code&gt;star&lt;/code&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;也可以把我们的工具，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享给您的小伙伴&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;非常感谢大家的认可和支持🙏🙏🙏。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhttpsok%2Fhttpsok" target="_blank"&gt;&lt;span&gt;仓库地址-github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://gitee.com/httpsok/httpsok"&gt;&lt;span&gt;仓库地址-gitee.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fquickstart.html" target="_blank"&gt;&lt;span&gt;nginx 证书一键自动续期&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fapply.html" target="_blank"&gt;&lt;span&gt;免费申请 SSL 通配符证书&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fcdn.html" target="_blank"&gt;&lt;span&gt;CDN 证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Foss.html" target="_blank"&gt;&lt;span&gt;OSS（对象存储）证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Flb.html" target="_blank"&gt;&lt;span&gt;LB（负载均衡）证书部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372655</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372655</guid>
      <pubDate>Sat, 13 Sep 2025 20:12:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
  </channel>
</rss>
