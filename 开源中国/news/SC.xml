<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 19 Jun 2025 12:48:24 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Roo Code 3.21 发布，官方 Roo Code Marketplace 上线</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Roo Code 3.21&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.roocode.com%2Fupdate-notes%2Fv3.21.0" target="_blank"&gt;已发布&lt;/a&gt;&lt;/u&gt;，带来了官方 Roo Code Marketplace 和 20 多项改进，其中包括对 Gemini 2.5 新模型的支持。&lt;/p&gt; 
&lt;h3&gt;新功能上线&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Roo Marketplace 正式推出&lt;/strong&gt; ：用户无需实验特性即可在 Roo Code 内浏览、安装社区创建的模型上下文协议（MCP）服务器和自定义模式，几下点击就能轻松获取所需工具。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持最新 Gemini 2.5 模型&lt;/strong&gt; ：增加对 Gemini 2.5 Pro（复杂编程任务增强型）、Gemini 2.5 Flash（性能提升的快速模型）、Gemini 2.5 Flash Lite（适用于快速任务的轻量级模型）的支持，提升各类编程任务的推理能力和性能。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持 Excel 文件处理&lt;/strong&gt; ：允许在工具中读取 Excel（.xlsx）文件，直接分析和处理 Excel 电子表格，提取单元格值、公式和工作表信息，并且能与现有 Roo Code 工具和功能无缝集成。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;质量改进&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;OpenAI 最大令牌数选项&lt;/strong&gt; ：在 OpenAI 兼容提供程序设置中添加最大令牌数的复选框选项。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;供应商更新&lt;/strong&gt; ：更新 Groq 和 Mistral 的模型列表及价格信息。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;终端细节改进&lt;/strong&gt; ：终端详情新增当前工作目录，增强上下文感知能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;多文件差异&lt;/strong&gt; ：鼓励使用 start_line 参数以匹配旧版差异行为。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;界面与用户体验优化&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;市场品牌更新&lt;/strong&gt; ：更新市场品牌标识，使其显示为 「Roo Marketplace」，保持品牌一致性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;历史界面重构&lt;/strong&gt; ：重构历史界面，使其更加一致和现代化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;上下文菜单调整&lt;/strong&gt; ：调整上下文菜单位置，使其靠近 GitHub Copilot，方便访问。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;面板焦点优化&lt;/strong&gt; ：点击面板时始终聚焦面板，确保菜单按钮可见。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;Bug 修复&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;API 会话历史修复&lt;/strong&gt; ：为会话历史问题添加适当的错误处理机制。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模型 ID 错误消息修复&lt;/strong&gt; ：修正模糊的模型 ID 错误消息。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;提示设置保存流程修复&lt;/strong&gt; ：修复提示设置的保存/丢弃/还原流程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;代码库索引修复&lt;/strong&gt; ：修正代码库索引与列表文件的隐藏目录过滤对齐问题。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;子任务完成修复&lt;/strong&gt; ：解决子任务与整体任务完成之间的不匹配问题。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Windows MCP 配置修复&lt;/strong&gt; ：修复 Windows 上 MCP 变量注入的路径标准化问题。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;其他改进&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;测试模式更新&lt;/strong&gt; ：更新测试模式以支持 Vitest 测试框架。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;工作目录警告移除&lt;/strong&gt; ：移除关于工作目录更改的不必要警告。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;遥测添加&lt;/strong&gt; ：添加市场标签视图和安装点击跟踪的遥测功能。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Windows Docker 更新&lt;/strong&gt; ：更新评估 Docker 设置，使其在 Windows 上可以正常运行。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;详情查看 https://docs.roocode.com/update-notes/v3.21.0&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356236/roocode-3-21</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356236/roocode-3-21</guid>
      <pubDate>Sun, 11 May 2025 10:38:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马斯克驳斥 xAI 巨额亏损传闻：每月烧钱 10 亿美元纯属无稽之谈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;有媒体报道称，科技巨头埃隆・马斯克创办的人工智能初创公司 xAI 每月烧钱高达 10 亿美元，这一说法引发了广泛关注。消息称，xAI 在构建先进的 AI 模型方面的成本远远超过其收入增长，公司的资金需求愈加迫切。对此，马斯克进行了强烈反驳，称这些报道 「纯属胡说八道」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-34a4735e7445256b266cb4625e29a62693a.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;xAI 自 2023 年成立以来，正积极寻求通过债务和股权融资来填补资金缺口，目标是融资 93 亿美元。尽管如此，马斯克合并了 xAI 与社交媒体平台 X，令合并后的新公司的估值达 1130 亿美元，其中 xAI 的估值为 800 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;根据相关人士透露，xAI 的支出速度在整个 AI 行业中显得尤为显著。公司预计在未来三个月内将花费超过一半的融资金额，而全年亏损预计达到 130 亿美元。相比之下，竞争对手 OpenAI 预计在 2025 年的收入将达到 127 亿美元，而 xAI 在同年仅预计收入 5 亿美元，明年才有可能突破 20 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;马斯克的巨大个人魅力和资源，使得 xAI 有理由保持乐观。他曾在特斯拉和 SpaceX 的早期阶段也经历了类似的巨额亏损，然而这些项目最终都取得了成功。马斯克相信，xAI 将在 2027 年实现盈利，尽管当前仍需与时间赛跑，以应对巨额支出。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;xAI 计划利用与 X 平台的整合，利用其庞大的数据档案来训练 AI 模型，从而降低昂贵的数据费用。虽然目前 xAI 正在进行大规模的资金筹集，但公司对于未来的发展前景充满信心。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356227</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356227</guid>
      <pubDate>Sun, 11 May 2025 10:07:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MoonBit 编程语言 Beta 版正式发布！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;p&gt;MoonBit 编程语言已于今日正式发布 Beta 版本。作为一门专注于工具链构建（特别是 AI 场景）与开发者体验的新一代编程语言，MoonBit 由 IDEA 研究院主导开发，自设计之初便强调结构化、类型安全与高性能可视化调试。&lt;/p&gt; 
 &lt;div&gt;
  目前，MoonBit 已支持 WebAssembly、JavaScript 与原生后端（native)。功能上，它接近 Rust，但内置垃圾回收（GC），并配套高效、健壮的工具链，显著提升开发效率。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  对于希望体验语言特性的用户，MoonBit 官方推出了交互式入门平台 
  &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftour.moonbitlang.com%2F" target="_blank"&gt;MoonBit Tour&lt;/a&gt;，提供内嵌值追踪、即时运行和语法提示等功能，帮助开发者快速上手。
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;Beta 阶段的含义&lt;/h2&gt; 
 &lt;div&gt;
  据 MoonBit 团队介绍，过去两年中，MoonBit 经历了快速迭代与大量实验，语言特性在实践与反馈中逐步沉淀，现已进入稳定阶段。此次 Beta 发布意味着：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    语言已覆盖日常开发所需的关键能力
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    语法层面已趋稳定，后续改动将遵循公开的 RFC 提案流程
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  虽然语言本身已趋稳定，标准库与工具链仍将持续演进。目前，MoonBit 团队正对包命名、模块结构进行整理与优化，以提升语言一致性与可维护性。接下来，团队将重点投入在官方文档完善、包生态扩展与社区协作机制上。
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;异步与错误处理：Beta 中的重要特性&lt;/h2&gt; 
 &lt;div&gt;
  MoonBit 在 Beta 阶段即提供内建的异步机制与静态检查的错误处理模型，这一设计区别于多数语言在正式版之后才补充异步语义的做法。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  该模型具有以下特性：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;安全性&lt;/strong&gt;：所有错误传递均由编译器静态检查
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;简洁性&lt;/strong&gt;：异步函数与常规函数写法一致，无需 
    &lt;code&gt;await&lt;/code&gt; 或其他语法糖
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;可读性&lt;/strong&gt;：IDE 对异步与可能出错的操作进行可视化标注，开发者无需显式声明（例如，错误操作带下划线，异步操作为斜体）
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  官方示例中展示了一个用 MoonBit 编写的简化版 
  &lt;code&gt;cat&lt;/code&gt; 命令，结合了多个异步数据源与错误路径，代码依然保持清晰简洁，体现了语言在可维护性与表现力上的优势。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;img src="https://oscimg.oschina.net/oscnet//80457b66b57b131122f2c0fa278ca618.jpg" referrerpolicy="no-referrer"&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;发展路线与社区协作&lt;/h2&gt; 
 &lt;div&gt;
  MoonBit 项目当前正朝着 1.0 稳步推进，预计将在 2026 年发布正式版本。团队承诺，自 Beta 起，所有语言层级的重要变更都将通过公开的 RFC（Request for Comments）流程，确保透明度与社区参与。
 &lt;/div&gt; 
 &lt;div&gt;
  社区开发者可通过以下方式参与语言建设：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    🐛 
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2Fcore%2Fissues" target="_blank"&gt;提交 bug 报告或改进建议&lt;/a&gt;
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    💬 加入 Discord 社区参与讨论
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    📄 关注并参与
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2Fmoonbit-RFCs" target="_blank"&gt; RFC &lt;/a&gt;提案流程
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    📦 为官方包注册平台 
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmooncakes.io" target="_blank"&gt;mooncakes.io&lt;/a&gt; 贡献组件或库
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  MoonBit 的成长离不开每一位社区成员的参与与反馈。团队表示，期待更多开发者加入 GitHub 与 Discord，共同探索面向未来的编程语言新范式。
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356224/moonbitlang-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356224/moonbitlang-beta</guid>
      <pubDate>Sun, 11 May 2025 09:51:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>Spring Boot 启动优化实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互联网服务器团队- Liu Di&lt;/p&gt; 
 &lt;p&gt;本文系统性分析并优化了一个 Spring Boot 项目启动耗时高达 280 秒的问题。通过识别瓶颈、优化分库分表加载逻辑、异步初始化耗时任务等手段，最终将启动耗时缩短至 159 秒，提升近 50%。文章涵盖启动流程分析、性能热点识别、异步初始化设计等关键技术细节，适用于大型 Spring Boot 项目的性能优化参考。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;文章太长？1 分钟看图抓住核心观点👇&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//de4a19ad8ae5ee03f930e1ffa71b9716.gif" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h1&gt;一、前言&lt;/h1&gt; 
&lt;p&gt;随着业务的发展，笔者项目对应的 Spring Boot 工程的依赖越来越多。随着依赖数量的增长，Spring 容器需要加载更多组件、解析复杂依赖并执行自动装配，导致项目启动时间显著增长。在日常开发或测试过程中，一旦因为配置变更或者其他热部署不生效的变更时，项目重启就需要等待很长的时间影响代码的交付。加快 Spring 项目的启动可以更好的投入项目中，提升开发效率。&lt;/p&gt; 
&lt;p&gt;整体环境介绍：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Spring 版本：4.3.22&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Spring Boot 版本：1.5.19&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;CPU：i5-9500&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;内存：24GB&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;优化前启动耗时：280 秒&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;二、Spring Boot 项目启动流程介绍&lt;/h1&gt; 
&lt;p&gt;Spring Boot 项目主要启动流程都在 org.spring-&lt;/p&gt; 
&lt;p&gt;framework.boot.SpringApplication#run(java.lang.String...) 方法中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // Spring 上下文
    ConfigurableApplicationContext context = null;
    FailureAnalyzers analyzers = null;
    configureHeadlessProperty();
    // 初始化 SpringApplicationRunListener 监听器
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(
                args);
        // 环境准备
        ConfigurableEnvironment environment = prepareEnvironment(listeners,
                applicationArguments);
         // 打印 banner
        Banner printedBanner = printBanner(environment);
        // 创建上下文
        context = createApplicationContext();
        analyzers = new FailureAnalyzers(context);
        // 容器初始化
        prepareContext(context, environment, listeners, applicationArguments,
                printedBanner);
        // 刷新容器内容
        refreshContext(context);
        afterRefresh(context, applicationArguments);
        // 结束监听广播
        listeners.finished(context, null);
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass)
                    .logStarted(getApplicationLog(), stopWatch);
        }
        return context;
    } catch (Throwable ex) {
        handleRunFailure(context, listeners, analyzers, ex);
        throw new IllegalStateException(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到在启动流程中，监听器应用在了应用的多个生命周期中。并且 Spring Boot 中也预留了针对 listener 的扩展点。我们可以借此实现一个自己的扩展点去监听 Spring Boot 的每个阶段的启动耗时，实现如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Slf4j
public class MySpringApplicationRunListener implements SpringApplicationRunListener{
    private Long startTime;
    public MySpringApplicationRunListener(SpringApplication application, String[] args){
    }
    @Override
    public void starting(){
        startTime = System.currentTimeMillis();
        log.info("MySpringListener 启动开始 {}", LocalTime.now());
    }
    @Override
    public void environmentPrepared(ConfigurableEnvironment environment){
        log.info("MySpringListener 环境准备，准备耗时：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
    @Override
    public void contextPrepared(ConfigurableApplicationContext context){
        log.info("MySpringListener 上下文准备，耗时：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
    @Override
    public void contextLoaded(ConfigurableApplicationContext context){
        log.info("MySpringListener 上下文载入，耗时：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
   @Override
   public void finished(ConfigurableApplicationContext context, Throwable exception){
        log.info("MySpringListener 结束，耗时：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;接着还需要在 classpath/META-INF 目录下新建 spring.factories 文件，并添加如下文件内容：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;org.springframework.boot.SpringApplicationRunListener=com.vivo.internet.gameactivity.api.web.MySpringApplicationRunListener
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;至此，借助 Listener 机制，我们能够追踪 Spring Boot 启动各阶段的耗时分布，为后续性能优化提供数据支撑。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e19075cd485d32e7d5029945fd7ba604.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;contextLoaded 事件是在 run 方法中的 prepareContext() 结束时调用的，因此 contextLoaded 事件和 finished 事件之间仅存在两个语句：refreshContext(context) 和 afterRefresh&lt;/p&gt; 
&lt;p&gt;(context,applicationArguements) 消耗了 285 秒的时间，调试一下就能发现主要耗时在 refreshContext() 中。&lt;/p&gt; 
&lt;h1&gt;三、AbstractApplicationContext#refresh&lt;/h1&gt; 
&lt;p&gt;refreshContext() 最终调用到 org.spring-framework.context.support.AbstractApplicationContext#refresh 方法中，这个方法主要是 beanFactory 的预准备、对 beanFactory 完成创建并进行后置处理、向容器添加 bean 并且给 bean 添加属性、实例化所有 bean。通过调试发现，finishBeanFactoryInitialization(beanFactory) 方法耗时最久。该方法负责实例化容器中所有的单例 Bean，是启动性能的关键影响点。&lt;/p&gt; 
&lt;h1&gt;四、找出实例化耗时的 Bean&lt;/h1&gt; 
&lt;p&gt;Spring Boot 也是利用的 Spring 的加载流程。在 Spring 中可以实现 InstantiationAwareBeanPost-&lt;/p&gt; 
&lt;p&gt;Processor 接口去在 Bean 的实例化和初始化的过程中加入扩展点。因此我们可以实现该接口并添加自己的扩展点找到处理耗时的 Bean。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Service
public class TimeCostCalBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
    private Map&amp;lt;String, Long&amp;gt; costMap = Maps.newConcurrentMap();

    @Override
    public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        if (!costMap.containsKey(beanName)) {
            costMap.put(beanName, System.currentTimeMillis());
        }
        return null;
    }
    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        return true;
    }
    @Override
    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
        return pvs;
    }
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
         if (costMap.containsKey(beanName)) {
            Long start = costMap.get(beanName);
            long cost = System.currentTimeMillis() - start;
            // 只打印耗时长的 bean
             if (cost &amp;gt; 5000) {
                System.out.println("bean: " + beanName + "\ttime: " + cost + "ms");
            }
        }
         return bean;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体原理就是在 Bean 开始实例化之前记录时间，在 Bean 初始化完成后记录结束时间，打印实例化到初始化的时间差获得 Bean 的加载总体耗时。结果如图：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//28a73a7adfed28c5eff40855c8260121.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;可以看到有许多耗时在 10 秒以上的类，接下来可以针对性的做优化。值得注意的是，统计方式为单点耗时计算，未考虑依赖链上下文对整体加载顺序的影响，实际优化还需结合依赖关系分析。&lt;/p&gt; 
&lt;h1&gt;五、singletonDataSource&lt;/h1&gt; 
&lt;pre&gt;&lt;code&gt;@Bean(name = "singletonDataSource")
public DataSource singletonDataSource(DefaultDataSourceWrapper dataSourceWrapper) throws SQLException {
    //先初始化连接
    dataSourceWrapper.getMaster().init();
    //构建分库分表数据源
    String dataSource0 = "ds0";
    Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;();
    dataSourceMap.put(dataSource0, dataSourceWrapper.getMaster());
    //分库分表数据源
    DataSource shardingDataSource = ShardingDataSourceFactory.createDataSource
    (dataSourceMap,shardingRuleConfiguration, prop);
    return shardingDataSource;    
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;singletonDataSource 是一个分库分表的数据源，连接池采用的是 Druid，分库分表组件采用的是公司内部优化后的中间件。通过简单调试代码发现，整个 Bean 耗时的过程发生在 createDataSource 方法，该方法中会调用 createMetaData 方法去获取数据表的元数据，最终运行到 loadDefaultTables 方法。该方法如下图，会遍历数据库中所有的表。因此数据库中表越多，整体就越耗时。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//05283b802a6c9c0a6c8653f9a7f080cd.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;笔者的测试环境数据库中有很多的分表，这些分表为了和线上保持一致，分表的数量都和线上是一样的。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//eee1a3f0f0dd73861b2894776a40850b.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;因此在测试环境启动时，为了加载这些分表会更加的耗时。可通过将分表数量配置化，使测试环境在不影响功能验证的前提下减少分表数量，从而加快启动速度。&lt;/p&gt; 
&lt;h1&gt;六、初始化异步&lt;/h1&gt; 
&lt;p&gt;activityServiceImpl 启动中，主要会进行活动信息的查询初始化，这是一个耗时的操作。类似同样的操作在工程的其他类中也存在。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Service
public class ActivityServiceImpl implements ActivityService, InitializingBean{
     // 省略无关代码
     @Override
     public void afterPropertiesSet() throws Exception {
        initActivity();
    }
     // 省略无关代码
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以通过将 afterPropertiesSet() 异步化的方式加速项目的启动。&lt;/p&gt; 
&lt;p&gt;观察 Spring 源码可以注意到 afterPropertiesSet 方法是在 AbstractAutowireCapableBeanFactory#&lt;/p&gt; 
&lt;p&gt;invokeInitMethods 中调用的。在这个方法中，不光处理了 afterPropertiesSet 方法，也处理了 init-method。&lt;/p&gt; 
&lt;p&gt;因此我们可以写一个自己的 BeanFactory 继承 AbstractAutowireCapableBeanFactory，将 invokeInitMethods 方法进行异步化重写。考虑到 AbstractAutowireCapableBeanFactory 是个抽象类，有额外的抽象方法需要实现，因此继承该抽象类的子类 DefaultListableBeanFactory。具体实现代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncInitListableBeanFactory extends DefaultListableBeanFactory{
     public AsyncInitBeanFactory(ConfigurableListableBeanFactory beanFactory){
         super(beanFactory);
    }
     @Override
     protected void invokeInitMethods(String beanName, Object bean, RootBeanDefinition mbd)throws Throwable {
        if (beanName.equals("activityServiceImpl")) {
            AsyncTaskExecutor.submitTask(() -&amp;gt; {
                try {
                      super.invokeInitMethods(beanName, bean, mbd);
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }
            });
        } else {
              super.invokeInitMethods(beanName, bean, mbd);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;又因为 Spring 在 refreshContext() 方法之前的 prepareContext() 发放中针对 initialize 方法提供了接口扩展 (applyInitializers())。因此我们可以通过实现该接口并将我们的新的 BeanFactory 通过反射的方式更新到 Spring 的初始化流程之前。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public interface ApplicationContextInitializer&amp;lt;C extends ConfigurableApplicationContext&amp;gt; {
     /**
     * Initialize the given application context.
     * @param applicationContext the application to configure
     */
    void initialize(C applicationContext);

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;改造后的代码如下，新增 AsyncAccelerate-&lt;/p&gt; 
&lt;p&gt;Initializer 类实现 ApplicationContextInitializer 接口：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncBeanFactoryInitializer implements ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt; {
    @SneakyThrows
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext){
        if (applicationContext instanceof GenericApplicationContext) {
            AsyncInitListableBeanFactory beanFactory = new AsyncInitListableBeanFactory(applicationContext.getBeanFactory());
            Field field = GenericApplicationContext.class.getDeclaredField("beanFactory");
            field.setAccessible(true);
            field.set(applicationContext, beanFactory);
        }
    }
}
public class AsyncBeanInitExecutor{
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final AtomicReference&amp;lt;ThreadPoolExecutor&amp;gt; THREAD_POOL_REF = new AtomicReference&amp;lt;&amp;gt;();
    private static final List&amp;lt;Future&amp;lt;?&amp;gt;&amp;gt; FUTURES = new ArrayList&amp;lt;&amp;gt;();
     /**
      * 创建线程池实例
      */
     private static ThreadPoolExecutor createThreadPoolExecutor(){
         int poolSize = CPU_COUNT + 1;
         return new ThreadPoolExecutor(poolSize, poolSize, 50L, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;&amp;gt;(), new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
    /**
     * 确保线程池已初始化（线程安全）
     */
     private static void ensureThreadPoolExists(){
         if (THREAD_POOL_REF.get() != null) {
              return;
        }
        ThreadPoolExecutor executor = createThreadPoolExecutor();
         if (!THREAD_POOL_REF.compareAndSet(null, executor)) {
            executor.shutdown(); // 另一线程已初始化成功
        }
    }
    /**
     * 提交异步初始化任务
     *
     * @param task 初始化任务
     * @return 提交后的 Future 对象
     */
    public static Future&amp;lt;?&amp;gt; submitInitTask(Runnable task) {
        ensureThreadPoolExists();
        Future&amp;lt;?&amp;gt; future = THREAD_POOL_REF.get().submit(task);
        FUTURES.add(future);
        return future;
    }
    /**
     * 等待所有初始化任务完成并释放资源
     */
    public static void waitForInitTasks(){
        try {
            for (Future&amp;lt;?&amp;gt; future : FUTURES) {
                future.get();
            }
        } catch (Exception ex) {
            throw new RuntimeException("Async init task failed", ex);
        } finally {
            FUTURES.clear();
            shutdownThreadPool();
        }
    }
     /**
     * 关闭线程池并重置引用
     */
     private static void shutdownThreadPool(){
        ThreadPoolExecutor executor = THREAD_POOL_REF.getAndSet(null);
         if (executor != null) {
            executor.shutdown();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;实现类后，还需要在 META-INF/spring.factories 下新增说明 org.springframework.context.&lt;/p&gt; 
&lt;p&gt;ApplicationContextInitializer=com.xxx.AsyncAccelerateInitializer，这样这个类才能真正生效。&lt;/p&gt; 
&lt;p&gt;这样异步化以后还有一个点需要注意，如果该初始化方法执行耗时很长，那么会存在 Spring 容器已经启动完成，但是异步初始化任务没执行完的情况，可能会导致空指针等异常。为了避免这种问题的发生，还要借助于 Spring 容器启动中 finishRefresh() 方法，监听对应事件，确保异步任务执行完成之后，再启动容器。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncInitCompletionListener implements ApplicationListener&amp;lt;ContextRefreshedEvent&amp;gt;, ApplicationContextAware, PriorityOrdered{
    private ApplicationContext currentContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext)throws BeansException {
         this.currentContext = applicationContext;
    }
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event){
        if (event.getApplicationContext() == currentContext) {
            AsyncBeanInitExecutor.waitForInitTasks();
        }
    }
    @Override
    public int getOrder(){
         return Ordered.HIGHEST_PRECEDENCE;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h1&gt;七、总结&lt;/h1&gt; 
&lt;p&gt;启动优化后的项目实际测试结果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//2f535724d8b21204e9e881711c6acf6f.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;通过异步化初始化和分库分表加载优化，项目启动时间从 280 秒缩短至 159 秒，提升约 50%。这对于提升日常开发效率、加快测试与联调流程具有重要意义。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/vivotech/blog/18627678</link>
      <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18627678</guid>
      <pubDate>Sun, 11 May 2025 09:43:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Workout.cool —— 现代开源健身教练平台</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;一个全面的健身指导平台，可以为你制定锻炼计划、跟踪进度并访问包含详细说明和视频演示的庞大锻炼数据库。&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;项目包含一个全面的练习数据库。要导入练习样本，请执行以下操作：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;导入的先决条件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;准备 CSV 文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;你的 CSV 应该包含以下列：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;id,name,name_en,description,description_en,full_video_url,full_video_image_url,introduction,introduction_en,slug,slug_en,attribute_name,attribute_value
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可以使用提供的示例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;导入命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;#&lt;/span&gt;&lt;/span&gt; Import exercises from a CSV file&lt;/span&gt;&lt;/span&gt;
pnpm run import:exercises-full /path/to/your/exercises.csv

&lt;span&gt;&lt;span style="color:#59636e"&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;#&lt;/span&gt;&lt;/span&gt; Example with the provided sample data&lt;/span&gt;&lt;/span&gt;
pnpm run import:exercises-full ./data/sample-exercises.csv&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CSV 格式示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;id,name,name_en,description,description_en,full_video_url,full_video_image_url,introduction,introduction_en,slug,slug_en,attribute_name,attribute_value
157,"Fentes arrières à la barre","Barbell Reverse Lunges","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;",https://youtube.com/...,https://img.youtube.com/...,slug-fr,slug-en,TYPE,STRENGTH
157,"Fentes arrières à la barre","Barbell Reverse Lunges","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;",https://youtube.com/...,https://img.youtube.com/...,slug-fr,slug-en,PRIMARY_MUSCLE,QUADRICEPS&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可用的属性类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TYPE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;STRENGTH&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;CARDIO&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;PLYOMETRICS&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;STRETCHING&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRIMARY_MUSCLE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;QUADRICEPS&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;CHEST&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BACK&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;SHOULDERS&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SECONDARY_MUSCLE&lt;/strong&gt;: Secondary muscle groups targeted&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EQUIPMENT&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BARBELL&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;DUMBBELL&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BODYWEIGHT&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;MACHINE&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MECHANICS_TYPE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;COMPOUND&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;ISOLATION&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/workout-cool</link>
      <guid isPermaLink="false">https://www.oschina.net/p/workout-cool</guid>
      <pubDate>Sun, 11 May 2025 08:20:00 GMT</pubDate>
    </item>
    <item>
      <title>MoonBit 正式进入 Beta 版本，迈入语言稳定阶段</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;IDEA 研究院编程语言 MoonBit &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fblog%2Fbeta-release" target="_blank"&gt;宣布推出 Beta 版本&lt;/a&gt;，正式迈入可落地应用的新阶段，并逐步演进为&lt;strong&gt;可被实际部署的基础设施技术。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-fb44018fd10f40a81f0db905688512c73fa.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;进入 Beta 版本的 MoonBit，具备以下优势特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;语言特性进入稳定期&lt;/strong&gt;：目前 MoonBit 已覆盖工业级开发所需的语言特性与工具链支持。现有语法和语义将保持向后兼容，未来的更新将尽量避免破坏性修改。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;改进流程更标准化&lt;/strong&gt;：语言层面的进一步优化将通过公开、透明的 RFC 流程与社区共同讨论，确保演进方向清晰、稳定、可协作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;异步支持三大优势&lt;/strong&gt;：MoonBit 在语言层面提供了错误处理与异步编程的支持。MoonBit 对错误处理和异步编程的支持有三大优势。 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;大部分编程语言在静态分析中，彻底放弃错误处理的支持，这意味着任何函数都可以抛出异常，很难写出高可靠性的代码，MoonBit 通过准确的控制流分析，可以完全在编译时期跟踪函数的错误，用户只需要在顶层标记用作文档的签名。这一过程几乎完全由编译器自行推导，而又不像 Java checked exception 那样过于繁琐，对用户带来较高的心智负担；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;编写便捷性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;在 MoonBit 中，带有错误和异步操作的函数使用起来就像普通函数一样便利，无需任何特殊标记，也无需修改程序结构；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;可读性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;MoonBit IDE 会给带错误的函数标注「下划线」、并将异步函数标记为「&lt;em&gt;斜体&lt;/em&gt;」。用户在编写代码时无需写任何特殊标注，但依然能在阅读代码时快速定位到带有错误/异步的关键操作。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Beta 版：工具链打磨与语言层面深度融合&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fblog%2Fbeta-release%23beta-%25E7%2589%2588%25E5%25B7%25A5%25E5%2585%25B7%25E9%2593%25BE%25E6%2589%2593%25E7%25A3%25A8%25E4%25B8%258E%25E8%25AF%25AD%25E8%25A8%2580%25E5%25B1%2582%25E9%259D%25A2%25E6%25B7%25B1%25E5%25BA%25A6%25E8%259E%258D%25E5%2590%2588" target="_blank"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;作为最早支持 WebAssembly 的编程语言之一，MoonBit 天然契合&lt;strong&gt;高性能、低延迟、跨平台&lt;/strong&gt;的分布式系统开发需求。在浏览器、边缘节点和轻量微服务等场景中，MoonBit 可通过 Wasm 实现快速部署与高度可移植性，同时保持极低运行时开销，为「&lt;strong&gt;一次编写，任意运行&lt;/strong&gt;」的开发模式提供了切实可行的路径。&lt;/p&gt; 
&lt;p&gt;更重要的是，MoonBit 还带来了具备「&lt;strong&gt;修改即响应&lt;/strong&gt;」特性的即时反馈开发体验。开发者可直接在 Web 环境中编写、运行与调试代码，极大提升开发效率。这种体验目前在主流语言体系中仍属稀缺，也正是 MoonBit 在工具链打磨与语言层面深度融合下取得的重要成果。&lt;/p&gt; 
&lt;p&gt;下面是一个著名命令行程序&lt;code&gt;cat&lt;/code&gt;的简单版的 MoonBit 实现。这段程序包含了对多个不同来源操作的错误处理、异步操作等，实际控制流非常复杂。但在 MoonBit 中，这段程序编写起来非常自然简洁，没有任何语法噪音。同时，得益于语法着色，阅读代码时很容易捕捉到几处异步/带错误的关键操作。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;async fn cat(files : ArrayView[String]) -&amp;gt; Unit raise {
  if files is [] {
    @async.stdin.read_streaming() // read from stdin only once
  } else {
    for file in files {
      if file is "-" {
        @async.stdin.read_streaming() // read from stdin
        continue
      } else {
        @async.path(file).read_all()
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;下载地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fdownload%2F" target="_blank"&gt;https://www.moonbitlang.cn/download/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;在线使用：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftry.moonbitlang.cn%2F" target="_blank"&gt;https://try.moonbitlang.cn/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356201/moonbit-language-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356201/moonbit-language-beta</guid>
      <pubDate>Sun, 11 May 2025 07:53:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenBMB 开源轻量级 CUDA 推理框架 CPM.cu</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenBMB 推出了 CPM.cu，这是一个轻量级且高效的开源 CUDA 推理框架，专为端侧大型语言模型（LLMs）的部署而设计，并为&lt;a href="https://www.oschina.net/news/354328"&gt;MiniCPM4&lt;/a&gt;提供优化，核心支持&lt;strong&gt;稀疏架构&lt;/strong&gt;、&lt;strong&gt;投机采样&lt;/strong&gt;和&lt;strong&gt;低位宽量化&lt;/strong&gt;等前沿技术创新。&lt;/p&gt; 
&lt;p&gt;CPM.cu 亮点包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;集成了 InfLLM v2 可训练稀疏注意力内核，可加速长上下文预填充和解码；&lt;/li&gt; 
 &lt;li&gt;FR-Spec（频率排序推测采样）通过压缩词汇空间提高草稿效率，显著降低计算开销；&lt;/li&gt; 
 &lt;li&gt;结合了 EAGLE-2 推测采样、4 位量化和基于滑动窗口注意力的长上下文支持，从而在资源受限设备上实现高效部署。&lt;/li&gt; 
 &lt;li&gt;性能方面，在 128K-token 序列上，预填充速度比 Qwen3-8B 快 2-4 倍，解码速度快 4-6 倍。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;CPM.cu&amp;nbsp; 框架结构：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CPM.cu/
├── src/
│   ├── flash_attn/ # 修改后的 Flash-Attention, 支持稀疏和投机采样
│   ├── model/
│   │   ├── minicpm4/ # minicpm4 模型
│   │   │   ├── minicpm4_model.cuh # 模型的核心实现
│   │   │   └── minicpm4_eagle.cuh # 投机采样实现
│   │   ├── model.cuh # 其他代表性模型
│   │   ├── w4a16_gptq_marlin/ # GPTQ 量化计算 kernel
│   │   ├── memory.cuh # 显存分配
│   │   └── layer.cuh # 通用层
│   ├── entry.cu # pybind: 连接 C/CUDA 和 Python
│   └── ...
├── cpmcu/ # python interface
└── ...&lt;/code&gt;&lt;/pre&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;cpmcu/ 代码提供了一个 python 的调用接口，里面涉及在 Python 侧 tokenize，调用 C 代码得到模型的输出 logits，在 Python 侧根据 logits 采样并 detokenize 这些过程。我们使用了 pybind 将 C 代码与 Python 代码进行绑定。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/memory.cuh 这里实现了整个推理框架的内存管理，这里我们采用了先分配模型权重，再分配模型中间计算结果所需的空间，最后把所有剩余显存分配给 kv-cache 的内存管理策略。这一点设计上是和 vLLM, SGLang 类似的。分配中间计算结果的空间时可以考虑一下中间计算结果的生命周期，做一点显存复用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/w4a16_gptq_marlin/ 量化的计算 kernel。这里直接使用了 vLLM 的 Marlin 代码。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/minicpm4/ 这里是模型的架构实现。src/model/下也有其他代表性模型实现。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/flash_attn/ 我们基于 flash_attn 2.6.3 版本，在上面增加了对 InfLLM v2、投机采样的适配支持。下面我们主要介绍这一部分，也是整个框架实现的难点。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;开源地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenBMB%2FCPM.cu" target="_blank"&gt;https://github.com/OpenBMB/CPM.cu&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356197</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356197</guid>
      <pubDate>Sun, 11 May 2025 07:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源模型上下文协议 MCP 更新规范文档，添加对结构化工具输出的支持</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源模型上下文协议 MCP 昨天更新了规范文档，主要变更如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;移除对 JSON-RPC 批处理的支持（PR #416）&lt;/li&gt; 
 &lt;li&gt;添加对结构化工具输出的支持（PR #371）&lt;/li&gt; 
 &lt;li&gt;将 MCP 服务器归类为 OAuth 资源服务器，添加受保护资源元数据以发现相应的授权服务器。（PR #338）&lt;/li&gt; 
 &lt;li&gt;要求 MCP 客户端按照 RFC 8707 中描述的方式实现资源指示器，以防止恶意服务器获取访问令牌。（PR #734）&lt;/li&gt; 
 &lt;li&gt;在授权规范中阐明安全注意事项和最佳实践，并在新的安全最佳实践页面中说明。&lt;/li&gt; 
 &lt;li&gt;增加引导支持，使服务器能够在交互过程中向用户请求更多信息。（PR #382）&lt;/li&gt; 
 &lt;li&gt;在工具调用结果中增加资源链接支持。（PR #603）&lt;/li&gt; 
 &lt;li&gt;在使用 HTTP 时，后续请求中需通过&amp;nbsp;&lt;code&gt;MCP-Protocol-Version&lt;/code&gt;&amp;nbsp;头指定协商的协议版本。（PR #548）&lt;/li&gt; 
 &lt;li&gt;将生命周期操作中的 SHOULD 改为 MUST&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;详情查看&amp;nbsp;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelcontextprotocol.io%2Fspecification%2F2025-06-18%2Fchangelog" target="_blank"&gt;https://modelcontextprotocol.io/specification/2025-06-18/changelog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356195</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356195</guid>
      <pubDate>Sun, 11 May 2025 07:33:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源代码编辑器 Zed 上线「调试器」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源代码编辑器 Zed &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fdebugger" target="_blank"&gt;宣布&lt;/a&gt;&lt;/u&gt;推出「调试器（Debugger）」功能，称这是向 Zed 1.0 迈出的重要一步。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;调试器特性&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;快速&lt;/strong&gt; ：减少上下文切换时间，让用户能更专注于调试。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;熟悉&lt;/strong&gt; ：与 Zed 的设计语言保持一致，支持典型的调试流程，方便用户快速上手。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;可配置&lt;/strong&gt; ：用户可自定义 UI、键绑定、调试配置等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-43c899b5d73c5470109aecf601bbff05ba7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，Zed 开箱即支持调试多种流行编程语言，包括 Rust、C/C++、JavaScript、Go 和 Python。通过扩展系统，Zed 可以支持任何实现调试适配器协议（DAP）的调试适配器。&lt;/p&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;技术架构&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   采用两层架构，数据层与调试适配器直接通信，UI 层从数据层获取数据进行界面渲染。
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   数据层负责维护会话状态、缓存响应、使失效数据，UI 层按需请求数据，避免不必要的请求，便于后续实现协作调试。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;调试适配器集成&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   扩展了 Zed 的扩展 API 以支持调试器集成，通过定义自定义架构等方式，让扩展作者能轻松将调试适配器集成到 Zed 中。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;内联变量值实现&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   利用 Tree-sitter 查询准确识别当前执行范围内的变量，无需依赖 LSP 服务器与调试适配器的紧密集成，目前支持 Python、Rust、Go 等语言。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;详情查看文档：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fdocs%2Fdebugger" target="_blank"&gt;https://zed.dev/docs/debugger&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356190/zed-debugger</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356190/zed-debugger</guid>
      <pubDate>Sun, 11 May 2025 06:59:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源 Rust 浏览器引擎 Servo 支持 GIF</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Servo 是一款开源的浏览器引擎，最初由 Mozilla 开发。它使用 Rust 语言编写，旨在提供高效、安全的网页渲染能力，并且采用并行渲染技术，以提高网页加载速度和性能。&lt;/p&gt; 
&lt;p&gt;近日，Servo 团队介绍了最近的更新内容，其中一项重要新功能是&lt;strong&gt;支持显示动态 GIF&lt;/strong&gt;，并且还可以通过 HTML "img"标签加载 SVG 图像。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0619/142856_yG2V_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Servo 还在推进其 Trusted Types API、输入类型 &amp;lt;input type=color&amp;gt; 支持、更好的布局和 CSS 支持，以及支持各种其他 API 和功能。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-958f8cd0cc574887e5f2e0cc055fb9586cf.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Servo 还在继续努力提升围绕 Servo 嵌入支持的开发者体验，以 Servo 作为 Chromium 的 CEF 替代方案在应用程序中利用 Servo。&lt;/p&gt; 
&lt;p&gt;详情查看&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fservo.org%2Fblog%2F2025%2F06%2F18%2Fthis-month-in-servo%2F" target="_blank"&gt;https://servo.org/blog/2025/06/18/this-month-in-servo/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356185/servo-may-2025-animated-gifs</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356185/servo-may-2025-animated-gifs</guid>
      <pubDate>Sun, 11 May 2025 06:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Qt Creator 17 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Qt Creator 17 现已发布，&lt;span style="color:#000000"&gt;一些亮点更新内容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;General&lt;/h4&gt; 
&lt;p&gt;在 Qt Creator 15 中引入并在 Qt Creator 16 中更新的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-15-released%3FhsLang%3Den" target="_blank"&gt;「2024」浅色和深色主题&lt;/a&gt;现已成为默认主题。用户仍然可以使用 Preferences &amp;gt; Environment &amp;gt; Interface &amp;gt; Theme 来选择其他主题。已审核并更新了 Qt Creator 中的图标，以与新的视觉风格保持一致，并实现更一致的用户界面。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" height="382" src="https://oscimg.oschina.net/oscnet/up-806935a7e5b640cd078f2e4a9533addd625.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;已将扩展的默认注册表移至&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fqt-creator%2Fextension-registry" target="_blank"&gt;GitHub&lt;/a&gt;。用户现在可以在 Preferences &amp;gt; Extensions &amp;gt; Browser 中设置扩展的多个来源，但使用风险需自负。同时，项目团队还扩展了尚未安装的扩展的显示信息，用户可以直接将扩展的存档拖放到「扩展」模式进行安装。&lt;/p&gt; 
&lt;h4&gt;Projects&lt;/h4&gt; 
&lt;p&gt;Qt Creator 17 中一个比较大的变化是，将运行配置设为构建配置的一部分。在此之前，构建配置和运行配置完全独立。现在，每个运行配置都属于一个特定的构建配置，切换活动的构建配置也会切换可用的运行配置集。这涵盖了经常需要使用不同运行参数的用例，例如不同的命令行参数或针对不同构建配置（例如 Debug 或 Release）所需的不同环境。&lt;/p&gt; 
&lt;p&gt;此外，现在可以使用新的「&lt;span style="color:#09102b"&gt;Clone into This&lt;/span&gt;」按钮将值从一个运行配置复制到另一个运行配置，而不管它们属于哪个构建配置。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;CMake&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;添加了一个选项，当 CMake 配置因缺少 Qt 软件包而失败时，可以使用 Qt 在线安装程序（如果 Qt Creator 已链接到该安装程序）安装缺失的 Qt 组件。此功能依赖于 Qt Creator 中的 Preferences &amp;gt; CMake &amp;gt; General &amp;gt; Package manager auto setup 功能，该功能要求使用 Qt Creator 中的 CMake 配置项目。有关此功能以及 Qt Creator 中 CMake 支持的其他改进的更多信息，可查看&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-17-cmake-update%3FhsLang%3Den" target="_blank"&gt;单独的博客文章&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;添加了在 Qt Creator 中打开基于&lt;code&gt;pyproject.toml&lt;/code&gt;项目的支持。现在，通过 Qt Creator 的项目向导创建的新 PySide 项目也默认打开 pyproject.toml。同时也支持打开基于&lt;code&gt;.pyproject&lt;/code&gt;的 PySide 项目。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Editing&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将预构建的二进制文件切换至 LLVM 20.1.3，以获得更新的 C++ 支持。新增了一些快速修复，用于将&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.qt.io%2Fqt-6%2Fqt-literals-stringliterals.html" target="_blank"&gt;Qt 的字符串字面量运算符&lt;/a&gt;（例如「_ba」或「_L1」）添加到字符串字面量中。还修复了一些与&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugreports.qt.io%2Fbrowse%2FQTCREATORBUG-32667" target="_blank"&gt;function-like built-ins&lt;/a&gt;&amp;nbsp;和&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugreports.qt.io%2Fbrowse%2FQTCREATORBUG-32598" target="_blank"&gt;function-like macros&lt;/a&gt;&lt;span style="color:#09102b"&gt;&amp;nbsp;的&lt;/span&gt;问题。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;QML&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;现在，Preferences &amp;gt; Qt Quick &amp;gt; Code Style 中的代码样式选项允许使用集成到 QML 语言服务器的 qmlformat 进行代码格式化，以及内置格式化程序和自定义的、兼容 qmlformat 的格式化程序。现在还可以通过上下文菜单和 Tools &amp;gt; QML/JS 菜单重新格式化文档。&lt;/p&gt; 
&lt;p&gt;QML 代码编辑器的工具栏上有一个新的&lt;code&gt;.ui.qml&lt;/code&gt;文件按钮，可以在 Qt Design Studio 中打开文件。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Version Control&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;对于 Git 版本控制，添加了各种「diff」操作的变体，这些操作适用于已暂存的更改，而非未暂存的更改。「Instant Blame」的工具提示现在新增了用于还原更改的操作，Add Tag 对话框现在也可以创建带注释的标签。&lt;/p&gt; 
&lt;p&gt;更多详情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-17-released" target="_blank"&gt;查看官方公告&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356182/qt-creator-17-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356182/qt-creator-17-released</guid>
      <pubDate>Sun, 11 May 2025 06:24:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源游戏引擎 Godot 4.5 beta 1 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源游戏引擎 Godot 4.5 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Farticle%2Fdev-snapshot-godot-4-5-beta-1%2F" target="_blank"&gt;发布了首个 Beta 更新&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1a2f0c1591c9660839ac2bc0e69402a7647.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2c8b42310278dcb1ea2ce6d7e8611e46f25.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下是 Godot 4.5 beta 版本的更新亮点&lt;/p&gt; 
&lt;h3&gt;新功能&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;支持导出变量为 Variant 类型&lt;/strong&gt; ：此前数组和字典虽技术上支持 Variant 值，但无法直接导出 Variant 类型变量，现在可通过修改导出变量类型实现，为用户提供了更大的灵活性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;标签的堆叠轮廓效果&lt;/strong&gt; ：以往添加文本的轮廓或阴影效果时选择有限，现在支持在 Label 上添加多层堆叠的轮廓效果，无需再通过堆叠多个文本对象来实现，操作更简便。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;基于环境光的镜面遮挡&lt;/strong&gt; ：渲染器新增了基于环境光的镜面遮挡功能，可使某些金属或反射材质在该遮挡生效时不再出现不自然的反射，且该功能可通过项目设置中的切换按钮进行开关。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;内联颜色选择器&lt;/strong&gt; ：在脚本编辑器中为导出色彩变量添加了内联颜色选择器，用户无需在检查器中查看，即可直观地看到变量所代表的颜色，使代码编写更加直观。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;动画改进&lt;/strong&gt; ：如动画播放器添加字母排序功能、动画编辑器添加动画过滤功能等，提升了动画制作的便利性和效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;对 Apple Vision Pro 的原生支持&lt;/strong&gt; ：Godot 4.5 Beta 版本中，visionOS 成为近十年来首个被 Godot 引擎正式纳入支持的平台，为开发者打开了 XR 游戏开发的新大门。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;改进&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;编辑器改进&lt;/strong&gt; ：增加了将主菜单折叠到菜单按钮的编辑器设置；默认启用了外部更改时的自动重载脚本功能；添加了在编辑器资源选择器中快速加载的按钮等，提升了编辑器的易用性和工作效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;图形用户界面改进&lt;/strong&gt; ：如添加了文件对话框中的文件排序功能；添加了控制在焦点事件上显示虚拟键盘的属性；添加了使用 Ctrl+中键进行拖动缩放的功能等，优化了用户在图形界面操作时的体验。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;导入改进&lt;/strong&gt; ：使用 libjpeg-turbo 替代原有的 jpeg 编解码器，提高了兼容性和速度；为纹理资源导入添加了通道重映射设置，为资源导入提供了更多的灵活性和控制。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;网络改进&lt;/strong&gt; ：修复了 mbedTLS 中与 TLS 相关的并发问题，提高了网络功能的稳定性和可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;粒子系统改进&lt;/strong&gt; ：对光照、贴花和粒子碰撞器的剔除掩码内部机制进行了大修，优化了粒子系统的性能和效果。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;渲染改进&lt;/strong&gt; ：添加了将网格添加到显存占用分析器中；允许在没有运动矢量的情况下移动网格；在正向 + 渲染路径中，用 DFG LUT 替换了当前的 BRDF 近似，并添加了多散射能量补偿等，提升了渲染的质量和性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;着色器改进&lt;/strong&gt; ：公开了内置的区域信息，使着色器编程更加灵活和强大，为开发者提供了更多的创作空间。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;修复&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;修复了调试时对类型化字典的调试问题。&lt;/li&gt; 
 &lt;li&gt;修复了崩溃处理程序中打印脚本回溯的问题。&lt;/li&gt; 
 &lt;li&gt;修复了资源复制的问题。&lt;/li&gt; 
 &lt;li&gt;修复了字符串序列化问题。&lt;/li&gt; 
 &lt;li&gt;修复了多通道音频重采样问题。&lt;/li&gt; 
 &lt;li&gt;修复了 Android 平台相关问题，如更新 NDK 版本、移除某些导出选项等。&lt;/li&gt; 
 &lt;li&gt;修复了在非监控区域使用 Jolt 物理时的性能问题。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下载地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Fdownload%2Farchive%2F4.5-beta1%2F" target="_blank"&gt;https://godotengine.org/download/archive/4.5-beta1/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356177/godot-4-5-beta-1-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356177/godot-4-5-beta-1-released</guid>
      <pubDate>Sun, 11 May 2025 06:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>美国科技巨头推动联邦立法，禁止各州单独监管 AI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《金融时报》报道称，近日美国多家大型科技公司正积极推动一项联邦禁令，旨在禁止各州自行制定人工智能（AI）监管法规。此次立法倡议得到了亚马逊、谷歌、微软和 Meta 等公司的支持，目的是避免各州在 AI 监管方面各自为政，影响行业的整体发展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;知情人士透露，这项禁令提案已经被纳入众议院版本的 「大而美」 预算法案中。参议院也计划在近期推出自己的版本，并希望能够在 7 月 4 日之前完成相关立法工作。前联邦众议员、现任 INCOMPAS 首席执行官 Chip Pickering 是这项提案的重要推动者，他表示，保持美国在技术领域的领导地位是确保国家竞争力的关键。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;INCOMPAS 组织于 2024 年成立了 「人工智能竞争中心」（AICC），专注于游说国会与监管机构，以适应快速发展的 AI 行业。随着 AI 监管讨论的加剧，尤其是在欧盟出台新规后，亚马逊和 Meta 也加入了该组织，试图通过统一监管来增强竞争力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;然而，此提案引发了广泛的争议。反对者认为，大型科技公司推动禁令的真正目的是为了巩固自身在 AGI（通用人工智能）竞争中的垄断地位。范德比尔特大学的政策加速中心 AI 与科技政策主任 Asad Ramzanali 表示，负责任的创新不应该惧怕法律的约束。同时，麻省理工学院的教授 Max Tegmark 也批评称，这种行为是科技巨头为了进一步集中财富和权力的扩张。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;另一方面，支持禁令的人士认为，联邦层面的统一监管将有助于避免各州的分歧，保持行业的创新能力，从而在全球 AI 竞争中处于有利地位。AI 安全倡导者如 Anthropic 联合创始人 Dario Amodei 则警告称，如果完全依赖企业自我监管，可能会带来严重的社会风险。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356176</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356176</guid>
      <pubDate>Sun, 11 May 2025 06:08:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>百度垂搜数据管理系统弹性调度优化实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;百度垂直搜索系统将搜索核心能力赋能阿拉丁（百度搜索特型结果）、垂直领域搜索、应用内搜索等场景，支撑了数百个检索场景、百亿级内容数据的检索。随着接入业务数量和数据量不断增长，系统在海量数据管理与调度上遭遇新的挑战，通过垂搜数据管理系统弹性调度优化实践来满足业务增长需求。&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;01 背景&lt;/h1&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;1.1 简介&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;百度垂搜架构的召回引擎经过历史架构演进确定了&lt;strong&gt;&lt;strong&gt;异构&lt;/strong&gt;&lt;/strong&gt;部署的架构模型，相较于同构部署在容量自动调整、数据按需存储等方面更具效率与成本的优势，同时在海量数据和海量检索方面也实现了高可用和高性能。目前系统已承接 80+业务，全机房部署了数百个检索服务，数千个索引库，共计数百亿文档收录。随着接入新业务数量的增加，以及存量业务的深入迭代，我们遇到了更加复杂多样的场景，进而对系统提出更高的要求。本文主要介绍我们的系统在海量数据管理与调度上面临的问题， 以及各项优化工作落地后在系统扩展性、稳定性等方面取得的效果。&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;1.2&amp;nbsp;当前数据管理架构存在的问题&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;此前我们的系统设计了弹性伸缩机制应对流量和数据量的上涨，冷热分离机制实现了资源按需部署。随着接入业务的增加，系统逐渐暴露出一些新的问题，主要体现在以下几点:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;元信息管理瓶颈。系统使用 ETCD 进行服务发现和心跳管理， 然而所有业务实例&lt;strong&gt;&lt;strong&gt;直连 ETCD&lt;/strong&gt;&lt;/strong&gt;存在严重读写放大问题， 导致 ETCD 负载超发出现&lt;strong&gt;&lt;strong&gt;单点瓶颈&lt;/strong&gt;&lt;/strong&gt;, 限制集群规模进一步增长。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;依靠人工评估资源。新业务的接入或者一些大事件运营保障依赖人工估算所需资源，&lt;strong&gt;&lt;strong&gt;不仅耗费人力，而且不够准确&lt;/strong&gt;&lt;/strong&gt;，估算过高，服务长期处于低负载会造成资源浪费，估算过低，服务容易过载，进而导致稳定性问题。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据量增长瓶颈。 当前的架构可以在无需重新建库的情况下原地扩分片，但是分片数只能倍数扩展，并且&lt;strong&gt;&lt;strong&gt;分片数量有限制&lt;/strong&gt;&lt;/strong&gt;，大库场景容易触发上限，进而导致数据量无法继续增长。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;02 检索系统与数据管理系统架构&lt;/h1&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.1&amp;nbsp;检索系统架构概览&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;首先简单介绍下垂搜检索系统的各模块，如下图所示:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c6fa6c464ffb4e6ea05cb47989be85fcbaf.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;RANK。检索精排模块，负责 query 理解、请求构造、多队列拆分、正排数据获取、策略因子计算、算分排序、返回结果组装等流程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS。检索召回引擎，负责基础召回/粗排，根据基础相关性等权重因子进行数据的粗筛，支持基于 term 倒排拉链和 ANN 向量基础召回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BUILD。数据建库模块，负责数据处理、切词、生成正排/倒排/向量/摘要等功能。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;每个垂类 (业务) 拥有一套独立的上述检索系统服务，数据管理系统为每个业务的检索系统提供&lt;strong&gt;&lt;strong&gt;实例调度、容量管理、服务发现、心跳管理、路由控制&lt;/strong&gt;&lt;/strong&gt;等能力，数据管理系统面向的核心管理对象是召回引擎 (BS)。&lt;/p&gt; 
&lt;span id="OSC_h3_6"&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1&amp;nbsp;垂搜召回引擎&lt;/h3&gt; 
&lt;p&gt;如下图所示，百度垂搜的召回引擎是一个&lt;strong&gt;&lt;strong&gt;流式、多分片、异构、有状态的倒排+向量&lt;/strong&gt;&lt;/strong&gt;索引引擎:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6a59f451eae4330c4d002228c9ca5d20b51.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;流式。业务经过离线建库环节产出建库包并生效到 Kafka 中，召回引擎再从 Kafka 消费，数据从建库到检索可实现&lt;strong&gt;&lt;strong&gt;秒级生效&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;多分片。业务数据量超过单机存储上限，会被拆分成多个分片 (slice)，每个分片由 PaaS 层面实例承载，并对应 Kafka 的一段 partition 区间。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;异构。单个业务的若干个资源号 (resource) 之间支持独占或者混部，一般根据服务负载设置不同副本数，根据数据量设置不同分片数。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;有状态。每个实例承载一个或多个分片数据，周期性汇报心跳，消费分片由中控服务统一调度。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;名词解释:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;resource(资源号): 一类或者一个场景的数据集合，即一个&lt;strong&gt;&lt;strong&gt;索引库&lt;/strong&gt;&lt;/strong&gt;，一个业务通常包含多个资源号 (如图中 mobile_game，pc_game， game_video 等)。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;slice(分片):数据调度基本单位，一个 resource 根据数据量可能会拆分成多个 slice(mobile_game 有三个 slice, pc_game 和 game_video1 个)。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;slot:数据划分的基本单位，一个 slice 下有若干个 slot， 与 Kafka 的 partition 一一对应，在业务接入时根据数据量级确定。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;pod:PaaS 层面实际的物理存储容器，一个 pod 会承载一个或多个 slice，由中控服务统一调度。&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.2&amp;nbsp;动态化数据管理系统&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;动态化数据管理系统负责召回引擎的每个实例从建库到检索，从部署到下线的全生命周期管理。经过&lt;strong&gt;&lt;strong&gt;服务重构、架构升级、新功能建设&lt;/strong&gt;&lt;/strong&gt;等方面的优化工作，形成了包括中控服务，心跳服务 (HeartbeatService), 名字服务 (NamingService), 存储 ETCD 等模块的现有系统架构:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-da1b5525954986be5194f44d536e0d8d45b.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.1&amp;nbsp;中控服务&lt;/h3&gt; 
&lt;p&gt;整个动态化数据管理系统的核心模块，负责各类调度任务的发起、控制等:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;资源号接入/下线。新增资源号 (索引库)，为每个资源号根据副本数、资源号之间部署关系等调度实例；下线资源号， 对应资源号的数据发起清理以及实例回收。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;副本保活。每个资源号实际副本数可能由于扩缩副本或 PaaS 层面迁移，导致与目标副本数不一致，中控服务负责定期轮训所有资源号 (分片)，维持副本数与目标一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;容量管理。自动扩缩容服务/人工基于负载调整资源号的副本数，并通过副本保活生效，基于数据量调整资源号分片数，通过任务控制器生效。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可用度控制。上线重启需要保证分片维度的可用度，变更由 PaaS 发起，每个实例重启前需要请求中控服务的探针，中控服务根据当前分片可用度决定实例是否可以重启。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.2&amp;nbsp;名字服务 NamingService&lt;/h3&gt; 
&lt;p&gt;提供服务发现，实例屏蔽，建库路由控制等能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;服务发现。周期性加载并更新全量业务的资源号检索路由拓扑信息，对每个分片过滤心跳丢失、未消费完成、重启中等暂不可用实例。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;实例屏蔽。支持异常实例的分片维度/App 维度屏蔽，线上快速止损，并保留现场便于后续问题追查。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;建库路由控制。提供离线建库侧全量业务资源号与 Kafka partition 映射关系查询，资源号倒排索引双写控制。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.3&amp;nbsp;心跳服务 HeartbeatService&lt;/h3&gt; 
&lt;p&gt;负责召回引擎 (BS) 实例、分片心跳信息收集并持久化，实例消费区间信息传递等:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;心跳管理。收集召回引擎实例上报的心跳信息，包括实例自身心跳以及消费分片信息， 并将心跳信息聚合后写入 ETCD。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;实例调度信息传递。获取由中控调度下发的最新消费分片信息，写入心跳请求 response，实例感知到消费分片发生变化后，清理旧分片数据，并重新消费新分片数据。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_11"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.4&amp;nbsp;存储 ETCD&lt;/h3&gt; 
&lt;p&gt;动态化数据管理系统各类元信息持久化存储:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;实例心跳信息。包括版本号，实例唯一标识，上报时间戳，消费分片等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;分片路由拓扑信息。分片下全量副本状态信息，包括 endpoint，snapshot 版本，上报时间戳，消费状态等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;业务资源号拓扑信息、建库路由信息。单业务视角下全量资源号信息，包括版本号，分片数，副本数，对应 Kafka partition 区间，rpc 参数配置等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_12"&gt;&lt;/span&gt; 
&lt;h1&gt;03 弹性调度机制优化实践&lt;/h1&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.1&amp;nbsp;服务发现、心跳管理模块重构&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.1&amp;nbsp;原有架构&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6f12910e29c40a1a821609e09c774e7296d.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;可以看到在原有架构，业务 RANK 和 BS 实例都是直连 ETCD，随着业务接入数量的增加逐渐暴露出一些问题:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;读流量放大。同业务的不同 RANK 实例会各自访问 ETCD 获取相同的路由拓扑，导致读流量放大，对于 RANK 实例数多的业务放大现象愈发明显。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;写流量放大。每个分片含有多个副本，在进行更新时，一轮周期内同一个分片会被写入多次，导致写流量放大，对于副本数多的分片写竞争愈发激烈。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;升级改造困难。路由筛选策略、心跳上报策略均内嵌在 sched-lib 中, 进行升级需要给每个业务 RANK/BS 上线，人力成本巨大。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为了解决上述问题，我们对心跳管理和服务发现模块进行了微服务拆分，新增心跳服务 (以下简称 HS) 和名字服务 (以下简称 NS) 避免了业务实例直连 ETCD，同时引入了 Prometheus，对心跳上报状态和路由获取状态等信息进行监控和可视化展示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bb9efb9826cf2b2ebe1bae522ce0df14546.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.2&amp;nbsp;NS(NamingService) 设计&lt;/h3&gt; 
&lt;p&gt;我们对 NS 的定位是作为 ETCD 的 cache，采用 Read-Through 的模式，对全量业务的 RANK 提供拓扑信息查询，RANK 不再直接访问 ETCD:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;NS 本身设计为一个&lt;strong&gt;&lt;strong&gt;无状态服务&lt;/strong&gt;&lt;/strong&gt;， RANK 可以访问任意一台 NS 获取拓扑，NS 实例之间拓扑路由&lt;strong&gt;&lt;strong&gt;保证最终一致性&lt;/strong&gt;&lt;/strong&gt;，NS 在拓扑变更时返回拓扑信息+MD5(拓扑)+更新时间戳，未变更时仅返回 MD5 和时间戳， RANK 基于 MD5 和时间戳自行判断是否需要更新。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;拓扑更新策略下沉到 NS 中，RANK 获取到的拓扑即为直接可用拓扑，针对不同业务提供不同的控制策略并且后续升级改造只需上线 NS，成本大幅降低。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;单机房 3 台 NS 实例即可支撑全部业务拓扑查询，重构前后 ETCD 读流量比例为 M:3，M 为平均每个业务 RANK 实例数，假设 N 取 30，则读流量下降 90%。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-93ea29c3774379e1a2cabf37f1ed095a248.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_16"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.3&amp;nbsp;HS(HeartbeatService) 设计&lt;/h3&gt; 
&lt;p&gt;HS 负责收集 BS 实例本身的心跳以及实例消费的分片的心跳，周期性&lt;strong&gt;&lt;strong&gt;聚合写入&lt;/strong&gt;&lt;/strong&gt;ETCD，并且向 BS 实例返回其最新的消费分片信息:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;HS 采用无主节点设计，也支持任意水平扩展。同一个业务的不同 BS 实例通过&lt;strong&gt;&lt;strong&gt;一致性 hash&lt;/strong&gt;&lt;/strong&gt;方式请求同一台 HS 实例, 便于 HS 进行分片维度的信息聚合，这样在大部分时间，每个分片无论有多少个副本一个周期内只会被写入一次，实例本身的心跳采用批量更新形式，写竞争大幅降低。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS 在上报心跳的同时会从 HS 的 response 中获取自身消费的最新分片信息，如果分片信息变化，则清理老分片数据，消费新分片数据，后续只上报新分片状态信息。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;单机房 3 台 NS 实例即可支撑全部业务心跳更新，重构前后 ETCD 写流量比例为 N:1，N 为平均每个分片副本数，假设 N 取 5，则写流量下降 80%。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-f141ad59566f2bbe45c04a1a0dac2046805.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_17"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.2&amp;nbsp;自动扩缩容&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.1&amp;nbsp;当前现状&lt;/h3&gt; 
&lt;p&gt;BS 是一个&lt;strong&gt;&lt;strong&gt;多分片、异构&lt;/strong&gt;&lt;/strong&gt;服务，即每个 App 内通常部署了多个资源号，各业务 App 在 PasS 层面隔离部署，在资源利用率、扩缩容管理等方面我们遇到以下问题：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;整体资源利用率低。全机房拥有上百个 BS 业务 App、上千个资源号，PaaS 层面的整体平均峰值 CPU 利用率低于平均水平，峰值 CPU 超过 70% 的资源号占比不足 20%。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;依赖人工进行资源号副本数调整。一般上线前通过人工压测评估放量后所需的资源然后进行申请，有时候通过压测难以估算真实的资源，并且后续业务迭代或者流量变化也会引起资源使用的变化，如果负载超发，服务稳定性难以保障，如果负载太过空闲，也会造成资源浪费。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;无法直接接入 PaaS 层面自动扩缩容能力。一方面 PaaS 无法感知每个 App 内资源号维度负载信息，另一方面每个实例承载分片信息只能由中控服务调度，因此无法直接服用 PaaS 层面自动扩缩容能力。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-05f53f5b84434e08c78529d148cd54a6dcb.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_19"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.2&amp;nbsp;自动扩缩容实现&lt;/h3&gt; 
&lt;p&gt;为了实现容量自适应调整，我们开发了一个自动扩缩容服务，对全量资源号进行容量管理。自动扩缩容服务周期性计算资源号维度负载，根据负载情况，触发中控服务进行资源号副本数调整，或者 PaaS 层面实例数调整。对于扩容，优先调度存量资源池中实例，如果存量实例不足则触发 PaaS 扩容；对于缩容，先将空闲副本数回收至空闲资源池，再触发 PaaS 缩容。对于自动扩缩容服务的设计我们主要考虑了以下几点:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-53d9ad28a3b34ec0ecb4706a0bc8f9316eb.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_20"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;负载指标选取&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;垂搜系统大部分业务 BS 为纯内存版本，且几乎没有下游网络请求，属于典型的计算密集型业务， 因此我们选择 CPU 作为负载计算参考指标，另外资源号混部场景进一步结合 QPS 和 Latency 进行判断。此前我们已经实现了基于 Prometheus 采集实分片维度 CPU、MEM、QPS、Latency、建库数据量等指标全量业务覆盖，因此可以低成本的获取到全量&lt;strong&gt;&lt;strong&gt;资源号维度&lt;/strong&gt;&lt;/strong&gt;的负载数据。&lt;/p&gt; 
&lt;span id="OSC_h4_21"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;负载状态流转&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;每个资源号从扩容到缩容，共定义如下 7 种状态：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;enum LoadStatus { LOAD_STATUS_LOAD_OK = 0; //正常负载 LOAD_STATUS_OVERLOAD = 1; //超负载 LOAD_STATUS_IDLELOAD = 2; //低负载 LOAD_STATUS_BS_ADD_REPLICA = 3; //bs 扩副本中 LOAD_STATUS_BS_REMOVE_REPLICA = 4; // bs 缩副本中 LOAD_STATUS_TRIGGER_PAAS_EXPENSION = 5; // PaaS 扩容中 LOAD_STATUS_TRIGGER_PAAS_SHRINK = 6; // PaaS 缩容中 }&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt;每个资源号根据负载情况在上述状态之间流转:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8fa2f7581ed63466a8f24640ad7258bba52.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_22"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;扩缩容执行流程&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;扩副本&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;优先调度 App 内空闲实例，不足则触发 PaaS 层面实例数扩容，循环执行直到负载恢复正常。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-edfbd8b326a5709833d414a5fb013f357ed.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;缩容&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;先将资源号多余副本释放为空闲实例，再触发 PaaS 层面缩容，循环执行直到资源号负载以及空闲实例数回到正常水平。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-504ce96574f2dc384b323509ab32bd78022.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt; 
&lt;h2&gt;3.3&amp;nbsp;&lt;strong&gt;资源号扩分片进阶&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;每个资源号随着数据量级不断增长，分片数也需要动态扩展，否则会出现分片内存超发的情况。&lt;/p&gt; 
&lt;span id="OSC_h3_24"&gt;&lt;/span&gt; 
&lt;h3&gt;3.3.1&amp;nbsp;&lt;strong&gt;当前扩分片方案&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;每个资源号按 resource-&amp;gt;slice-&amp;gt;slot 的层级划分，slot 是数据划分最小单位与 kafka partion 一一对应，在业务接入时每个资源号 slot(partion) 的数量已经确定。扩层时，资源号的 slot 数量不变，&lt;strong&gt;&lt;strong&gt;分片数变成原来 2 倍， 每个分片的 slot 数则为原来的 1/2&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8db852d84d0b6a8d63c9bac9fed576d9490.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;原有的扩分片方案可以在无需重新建库的情况下实现业务无感的原地分片扩缩操作，然而依旧存在两个问题:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;分片数按指数增长，当分片数超过一定数值，将带来不容忽视的资源成本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果初始分配 slot 数太少，当 slice:slot=1:1 时，无法再扩层，数据增长出现瓶颈。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_25"&gt;&lt;/span&gt; 
&lt;h3&gt;3.3.2&amp;nbsp;&lt;strong&gt;进阶扩展方案&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;对于分片无法继续扩展但是依旧需要继续建库的情况，先前的方案只能是重建一个新的资源号，需要业务、架构共同介入，历史上我们使用原方案迁移一个资源号，前后&lt;strong&gt;&lt;strong&gt;投入近 3 周时间&lt;/strong&gt;&lt;/strong&gt;，耗费成本巨大，因此我们需要一个成本更低的方案。通过分析，当前分片的扩展瓶颈主要有以下三个限制条件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;每个资源号的 slots 是一段连续的区间。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS 的 slot 与 Kafka 的 partition 一一对应。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;初始分配 slot 数太少，且后续不支持调整。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;只需要打破其中任意一个条件，则可以消除瓶颈。综合考虑改造成本、扩展灵活性、实现难度等因素，我们选择从条件三入手，在新的 partition 区间重建分片，分片数和 slot 数根据数据量设置，将旧分片的数据全量复制到新的分片上，再将新分片替换旧分片，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1534a9d4b6b75072160e0a0470563a1c8c8.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_26"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;整体实现&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;对于一个流式建库系统，业务可能时刻都在进行数据建库，我们希望做到迁移过程中业务依旧可以持续建库，并且保证数据不丢失、时序不错乱。我们的方案是将数据分为存量数据 (老分片中的全量数据) 和增量数据 (实时写入的新数据)，对于增量数据可以通过双写机制，同时写入新旧分片，存量数据则通过构建 snapshot 的方法迁移至新分片，新分片数据 ready 后，再由服务发现层将检索流量切换至新分片，整体流程如下:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;离线侧开启双写，保证增量倒排索引数据同时写入新旧分片，正排和摘要部分数据无需变化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基于旧分片构建新分片 snapshot, 并记录构建时间点。将该时间点前旧分片所有数据进行 resharding 构建新分片 snapshot。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;新分片的 BS 实例加载构建好的 snapshot，然后每个 partition 的消费 offset&lt;strong&gt;&lt;strong&gt;回退到 snapshot 构建时间点开始重新消费&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;服务发现层将资源号到 slot 区间映射切换到新分片上，检索流量从老分片迁移至新分片。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;将旧分片 BS 实例回收，并关闭双写。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-2cc22fbbf1492e639ef2bf5cbd76b4f8c3a.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_27"&gt;&lt;/span&gt; 
&lt;h1&gt;04 总结与展望&lt;/h1&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;4.1&amp;nbsp;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;本文介绍了百度垂搜检索数据管理架构在弹性机制建设上的一系列优化工作，并且在扩展性、稳定性、以及成本效率等方面均取得了预期成果:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;扩展性&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;ETCD 负载下降一个量级，单机房 BS、RANK 集群规模提升两个量级， 单分片副本数上限提升至 5000+。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;分片扩展数量不再受限，解决了部分存量业务无法扩展分片导致的内存超发问题，并支持搜索创新业务数据量从百万级逐步增加至数十亿量级。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;稳定性&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;存量调度问题被修复，新增多种路由调度策略以应对不同场景，分片可用度不足干预时间从小时级缩短至分钟级。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;ETCD 负载不再超发，慢查询基本消失，稳定性风险基本消除，心跳上报、拓扑获取状态建立监控，异常情况及时感知。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;成本效率&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;全机房 BS 接入自动扩缩容，实现容量自适应调整，整体峰值 CPU 利用率提升了 15%+，同时相比之前减少了 80% 人工介入容量调整的情况出现。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;部分业务通过分片合并，最终使用存储资源为下降至原来的 20%，并且检索 97 分位耗时降低了 20ms，业务侧效果与先前打平。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_29"&gt;&lt;/span&gt; 
&lt;h2&gt;4.2&amp;nbsp;&lt;strong&gt;展望&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前索引库的自动扩缩容机制实现了副本数随负载 (CPU) 的自动调整，后续将实现分片数随数据量的自动调整。另外，在大库场景将持续建设流批一体机制，以追求用更低的存储成本实现更高的检索性能。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18627327</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18627327</guid>
      <pubDate>Sun, 11 May 2025 03:11:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Sam Altman 透露将在今年夏季发布 GPT-5</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;今天凌晨，OpenAI 发布了其联合创始人兼首席执行官 Sam Altman 的 40 分钟深度专访。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0619/105636_pUBl_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;OpenAI CEO Sam Altman &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1935357512011890815" target="_blank"&gt;透露&lt;/a&gt;&lt;/u&gt;，备受瞩目的 GPT-5 预计将于今年夏天推出，不过具体发布日期尚未确定。&lt;/p&gt; 
&lt;p&gt;据报道，GPT-5 性能将远超 GPT-4，测试者表示其在多方面有显著进步。据悉，这款新模型将整合 OpenAI 的核心技术，融合 GPT-4o 自然语言处理的灵活性与 o3 在代码及科学推理方面的优势，打造更强大的统一系统。&lt;/p&gt; 
&lt;p&gt;Altman 暗示，GPT-5 或许不仅是性能上的升级，更可能是 OpenAI 迈向统一、类似代理模型的重要一步，使其向人工通用智能（AGI）目标更进一步。&lt;/p&gt; 
&lt;p&gt;此外，据 AI 工程师 Tibor Blaho 和投资者「Chris（chatgpt21）」消息透露，OpenAI 或将在 7 月发布一个大规模模型，而该模型有望为 GPT-5。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;相关阅读：&lt;a href="https://www.oschina.net/news/354761" target="news"&gt;OpenAI 推迟开源模型的发布时间&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356142</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356142</guid>
      <pubDate>Sun, 11 May 2025 02:56:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Warm-Flow 发布 1.7.4，设计器和流程图优化</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;主要内容&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;[feat] 新增下载流程图功能&lt;/li&gt; 
 &lt;li&gt;[feat] start 和 skip 或者其衍生的方法，新增指定下个任务办理人 flowParams.nextHandler&lt;/li&gt; 
 &lt;li&gt;[feat] 新增流程图明暗主题&lt;/li&gt; 
 &lt;li&gt;[feat] 流程图新增通过访问路径设置网格显隐&lt;/li&gt; 
 &lt;li&gt;[feat] 流程图新增悬浮提示, 支持自定义内容和样式&lt;/li&gt; 
 &lt;li&gt;[update] 设计器打开自动居中&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;新版流程图&lt;/strong&gt;&lt;/p&gt; 
&lt;div&gt;
 &lt;img src="https://oscimg.oschina.net/oscnet//89db2b2722c309d9471d214941e3197b.png" referrerpolicy="no-referrer"&gt;
&lt;/div&gt; 
&lt;h2&gt;项目介绍&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Dromara Warm-Flow 国产工作流引擎，其特点简洁轻量，五脏俱全，灵活扩展性强，是一个可通过 jar 引入设计器的工作流。&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;支持常见审批功能、监听器与流程变量、条件表达式、办理人表达式&lt;/li&gt; 
 &lt;li&gt;自带流程图、流程设计器、节点扩展属性&lt;/li&gt; 
 &lt;li&gt;支持常见的 orm 框架&lt;/li&gt; 
 &lt;li&gt;支持不同的数据库&lt;/li&gt; 
 &lt;li&gt;生态丰富可扩展，文档全面&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;功能思维导图&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src="https://oscimg.oschina.net/oscnet//7c9b29e09f2b3ced6b7ee3f1f9a5977a.png" referrerpolicy="no-referrer"&gt;
&lt;/div&gt; 
&lt;h2&gt;演示地址&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.hhzai.top" target="_blank"&gt;http://www.hhzai.top&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;账号密码：admin/admin123&lt;/p&gt; 
&lt;h2&gt;官网&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwarm-flow.dromara.org" target="_blank"&gt;https://warm-flow.dromara.org&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;Warm-Flow 视频&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1AWRGYEEVr%2F%3Fspm_id_from%3D333.1387.0.0%26vd_source%3D1be886ace16159801f6ed0106df215d9" target="_blank"&gt;从零精通: 全流程开发与源码解读&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356140/warm-flow-1-7-4</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356140/warm-flow-1-7-4</guid>
      <pubDate>Sun, 11 May 2025 02:46:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>国产数据库管理工具 CloudDM 个人版六月版本发布合集</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;CloudDM 个人版&lt;/span&gt;&lt;span style="color:#333333"&gt;是&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ClouGence&lt;/span&gt;&lt;span style="color:#333333"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;公司推出的一款&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一站式多数据源开发管理工具&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#333333"&gt;，使用它可以方便地访问和管理&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;MySQL、Oracle、PostgreSQL、阿里云 RDS、Greenplum、TiDB、Redis、StarRocks、Doris、SelectDB、SQL Server、ClickHouse、OceanBase 、PolarDB-X 、IBM Db2 等多种不同类型的数据库。通过 CloudDM 丰富的数据源支持可以避免在多个专业工具之间切换，从而提高工作效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;它是本地化的应用程序，没有后台进程。和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;DataGrip&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Navicat&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;一样在安装完成后，只需要双击应用程序图标，便可以方便地管理位于本地计算机或远程计算机上的数据库。已支持&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;MacOS、Linux&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;三个操作系统。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8a94365af948142b7db590d03c3dc5e8d5d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#030303; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;六月 CloudDM 个人版共迭代发布了 2 个版本。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.0.7&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;问题修复&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，切换数据库模式时，数据库模式没有变化的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，切换数据库模式后，SQL 可能仍在上一个模式执行的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.0.6&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;优化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;优化，查询控制枱日志面板右侧区，新增两个按钮可以跳转到控制枱日志的最顶部和最底部。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;问题修复&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，达梦数据库设计表时，无法将字段默认值设置为 Empty String 的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，达梦数据库设计表时，无法将字段默认值设置为 NULL 的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，达梦数据库设计表时，字段默认值为自定义时，无法回显的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修复，查询控制枱日志面板在执行 SQL 后无法定位到最后的问题。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;下载与反馈&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;产品官网：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.clougence.com%2Fclouddm-personal" target="_blank"&gt;&lt;span&gt;https://www.clougence.com/clouddm-personal&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;问题反馈：&lt;a href="https://gitee.com/clougence/clouddm-issue/issues"&gt;&lt;span&gt;https://gitee.com/clougence/clouddm-issue/issues&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;微信交流群：访问产品官网，扫描右侧二维码即可加入。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356139</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356139</guid>
      <pubDate>Sun, 11 May 2025 02:44:00 GMT</pubDate>
      <author>来源: 投稿</author>
    </item>
    <item>
      <title>​OpenAI 终止与 Scale AI 合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 发言人当地时间周三向&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-06-18%2Fopenai-is-phasing-out-its-work-with-scale-ai-after-meta-deal" target="_blank"&gt;彭博社&lt;/a&gt;透露，在 Meta 与 Scale AI 达成交易后，OpenAI 将逐步停止与 Scale AI 的合作，并切断与该数据供应商的联系。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 表示，早在 Meta 上周宣布向这家初创公司投资数十亿美元并任命 Alexandr Wang 担任首席执行官之前，该公司就已开始逐步结束与 Scale AI 的合作。OpenAI 一直在寻找其他供应商来获取更专业的数据，以开发日益先进的 AI 模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="336" src="https://oscimg.oschina.net/oscnet/up-77faf9c892257b37289b5ccb5a6d4304d54.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 断绝关系的决定引发了人们对 Scale AI 核心数据标签业务的质疑。上周，路透社报道称，谷歌也在讨论放弃 Scale AI 作为数据提供商的计划。随着 Meta 与 Scale AI 达成合作，Scale AI 的一些竞争对手表示，他们收到了大量寻求「中立」合作伙伴的 AI 模型供应商的兴趣。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在周三发布的一篇博客文章中，Scale AI 的总法律顾问试图驳斥 Meta 将在此次交易后获得优待的说法。Scale AI 的高管表示，公司不会与 Meta 分享其他客户的机密信息，并且新任首席执行官 Wang 不会直接参与公司的日常运营。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在周三发布的另一篇博客文章中，Scale AI 的临时首席执行官 Jason Droege 则表示，公司将「加倍投入」其应用程序业务，其中包括为政府和企业构建定制的 AI 应用程序。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356119/openai-drops-scale-ai-meta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356119/openai-drops-scale-ai-meta</guid>
      <pubDate>Sun, 11 May 2025 02:29:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Midjourney 发布首个 AI 视频生成模型 V1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 初创公司 Midjourney &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fmidjourney%2Fstatus%2F1935377193733079452" target="_blank"&gt;宣布&lt;/a&gt;推出其备受期待的首款 AI 视频生成模型 V1，支持图像到视频的生成，并可实现从文本直接生成视频。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1216" src="https://static.oschina.net/uploads/space/2025/0619/102551_SwUy_2720166.png" width="1286" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;V1 目前仅通过 Discord 平台的网页端提供服务，基础订阅费为每月 10 美元。&lt;/p&gt; 
&lt;p&gt;根据 Midjourney 的官方介绍，V1 基于此前的图像模型生态进行打造。&lt;/p&gt; 
&lt;p&gt;Midjourney V1 操作分为自动和手动两种模式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;自动模式下，平台会根据用户生成的图片，自动创建「动作提示词」并让画面运动起来；&lt;/li&gt; 
 &lt;li&gt;手动模式则是由用户提供提示词。同时，Midjourney V1 也分为「低动态」和「高动态」两种运动模式。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;V1 的发布让 Midjourney 加入与 OpenAI 的 Sora、Runway 的 Gen 4 等 AI 视频模型的竞争。其目标不止于为好莱坞或广告业生成素材，公司 CEO David Holz 称这是迈向 「实时开放世界模拟」 AI 模型的一步，后续还计划开发 3D 渲染和实时 AI 模型。 &amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356115/midjourney-launches-its-first-ai-video-generation-model-v1</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356115/midjourney-launches-its-first-ai-video-generation-model-v1</guid>
      <pubDate>Sun, 11 May 2025 02:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 考虑赴港 IPO？知情人士：属实，仍处于初步筹备阶段</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;有消息称，AI 独角兽稀宇科技 (MiniMax) 正考虑在香港进行首次公开募股（IPO）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;对此，有接近 MiniMax 的知情人士向澎湃新闻记者表示，MiniMax 内部确实有类似想法，但目前仍处于初步筹备阶段。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="275" src="https://oscimg.oschina.net/oscnet/up-1c8fdc630a51d77c2dbbdb3ff2131f20e68.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官网介绍显示，MiniMax 是全球领先的通用人工智能科技公司。自 2022 年初成立以来，以「与所有人共创智能」为使命，致力于推动人工智能科技前沿发展，实现通用人工智能 (AGI）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，MiniMax 已自主研发了一系列多模态通用大模型，包括 MiniMax M1、Hailuo-02、Speech-02 和 Music-01，具备超长上下文处理能力，能够理解、生成并整合包括文本、音频、图像、视频和音乐在内的多种模态。并基于这些自研模型推出一系列 AI 原生产品，包括 MiniMax、海螺 AI、MiniMax Audio、星野等，以及面向企业和开发者的开放平台。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;2024 年 3 月，MiniMax 获 6 亿美元 A 轮融资，投后估值 25 亿美元，由阿里巴巴领投，此前融资的投资方也包括腾讯等。据媒体报道称，MiniMax 的实际估值目前已经超过 2024 年所报道过的「25 亿美元」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356108</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356108</guid>
      <pubDate>Sun, 11 May 2025 02:10:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
