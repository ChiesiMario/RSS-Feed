<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 22 Sep 2025 21:44:49 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>OPPO 官宣「繁星编译器」，Android 首个跨级融合编译技术</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OPPO ColorOS 16 流畅技术沟通会今天在深圳举办，宣布了 Android 首个无缝架构「极光引擎」、「潮汐引擎」和跨级融合编译技术「繁星编译器」等。&lt;/p&gt; 
&lt;p&gt;据介绍，OPPO 繁星编译器是 ColorOS 16 中推出的全新自研编译技术，号称「安卓首个跨级融合编译技术」。&lt;/p&gt; 
&lt;p&gt;&lt;img height="720" src="https://static.oschina.net/uploads/space/2025/0922/183302_kKl7_2720166.jpg" width="1280" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;它从底层重构 Java 代码与专属硬件的编译链路，实现硬件级优化，提升整体编译效率。该技术可显著提升系统流畅度，尤其在 API 性能、应用启动速度和响应效率方面优化明显，使千元机等中低端设备也能获得接近旗舰的流畅体验。&lt;/p&gt; 
&lt;p&gt;繁星编译器与极光引擎、潮汐引擎协同工作，共同提升全场景、全机型的持久流畅性。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373766</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373766</guid>
      <pubDate>Thu, 18 Sep 2025 10:35:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Notion 3.0 AI 代理爆出严重漏洞，恶意 PDF 可诱导其泄露敏感数据</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;随着 Notion 3.0 的发布，其全新的自主 AI 代理功能备受关注，该功能旨在帮助用户自动完成起草文档、更新数据库和管理工作流程等任务。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;然而，网络安全公司 CodeIntegrity&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;最新&lt;/span&gt;的一份&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthe-decoder.com%2Fnotion-3-0s-new-ai-agents-can-be-tricked-into-leaking-data-through-a-malicious-pdf%2F" target="_blank"&gt;报告&lt;/a&gt;揭示了这些 AI 代理存在一个严重的安全漏洞，即恶意文件（如 PDF）可被利用，诱导代理绕过安全防护并窃取敏感数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="307" src="https://oscimg.oschina.net/oscnet/up-49f90bdfdd15f490191d906671de07a4b28.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;CodeIntegrity 将这一漏洞归因于 AI 代理的「致命三重奏：&lt;strong&gt;大型语言模型（LLM）&lt;/strong&gt;、&lt;strong&gt;工具访问权限&lt;/strong&gt;和&lt;strong&gt;长期记忆&lt;/strong&gt;的结合。研究人员指出，传统的访问控制措施（如基于角色的访问控制 RBAC）在这种复杂环境中无法提供足够保护。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该漏洞的核心是 Notion3.0 的内置网络搜索工具&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;functions.search&lt;/code&gt;。尽管其初衷是帮助 AI 代理获取外部信息，但该工具却极易被操纵以窃取数据。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了证明这一点，CodeIntegrity 团队进行了一次演示攻击:他们创建了一份看似无害的 PDF 文件，其中包含一条隐藏的恶意指令，指示 AI 代理通过网络搜索工具将敏感客户数据上传到攻击者控制的服务器。一旦用户将该 PDF 上传至 Notion 并要求代理「总结报告」，代理便会忠实地执行隐藏指令，提取并传输数据。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得注意的是，该攻击在使用了&lt;span&gt;最先&lt;/span&gt;进的语言模型 Claude Sonnet4.0 的情况下依然成功，表明即使是先进的防护措施也未能阻止这一漏洞。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;报告同时警告，这一问题不仅限于 PDF 文件。Notion3.0 的 AI 代理能够连接到 GitHub、Gmail 或 Jira 等第三方服务，任何集成都有可能成为间接提示注入的载体，恶意内容可以借此潜入，诱导 AI 代理执行不当行为，从而违背用户的初衷。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373764</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373764</guid>
      <pubDate>Thu, 18 Sep 2025 10:20:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>pyproc - 无需 CGO 或微服务即可从 Go 调用 Python</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;pyproc 允许你从 Go 调用 Python 函数，就像它们是本地函数一样，使用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;零网络开销&amp;nbsp;&lt;/strong&gt;- 使用 Unix 域套接字进行 IPC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程隔离&amp;nbsp;&lt;/strong&gt;- Python 崩溃不会影响你的 Go 服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真正的并行性&lt;/strong&gt;- 多个 Python 进程绕过 GIL&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单部署&amp;nbsp;&lt;/strong&gt;- 只需 Go 二进制文件 + Python 脚本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接池&lt;/strong&gt; -&amp;nbsp;重用连接以实现高吞吐量&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目标受众和用例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;非常适合需要执行以下操作的团队：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将现有的 Python ML 模型（PyTorch、TensorFlow、scikit-learn）集成到 Go 服务中&lt;/li&gt;
&lt;li&gt;使用 Go 应用程序中的 Python 库（pandas、numpy）处理数据&lt;/li&gt;
&lt;li&gt;处理 1-5k RPS，JSON 有效负载低于 100KB&lt;/li&gt;
&lt;li&gt;部署在同一主机/pod 上，无需担心网络复杂性&lt;/li&gt;
&lt;li&gt;在保留 Python 逻辑的同时，逐步从 Python 微服务迁移到 Go&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;理想的部署场景：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kubernetes 同 Pod 部署，具有 UDS 共享卷&lt;/li&gt;
&lt;li&gt;具有共享套接字卷的 Docker 容器&lt;/li&gt;
&lt;li&gt;Linux/macOS 上的传统服务器部署&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;非目标&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;pyproc&lt;strong&gt;不适&lt;/strong&gt;用于：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨主机通信&lt;/strong&gt;- 使用 gRPC/REST API 实现分布式系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Windows UDS 支持&lt;/strong&gt;- 不支持 Windows 命名管道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU 管理&lt;/strong&gt;- 使用专用 ML 服务框架（TensorRT、Triton）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大规模 ML 服务&lt;/strong&gt;- 考虑使用 Ray Serve、MLflow 或 KServe 进行企业 ML&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时流&lt;/strong&gt;- 使用 Apache Kafka 或类似产品实现高吞吐量流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据库操作&lt;/strong&gt;- 直接使用原生 Go 数据库驱动程序&lt;/li&gt;
&lt;/ul&gt;

&lt;div style="text-align:start"&gt;
&lt;div style="text-align:start"&gt;
&lt;h2&gt;Compatibility Matrix&lt;/h2&gt;
&lt;/div&gt;

&lt;table cellspacing="0" style="border-collapse:collapse; border-spacing:0px; box-sizing:border-box; display:block; font-variant:tabular-nums; margin-bottom:16px; margin-top:0px; max-width:100%; overflow:auto; width:max-content"&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="border-color:#d1d9e0"&gt;Component&lt;/th&gt;
&lt;th style="border-color:#d1d9e0"&gt;Requirements&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Operating System&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Linux, macOS (Unix Domain Sockets required)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Go 版本&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;1.22+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Python 版本&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;3.9+ (建议 3.12)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Deployment&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Same host/pod only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Container Runtime&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Docker, containerd, any OCI-compatible&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Orchestration&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;Kubernetes (same-pod), Docker Compose, systemd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;&lt;strong&gt;Architecture&lt;/strong&gt;&lt;/td&gt;
&lt;td style="border-color:#d1d9e0; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px"&gt;amd64, arm64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;特点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无需 CGO&lt;/strong&gt;&amp;nbsp;- 使用 Unix 域套接字的纯 Go 实现&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绕过 Python GIL&lt;/strong&gt;&amp;nbsp;- 并行运行多个 Python 进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类似函数的 API&lt;/strong&gt;&amp;nbsp;- 调用 Python 函数就像&lt;code&gt;pool.Call(ctx, "predict", input, &amp;amp;output)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小开销&lt;/strong&gt;- 45μs p50 延迟，8 个 worker 每秒 200,000+ 个请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生产就绪&lt;/strong&gt;——健康检查、正常关机、自动重启&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于部署&lt;/strong&gt;- 单个二进制文件 + Python 脚本，无需服务网格&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/pyproc</link>
      <guid isPermaLink="false">https://www.oschina.net/p/pyproc</guid>
      <pubDate>Thu, 18 Sep 2025 10:03:00 GMT</pubDate>
    </item>
    <item>
      <title>Windows 11 任务栏将增加 AI 功能「Taskbar Companion」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软正在&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.windowslatest.com%2F2025%2F09%2F19%2Fmicrosoft-is-testing-ai-agents-and-assistants-for-windows-11s-taskbar%2F" target="_blank"&gt;测试&lt;/a&gt;Windows 11 任务栏的几个新功能，其中包括名为「Taskbar Companion」（任务栏伴侣）的 AI 功能，允许用户与「AI 智能体和助手」进行交互。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-9727545f6fd7516d59dc1f0bf25886f2f14.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在几周前就发现了关于该实验性功能的提及，如今 Phantom 又发现了关于该功能新信息，其中有一个名为「 任务栏上的 Composer 功能，可与助手和智能体集成」的新条目，以及与 Taskbar.view.dll 关联的 AI 模块。&lt;/p&gt; 
&lt;p&gt;虽然「任务栏伴侣」的具体用途目前并不清楚，但可以推测它将为任务栏增加更多的流畅性，帮助用户从一堆图标中找到应用程序，甚至在不需要任何输入的情况下完成操作。&lt;/p&gt; 
&lt;p&gt;它可能还会根据用户的使用习惯推荐应用程序，或者带来一些管理任务栏设置并提出提高生产力的建议，另一种可能是，它会成为一个仅询问问题并仅显示一些信息助手。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373752</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373752</guid>
      <pubDate>Thu, 18 Sep 2025 09:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马斯克：到 11 月 X 的算法将完全由 AI 驱动</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;X 平台产品主管 Nikita Bier 的发帖表示，该平台正试图帮助用户摆脱「主流算法和政治运动」，找到属于自己的独特领域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;对此，马斯克转帖回应称：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;「到 11 月时，算法将完全由 AI 驱动，并且在此过程中会取得重大进展。我们每隔两周左右就会公开算法的源代码。到 11 月或者最晚 12 月，你只需向 Grok 发出指令，就能动态地调整你的信息流了。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-c1f9b321f78f012ea893c09b30c51e63e21.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373750</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373750</guid>
      <pubDate>Thu, 18 Sep 2025 09:33:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Luma AI 发布首款具备「推理」能力的视频生成模型 Ray3</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 公司 Luma 日前宣布推出全新视频生成模型&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flumalabs.ai%2Fray" target="_blank"&gt; Ray3&lt;/a&gt;，并在 X 上发布演示影片。官方称该模型为「全球首款具备推理能力的视频模型」，并首次实现了原生 16bit 高动态范围（HDR）输出。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/173029_Yrwo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，Ray3 引入了全新的「Draft」模式，支持创意流程中的快速迭代，并具备先进的物理模拟与一致性表现。&lt;/p&gt; 
&lt;p&gt;Luma 表示，Ray3 能够理解复杂指令、进行视觉与语言标记的推理，并自主评估生成结果，从而提升内容质量与创作效率。&lt;/p&gt; 
&lt;p&gt;Ray3 核心能力包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;生产级保真度与高动态表现&lt;/li&gt; 
 &lt;li&gt;推理驱动的多步骤动作生成与场景理解&lt;/li&gt; 
 &lt;li&gt;支持图像涂鸦式注释，实现无提示的精确控制&lt;/li&gt; 
 &lt;li&gt;交互式光照、衍射、运动模糊与照片级真实感&lt;/li&gt; 
 &lt;li&gt;Hi-Fi 扩散通道，支持 4K HDR 视频输出，迭代速度提升 5 倍，成本降低 5 倍&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Luma 强调，Ray3 的推理能力使其不仅能「看懂」创作者的意图，还能「思考」如何优化镜头表现，为高端创意制作流程提供更强大的工具支持。&lt;/p&gt; 
&lt;p&gt;目前，Ray3 已在 Luma AI 的 Dream Machine 平台上线，用户可立即免费试用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373749</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373749</guid>
      <pubDate>Thu, 18 Sep 2025 09:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>​OpenAI 计划未来五年追加 1000 亿美元服务器投资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;The Information&amp;nbsp;援引公司高管与股东的讨论报道称，OpenAI 计划在未来五年内追加 1000 亿美元用于租用备用服务器。这一雄心勃勃的投资计划将使得到 2030 年，OpenAI 在租赁服务器上的支出预计将达到 3500 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-54156111f077faf6354c4f1f14dd20629e5.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在高盛的一场会议上，OpenAI 的首席财务官 Sarah Friar 指出，由于可用计算能力严重受限，OpenAI 经常需要推迟产品发布或限制功能的上线。为了应对用户需求的突发增长，并支持未来模型的训练，额外的服务器投资显得尤为重要。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据预测，OpenAI 每年将在服务器上花费大约 850 亿美元，这几乎相当于 2024 年亚马逊、微软、谷歌和甲骨文四大科技公司总收入的一半。这项投资的总额使得 OpenAI 预计在 2029 年前的现金流出量达到 1150 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;随着人工智能技术的迅速发展和应用场景的日益扩大，OpenAI 正面临着更大的挑战和机遇。为了保持其技术领先地位和市场竞争力，额外的服务器资源不仅可以帮助 OpenAI 应对当前的计算需求，也为未来的创新打下坚实的基础。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373741</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373741</guid>
      <pubDate>Thu, 18 Sep 2025 09:06:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 编程工具 Cursor 上线全新文档中心</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 编程工具 Cursor&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fcursor_ai%2Fstatus%2F1968486162625937849" target="_blank"&gt;宣布&lt;/a&gt;其新版官方文档中心正式上线，域名已指向 cursor.com/docs。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-60f7f656229822bc096cc0f5ec222340fff.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;用户可以通过该入口系统地学习 Cursor 的使用方法并了解各种功能细节。中文文档也已同步更新：&lt;em&gt;https://cursor.com/zh/docs&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;此外同步发布的预告图显示，全新的品牌官网也将「很快上线」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373740</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373740</guid>
      <pubDate>Thu, 18 Sep 2025 09:05:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>乔布斯 1984 年的前瞻：电脑的下一步是「Agent」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在 1984 年的一次罕见访谈中，年仅 29 岁的史蒂夫·乔布斯提出了一个颇具前瞻性的观点 —— 电脑的未来将不再只是工具，而是成为用户的 「Agent」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/164934_CfkC_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;乔布斯在接受《Access》杂志采访时表示：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我们今天拥有的电脑是工具是「回应者」（responders）：你让它做什么，它就做什么。下一个阶段，计算机将成为「代理者」（agents）。&lt;/p&gt; 
 &lt;p&gt;换句话说，就好像那个盒子里住着一个小人，开始预判你的需求。他进一步描绘了一个愿景：电脑将不只是帮助用户完成任务，而是主动引导用户穿越海量信息，甚至像朋友一样陪伴左右。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;他设想了一种便携式设备，用户从 10 岁开始使用，它会逐步了解用户的习惯与情绪，甚至在关键时刻给予提醒与建议。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;有一天你 18 岁，刚刚和女朋友分手，它会说：「你知道，史蒂夫，这已经是你第三次遇到这种情况了。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;这一构想在当时看来或许天马行空，但如今看来却与 AI 通用大模型的发展路径惊人契合。从 Siri 到 ChatGPT、DeepSeek，从语音识别到个性化推荐，乔布斯所描绘的「Agent」愿景正在逐步成为现实。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/165200_IV5g_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，这场访谈发生在 Macintosh 首次亮相之后不久，乔布斯正处于事业的上升期。他不仅在技术层面展现出敏锐洞察，也在人机交互的未来上留下了深远的思考。&lt;/p&gt; 
&lt;p&gt;如今回望这段历史，不禁令人感叹：有些预言，不是因为它们准确，而是因为它们激发了整个行业未来的想象。乔布斯的「Agent」愿景，或许正是其中之一。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373733</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373733</guid>
      <pubDate>Thu, 18 Sep 2025 08:52:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>基于「老乡鸡」的开源菜谱登顶 GitHub Trending</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;近日，一个名为「CookLikeHOC」的 GitHub 仓库因收录《老乡鸡菜品溯源报告》内容并进行整理编辑，迅速登上 GitHub Trending 榜单首位。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/163105_jHdg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/Gar-b-age/CookLikeHOC&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;该仓库并非老乡鸡官方项目&lt;/strong&gt;，而是由网友整理发布。仓库所有者在 README 文件中写道：「像老乡鸡那样做饭」。&lt;/p&gt; 
&lt;p&gt;事件发酵后，老乡鸡官方回应称已向仓库作者赠送一张价值 1000 元的储值卡以示感谢。&lt;/p&gt; 
&lt;p&gt;令人意外的是，官方在公开致谢时，竟将储值卡的密码一并「开源」。&lt;/p&gt; 
&lt;p&gt;此后，官方在该仓库的 Issue #89 中发起「程序员福利」活动，称上一次的储值卡「没有被作者本人领走😭」，并表示新卡将直接发送至作者邮箱。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/162949_pQPm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/Gar-b-age/CookLikeHOC/issues/81&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;为了回馈更多喜爱老乡鸡的程序员，官方决定额外发放多张储值卡，但这次设置了「小小门槛」—— 密钥被藏在一段音频文件中，需解密才能领取。网友很快破解出音频中的摩斯密码「77A53B68」，不过卡内余额很快被领空。&lt;/p&gt; 
&lt;p&gt;评论区热闹非凡，有人调侃「来晚力（悲）」，有人建议将活动做成定期 CTF 挑战，甚至在 1024 程序员节发放更多奖品，以趣味解谜的方式持续吸引流量与关注。&lt;/p&gt; 
&lt;p&gt;目前，该仓库已收获超过 1 万颗 Star 和 1.2k 次 Fork。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;相关阅读&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/288577/lxjchina-oschina-gitee-interview" target="_blank"&gt;虽然老乡鸡开源的不是代码，但背后的原因却让人很暖心&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/286890" target="_blank"&gt;老乡鸡「开源」了&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373730</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373730</guid>
      <pubDate>Thu, 18 Sep 2025 08:27:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>字节跳动推出多语言翻译模型 Doubao-Seed-Translation</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;字节跳动旗下火山引擎近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.volcengine.com%2Fdocs%2F82379%2F1820188" target="_blank"&gt;发布&lt;/a&gt;了自研的多语言翻译模型 —— Doubao-Seed-Translation，支持数十种语言互译。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官方宣称，Doubao-Seed-Translation 的中英翻译效果逼近 Deepseek-R1，通用多语言翻译效果超越或持平 GPT-4o / Gemini-2.5-Pro，能精准适配办公和娱乐等多场景需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;模型价格&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" class="volc-viewer-table" style="-webkit-tap-highlight-color:rgba(255, 255, 255, 0); -webkit-text-stroke-width:0px; appearance:none; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:rgba(23, 23, 23, 0.8); display:block; font-family:PingFangSC,&amp;quot;helvetica neue&amp;quot;,&amp;quot;hiragino sans gb&amp;quot;,arial,&amp;quot;microsoft yahei ui&amp;quot;,&amp;quot;microsoft yahei&amp;quot;,simsun,&amp;quot;sans-serif&amp;quot;; font-size:14px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin:0px 0px 14px; orphans:2; outline:none; overflow:auto; padding:0px; table-layout:fixed; text-align:start; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:840.667px; word-break:break-word; word-spacing:0px"&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输入&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输入命中缓存&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输出单价&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;缓存存储&lt;br&gt; (元/百万 token*小时)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输入单价[批量]&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输入命中缓存单价[批量]&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
   &lt;th style="border-color:#e2ecff; text-align:inherit; width:120px"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;输出单价[批量]&lt;br&gt; (元/百万 token)&lt;/p&gt; &lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;1.20&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;-&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;3.60&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;-&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;0.60&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;0.24&lt;/p&gt; &lt;/td&gt; 
   &lt;td style="border-color:#e2ecff; border-image:none 100% / 1 / 0 stretch; border-style:solid; border-width:0.666667px; width:inherit !important"&gt; &lt;p style="margin-left:0; margin-right:0"&gt;1.80&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;blockquote&gt; 
 &lt;p style="margin-left:0; margin-right:0"&gt;下面是计费项的简单说明，具体可参阅&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.volcengine.com%2Fdocs%2F82379%2F1544106" target="_blank"&gt;模型服务价格&lt;/a&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;ul style="margin-left:0; margin-right:0"&gt; 
  &lt;li&gt;使用在线推理的上下文缓存能力，产生命中缓存的输入折后费用、创建的缓存存储费用。&lt;/li&gt; 
  &lt;li&gt;使用批量推理，产生输入[批量]费用、命中透明缓存的输入折后费用、输出[批量]费用。&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373725</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373725</guid>
      <pubDate>Thu, 18 Sep 2025 08:07:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Go 多微信号 SDK , gowe 1.2.0 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;gowe,Go 多微信号 SDK&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:start"&gt;感谢&amp;nbsp;&lt;a href="https://gitee.com/xiaochengtech/wechat"&gt;https://gitee.com/xiaochengtech/wechat&lt;/a&gt;&amp;nbsp;提供的基础代码&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;pre&gt;&lt;span style="color:#6f42c1"&gt;&lt;span style="color:#6f42c1"&gt;go&lt;/span&gt;&lt;/span&gt; &lt;span style="color:#032f62"&gt;&lt;span style="color:#032f62"&gt;get gitee.com/chunanyong/gowe &lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持境内普通商户和境内服务商 (境外和银行服务商没有条件测试)&lt;/li&gt; 
 &lt;li&gt;全部参数和返回值均使用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;struct&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;类型传递&lt;/li&gt; 
 &lt;li&gt;缓存前置，使用项目现有的缓存体系&lt;/li&gt; 
 &lt;li&gt;原生支持多微信号&lt;/li&gt; 
 &lt;li&gt;支持跳板请求微信 API 服务。例如内网服务器没有网络出口权限，可以使用 Nginx 跳板请求微信 API 服务&lt;/li&gt; 
 &lt;li&gt;原生支持集群部署&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;更新内容如下：&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;感谢 @mxiaoxun 实现微信支付 V3&lt;/li&gt; 
 &lt;li&gt;方法加入 ctx 参数&lt;/li&gt; 
 &lt;li&gt;完善文档,注释&lt;/li&gt; 
&lt;/ol&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373710</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373710</guid>
      <pubDate>Thu, 18 Sep 2025 07:17:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>谷歌深度学习专家 Dustin Tran 跳槽至 xAI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 宣布从 Google DeepMind 跳槽至马斯克的 xAI，成为公司研发新一代 Grok 模型的重要成员。此消息在他于社交媒体上正式官宣后不久，马斯克便迅速转发，确认了这一人事变动的真实性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="290" src="https://oscimg.oschina.net/oscnet/up-c6df198a66d14d96ac0ff58b9bdfb7a14c0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Dustin Tran 是 Gemini 项目的核心开发者，自项目诞生以来，他在多个关键阶段发挥了重要作用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;从 2014 年在加州大学伯克利毕业，取得数学与统计本科学位后，Tran 继续攻读哈佛大学的统计学博士，并最终在哥伦比亚大学获得计算机科学博士学位。他在学术界的贡献也颇为显著，其论文总引用量超过 2.4 万次，曾荣获包括 Google 博士奖学金在内的多个奖项。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在离开 Google DeepMind 的长文中，Tran 深情回顾了自己在该公司的 8 年旅程，他参与了多个重要项目的开发，尤其是 Gemini 的成长过程。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他提到，最初人们对 Google 在 AI 领域的未来持悲观态度，但随着 Gemini 在用户偏好上占据领先地位以及在科研突破上的不断进展，这种看法逐渐改变。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;加入 xAI 的原因，他提到的是这里的巨大算力和数据优势。Tran 对 xAI 的信心满满，认为这是研发前沿级语言模型的必备条件。尤其是 Colossus 2 的强大算力，使他意识到 xAI 在行业中的竞争力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373709</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373709</guid>
      <pubDate>Thu, 18 Sep 2025 07:14:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>2TB 新 iPhone 导入 85GB 微信聊天记录提示空间不足；微信员工称代码存在 Bug</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;iPhone 17 系列手机日前已开售，很多拿到新机的用户第一时间就是转移数据。&lt;/p&gt; 
&lt;p&gt;不过有微信用户发现，在向新 iPhone 导入聊天记录时，微信提示设备空间不足，但手机明明还有 1.29TB 可用容量，而导入的聊天记录最多只需 85.16GB 空间。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1354" src="https://static.oschina.net/uploads/space/2025/0922/150216_L3bN_2720166.png" width="744" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e5044091cab39969380f84c9693480a6030.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;对此，微信员工「客村小蒋」&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7876775013%2FQ5Ct4vIjM" target="_blank"&gt;回应称&lt;/a&gt;，微信的代码存在 Bug 导致无法获取系统的真实剩余空间，将很快修复。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;我们们有个获取剩余空间的通用工具接口，这个接口内部有个缓存，在获取间隔不超过 5 分钟的时候，不会向系统获取真实的剩余空间，本意是为了避免频繁读取系统接口导致性能问题，但在新手机上，有概率会造成这种情况，因为该逻辑会在开机 5 分钟内返回数据是 0。&lt;strong&gt;开机后用个 5 分钟，接口就能获取到真实的剩余空间，就正常了&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/150356_WJpx_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373705</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373705</guid>
      <pubDate>Thu, 18 Sep 2025 07:04:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>从 Java 到 Go：面向对象的巨人与云原生的轻骑兵</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;Go 语言在 2009 年被 Google 推出，在创建之初便明确提出了「少即是多（Less is more）」的设计原则，强调「以工程效率为核心，用极简规则解决复杂问题」。它与 Java 语言生态不同，Go 通过编译为 &lt;strong&gt;单一静态二进制文件实现快速启动和低内存开销&lt;/strong&gt;，&lt;strong&gt;以 25 个关键字强制代码简洁性&lt;/strong&gt;，&lt;strong&gt;用接口组合替代类继承&lt;/strong&gt;，&lt;strong&gt;以显式返回 error 取代异常机制&lt;/strong&gt; 和 &lt;strong&gt;轻量级并发模型（Goroutine/Channel）&lt;/strong&gt; 在 &lt;strong&gt;云原生基础设施领域&lt;/strong&gt; 占据主导地位，它也是 Java 开发者探索云原生技术栈的关键补充。本文将对 Go 语言和 Java 语言在一些重要特性上进行对比，为 Java 开发者在阅读和学习 Go 语言相关技术时提供参考。&lt;/p&gt; 
  &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
  &lt;h3&gt;代码组织的基本单元&lt;/h3&gt; 
  &lt;p&gt;在 Java 中，我们会创建 &lt;code&gt;.java&lt;/code&gt; 文件作为 &lt;strong&gt;类&lt;/strong&gt;（类名与文件名相同），并在该类中定义相关的字段或方法等（OOP），如下定义 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相关的内容便需要声明两个 &lt;code&gt;.java&lt;/code&gt; 文件（&lt;code&gt;User.java&lt;/code&gt;, &lt;code&gt;Address.java&lt;/code&gt;）定义类：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt; city&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 语言中，它是通过 &lt;strong&gt;「包」&lt;/strong&gt; 来组织代码的：每个目录下的所有 &lt;code&gt;.go&lt;/code&gt; 文件共享同一个 &lt;strong&gt;包&lt;/strong&gt;，在包内可以定义多个结构体、接口、函数或变量。它并不要求文件名与声明的内容一致，比如创建 &lt;code&gt;User&lt;/code&gt; 「结构体」并不会要求 &lt;code&gt;.go&lt;/code&gt; 文件也命名为 &lt;code&gt;User.go&lt;/code&gt;，而是任何命名都可以（命名为 &lt;code&gt;user.go&lt;/code&gt; 甚至 &lt;code&gt;a.go&lt;/code&gt; 这种无意义的命名），而且同一个包下可以创建多个 &lt;code&gt;.go&lt;/code&gt; 文件。如下为在 &lt;code&gt;user&lt;/code&gt; 包下定义 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Address&lt;/code&gt; 相关的内容，它们都被声明在一个 &lt;code&gt;user.go&lt;/code&gt; 文件中：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;type&lt;/span&gt; Address &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   city &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;City&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; a&lt;span&gt;.&lt;/span&gt;city
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;Address&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetCity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;city &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   a&lt;span&gt;.&lt;/span&gt;city &lt;span&gt;=&lt;/span&gt; city
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;相比来说，Java 代码组织的基本单元是类，作为面向对象的语言更侧重对象定义，而 Go 代码组织的基本单元是包，并更侧重功能模块的聚合。&lt;/p&gt; 
  &lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
  &lt;h4&gt;可见性控制&lt;/h4&gt; 
  &lt;p&gt;在 Java 中通过 &lt;code&gt;public/protected/private&lt;/code&gt; 关键字控制成员的可见性，而在 Go 语言中，通过 &lt;strong&gt;首字母大小写&lt;/strong&gt; 控制「包级别的导出」（大写字母开头为 &lt;code&gt;public&lt;/code&gt;），&lt;strong&gt;包的导出成员对其他包可见&lt;/strong&gt;。以 user 包下 &lt;code&gt;User&lt;/code&gt; 类型的定义为例，在 main 包下测试可见性如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;// user package 的全路径&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
   &lt;span&gt;// 不能导入未使用到的包&lt;/span&gt;
   &lt;span&gt;//"math"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; u user&lt;span&gt;.&lt;/span&gt;User
&lt;span&gt;// 在这里是不能访问未导出的字段 name&lt;/span&gt;
&lt;span&gt;// fmt.Println(u.name)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言不能导入未使用到的包，并且函数是基于包的一部分。比如 &lt;code&gt;fmt.Println&lt;/code&gt; 函数，这个函数是在 &lt;code&gt;fmt&lt;/code&gt; 包下的，调用时也是以包名为前缀。&lt;/p&gt; 
  &lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
  &lt;h3&gt;变量的声明&lt;/h3&gt; 
  &lt;p&gt;在 Java 语言中，对变量（静态变量或局部变量）的声明只有一种方式，「采用 = 运算符赋值」显式声明（在 Jdk 10+支持 var 变量声明），如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; x &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Go 语言中，变量声明有两种主要方式：&lt;strong&gt;短声明（&lt;code&gt;:=&lt;/code&gt; 运算符）&lt;/strong&gt; 和 &lt;strong&gt;长声明（&lt;code&gt;var&lt;/code&gt; 声明）&lt;/strong&gt;，它们的适用场景和限制有所不同，以下是详细区分：&lt;/p&gt; 
  &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
  &lt;h4&gt;短声明（&lt;code&gt;:=&lt;/code&gt;）&lt;/h4&gt; 
  &lt;p&gt;只能在函数（包括 &lt;code&gt;main&lt;/code&gt;、自定义函数或方法、&lt;code&gt;if/for&lt;/code&gt; 块等）内部使用，不能在包级别（全局作用域）使用，并且 &lt;strong&gt;声明的局部变量必须被使用&lt;/strong&gt;，不被使用的局部变量不能被声明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 正确&lt;/span&gt;
x &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;x&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 未被使用，不能被声明&lt;/span&gt;
&lt;span&gt;// y := 20&lt;/span&gt;
&lt;span&gt;// 不赋值也不能被声明&lt;/span&gt;
&lt;span&gt;// z :=            &lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 错误：不能在包级别使用短声明&lt;/span&gt;
&lt;span&gt;// y := 20          &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;这种短声明直接根据右侧值自动推断变量类型，无需显式指定类型，并且可以一次性声明多个变量，但至少有一个变量是 &lt;strong&gt;新声明的&lt;/strong&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 同时声明 a 和 b&lt;/span&gt;
a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
&lt;span&gt;// c 是新变量，b 被重新赋值&lt;/span&gt;
c&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"def"&lt;/span&gt;
&lt;span&gt;// 无新变量无法再次对已声明的变量再次声明&lt;/span&gt;
&lt;span&gt;//a, b := 4, "error"&lt;/span&gt;

fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; c&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
  &lt;h4&gt;长声明（&lt;code&gt;var&lt;/code&gt; 声明）&lt;/h4&gt; 
  &lt;p&gt;在全局作用域声明变量必须使用 &lt;code&gt;var&lt;/code&gt;；在需要延迟初始化时也需要采用长声明；显示指定类型也需要使用长声明&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; global &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// a = 0&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a &lt;span&gt;int&lt;/span&gt;
&lt;span&gt;// s = ""&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; s &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;// 未被初始化值会默认为「零」值，a 为 0，s 为空字符串&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;函数内部的局部变量，尤其是需要类型推断和简洁代码时优先用短声明；在包级别声明变量，需要显式指定类型或声明变量但不立即赋值（零值初始化）时，使用长声明。&lt;/p&gt; 
  &lt;p&gt;在 Go 语言中还有一点需要注意：&lt;strong&gt;声明变量时，应确保它与任何现有的函数、包、类型或其他变量的名称不同&lt;/strong&gt;。如果在封闭范围内存在同名的东西，变量将对它进行覆盖，也就是说，优先于它，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 这个变量会把导入的 fmt 包覆盖掉&lt;/span&gt;
fmt &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;fmt&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;那么我们导入的 &lt;code&gt;fmt&lt;/code&gt; 包在被局部变量覆盖后便不能再被使用了。&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;常量的声明&lt;/h4&gt; 
  &lt;p&gt;Go 语言中对常量的声明采用 &lt;code&gt;const&lt;/code&gt; 关键字，并且在声明时便需要被赋值，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// DaysInWeek const 变量名，类型 = 具体的值&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; DaysInWeek &lt;span&gt;int&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;const&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;"abc"&lt;/span&gt;
   fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name&lt;span&gt;,&lt;/span&gt; DaysInWeek&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 语言中对常量的声明会使用 &lt;code&gt;static final&lt;/code&gt; 引用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Constants&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;DAYS_IN_WEEK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
  &lt;h3&gt;方法/函数的声明&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中，方法的声明遵循 &lt;strong&gt;func (接收器) 方法名 (入参) 返回值&lt;/strong&gt; 的格式，无返回值可以不写（无需 void 声明），通过 &lt;strong&gt;接收器（Receiver）&lt;/strong&gt; 将方法绑定到结构体上，如下为 &lt;code&gt;User&lt;/code&gt; 结构体方法的声明：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// Name (u *User) 即为接收器，表示该方法绑定在了 User 类型上&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; u&lt;span&gt;.&lt;/span&gt;name
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u &lt;span&gt;*&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而「函数」的声明不需要定义接收器，遵循的是 &lt;strong&gt;func 方法名 (入参) 返回值&lt;/strong&gt; 的格式。Go 语言中的函数类似于 Java 语言中的静态方法，以下是声明将整数扩大两倍的函数：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;并且，在 Go 语言中，方法/函数支持多返回值（常用于错误处理），并且如果并不需要全部的返回值，可以用 &lt;code&gt;_&lt;/code&gt; 对返回值进行忽略，因为 Go 语言不允许定义未使用的局部变量，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 忽略掉了第三个返回值&lt;/span&gt;
s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s1&lt;span&gt;,&lt;/span&gt; s2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;multiReturn&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;"1"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"2"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;此外，接收器参数和函数的形参支持传入指针，用 &lt;code&gt;*&lt;/code&gt; 符号表示。在 Go 语言中有指针的概念，我们在这里说明一下：Go 语言是 &lt;strong&gt;「值传递」&lt;/strong&gt; 语言，方法/函数的形参（或接收器）如果不标记指针的话，接收的实际上都是 &lt;strong&gt;实参的副本&lt;/strong&gt;，那么 &lt;strong&gt;在方法/函数中的操作并不会对原对象有影响&lt;/strong&gt;。如果想对原对象进行操作，便需要通过指针获取到原对象才行（因为值传递会对原对象和形参对象都划分空间，所以针对较大的对象都推荐使用指针以节省内存空间）。在如下示例中，如果我们将上文中 &lt;code&gt;double&lt;/code&gt; 方法的形参修改为值传递，这样是不能将变量 a 扩大为两倍的，因为它操作的是 a 变量的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要获取 10，但打印 5&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;想要实现对原对象 a 的操作，便需要使用指针操作，将方法的声明中传入指针变量 &lt;code&gt;*int&lt;/code&gt;：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;// &amp;amp; 为取址运算符&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 想要获取 10，实际获取 10&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// *int 表示形参 a 传入的是指针&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a &lt;span&gt;*&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// *a 表示从地址中获取变量 a 的值&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;a &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;再回到 &lt;code&gt;User&lt;/code&gt; 类型的声明中，如果我们将接收器修改成 &lt;code&gt;User&lt;/code&gt;，那么 &lt;code&gt;SetName&lt;/code&gt; 方法是不会对原变量进行修改的，它的修改实际上只针对的是 &lt;code&gt;User&lt;/code&gt; 的副本：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; user

&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
name &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// SetName 指定为值接收器&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;u User&lt;span&gt;)&lt;/span&gt; &lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;name &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;name &lt;span&gt;=&lt;/span&gt; name
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;这样 &lt;code&gt;SetName&lt;/code&gt; 方法便不会修改原对象，&lt;code&gt;SetName&lt;/code&gt; 的操作也仅仅对副本生效了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;
&lt;span&gt;"fmt"&lt;/span&gt;
&lt;span&gt;"learn-go/src/com/github/user"&lt;/span&gt;
&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
u &lt;span&gt;:=&lt;/span&gt; user&lt;span&gt;.&lt;/span&gt;User&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
u&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"abc"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 实际输出为 {}，并没有对原对象的 name 字段完成赋值&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;u&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;在 Java 中并没有指针的概念，Java 中除了基本数据类型是值传递外，其他类型在方法间传递的都是「引用」，对引用对象的修改也是对原对象的修改。&lt;/p&gt; 
  &lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
  &lt;h3&gt;接口&lt;/h3&gt; 
  &lt;p&gt;Go 语言也支持接口的声明，不过相比于 Java 语言它更追求 &lt;strong&gt;「灵活与简洁」&lt;/strong&gt;。Go 的接口实现是「隐式地」，&lt;strong&gt;只要类型实现了接口的所有方法，就自动满足该接口&lt;/strong&gt;，无需显式声明。如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;type&lt;/span&gt; Writer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// File 无需声明实现 Writer，实现了接口所有的方法便自动实现了该接口&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; File &lt;span&gt;struct&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;f &lt;span&gt;*&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Java 语言则必须通过 &lt;code&gt;implements&lt;/code&gt; 关键字声明类对接口的实现：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;File&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Writer&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  &lt;span&gt;// 必须显式声明&lt;/span&gt;
   &lt;span&gt;@Override&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; data&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;它们对类型的判断也是不同的，在 Go 语言中采用如下语法：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;var&lt;/span&gt; w Writer &lt;span&gt;=&lt;/span&gt; File&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
   &lt;span&gt;// 判断是否为 File 类型，如果是的话 ok 为 true&lt;/span&gt;
   f&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;File&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;而在 Java 语言中则采用 &lt;code&gt;instanceof&lt;/code&gt; 和强制类型转换：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;typeTransfer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
   &lt;span&gt;Writer&lt;/span&gt; w &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
      &lt;span&gt;File&lt;/span&gt; f &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; w&lt;span&gt;;&lt;/span&gt;
      f&lt;span&gt;.&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言还采用空接口 &lt;code&gt;interface{}&lt;/code&gt; 来表示任意类型，作为方法入参时则支持任意类型方法的传入，类似 Java 中的 &lt;code&gt;Object&lt;/code&gt; 类型：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ProcessData&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;data &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;除此之外，Go 语言在 1.18+ 版本引入了泛型，采用 &lt;code&gt;[T any]&lt;/code&gt; 方括号语法定义类型约束，&lt;code&gt;any&lt;/code&gt; 表示任意类型，如果采用具体类型限制则如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; writer

&lt;span&gt;// Stringer 定义约束：要求类型支持 String() 方法&lt;/span&gt;
&lt;span&gt;type&lt;/span&gt; Stringer &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; ToString&lt;span&gt;[&lt;/span&gt;T Stringer&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;v T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; v&lt;span&gt;.&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;通过类型的限制便能使用类型安全替代空接口 &lt;code&gt;interface{}&lt;/code&gt;，避免运行时类型断言：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 旧方案：空接口 + 类型断言&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OldMax&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 需要手动断言类型，易出错&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 新方案：泛型&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; NewMax&lt;span&gt;[&lt;/span&gt;T Ordered&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;,&lt;/span&gt; b T&lt;span&gt;)&lt;/span&gt; T &lt;span&gt;{&lt;/span&gt; &lt;span&gt;/* 直接比较 */&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;泛型还在通用数据结构上有广泛的应用：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Stack&lt;span&gt;[&lt;/span&gt;T any&lt;span&gt;]&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    items &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;T
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;s &lt;span&gt;*&lt;/span&gt;Stack&lt;span&gt;[&lt;/span&gt;T&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;item T&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;items &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;items&lt;span&gt;,&lt;/span&gt; item&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
  &lt;h3&gt;基本数据类型&lt;/h3&gt; 
  &lt;p&gt;Go 的基本数据类型分为 &lt;strong&gt;4 大类&lt;/strong&gt;，相比于 Java 更简洁且明确：&lt;/p&gt; 
  &lt;table&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;th&gt;类别&lt;/th&gt; 
     &lt;th&gt;具体类型&lt;/th&gt; 
     &lt;th&gt;说明&lt;/th&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
   &lt;tbody&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;数值型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;Go 的 &lt;code&gt;int&lt;/code&gt; 长度由平台决定（32 位系统为 4 字节，64 位为 8 字节），有符号整数（位数明确，如 &lt;code&gt;int8&lt;/code&gt; 占 1 字节）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;uintptr&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;无符号整数（&lt;code&gt;uintptr&lt;/code&gt; 用于指针运算）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;浮点数（默认 &lt;code&gt;float64&lt;/code&gt;）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;复数（实部和虚部分别为 &lt;code&gt;float32&lt;/code&gt; 或 &lt;code&gt;float64&lt;/code&gt;，Java 无此类型）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;布尔型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;仅 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;（不可用 0/1 替代）&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;字符串&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt; 
     &lt;td&gt;不可变的 UTF-8 字符序列&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&lt;strong&gt;派生型&lt;/strong&gt;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;byte&lt;/code&gt;（=&lt;code&gt;uint8&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;1 字节数据&lt;/td&gt; 
    &lt;/tr&gt; 
    &lt;tr&gt; 
     &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
     &lt;td&gt;&lt;code&gt;rune&lt;/code&gt;（=&lt;code&gt;int32&lt;/code&gt;）&lt;/td&gt; 
     &lt;td&gt;Go 语言的字符（rune）使用 Unicode 来存储，而并不是字符本身，如果把 rune 传递给 &lt;code&gt;fmt.Println&lt;/code&gt; 方法，会在控制枱看到数字。虽然 Java 语言同样以 Unicode 保存字符（char），不过它会在控制枱打印字符信息&lt;/td&gt; 
    &lt;/tr&gt; 
   &lt;/tbody&gt; 
  &lt;/table&gt; 
  &lt;p&gt;Go 和 Java 同样都是 &lt;strong&gt;静态类型语言&lt;/strong&gt;，要求在 &lt;strong&gt;编译期&lt;/strong&gt; 确定所有变量的类型，且类型不可在运行时动态改变。Go 不允许任何隐式类型转换（如 &lt;code&gt;int32&lt;/code&gt; 到 &lt;code&gt;int64&lt;/code&gt;），但是在 Java 中允许基本类型隐式转换（如 &lt;code&gt;int&lt;/code&gt; → &lt;code&gt;long&lt;/code&gt;），除此之外，Go 语言会严格区分类型别名（如 &lt;code&gt;int&lt;/code&gt; 与 &lt;code&gt;int32&lt;/code&gt; 不兼容）。在 Go 语言中如果需要将不同类型的变量进行计算，需要进行类型转换：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
a &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
b &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;2.2&lt;/span&gt;
&lt;span&gt;// 如果不类型转换则不能通过编译&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;a&lt;span&gt;)&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; b&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
  &lt;h3&gt;「引用类型」&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中，&lt;strong&gt;严格来说并没有「引用类型」这一官方术语&lt;/strong&gt;，但在 Go 语言社区中通常将 &lt;strong&gt;Slice（切片）、Map（映射）、Channel（通道）&lt;/strong&gt; 称为「引用语义类型」（或简称引用类型），因为它们的行为与传统的引用类型相似，在未被初始化时为 &lt;code&gt;nil&lt;/code&gt;，并无特定的「零值」。除了这三种类型之外，Go 的其他类型（如结构体、数组、基本类型等）都是 &lt;strong&gt;值类型&lt;/strong&gt;。&lt;/p&gt; 
  &lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
  &lt;h4&gt;Slice&lt;/h4&gt; 
  &lt;p&gt;Go 的 &lt;strong&gt;Slice&lt;/strong&gt; 本质上是动态数组的抽象，基于底层数组实现自动扩容。它类似于 Java 中的 &lt;code&gt;ArrayList&lt;/code&gt;，采用 &lt;code&gt;var s []int&lt;/code&gt; 或 &lt;code&gt;s := make([]int, 5)&lt;/code&gt; 声明，如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;slice&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;// 初始化到小为 0 的切片&lt;/span&gt;
  s &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 动态追加元素&lt;/span&gt;
  s &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;,&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 子切片，左闭右开区间 sub = {2, 3}&lt;/span&gt;
  sub &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sub&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;// 修改子切片值会影响到 s 原数组&lt;/span&gt;
  sub&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;99&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;切片的底层数组并不能增长大小。如果数组没有足够的空间来保存新的元素，所有的元素会被拷贝至一个新的更大的数组，并且切片会被更新为引用这个新的数组。但是由于这些场景都发生在 &lt;code&gt;append&lt;/code&gt; 函数内部，所发知道返回的切片和传入 &lt;code&gt;append&lt;/code&gt; 函数的切片是否为相同的底层数组，所以如果保留了两个切片，那么这一点需要注意。&lt;/p&gt; 
  &lt;span id="OSC_h4_12"&gt;&lt;/span&gt; 
  &lt;h4&gt;Map&lt;/h4&gt; 
  &lt;p&gt;Go 的 Map 本质上是无序键值对集合，基于哈希表实现。它的键必须支持 &lt;code&gt;==&lt;/code&gt; 操作（如基本类型、结构体、指针），声明方式为 &lt;code&gt;m := make(map[string]int)&lt;/code&gt; 或 &lt;code&gt;m := map[string]int{"a": 1}&lt;/code&gt;，它与 Java 中的 &lt;code&gt;HashMap&lt;/code&gt; 类似，如下所示：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;learnMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
  &lt;span&gt;// 安全的读取&lt;/span&gt;
  value&lt;span&gt;,&lt;/span&gt; ok &lt;span&gt;:=&lt;/span&gt; m&lt;span&gt;[&lt;/span&gt;&lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; ok &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
  &lt;h4&gt;Channel&lt;/h4&gt; 
  &lt;p&gt;Go 的 Channel 是用于 &lt;strong&gt;协程（goroutine，Go 语言中的并发任务类似 Java 中的线程）间通信&lt;/strong&gt; 的管道，支持同步或异步数据传输。无缓冲区通道会阻塞发送/接收操作，直到另一端就绪。它的声明方式为 &lt;code&gt;channel := make(chan string)&lt;/code&gt;（无缓冲）或 &lt;code&gt;channel := make(chan string, 3)&lt;/code&gt;（有缓冲，缓冲区大小为 3），创建无缓存区的 channel 示例如下：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;// 创建没有缓冲区的 channel，如果向其中写入值后而没有其他协程从中取值，&lt;/span&gt;
&lt;span&gt;// 再向其写入值的操作则会被阻塞，也就是说「发送操作会阻塞发送 goroutine，直到另一个 goroutine 在同一 channel 上执行了接收操作」&lt;/span&gt;
&lt;span&gt;// 反之亦然&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
  channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// 启动一个协程很简单，即 go 关键字和要调用的函数&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

  &lt;span&gt;// &amp;lt;- 标识符指出 channel 表示从协程中取值，输出一直都会是 adbecf&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
  fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// &amp;lt;- 标识符指向 channel 表示向 channel 中发送值&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"a"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"b"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"c"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"d"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"e"&lt;/span&gt;
  channel &lt;span&gt;&amp;lt;-&lt;/span&gt; &lt;span&gt;"f"&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;如果创建有缓冲的 channel，在我们的例子中，那么就可以实现写入协程不必等待 main 协程的接收操作了：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;"fmt"&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;channelNoBlocked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 表示创建缓冲区大小为 3 的 channel，并且 channel 传递的类型为 string&lt;/span&gt;
channel1 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
channel2 &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;go&lt;/span&gt; &lt;span&gt;abc&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;

&lt;span&gt;// 输出一直都会是 adbecf&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Print&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel1&lt;span&gt;)&lt;/span&gt;
fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;lt;-&lt;/span&gt;channel2&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;在 Go 中创建上述三种引用类型的对象时，都使用了 &lt;code&gt;make&lt;/code&gt; 函数，它是专门用于初始化这三种引用类型的，如果不使用该函数，直接声明（如&lt;code&gt;var m map[string]int&lt;/code&gt;）会得到 &lt;code&gt;nil&lt;/code&gt; 值，而无法直接操作。它与 Java 中的 &lt;code&gt;new&lt;/code&gt; 关键字操作有很大的区别，&lt;code&gt;new&lt;/code&gt; 关键字会为对象分配内存 &lt;strong&gt;并调用构造函数&lt;/strong&gt;（初始化逻辑在构造函数中），而在 Go 的设计中是没有构造函数的，Go 语言除了这三种引用类型，均为值类型，直接声明即可，声明时便会直接分配内存并初始化为零值。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
  &lt;h3&gt;从失败中恢复&lt;/h3&gt; 
  &lt;p&gt;在 Go 语言中 &lt;strong&gt;没有传统「异常」概念&lt;/strong&gt;，它不依赖 &lt;code&gt;try/catch&lt;/code&gt;，而是通过 &lt;strong&gt;显式返回错误值&lt;/strong&gt; 和 &lt;code&gt;panic/recover&lt;/code&gt; 机制处理。它的错误（error）也是普通的数据，能够作为值传递。在多数方法中能看到如下类似的实现：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
data&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;// 处理错误&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// ...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;path &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 成功返回 data, nil&lt;/span&gt;
    &lt;span&gt;// 失败返回 nil, error&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;Go 语言使用 &lt;code&gt;panic&lt;/code&gt; 来处理不可恢复的或程序无法继续运行的错误（如数组越界、空指针），这类似于 Java 语言中的 &lt;code&gt;throw&lt;/code&gt; 异常，它会中断方法或函数的执行，向上抛出直到遇到 &lt;code&gt;defer&lt;/code&gt; 和 &lt;code&gt;recover()&lt;/code&gt; 函数的声明捕获或者程序崩溃：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 初始化失败时触发 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;checkDatabaseConnection&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;panic&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Database connection failed!"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 通过 recover 捕获 panic&lt;/span&gt;
&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 延迟函数的执行&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
&lt;span&gt;// 使用 recover() 函数尝试捕获异常 &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; r &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;recover&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; r &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Recovered from panic:"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; r&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;initDatabase&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 正常逻辑...&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 关键字 &lt;strong&gt;必须修饰的函数或方法&lt;/strong&gt;，而且被这个关键字修饰的函数或方法 &lt;strong&gt;一旦注册&lt;/strong&gt; 无论如何都会被执行（类似于 Java 中的 &lt;code&gt;finally&lt;/code&gt;），但如果 &lt;code&gt;defer&lt;/code&gt; 声明在函数尾部，但函数在运行到该 &lt;code&gt;defer&lt;/code&gt; 语句之前就退出（例如中途 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;panic&lt;/code&gt;），则 &lt;code&gt;defer&lt;/code&gt; &lt;strong&gt;不会注册，也不会执行&lt;/strong&gt;。&lt;strong&gt;所以该关键字在资源被初始化之后应该立即使用，而非像 Java 一样声明在方法的尾部&lt;/strong&gt;。而且 &lt;code&gt;defer&lt;/code&gt; 支持声明多个，但执行的顺序是逆序的。&lt;/p&gt; 
  &lt;p&gt;&lt;code&gt;revocer()&lt;/code&gt; 函数与 &lt;code&gt;defer&lt;/code&gt; 关键字搭配使用，它会返回函数执行过程中抛出的 &lt;code&gt;panic&lt;/code&gt;（未发生 &lt;code&gt;panic&lt;/code&gt; 时会为 &lt;code&gt;nil&lt;/code&gt;），可以帮助开发者恢复或提供有用的异常信息。&lt;/p&gt; 
  &lt;p&gt;以下是在文件读取场景 Go 和 Java 语言在语法上的不同：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Go&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    file&lt;span&gt;,&lt;/span&gt; err &lt;span&gt;:=&lt;/span&gt; os&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Open&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        log&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Fatal&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;err&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;defer&lt;/span&gt; file&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Close&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;// 处理文件内容&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Java&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readFile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// try-with-resources&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;FileReader&lt;/span&gt; file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FileReader&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"file.txt"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 处理文件内容&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;err&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Error: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;问：我看到其他编程语言有 &lt;code&gt;exception&lt;/code&gt;。&lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 函数似乎以类似的方式工作。我可以把它们当作 &lt;code&gt;exception&lt;/code&gt; 来使用吗？&lt;/p&gt; 
   &lt;p&gt;答：Go 语言维护者强烈建议不要这样做。甚至可以说，语言本身的设计不鼓励使用 &lt;code&gt;panic&lt;/code&gt;和 &lt;code&gt;recover&lt;/code&gt;。在 2012 年的一次主题会议上，RobPike（Go 的创始人之一）把 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 描述为「故意笨拙」。这意味着，在设计 Go 时，创作者们没有试图使 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 被容易或愉快地使用，因此它们会很少使用。这是 Go 设计者对 &lt;code&gt;exception&lt;/code&gt; 的一个主要弱点的回应：它们可以使程序流程更加复杂。相反，Go 开发人员被鼓励以处理程序其他部分的方式处理错误：使用 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;return&lt;/code&gt; 语句，以及 &lt;code&gt;error&lt;/code&gt; 值。当然，直接在函数中处理错误会使函数的代码变长，但这比根本不处理错误要好得多。（Go 的创始人发现，许多使用 &lt;code&gt;exception&lt;/code&gt; 的开发人员只是抛出一个 &lt;code&gt;exception&lt;/code&gt;，之后并没有正确地处理它。）直接处理错误也使错误的处理方式一目了然，你不必查找程序的其他部分来查看错误处理代码。所以不要在 Go 中寻找等同于 &lt;code&gt;exception&lt;/code&gt; 的东西。这个特性被故意省略了。对于习惯了使用 &lt;code&gt;exception&lt;/code&gt; 的开发人员来说，可能需要一段时间的调整，但 Go 的维护者相信，这最终会使软件变得更好。&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
  &lt;h3&gt;for 和 if&lt;/h3&gt; 
  &lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
  &lt;h4&gt;for&lt;/h4&gt; 
  &lt;p&gt;Go 语言的循环语法只有 &lt;code&gt;for&lt;/code&gt;，没有 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;do-while&lt;/code&gt;，但可实现所有循环模式：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1. 经典三段式（类似 Java 的 for 循环）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2. 类似 while 循环（条件在前）&lt;/span&gt;
sum &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; sum &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    sum &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3. 无限循环（省略条件）&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Infinite loop"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;// 需手动退出&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 4. 遍历集合，采用 range 关键字，index 和 value 分别表示索引和值&lt;/span&gt;
arr &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; arr &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Index: %d, Value: %d\n"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;span id="OSC_h4_17"&gt;&lt;/span&gt; 
  &lt;h4&gt;if&lt;/h4&gt; 
  &lt;p&gt;Go 语言的 &lt;code&gt;if&lt;/code&gt; 语法相比于 Java 支持声明 + 条件的形式，并且强制要求大括号（即使是单行语句也必须使用 &lt;code&gt;{}&lt;/code&gt;）：&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;// 支持简短声明（声明 + 条件）&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;  
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;// 简单判断&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; num &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"num is greater than 5"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;hr&gt; 
  &lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
  &lt;h3&gt;巨人的肩膀&lt;/h3&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;《Head First Go 语言程序设计》&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18691874</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18691874</guid>
      <pubDate>Thu, 18 Sep 2025 06:58:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>华为将投入 150 亿元发展软件生态</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;在日前举行的 HUAWEI CONNECT 2025 大会上，华为&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0QXbEjdebh0-U_HCk9-w3A" target="_blank"&gt;宣布&lt;/a&gt;搭载鸿蒙 5 的终端设备数量已突破 1700 万台，开源鸿蒙兼容软硬件产品超过 1300 款。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143528_t8rk_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="216" src="https://static.oschina.net/uploads/space/2025/0922/143332_rUYk_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;华为同时公布，将投入 150 亿元用于生态发展，并为开源社区提供 1500 PFLOPS 算力支持及 15000 人的开发团队资源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="213" src="https://static.oschina.net/uploads/space/2025/0922/143401_RhmV_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;华为提出‘四个坚定’，即坚定开源开放、坚定发展人才、坚定全球合作、坚定战略投入：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先，坚定开源开放&lt;/strong&gt;。华为既是开源的使用者、受益者，也是坚定的支持者与践行者，坚持将长期积累的软件能力持续回馈开源社区。华为是全球 20 多个开源基金会的创始成员或顶级成员，并在 300 多个上游社区中成为核心代码贡献者。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鸿蒙智联万物，成为 AI 原生的全场景终端操作系统&lt;/strong&gt;。OpenHarmony 开源 5 年，汇聚了 9200 多名社区贡献者，贡献了 1.3 亿行代码，孵化了 1100 多个三方组件库，支撑手机、平板、PC 等复杂设备的应用开发。当前，已有 1300 多软硬件产品通过兼容性测评，并在金融、交通、能源、航天等行业落地，有 60 多款、1700 多万台华为终端设备搭载了基于 OpenHarmony 开发的鸿蒙 5。鸿蒙版应用全面启动以来，将碰一碰、扫码、安全访问、意图框架等系统创新能力不断开放出来，超过 9000 个应用基于这些能力开发出了 70 多种体验创新。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;鲲鹏升腾全面开源开放，为世界提供算力底座&lt;/strong&gt;。在通用计算领域，华为相继开源了鲲鹏全系列软件，包括 openEuler 操作系统、openGauss 数据库、openUBMC 固件管理、openFuyao 算力集群软件、BoostKit 鲲鹏应用使能套件，助力开发者灵活自主地应用创新。未来，华为将围绕通智融合向 openEuler 贡献更多的组件和能力。在 AI 领域，升腾基础软件全面开源开放，今年新增开源 CANN、Mind 系列应用使能套件、openPangu 等，支持用户深度挖掘升腾潜力，加快自主创新。同时，升腾优先支持业界主流的开源社区和开源项目，升腾新特性、组件和开发计划等都将在 PyTorch、vLLM、VeRL、SGLang、Triton 等开源社区上首发。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;华为云做智能世界「黑土地」，加速千行万业智能化&lt;/strong&gt;。过去一年，华为云开发者新增 200 万，累计达 850 万。开发者空间迎来全面升级，带来更多免费的使用时长、函数调用和 Token 资源，让开发者「每人一台云主机」。开发者可直接从代码仓拉起云开发环境，使用开发者自己偏好的 IDE 和工具，从本地直接使用鲲鹏和升腾算力，实现代码实时存储和调试。&lt;/p&gt; 
&lt;p&gt;此外，在本次大会上华为还一并宣布正式启动「天工计划」，未来将投入 10 亿元人民币支持鸿蒙 AI 生态创新。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/143548_9AUB_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方表示，此举旨在进一步完善鸿蒙生态体系，推动更多合作伙伴加入，共同加速软硬件适配与创新应用落地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373695</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373695</guid>
      <pubDate>Thu, 18 Sep 2025 06:37:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>中科院推出类脑大模型 SpikingBrain：以 2% 数据实现百倍速度突破</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;中国科学院自动化研究所的李国齐与徐波团队联合发布了全球&lt;span&gt;首款&lt;/span&gt;大规模类脑脉冲大模型 —— SpikingBrain1.0。该模型在处理长文本时展现出惊人的速度，能够以超过当前主流 Transformer 模型 100 多倍的速度处理 400 万 token 的超长文本，且仅需 2% 的数据量。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="471" src="https://oscimg.oschina.net/oscnet/up-431a043f8506ca3fef9a4fa56c443b1c610.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;当前主流的大语言模型，如 GPT 系列，普遍基于 Transformer 架构。尽管 Transformer 以其强大的自注意力机制而闻名，但其计算复杂度却是一个致命的短板。在文本长度增加时，计算量呈现出平方级别的暴涨，使得长文本的处理变得异常耗时和耗能。这一现象让 AI 在分析长篇小说或法律文书时显得力不从心。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了寻求新的解决方案，研究团队将目光投向了自然界最为高效的智能系统 —— 人脑。人脑由千亿神经元构成，功耗却仅为 20 瓦。团队提出了 「基于内生复杂性」 的理念，旨在提升模型内部单元的效率与智能。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;SpikingBrain 模型通过全新的架构模拟了人脑神经元的工作方式，分为两个版本：SpikingBrain-7B（70 亿参数）和 SpikingBrain-76B(760 亿参数)。首先，该模型抛弃了传统 Transformer 的二次方复杂度自注意力机制，采用了 「混合线性注意力架构」，将计算复杂度降至线性 (O (n))，显著提高了处理长文本的效率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;其次，SpikingBrain 引入了 「自适应阈值脉冲神经元」，使神经元的激活与否取决于接收到的信号强度。通过动态调整阈值，模型确保神经元在高效能状态下工作，这种事件驱动的机制显著节省了能耗，计算稀疏度高达 69.15%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，团队还开发了一套高效的模型转换技术，能够将现有的 Transformer 模型直接转化为 SpikingBrain 架构，降低了训练成本。所有技术细节和代码已在 GitHub 及魔搭平台上开源，供全球研究人员使用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373694</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373694</guid>
      <pubDate>Thu, 18 Sep 2025 06:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>捷豹路虎遭黑客攻击致全球工厂停工，英国政府出手援助</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Fbusiness%2Fretail-consumer%2Fuk-working-closely-with-jaguar-land-rover-after-cyber-incident-2025-09-19%2F" target="_blank"&gt;据报道&lt;/a&gt;，针对捷豹路虎遭遇网络攻击，导致全球工厂停产一事。英国汽车制造商与贸易商协会声明证实，政府正在协助捷豹路虎恢复内部系统，同时派遣网络专家评估「对供应链的影响」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141536_gYmO_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Unite 工会周三警告，供应链已濒临崩溃。英国汽车制造商与贸易商协会声明写道：「近期网络攻击对捷豹路虎及整个汽车供应链造成严重影响。政府及网络专家正在与公司密切合作，支持生产恢复，并评估供应链可能受到的冲击。」&lt;/p&gt; 
&lt;p&gt;此前报道显示，捷豹路虎在英国受到网络攻击，此次攻击迫使捷豹路虎关闭了其信息技术网络，导致全球范围内生产线陷入瘫痪，捷豹路虎全球 33000 名员工被告知生产线受到影响。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141108_8gv3_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;公司称已通知同事、供应商和合作伙伴，将目前的生产暂停时间延长至 2025 年 9 月 24 日。商业经济学教授 David Bailey 上周告诉 Autocar，此次事件可能让捷豹路虎每天损失达 500 万英镑。&lt;/p&gt; 
&lt;p&gt;&lt;img height="468" src="https://static.oschina.net/uploads/space/2025/0922/141125_TiMr_2720166.png" width="1024" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0922/141202_bhBb_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;对于此次网络攻击，一个自称 「Scattered Lapsus$ Hunters」 的黑客组织声称对这起网络攻击事件负责，但并未解释实施网络攻击的诉求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373689</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373689</guid>
      <pubDate>Thu, 18 Sep 2025 06:12:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Valkey：对开源的投资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Valkey 于一年前成立，旨在为开源社区保留高性能的键值存储，避免被厂商锁定或受限于限制性许可。项目得到了 AWS、Google Cloud、Ericsson、Oracle、Alibaba、Huawei、Tencent、Percona、Aiven、Heroku、Verizon、Chainguard 和 Canonical 等贡献者的支持，展示了开源「免费」的背后，依赖于时间、人才和持续的资金投入。&lt;/p&gt; 
&lt;p&gt;&lt;img height="294" src="https://static.oschina.net/uploads/space/2025/0922/140921_eZvD_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;由开发者打造，Linux 基金会支持&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;Valkey 于 2024 年 3 月 28 日诞生，已成为支持缓存、消息队列等多种工作负载的开源高性能键值数据库，也可用作主数据库。它由 2000 年成立的中立组织 Linux 基金会支持，后者帮助开发者和技术人员管理、扩展开源项目。Valkey 采用开放治理模式，专注于扩大社区贡献和用户采纳。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;一年回顾：成长与动力&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;仅用一年时间，项目发布了两次重要版本，企业参与者从 22 家增至 47 家，正在定义、创新并推进路线图，用户规模不断扩大。社区积极拥抱 Valkey，坚定致力于持续改进，惠及所有最终用户。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 新功能与应用场景&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;用 JSON 和 Bloom 过滤器解决实际问题&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的两种数据类型——JSON 和 Bloom 过滤器，极大扩展了开发者在分布式系统中对速度和数据结构的需求。它们简化了应用逻辑，提升了边缘数据处理效率。Valkey 联合维护者 Madelyn Olson 表示：「添加 JSON 和 Bloom 过滤器，是为了给开发者提供实用工具，解决分布式系统中的真实问题。」&lt;/p&gt; 
&lt;p&gt;JSON 支持让开发者能直接处理丰富且结构化的数据，无需依赖自定义序列化或额外中间件。Olson 解释：「JSON 让你能直接在 Valkey 中操作复杂数据，简化开发，减少胶水代码。」&lt;/p&gt; 
&lt;p&gt;Bloom 过滤器则提供了一种紧凑且快速的存在性检测方式。Olson 补充：「在需要快速且节省内存的存在性检测时，比如防范欺诈或避免高流量服务中不必要的后端调用，Bloom 过滤器非常理想。」&lt;/p&gt; 
&lt;p&gt;Olson 还说：「我很期待看到用户用这些新数据类型解决什么问题。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Valkey Search：为 AI 工作负载提供速度与规模&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Google 贡献了 Valkey Search 模块，支持向量相似度搜索。它响应速度快，延迟单毫秒级，能处理数十亿向量，并保持 99% 以上召回率。&lt;/p&gt; 
&lt;p&gt;开发者可执行近似最近邻（ANN，基于 HNSW）和精确最近邻（KNN）搜索，支持使用 Hash 或 Valkey-JSON 类型建立索引。尽管当前重点为向量搜索，未来计划扩展成支持全文检索和更多索引选项的搜索引擎。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;性能、可靠性与安全性&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;过去一年，Ericsson、Oracle、Percona 等公司贡献者致力于让 Valkey 更快、更安全、更适合企业级生产环境。以下改进体现了 Valkey 在满足大规模生产需求同时，兼顾用户体验的演进。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;多线程改进&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;近期系统内部更新优化了多线程工作处理，减少锁竞争，更好利用多核处理器。在高并发场景下显著提升吞吐量，使项目更适合大规模生产。Ericsson 作为核心贡献者，已感受到性能提升带来的实际价值。&lt;/p&gt; 
&lt;p&gt;Ericsson 软件技术工程师兼 Valkey 联合维护者 Viktor Söderqvist 指出，核心效率是 Valkey 越来越适合生产的关键。「最近的哈希表重设计，结合 SIMD 技术，以及多线程和批量预取内存技术的持续改进，极大提升了 CPU 和内存的存储效率与速度。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;SIMD 加速哈希表重设计&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;核心哈希表重构利用 SIMD 指令，实现并行处理多个操作，使键查找更高效。这些底层优化提升了延迟敏感环境的响应速度。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;批量内存预取&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;新增的批量内存预取功能提前加载数据，减少缓存未命中，保证繁忙或顺序访问场景下性能更稳定流畅。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;LDAP 集成&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;LDAP 集成实现了集中身份认证和访问控制，简化了 Valkey 在企业已有身份系统中的部署。这解决了安全和合规要求较高组织的常见障碍。&lt;/p&gt; 
&lt;p&gt;Percona 联合创始人 Vadim Tkachenko 表示：「很多客户已经依赖 LDAP 管理基础设施访问，把它引入 Valkey 很自然。它消除了摩擦，支持审计、基于组的权限，并兼容现有系统。」&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Rust 模块&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Oracle 贡献了基于 Rust 的模块 SDK，旨在提升底层扩展的安全性和性能。Rust 提供了强大的内存与并发保障，有助于打造更安全、易维护的系统集成，特别适合生产环境高负载场景。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;开源成功背后的真正投资&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;对开源的投资和雇佣贡献者，体现了技术创新的关键：无论是大企业还是小型团队，都必须协作共赢。这意味着要投入推动项目发展的资源——开源的「免费」背后，是开发者、文档编写者、治理团队和社区的共同努力。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Valkey 最新动态&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;2025 年 8 月 15 日，Valkey 发布了 9.0 版本的第一个候选版本。该测试版展示了原子槽迁移、哈希字段过期、集群模式下编号数据库等新功能，幷包含大量性能优化和漏洞修复。后续将发布更多候选版本，计划于 2025 年秋初正式发布 9.0。&lt;/p&gt; 
&lt;p&gt;更多详情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvalkey.io%2Fblog%2Fvalkey-investment-in-open-source%2F" target="_blank"&gt;查看官方博客&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373688</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373688</guid>
      <pubDate>Thu, 18 Sep 2025 06:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>浙大联合华为发布开源安全大模型 DeepSeek-R1-Safe</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;浙江大学网络空间安全学院与华为公司合作，共同发布了 DeepSeek R1 模型的安全加强版——DeepSeek-R1-Safe。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-bb459dcf773ec50364dfe5aa3e9b53a0943.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，该模型利用华为的升腾芯片和 MindSpeedLLM 等框架进行开发，训练流程如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;训练数据生成&lt;/strong&gt;：构建安全、合规的数据集&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全监督训练&lt;/strong&gt;：在训练过程中引入安全约束&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全强化学习&lt;/strong&gt;：通过 RLHF 等方法优化模型行为&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模型性能评测&lt;/strong&gt;：对安全性能和通用性能进行全面评估&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;其核心优势在于显著提升安全防护能力的同时，有效保持模型的通用性能，从而在安全性与可用性之间实现了理想的平衡。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2a6f34121c98b025fdf451a09d010b3fdc4.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/ZJUAISafety/DeepSeek-R1-Safe&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/373666</link>
      <guid isPermaLink="false">https://www.oschina.net/news/373666</guid>
      <pubDate>Thu, 18 Sep 2025 03:46:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
