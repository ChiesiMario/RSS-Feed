<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 21 Aug 2025 03:40:29 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>systemd 259 将提高运行系统要求，弃用旧版 iptables</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;随着 systemd 258 正式推出（目前已发布 rc3 候选版本），开发团队已公布下一个版本 &lt;strong&gt;systemd 259&lt;/strong&gt; 的重要调整：它将全面提高依赖组件的最低版本要求，并逐步淘汰旧技术支持。&lt;/p&gt; 
&lt;p&gt;具体来看，systemd 259 要求运行环境至少满足以下条件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Linux 内核&lt;/strong&gt; 5.10+（推荐 5.14+）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;glibc&lt;/strong&gt; 2.34+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;libxcrypt&lt;/strong&gt; 4.4.0+（不再依赖 glibc 内建 libcrypt）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;util-linux&lt;/strong&gt; 2.37+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;elfutils&lt;/strong&gt; 0.177+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;OpenSSL&lt;/strong&gt; 3.0.0+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;cryptsetup&lt;/strong&gt; 2.4.0+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;libfido2&lt;/strong&gt; 1.5.0+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;libseccomp&lt;/strong&gt; 2.4.0+&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt; 3.9+&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;值得注意的是，systemd 259 还将 &lt;strong&gt;移除对旧版 iptables（libiptc）的支持&lt;/strong&gt;。这意味着使用 &lt;strong&gt;systemd-networkd&lt;/strong&gt; 或 &lt;strong&gt;systemd-nspawn&lt;/strong&gt; 的用户必须转向 &lt;strong&gt;nftables&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;总体来看，对这些组件版本做出要求上调「似乎合乎情理」，并且对于那些自己手动编译 systemd 最新版本的用户来说，这些新要求「可能不会带来太大问题」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0821/113310_VlmL_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;https://github.com/systemd/systemd/releases/tag/v258-rc3&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367576/systemd-259-requirements</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367576/systemd-259-requirements</guid>
      <pubDate>Thu, 21 Aug 2025 03:33:30 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>金山办公半年报：AI 月活用户突破 2900 万，WPS365 营收暴增 62%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;金山办公（688111）发布 2025 年半年报，展现出稳健的增长态势。公司上半年实现营业收入 26.57 亿元，同比增长 10.12%；归属于母公司所有者净利润 7.47 亿元，同比增长 3.57%；;扣非净利润 7.27 亿元，同比增长 5.77%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;AI 技术的深度应用为金山办公带来显著效果。截至 6 月 30 日，WPS AI 月活跃用户数达 2951 万，较 2024 年底的 1968 万实现大幅增长。WPS Office 全球月度活跃设备数创历史新高，达 6.51 亿，同比增长 8.56%，其中 PC 版月活 3.05 亿，移动版月活 3.46 亿。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;个人业务方面，WPS 个人业务收入 17.48 亿元，同比增长 8.38%。国内累计年度付费个人用户数 4179 万，同比增长 9.54%；海外付费用户 189 万，收入 1.29 亿元。海外市场通过优化本地运营及 AI 权益部署，用户增长效率持续提升。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="287" src="https://static.oschina.net/uploads/space/2025/0821/113303_siIk_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;企业级市场表现亮眼，WPS365 业务收入 3.09 亿元，同比增长 62.27%，成为公司业务增长新引擎。该业务加速行业解决方案落地，在教育领域覆盖双一流院校达 75%，服务超 1000 家高校及 2000 万师生。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在政企领域，WPS365 推出"企业大脑"解决方案，整合 AI Hub、AI Docs 和 Copilot Pro，新增中国联通、长江三峡集团、中国电气装备集团等标杆客户。升级后的智能文档库表格识别召回准确率高达 95% 以上，多格式文档解析能力行业领先。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;报告期内，金山办公发布 WPS AI3.0 并推出原生 Office 办公智能体——WPS 灵犀，通过"双向改造"重新定义 AI 与办公软件的融合模式。WPS 灵犀获评 2025 世界人工智能大会"镇馆之宝"奖项，具备多轮对话、修改可控、格式保留等优势。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;创新功能包括 AI 改文档的"左侧 Office、右侧灵犀"同屏交互方式，WPS AIPPT 支持自然语句动态优化大纲，以及业内首个支持"聊文档"的灵犀语音助手。WPS 知识库支持一键升级云文档，单文件解析量级达 500M。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;公司 2025 上半年研发投入 9.59 亿元，同比增长 18.70%，研发费用率约 36%。截至报告期末，研发人员 3533 人，占总员工数比例约 66%，为技术突破提供坚实支撑。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;东吴证券和华创证券研报均看好金山办公在 AI+企业服务领域的投资价值，认为公司在 AI Agent 规模化落地背景下具有重要机会。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367574</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367574</guid>
      <pubDate>Thu, 21 Aug 2025 03:31:30 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>高性能缓存设计：如何解决缓存伪共享问题</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;在多核高并发场景下，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;缓存伪共享（False Sharing）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; 是导致性能骤降的「隐形杀手」。当不同线程频繁修改同一缓存行（Cache &amp;nbsp;Line）中的独立变量时，CPU 缓存一致性协议会强制同步整个缓存行，引发无效化风暴，使看似无关的变量操作拖慢整体效率。本文从缓存结构原理出发，通过实验代码复现伪共享问题（耗时从 3709ms 优化至 473ms），解析其底层机制；同时深入剖析高性能缓存库 &amp;nbsp;Caffeine 如何通过&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内存填充技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;（120 字节占位变量）隔离关键字段，以及 JDK 1.8 的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;注解如何以「空间换时间」策略高效解决伪共享问题，揭示缓存一致性优化的核心思想与实践价值，为开发者提供性能调优的关键思路。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
 &lt;h3 style="text-align:left"&gt;&lt;span&gt;&lt;strong&gt;伪共享&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;伪共享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;（False &amp;nbsp;sharing）是一种会导致性能下降的使用模式，最常见于现代多处理器 CPU 缓存中。当不同线程频繁修改同一缓存行（Cache &amp;nbsp;Line）中不同变量时，由于 CPU 缓存一致性协议（如 MESI）会强制同步整个缓存行，导致线程间无实际数据竞争的逻辑变量被迫触发缓存行无效化（Invalidation），引发频繁的内存访问和性能下降。尽管这些变量在代码层面彼此独立，但因物理内存布局相邻，共享同一缓存行，造成「虚假竞争」，需通过内存填充或字段隔离使其独占缓存行解决。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;接下来我们讨论并验证在 CPU 缓存中是如何发生伪共享问题的，首先我们需要先介绍一下 CPU 的缓存结构，如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img alt="cpu_cache.png" src="https://oscimg.oschina.net/oscnet/aa55ef0e-e751-44a8-8c1e-7f3b65df1a5d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;CPU Cache 通常分为大小不等的三级缓存，分别为 L1 Cache、L2 Cache、L3 &amp;nbsp;Cache，越靠近 CPU 的缓存，速度越快，容量也越小。CPU Cache 实际上由很多个缓存行 Cache Line 组成，通常它的大小为 &amp;nbsp;64 字节（或 128 字节），是 CPU 从内存中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;读取数据的基本单位&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，如果访问一个&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;long[]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;数组，当其中一个值被加载到缓存中时，它会额外加载另外 7 个元素到缓存中。那么我们考虑这样一种情况，CPU 的两个核心分别访问和修改统一缓存行中的数据，如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img alt="伪共享问题.drawio.png" src="https://oscimg.oschina.net/oscnet/cfacaa63-82cd-48e0-8f47-25e712a69542.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;核心 1 不断地访问和更新值 X，核心 2 则不断地访问和更新值 &amp;nbsp;Y，事实上每当有核心对某一缓存行中的数据进行修改时，都会导致其他核心的缓存行失效，从而导致其他核心需要重新加载缓存行数据，进而导致性能下降，这也就是我们上文中所说的缓存伪共享问题。接下来我们用一段代码来验证下缓存伪共享问题造成的性能损失，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;TestFalseSharing&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;static&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;Pointer&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// 两个 volatile 变量，保证可见性&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;String&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;return&lt;/span&gt;&amp;nbsp;&lt;span&gt;"x="&lt;/span&gt;&amp;nbsp;+ x +&amp;nbsp;&lt;span&gt;", y="&lt;/span&gt;&amp;nbsp;+ y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; @Test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;&lt;span&gt;testFalseSharing&lt;/span&gt;&lt;/span&gt;&lt;span&gt;() throws InterruptedException&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Pointer pointer =&amp;nbsp;&lt;span&gt;new&lt;/span&gt;&amp;nbsp;Pointer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// 启动两个线程，分别对 x 和 y 进行自增 1 亿，次的操作&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;start = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Thread t1 =&amp;nbsp;&lt;span&gt;new&lt;/span&gt;&amp;nbsp;Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span&gt;int&lt;/span&gt;&amp;nbsp;i =&amp;nbsp;&lt;span&gt;0&lt;/span&gt;; i &amp;lt;&amp;nbsp;&lt;span&gt;100&lt;/span&gt;_000_000; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pointer.x++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Thread t2 =&amp;nbsp;&lt;span&gt;new&lt;/span&gt;&amp;nbsp;Thread(() -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span&gt;int&lt;/span&gt;&amp;nbsp;i =&amp;nbsp;&lt;span&gt;0&lt;/span&gt;; i &amp;lt;&amp;nbsp;&lt;span&gt;100&lt;/span&gt;_000_000; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pointer.y++;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t1.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t2.start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t1.&lt;span&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; t2.&lt;span&gt;join&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.&lt;span&gt;out&lt;/span&gt;.println(System.currentTimeMillis() - start);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.&lt;span&gt;out&lt;/span&gt;.println(pointer);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;pre style="text-align:left"&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;这种情况下会发生缓存的伪共享，x 和 y &amp;nbsp;被加载到同一缓存行中，当其中一个值被修改时，会使另一个核心中的该缓存行失效并重新加载，代码执行实际耗时为 3709ms。如果我们将 x &amp;nbsp;变量后再添加上 7 个 long 型的元素，使得变量 x 和变量 y 分配到不同的缓存行中，那么理论上性能将得到提升，我们实验一下：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;TestFalseSharing&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;static&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;Pointer&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;p1, p2, p3, p4, p5, p6, p7;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;String&amp;nbsp;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;return&lt;/span&gt;&amp;nbsp;&lt;span&gt;"x="&lt;/span&gt;&amp;nbsp;+ x +&amp;nbsp;&lt;span&gt;", y="&lt;/span&gt;&amp;nbsp;+ y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;void&lt;/span&gt;&amp;nbsp;&lt;span&gt;testFalseSharing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&amp;nbsp;&lt;span&gt;throws&lt;/span&gt;&amp;nbsp;InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;pre style="text-align:left"&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;本次任务执行耗时为 473ms，性能得到了极大的提升。现在我们已经清楚的了解了缓存伪共享问题，接下来我们讨论下在 Caffeine 中是如何解决缓存伪共享问题的。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
 &lt;h3 style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;Caffeine 对缓存伪共享问题的解决方案&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;在，缓存之美：万文详解 Caffeine 实现原理，中我们提到过，负责记录写后任务的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;WriterBuffer&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;数据结构的类继承关系如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img alt="WriteBuffer.drawio.png" src="https://oscimg.oschina.net/oscnet/4530771c-ae81-4fff-b8c9-6200bec97db3.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;如图中标红的类所示，它们都是用来解决伪共享问题的，我们以&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;为例来看下它的实现：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;abstract&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&amp;nbsp;&lt;span&gt;extends&lt;/span&gt;&amp;nbsp;&lt;span&gt;AbstractQueue&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p000, p001, p002, p003, p004, p005, p006, p007;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p008, p009, p010, p011, p012, p013, p014, p015;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p016, p017, p018, p019, p020, p021, p022, p023;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p024, p025, p026, p027, p028, p029, p030, p031;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p032, p033, p034, p035, p036, p037, p038, p039;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p040, p041, p042, p043, p044, p045, p046, p047;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p048, p049, p050, p051, p052, p053, p054, p055;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p056, p057, p058, p059, p060, p061, p062, p063;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p064, p065, p066, p067, p068, p069, p070, p071;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p072, p073, p074, p075, p076, p077, p078, p079;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p080, p081, p082, p083, p084, p085, p086, p087;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p088, p089, p090, p091, p092, p093, p094, p095;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p096, p097, p098, p099, p100, p101, p102, p103;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p104, p105, p106, p107, p108, p109, p110, p111;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;byte&lt;/span&gt;&amp;nbsp;p112, p113, p114, p115, p116, p117, p118, p119;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;abstract&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt;&amp;nbsp;&lt;span&gt;extends&lt;/span&gt;&amp;nbsp;&lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// 生产者操作索引（并不对应缓冲区 producerBuffer 中索引位置）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;protected&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;producerIndex;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;可以发现在这个类中定义了 120 个字节变量，这样缓存行大小不论是 64 字节还是 128 字节，都能保证字段间的隔离。如图中所示&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;AbstractQueue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中的变量一定会&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;被分配到不同的缓存行&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中。同理，借助&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;BaseMpscLinkedArrayQueuePad2&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中的 120 个字节变量，&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中的变量也会被分配到不同的缓存行中，这样就避免了缓存的伪共享问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;其实除了 Caffeine 中有解决缓存伪共享问题的方案外，在 JDK 1.8 中引入了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;注解，它也可以解决缓存伪共享问题，如下所示为它在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中的应用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;K,V&amp;gt;&amp;nbsp;&lt;span&gt;extends&lt;/span&gt;&amp;nbsp;&lt;span&gt;AbstractMap&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span&gt;ConcurrentMap&lt;/span&gt;&amp;lt;K,V&amp;gt;, Serializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@sun&lt;/span&gt;.misc.Contended&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;static&lt;/span&gt;&amp;nbsp;&lt;span&gt;final&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;CounterCell&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;value;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; CounterCell(&lt;span&gt;long&lt;/span&gt;&amp;nbsp;x) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; value = x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;pre style="text-align:left"&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;其中的内部类&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;CounterCell&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;被标记了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@sun.misc.Contended&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;注解，表示该类中的字段会与其他类的字段相隔离，如果类中有多个字段，实际上该类中的变量间是不隔离的，这些字段可能被分配到同一缓存行中。因为&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;CounterCell&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中只有一个字段，所以它会被被分配到一个缓存行中，剩余缓存行容量被空白内存填充，本质上也是一种以空间换时间的策略。这样其他变量的变更就不会影响到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;CounterCell&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;中的变量了，从而避免了缓存伪共享问题。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;这个注解不仅能标记在类上，还能标记在字段上，拿我们的的代码来举例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;TestFalseSharing&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;static&lt;/span&gt;&amp;nbsp;&lt;span&gt;class&lt;/span&gt;&amp;nbsp;&lt;span&gt;Pointer&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Contended("cacheLine1")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;long p1, p2, p3, p4, p5, p6, p7;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Contended("cacheLine2")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;volatile&lt;/span&gt;&amp;nbsp;&lt;span&gt;long&lt;/span&gt;&amp;nbsp;y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;String&amp;nbsp;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;return&lt;/span&gt;&amp;nbsp;&lt;span&gt;"x="&lt;/span&gt;&amp;nbsp;+ x +&amp;nbsp;&lt;span&gt;", y="&lt;/span&gt;&amp;nbsp;+ y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;
&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;public&lt;/span&gt;&amp;nbsp;&lt;span&gt;void&lt;/span&gt;&amp;nbsp;&lt;span&gt;testFalseSharing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&amp;nbsp;&lt;span&gt;throws&lt;/span&gt;&amp;nbsp;InterruptedException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;pre style="text-align:left"&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;它可以指定内容来&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;定义多个字段间的隔离关系&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。我们使用注解将这两个字段定义在两个不同的缓存行中，执行结果耗时与显示声明字段占位耗时相差不大，为 520ms。另外需要注意的是，要想使注解&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;Contended&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;生效，需要添加 JVM 参数&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;-XX:-RestrictContended&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
 &lt;h3 style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;再谈伪共享&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;避免伪共享的主要方法是代码检查，而且伪共享可能不太容易被识别出来，因为只有在线程访问的是不同且碰巧在主存中相邻的全局变量时才会出现伪共享问题，线程的局部存储或者局部变量不会是伪共享的来源。此外，解决伪共享问题的本质是以空间换时间，所以并不适用于在大范围内解决该问题，否则会造成大量的内存浪费。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img alt="图片" src="https://oscimg.oschina.net/oscnet/7bafa35a-90f7-48c8-8f49-5a34b1595a0b.png" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span&gt;&lt;span&gt;扫一扫，加入技术交流群&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style="color:#858585"&gt;本文分享自微信公众号 - 京东云开发者（JDT_Developers）。&lt;br&gt; 如有侵权，请联系 support@oschina.cn 删除。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18683171</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18683171</guid>
      <pubDate>Thu, 21 Aug 2025 03:15:30 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>腾讯 Kuikly 开源框架新增支持 Web</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Kuikly 是腾讯广泛应用的跨端开发框架，基于 Kotlin Multiplatform 技术构建，为开发者提供了技术栈更统一的跨端开发体验，由腾讯大前端领域 Oteam（公司级）推出。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;本次在 Android、iOS、鸿蒙开源基础上，将新增开源 Web 版，支持&lt;strong style="color:#3e4753"&gt;H5&lt;/strong&gt;和&lt;strong style="color:#3e4753"&gt;微信小程序&lt;/strong&gt;，进一步扩展多端适配场景。Kuikly 适配的 H5 和微信小程序已接入腾讯多款业务，如搜狗输入法、鹅毛市集、QQ 小游戏等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Kuikly Web 版在 H5 和微信小程序上已经实现了绝大多数核心组件能力，运行效果如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="458" src="https://oscimg.oschina.net/oscnet/up-26eba6de49c36b7b6604edca4017c18a207.gif" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;Kuikly 是基于客户端技术栈设计，在支持 Android、iOS、鸿蒙高性能跨端的基础上，拓展支持 H5 和小程序，以达到更多端的复用。这与一些业界跨端框架定位是类似的，如 Flutter、Compose Multiplatform 等。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;官方从其中挑选了两个框架，从多个维度与它们对比在 H5 与微信小程序场景下的差异。&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;产物大小&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;在 H5 平台上，三个框架编译产物大小差别很大，Kuikly 包体积优势明显。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;业界基于终端技术栈的跨端方案，都是通过自绘引擎，通过 WASM 技术运行在浏览器上，编译后产物体积很大。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;Kuikly Web 使用 DOM 渲染方案，不依赖第三方产物，产物远小于其他框架，只有 463KB。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="333" src="https://oscimg.oschina.net/oscnet/up-5b25ce97181f67aff6ea73e9b3980f446fe.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;页面加载速度&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;在 iOS，Android 和 PC 浏览器环境进行性能测试 (运行 Hello World Demo)，Kuikly 在三个浏览器环境下加载速度都是最快的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;iOS 加载速度对比&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="270" src="https://oscimg.oschina.net/oscnet/up-27280d66307e6df8ddd303421bb8a23aad6.gif" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;Android 加载速度对比&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="278" src="https://oscimg.oschina.net/oscnet/up-28e3107909042c55583b2ec7091dd435b7a.gif" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;PC 性能数据对比&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;在 MacBook Pro M4Pro 电脑的 Chrome 浏览器 (138.0.7204.158) 上，使用开发者工具上进行了详细的性能测试。测出 Kuikly 的 FCP 耗时仅为 87.76ms，不到其他框架的一半。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-3f8064ac0857c8405a77ac1d882e7541d0b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;其他优势&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;在 H5 平台上与主流跨端框架对比，Kuikly 还具有以下优势：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;开发体验: &amp;nbsp;Android Studio 完善的开发支持。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;代码调试: &amp;nbsp;可直接调试 JS 或通过 SourceMap 调试 Kotlin。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;SEO 友好: &amp;nbsp;采用 DOM 渲染，传统的 SEO 优化都可以生效。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;兼容性好: &amp;nbsp;仅依赖 ES6 和 CSS3 特性，大部分设备都支持。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;生态复用: &amp;nbsp;编译产物是 JS，采用 DOM 渲染方案，可通过 Kuikly 自定义扩展复用 React 等 H5 生态库。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;微信小程序支持&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;主流的基于终端技术栈的跨端框架，缺少官方微信小程序运行方案支持，&lt;strong style="color:#3e4753"&gt;Kuikly Web 版微信小程序&lt;/strong&gt;的出现填补了这部分空白。&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;Kuikly 的架构设计回顾&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;简单回归一下 Kuikly 的整体架构，跨端 Core 层处理框架核心逻辑，Render 层负责不同平台渲染。新平台接入 Kuikly 需要实现自己的 Render 层。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;img height="271" src="https://oscimg.oschina.net/oscnet/up-00796c13ed7fc388ea9fbfaaeea7c5acbac.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;Kuikly Web 版本整体方案设计&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;在进行 Kuikly Web 版 H5 和微信小程序适配工作时，发现许多代码可以共用，因此抽象了一个&lt;strong style="color:#3e4753"&gt;Web 容器运行时&lt;/strong&gt;作为适配层，这个适配层依赖抽象的&lt;strong style="color:#3e4753"&gt;DOM API&lt;/strong&gt;、&lt;strong style="color:#3e4753"&gt;KuiklyWindow&lt;/strong&gt;、&lt;strong style="color:#3e4753"&gt;KuiklyDocument&lt;/strong&gt;，实现了绝大部分 Render 逻辑。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="459" src="https://oscimg.oschina.net/oscnet/up-b5941e643a63f02ecd410ab78aec4fe93db.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;Web 容器运行时&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0px; margin-right:0px; text-align:justify"&gt;&lt;span style="color:#000000"&gt;通过抽象核心接口构建 Web 容器运行时，实现了以下能力：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;将 Kuikly 的 UI 操作转换为标准 DOM 操作&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;为差异化模块（动画/列表/文本测量等）提供扩展接口&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;支持 JS 宿主通过实现 Web 容器运行时接口，接入 Kuikly&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;H5 运行时&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;浏览器提供了标准的 DOM，Window，Document。Kuikly 适配 H5 时只需实现动画，滚动列表，文本测量等少部分 Web 容器运行时拓展接口。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="255" src="https://oscimg.oschina.net/oscnet/up-de16c24658498c58d968d9839cc175a565b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;微信小程序运行时&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;项目团队在适配微信小程序之前，调研了目前支持微信小程序的跨端框架。这些框架基本都是基于前端技术，在微信小程序上基本采用编译时或者运行时方案，最终都是数据驱动模板完成 UI 渲染。如下图：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="441" src="https://oscimg.oschina.net/oscnet/up-39acc3990f6fabf312c1dbbbd4917a4b113.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;借鉴了业界主流小程序框架 Tarojs 和 Kbone 的思路，结合 Kuikly 框架的特点，通过实现 Web 容器运行时接口，提供轻量级 DOM 和拓展接口实现，仅实现 Kuikly 需要的能力，并做了一系列针对 Kuikly 渲染流程的优化。如下图：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="313" src="https://oscimg.oschina.net/oscnet/up-025a75a0f0cf58fe6c86b63b2afadf35565.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#3e4753; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span style="color:#000000"&gt;目前 Kuikly 适配微信小程序的方案在性能上仍有不少优化空间，后续将会探索编译 Kuikly 产物为 WASM，使用预编译等方式优化 Kuikly 在微信小程序平台的体验。&lt;/span&gt;&lt;/p&gt; 
&lt;h4 style="margin-left:0px; margin-right:0px; text-align:justify"&gt;&lt;span style="color:#000000"&gt;&lt;strong style="color:#000000"&gt;&lt;strong style="color:#3e4753"&gt;技术展望&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;继续对 Kuikly Web 版进行性能优化，使用预编译进一步提升小程序性能，同时减少编译产物大小。&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;探索使用 WASM 提升计算密集型任务的执行效率，优化 Kuikly Web 版的使用体验&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="text-align:justify"&gt;&lt;span style="color:#000000"&gt;扩大 Kuikly Web 版支持范围，下半年将开源 Electron 环境的适配&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367561</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367561</guid>
      <pubDate>Tue, 19 Aug 2025 02:37:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>字节跳动辟谣：与芯原股份并无 AI 芯片相关合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;近日，业内消息传字节跳动正与芯原股份联手设计一款先进的 AI 算力芯片。对此，字节跳动相关负责人回复称：&lt;strong&gt;字节跳动与芯原股份并无 AI 芯片相关合作&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;这并不是字节跳动第一次传出与其他厂商联手设计 AI 芯片（处理器）。去年上半年，曾有外媒报道称字节跳动与博通公司合作开发 AI 处理器，以确保有足够多的高端芯片。这款 AI 处理器制程为 5nm，将由台积电制造。虽然设计工作进展顺利，但标志着设计阶段结束和制造开始的「流片」尚未开始。字节跳动后续否认了「与博通合作开发 AI 芯片」相关传闻。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-4f7ed7c637e5768388c84b63ed136901daa.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;去年 9 月，针对媒体报道的字节跳动计划与台积电就 AI 芯片开展合作，字节方面回应表示，报道不实。字节跳动称公司在芯片领域确实有一些探索，但还处于初期阶段，主要是围绕推荐、广告等业务的成本优化，所有项目也完全符合相关的贸易管制规定。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367559</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367559</guid>
      <pubDate>Tue, 19 Aug 2025 02:31:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>快手发布 Klear-Reasoner 模型，基于 Qwen3-8B-Base 打造</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;快手 Klear 语言大模型团队&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fjbd-doTA48xw2Y86G8CWyg" target="_blank"&gt;推出&lt;/a&gt;了全新的 Klear-Reasoner 模型，基于 Qwen3-8B-Base 打造，在数学与代码的多个权威基准测试中达到同规模模型的 SOTA 水平，并完整公开了训练细节与全流程 pipeline。&lt;/p&gt; 
&lt;p&gt;据介绍，Klear-Reasoner 在 AIME2024、AIME2025、LiveCodeBench V5 和 V6 等基准测试中，不仅全面超越同规模的强力开源模型（包括 DeepSeek 蒸馏版 DeepSeek-R1-0528-8B），更是在 AIME2024 上取得了 90.5%、AIME2025 上取得了 83.2% 的惊人成绩，直接登顶 8B 模型榜首。&lt;/p&gt; 
&lt;p&gt;&lt;img height="394" src="https://static.oschina.net/uploads/space/2025/0821/102021_MBtp_2720166.png" width="1144" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="924" src="https://static.oschina.net/uploads/space/2025/0821/102031_wKeK_2720166.png" width="1524" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Klear-Reasoner 模型的核心创新是 GPPO（Gradient-Preserving Clipping Policy Optimization）算法，通过 stop-gradient 将裁剪与梯度回传解耦，保留了高熵 token 与负样本的梯度，兼顾了稳定性和探索力。&lt;/p&gt; 
&lt;p&gt;训练流程的洞察显示：SFT 阶段强调高质量少量数据优于海量低质数据；RL 阶段代码任务使用软奖励（通过率）优于硬奖励，并过滤了测试用例中的缺陷数据以消除假阴性。&lt;/p&gt; 
&lt;p&gt;论文、模型与代码均已公开，团队称该技术路线可复现、可推广，为社区提供了 RLVR 任务的新范式。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;论文标题：Klear-Reasoner: Advancing Reasoning Capability via Gradient-Preserving Clipping Policy Optimization&lt;/li&gt; 
 &lt;li&gt;论文链接：https://arxiv.org/pdf/2508.07629&lt;/li&gt; 
 &lt;li&gt;Hugging Face 地址：https://huggingface.co/Suu/Klear-Reasoner-8B&lt;/li&gt; 
 &lt;li&gt;GitHub 地址：https://github.com/suu990901/KlearReasoner/tree/main&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367555</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367555</guid>
      <pubDate>Tue, 19 Aug 2025 02:21:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>《GPT-5 家族 SQL 能力评测报告》发布</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-04cf3156161feafe5188e24a3bc155faa62.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;一、本期导览与核心看点&lt;/h2&gt; 
&lt;p&gt;2025 年 8 月，&lt;strong&gt;我们迎来了 AI 发展史上的又一个里程碑 ------ &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.com%2Fzh-Hans-CN%2Fgpt-5%2F" title="GPT-5" target="_blank"&gt;GPT-5&lt;/a&gt; 家族的正式发布。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当整个科技界都在讨论其通用能力的飞跃时，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Factiontech%2Fsql-llm-benchmark" title="SCALE" target="_blank"&gt;SCALE&lt;/a&gt; 平台将目光聚焦于 SQL 能力：&lt;strong&gt;GPT-5 在 SQL 处理上的表现究竟如何？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;本期评测为针对 &lt;strong&gt;GPT-5&lt;/strong&gt; 家族的评测特别版，旨在对其 SQL 相关能力进行一次全面的基准测试。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本期核心看点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;旗舰模型表现分析&lt;/strong&gt; ：&lt;strong&gt;gpt-5-chat&lt;/strong&gt; 的评测结果显示其能力存在特定短板，而 &lt;strong&gt;mini&lt;/strong&gt; 版本在本次测试的综合表现中更为均衡。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;全方位的能力评估&lt;/strong&gt; ：通过多维度多指标的用例评估，分析了 &lt;strong&gt;GPT-5&lt;/strong&gt; 在不同场景下的实际性能，揭示了其理论能力与实践应用的差异。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;数据驱动的模型选型&lt;/strong&gt; ：评测数据表明，不同版本的模型在处理 &lt;strong&gt;SQL 能力&lt;/strong&gt; 上各有千秋。本报告将基于数据，探讨如何进行场景化选型。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;二、评测基准说明&lt;/h2&gt; 
&lt;p&gt;为确保本次特别评测的公正性与深度，我们沿用了成熟的三维评测体系。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;SQL 理解&lt;/strong&gt;：考察模型是否精准解析复杂查询逻辑与用户意图。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SQL 优化&lt;/strong&gt;：考察模型提升查询效率与性能的意识。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;方言转换&lt;/strong&gt;：考察模型在主流数据库之间进行语法迁移的能力。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;接下来，我们将揭晓本次评测的详细结果。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;* 测评数据截止时间 2025/8/20&lt;/em&gt;&lt;/p&gt; 
&lt;h2&gt;三、本月榜单与焦点分析&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;GPT-5&lt;/strong&gt; 家族在 SQL 领域的评测结果并非简单的性能递减，不同版本间表现出显著的能力分化，这凸显了场景化选型的重要性。&lt;/p&gt; 
&lt;h3&gt;1. gpt-5-mini：综合能力均衡&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;gpt-5-mini&lt;/strong&gt; 在本次评测中综合表现领先，其在三个维度上展现了均衡且突出的能力。&lt;/p&gt; 
&lt;h4&gt;各维度表现得分&lt;/h4&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align="left"&gt;能力&lt;/th&gt; 
   &lt;th align="left"&gt;得分&lt;/th&gt; 
   &lt;th align="left"&gt;详细说明&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 理解&lt;/td&gt; 
   &lt;td align="left"&gt;80.8&lt;/td&gt; 
   &lt;td align="left"&gt;执行准确性：87.1 / 执行计划检测：57.1 / 语法错误检测：74.3&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;方言转换&lt;/td&gt; 
   &lt;td align="left"&gt;75.6&lt;/td&gt; 
   &lt;td align="left"&gt;大 SQL 转换：54.8 / 国产数据库：92.1 / 逻辑等价：74.2 / 语法错误检测：85.7&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 优化&lt;/td&gt; 
   &lt;td align="left"&gt;68.4&lt;/td&gt; 
   &lt;td align="left"&gt;逻辑等价：63.2 / 优化深度：64.4 / 语法错误检测：94.7&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h4&gt;亮点与不足&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;亮点&lt;/strong&gt;：执行准确性高，可靠性强；在高级、复杂的优化任务中表现出色。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;不足&lt;/strong&gt;：常规优化能力并非顶级，处理大型、复杂 SQL 转换时能力有限。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;综合评价&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;综合来看，&lt;strong&gt;gpt-5-mini&lt;/strong&gt; 在准确性、可靠性和复杂任务处理上表现均衡，适合追求稳定输出和综合性能的企业级应用。&lt;/li&gt; 
 &lt;li&gt;横向对比来看，&lt;strong&gt;gpt-5-mini&lt;/strong&gt; 在 &lt;strong&gt;SQL 理解维度&lt;/strong&gt; 位列第三，&lt;strong&gt;方言转换&lt;/strong&gt; 维度位列前五，综合实力在参评模型中名列前茅。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;2. gpt-5-nano：高精度代码生成器&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;gpt-5-nano&lt;/strong&gt; 表现出扎实和均衡的能力，其在三个维度上的得分非常接近。&lt;/p&gt; 
&lt;h4&gt;各维度表现得分&lt;/h4&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align="left"&gt;能力&lt;/th&gt; 
   &lt;th align="left"&gt;得分&lt;/th&gt; 
   &lt;th align="left"&gt;详细说明&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 理解&lt;/td&gt; 
   &lt;td align="left"&gt;77.1&lt;/td&gt; 
   &lt;td align="left"&gt;执行准确性：85.7 / 执行计划检测：35.7 / 语法错误检测 75.7&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;方言转换&lt;/td&gt; 
   &lt;td align="left"&gt;66.4&lt;/td&gt; 
   &lt;td align="left"&gt;大 SQL 转换：19.4 / 国产数据库：100 / 逻辑等价：80.6 / 语法错误检测：69.0&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 优化&lt;/td&gt; 
   &lt;td align="left"&gt;68.7&lt;/td&gt; 
   &lt;td align="left"&gt;逻辑等价：89.5 / 优化深度：55.6 / 语法错误检测：100&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h4&gt;亮点与不足&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;亮点&lt;/strong&gt;：生成的 SQL 语法正确性极高，结果可靠；逻辑转换能力扎实。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;不足&lt;/strong&gt;：缺乏对 SQL 执行效率的深层理解；难以应对复杂、冗长的查询迁移。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;综合评价&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-5-nano 是一个出色的"SQL 代码生成器"&lt;/strong&gt; ，适合嵌入自动化工作流，处理标准化的 "&lt;strong&gt;文本到 SQL&lt;/strong&gt;" 和简单方言转换任务。但对于需要深度优化和理解复杂查询的场景，则非其所长。&lt;/li&gt; 
 &lt;li&gt;在本次评测的横向对比中，&lt;strong&gt;gpt-5-nano&lt;/strong&gt; 凭借其 SQL 优化能力进入榜单前五，但在其他维度的竞争中未显现出明显优势。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;3. gpt-5-chat：能力特点分化&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;gpt-5-chat&lt;/strong&gt; 的综合表现不如预期，其能力存在显著的"偏科"现象。&lt;/p&gt; 
&lt;h4&gt;各维度表现得分&lt;/h4&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th align="left"&gt;能力&lt;/th&gt; 
   &lt;th align="left"&gt;得分&lt;/th&gt; 
   &lt;th align="left"&gt;详细说明&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 理解&lt;/td&gt; 
   &lt;td align="left"&gt;62.3&lt;/td&gt; 
   &lt;td align="left"&gt;执行准确性：57.1 / 执行计划检测：60.7 / 语法错误检测 84.3&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;方言转换&lt;/td&gt; 
   &lt;td align="left"&gt;55.4&lt;/td&gt; 
   &lt;td align="left"&gt;大 SQL 转换：3.2 / 国产数据库：86.8 / 逻辑等价：71.0 / 语法错误检测：66.7&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td align="left"&gt;SQL 优化&lt;/td&gt; 
   &lt;td align="left"&gt;56.0&lt;/td&gt; 
   &lt;td align="left"&gt;逻辑等价：52.6 / 优化深度：48.9 / 语法错误检测：94.7&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h4&gt;亮点与不足&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;亮点&lt;/strong&gt;：对复杂的优化策略和逻辑推理有深刻的理论理解。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;不足&lt;/strong&gt;：基础执行的准确性堪忧，生成的 SQL 有较大概率出错；无法处理复杂、大型的查询迁移。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h4&gt;综合评价&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-5-chat&lt;/strong&gt; 在高级理论知识上表现出色，但在基础执行的准确性上存在不足。这种能力分化表明，对模型的评估不应仅依据其通用能力，而需通过专业、细分的场景评测来确定其在特定领域的适用性。&lt;/li&gt; 
 &lt;li&gt;横向来看，&lt;strong&gt;gpt-5-chat&lt;/strong&gt; 在各维度的榜单排名中均未进入前列，其综合定位处于中游水平。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;四、总结与展望&lt;/h2&gt; 
&lt;p&gt;本次特别评测清晰地表明，&lt;strong&gt;GPT-5&lt;/strong&gt; 的发布不仅是数字上的提升，更带来了 AI 在 SQL 领域 &lt;strong&gt;专业化&lt;/strong&gt; 和 &lt;strong&gt;场景化&lt;/strong&gt; 的深刻变革。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;场景定义模型&lt;/strong&gt; ：评测结果表明，企业在选择模型时，应更多地从具体应用场景出发（复杂分析、数据迁移等），而非仅仅依据模型的"名号"或通用能力排名。&lt;strong&gt;gpt-5-mini&lt;/strong&gt; 的胜出，是"场景定义价值"的最佳体现。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;专业化趋势&lt;/strong&gt; ：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlflash.ai%2F" title="SQLFlash" target="_blank"&gt;SQLFlash&lt;/a&gt; 在优化领域的绝对优势，与 &lt;strong&gt;GPT-5 家族&lt;/strong&gt; 内部的能力分化，共同揭示了未来 AI 发展的趋势------通用大模型与领域专用模型将长期共存，互为补充。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;五、下期展望：&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;GPT-5 家族&lt;/strong&gt; 的评测结果揭示了模型能力的巨大分化，也对我们的评测体系提出了新的要求。本月我们将：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;引入新玩家&lt;/strong&gt;：随着 AI 领域的加速发展，我们将引入更多备受关注的新模型，为用户提供更全面的市场视图。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;聚焦专用工具&lt;/strong&gt; ：除了通用模型，我们还将对新兴的 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsqlshift.cn%2F" title="SQLShift" target="_blank"&gt;SQLShift&lt;/a&gt;&lt;/strong&gt; 方言转换应用进行深度剖析，检验其在复杂迁移场景下的真实表现。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;感谢您的关注。我们致力于通过最专业、最深入的评测，为您揭示 AI 在数据领域的前沿进展。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;SCALE：为专业 SQL 任务，选专业 AI 模型。&lt;/strong&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/actiontechoss/blog/18688968</link>
      <guid isPermaLink="false">https://my.oschina.net/actiontechoss/blog/18688968</guid>
      <pubDate>Tue, 19 Aug 2025 02:20:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>字节跳动发布开源大语言模型 Seed-OSS</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;字节跳动的 Seed 团队宣布推出一系列开源大型语言模型 ——Seed-OSS。该系列模型旨在满足国际化（i18n）应用场景的需求，专注于强大的长文本理解、推理能力和灵活的开发者友好特性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Seed-OSS 系列模型基于流行的因果语言模型架构，采用了 RoPE、GQA 注意力机制、RMSNorm 和 SwiGLU 激活函数。&lt;span&gt;最新&lt;/span&gt;发布的 Seed-OSS-36B 模型拥有 360 亿个参数，具备 512K 的长上下文处理能力。尽管该模型仅使用了 12 万亿个训练数据，其在多个流行的基准测试中表现出色。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="329" src="https://oscimg.oschina.net/oscnet/up-6f87300068922ebee13eab7802b4dd4e241.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Seed-OSS 模型系列包括两种版本：带有合成指令数据的 Seed-OSS-36B-Base 和不带合成指令数据的 Seed-OSS-36B-Base-woSyn。这种设计不仅为开发者提供了高性能的基础模型，还为研究者提供了更为多样化的选择，以确保研究的有效性不受合成数据的影响。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;该模型的关键特性之一是 「思考预算」 的灵活控制，允许用户根据需要动态调整推理的长度。这种能力在实际应用场景中大大提高了推理的效率。此外，Seed-OSS 特别优化了推理任务，确保在保持良好一般能力的同时，推理能力也得到了增强。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="375" src="https://static.oschina.net/uploads/space/2025/0821/102210_RBBH_4252687.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在发布会上，Seed 团队强调，Seed-OSS 模型不仅适用于学术研究，还可广泛应用于各类开发任务，例如工具使用和问题解决等代理智能任务。模型的训练和评估结果表明，Seed-OSS 在知识问答、数学推理、编程等任务中的表现达到了开源领域的领先水平。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;对于希望参与的开发者，Seed 团队提供了详细的快速入门指南。用户只需通过 pip 安装相关依赖，即可轻松下载和使用 Seed-OSS 模型。此外，团队还支持多种量化方式以降低内存使用，提高模型的运行效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367553</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367553</guid>
      <pubDate>Tue, 19 Aug 2025 02:20:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenSearch 3.2 发布：增强 AI 能力的下一代搜索和分析</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenSearch 3.2 现已&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FglqBlloPuHeVAidzI5bx5A" target="_blank"&gt;发布&lt;/a&gt;，带来众多功能，提升和拓展搜索、可观测性及生成式 AI 应用场景。&lt;/p&gt; 
&lt;p&gt;本次版本重点延续 3.x 系列的新创新，包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;扩展 GPU 支持&lt;/li&gt; 
 &lt;li&gt;近似框架重大改进&lt;/li&gt; 
 &lt;li&gt;OpenSearch 中 Protobuf 正式发布（GA）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="332" src="https://oscimg.oschina.net/oscnet/up-8384e3d1bc249e0a383aab5423b087ff3e8.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;许多改进旨在帮助更高效地扩展工作负载，提升索引和查询能力。一些重点更新内容如下：&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;搜索&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;搜索在性能、可扩展性和功能扩展上都有多项改进。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;近似框架重大升级&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;OpenSearch 3.2 在两个方面增强了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensearch.org%2Fblog%2Fopensearch-approximation-framework%2F" target="_blank"&gt;近似框架&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;首先，3.2 支持了 search_after 查询，解决了此前此类查询退化为默认 Lucene 遍历的性能瓶颈。改进后，search_after 参数转为合理的范围查询边界——ASC 排序时作为下界，DESC 排序时作为上界，从而持续利用 ApproximatePointRange 优化的 BKD 遍历，避免回退到 Lucene。该优化大幅提升时间序列和数值型分页查询性能。基准测试中，Big5 数据集 p90 延迟从 185ms 降至 8ms，http_logs 数据集 DESC 排序延迟从 397ms 降至 7ms。提升了分页搜索、实时仪表盘及深度分页应用的响应速度。&lt;/p&gt; 
&lt;p&gt;其次，3.2 扩展了近似查询支持的数值字段类型，覆盖 HALF_FLOAT、FLOAT、DOUBLE、INTEGER、BYTE、SHORT、UNSIGNED_LONG，不再限于 LONG。基准测试表明，http_logs 和 nyc_taxis 数据集的 p90 延迟最高下降 80%。这一优化对分析任务、时间序列分析及多样数值字段的快速过滤排序尤为有效。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;体验更高性能的 gRPC/Protobuf API&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.2 版本中，gRPC 传输层正式发布（GA），支持高性能的批量文档导入和 k-NN 查询。相比传统 REST API，gRPC 使用 Protocol Buffers（Protobuf）——一种紧凑、结构化且强类型的二进制格式，自动从 OpenSearch API 规范生成。此格式减小负载体积，提升整体性能，尤其适合高吞吐量操作和向量搜索等原始数据类型。GA 版本还扩展了搜索 API 功能和传输加密。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;新增 skip_list 功能提升查询性能&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.2 引入了 skip_list 参数，适用于频繁用于范围查询或聚合的字段。skip_list 使查询引擎跳过不匹配的文档区间，从而提升查询效率。详情参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.opensearch.org%2Flatest%2Ffield-types%2Fsupported-field-types%2Findex%2F" target="_blank"&gt;字段类型文档&lt;/a&gt;。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;star-tree 搜索新增功能&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;star-tree 支持基于 IP 字段的聚合查询。同时，star-tree 相关的基本查询指标已纳入索引/节点/分片统计，包含使用 star-tree 解析的查询总数、当前运行查询数和累计耗时。详见相关&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensearch.org%2Fblog%2Fthe-power-of-star-tree-indexes-supercharging-opensearch-aggregations%2F" target="_blank"&gt;博客&lt;/a&gt;介绍。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;流式聚合优化资源分配&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.2 试验性引入基于流式传输的聚合功能，支持分段级别的部分聚合结果流式返回给协调节点，避免每个分片返回单一响应。此架构让协调节点成为扩展关键点，内存密集的 reduce 逻辑从数据节点迁移至协调节点，更好支持高基数聚合。通过 stream=true 参数可选择启用此功能。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;向量数据库与生成式 AI&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;OpenSearch 3.2 在性能和扩展性上多项提升，包括支持更多向量类型的 GPU 支持、向量搜索质量改进及 Neural Search 插件更新。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;新向量类型扩展 GPU 支持&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;GPU 索引支持 FP16、byte 和 binary 向量类型，除了之前的 FP32。新类型占用更少内存，减少 GPU 和 CPU 之间的数据传输，提高资源利用率和扩展能力，助力更多 GPU 加速索引应用。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;提升磁盘向量搜索召回率&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.2 推出两种提升二进制量化索引搜索质量的技术。非对称距离计算（ADC）保持查询向量全精度，对压缩文档向量进行比对，保留关键信息。随机旋转（RR）重新分配向量维度方差，防止 32 倍压缩中信息丢失。ADC 支持 1-bit 量化，RR 支持 1、2、4-bit 配置。两者结合可在复杂数据集（如 SIFT）上召回率提升最高达 80%，延迟适中，使二进制量化适用于对精度要求高的场景。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;优化语义搜索，满足多样需求&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Neural Search 插件的语义字段参数更灵活，支持调节密集嵌入字段（engine、mode、compression_level、method）、自定义文本分块算法及稀疏嵌入生成的剪枝策略和比例。新增批量大小选项提升索引吞吐，嵌入复用减少重复计算。提升语义搜索的灵活性、效率和适配性，针对不同数据、性能及相关性需求优化。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Plan-execute-reflect 代理正式发布&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;该代理可自主规划和反思，解决复杂任务，3.2 达到 GA 级别，新增提示词优化性能、消息历史参数控制、支持日期时间输入。通过 ML Commons 插件提供，能将复杂问题拆解为步骤，选择合适工具执行，并不断反思改进策略。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;可观测性、日志分析与安全分析&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;OpenSearch 3.2 在查询性能、Trace Analytics 插件分析能力等方面持续提升。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;支持 OpenTelemetry 和服务图控制&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Trace Analytics 插件支持 OpenTelemetry（OTel）追踪分析，从 Data Prepper 2.11 的数据接收，到 OpenSearch 3.2 的可视化。配置 OTel 源时，设置 output_format: otel，可保留标准字段和元数据，助力与 OTel 工具链集成。服务图新增最大节点和边数配置，方便大规模环境下调整视觉复杂度。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;PPL Calcite 更新提升性能和易用性&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.2 对 Piped Processing Language（PPL）带来性能和查询灵活性提升。新增基于 Calcite 行表达式的脚本引擎，支持聚合函数、过滤函数下推、跨度下推、相关性查询下推、排序合并连接下推及 IP 比较下推。增加参数强制转换、新增日期处理及 QUERY_SIZE_LIMIT 强制执行等功能。整体提升复杂查询的性能、正确性和易用性。&lt;/p&gt; 
&lt;p&gt;&lt;img height="268" src="https://oscimg.oschina.net/oscnet/up-1209318cdde40a0788039ab8abee23e77f6.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;OpenSearch Prometheus Exporter&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Prometheus exporter 插件已归入 OpenSearch 项目，与 3.2 同步发布。该插件不随核心包内置，需单独安装。发布节奏和版本管理已同步 OpenSearch，现有 Prometheus 抓取流程保持兼容，指标继续暴露在 /_prometheus/metrics。&lt;/p&gt; 
&lt;p&gt;更多详情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopensearch-project%2Fopensearch-build%2Fblob%2Fmain%2Frelease-notes%2Fopensearch-release-notes-3.2.0.md" target="_blank"&gt;查看发行说明&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367552/opensearch-3-2-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367552/opensearch-3-2-released</guid>
      <pubDate>Tue, 19 Aug 2025 02:15:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>微软为 Excel 添加 =COPILOT() 函数，引入 LLM 能力</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微软正在为 Excel 添加一项名为 =COPILOT() 的新函数，该功能将大型语言模型 (LLM) 的特性直接集成到电子表格的单元格中，可用于数据分析和内容生成。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1244" src="https://static.oschina.net/uploads/space/2025/0820/190354_6lID_2720166.png" width="1290" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;用户可以直接在网格内使用此函数来帮助填充单元格。根据指定的一组单元格数据，=COPILOT() 函数可以利用 AI 进行分析、生成内容和头脑风暴。具体功能包括生成摘要、标签、表格等。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0c757914b31abe665f8fe19dd133ddcc775.webp" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://techcommunity.microsoft.com/blog/microsoft365insiderblog/bring-ai-to-your-formulas-with-the-copilot-function-in-excel/4443487&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367473</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367473</guid>
      <pubDate>Mon, 18 Aug 2025 11:06:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Augment Code 推出 Agent Turn Summary 功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 编程平台 Augment Code 发布了一项名为&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.augmentcode.com%2Fchangelog%2Fagent-turn-summary" target="_blank"&gt;Agent Turn Summary&lt;/a&gt;的新功能。该功能可以将 Agent 在单次交互（turn）中执行的复杂操作序列浓缩为一行简洁的摘要，让开发者在几秒钟内就能掌握全局，而非花费数分钟滚动浏览大量日志。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-9aa640b9721c46d955b27fcc7aca5797a31.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该功能在 Agent 响应的末尾、反馈页脚旁边显示，内容包括工具调用的摘要与计数，以及所做更改的快照。用户可以一目了然地看到操作的整体范围，仅在需要时才展开查看完整细节。&lt;/p&gt; 
&lt;p&gt;目前，Agent Turn Summary 功能已在 VS Code 和 JetBrains 的预发布版本中提供。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367472</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367472</guid>
      <pubDate>Mon, 18 Aug 2025 11:00:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Kilo Code 新增基于用量的价格估算，支持 Qwen Code</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;strong&gt;Kilo Code&lt;/strong&gt; 近期&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.kilocode.ai%2Fp%2Fkilo-code-v4791v4810-usage-based" target="_blank"&gt;发布重要更新&lt;/a&gt;，新增基于真实用量的 AI 模型价格估算功能，并支持 &lt;strong&gt;QwenCode&lt;/strong&gt; 作为 API provider 。&lt;/p&gt; 
&lt;p&gt;更新后，Kilo Code 能根据真实世界使用情况（基于每日处理超 &lt;strong&gt;300 亿&lt;/strong&gt; token 的真实用量，已计入缓存折扣等因素）估算各模型的平均每百万 token 成本，用户可在设置中查看 。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f7ab70cf8e4317d267793b8e767d3046e4e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-25de1b84c1e8e008e8a8f4c05d59d91f950.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，用户安装 &lt;strong&gt;QwenCode&lt;/strong&gt; 并创建账户后，Kilo Code 能自动找到其配置文件，实现开箱即用的集成 。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-c5cba126534a4d92f8f5cc0513c06ee0973.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Kilo Code 是开源 VS Code AI Agent 扩展，内置最新的 AI 模型，具备强大的代码生成能力，能根据自然语言描述快速生成代码片段，有效减少手动编写代码的时间。Kilo Code 能自动化执行多种重复性编码任务，例如代码格式化、重构以及生成样板代码等，进一步提高开发效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367470</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367470</guid>
      <pubDate>Mon, 18 Aug 2025 10:52:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>谷歌图像编辑 AI 模型 nano-banana 现身 LMArena</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;最近，一款名为 nano-banana 的神秘图像编辑 AI 模型悄然现身 LMArena 平台。有爆料称：这是谷歌正在测试的新模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-daa046b2afeced90c8ac232dead09582575.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f40a92db7e4552760f02564cf4641fa98f1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;谷歌工程师在社交平台上发布香蕉 emoji 或香蕉图片，明示代号为 nano-banana 的图像生成模型为谷歌所有。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-867584592c2b8c9970b5f4314a01c353dda.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前该模型在 LMArena 平台进行测试，但尚未在 AI Studio 上线。在 text-to-image（文生图）和 image-edit（图像编辑）功能方面，nano-banana 展示了强大的能力，其性能被认为超越了 GPT-Image-1 模型。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://lmarena.ai/?chat-modality=image&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367467</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367467</guid>
      <pubDate>Mon, 18 Aug 2025 10:43:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Firecrawl 获 1450 万美元 A 轮融资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Firecrawl 宣布完成 1450 万美元的 A 轮融资。本轮融资由 Nexus Venture Partners 领投，Shopify 首席执行官 Tobias Lütke 及 Y Combinator 等知名投资者跟投。&lt;/p&gt; 
&lt;p&gt;据悉，Firecrawl 通过一封大胆的电子邮件与 Tobias Lütke 建立了联系，此前后者通过自助服务平台试用了 Firecrawl 的产品。这一投资不仅为 Firecrawl 注入了资金动力，也为其技术创新和市场扩展提供了强有力的背书。&lt;/p&gt; 
&lt;p&gt;Firecrawl 表示，此轮融资将用于加速产品研发、扩大全球工程与 AI 专家团队，并进一步优化其服务能力。&lt;/p&gt; 
&lt;p&gt;&lt;img height="351" src="https://oscimg.oschina.net/oscnet/up-0f5d3148770305396b53663dc286ff63317.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Firecrawl 同步推出了其 V2 版本 API，被称为迄今为止最重大的技术升级。新版本在以下几个方面实现了突破：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;10 倍速抓取：通过优化的 Fire-Engine 技术，V2 版本的网页抓取速度提升了 10 倍，成功率提高 40%，为大规模数据处理提供了更高的效率。&lt;/li&gt; 
 &lt;li&gt;语义化爬取：利用自然语言处理技术，Firecrawl 能够根据语义理解网页结构，自动提取所需数据，减少手动干预，提升数据质量。&lt;/li&gt; 
 &lt;li&gt;新增新闻与图像搜索功能：V2 版本新增了对新闻和图像内容的搜索与提取支持，为 AI 应用提供了更丰富的实时数据来源。&lt;/li&gt; 
 &lt;li&gt;多功能集成：持 Markdown、JSON、截图等多种数据格式输出，并与 LangChain 等 AI 框架无缝集成，方便开发者快速构建 AI 应用。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367465</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367465</guid>
      <pubDate>Mon, 18 Aug 2025 10:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>钉钉重注 AI：成立行业专属模型团队，向 CTO 汇报</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWRBSkp0dSe3sfff4WP0CFw" target="_blank"&gt;智能涌现&lt;/a&gt;》独家获悉，钉钉近期成立了一个新业务线——行业专属模型，并作为独立团队存在，向钉钉 CTO 朱鸿汇报。这也是钉钉创始人无招回归后，钉钉在 AI 战略推进中的重要动作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「团队成立后，目前钉钉已经与多家行业客户接触，目前已有几个行业/企业专属模型在推进中。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;自 4 月重返钉钉后，无招将产品体验和 AI 创新作为首要优先级。从 4 月开始，钉钉就经历了一场整改——覆盖范围很广，从产品设计、排查，到整改，无招都在一线深度参与。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;从 ChatGPT 爆火后，钉钉已经完成了大模型基础能力的接入。2023 年 8 月，钉钉就已经将智能化底座 (AI PaaS) 开放给生态伙伴和客户，鼓励合作伙伴利用大模型重新打造产品；再到 2024 年 1 月发布的 AI 助理，具备感知、记忆、规划和行动能力，能够跨应用程序执行任务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据钉钉此前披露的数字，钉钉目前企业组织数超过 2500 万，其中有超 220 万家企业在钉钉使用 AI，覆盖制造、医疗、金融、零售等 20 个一级行业。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;成立行业专属模型团队，是大模型在技术、产品化之后，继续在企业侧落地的体现。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;企业 AI 落地的挑战并不小。一方面，大多数企业、尤其是中小企业虽然对 AI 有强烈需求，但普遍缺乏专业的技术团队和数据处理能力；另一方面，通用大模型虽然功能强大，但难以满足垂直行业的专业需求，需要针对特定场景进行深度定制和优化。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;钉钉的行业专属模型团队，主要面向钉钉平台上的企业客户、第三方合作伙伴。比如，对于没有充足 AI 人才资源的中小企业客户，钉钉会提供全流程的模型训练和数据工程服务，包括前端的数据打标、清洗到模型的调优，都由钉钉团队完成。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;与面向开发者的阿里云旗下百炼等平台相比，钉钉行业专属模型会更贴近业务场景。「行业专属模型是由钉钉和企业中懂业务、懂行业的业务人员共创，将行业 know-how 沉淀下来，让企业客户能够更快、更好地用上模型。」一位钉钉人士对 36 氪表示。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，钉钉已经在行业专属模型方面取得了初步成果。在 7 月发布的豆蔻妇科大模型，其实是钉钉平台上成功落地的第一个垂类专属大模型。其作为医疗领域的垂类模型，可将妇科六大症状的诊断准确率，从 77.1% 提升到 90.2%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在推动行业专属模型的同时，钉钉也在加速完成 AI 生态的闭环，另一个新动作是对应用市场进行改版。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Agent 已经是 2025 年大厂竞争的「明牌」。从 2024 年开始，大厂们已经推出了包括阿里云百炼、字节跳动扣子 (Coze)、百度文心智能体、腾讯元器等 Agent 平台。钉钉也在 2024 年 4 月上线了 AI Agent Store。无招回归钉钉后，一个重要工作也是重新构造 Agent 市场的逻辑。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;除了应用推荐方式大变之外，钉钉未来会在 Agent 市场上再发力，开放能力给更多的 ISV 和企业，帮助企业打造 Agent 应用，并通过钉钉实现商业化闭环，打通整个 Agent 应用生态。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367464</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367464</guid>
      <pubDate>Mon, 18 Aug 2025 10:15:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>DatologyAI 发布合成数据框架 BeyondWeb</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DatologyAI 发布了 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.datologyai.com%2Fbeyondweb%2F" target="_blank"&gt;&lt;strong&gt;BeyondWeb&lt;/strong&gt;&lt;/a&gt;，一个专为大规模语言模型（LLM）预训练设计的合成数据生成框架，旨在突破当前面临的数据瓶颈问题。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0820/181040_p3sx_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该框架采用「目标导向的文档重写」策略，对现有高质量网络数据进行改写，而非从头生成，从而在保证数据多样性和信息密度的同时，避免了低质量内容的引入。&lt;/p&gt; 
&lt;p&gt;据介绍，BeyondWeb 通过高质量、信息密集的合成数据，显著提升了模型性能，即使在原始网络数据有限的情况下，也能实现超越传统数据规模扩展的效果。在 14 项基准测试中，使用 BeyondWeb 生成的合成数据训练的 3B 参数模型，其性能超过了使用 Cosmopedia 数据训练的 8B 参数模型，同时训练速度提升了最高达 7.7 倍。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-eadd4a1595c18a9ec07e6705a60c8bc60c7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;论文地址：https://arxiv.org/pdf/2508.10975&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367463</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367463</guid>
      <pubDate>Mon, 18 Aug 2025 10:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>100% 开源版的 Claude Code？00 后这么勇吗？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;几天前，来新璐告诉我，他做了一个开源版本的 Claude Code 。&lt;/p&gt; 
&lt;p&gt;我问他，能实现几成&amp;nbsp;Claude Code 的效果。&lt;/p&gt; 
&lt;p&gt;他简单地回复我：100%。&lt;/p&gt; 
&lt;p&gt;&lt;img height="124" src="https://oscimg.oschina.net/oscnet/up-3f746e5853445f04492023812b04aeba4d2.png" width="309" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;如果是别人，我可能就当他说大话了。&lt;/p&gt; 
&lt;p&gt;但他是来新璐，llama3 中文版作者，GitHub Star 数已经有 4.2K 了。&lt;/p&gt; 
&lt;p&gt;此前曾在百度&lt;a href="https://www.oschina.net/action/visit/ad?id=1185"&gt;飞桨&lt;/a&gt; &amp;amp; 腾讯混元负责多模态大模型训练、推理相关的开源套件工作。&lt;/p&gt; 
&lt;p&gt;他还开发了多个技术项目，比如文生图大模型训练工具箱 ——&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCrazyBoyM%2Fdreambooth-for-diffusion" target="_blank"&gt;&lt;span&gt;dreambooth-for-diffusion&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，也给 ComfyUI 的 controlnet 部分贡献过代码。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;这么看起来，他还是有点东西的。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;而且，作为一个 00 后，他还&lt;span&gt;是奇绩创坛 F24 校友，&lt;/span&gt;创立了 ShareAI-Lab，一家注重技术创新的实验室性质的公司，面向 toB 市场，做模型后训练、数据合成标注、资料知识库+ AI agent 搜索。&lt;/p&gt; 
&lt;p&gt;公司还有一个技术开发组长，叫陶熠，是斯坦福大学人工智能专业硕士毕业，妥妥的 AI&amp;nbsp;Agent 专家。&lt;/p&gt; 
&lt;p&gt;再加上前段时间，来新璐一直在对 Claude Code 源码进行深度逆向分析，一口气发了 5 篇文章。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fo4pu8QX1tRIPBRlFJqrX3A" target="_blank"&gt;Claude Code 逆向破解 Prompt 篇&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FGspfXKHiwtdhr73KtDgO1w" target="_blank"&gt;Claude Code 分层多 Agent 架构篇&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlBhZhdlb1s0y4qgl_5HSWQ" target="_blank"&gt;Claude Code: 上下文工程 system-reminder 篇&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FMeJTDMcYV2u-TJfOJlLilg" target="_blank"&gt;Claude Code 异步消息通信机制篇&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fj8eTytIDy9l4dnLVHS_Cuw" target="_blank"&gt;Claude Code 最新版解读之自定义 Agent 机制篇&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;现在跟我说搞了个 100% 开源版的 Claude Code，这个可信度就又提高了。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;这个号称 「100% 开源版 Claude Code」 的项目，叫 Kode。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FshareAI-lab%2FKode" target="_blank"&gt;&lt;strong&gt;GitHub 地址：&lt;/strong&gt;https://github.com/shareAI-lab/Kode&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;7 月初就放话说要开源，不过一直没有发布，大家甚至一度以为要被鸽 ！&lt;/p&gt; 
&lt;p&gt;&lt;img height="351" src="https://oscimg.oschina.net/oscnet/up-6f1e9a2460372836c22eccc6194f26d9880.png" width="600" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="background-color:#ffffcc"&gt;不过，最终它来了！目前 GitHub 已经有 900 多 Star。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;与官方 Claude Code 比较之后，也有较多出彩的地方。&lt;/p&gt; 
&lt;p&gt;&lt;img height="268" src="https://oscimg.oschina.net/oscnet/up-20256148956a23d9da17f32f0fa7b0e2416.png" width="600" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;最后，不管我怎么问他，得到的回答都是非常肯定的——Kode 就是开源版 Claude Code。&lt;/p&gt; 
&lt;p&gt;看来，Kode 都是要蹭劳 Claude Code 这波流量了。&lt;/p&gt; 
&lt;p&gt;&lt;img height="195" src="https://oscimg.oschina.net/oscnet/up-6cb6eb15c540029a760c2eea5f8475ec939.png" width="538" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;既然他敢把话说得这么满，那就直播来验一验真假！&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-0635a39399fde8a01a773d4770b4bb9e1d9.png" width="540" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;是骡子是马，拉出来遛遛就知道了！&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;strong&gt;直播主题：&lt;/strong&gt;ShareAI-lab 搞了个 100% 开源版 Claude Code&lt;/p&gt; 
  &lt;p&gt;&lt;strong&gt;直播时间：&lt;/strong&gt;8 月 23 日周五 20:00-21:00&lt;/p&gt; 
  &lt;p&gt;&lt;strong&gt;直播平台：&lt;/strong&gt;视频号 「OSC 开源社区」&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;strong&gt;直播亮点&lt;/strong&gt;&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;拆解 Claude Code 技术设计原理&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;开源版 Claude Code —— Kode 源码带读&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;Claude Code 高阶使用技巧及 SDK 应用潜力场景分享&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;实战：用 Kode 维护大型项目&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;演示：小型 MVP Demo &amp;amp; 使用技巧&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;展望 Agent 世界发展&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;p&gt;&lt;strong&gt;直播福利：&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;福袋抽奖：直播中将有 5 轮抽奖，参与就有机会获得 OSC T 恤、马建仓蛇年公仔（限量版）、代码圣杯、马克杯、冰箱贴、前沿技术书籍等。&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="up-d0ddd08ceeff2b5526d3def6537a6ac649b.png" height="253" src="https://oscimg.oschina.net/oscnet/up-d0ddd08ceeff2b5526d3def6537a6ac649b.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt;
  可以加入 OSC 直播交流群，进来唠唠嗑，或者你有好的产品 / 项目，也欢迎推荐过来呀～ 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="200" src="https://oscimg.oschina.net/oscnet/up-f4e3f0507c7b79ba06185e2b2d6da4cd412.png" width="200" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;hr&gt; 
 &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《技术领航》是开源中国 OSCHINA 推出的一档直播栏目，旨在为&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;开源软件、商业产品、前沿技术、知名品牌活动等各类项目&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供一个展示平台，基本上每周五晚上开播&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;栏目邀请项目的创始人、核心团队成员或资深用户作为嘉宾，通过路演式直播分享项目的亮点和经验，有助于提高项目的知名度，吸引更多的用户和开发者关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你手上也有好的项目，想要跟同行交流分享，欢迎联系我，栏目随时开放～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"&gt;&lt;img height="537" src="https://oscimg.oschina.net/oscnet/up-4dd54c1b0b817689ceefa15aa66d79cfae8.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3859945/blog/18688925</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/18688925</guid>
      <pubDate>Mon, 18 Aug 2025 10:10:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Anthropic 推出 Usage and Cost API</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Anthropic 近期推出了 Usage and Cost API，作为其 Admin API 的一部分，旨在帮助开发者和组织以编程方式实时监控和追踪 Claude 模型的使用情况和成本。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0820/180149_Zv2V_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://docs.anthropic.com/en/api/admin-api/usage-cost/get-messages-usage-report&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;该 API 允许用户通过请求获取详细的用量报告。报告支持多种精细化的筛选和分组条件，包括按 API 密钥 ID、工作区 ID、模型（例如 claude-sonnet-4-20250514）、服务等级（standard,batch,priority）以及上下文窗口大小（0-200k,200k-1M）进行查询。报告的时间粒度可以设置为分钟（1m）、小时（1h）或天（1d）。&lt;/p&gt; 
&lt;p&gt;为了方便开发者快速上手，Anthropic 在 GitHub 的 anthropic-cookbook 项目中提供了一个名为 usage_cost_api.ipynb 的 Jupyter Notebook 示例教程。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/anthropics/anthropic-cookbook/blob/main/observability/usage_cost_api.ipynb&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367457</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367457</guid>
      <pubDate>Mon, 18 Aug 2025 10:02:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>韩国政府拟未来两年采购超 3.5 万枚 GPU</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;韩国科学技术信息通信部周三表示，韩国将在未来两年内采购超过 35000 枚图形处理器（GPU），作为全国范围内加强人工智能（AI）基础设施计划的一部分。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="380" src="https://oscimg.oschina.net/oscnet/up-bef12c45835c72bb33b4f121bbd7f104e9c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;韩国科学技术信息通信部长官裴庆勋当天在国会表示，政府的长期目标是到 2030 年确保 5 万枚 GPU。「我不认为政府能包办一切。政府将为私营部门创造人工智能市场和基础设施投资铺平道路。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作为该计划的一部分，韩国政府启动了一个开发韩国 AI 基础模型的项目，五家公司 Naver Cloud、Upstage、SK Telecom、NC AI 和 LG AI Research 将获得研发资金支持以及政府资源。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此前，韩国政府通过「AI 高速公路」计划，提出了到 2030 年成为全球人工智能领导者的愿景，其中包括建立配备 5 万枚 GPU 的国家人工智能数据中心。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/367456</link>
      <guid isPermaLink="false">https://www.oschina.net/news/367456</guid>
      <pubDate>Mon, 18 Aug 2025 10:01:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>COLMAP - 三维重建软件</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                            &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;COLMAP 是一个通用的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;Structure-from-Motion (SfM) 和 Multi-View Stereo (MVS) pipeline&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，具有图形和命令行界面。它提供了丰富的功能，可用于重建有序和无序图像集。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img alt="" height="210" src="https://static.oschina.net/uploads/space/2025/0818/145035_b3XQ_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img alt="" height="102" src="https://static.oschina.net/uploads/space/2025/0818/145138_oR0u_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你将此项目用于您的研究，请引用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;@inproceedings{schoenberger2016sfm,
    author={Sch\"{o}nberger, Johannes Lutz and Frahm, Jan-Michael},
    title={Structure-from-Motion Revisited},
    booktitle={Conference on Computer Vision and Pattern Recognition (CVPR)},
    year={2016},
}

@inproceedings{schoenberger2016mvs,
    author={Sch\"{o}nberger, Johannes Lutz and Zheng, Enliang and Pollefeys, Marc and Frahm, Jan-Michael},
    title={Pixelwise View Selection for Unstructured Multi-View Stereo},
    booktitle={European Conference on Computer Vision (ECCV)},
    year={2016},
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你使用 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;image retrieval / vocabulary tree engine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，请同时引用：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;div&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;@inproceedings{schoenberger2016vote,
    author={Sch\"{o}nberger, Johannes Lutz and Price, True and Sattler, Torsten and Frahm, Jan-Michael and Pollefeys, Marc},
    title={A Vote-and-Verify Strategy for Fast Spatial Verification in Image Retrieval},
    booktitle={Asian Conference on Computer Vision (ACCV)},
    year={2016},
}
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;COLMAP 建立在现有成果之上，在 COLMAP 中使用特定算法时，请注明原始作者（如源代码中所述），并考虑引用相关的第三方依赖项（例如 ceres-solver、poselib、sift-gpu 和 vlfeat）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/colmap</link>
      <guid isPermaLink="false">https://www.oschina.net/p/colmap</guid>
      <pubDate>Mon, 18 Aug 2025 09:38:00 GMT</pubDate>
    </item>
  </channel>
</rss>
