<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-最新资讯</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-最新资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Mon, 24 Mar 2025 02:37:48 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>Perplexity 欲收购 TikTok 并开源其算法</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;人工智能搜索初创公司 Perplexity 近日在官方博客&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.perplexity.ai%2Fhub%2Fblog%2Frebuilding-tiktok-in-america&quot; target=&quot;_blank&quot;&gt;发布文章&lt;/a&gt;&lt;/u&gt;，提出收购（并改造）TikTok 的要约。&lt;/p&gt; 
&lt;p&gt;该公司写道：「Perplexity 拥有独特的优势，可以在不造成垄断的情况下重建 TikTok 算法，将世界一流的技术能力与 Little Tech 的独立性结合起来。」&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2e5510e21cdce267c8df1b32cb6fc68d994.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;他们声称，他们拥有独特的优势，可以「不造成垄断」地做到这一点，这与竞争对手或投资者财团可能进行的收购不同，后者可能会保持字节跳动的影响力。该计划包括：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;「在美国数据中心和美国监督下」从头重建 TikTok 算&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;让推荐系统「透明」且开源&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用 NVIDIA Dynamo 技术升级 AI 基础设施&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;为视频添加与 Perplexity 现有功能类似的引用功能&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;将 Perplexity 的搜索功能与 TikTok 的视频库相集成&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;为连接 Perplexity 和 TikTok 账户的用户增强个性化（该初创公司声称，「这可以帮助在 TikTok 上展示更多相关内容」）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;通过自动翻译添加多语言功能&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;全文如下&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在美国重建 TikTok 的愿景&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 的使命一直是通过准确、透明且易于获取的信息满足全世界的好奇心。自 2022 年由一群 AI 研究人员创立以来，我们一直致力于成为世界上最好的答案引擎。&lt;/p&gt; 
&lt;p&gt;TikTok 已成为最重要、最真实的创意表达和内容发现平台之一，连接着全球数百万用户。我们认为 Perplexity 可以让 TikTok 变得更好。&lt;/p&gt; 
&lt;p&gt;我们很高兴能够分享我们所设想的未来：一个对每个人都更有用的 TikTok，用户拥有易于使用的工具，可以让他们深入了解并寻求真相，并由世界上最好的答案引擎提供支持。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在美国建立透明的算法&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 拥有独一无二的优势，能够重建 TikTok 算法而不会造成垄断，将世界一流的技术能力与 Little Tech 的独立性结合起来。任何投资者财团的收购实际上都可能让字节跳动控制算法，而任何竞争对手的收购都可能在短视频和信息领域造成垄断。当内容信息流从外国政府和全球主义垄断者的操纵中解放出来时，整个社会都会受益。&lt;/p&gt; 
&lt;p&gt;TikTok 的「为你推荐」推送针对每个用户进行个性化设置，构建实时推荐系统对于保持短视频平台的新鲜感和趣味性至关重要。Perplexity 将首先构建这些基本系统，以确保用户获得无缝体验。该基础设施将在美国数据中心开发和维护，并接受美国监管，确保符合国内隐私标准和法规。&lt;/p&gt; 
&lt;p&gt;TikTok 算法如今是一个黑匣子。我们认为这些推荐系统应该是透明的。为了消除用户操纵的风险，我们建议以透明为指导原则从头开始重建 TikTok 算法。我们承诺将 TikTok 打造成世界上最中立、最值得信赖的平台。为了实现这一目标，我们不仅致力于开发新算法，还致力于将 TikTok For You 信息开源。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;升级至世界一流的人工智能基础设施&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 运行的先进 AI 基础设施由 NVIDIA Dynamo 提供支持（在 2025 年 NVIDIA GPU 技术大会上宣布，并提到 Perplexity 是其最喜欢的合作伙伴），可以轻松将 TikTok 的推荐模型扩展 100 倍，同时实现更快的推理速度，从而提高 TikTok 的推荐系统的标准，使其成为世界上最好的。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;利用 Perplexity 的引文和社区注释功能增强对 TikTok 的信任&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 上的所有答案都包含引文，我们认为这对于创建值得信赖的信息生态系统至关重要。作为第一步，Perplexity 将立即将此功能扩展到 TikTok 视频，让用户在观看视频时可以轻松实时交叉引用信息。&lt;/p&gt; 
&lt;p&gt;我们可以开发世界上最强大的上下文系统。该系统利用社区反馈和人工智能功能来突出显示可靠信息。这种方法类似于我们在 X 上的 @AskPerplexity 帐户，该帐户已获得超过 13 万名粉丝，每天为数千名用户提供上下文信息。通过将类似的功能引入 TikTok，我们可以确保用户在滚动「为您推荐」信息流时能够访问世界一流的信息工具。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;打造全球最佳「搜索框」&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;将 Perplexity 的答案引擎与 TikTok 的丰富视频库相结合，我们将能够打造世界上最好的搜索体验，让 TikTok 和 Perplexity 用户随时随地通过任何媒介获得他们寻求的答案。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;使用 Perplexity 的答案引擎增强 TikTok 搜索：这将为用户提供全面、引用充分的答案，将世界上最好的答案引擎与最大的用户生成内容库之一相结合。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;将 TikTok 视频引入 Perplexity：同时，Perplexity 的答案将通过 TikTok 视频进行丰富，以将相关内容带入专业、推理和深入研究。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;无论您是在寻找 100 美元以下的最佳网球拍，试图了解收益电话会议对股票的影响，还是想知道当地人喜欢吃饭的地方——我们都会始终致力于让您获得最好的结果。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;让 TikTok 对每个人都有用&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;除了构建基础设施之外，我们的首要任务是提升用户在 TikTok 上发现的内容的信息价值。我们认为，用户在平台上花费的时间应该是值得的，指标和优化应侧重于用户满意度和信息价值，而不仅仅是参与度。&lt;/p&gt; 
&lt;p&gt;对于选择将 Perplexity 和 TikTok 帐户关联的用户，我们可以利用跨平台信号来改善个性化。Perplexity 通过问题和空间了解用户的兴趣，可以帮助在 TikTok 上展示更多相关内容。同样，TikTok 上的内容偏好可以为 Perplexity 提供更个性化的答案。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;利用人工智能丰富内容&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 的 LLM 编排功能可通过为视频添加上下文信息甚至多语言功能来改变 TikTok 体验。通过自动翻译和注释，创作者可以轻松将影响力扩大到全球观众。&lt;/p&gt; 
&lt;p&gt;对于用户来说，这将提供广度和深度——提供对更多样化内容的访问，同时允许更深入地探索引起他们好奇心的话题。想象一下，观看有关量子物理的视频并能够直接从该内容发起深入的研究查询。这种集成将允许用户在 TikTok 的滚动体验和 Perplexity 强大的研究功能之间无缝过渡——所有这些都在单一、统一的 Feed 中完成。&lt;/p&gt; 
&lt;p&gt;从重建开源「为你推荐」算法到利用最新的 AI 基础设施增强个性化，我们对 TikTok 可能实现的可能性感到兴奋。将 Perplexity 在提供准确、值得信赖的答案方面的专业知识与 TikTok 充满活力、富有创意的社区和丰富的视频库相结合，将使每个人都受益。由 Perplexity 重建和支持的 TikTok 将打造出世界上最伟大的创造力和知识发现平台。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/330728&quot; target=&quot;news&quot;&gt;美国 AI 初创企业 Perplexity 寻求与 TikTok 合并&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/326518&quot; target=&quot;news&quot;&gt;字节 TikTok 算法负责人陈志杰或于近期离职，开启 AI Coding 方向创业&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/295111/tiktok-preparing-us-copy-apps-core-algorithm-sources-say&quot; target=&quot;news&quot;&gt;TikTok 准备在美国复制一套该应用的核心算法&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340590/perplexity-rebuilding-tiktok-in-america</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340590/perplexity-rebuilding-tiktok-in-america</guid>
            <pubDate>Mon, 24 Mar 2025 02:29:22 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>​全球首个体重管理 AI 大模型 「减单」 发布，基于 DeepSeek 等</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;安徽医科大学联合中国科学技术大学附属第一医院和健康科技企业，近日在合肥发布体重管理大模型智能助手「减单」，希望借助 AI 技术提高减重的个性化干预质量和诊疗效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据介绍，「减单」 模型的构建，基于 DeepSeek、OpenAI 及豆包三个大模型，结合过 40 万名肥胖相关慢性疾病患者的管理数据，不断训练而成。与其他同类模型不同，「减单」 专注于生活方式的干预，旨在应用于肥胖相关的慢性疾病管理。诺&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户拍照上传每餐食物，大模型智能助手自动识别分析营养成分和热量，结合用户健康档案，生成个性化评价和膳食指导建议。此外，该模型的模块化应用也将扩展至内分泌科、营养科及全科管理等领域，预计在未来三年内覆盖超过 1 亿名慢性病患者。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据《中国居民营养与慢性病状况报告（2020 年）》，2018 年我国成人超重率和肥胖率分别为 34.3% 和 16.4%，6 岁至 17 岁儿童青少年超重率和肥胖率分别为 11.1% 和 7.9%，并呈逐年递增趋势。国家衞生健康委发布的《体重管理指导原则（2024 年版）》指出，有研究预测，若该趋势得不到有效遏制，2030 年我国成人、儿童超重肥胖率将分别达到 70.5% 和 31.8%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;安徽医科大学校长、中国科学技术大学临床医学院执行院长翁建平介绍，AI 大模型智能助手结合专业化医生的人工支持，可以实现对肥胖人群「千人千策」式的个性化干预，帮助老百姓从「被动治疗」转向「主动预防」。下一步，研发团队将继续优化「减单」的功能并致力于推广，让人工智能技术惠及我国更多的肥胖相关慢性疾病患者。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340589</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340589</guid>
            <pubDate>Mon, 24 Mar 2025 02:24:22 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>上海交大发布大模型 Venus，可让蛋白质「定向进化」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上海交通大学特聘教授洪亮团队近日发布了大模型 Venus，其核心能力是让蛋白质实现功能的「定向进化」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;团队将 AI 与蛋白质设计与改造相结合，建立了全球最大的蛋白质数据集，基于该数据集训练的模型，可以精准、高效地预测、设计蛋白质的功能，把蛋白质生产由「缓慢的试错」变为「高效率的精准设计」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果想要强化目标蛋白质的某个功能，只需要提供该蛋白质的序列信息，Venus 就可以快速给出一批蛋白质序列改造方案，随后结合实验验证得到最优改造方案。据悉，经过 Venus 系列模型设计的多款蛋白质已经实现了落地产业化，将助力阿尔兹海默等疾病的诊断。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;335&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8fe0d70f558b02cbaba3a1c6707d54d13f8.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;洪亮团队建立的蛋白质序列数据集 Venus-Pod（Venus-Protein Outsize Dataset）含有近 90 亿条蛋白质序列，包含数亿个功能标签，是全球数据规模最大、功能批注标签最多的数据集，也是另一行业知名模型——美国 ESM-C 模型训练用的 21 亿蛋白质序列的 4 倍体量。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;该数据集包含 36.2 亿条陆地微生物蛋白质序列、26.4 亿条海洋微生物蛋白质序列、24.3 亿条抗体蛋白质序列、0.6 亿条病毒蛋白质序列，覆盖从常规地表生物到极端环境微生物的蛋白质序列信息，尤其是配备的数亿功能标签（蛋白质工作的温度、酸碱度、压强等）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「我们训练了 Venus（启明星）系列模型，与 DeepMind 团队的 AlphaFold 预测蛋白质结构不同，这个模型学习自然界蛋白质序列的组织规则以及它与功能之间的关系，其预测蛋白质突变功能的精度位居行业榜单之首。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;洪亮表示，Venus 系列模型具备两大核心功能：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「AI 定向进化」与「AI 挖酶」。所谓「AI 定向进化」是指 Venus 系列模型可以对一个不尽如人意的蛋白质产品的多种性能进行优化，让它成为一个「六边形战士」满足应用需求。而「AI 挖酶」则是指 Venus 系列模型基于其海量的未知功能蛋白质数据集，可以「海选超能力战士」，去精准发掘满足苛刻应用需求的具备超常规功能的蛋白质，比如极度耐热、极度耐酸、极度耐碱、极度耐胃肠消化等。这些超常规功能的蛋白质在生物技术、医药研发和工业生产中具有巨大的应用潜力，能够为相关领域带来创新和突破。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340580</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340580</guid>
            <pubDate>Mon, 24 Mar 2025 02:13:22 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Docker 将原生支持运行 LLM</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.docker.com%2Fllm%2F&quot; target=&quot;_blank&quot;&gt;根据 Docker 官网消息&lt;/a&gt;&lt;/u&gt;，其即将推出 Docker Model Runner 工具，旨在通过容器化技术简化 LLM 本地运行流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0324/100640_My7h_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其主要功能包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模型获取：支持从 Docker Hub 直接获取 AI 模型，简化配置流程。&lt;/li&gt; 
 &lt;li&gt;操作便捷：通过 Docker 命令行工具使用，符合开发者日常操作习惯。&lt;/li&gt; 
 &lt;li&gt;接口兼容：适配 OpenAI 标准接口，方便现有项目集成。&lt;/li&gt; 
 &lt;li&gt;运行效率：支持苹果芯片和 NVIDIA 显卡加速，提升本地计算性能。&lt;/li&gt; 
 &lt;li&gt;安全隔离：沿用 Docker 容器技术，保障运行环境的安全性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;当前开发者普遍使用 ollama 开源工具部署 AI 模型。相比而言，Docker Model Runner 对已在使用容器技术的开发者具有天然适配优势。而 ollama 作为成熟的开源工具，拥有丰富的模型支持和活跃的社区资源。&lt;/p&gt; 
&lt;p&gt;有意思的是，ollama 本身也支持在 Docker 环境中运行，这为用户提供了更多选择空间。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340579/docker-model-runner-run-llms-natively</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340579/docker-model-runner-run-llms-natively</guid>
            <pubDate>Mon, 24 Mar 2025 02:13:22 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>腾讯混元自研深度思考模型「T1」发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;腾讯已于近日&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F38ilIogkFK8tbgRFDSXdSw&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;正式推出自研深度思考模型混元 T1 正式版。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「T1」吐字快、能秒回，还擅长超长文处理，是腾讯自研的强推理模型，已经上线腾讯云，即将在腾讯元宝灰度上线。通过大规模强化学习，并结合数学、逻辑推理、科学和代码等理科难题的专项优化，混元 T1 正式版进一步提升了推理能力。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告称，在体现推理模型基础能力的常见 benchmark 上，如大语言模型评估增强数据集 MMLU-PRO 中，混元 T1 取得 87.2 分，仅次于 o1。在 CEval、AIME、Zebra Logic 等中英文知识及竞赛级数学、逻辑推理的公开基准测试中，混元 T1 的成绩也达到业界领先推理模型的水平。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「T1」还在多项对齐任务、指令跟随任务和工具利用任务中展现出了非常强的适应性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;323&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c5034efbc2180d11de8f1e91ba6bf5ff565.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;351&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-89b33c47634ba22094d141898c359f35e39.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;混元 T1 正式版沿用了混元 Turbo S 的创新架构，采用 Hybrid-Mamba-Transformer 融合模式。「这是工业界首次将混合 Mamba 架构无损应用于超大型推理模型。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;这一架构有效降低了传统 Transformer 结构的计算复杂度，减少了 KV-Cache 的内存占用，从而显著降低了训练和推理成本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;混元 T1 在超长文本推理领域也展现出独特优势，能有效解决长文推理中常见的上下文丢失和长距离信息依赖问题。同时，混合 Mamba 架构针对长序列处理进行了专项优化，通过高效的计算方式，在确保长文本信息捕捉能力的同时大幅降低资源消耗，在相近的激活参数量下，实现了解码速度提升 2 倍。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340576</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340576</guid>
            <pubDate>Mon, 24 Mar 2025 02:01:22 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>《AppGallery 版本升级，好用小妙招请查收》</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;近期,鸿蒙应用市场（AppGallery）已升级到 6.0.2 版本。新版本带来了哪些全新变化和实用小技巧？想要一键找到同类型更多应用，并同时高速下载，有什么好方法呢？本期的跟手教程别错过！&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;一、「应用更新」优化，长长的更新列表「不见了」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;针对有用户提到在「我的」页面中看到「应用更新」展示的列表太长、占版面等问题，新版本的 AppGallery 进行了优化。目前进入进入「应用市场&amp;gt;我的」你会发现页面更清爽、长串的待更新应用列表不见了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;那更新列表去哪里了呢？点击进入「应用更新」，你可看到：应用更新列表在这里，且已分成了「待更新」和「最近已更新」两部分展示。「待更新」可提醒大家进行应用升级，「最近已更新」列表能帮助大家随时查看更新记录，了解应用更新后的新特性。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;此外，当所有应用均为最新版本时，在「我的」页面就可以直接看到相应的提示，这对于有 「应用更新强迫症」的朋友来说无疑是一个福音。&amp;nbsp;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;2.png&quot; height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet//9a443ec842a34c20c679ca60a3ce582a.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;二、一键可达同类应用列表&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;接下来的小技巧，必须要敲黑板了！首先新版本的 AppGallery 在应用页增加了&lt;strong&gt;腰部分类胶囊&lt;/strong&gt;的模块，提供了超过 20 个分类胶囊，大家可以通过滑动选择感兴趣的胶囊，找到同类型应用列表；比如点击了「房产与装修」胶囊，常用的找房和装修类 App&amp;nbsp;就出现眼前了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;同类应用太多，该怎么选？可以看看 AppGallery 给你哪些推荐和实用解题思路。回到「房产与装修」列表中，随机选择《贝壳找房》进入详情页，详情页下方可找到「相关专题」栏目，打开专题内容浏览，获取使用技巧，如利用《贝壳找房》搜索短租的资源等。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;让探索更高效，为你的选择提供更有价值的参考，这么好用的技巧要是不知道可真太浪费了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;3.png&quot; height=&quot;610&quot; src=&quot;https://oscimg.oschina.net/oscnet//ec965fbc9f249d96b8a34c622b1d7a69.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;三、应用同时下载能力增强&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;本次更新后， AppGallery 最多可支持同时下载或更新 3 个应用，这一改进将极大地提升大家在使用新机或有批量下载需求时的效率。众所周知，HarmonyOS 5 应用下载速度和使用流畅度都有了很大的提升，如今可支持同时下载多个应用，必然会给大家带来加倍的便利和快乐。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;4.png&quot; height=&quot;735&quot; src=&quot;https://oscimg.oschina.net/oscnet//b3a69f29699edeac988ee2b7dc1dae46.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;四、横滑一下，就可获取更多应用信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;在 AppGallery 版本升级后，应用详情页悄悄发生了变化。在应用信息栏的位置，轻轻往左一滑，就能看到应用分类、开发者信息和应用包体大小，针对「一眼锁定」应用的用户来说可帮了大忙，不用再滑到下面去检索信息。这虽然是一个非常小的改变，但在为用户检索应用时，提供了更多参考维度。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;还要告诉你一个小技巧，应用分类的图标就是一个分类胶囊，点击后即可轻松进入同类应用列表了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;5.png&quot; height=&quot;802&quot; src=&quot;https://oscimg.oschina.net/oscnet//2b4db5f745415945cac452a69f850590.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;五、「下载记录」和「购买记录」中的应用操作办法&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;最后一点可能对应用发烧友来说更感兴趣，新版本的 AppGallery 除了能够常规的管理应用下载记录（长按操作）和购买记录（滑动操作）之外，大家还可以随时取消之前添加的「心愿单」应用，这一功能虽然不常用，但也可解用户所需。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;以上就是 AppGallery6.0.2 版本更新的实用小妙招。如果大家还在使用旧版本，不妨赶紧更新体验一下。当然，AppGallery 的宝藏功能远不止这些，更多惊喜等待你去探索发现！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340252</guid>
            <pubDate>Fri, 21 Mar 2025 10:14:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>OpenAI CEO 奥特曼 ：DeepSeek 教训了我们，GPT-5 将免费开放</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;日前，&amp;nbsp;OpenAI CEO 奥特曼在与硅谷知名分析师 Ben Thompson&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstratechery.com%2F2025%2Fan-interview-with-openai-ceo-sam-altman-about-building-a-consumer-tech-company%2F&quot; target=&quot;_blank&quot;&gt;对谈&lt;/a&gt;&lt;/u&gt;中提到 DeepSeek。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/164748_HXaN_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;奥特曼认为 DeepSeek 确实是个很棒的团队，也做出了很优秀的模型，&lt;strong&gt;但他们真正走红的原因，并不完全是模型本身的能力&lt;/strong&gt;。&lt;br&gt; &amp;nbsp;&lt;br&gt; 「这对我们来说是一个教训，那就是当我们隐藏一个功能时（思维链），我们给其他人留下了获得病毒式传播的机会。这是一个很好的警醒。它也让我重新思考我们在免费层中提供的内容， GPT-5 将可以免费使用」，奥特曼这样看 DeepSeek 的走红。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;奥特曼表示，OpenAI 其实早就有类似能力，只是过去出于谨慎考虑没有对外开放，怕太智能会变得不可控。但现在回头看，这种「保守」反而错失了机会，「我们做的模型更好，但大家没注意到，反而被别人抢走了注意力」，他还透露，GPT-5 会加入更多功能，思维链、联网搜索、甚至更长记忆都有可能下放，算是一个明显的转向。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338735/openai-calls-deepseek-state-controlled&quot; target=&quot;news&quot;&gt;OpenAI 呼吁美国政府禁止 DeepSeek&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338329/openai-chain-of-thought-monitoring&quot; target=&quot;news&quot;&gt;OpenAI 透露 CoT 思维链研究成果：CoT 监控可阻止大模型恶意行为&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/336125/openai-gpt-4-5&quot; target=&quot;news&quot;&gt;OpenAI 正式发布 GPT-4.5 模型&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340236</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340236</guid>
            <pubDate>Fri, 21 Mar 2025 08:48:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>马斯克：2024 年特斯拉 AI 投资约 100 亿美元、FSD 安全水平将超过人类</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;特斯拉公司 CEO 埃隆・马斯克今天在员工大会上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCernBasher%2Fstatus%2F1902918128876544315&quot; target=&quot;_blank&quot;&gt;分享&lt;/a&gt;&lt;/u&gt;了公司在电动汽车、储能、智能辅助驾驶、人工智能计算及人形机器人等业务板块的最新动态。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-39bef0ad1f0e3c05326afa6e48d068ce7c8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;马斯克称，特斯拉用于智能辅助驾驶训练的 Cortex 算力中心目前已有超过 5 万块 GPU，且即将突破 10 万块大关，跻身全球前五大超级计算中心。&lt;/p&gt; 
&lt;p&gt;此外，Dojo 2 超级计算机即将问世，其将比第一代 Dojo 超级计算机强大 10 倍。目前，Dojo 超级计算机已在纽约超级工厂投入运行，承担了特斯拉 5% 至 10% 的智能辅助驾驶训练数据量。&lt;/p&gt; 
&lt;p&gt;马斯克透露，2024 年特斯拉在人工智能方面的投资约达 100 亿美元（现汇率约合 724.51 亿元人民币），其中约一半为内部投入，主要用于特斯拉自研的 AI 推理计算机、所有车辆传感器以及 Dojo 超级计算机。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-caf53effe89e63245f2c7f3bdf2d0223c1b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;特斯拉全系现款在售车型均已搭载 AI 4 智能辅助驾驶硬件。尽管 AI 4 硬件设计于数年前，但至今仍无同类产品超越其性能。AI 4 不仅性能强大，且能耗极低。&lt;strong&gt;未来几年，特斯拉将推出 AI 5、AI 6、AI 7 硬件&lt;/strong&gt;，但马斯克强调，消费者不应因此延迟购买，因为特斯拉的技术进化永无止境，早入手即可早享受，现阶段的 AI 4 对于特斯拉智能辅助驾驶硬件来说已经足够。&lt;/p&gt; 
&lt;p&gt;马斯克还表示，特斯拉的智能辅助驾驶系统在行驶过程中所需的干预越来越少，&lt;strong&gt;最终将完全无需人工干预，且行驶安全水平将超过人类驾驶，达到比人类安全 10 倍的水平&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;目前，在北美地区，特斯拉的智能辅助驾驶系统（北美称 FSD）已经能够实现从弗里蒙特工厂下线的车辆在无人驾驶情况下自行开往目的地停车场，等待装车长途运输。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/339990/blackrock-ai-infrastructure-partnership&quot; target=&quot;news&quot;&gt;马斯克 xAI 和微软、贝莱德等组成新联盟，共建 300 亿美元 AI 基础设施项目&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334522/xai-grok3&quot; target=&quot;news&quot;&gt;马斯克旗下 xAI 发布 Grok 3 推理模型，声称超越 o1、R1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340233</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340233</guid>
            <pubDate>Fri, 21 Mar 2025 08:38:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Minesweeper MCP Server —— 扫雷 MCP 服务器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Minesweeper MCP Server 是一个扫雷 MCP 服务器，让 Claude 可以玩扫雷游戏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0d7a16d356b0beb3c58ab8498176657e2fd.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/minesweeper-mcp-server</link>
            <guid isPermaLink="false">https://www.oschina.net/p/minesweeper-mcp-server</guid>
            <pubDate>Fri, 21 Mar 2025 08:32:00 GMT</pubDate>
        </item>
        <item>
            <title>刘强东：技术算法不应压榨最底层兄弟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 21 日，据网传截图显示，近日刘强东在朋友圈发文评价京东为快递员缴纳五险一金一事，对此，界面新闻向京东求证，对方回应，截图内容属实。刘强东称，去年是创业 20 年以来最有成就感的时候，因为仅仅快递小哥就有 1200 多个兄弟退休了。每人可领取数十万公积金、每月 5350 元退休金，并享受医保全覆盖。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;刘强东称，我们所学的知识、商业模式、技术算法都不应该是用来压榨社会最底层的兄弟们的，我们的利润、市值和财富更不应该建立在底层百姓无保障的生活之上的。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;刘强东呼吁所有快递员和骑手都可以获得五险一金待遇，因为今天中国几大平台的利润和市值完全可以支撑，期待各阶层一起幸福生活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;512&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/163026_g23O_4252687.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340231</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340231</guid>
            <pubDate>Fri, 21 Mar 2025 08:30:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>浏览器崩溃的第一性原理：内存管理的艺术</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;79&quot; data-source-title=&quot;&quot;&gt; 
  &lt;section class=&quot;js_blockquote_digest&quot;&gt; 
   &lt;section&gt;
     你是否曾经遇到过浏览器突然卡顿，甚至崩溃的情况？尤其是在打开多个标签页或运行复杂的网页应用时，浏览器似乎变得异常脆弱。这种崩溃的背后，往往与内存管理息息相关。 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/blockquote&gt; 
 &lt;section style=&quot;text-indent: 0em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;浏览器的内存管理机制决定了它能否高效地分配和释放资源，而 JavaScript 引擎 V8 正是这一机制的核心。&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;本文将探讨 V8 的内存管理机制，帮助你理解浏览器崩溃的根源，并学会如何优化内存使用，避免类似问题的发生。&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;3&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;一、内存管理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;底层语言（如 C 语言）拥有手动的内存管理原语，例如：&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;ree()&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;。相反，JavaScript 是在创建对象时自动分配内存，并在不再使用时自动释放内存（垃圾回收）。这种自动化机制虽然方便，但也容易让我们产生误解，认为不需要关心内存管理，从而忽略潜在的内存问题。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;5&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;二、内存生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;无论使用何种编程语言，内存的生命周期通常都遵循以下步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ul data-nodeid=&quot;7&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;182&quot;&gt;分配内存&lt;/strong&gt;：根据需求分配所需的内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;187&quot;&gt;使用内存&lt;/strong&gt;：对分配的内存进行读写操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;192&quot;&gt;释放内存&lt;/strong&gt;：在内存不再需要时将其释放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;在底层语言中，内存的分配和释放是显式的，开发者需要手动管理。而在高级语言如 JavaScript 中，内存的分配和释放大多是隐式的，由垃圾回收机制自动处理。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;15&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1 内存分配&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_4&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;16&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1.1 值的初始化&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;为了不让我们费心内存分配，JavaScript 在值初次声明时自动分配内存。&lt;/span&gt;&lt;/p&gt; 
 &lt;pre data-nodeid=&quot;18&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;28&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为数值分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为字符串分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; o = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为对象及其包含的值分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 为数组及其包含的值分配内存（就像对象一样）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为函数（可调用的对象）分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 函数表达式也会分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;someElement.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;click&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    someElement.style.backgroundColor = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;19&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2.1 通过函数调用分配内存&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些函数调用的结果是为对象分配内存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;21&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为 Date 对象分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; e = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;div&quot;&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为 DOM 元素分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些方法为新值或新对象分配内存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;23&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;azerty&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s2 = s.substr(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// s2 是一个新的字符串&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 因为字符串是不可变的值，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// JavaScript 可能决定不分配内存，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 只是存储了 [0-3] 的范围。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yeah yeah&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a2 = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;generation&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a3 = a.concat(a2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 有四个元素的新数组，由 a 和 a2 其中的元素连接而成。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;24&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2 变量读取&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用值通常涉及对分配的内存进行读写操作。无论是读取变量值、访问对象属性，还是传递函数参数，都会使用到内存中的值。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;26&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.3 内存回收（垃圾回收）&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;当内存不再需要时，系统会将其释放。大多数内存管理问题都出现在这一阶段，尤其是如何确定已分配的内存何时不再需要。在底层语言中，开发者需要手动判断并释放内存，而 JavaScript 则通过垃圾回收机制自动完成这一任务。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;28&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;三、V8 的垃圾回收&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;垃圾回收的核心任务是识别内存中的「死区」，即不再使用的内存。一旦识别出这些区域，它们可以被重新用于新的内存分配或释放回操作系统。一个对象如果不再被根对象或活跃对象引用，则被视为「死的」。根对象通常是活跃的，例如局部变量、全局对象或浏览器对象（如 DOM 元素）。&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;例如：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;31&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; obj = { &lt;span class=&quot;code-snippet__attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  g(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// might contain an infinite loop.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj.x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于无法精确判断对象是否会被再次引用（这相当于停机问题），垃圾回收器采用了一种宽松的定义：如果对象可以通过某个指针链从根对象到达，则该对象是活跃的，否则就是垃圾。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;33&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.1 V8 内存结构&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;V8 的内存分为以下几个主要部分：&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028741&quot; data-ratio=&quot;0.7166882276843467&quot; src=&quot;https://oscimg.oschina.net/oscnet/ca11da54-bc8b-4a09-9c14-3c4399c0411a.png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;35&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;219&quot;&gt;堆内存（Heap）&lt;/strong&gt;：&lt;br&gt;堆内存是 V8 中用于动态分配内存的区域，存储 JavaScript 对象、闭包、函数等数据。堆内存进一步分为以下几个区域：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;38&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;226&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;新生代&lt;/span&gt;&lt;/strong&gt;：用于存储生命周期较短的对象（如临时变量、局部变量等）。分为两个半空间（From Space 和 To Space），采用 Scavenge 算法进行垃圾回收。新生代空间较小，垃圾回收频率较高。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;233&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;老生代&lt;/span&gt;&lt;/strong&gt;：：用于存储生命周期较长的对象（如全局变量、闭包等）。采用标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）算法进行垃圾回收。老生代空间较大，垃圾回收频率较低。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;240&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;代码空间&lt;/span&gt;&lt;/strong&gt;：专门用于存储 JIT（Just-In-Time）编译生成的机器代码。代码空间与其他空间分离，因为代码的生命周期通常较长，且需要高效访问。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;247&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;大对象空间&lt;/span&gt;&lt;/strong&gt;：用于存储较大的对象（如大数组、大字符串），避免频繁复制。采用标记-清除和标记-整理算法进行垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;254&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;单元空间、属性单元空间和映射空间&lt;/span&gt;&lt;/strong&gt;：些空间分别包含 Cells、PropertyCells 和 Maps。每个空间都包含大小相同的对象，并且对它们指向的对象类型有一定的限制，从而简化了垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;260&quot;&gt;栈内存（Stack）&lt;/strong&gt;&lt;br&gt;栈内存用于存储函数调用时的局部变量、参数和返回地址。栈内存的特点是分配和释放速度快，但空间有限。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;51&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2 V8 垃圾回收机制&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;52&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.1 栈数据的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028742&quot; data-ratio=&quot;0.4969097651421508&quot; src=&quot;https://oscimg.oschina.net/oscnet/dd9587a0-84da-4c35-ab5e-3b2f0a559e6e.png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;栈数据的「垃圾回收」是通过函数调用和返回机制自动完成的。栈帧的内存释放是隐式的，栈是连续的内存区域，内存分配和释放通过指针移动实现。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;55&quot; style=&quot;text-align: left;&quot;&gt;&lt;code&gt;
   
   
   &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;38&quot; data-source-title=&quot;&quot;&gt;
 
    
    
    &lt;section class=&quot;js_blockquote_digest&quot;&gt;
  
     
     
     &lt;section&gt;
      
      
      
   为什么需要区分「堆」和「栈」两个存储空间？为什么不将所有数据直接存放在栈中？
  
     
     
     &lt;/section&gt;
 
    
    
    &lt;/section&gt;

   
   
   &lt;/blockquote&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;JavaScript 引擎需要用栈来维护程序执行期间的上下文状态。如果栈空间过大，所有数据都存放在栈中，会影响上下文切换的效率，进而影响整个程序的执行效率。例如，当函数执行结束时，JavaScript 引擎只需将指针下移到上一个执行上下文的地址即可，栈帧的内存会自动回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_12&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;57&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.2 堆数据的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;代际假说是垃圾回收领域的一个重要理论，V8 的垃圾回收策略正是基于这一假说。代际假说包含两个核心观点：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;59&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;大多数对象的生命周期很短，分配后很快变得不可访问。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;少数对象会存活较长时间。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;基于此，V8 将堆内存分为新生代和老生代两个区域。新生代存放生命周期短的对象，老生代存放生命周期长的对象。V8 的垃圾回收器分为主垃圾回收器和副垃圾回收器。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h5_13&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;65&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器主要负责新生代的垃圾回收。由于大多数小对象都分配在新生代，因此该区域的垃圾回收频率较高。&lt;br&gt;新生代采用 Scavenge 算法，进行垃圾回收。该算法将新生代空间对半划分为对象区域和空闲区域。&lt;br&gt;&lt;/span&gt;&lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028740&quot; data-ratio=&quot;0.5777063236870311&quot; src=&quot;https://oscimg.oschina.net/oscnet/20a6d122-d24b-4ae0-90ec-ec263472ba5c.png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;新加入的对象存放在对象区域。当对象区域快满时，副垃圾回收器会执行以下步骤：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;67&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;标记对象区域中的存活对象。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;将存活对象复制到空闲区域，并有序排列，消除内存碎片。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;角色翻转：对象区域变为空闲区域，空闲区域变为对象区域。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于 &lt;strong data-nodeid=&quot;298&quot;&gt;Scavenge 算法&lt;/strong&gt;需要复制存活对象，如果新生代空间过大，复制操作会耗费较多时间。因此，新生代空间通常较小。为了应对新生代空间不足的问题，V8 采用了对象晋升策略：经过两次垃圾回收后仍然存活的对象会被移动到老生代。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_14&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;75&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;主垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;老生代的对象通常较大，使用 &lt;strong data-nodeid=&quot;313&quot;&gt;Scavenge 算法&lt;/strong&gt;进行垃圾回收效率较低。因此，主垃圾回收器采用&lt;strong data-nodeid=&quot;314&quot;&gt;标记-清除&lt;/strong&gt;和&lt;strong data-nodeid=&quot;315&quot;&gt;标记-整理&lt;/strong&gt;算法。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;标记-清除：首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历调用栈，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。标记过程和清除过程就是标记 - 清除算法 Mark-Sweep ，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028743&quot; data-ratio=&quot;0.4945770065075922&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed116503-4d1e-493b-8d7f-3457262b4501.png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法—标记-整理（Mark-Compact）&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。V8 研究团队 2016 年的一篇博文：在一次完整的垃圾回收之后，V8 的堆增长策略会根据活动对象的数量外加一些余量来确定何时再进行垃圾回收。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028739&quot; data-ratio=&quot;0.4106029106029106&quot; src=&quot;https://oscimg.oschina.net/oscnet/7d262ac7-2d6e-4dff-9074-41b2a5be869f.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_15&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;80&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;全停顿和增量标记&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有研究数据表明，如果堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028745&quot; data-ratio=&quot;0.2915506035283194&quot; src=&quot;https://oscimg.oschina.net/oscnet/e32c7d49-8a28-410a-a60f-f0f1f13ba6dc.png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;83&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section style=&quot;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;
   
   
   &lt;code&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。&lt;br&gt;&lt;/span&gt;&lt;/code&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法，&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028744&quot; data-ratio=&quot;0.3201663201663202&quot; src=&quot;https://oscimg.oschina.net/oscnet/0d30149e-d536-4d77-ac3a-0c1865d98a4b.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;86&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;四、内存泄漏与优化&lt;/span&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_17&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;88&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1 常见的内存泄漏场景及优化方案&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_18&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;89&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.1 意外的全局变量&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未使用 var、let 或 const 声明的变量会隐式变为全局变量，直到页面关闭才会被释放。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;92&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;leak&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  leakedVar = &lt;span class=&quot;code-snippet__string&quot;&gt;&#39;This is a global variable&#39;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 意外的全局变量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;351&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;始终使用 var、let 或 const 声明变量。启用严格模式（&quot;use strict&quot;），避免意外创建全局变量。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_19&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;94&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.2 未清理的定时器或回调函数&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未清除的 setInterval 或 setTimeout 会持续持有引用，导致相关对象无法被回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;97&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; data = getData();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;setInterval(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  process(data); &lt;span class=&quot;code-snippet__comment&quot;&gt;// data 一直被引用，无法释放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;360&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 clearInterval 或 clearTimeout 清除定时器。在组件销毁或页面卸载时清理定时器。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;99&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.3 未解绑的事件监听器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未移除的事件监听器会持续持有对 DOM 元素或对象的引用，导致内存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;102&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; button = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myButton&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;button.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;Button clicked&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果 button 被移除，但未解绑事件监听器，会导致内存泄漏&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;369&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 removeEventListener 解绑事件监听器。在组件销毁或页面卸载时解绑事件。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_21&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;104&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.4 闭包中的引用&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;闭包会捕获外部函数的变量，如果闭包未被释放，这些变量也会一直存在。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;107&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;createClosure&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; largeData = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1000000&lt;/span&gt;).fill(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(largeData[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;code-snippet__comment&quot;&gt;// largeData 一直被闭包引用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; closure = createClosure();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;378&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;免在闭包中捕获不必要的变量。在不再需要闭包时，手动解除引用（例如将闭包设置为 null）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;109&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.5 DOM 引用未释放&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果 JavaScript 中保留了 DOM 元素的引用，即使该元素从页面中移除，也无法被垃圾回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;112&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; element = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.removeChild(element); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从 DOM 中移除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// element 仍然被引用，无法释放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;387&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;在移除 DOM 元素后，将其引用设置为 null：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;114&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;element&lt;/span&gt; = null;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_23&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;115&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.6 缓存未清理&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;缓存对象（如 Map 或 WeakMap）如果未正确清理，会导致内存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;118&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; cache = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCache&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;key, value&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache.set(key, value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果缓存未清理，会持续增长&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;396&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 WeakMap 或 WeakSet，它们不会阻止键对象的垃圾回收。定期清理缓存。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_24&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;120&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2 内存泄漏检查&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_25&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;121&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.1 使用 Chrome 任务管理器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 自带的任务管理器可以帮助你快速发现内存占用异常的任务。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;内存&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028747&quot; data-ratio=&quot;0.6096885813148789&quot; src=&quot;https://oscimg.oschina.net/oscnet/4a266a6f-5f33-4576-8745-89dbad18ebff.png&quot; data-type=&quot;png&quot; data-w=&quot;2890&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;124&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打开 Chrome 任务管理器：点击 Chrome 右上角的三个点（菜单按钮） &amp;gt; 更多工具 &amp;gt; 任务管理器。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查看内存占用：关注内存占用异常高的任务（如标签页、扩展程序、辅助框架等）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;检查内存增长：观察某个任务的内存占用是否持续增长（即使页面没有操作）。如果某个任务的内存占用不断增加，可能是内存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_26&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;131&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.2 使用 Chrome 开发者工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 的开发者工具提供了强大的内存分析功能，可以帮助你定位内存泄漏。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028746&quot; data-ratio=&quot;0.6623970722781336&quot; src=&quot;https://oscimg.oschina.net/oscnet/243ee5e7-4a79-4326-8fd1-68e8488a7f46.png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;br&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;133&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打开开发者工具：右键点击页面，选择，检查，或者使用快捷键：Ctrl + Shift + I（Windows/Linux）或 Cmd + Option + I（Mac）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用 Memory 面板：切换到 Memory 标签。选择以下工具之一进行分析：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;138&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Heap Snapshot：拍摄堆内存快照，分析内存分配情况。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation instrumentation on timeline：记录内存分配的时间线，查看内存增长情况。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation sampling：通过采样分析内存分配。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;分析内存泄漏：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;147&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;拍摄多个堆内存快照，比较快照之间的内存变化。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查找未被释放的对象（如 DOM 节点、事件监听器等）。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;检查 Retainers（持有者），找到导致内存泄漏的代码。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_27&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;154&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.3 使用第三方工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;除了 Chrome 自带的工具，还可以使用以下第三方工具进行内存分析：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;156&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Lighthouse：Chrome 的 Lighthouse 工具可以检测页面性能问题，包括内存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;MemLab：Facebook 开源的 JavaScript 内存分析工具，专门用于检测内存泄漏。&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h2_28&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;161&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;五、从崩溃到优化：内存管理的终极目标&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;浏览器的崩溃往往源于内存管理的不足，而 V8 引擎的内存管理机制正是解决这一问题的关键。通过理解 V8 的内存分配、垃圾回收机制以及常见的内存泄漏场景，我们可以更好地优化代码，避免内存浪费和性能瓶颈。无论是开发者还是普通用户，了解这些原理都能帮助我们更好地应对浏览器崩溃问题，提升应用的整体性能和用户体验。&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_29&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;163&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;六、 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;本文通过从常见的浏览器崩溃场景引出本篇文章的分享主题：V8 的内存管理， 文章主要介绍了 V8 垃圾回收的原理、常见的内存泄漏场景及其预防方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;最后，最重要的一点：欢迎评论区互动，一起交流学习，共同成长&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;img alt=&quot;图片&quot; class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-imgfileid=&quot;100028749&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fc371ec9-2b7f-4b7f-b317-4e6e306662bf.png&quot; data-type=&quot;webp&quot; data-w=&quot;396&quot; style=&quot;pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;扫一扫，加入技术交流群&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 16px;&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公众号 - 京东云开发者（JDT_Developers）。&lt;br&gt;如有侵权，请联系 support@oschina.cn 删除。&lt;br&gt;本文参与「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源创计划&lt;/a&gt;」，欢迎正在阅读的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/17955030</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/17955030</guid>
            <pubDate>Fri, 21 Mar 2025 08:29:00 GMT</pubDate>
            <author>京东云开发者</author>
        </item>
        <item>
            <title>Linux 内核越界写入漏洞致权限提升</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcybersecuritynews.com%2Flinux-kernel-out-of-bounds-write-vulnerability%2F&quot; target=&quot;_blank&quot;&gt;Linux 内核存在近 20 年的严重漏洞&lt;/a&gt;&lt;/u&gt;，允许本地用户获取 root 权限，影响多版本系统。&lt;/p&gt; 
&lt;p&gt;该漏洞被分配的编号为 CVE-2025-0927，在 Linux 内核 HFS+文件系统驱动程序中存在越界写入漏洞，影响运行至 6.12.0 版本内核的系统，已确认 Ubuntu 22.04 带有 Linux 内核 6.5.0-18-generic 版本的系统存在漏洞。&lt;/p&gt; 
&lt;p&gt;根据 SSD 的安全公告，该漏洞存在于 HFS+驱动程序中，该驱动程序支持 Apple 的过时文件系统格式，该格式在 2017 年被 APFS 取代之前一直是 MacOS X 的主要文件系统。&lt;/p&gt; 
&lt;p&gt;该漏洞自初始 git 仓库构建 1da177 以来一直存在，并且自 Linux 内核 2.6.12-rc2 版本以来一直未被检测到。&lt;/p&gt; 
&lt;p&gt;该漏洞的核心在于 B 树节点处理中的缓冲区溢出。易受攻击的函数 fs/hfsplus/bnode.c 中的 hfs_bnode_read_key 未能正确验证键大小的边界条件：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2f9a4d0f8d837764ff162322f00ccb86e82.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在该代码中，函数未实现适当的边界检查，允许攻击者触发越界写操作，从而破坏内核内存。&lt;/p&gt; 
&lt;p&gt;Ubuntu 已发布修复程序，管理员需立即更新。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</guid>
            <pubDate>Fri, 21 Mar 2025 08:28:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>AI 组件 ComfyUI 易被黑产盯上</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;随着近几年大模型的迅猛发展，以及安全对抗技术的持续迭代升级，黑产团伙逐渐将攻击目标从传统服务转移到了 AI 相关服务。&lt;/p&gt; 
&lt;p&gt;近日，百度安全团队捕获到了一起&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIPzuok7ej_ghTn59R9PRbA&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;针对大模型相关组件 ComfyUI 的攻击事件&lt;/strong&gt;&lt;/a&gt;&lt;/u&gt;，经过深入分析，该事件背后团伙已实际针对国内不少公网 ComfyUI 进行了入侵。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;关于 ComfyUI&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;‌ComfyUI 是一款基于节点流程的 Stable Diffusion 操作界面，专为图像生成任务设计。‌它通过将深度学习模型的工作流程简化为图形化节点，使用户操作更加直观和易于理解。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 提供了高度的可视化和扩展性，用户可以通过拖放操作来构建和调整图像生成流程，无需编写代码。‌作为大模型图像生成领域的最热门框架之一，其在 GitHub 斩获了接近 7W Star，备受开发者喜爱，根据网络空间测绘数据，全网共有近 2700 例 ComfyUI 服务，其中不乏无需密码直接访问的案例。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 后台支持加载用户指定的模型文件，同时用户可以方便地管理模型。但给用户带来便利的同时，也存在一些安全隐患。&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;376&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161939_EGHc_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;百度安全在捕获的攻击事件中发现，攻击者利用 ComfyUI 用户错误配置问题，在无需认证的情况下进入到 ComfyUI 后台，同时利用后台模型加载功能安装攻击者提前上传在 Hugging Face 的投毒模型文件，以便利用模型加载时的 pickle 反序列化逻辑，控制受害者机器，进一步渗透目标内网。&lt;/p&gt; 
&lt;p&gt;本次事件攻击者主要利用了 ComfyUI 控制枱无身份鉴权的配置错误问题进入控制后台，并通过 ComfyUI-Manager 插件中的远程下载功能从 Hugging Face 及其镜像站等相关模型仓库拉取投毒模型（.pth 后缀的文件），使得开发者在使用 ComfyUI 加载投毒模型时会因自身的 pickle 反序列化逻辑触发恶意的 Loader，进而执行恶意 Bash 脚本，脚本会从攻击者的服务器上拉取 C2 木马进行远程控制，C2 域名为 cloudflare.com 提供给普通用户使用的隧道服务（用户可以无需外部域名和 ip 就可以把内网的服务映射到外部），攻击者滥用该服务，达成隐蔽控制的目的。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;696&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/162047_QvnF_2720166.png&quot; width=&quot;941&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;据 CVE 官方披露，ComfyUI 历史存在多种漏洞类型，包括：任意文件读取漏洞、远程代码执行漏洞、存储 XSS 漏洞等。&lt;/p&gt; 
&lt;p&gt;相关漏洞已分配如下 CVE 编号：CVE-2024-10099、CVE-2024-21574、CVE-2024-21575、CVE-2024-21576、CVE-2024-21577。&lt;/p&gt; 
&lt;p&gt;本次事件主要利用的 ComfyUI 默认无身份鉴权机制的&quot;特性&quot;，从而直接访问 ComfyUI 后台。但该「特性」官方并不认为是安全漏洞，归因为用户错误配置，在使用上官方始终认为使用者应自行注意，不要将 ComfyUI 对公网暴露或应该通过沙箱环境运行，以确保 ComfyUI 安全。&lt;/p&gt; 
&lt;p&gt;参考&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomfyanonymous%2FComfyUI%2Fdiscussions%2F5165&quot; target=&quot;_blank&quot;&gt;https://github.com/comfyanonymous/ComfyUI/discussions/5165&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340226</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340226</guid>
            <pubDate>Fri, 21 Mar 2025 08:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>CleanRL —— 深度强化学习库</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CleanRL 是一个深度强化学习库，提供具有研究友好功能的高质量 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;single-file&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实现。该实现简洁明了，但我们可以使用 AWS Batch 对其进行扩展以运行数千次实验。CleanRL 的亮点包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;Single-file&amp;nbsp;&lt;/span&gt;实现

&lt;ul&gt;
&lt;li&gt;关于算法变体的每个细节都被放入一个独立的文件中。&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;ppo_atari.py&lt;/code&gt;只有 340 行代码，但包含了 PPO 如何与 Atari 游戏配合使用的所有实现细节，&lt;strong&gt;因此对于不想阅读整个模块库的人来说，它是一个很好的参考实现&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://benchmark.cleanrl.dev/&quot;&gt;基准测试实施（ https://benchmark.cleanrl.dev&lt;/a&gt;上的 7 种以上算法和 34 种以上游戏）&lt;/li&gt;
&lt;li&gt;Tensorboard&amp;nbsp;Logging&lt;/li&gt;
&lt;li&gt;Local Reproducibility via Seeding&lt;/li&gt;
&lt;li&gt;游戏视频捕捉&lt;/li&gt;
&lt;li&gt;利用&lt;a href=&quot;https://wandb.ai/site&quot;&gt;权重和偏差进行实验管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;与 Docker 和 AWS 进行云集成&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/cleanrl</link>
            <guid isPermaLink="false">https://www.oschina.net/p/cleanrl</guid>
            <pubDate>Fri, 21 Mar 2025 08:20:00 GMT</pubDate>
        </item>
        <item>
            <title>快手搜索已全面接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;快手搜索官方宣布已全面接入 DeepSeek R1 的大模型能力，优化搜索效果与用户体验，未来也会持续探索智能搜索场景的商业化变现能力。&lt;/p&gt; 
&lt;p&gt;此前，快手已宣布&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fir.kuaishou.com%2Fzh-hans%2Fnews-releases%2Fnews-release-details%2Fkuaishou-kling-ai-integrates-deepseek-lowering-entry-barrier-ai%2F&quot; target=&quot;_blank&quot;&gt;可灵 AI 已全面接入 DeepSeek-R1&lt;/a&gt;&lt;/u&gt;，在视频生成、图片生成等场景下，用户可通过 DeepSeek 协助生成或者优化提示词，将灵感转化为专业提示词，打造高质量创意视频。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;3436&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161226_9Zcs_2720166.png&quot; width=&quot;2324&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340224</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340224</guid>
            <pubDate>Fri, 21 Mar 2025 08:12:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>印度人工智能快速发展隐忧犹存</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在美国斯坦福大学 2024 年底发布的《全球人工智能实力排行榜》上，印度在全球 36 个国家 AI 活跃度综合评估中排名第四位，仅次于美国、中国和英国。今年 2 月，印度总理莫迪提出了印度的「双重 AI」愿景。第一重「AI」是人工智能（Artificial Intelligence），第二重「AI」是有雄心的印度（Aspirational India）。随后印度与法国在巴黎联合主办了「人工智能行动峰会」，向全世界展示了印度希望通过人工智能推动经济转型升级，实现跨越发展的目标。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度政府近年来不断加大对人工智能领域的投入。2024 年 3 月，印度政府启动「印度人工智能使命（India AI Mission）」，这是一项国家产业发展规划，为印度人工智能初创企业提供包括 GPU（图形处理器）关键算力在内的数字基础设施服务以及政策和资金支持，计划推动印度人工智能市场在 2024 年至 2027 年之间年均增长率达到 25% 至 35%，并在 2027 年创造 170 亿美元的价值。全球统计数据库（Statista）预计，2025 年，印度人工智能市场规模将超过 80 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度拥有庞大的人口基数和多样化的市场需求，为人工智能技术应用提供了广阔空间。在政府大力扶持下，阿达尼、塔塔、信实集团等印度本国大企业近年来不断加大人工智能和数据中心建设投资，助推印度数字经济发展。威普罗（Wipro）、菲尔洛普（Verloop）等印度本土私营人工智能企业也加大研发投资和应用推广，加速拓展本土和周边国家市场，特别是印度企业凭借本国语言多样性优势，训练适用广泛的多语言数据模型，已经成功拿下多个东南亚、南亚国家政府订单。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但相较而言，印度自主研发人工智能技术面临较大挑战。研发偏基础研究而非应用研究，基础编程人员多，应用研究人才少，同时大量技术人才流失，大多流向美西方科技企业，研发投入整体仍显不足，推动研究成果商业化的生态系统有待完善。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对本国企业在技术研发能力上的不足，印度政府借助与世界顶尖人工智能研究机构和企业合作，利用世界现有先进技术实现应用层面的创新，加速自身技术突破。近年来，谷歌、微软、亚马逊、AMD 等国际科技企业高层频频造访印度，科技巨头们也纷纷宣布大规模投资印度人工智能和大数据项目。今年 2 月初，OpenAI 首席执行官萨姆·奥尔特曼在会见印度铁道、通信以及电子和信息技术部长阿什维尼·瓦伊什瑙时表示，印度是人工智能领域重要的市场，应当成为人工智能革命的领导者之一。在中国开源人工智能模型深度求索（DeepSeek）推出后，印度政府表示，将在本土服务器上部署 DeepSeek，并计划再用 6 个月至 10 个月的时间，根据不同文化和语言需求设计开发出印度自己的开源人工智能基础大模型。印度政府希望，届时印度将在人工智能领域具备更强的国际竞争力，能够为世界提供「另一个有希望的替代方案」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;不过，在印度人工智能市场快速发展的背后也存在隐忧。有专家指出，人工智能热潮可能冲击印度以服务业为主的产业结构，人工智能的替代效应可能造成规模性失业和消费下滑，抑制人口红利释放，加大印度政府通过劳动密集型产业推动工业化的难度。一旦人工智能发展不能与工业制造业发展兼容，印度可能错过本轮产业升级窗口期。 （经济日报记者，王宝锟）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340223</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340223</guid>
            <pubDate>Fri, 21 Mar 2025 08:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Midjourney 核心开发者离职，加入 Cursor 负责开发 AI 编程 Agents</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;负责 Midjourney V2 至 V7 模型开发的核心工程师 theseriousadult 在 X 上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fgallabytes%2Fstatus%2F1902864672728158610&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;&lt;/u&gt;已从公司离职。&lt;/p&gt; 
&lt;p&gt;theseriousadult 写道：「&lt;strong&gt;&lt;em&gt;我几乎从第一天起就一直在使用 Cursor，我真的很高兴能开始从事长期以来在我的工作流程中如此重要的事情。语言模型将改变我们构建代码和与代码交互的方式，我想将其推向极限。&lt;/em&gt;&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2593&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/154821_Ouez_2720166.png&quot; width=&quot;1304&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;这位开发者在 Midjourney 的三年时间里，主导了多个版本的模型迭代，以其对美学与创意的专注而闻名，其工作成果深受业界赞誉。离职后，theseriousadult 加入 Cursor 负责开发 AI 编程 Agents。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/337993/anysphere-in-talks-for-close-to-10-billion-valuation&quot; target=&quot;news&quot;&gt;AI 编程神器 &quot;Cursor&quot; 估值达百亿美元&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/320498/anysphere-acquires-supermaven&quot; target=&quot;news&quot;&gt;Cursor 母公司 Anysphere 收购 AI 编码助手 Supermaven&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340219</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340219</guid>
            <pubDate>Fri, 21 Mar 2025 07:53:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>腾讯元宝新技能：支持分析复杂 Excel 表格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;腾讯元宝&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FV3c4L5T9jvSMACo2JRtrxw&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;推出一项新功能，能够帮助用户分析复杂 Excel。「你只需要把表格给到元宝，元宝就能直接算、直接答，还能画重点。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在过去，处理 Excel 表格往往需要用户记住大量的函数和公式，稍有不慎就可能导致错误。现在，用户只需将表格上传至元宝平台，元宝就能直接进行分析，无需用户手动输入公式或进行复杂的操作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;394&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7eae121ba5a814f0370a2c7d0fc4f138ce3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在碰到体量很大、需要做复杂计算的表格时，可以切换到 Hunyuan，并关闭深度思考。这样，快思考模型混元 Turbo S 就可以用代码的方式进行快速分析。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，腾讯元宝不仅支持本地上传表格，还支持从微信和腾讯文档直接导入。无论是电脑版、Web 版还是移动端，用户都可以无缝切换。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338559&quot; target=&quot;news&quot;&gt;腾讯元宝宣布支持上传、导出腾讯文档&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340214</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340214</guid>
            <pubDate>Fri, 21 Mar 2025 07:36:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>百度：任何人无权触碰用户数据</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在就 「谢广军女儿开盒」 事件发布声明后，百度于 3 月 20 日下午召开信息安全沟通会，针对事件的调查过程及结果进行现场说明，并展示经三方公证的「（2025）京精诚内经证字第 1642 号」公证书。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;492&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d450818c480c7db9cb2aaf28a87e1384093.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度安全负责人陈洋表示，&lt;strong&gt;百度任何职级的员工及高管均无权限触碰用户数据&lt;/strong&gt;。同时披露了事件调查结果：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;事件发生以来，百度对当事员工的「历史数据申请记录」、「权限记录」、「数据查询」等多项权限和操作日志进行了调查与审计，确认其没有百度用户个人身份信息的数据权限，也未登录任何百度数据库与服务器。经核实，确认开盒信息并非从百度泄露。该过程，全程经过三方现场公证。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对「开盒事件」发生后网上流传的「当事人承认家长给她数据库」截图，经核实发现，该截图的信息内容不实，事实为博主收到家人红包后，在平台晒出红包截图，博主回复「我家长给的」，本意是想说明红包的来源，与「开盒」无关，事件发生后的大量传播信息均为不实。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;并详细讲解了百度针对数据安全的多项防护措施：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户注册账号阶段，即实施假名化处理，降低数据泄露风险，提高数据合规性；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;对数据实施加密，对敏感数据进行严格隔离，并依托数据安全管理平台，实现数据管理、权限控制及安全审计的统一管控；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;遵循国际公认的风险控制理念，建立「基础防守」、「制度&amp;amp;能力&amp;amp;风险专项」、「稽查&amp;amp;内部审计」三道安全防线。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度表示，在相关政府部门的指导下，积极响应和倡议推进「反开盒」联盟的成立，共同加强数据隐私防护，严厉打击非法数据窃取及泄露行为，筑牢网络安全防线，共同维护清朗网络空间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/339949&quot; target=&quot;_blank&quot;&gt;百度就 「谢广军女儿开盒」 事件发布声明&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340213</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340213</guid>
            <pubDate>Fri, 21 Mar 2025 07:22:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>13 年后，AlexNet 源代码终于公开</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌首席科学家 Jeff Dean 宣布，他们与计算机历史博物馆（CHM）合作，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcomputerhistory.org%2Fblog%2Fchm-releases-alexnet-source-code%2F&quot; target=&quot;_blank&quot;&gt;共同发布了 AlexNet 的源代码&lt;/a&gt;&lt;/u&gt;，并将长期保存这些代码。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150916_mJ2m_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;开放后的代码库如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;520&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/150931_Gm2o_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;GitHub 链接：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomputerhistory%2FAlexNet-Source-Code&quot; target=&quot;_blank&quot;&gt;https://github.com/computerhistory/AlexNet-Source-Code&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;AlexNet 是一个人工神经网络，用于识别照片内容。它由当时的多伦多大学研究生 Alex Krizhevsky 和 Ilya Sutskever 以及他们的导师 Geoffrey Hinton 于 2012 年开发。&lt;/p&gt; 
&lt;p&gt;在计算机历史上，AlexNet 的出现有着划时代的意义。在它出现之前，很少有机器学习研究人员使用神经网络。但在 AlexNet 出现之后，几乎所有研究人员都会使用神经网络。从 2012 年到 2022 年，神经网络不断取得进步，包括合成可信的人类声音、击败围棋冠军选手、模拟人类语言并生成艺术作品…… 最终，OpenAI 于 2022 年发布 ChatGPT…… 它是这一系列故事的重要起点。&lt;/p&gt; 
&lt;p&gt;「谷歌很高兴将具有开创性意义的 AlexNet 项目的源代码贡献给计算机历史博物馆」，Jeff Dean 说，「这段代码是 Alex Krizhevsky、Ilya Sutskever 和 Geoffrey Hinton 撰写的标志性论文《ImageNet Classification with Deep Convolutional Neural Networks》的基础，该论文革新了计算机视觉领域，是有史以来被引用次数最多的论文之一。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/151006_C9sF_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Google Scholar 数据显示，AlexNet 相关论文被引量已经超过 17 万。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;除了代码本身的价值，HuggingFace 联合创始人 Thomas Wolf 还发现，代码中的注释也非常有启发性。他说，「也许真正的历史记录是 AlexNet 代码中每个实验配置文件末尾的实验记录注释。一个开创性的神经网络正在诞生……」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1454&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/151021_yhzH_2720166.png&quot; width=&quot;1204&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</guid>
            <pubDate>Fri, 21 Mar 2025 07:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>