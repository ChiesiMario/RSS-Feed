<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 11 Aug 2025 12:45:52 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>开源前端框架 Tailwind 创始人为 AI 生成的默认紫色 UI 道歉</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源前端框架 Tailwind 创始人 Adam Wathan&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FGZhan57%2Fstatus%2F1953866977539219836%2Fphoto%2F1" target="_blank"&gt;表示&lt;/a&gt;，因为五年前他将 Tailwind UI 中的每个按钮都设为「bg-indigo-500」，这导致地球上每个 AI 生成的 UI 也都是靛蓝色的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0811/191017_Uh4E_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Tailwind CSS 是一个为快速开发而精心设计的原子类开源 CSS 框架，它提供了充满设计感和应用程序至上的能力来创建组件，开箱即用。&lt;/p&gt; 
&lt;p&gt;Tailwind CSS 在 AI 项目（尤其是涉及生成 UI 的 AI，如 LLM 驱动的代码助手、AI 设计转代码工具等）中广受欢迎。这源于其设计哲学和特性完美契合了 AI 生成代码的需求和挑战。它提供了：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;可预测、低歧义的样式表达方式（原子类）。&lt;/li&gt; 
 &lt;li&gt;自包含、上下文独立的代码结构（内联样式）。&lt;/li&gt; 
 &lt;li&gt;有限决策空间、高一致性的设计约束（预设系统）。&lt;/li&gt; 
 &lt;li&gt;高效、快速迭代的开发模式。&lt;/li&gt; 
 &lt;li&gt;基于海量流行数据训练的开发者友好模式。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;如果要避免 AI 使用蓝色、紫色，可以加这句 prompt：&lt;br&gt; avoids using indigo or blue colors unless specified in the user's request.&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365577</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365577</guid>
      <pubDate>Sun, 10 Aug 2025 11:11:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 在华申请「GPT-5」商标被驳回</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;近日，随着&amp;nbsp;OpenAI&amp;nbsp;正式推出其新一代人工智能模型&amp;nbsp;GPT-5，该公司在中国申请相关商标的进展也引发了关注。据天眼查数据显示，OpenAI 公司及其运营子公司曾多次申请注册「OPENAI GPT-5」和「GPT-5」等商标，但目前这些申请均处于「等待驳回复审」或「驳回复审中」的状态。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="345" src="https://oscimg.oschina.net/oscnet/up-1477ae4d4e71cad8ceb2fea3ca19cc1802f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在 OpenAI 之前，国内也曾有公司尝试注册「GPT-5」商标。数据显示，深圳一家科技公司曾申请注册两枚「GPT-5」商标，但均已被驳回并处于无效状态。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 此次在中国申请的商标涵盖「网站服务」和「科学仪器」等国际分类，但流程显示，其注册申请并未顺利通过。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;a href="https://www.oschina.net/news/364960/openai-gpt-5" target="news"&gt;OpenAI 正式发布 GPT-5&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365571</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365571</guid>
      <pubDate>Sun, 10 Aug 2025 10:39:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源重构汽车：从孤岛到协作的生态演进</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;智能汽车的软件正迅速成为核心价值载体:其代码规模已达数亿行、成本占比迅速上升，与此同时开源正在成为推动技术品牌、成本控制、效率提升、生态协作的关键手段，而全球及中国的车企正在通过分层架构、自主研发与行业协作融合大模型技术，共同推进「软件定义汽车「时代的到来。&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span style="font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif"&gt;一辆有智能辅助驾驶功能的汽车需要多少行代码？&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到今天，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果考虑车上的所有软件，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个答案已趋近于 7 亿行。同时，软件也正在成为整车 BOM 表里单价最高的「零部件」。德勤报告测算，2030 年软件成本占整车 BOM 比重将从目前不到 10% 增长到 50%，包括程序开发、AI 算法、操作系统、控制器和芯片等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「软件定义汽车」的趋势愈加明晰。而开源作为现代软件世界中提升&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;协同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;效率、降低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基础技术研发&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成本的大功臣，自然也被引入到汽车软件的场景中，扮演着至关重要的角色。据相关调研数据显示，汽车行业中代码库的开源代码占比近 70%，广泛应用在基础软件、座舱软件等不同的场景中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从开源协作的角度看，近期海内外的车企、科技企业等都有引人注目的动作：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;除了我们近两年看到的普华软件、国科础石、睿赛徳、理想汽车&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面向基础操作系统的开源，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不久前，包括大众集团、宝马集团、梅赛德斯-奔驰等在内的 11 家欧洲汽车及科技公司决定结盟，计划共同开发并共享先进的汽车软件平台。根据规划，这些公司将在 2026 年之前交付核心软件栈，基于该平台的首批车辆预计将于 2030 年开始批量生产。该软件栈的源代码将作为开源项目发布，由 Eclipse 基金会管理，并基于现有的 S - Core 项目进行开发，采用模块化设计：基础层（通信中间件、认证模块）开源共享，而上层信息娱乐、自动驾驶功能允许品牌差异化定制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这一系统性、行业级别的协作，被业内视为欧洲应对中美智能化领先的关键布局。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就在这个消息发布的前几天，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OpenSDV 汽车软件开源联盟也在积极行动，OpenSDV 汽车软件开源联盟技术生态总监滕召智与日本爱信、丰田等企业通话&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，沟通汽车开源生态建设的相关事项。滕召智表示，整体来看，欧洲的协作深度更深，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;架构上更容易统一，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;国内车企&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在市场上冲突比较直接，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技术上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;仍处于各自为战状态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，说明国内的技术认知尚未收敛，也侧面反映为了应对「内卷」而进行的创新还在持续。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这种分化格局，其根源并非仅是表面的合作意愿问题，也反映出技术路线、商业逻辑与协作成熟度的差异。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;汽车软件架构：分层协作与车企的掌控焦虑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;智能汽车的软件体系早已超越简单的代码堆砌，形成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;供应链&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;协作的复杂生态。想要了解汽车软件的生态发展，首先得清楚一辆车究竟需要哪些软件，成本或者营收更可能发生在什么地方？滕召智介绍，汽车软件通常分为硬件抽象、虚拟化、操作系统、中间件、应用、工具链及外延&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;生态&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;七个层级。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;硬件抽象层（BSP/HAL 层）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;功能定义：作为最底层的软件，直接管理硬件资源，包括芯片级驱动程序和硬件虚拟化接口。其核心是为上层系统提供统一的硬件操作界面，屏蔽不同硬件的差异。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技术形式：以板级支持包（BSP）或硬件抽象层（HAL）的形式存在，实现硬件资源的标准化调度，如传感器控制、内存分配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;产业实践：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在国内&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由地平线、黑芝麻智能等芯片厂商主导开发，确保操作系统和应用能跨硬件平台调用资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;虚拟化层：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;功能定义：通过 Type 1 虚拟机将单一 SoC 芯片划分为多个独立域，支持不同操作系统并行运行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;典型场景：例如在智能座舱中，同时运行 Linux 驱动的仪表盘和 Android 系统的娱乐中控。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代表企业：中科创达、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中瓴智行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、国科础石&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供商业化解决方案，已应用于理想、小鹏&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、东风等车企的部分车型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;操作系统层：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分类与定位：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;座舱系统：车企主导定制化开发，如鸿蒙 OS、理想 OS，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小米澎湃，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;侧重交互体验；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;车控系统：依赖实时操作系统，如 Linux/Unix 变体，满足高可靠性要求，如制动、转向控制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，当前也激发了零部件厂商像智能零部件交付的进化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发模式：车企与操作系统厂商&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、方案商&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;联合研发，确保功能安全与差异化适配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中间件层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;核心功能：实现软硬件解耦，提供通信、数据管理和服务调度能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技术路线：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;传统框架：AUTOSAR AP 汽车开放系统架构仍是主流标准；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新兴方向：ROS 2/DDS 用于感知融合框架，支持自动驾驶多传感器协同处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;行业趋势：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;结合自身的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SOA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;体系建设，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成为车企技术投入重点，以降低功能迭代复杂度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;形成具有车企供应链管理、软件迭代特性的工具链体系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用户导向功能：直接面向消费者的交互模块，包括语音识别、导航、ADAS 自动紧急制动及座舱娱乐系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发占比：车企 40% 以上资源投入此层，因其直接决定品牌体验差异和溢价能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工具链层：提供一些关键工具，如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SOA 设计工具：实现硬件资源服务化定义，如 Vector Davinci；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;仿真验证平台：华为云 KubeEdge 支持数字孪生测试 Sim-to-Real；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;台架测试系统：dSPACE SCALEXIO 硬件在环验证&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;外延生态层：互联协议，可以实现将手机应用直接「投影」到车载屏幕上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;国际：Apple CarPlay；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;国内：ICCOA Carlink，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由多家车企、手机厂商联合创建，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;生态内的所有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;手机&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，目前也有很多合资品牌兼容了该协议。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分层协作的复杂生态中，投入的着力点往往也在决定着生态演进的方向。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当下，车企往往最愿投入用户看得见的部分——智能座舱的应用，应用层功能直接决定品牌溢价。究竟该自研哪些层级才能既保安全可控又赢得差异化？深扎操作系统和中间件的核心层级，投入巨大且周期漫长；完全依赖供应商方案，又恐丧失技术主动权和品牌特色。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此外，比亚迪、小米&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、华为、理想&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等头部企业重仓操作系统与中间件，以降低供应链风险；中小车企则聚焦应用层，通过座舱娱乐功能提升溢价能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;供应链与合作：用开源建立信任&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如此清晰的软件架构之下，业界如何协作共建？答案在中、欧之间呈现出截然不同的图景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;今年上半年，国内车企及相关业界机构的开源动作频频，但另一方面项目间关联性不强。理想汽车在中关村论坛宣布开源「理想星环 OS」，成为全球首家开源整车操作系统的车企。吉利汽车与阶跃星辰联合开源两款大模型——300 亿参数视频生成模型 Step-Video-T2V 和多场景语音交互模型 Step-Audio。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;img height="972" src="https://oscimg.oschina.net/oscnet/up-7c402c968f8612ec93d43599261106adbf4.png" width="1536" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;项目地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://gitee.com/haloos/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此外，东风汽车发布行业最大端到端自动驾驶开源数据集，包含 125 万组数据、6000 多个真实驾驶场景片段，如雨天避障、夜间会车等。除了普华基础软件的 EasyAda、小满 EasyXMen 及天元 OS 等开源平台，企业开源的阵营在不断扩大：比亚迪等车企已实现相关智能 AI 技术平台的开源，华为鸿蒙座舱开放核心能力后已有多家车企接入。在政府引导协同层面，早在 2024 年年底，国家智能网联汽车创新中心发布了车用操作系统基线版本开源计划。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「车企普遍依赖自研体系，各家企业都认为自己能解决大部分问题，导致技术路线分散」，滕召智指出，这种模式虽能快速响应市场，但难以形成标准化合力。例如 AUTOSEMO 推动的 ASF 标准，因车企&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不同的技术现实情况不同，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;执行差异大而落地困难。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;另一方面，企业参与开源也面临着一些阻碍。比如传统车企决策层对开源接受度低，且「忙于&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;业务生产&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无暇顾及共性技术」；新势力虽有技术意愿，但需承担高额成本分摊风险。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而且汽车供应链存在较高的准入壁垒，新兴软件厂商进入车规领域，需攻克功能安全认证（ISO 26262）或寻找资质供应商背书，尤其是在车控安全领域。这一点在 Eclipse Foundation 2023 年发布的《汽车行业中的开源软件》中也有提到：开源软件在汽车外部应用中的使用率比汽车内部的高很多。在汽车内的有限使用主要是因为业内有严格的功能安全标准要求和严格的软件开发流程，而许多（但不是所有）开源软件方案往往达不到这样的要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面对这些挑战，滕召智以 Linux 发展史类比中国汽车开源生态的破局关键：「Debian、RedHat 等发行版让小白用户能用 Linux，才引爆生态繁荣。我们亟需更多像新环 OS（指理想星环 OS 等）这样的开源发行版，降低开发者参与门槛。」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;为此，OpenSDV 选择从工具链和标准入手进行突破，试图为打破孤岛创造条件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代码安全基础设施：开发 AI 驱动的代码自动审查工具，可识别功能安全缺陷并自动修复，已被 Linux 基金会 AGL 项目纳入流程，供全球车企使用；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实时性评测标准：联合 40 余家车企制定智驾 OS 实时性团体标准，统一主机厂与供应商的测试阈值，打破交付反复认证的僵局；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;法务支撑体系：构建开源合规知识库，解决车企出海时的软件供应链法律风险。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:left"&gt;&lt;img height="732" src="https://oscimg.oschina.net/oscnet/up-5c18bb6f6370e3e7f34fa2d8b2e11747377.png" width="1386" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;2024 年，OpenSDV 在成员单位中，针对开源在汽车软件供应链的应用、使用、管理等方面，做出了行业调研。样本企业主要来自整车主机厂、汽车软硬件 Tire1 供应商、检测机构、 软件工具厂商等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「开源让车企深度参与代码贡献，看清系统如何运作，才能建立技术信任」，滕召智认为，开源的关键作用之一还在于建立信任，基于透明参与和深度理解的技术信任，或许可以打破当前各自为战的局面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技术演进：大模型技术的融合&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开源生态的成熟，最终也会服务于更高阶的智能化应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前国内车企在人工智能技术应用上，主要还是依赖现有的通用大模型算法，在垂直汽车场景的专用优化方面投入有限。应用场景也多是语音交互等浅层功能，缺乏专用数据集训练。这导致了大模型要真正契合汽车行业的复杂需求，如融合感知、仓驾决策上还存在明显短板，无论是行业数据的深度积累，还是底层算法架构的针对性调整，都还需要一个长期的持续投入过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;谈到新兴的大模型技术如何融入现有的智能驾驶系统时，滕召智用了人与「提线木偶」的对比来形象说明：未来理想的架构中，像特斯拉 Grok 这样的高级大模型更像是那个操纵全局的「大脑」或核心决策者，负责整合车内外的感知信息。例如判断驾驶员状态是否安全，或者结合外部环境复杂情况，并做出整车级的统筹管理策略，比如决定何时需要系统接管控制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;甚至是一个很好的副驾或者领航员。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而当下成熟的智驾系统依赖传感器如激光雷达和传统控制算法，则更像是「提线木偶」本身——是大模型决策指令的执行单元，专注于实时、具体的车辆操控，如转向、刹车等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;因此，大模型并非要取代或压缩现有的智驾系统，而是作为一种升级和补充，两者共同协作实现更高级别的智能驾驶能力，最终目标是达到这种「大脑指挥肢体」的集成状态。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至于 OpenSDV 联盟在推进汽车行业大模型技术标准化方面的工作，滕召智坦言目前联盟的角色更偏向于参与者和引导者，而非主导者或实际研发方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要原因是联盟内尚未出现足够强大的引领性企业来牵头。因此，OpenSDV 的策略是通过其技术监督委员会，专注于在标准化层面推动一些基础性工作。这具体包括参与到制定通用模型相关标准的讨论中去，重点关注诸如 AI-BOM 方面的内容，规范模型组件的来源、兼容性和安全性，以及确保大模型在车载环境下符合功能安全要求的设计规范等领域。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过协同，提炼共性需求，也形成了很多成果，比如在功能安全代码的自动化审核，发起车用智能驾驶操作系统的性能评测规范等。其&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;核心思路是通过凝聚成员单位的共识，依托行业影响力，来间接推动相关标准框架在行业中的建立与发展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4489239/blog/18687777</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/18687777</guid>
      <pubDate>Sun, 10 Aug 2025 10:28:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>英伟达在中国销售 AI 芯片需要向美国政府支付所得收入的 15%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;根据报道，&lt;strong&gt;英伟达和 AMD 预计将向美国政府支付其从向中国销售人工智能芯片所得收入的 15%&lt;/strong&gt;，这是他们与特朗普政府达成的一项极为不寻常的财务协议的一部分。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/182159_4urE_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据三位了解该协议但因未获授权公开讨论而匿名的人士透露，这项协议是在英伟达获准向中国销售其人工智能芯片的一个版本后一个月达成的。&lt;/p&gt; 
&lt;p&gt;虽然特朗普政府在一个月前公开表示已批准英伟达向中国销售 H20，但实际上一直迟迟没有颁发允许这些销售的许可证。&lt;/p&gt; 
&lt;p&gt;据知情人士称，上周三，英伟达首席执行官黄仁勋在白宫与特朗普总统会面，并同意将 15% 的收入交给联邦政府，实质上使联邦政府成为英伟达在中国业务中的合作伙伴。&lt;/p&gt; 
&lt;p&gt;这些人士表示，商务部在两天后开始颁发人工智能芯片销售的许可证。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365568</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365568</guid>
      <pubDate>Sun, 10 Aug 2025 10:24:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>马斯克宣布 Grok V7 基础模型完成预训练，具备原生多模态能力</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;埃隆·马斯克于 8 月 11 日在 X 平台上宣布，xAI 的 Grok V7 基础模型已于上周完成预训练。该版本&lt;span&gt;最大&lt;/span&gt;的亮点在于其原生多模态能力，能够直接处理视频和音频的比特流，无需进行转换即可理解内容。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这意味着 Grok V7 不仅能看懂视频画面，还能听懂语音中的细微变化，精准辨识出表达的情绪和语调重点，从而实现更深层次的语义理解。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="254" src="https://oscimg.oschina.net/oscnet/up-422d19d41c58d8b2c53f7d673b21c723220.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;与此同时，马斯克还宣布，Grok4 模型现在对所有用户免费开放。免费用户每天可以进行少量查询，如果需要更多的使用权限，则需要付费订阅。此举旨在扩大 Grok 的用户基础，使其更广泛地被大众所接触和使用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Grok V7 的原生多模态能力，预示着其在视频和音频处理方面将带来显著提升，为未来的 AI 应用开启了更多可能性。而 Grok4 的免费开放，也反映了 xAI 正在通过不同的策略来平衡技术创新与市场普及。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365565</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365565</guid>
      <pubDate>Sun, 10 Aug 2025 10:03:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Linus Torvalds 怒喷谷歌 Android 工程师，你的代码就是垃圾</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Linux 创始人 Linus Torvalds 近日在 Linux 内核邮件列表中公开批评了谷歌 Android 团队成员 Palmer Dabbelt 提交的 RISC-V 补丁代码，称其「质量低劣且严重超时」，直言「这是垃圾」，并警告不得再迟交。&lt;/p&gt; 
&lt;p&gt;Palmer Dabbelt 于上周五提交了一份旨在合并到 Linux 6.17 内核的 RISC-V 补丁代码。然而 Linus Torvalds 认为该代码不仅质量差，而且提交时间太晚，已接近 Linux 6.17 合并窗口的尾声。&lt;/p&gt; 
&lt;p&gt;Linus&amp;nbsp;在邮件中毫不留情地指出：「&lt;strong&gt;不，这是垃圾，而且提交得太晚了……这种东西根本不应该发给我，更别提是在合并窗口的后期&lt;/strong&gt;」。他还强调，&lt;strong&gt;这段代码「让这个世界变得更糟糕&lt;/strong&gt;」，并警告称：「&lt;strong&gt;若再提交此类垃圾代码或延迟提交，将不再接受&lt;/strong&gt;」。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-936d20875ad3eebbff999f8de659ee9d2ec.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;后续建议 Linus 强烈建议 Palmer Dabbelt 尽早为 Linux 内核 6.18 提交代码，并希望未来提交的代码中「没有垃圾」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365562</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365562</guid>
      <pubDate>Sun, 10 Aug 2025 10:00:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>「沉浸式翻译」插件试图限制用户自填 API 引发争议</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;8 月 9 日，知名翻译插件「沉浸式翻译」宣布，注意到很多用户自行设置使用的大模型 API「并非源自正规渠道」，有许多属于商家使用盗刷信用卡等非法方式购买，并自行搭建服务器转售，翻译体验差且面临断流停用、维权困难的风险。&lt;/p&gt; 
&lt;p&gt;因此，决定之后仅支持在设置中填写官方渠道、大型云服务商或已认证第三方的 API（本地和局域网搭建的 API 不受影响）。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-62b02bbacf9a32be29eb28a48071f89fd40.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该消息引发许多批评。当天晚上，沉浸式翻译删除了之前的公告并致歉，表示立即撤回所有关于限制第三方服务的计划，永远不会限制用户使用任何第三方翻译服务。&lt;/p&gt; 
&lt;p&gt;&lt;img height="640" src="https://static.oschina.net/uploads/space/2025/0811/174011_EjiN_2720166.png" width="1276" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/174058_O2gg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，将建立更加透明的决策机制，在重大功能调整前充分听取社区意见。公告还承认，「作为一个成长中的团队，我们在面对增长压力时产生了焦虑，做出了偏离初心的决定」，请求用户给予改正的机会。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365558</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365558</guid>
      <pubDate>Sun, 10 Aug 2025 09:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>百度搜索 PC 端全面上线 AI 搜索功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;百度搜索 PC 端首页全面上线一系列 AI 功能，这一升级将传统的信息入口转变为任务中枢。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;新上线的 「&lt;span&gt;超级&lt;/span&gt;智能双行框」 让用户能够一键进行深度搜索，解答更复杂的问题，提升了用户的搜索体验。此外，百度还推出了 「工作台」 模块，其中集成了 AI 阅读、AI 写作和 AI PPT 三大工具，方便用户在日常工作和学习中使用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="217" src="https://oscimg.oschina.net/oscnet/up-6d9383c18ef0abf0fcbe406cd632ba34f0f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在 AI 阅读功能中，用户可以轻松一键总结链接、图片及超大文档，大大节省了阅读和理解的时间。AI 写作工具则提供了超过 20 种文风的选择，同时支持划线修改，帮助用户更好地进行创作和编辑。AI PPT 功能则能根据&lt;span&gt;全网&lt;/span&gt;内容自动生成演示文稿，极大地方便了用户的演示需求。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;根据 QuestMobile 发布的《2025 年 AI 应用市场半年报》，百度 AI 搜索的月活跃用户已超过 3.22 亿，稳居国内 AI 搜索行业的&lt;span&gt;第一&lt;/span&gt;名。此外，国际数据公司 IDC 也在同期报告中指出，百度 AI 搜索在中国通用型 AI 搜索类产品的综合评分中位列&lt;span&gt;第一&lt;/span&gt;，其中用户数据和技术能力这两项关键指标均名列前茅。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;用户在使用百度搜索时可以在 「智能模式」 和 「经典模式」 之间自由切换，只有在 「智能模式」 下才能直接使用相关的 AI 功能。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="215" src="https://oscimg.oschina.net/oscnet/up-4bec8aeb07ebade3a470534751c0319421e.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365557</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365557</guid>
      <pubDate>Sun, 10 Aug 2025 09:32:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Notte - 快速构建可靠的 Web 自动化代理</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;Notte 是一个用于构建和部署可靠的 Web AI 代理的平台，这些代理可以在任何网站上执行操作和数据抓取。Notte 提供你所需的一切，只需一个 API 即可实现大规模重复性工作流程的自动化。它能够隐秘地管理云浏览器会话、代理、安全凭证管理，并与生态系统中的 AI 工具无缝集成。&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#111827"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要特点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e4441"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一个用于安全、可扩展和智能 Web 自动化的全栈平台：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol style="margin-left:0; margin-right:0"&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/sessions"&gt;创建即时浏览器会话&lt;/a&gt;&lt;/strong&gt;。在云端即时启动和管理无头浏览器。与 Playwright CDP 集成，管理 Cookie 和文件，重放会话并绕过验证码和机器人检测。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/agents"&gt;运行自动代理&lt;/a&gt;&lt;/strong&gt;。LLM 驱动的代理可自动化任何 Web 工作流程。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/operations"&gt;掌控全局&lt;/a&gt;&lt;/strong&gt;：在网站上观察、操作和抓取数据。对于需要比自主代理更精确控制的场景，为 LLM 代理提供了功能齐全的 Web 浏览器界面。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/vaults"&gt;保护你的凭证&lt;/a&gt;&lt;/strong&gt;。提供安全的保险库和凭证管理系统，让你可以安全地与 AI 代理共享身份验证详细信息。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/personas"&gt;为你的代理创建数字身份&lt;/a&gt;&lt;/strong&gt;。为你的代理创建和管理数字身份（姓名、邮箱、电话号码）。使用它们进行自动入职和账户创建。&lt;/li&gt;
&lt;/ol&gt;

&lt;p style="text-align:start"&gt;&lt;strong style="color:#1f2328"&gt;Opensource Core&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#using-python-sdk-recommended"&gt;运行网络代理&lt;/a&gt;&lt;/strong&gt;→让&amp;nbsp;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;AI agents&amp;nbsp;&lt;/span&gt;在网站上完成自然语言任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#structured-output"&gt;结构化输出&lt;/a&gt;&lt;/strong&gt;→使用 Pydantic 模型获取精确格式的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#scraping"&gt;网站交互&lt;/a&gt;&lt;/strong&gt;→使用 Playwright 兼容原语和自然语言命令观察网站状态、抓取数据并执行操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;strong style="color:#1f2328"&gt;API service&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;（推荐）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#session-features"&gt;隐身浏览器会话&lt;/a&gt;&lt;/strong&gt;→具有内置 CAPTCHA 解决、代理和反检测功能的浏览器实例&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#workflows"&gt;混合工作流程&lt;/a&gt;&lt;/strong&gt;→结合脚本和 AI agents 以降低成本并提高可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#agent-vault"&gt;秘密保险库&lt;/a&gt;&lt;/strong&gt;→企业级凭证管理，用于存储电子邮件、密码、MFA 令牌、SSO 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#agent-persona"&gt;数字角色&lt;/a&gt;&lt;/strong&gt;→ 使用独特的电子邮件、电话和自动化 2FA 创建数字身份，用于帐户创建工作流程&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/notte</link>
      <guid isPermaLink="false">https://www.oschina.net/p/notte</guid>
      <pubDate>Sun, 10 Aug 2025 09:11:00 GMT</pubDate>
    </item>
    <item>
      <title>Hugging Face 发布 AI Sheets，使用 AI 模型处理数据集的开源工具</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Hugging Face 近日发布了一款开源工具&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fblog%2Faisheets"&gt;AI Sheets&lt;/a&gt;，旨在让用户无需编写代码，&lt;strong&gt;就能在类似电子表格的界面中使用 AI 模型构建、丰富和转换数据集&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;开源地址：https://github.com/huggingface/aisheets&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;简单来说，AI Sheets 就像是 Excel 和 Google Sheets 的 AI 增强版，但它专为数据科学家和开发者设计，能够直接调用各种 AI 模型来处理表格数据。无论你是需要对文本进行分类、生成新内容，还是进行数据清洗，AI Sheets 都能帮你轻松完成。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4abcb51433832c7c0ffa60b4023092a2363.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AI Sheets&amp;nbsp;允许用户通过&amp;nbsp;Hugging Face&amp;nbsp;的&amp;nbsp;Inference Providers&amp;nbsp;调用数千个开源模型，更重要的是，它支持连接到自定义和本地运行的&amp;nbsp;LLM。&lt;/p&gt; 
&lt;p&gt;用户只需确保其本地&amp;nbsp;LLM&amp;nbsp;支持&amp;nbsp;OpenAI API&amp;nbsp;规范即可，例如通过&amp;nbsp;Ollama&amp;nbsp;等工具部署的模型。该工具现已在&amp;nbsp;GitHub&amp;nbsp;上开源，并提供了一个公开的&amp;nbsp;Hugging Face Space&amp;nbsp;供用户即时体验。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-29bed047aa33f64f8907fed342f6dc3fcb5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-73e30d3cb9a97c73489b118e9588ef6202b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365544</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365544</guid>
      <pubDate>Sun, 10 Aug 2025 09:02:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>百川智能开源医疗增强大模型 Baichuan-M2</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;百川智能&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FVL2OWORdVDXkenXJ-Jw9Bg" target="_blank"&gt;宣布&lt;/a&gt;正式开源医疗增强大模型 Baichuan-M2。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;针对医疗领域用户隐私考虑下的模型私有化部署需求，项目团队对 Baichuan-M2 进行了极致轻量化，量化后的模型精度接近无损，可以在 RTX4090 上单卡部署，相比 DeepSeek-R1 H20 双节点部署的方式，成本降低了 57 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="263" src="https://oscimg.oschina.net/oscnet/up-74f868bc87127aa7dcb021b6b00dc67c8f0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;面向急诊、门诊等对于交互速度要求更高的场景，基于 Eagle-3 架构优化的 Baichuan-M2-Spec 版本在单用户场景下实现了 74.9% 的 token 速度跃升。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="249" src="https://oscimg.oschina.net/oscnet/up-d1adb36553288603ffa34ee4169a2800c92.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，M2 模型在数学、指令遵循、写作等通用核心性能上不降反升，因此这个模型也可应用于医疗以外的其他领域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="250" src="https://oscimg.oschina.net/oscnet/up-f35b08150804a24bf611bbbecb6487fd7b5.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;测评结果表明，Baichuan-M2 在 HealthBench 上得到 60.1 的高分，以 32B 的较小尺寸不仅反超 OpenAI 最新开源模型 gpt-oss120b（得分 57.6），更是力压 Qwen3-235B、Deepseek R1、Kimi K2 等当前世界所有开源大模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在 HealthBench Hard 评测中，Baichuan-M2 以 34.7 分成为全球第二款超过 32 分的模型，力压世界所有其他顶尖闭源大模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="413" src="https://oscimg.oschina.net/oscnet/up-1ce0b342e6ea9e33c918ce1f538296d76ed.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="444" src="https://oscimg.oschina.net/oscnet/up-8aa101f0b49a7b587d21048af4a2a44dd2c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告称，尽管真实医疗场景中还存在大量 HealthBench Hard 评测尚未包含的因素，但至少已经证明在多数医疗场景上的问答质量，GPT-5 和 Baichuan-M2 已经超越资深医生，特别是在知识更新速度和全面性上，完全可以给人类医生强大支持。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365539</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365539</guid>
      <pubDate>Sun, 10 Aug 2025 08:41:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通义 Qwen3 开源系列模型支持 100 万 token 超长上下文</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通义 Qwen 团队&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FAlibaba_Qwen%2Fstatus%2F1953760230141309354" target="_blank"&gt;宣布&lt;/a&gt;，Qwen3-30B-A3B-2507&amp;nbsp;和&amp;nbsp;Qwen3-235B-A22B-2507&amp;nbsp;系列模型现已支持高达 100 万 token 的超长上下文处理。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/163327_evaS_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此次升级集成了两项关键技术：Dual Chunk Attention (DCA)&amp;nbsp;和&amp;nbsp;MInference。&lt;/p&gt; 
&lt;p&gt;DCA&amp;nbsp;是一种长度外推方法，能将长序列分割成可管理的小块同时保持全局连贯性；MInference&amp;nbsp;则是一种稀疏注意力机制，通过聚焦关键 token 交互来降低计算开销。这些技术结合，使得模型在处理接近 100 万 token 的序列时，推理速度相比标准注意力实现可提升高达 3 倍。用户可以通过更新模型仓库中的&amp;nbsp;config.json&amp;nbsp;文件为&amp;nbsp;config_1m.json&amp;nbsp;来启用此功能。&lt;/p&gt; 
&lt;p&gt;官方指出，要有效处理 100 万 token 的上下文，用户将需要大约 1000GB 的总 GPU 显存。新版本与&amp;nbsp;vLLM&amp;nbsp;和&amp;nbsp;SGLang&amp;nbsp;完全兼容，便于高效部署。在 1M 版本的&amp;nbsp;RULER&amp;nbsp;基准测试中，更新后的模型在不同长度的上下文处理上均表现出优异的性能。&lt;/p&gt; 
&lt;p&gt;&lt;br&gt; https://huggingface.co/Qwen/Qwen3-235B-A22B-Instruct-2507&lt;br&gt; https://huggingface.co/Qwen/Qwen3-30B-A3B-Instruct-2507&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365537</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365537</guid>
      <pubDate>Sun, 10 Aug 2025 08:34:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通义发布 Wan2.2-I2V-Flash 图生视频模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里通义大模型&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FzsBYkzC3J9-jgEf5YNmUww" target="_blank"&gt;宣布&lt;/a&gt;推出其最新图生视频模型 Wan2.2-12V-Flash。「它不仅将电影级视觉呈现装进模型，更在生成速度与性价比上实现全面跃升，致力于为用户带来更快速、更专业、更稳定的图生视频体验。」&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;相比 Wan2.1，Wan2.2-I2V-Flash 推理速度提升 12 倍，创作效率跃升。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;指令遵循能力大幅提升：各种特效提示词直出，运镜精准控制，指令落地更精准。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;风格化图像稳定输出：对各类风格化图像均能稳定保持风格，并实现合理自然的动态效果。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="402" src="https://oscimg.oschina.net/oscnet/up-ee043f3ae5d17893e38134bd39a2eee008e.png" width="300" referrerpolicy="no-referrer"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365535</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365535</guid>
      <pubDate>Sun, 10 Aug 2025 08:28:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>北京人形发布具身世界模型体系</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;北京人形宣布&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX_jBihaFuIb5G_CoPD_yEA" target="_blank"&gt;发布&lt;/a&gt;了四项具身智能核心成果，包括：具身世界模型体系，打通认知与预判能力；跨本体 VLA 模型，实现跨本体、多场景、多技能的通用性；人形机器人全身控制自主导航系统，解决移动与操作协同的执行瓶颈；以及千台机器人真实场景数据采集计划，为持续进化提供规模化数据燃料。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其中，「具身世界模型体系」旨在为机器人理解现实与预测变化提供核心大脑。这一体系包含具备物理时空理解与推理能力的 72B 具身多模态大模型以及实现神经网络驱动世界模拟器的具身智能世界基座模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;针对通用大模型具身场景下精细空间/几何理解不足，物理交互误差大等问题，北京人形基于千问 72B 多模态大模型，通过自研数据清洗与混合模态训练框架，实现行业首个长视频理解 72B 具身多模态大模型 PelicanVLM，在现代多模态系统超长视频语言理解评测集 Egoschema、李飞飞的视觉空间智能基准评测集 VSI-Bench，多模态大模型物理推理能力大规模基准测试集 PhyX 等 6 项具身相关公开评测集上超越 GPT-4o、Gemini flash 2.0 以及原模型，7 个公开评测基准平均性能超过 SOTA 11%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;基于超过 5000 小时视频数据训练的具身世界模型 WU，则为具身智能机器人提供了「看见未来」的眼睛，并以未见场景下的泛化能力，解锁具身无限数据的可能性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-b1a6e72be028a347ae72f70a87255cc4178.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「跨本体 VLA 模型」成为通用性和扩展性的关键支撑。北京人形正式发布跨本体 VLA 模型 XR-1，让同一模型实现跨本体运行、多场景适配、多技能调用。在业界充分验证的 RoboMIND 高质量具身数据基础上，XR-1 通过积累超百万量级的自有多本体数据，采用首创的多模态视动统一表征学习，有效利用各类机器人操作数据和海量互联网视频数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在此基础上，XR-1 利用多模态视动统一表征训练、跨本体主网络训练和特定场景微调三阶段训练范式，实现机器人跨本体的通用操作知识积累和特定场景的多任务快速学习。在多种机器人本体上大量真实环境测试，实证了该方法的多本体、多技能、多任务、稳健泛化能力，以及其在快速掌握新技能上的巨大潜力。以 XR-1 为基础，「慧思开物」能够快速构建面向各类场景任务的通用技能库，实现多本体、多场景、多任务的能力，显著减少具身智能应用开发的成本与用时。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「人形机器人全身控制自主导航系统」聚焦机器人在实际工作中的核心能力，由「自主导航系统」和「全身控制系统」组成。自主导航系统具备点对点导航、动态障碍感知和自主避障能力，并搭载 OCC 环视感知模块，实现对环境的实时占用与语义感知，拓展了自主与语义导航的应用空间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;全身控制系统支持机器人在移动和站立状态下灵活进行上身动作控制，涵盖预设动作、遥操作与自主操作开发。通过稳定的质心控制与精准的末端控制，保障操作任务的稳定高效执行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「千台机器人真实场景数据采集计划」是业内首个千台级规模的真实场景数据采集计划，通过搭建远程遥操作中心，让千台机器人走出实验室，深入工厂车间、物流仓储、酒店商超等真实工业场景，在执行实际作业任务的同时，持续采集多模态交互数据。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365527</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365527</guid>
      <pubDate>Sun, 10 Aug 2025 08:07:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>缓存之美：万文详解 Caffeine 实现原理（上）</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;文章将采用「总-分-总」的结构对配置固定大小元素驱逐策略的 Caffeine 缓存进行介绍，首先会讲解它的实现原理，在大家对它有一个概念之后再深入具体源码的细节之中，理解它的设计理念，从中能学习到用于统计元素访问频率的 Count-Min Sketch 数据结构、理解内存屏障和如何避免缓存伪共享问题、MPSC 多线程设计模式、高性能缓存的设计思想和多线程间的协调方案等等，文章最后会对全文内容进行总结，希望大家能有所收获的同时在未来对本地缓存选型时提供完整的理论依据。&lt;/p&gt; 
&lt;p&gt;Caffeine 缓存原理图如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine-第 5 页.drawio.png" src="https://oscimg.oschina.net/oscnet//b6ecb4c848ed275752576f246ed15bec.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;它使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 保存数据，并在该数据结构的基础上创建了窗口区、试用区和保护区，用于管理元素的生命周期，各个区的数据结构是使用了 LRU 算法的双端队列，随着缓存的命中率变化，窗口区和保护区大小会自动调节以适应当前访问模式。在对元素进行驱逐时，使用了 TinyLFU 算法，会优先将频率低的元素驱逐，访问频率使用 Count-Min Sketch 数据结构记录，它能在保证较高准确率（93.75%）的情况下占用较少内存空间。读、写操作分别会向 &lt;code&gt;ReadBuffer&lt;/code&gt; 和 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加「读/写后任务」，这两个缓冲区的设计均采用了 MPSC 多生产者单消费者的多线程设计模式。缓冲区中任务的消费由维护方法 &lt;code&gt;maintenance&lt;/code&gt; 中 &lt;code&gt;drainReadBuffer&lt;/code&gt; 和 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 实现，维护方法通过添加同步锁，保证任务只由单线程执行，这种设计参考了 WAL（Write-Ahead Logging）思想，即：先写日志，再执行操作，先把操作记录在缓冲区，然后在合适的时机异步、批量地执行缓冲区中的任务。维护方法除了这些作用外，还负责元素在各个分区的移动、频率的更新、元素的驱逐等操作。&lt;/p&gt; 
&lt;p&gt;接下来的源码分析以如下测试用例为例：先分析构造方法，了解缓存初始化过程中创建的重要数据结构和关键字段，然后再深入添加元素的方法（put），该方法相对复杂，也是 Caffeine 缓存的核心，理解了这部分内容，文章剩余的内容理解起来会非常容易，接着分析获取元素的方法（getIfPresent），最后再回到核心的维护方法 &lt;code&gt;maintenance&lt;/code&gt; 中，这样便基本理解了 Caffeine 缓存的运行原理，需要注意的是，因为我们并未指定缓存元素的过期时间，所以与此相关的内容如时间过期策略和时间轮等内容不会专门介绍。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestReadSourceCode&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;@Test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// read constructor&lt;/span&gt;
        &lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;.&lt;/span&gt;&lt;span&gt;maximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10_000&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// read put&lt;/span&gt;
        cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"key"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"value"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// read get&lt;/span&gt;
        cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"key"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
&lt;h3&gt;constructor&lt;/h3&gt; 
&lt;p&gt;Caffeine 的实现类区分了 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt; 和 &lt;code&gt;UnboundedLocalManualCache&lt;/code&gt;，见名知意它们分别为「有边界」的和「无边界」的缓存。&lt;code&gt;Caffeine#isBounded&lt;/code&gt; 方法诠释了「边界」的含义：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1 &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; V1 &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 校验参数&lt;/span&gt;
        &lt;span&gt;requireWeightWithWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonLoadingCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;isBounded&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;?&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;span&gt;.&lt;/span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;:&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;UnboundedLocalCache&lt;span&gt;.&lt;/span&gt;UnboundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBounded&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 指定了最大大小；指定了最大权重&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumWeight &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;// 指定了访问后过期策略；指定了写后过期策略&lt;/span&gt;
                &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expireAfterAccessNanos &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expireAfterWriteNanos &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;// 指定了自定义过期策略；指定了 key 或 value 的引用级别&lt;/span&gt;
                &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expiry &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;keyStrength &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;valueStrength &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;也就是说，当为缓存指定了上述的驱逐或过期策略会定义为有边界的 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt; 缓存，它会限制缓存的大小，防止内存溢出，否则为无边界的 &lt;code&gt;UnboundedLocalManualCache&lt;/code&gt; 类型，它没有大小限制，直到内存耗尽。我们以创建配置了固定大小的缓存为例，它对应的类型便是 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt;，在执行构造方法时，有以下逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt;
        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// ...&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;CacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; loader&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            cache &lt;span&gt;=&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; loader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* async */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BoundedLocalCache&lt;/code&gt; 为抽象类，缓存对象的实际类型都是它的子类。它在创建时使用了反射并遵循简单工厂的编码风格：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;newBoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt;
                                                               &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; async&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; factory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;loadFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; factory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newInstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; async&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; e&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;getClassName&lt;/code&gt; 方法非常有意思，它会根据缓存配置的属性动态拼接出实际缓存类名：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StringBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// key 是强引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// value 是强引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'I'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了移除监听器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;removalListener &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'L'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了统计功能&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isRecordingStats&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 不同的驱逐策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 基于最大值限制，可能是最大权重 W，也可能是最大容量 S&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'M'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 基于权重或非权重&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了访问过期或可变过期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了写入过期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了刷新策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'R'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这也就是为什么能在 &lt;code&gt;com.github.benmanes.caffeine.cache&lt;/code&gt; 包路径下能发现很多类似 &lt;code&gt;SSMS&lt;/code&gt; 只有简称命名的类的原因（下图只截取部分，实际上有很多）：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="SSMS.png" src="https://oscimg.oschina.net/oscnet//e90933fffda7963aca2f9e451cff165e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根据代码逻辑，它的命名遵循如下格式 &lt;code&gt;S|W S|I [L] [S] [MW|MS] [A] [W] [R]&lt;/code&gt; 其中 &lt;code&gt;[]&lt;/code&gt; 表示选填，&lt;code&gt;|&lt;/code&gt; 表示某配置不同选择的分隔符，结合注释能清楚的了解各个位置字母简称表达的含义。如此定义实现类使用了 &lt;strong&gt;多级继承&lt;/strong&gt;，尽可能多地复用代码。&lt;/p&gt; 
&lt;p&gt;以我们测试用例中创建的缓存类型为例，它对应的实现类为 &lt;code&gt;SSMS&lt;/code&gt;，表示 key 和 value 均为强引用，并配置了非权重的最大缓存大小限制，类图关系如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="SSMS.drawio.png" src="https://oscimg.oschina.net/oscnet//ac900e4f348d7fa8c3f55d1442e17b2e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;虽然在一些软件设计相关的书籍中强调「多用组合，少用继承」，但是这里使用多级继承我觉得并没有增加开发者的理解难度，反而了解了它的命名规则后，能更清晰的理解各个缓存所表示的含义，更好地实现代码复用。&lt;/p&gt; 
&lt;p&gt;执行 &lt;code&gt;SSMS&lt;/code&gt; 的构造方法会有以下逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1&lt;/span&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt;
        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;PERCENT_MAIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.99d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;PERCENT_MAIN_PROTECTED&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.80d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;HILL_CLIMBER_STEP_PERCENT&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.0625d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;RemovalListener&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; evictionListener&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; drainBuffersTask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessPolicy&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; readBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodeFactory&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; weigher&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; executor&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isWeighted&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt;
                                &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 标记同步或异步&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;isAsync &lt;span&gt;=&lt;/span&gt; isAsync&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 指定 cacheLoader &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;cacheLoader &lt;span&gt;=&lt;/span&gt; cacheLoader&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 指定用于执行驱逐元素、刷新缓存等任务的线程池，不指定默认为 ForkJoinPool.commonPool()&lt;/span&gt;
        executor &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getExecutor&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 标记是否定义了节点计算权重的 Weigher 对象&lt;/span&gt;
        isWeighted &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 同步锁，在接下来的内容中会看到很多标记了 @GuardedBy("evictionLock") 注解的方法，表示这行这些方法时都会获取这把同步锁&lt;/span&gt;
        &lt;span&gt;// 根据该锁的命名，eviction 表示驱逐的意思，也就是说关注驱逐策略执行的方法都要获取该锁，这一点需要在后文中注意&lt;/span&gt;
        evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算元素权重的对象，不指定为 SingletonWeigher.INSTANCE&lt;/span&gt;
        weigher &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 执行缓存 maintenance 方法的任务，在后文中具体介绍&lt;/span&gt;
        drainBuffersTask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 创建节点的工厂&lt;/span&gt;
        nodeFactory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 驱逐监听器，有元素被驱逐时会回调&lt;/span&gt;
        evictionListener &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getEvictionListener&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 用于保存所有数据的 ConcurrentHashMap&lt;/span&gt;
        data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果指定驱逐策略，或 key 为弱引用，或 value 为弱引用或软引用，或 访问后过期则创建 readBuffer，否则它为不可用状态&lt;/span&gt;
        &lt;span&gt;// readBuffer 用于记录某些被访问过的节点&lt;/span&gt;
        readBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;collectKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;collectValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;?&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;BoundedBuffer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;disabled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果指定了驱逐策略，或 访问后过期策略则会定义访问策略，执行 onAccess 方法，后文详细介绍&lt;/span&gt;
        accessPolicy &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;onAccess&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; e &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 初始化最大值和最小值的双端队列作为 writeBuffer，用于记录一些写后操作任务 &lt;/span&gt;
        writeBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 执行了驱逐策略则更新最大容量限制&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;setMaximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setMaximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireArgument&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"maximum must not be negative"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;==&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 不能超过最大容量&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; max &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum&lt;span&gt;,&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算窗口区大小&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; window &lt;span&gt;=&lt;/span&gt; max &lt;span&gt;-&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PERCENT_MAIN&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算保护区大小&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mainProtected &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PERCENT_MAIN_PROTECTED&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;max &lt;span&gt;-&lt;/span&gt; window&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 记录这些值&lt;/span&gt;
        &lt;span&gt;setMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setWindowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;window&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setMainProtectedMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mainProtected&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 标记命中量、非命中量并初始化步长值，这三个值用于后续动态调整保护区和窗口区大小&lt;/span&gt;
        &lt;span&gt;setHitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setMissesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setStepSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;HILL_CLIMBER_STEP_PERCENT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 直到当前缓存的权重（大小）接近最大值一半时才初始化频率草图&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;max &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;FACTORY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// key value 强引用无需特殊操作&lt;/span&gt;
    &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var1&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;,&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SSMS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 频率草图，后文具体介绍&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; sketch &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderWindowDeque&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderProbationDeque&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderProtectedDeque&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;SSMS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var1&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;,&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果 Caffeine 初始化了容量则确定频率草图的容量&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; var4 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;sketch&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var4&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化窗口区、试用区和保护区，它们都是双端队列（链表实现）&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderWindowDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderProbationDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderProtectedDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在步骤 1 中定义了三个区的初始化大小为 1%|19%|80%，这样配置的性能相对较好。此外，我们还需要解释一下 &lt;code&gt;weightedSize()&lt;/code&gt; 方法，它用于访问 &lt;code&gt;long weightedSize&lt;/code&gt; 变量。根据其命名有「权重大小」的含义，在默认不指定权重计算对象 &lt;code&gt;Weigher&lt;/code&gt; 的情况下，&lt;code&gt;Weigher&lt;/code&gt; 默认为 &lt;code&gt;SingletonWeigher.INSTANCE&lt;/code&gt; 表示每个元素的权重大小为 1，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;SingletonWeigher&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;INSTANCE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这样 &lt;code&gt;weightedSize&lt;/code&gt; 表示的便是当前缓存中元素数量。如果自定义了 &lt;code&gt;Weigher&lt;/code&gt; 那么 &lt;code&gt;weightedSize&lt;/code&gt; 表示的便是缓存中总权重大小，每个元素的权重则可能会不同。因为在示例中我们并没有指定 &lt;code&gt;Weigher&lt;/code&gt;，所以在此处可以将 &lt;code&gt;weightedSize&lt;/code&gt; 理解为当前缓存大小。&lt;/p&gt; 
&lt;p&gt;上文中我们提到缓存的定义遵循大写字母缩写的命名规则，实际上节点类的定义也采用了这种方式，在创建节点工厂 &lt;code&gt;NodeFactory.newFactory(builder, isAsync)&lt;/code&gt;&lt;br&gt; 的逻辑中，它会执行如下逻辑，根据缓存的类型来确定它的节点类型，命名遵循 &lt;code&gt;P|F S|W|D A|AW|W| [R] [MW|MS]&lt;/code&gt; 的规则，同样使用了反射机制和简单工厂的编码风格，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// ...&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;newFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;interner&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Interned&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;FACTORY&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;loadFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StringBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// key 强引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'P'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'F'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// value 强引用或弱引用或软引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeakValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'D'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 过期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 访问后过期&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 写入后过期&lt;/span&gt;
                    className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 访问后过期&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 写入后过期&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 写入后刷新&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'R'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 驱逐策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 默认最大大小限制&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'M'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 加权&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;isAsync &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;weigher &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;singletonWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 非加权&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;SSMS&lt;/code&gt; 类型缓存对应的节点类型为 &lt;code&gt;PSMS&lt;/code&gt;。&lt;/p&gt; 
&lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
&lt;h4&gt;FrequencySketch&lt;/h4&gt; 
&lt;p&gt;接下来，我们需要具体介绍下 &lt;code&gt;FrequencySketch&lt;/code&gt;，它在上述构造方法的步骤 3 中被创建。这个类的实现采用了 &lt;strong&gt;Count-Min Sketch&lt;/strong&gt; 数据结构，它维护了一个 &lt;code&gt;long[] table&lt;/code&gt; 一维数组，每个元素有 64 位，每 4 位作为一个计数器（这也就限定了最大频率为 15），那么数组中每个槽位便是 16 个计数器。通过哈希函数取 4 个独立的计数值，将其中的最小值作为元素的访问频率。&lt;code&gt;table&lt;/code&gt; 的初始大小为缓存最大容量最接近的 2 的 n 次幂，并在计算哈希值时使用 &lt;code&gt;blockMask&lt;/code&gt; 掩码来使哈希结果均匀分布，保证了获取元素访问频率的正确率为 93.75%，达到空间与时间的平衡。它的实现原理和布隆过滤器类似，牺牲了部分准确性，但减少了占用内存的大小。如下图所示为计算元素 e 的访问频率：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="frequencySketch.drawio.png" src="https://oscimg.oschina.net/oscnet//0d20ca462980453af15f3e687ed9a674.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下为 &lt;code&gt;FrequencySketch&lt;/code&gt; 的源码，关注注释即可，并不复杂：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;RESET_MASK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;x7777777777777777L&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;ONE_MASK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;x1111111111111111L&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 采样大小，用于控制 reset&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sampleSize&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 掩码，用于均匀分散哈希结果&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; blockMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; table&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@NonNegative&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maximumSize&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireArgument&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 取缓存最大容量和 Integer.MAX_VALUE &amp;gt;&amp;gt;&amp;gt; 1 中的小值 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; maximum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximumSize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果已经被初始化过并且 table 长度大于等于最大容量，那么不进行操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;&amp;gt;=&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化 table，长度为最接近 maximum 的 2 的 n 次幂，和 8 中的大值&lt;/span&gt;
        table &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;max&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算采样大小&lt;/span&gt;
        sampleSize &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算掩码&lt;/span&gt;
        blockMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 特殊判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;sampleSize &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            sampleSize &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 计数器总数&lt;/span&gt;
        size &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@NonNegative&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;frequency&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果缓存没有被初始化则返回频率为 0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isNotInitialized&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 创建 4 个元素的数组 count 用于保存 4 次 hash 计算出的频率值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; count &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// hash 扰动，使结果均匀分布&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; blockHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 重 hash，进一步分散结果&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; counterHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;blockHash&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 根据掩码计算对应的块索引&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; block &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;blockHash &lt;span&gt;&amp;amp;&lt;/span&gt; blockMask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 循环 4 次计算 4 个计数器的结果&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 位运算变更 hash 值&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; counterHash &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;h &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 计算计数器的偏移量&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; h &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 定位到 table 中某个槽位后右移并进行位与运算得到最低的 4 位的值（0xfL 为二进制的 1111）&lt;/span&gt;
            count&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;block &lt;span&gt;+&lt;/span&gt; offset &lt;span&gt;+&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;xfL&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 取其中的较小值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isNotInitialized&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 长度为 8 的数组记录该元素对应的位置，每个计数器需要两个值来定位&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; blockHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; counterHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;blockHash&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; block &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;blockHash &lt;span&gt;&amp;amp;&lt;/span&gt; blockMask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; counterHash &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// i 记录定位到 table 中某元素的位偏移量&lt;/span&gt;
            index&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;h &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; h &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// i + 4 记录元素所在 table 中的索引&lt;/span&gt;
            index&lt;span&gt;[&lt;/span&gt;i &lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; block &lt;span&gt;+&lt;/span&gt; offset &lt;span&gt;+&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 四个对应的计数器都需要累加&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; added &lt;span&gt;=&lt;/span&gt;
                &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 累加成功且达到采样大小需要进行重置&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;added &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;size &lt;span&gt;==&lt;/span&gt; sampleSize&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; j &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;xfL &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1L&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 重置机制防止计数器溢出&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; count &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; table&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 累加 table 中每个元素的 2 进制表示的 1 的个数，结果为计数器个数的 4 倍&lt;/span&gt;
            count &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;bitCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;ONE_MASK&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 右移一位将计数值减半并将高位清零&lt;/span&gt;
            table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;RESET_MASK&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// count &amp;gt;&amp;gt;&amp;gt; 2 表示计数器个数，计算重置后的 size&lt;/span&gt;
        size &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;size &lt;span&gt;-&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;count &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0xed5ad4bb&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0xac4c1b51&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; x&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0x31848bab&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; x&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;到这里，&lt;code&gt;Caffeine&lt;/code&gt; 缓存的基本数据结构全貌已经展现出来了，如下所示，在后文中我们再具体关注它们之间是如何协同的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine.drawio.png" src="https://oscimg.oschina.net/oscnet//5408b3b6611371ddb67daf2bd23bed08.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;put&lt;/h3&gt; 
&lt;p&gt;接下来继续了解向缓存中添加元素的流程，本节内容比较多，理解起来也相对复杂，结合文章内容的同时，也需要多去深入查看 Caffeine 源码才能有更好的理解，以下为 &lt;code&gt;put&lt;/code&gt; 方法的源码：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 默认入参 onlyIfAbsent 为 false，表示向缓存中添加相同的 key 会对 value 进行替换 &lt;/span&gt;
    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* onlyIfAbsent */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;它会执行到如下具体逻辑中，关注注释信息：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodeFactory&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Nullable&lt;/span&gt;
    &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Expiry&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 不允许添加 null&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 获取当前时间戳&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; now &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 计算缓存权重，如果没有指定 weigher 的话，默认权重为 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newWeight &lt;span&gt;=&lt;/span&gt; weigher&lt;span&gt;.&lt;/span&gt;&lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 创建用于查找的键对象&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; lookupKey &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newLookupKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; attempts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; attempts&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 尝试获取节点；prior 译为先前的；较早的&lt;/span&gt;
            &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 处理不存在的节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 如果 node 在循环执行中还未被创建&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// NodeFactory 创建对应类型节点&lt;/span&gt;
                    node &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;keyReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;valueReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; newWeight&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 设置节点的过期时间&lt;/span&gt;
                    &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expireAfterCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 尝试添加新节点到缓存中，如果键已存在则返回现有节点&lt;/span&gt;
                prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;putIfAbsent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 返回 null 表示插入成功&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 写后操作：添加 AddTask 并调度执行任务&lt;/span&gt;
                    &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;AddTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; newWeight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// onlyIfAbsent 形参在默认的 put 方法中为 false，以下逻辑简单介绍&lt;/span&gt;
                &lt;span&gt;// 如果此时有其他线程添加了相同 key 的元素&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 获取到当前值，尝试判断读后失效策略，更新访问时间，并执行读后操作 afterRead 方法&lt;/span&gt;
                    &lt;span&gt;V&lt;/span&gt; currentValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;currentValue &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                            &lt;span&gt;tryExpireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; currentValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                            &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;}&lt;/span&gt;
                        &lt;span&gt;// 读后操作，该方法在 getIfPresent 中进行讲解&lt;/span&gt;
                        &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; currentValue&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 同样的逻辑&lt;/span&gt;
                &lt;span&gt;V&lt;/span&gt; currentValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;currentValue &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;tryExpireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; currentValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; currentValue&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意添加节点成功的逻辑，它会执行 &lt;code&gt;afterWrite&lt;/code&gt; 写后操作方法，添加 &lt;code&gt;AddTask&lt;/code&gt; 任务到 &lt;code&gt;writeBuffer&lt;/code&gt; 中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 写重试最多 100 次&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 添加写后 Task 到 writeBuffer 中并在合适的时机调度执行任务&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 最多重试添加 100 次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 写后调度&lt;/span&gt;
                &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 向 writeBuffer 中添加任务失败会调度任务执行&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 自旋等待，让出 CPU 控制权&lt;/span&gt;
            &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;writeBuffer&lt;/code&gt; 的类型为 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt;，在这里我们详细的介绍下它。&lt;/p&gt; 
&lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
&lt;h4&gt;WriteBuffer&lt;/h4&gt; 
&lt;p&gt;根据它的命名 &lt;strong&gt;GrowableArrayQueue&lt;/strong&gt; 可知它是一个容量可以增长的双端队列，前缀 &lt;strong&gt;MPSC&lt;/strong&gt; 表达的含义是「多生产者，单消费者」，也就是说可以有多个线程向其中添加元素，但只有一个线程能从其中获取元素。那么它是如何实现 &lt;strong&gt;MPSC&lt;/strong&gt; 的呢？接下来我们就根据源码详细了解一下。首先先来看一下它的类继承关系图及简要说明：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="WriteBuffer.drawio.png" src="https://oscimg.oschina.net/oscnet//9c4c7ac6929306032ede02853ad2e105.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;图中灰色的表示抽象类，蓝色为实现类，&lt;code&gt;java.util.AbstractQueue&lt;/code&gt; 就不再多解释了。我们先看看其中标记红框的类，讨论到底什么是「避免内存伪共享问题」？&lt;/p&gt; 
&lt;p&gt;以 &lt;code&gt;BaseMpscLinkedArrayQueuePad1&lt;/code&gt; 为例：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p000&lt;span&gt;,&lt;/span&gt; p001&lt;span&gt;,&lt;/span&gt; p002&lt;span&gt;,&lt;/span&gt; p003&lt;span&gt;,&lt;/span&gt; p004&lt;span&gt;,&lt;/span&gt; p005&lt;span&gt;,&lt;/span&gt; p006&lt;span&gt;,&lt;/span&gt; p007&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p008&lt;span&gt;,&lt;/span&gt; p009&lt;span&gt;,&lt;/span&gt; p010&lt;span&gt;,&lt;/span&gt; p011&lt;span&gt;,&lt;/span&gt; p012&lt;span&gt;,&lt;/span&gt; p013&lt;span&gt;,&lt;/span&gt; p014&lt;span&gt;,&lt;/span&gt; p015&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p016&lt;span&gt;,&lt;/span&gt; p017&lt;span&gt;,&lt;/span&gt; p018&lt;span&gt;,&lt;/span&gt; p019&lt;span&gt;,&lt;/span&gt; p020&lt;span&gt;,&lt;/span&gt; p021&lt;span&gt;,&lt;/span&gt; p022&lt;span&gt;,&lt;/span&gt; p023&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p024&lt;span&gt;,&lt;/span&gt; p025&lt;span&gt;,&lt;/span&gt; p026&lt;span&gt;,&lt;/span&gt; p027&lt;span&gt;,&lt;/span&gt; p028&lt;span&gt;,&lt;/span&gt; p029&lt;span&gt;,&lt;/span&gt; p030&lt;span&gt;,&lt;/span&gt; p031&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p032&lt;span&gt;,&lt;/span&gt; p033&lt;span&gt;,&lt;/span&gt; p034&lt;span&gt;,&lt;/span&gt; p035&lt;span&gt;,&lt;/span&gt; p036&lt;span&gt;,&lt;/span&gt; p037&lt;span&gt;,&lt;/span&gt; p038&lt;span&gt;,&lt;/span&gt; p039&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p040&lt;span&gt;,&lt;/span&gt; p041&lt;span&gt;,&lt;/span&gt; p042&lt;span&gt;,&lt;/span&gt; p043&lt;span&gt;,&lt;/span&gt; p044&lt;span&gt;,&lt;/span&gt; p045&lt;span&gt;,&lt;/span&gt; p046&lt;span&gt;,&lt;/span&gt; p047&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p048&lt;span&gt;,&lt;/span&gt; p049&lt;span&gt;,&lt;/span&gt; p050&lt;span&gt;,&lt;/span&gt; p051&lt;span&gt;,&lt;/span&gt; p052&lt;span&gt;,&lt;/span&gt; p053&lt;span&gt;,&lt;/span&gt; p054&lt;span&gt;,&lt;/span&gt; p055&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p056&lt;span&gt;,&lt;/span&gt; p057&lt;span&gt;,&lt;/span&gt; p058&lt;span&gt;,&lt;/span&gt; p059&lt;span&gt;,&lt;/span&gt; p060&lt;span&gt;,&lt;/span&gt; p061&lt;span&gt;,&lt;/span&gt; p062&lt;span&gt;,&lt;/span&gt; p063&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p064&lt;span&gt;,&lt;/span&gt; p065&lt;span&gt;,&lt;/span&gt; p066&lt;span&gt;,&lt;/span&gt; p067&lt;span&gt;,&lt;/span&gt; p068&lt;span&gt;,&lt;/span&gt; p069&lt;span&gt;,&lt;/span&gt; p070&lt;span&gt;,&lt;/span&gt; p071&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p072&lt;span&gt;,&lt;/span&gt; p073&lt;span&gt;,&lt;/span&gt; p074&lt;span&gt;,&lt;/span&gt; p075&lt;span&gt;,&lt;/span&gt; p076&lt;span&gt;,&lt;/span&gt; p077&lt;span&gt;,&lt;/span&gt; p078&lt;span&gt;,&lt;/span&gt; p079&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p080&lt;span&gt;,&lt;/span&gt; p081&lt;span&gt;,&lt;/span&gt; p082&lt;span&gt;,&lt;/span&gt; p083&lt;span&gt;,&lt;/span&gt; p084&lt;span&gt;,&lt;/span&gt; p085&lt;span&gt;,&lt;/span&gt; p086&lt;span&gt;,&lt;/span&gt; p087&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p088&lt;span&gt;,&lt;/span&gt; p089&lt;span&gt;,&lt;/span&gt; p090&lt;span&gt;,&lt;/span&gt; p091&lt;span&gt;,&lt;/span&gt; p092&lt;span&gt;,&lt;/span&gt; p093&lt;span&gt;,&lt;/span&gt; p094&lt;span&gt;,&lt;/span&gt; p095&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p096&lt;span&gt;,&lt;/span&gt; p097&lt;span&gt;,&lt;/span&gt; p098&lt;span&gt;,&lt;/span&gt; p099&lt;span&gt;,&lt;/span&gt; p100&lt;span&gt;,&lt;/span&gt; p101&lt;span&gt;,&lt;/span&gt; p102&lt;span&gt;,&lt;/span&gt; p103&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p104&lt;span&gt;,&lt;/span&gt; p105&lt;span&gt;,&lt;/span&gt; p106&lt;span&gt;,&lt;/span&gt; p107&lt;span&gt;,&lt;/span&gt; p108&lt;span&gt;,&lt;/span&gt; p109&lt;span&gt;,&lt;/span&gt; p110&lt;span&gt;,&lt;/span&gt; p111&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p112&lt;span&gt;,&lt;/span&gt; p113&lt;span&gt;,&lt;/span&gt; p114&lt;span&gt;,&lt;/span&gt; p115&lt;span&gt;,&lt;/span&gt; p116&lt;span&gt;,&lt;/span&gt; p117&lt;span&gt;,&lt;/span&gt; p118&lt;span&gt;,&lt;/span&gt; p119&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这个类除了定义了 120 字节的字段外，看上去没有做其他任何事情，实际上它为 &lt;strong&gt;性能提升&lt;/strong&gt; 默默做出了贡献，&lt;strong&gt;避免了内存伪共享&lt;/strong&gt;。CPU 中缓存行（Cache Line）的大小通常是 64 字节，在类中定义 120 字节来占位，这样便能将上下继承关系间的字段间隔开，保证被多个线程访问的关键字段距离至少跨越一个缓存行，分布在不同的缓存行中。这样在不同的线程访问 &lt;code&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/code&gt; 和 &lt;code&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/code&gt; 中字段时互不影响，详细了解原理可参考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fzhongqifeng%2Fp%2F14765576.html" rel="nofollow" target="_blank"&gt;博客园 - CPU Cache 与缓存行&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;接下来我们看看其他抽象类的作用。&lt;code&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/code&gt; 定义生产者相关字段：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 生产者操作索引（并不对应缓冲区 producerBuffer 中索引位置）&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerIndex&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/code&gt; 负责定义消费者相关字段：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad2&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 掩码值，用于计算消费者实际的索引位置&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; consumerMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 消费者访问这个缓冲区来获取元素消费&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; consumerBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 消费者操作索引（并不对应缓冲区 consumerBuffer 中索引位置）&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; consumerIndex&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/code&gt; 中定义字段如下，该类的命名包含 &lt;strong&gt;Cold&lt;/strong&gt;，表示其中字段被修改的次数会比较少：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad3&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 生产者可以操作的最大索引上限&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerLimit&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 掩码值，用于计算生产者在数组中实际的索引&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 存储生产者生产的元素&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; producerBuffer&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;现在关键字段我们已经介绍完了，接下来看一下创建 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 的逻辑，执行它的构造方法时会为我们刚刚提到的字段进行赋值：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 调用父类的构造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;,&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 省略字节占位字段...&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p119&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 调用父类的构造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;,&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxQueueCapacity&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 调用父类的构造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maxCapacity &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Max capacity must be 4 or more"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 保证了最大值最少比初始值大 2 倍&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
                    &lt;span&gt;"Initial capacity cannot exceed maximum capacity(both rounded up to a power of 2)"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 最大容量也为 2 的 n 次幂&lt;/span&gt;
        maxQueueCapacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;initialCapacity &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Initial capacity must be 2 or more"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化缓冲区大小为数值最接近的 2 的 n 次幂&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; p2capacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 掩码值，-1L 使其低位均为 1，左移 1 位则最低位为 0，eg: 00000110，注意该值会被生产者和消费者掩码值共同赋值&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;p2capacity &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1L&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 创建一个大小为 2 的 n 次幂 +1 大小的缓冲区，注意这个 buffer 分别被 producerBuffer 和 consumerBuffer 共同引用&lt;/span&gt;
        &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;allocate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;p2capacity &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// BaseMpscLinkedArrayQueueColdProducerFields 类中相关字段赋值&lt;/span&gt;
        producerBuffer &lt;span&gt;=&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        producerMask &lt;span&gt;=&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 将 producerLimit 值赋为，掩码值&lt;/span&gt;
        &lt;span&gt;soProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// BaseMpscLinkedArrayQueueConsumerFields 类中相关字段赋值&lt;/span&gt;
        consumerBuffer &lt;span&gt;=&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        consumerMask &lt;span&gt;=&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;现在 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 的构建已经看完了，了解了其中关键字段的赋值，现在我们就需要看它是如何实现 &lt;strong&gt;MPSC&lt;/strong&gt; 的。「多生产者」也就意味着会有多个线程向其中添加元素，既然是多线程就需要重点关注它是如何在多线程间完成协同的。添加操作对应了 &lt;code&gt;BaseMpscLinkedArrayQueue#offer&lt;/code&gt; 方法，它的实现如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"MissingDefault"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;NullPointerException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 生产者最大索引（生产者掩码值），获取 BaseMpscLinkedArrayQueueColdProducerFields 中定义的该字段&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; producerLimit &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 生产者当前索引，初始值为 0，BaseMpscLinkedArrayQueueProducerFields 中字段 &lt;/span&gt;
            pIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// producerIndex 最低位用来表示扩容（索引生产者索引 producerIndex 并不对应缓冲区中实际的索引）&lt;/span&gt;
            &lt;span&gt;// 低位为 1 表示正在扩容，自旋等待直到扩容完成（表示只有一个线程操作扩容）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 掩码值和 buffer 可能在扩容中被改变，每次循环使用最新值&lt;/span&gt;
            mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;producerMask&lt;span&gt;;&lt;/span&gt;
            buffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;producerBuffer&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 检查是否需要扩容&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;producerLimit &lt;span&gt;&amp;lt;=&lt;/span&gt; pIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;offerSlowPath&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; producerLimit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;result&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;,&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// CAS 操作更新生产者索引，注意这里是 +2，更新成功结束循环&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 计算该元素在 buffer 中的实际偏移量，并将其添加到缓冲区中&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 没有将 resize 逻辑封装在该方法中，而是由该方法判断是否需要扩容&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;offerSlowPath&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerLimit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; result&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 获取消费者索引 BaseMpscLinkedArrayQueueConsumerFields 类中&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; cIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 通过掩码值计算当前缓冲区容量&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; bufferCapacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getCurrentBufferCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果队列还有空间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cIndex &lt;span&gt;+&lt;/span&gt; bufferCapacity &lt;span&gt;&amp;gt;&lt;/span&gt; pIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 尝试更新生产者最大限制，更新失败则返回 1 重试&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;casProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; producerLimit&lt;span&gt;,&lt;/span&gt; cIndex &lt;span&gt;+&lt;/span&gt; bufferCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 如果队列已满且无法扩展&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;availableInQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; cIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 更新 producerIndex 最低位为 1，成功则进行扩容，否则重试&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; result&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; oldMask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; oldBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 计算新缓冲区大小并创建，2 * (buffer.length - 1) + 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newBufferLength &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getNextBufferSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; newBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;allocate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newBufferLength&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 更新缓冲区引用为新的缓冲区&lt;/span&gt;
        producerBuffer &lt;span&gt;=&lt;/span&gt; newBuffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新新的掩码&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;newBufferLength &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        producerMask &lt;span&gt;=&lt;/span&gt; newMask&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 计算元素在新旧缓冲区中的偏移量&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInOld &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; oldMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInNew &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; newMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 将元素放到新缓冲区中&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 将新缓冲区连接到旧缓冲区中&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; newBuffer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 校验可用空间&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; cIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; availableInQueue &lt;span&gt;=&lt;/span&gt; &lt;span&gt;availableInQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; cIndex&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;availableInQueue &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 更新生产者限制大小和生产者索引&lt;/span&gt;
        &lt;span&gt;soProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newMask&lt;span&gt;,&lt;/span&gt; availableInQueue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;soProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 将旧缓冲区中该位置的元素更新为 JUMP 标志位，这样在被消费时就知道去新的缓冲区获取了&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;,&lt;/span&gt; offsetInOld&lt;span&gt;,&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;// 因为最低位用来表示是否在扩容，所以 producerIndex 和 consumerIndex 并不表示实际的索引&lt;/span&gt;
    &lt;span&gt;// 注意生产者（消费者）操作索引值会随着元素的增加不断变大，因为有它们和掩码值的位与运算才保证了索引值一直在索引值的有效范围内&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可见，在这个过程中它并没有限制操作线程数量，也没有使用加锁的同步机制。它通过保证 &lt;strong&gt;可见性&lt;/strong&gt;，并使用 &lt;strong&gt;自旋锁结合 CAS 操作&lt;/strong&gt; 更新生产者索引值，因为该操作是原子的，同时只有一个线程能更新获取索引值成功，更新失败的线程会自旋重试，这样便允许多线程同时添加元素，可见性保证和 CAS 操作源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;VarHandle&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; pIndexLookup&lt;span&gt;.&lt;/span&gt;&lt;span&gt;findVarHandle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
            &lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"producerIndex"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// volatile 可见性保证&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVolatile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;// CAS 操作&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; expect&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; newValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;compareAndSet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; expect&lt;span&gt;,&lt;/span&gt; newValue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;保证可见性（内存操作对其他线程可见）的原理是 &lt;strong&gt;内存屏障&lt;/strong&gt;，除了保证可见性以外，内存屏障还能够 &lt;strong&gt;防止重排序&lt;/strong&gt;（确保在内存屏障前后的内存操作不会被重排序，从而保证程序的正确性）。到这里，生产者添加元素的逻辑我们已经分析完了，接下来我们需要继续看一下消费者获取元素的逻辑，它对应了 &lt;code&gt;BaseMpscLinkedArrayQueue#poll&lt;/code&gt; 方法，同样地，在这过程中需要关注「在这个方法中有没有限制单一线程执行」，以此实现单消费者呢：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 读取消费者相关字段 BaseMpscLinkedArrayQueueConsumerFields 类&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer &lt;span&gt;=&lt;/span&gt; consumerBuffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; consumerIndex&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; consumerMask&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 根据消费索引，计算出元素在消费者缓冲区中实际的位置&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 读取该元素（volatile 可见性读取）&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; e &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        
        &lt;span&gt;// 如果为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 比较生产者索引，如果两个索引不相等，那么证明两索引间存在距离表示还有元素能够被消费&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 自旋读取元素，直到读到元素&lt;/span&gt;
                &lt;span&gt;do&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    e &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 索引相等证明确实是空队列&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 获取到新缓冲区&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getNextBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 在新缓冲区中获取到对应元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;newBufferPoll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 清除当前索引的元素，表示该元素已经被消费&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新消费者索引，这里也是 +2，它并不表示实际的在缓冲区的索引&lt;/span&gt;
        &lt;span&gt;soConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; e&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;getNextBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果已经发生扩容，此时 consumerMask 仍然对应的是扩容前的 mask&lt;/span&gt;
        &lt;span&gt;// 此处与生产者操作扩容时拼接新旧缓冲区调用的是一样的方法，这样便能够获取到新缓冲区的偏移量&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nextArrayOffset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 获取到新缓冲区，因为在扩容操作时已经将新缓冲区链接到旧缓冲区上了&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; nextArrayOffset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 将旧缓冲区中新缓冲区位置设置为 null 表示旧缓冲区中已经没有任何元素需要被消费了，也不再需要被引用了（能被垃圾回收了）&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; nextArrayOffset&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; nextBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;newBufferPoll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 计算出消费者操作索引在新缓冲区中对应的实际位置&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInNew &lt;span&gt;=&lt;/span&gt; &lt;span&gt;newBufferAndOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在新缓冲区中获取到对应元素&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; n &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"new buffer must have at least one element"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 清除当前索引的元素，表示该元素已经被消费&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新消费者索引&lt;/span&gt;
        &lt;span&gt;soConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;newBufferAndOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 将消费者缓冲区引用和掩码值更新&lt;/span&gt;
        consumerBuffer &lt;span&gt;=&lt;/span&gt; nextBuffer&lt;span&gt;;&lt;/span&gt;
        consumerMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2L&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; consumerMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;REF_ARRAY&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVolatile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以发现在该方法中并没有限制单一线程执行，所以理论上这个方法可能被多个线程调用，那么它又为什么被称为 &lt;strong&gt;MPSC&lt;/strong&gt; 呢？在这个方法中的一段注释值得细心体会：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;This implementation is correct for single consumer thread use only.&lt;br&gt; 此实现仅适用於单消费者线程使用&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;所以调用该方法时开发者本身需要保证单线程调用而并不是在实现中控制。&lt;/p&gt; 
&lt;p&gt;到这里 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 中核心的逻辑已经讲解完了，现在我们回过头来再看一下队列扩容前后生产者和消费者是如何协同的？在扩容前，&lt;code&gt;consumerBuffer&lt;/code&gt; 和 &lt;code&gt;producerBuffer&lt;/code&gt; 引用的是同一个缓冲区对象。如果发生扩容，那么生产者会创建一个新的缓冲区，并将 &lt;code&gt;producerBuffer&lt;/code&gt; 引用指向它，此时它做了一个 &lt;strong&gt;非常巧妙&lt;/strong&gt; 的操作，将 &lt;strong&gt;新缓冲区依然链接到旧缓冲区&lt;/strong&gt; 上，并将触发扩容的元素对应的旧缓冲区的索引处标记为 JUMP，表示这及之后的元素已经都在新缓冲区中。此时，消费者依然会在旧缓冲区中慢慢地消费，直到遇到 JUMP 标志位，消费者就知道需要到新缓冲区中取获取元素了。因为之前生产者在扩容时对新旧缓冲区进行链接，所以消费者能够通过旧缓冲区获取到新缓冲区的引用，并变更 &lt;code&gt;consumerBuffer&lt;/code&gt; 的引用和 &lt;code&gt;consumerMask&lt;/code&gt; 掩码值，接下来的消费过程便和扩容前没有差别了。&lt;/p&gt; 
&lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
&lt;h4&gt;scheduleAfterWrite&lt;/h4&gt; 
&lt;p&gt;现在我们再回到 &lt;code&gt;put&lt;/code&gt; 方法的逻辑中，如果向 &lt;code&gt;WriterBuffer&lt;/code&gt; 中添加元素成功，则会调用 &lt;code&gt;scheduleAfterWrite&lt;/code&gt; 方法，调度任务的执行：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 默认为 ForkJoinPool.commonPool()&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; executor&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 该任务在创建缓存时已经完成初始化&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; drainBuffersTask&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// 根据状态的变化来调度执行任务&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 获取当前 drainStatus，drain 译为排空，耗尽&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; &lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 这里的状态机变更需要关注下&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;drainStatus&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// IDLE 表示当前无任务可做&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// CAS 更新状态为 REQUIRED&lt;/span&gt;
                    &lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 调度任务执行&lt;/span&gt;
                    &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// REQUIRED 表示当前有任务需要执行&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// 调度任务执行&lt;/span&gt;
                    &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// PROCESSING_TO_IDLE 表示当前任务处理完成后会变成 IDLE 状态&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// 又来了新的任务，则 CAS 操作将它更新为 PROCESSING_TO_REQUIRED 状态&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusAcquire&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// PROCESSING_TO_REQUIRED 表示正在处理任务，处理完任务后还有任务需要处理&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Invalid drain status: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; drainStatus&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 调度执行缓冲区中的任务&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果状态表示正在有任务处理则返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 注意这里要获取同步锁 evictionLock&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 获取锁后再次校验当前处理状态&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;drainStatus &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 更新状态为 PROCESSING_TO_IDLE&lt;/span&gt;
                &lt;span&gt;setDrainStatusRelease&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 同步机制保证任何时刻只能有一个线程能够提交任务&lt;/span&gt;
                executor&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;drainBuffersTask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WARNING&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when submitting maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;/* ignored */&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;写后调度处理任务（&lt;code&gt;scheduleAfterWrite&lt;/code&gt;）会根据状态选择性执行 &lt;code&gt;scheduleDrainBuffers&lt;/code&gt; 方法，执行该方法时通过同步锁 &lt;code&gt;evictionLock&lt;/code&gt; 保证同时只有一个线程能提交 &lt;code&gt;PerformCleanupTask&lt;/code&gt; 任务。这个任务在创建缓存时已经被初始化完成了，每次提交任务都会被复用，接下来我们看一下这个任务的具体实现：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 可重用的任务，用于执行 maintenance 方法，避免了使用 ForkJoinPool 来包装&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ForkJoinTask&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Void&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1L&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; reference&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;PerformCleanupTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            reference &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cache&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;exec&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when performing the maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// Indicates that the task has not completed to allow subsequent submissions to execute&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 获取到缓存对象&lt;/span&gt;
            &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache &lt;span&gt;=&lt;/span&gt; reference&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cache &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;performCleanUp&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;它的实现非常简单，其中 &lt;code&gt;reference&lt;/code&gt; 字段在调用构造方法时被赋值，引用的是缓存对象本身。当任务被执行时，调用的是 &lt;code&gt;BoundedLocalCache#performCleanUp&lt;/code&gt; 方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// 执行该任务时，也要获取同步锁，表示任务只能由一个线程来执行&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;performCleanUp&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 执行维护任务&lt;/span&gt;
            &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 更新状态为执行中&lt;/span&gt;
        &lt;span&gt;setDrainStatusRelease&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 处理读缓冲区中的任务&lt;/span&gt;
            &lt;span&gt;drainReadBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 处理写缓冲区中的任务&lt;/span&gt;
            &lt;span&gt;drainWriteBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;task &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                task&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 处理 key 和 value 的引用&lt;/span&gt;
            &lt;span&gt;drainKeyReferences&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;drainValueReferences&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 过期和驱逐策略&lt;/span&gt;
            &lt;span&gt;expireEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 「增值」 操作，后续重点讲&lt;/span&gt;
            &lt;span&gt;climb&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 状态不是 PROCESSING_TO_IDLE 或者无法 CAS 更新为 IDLE 状态的话，需要更新状态为 REQUIRED，该状态会再次执行维护任务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;setDrainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意在执行 &lt;code&gt;performCleanUp&lt;/code&gt; 方法时，也需要获取到同步锁 &lt;code&gt;evictionLock&lt;/code&gt;，那么任务的提交和任务的执行也是互斥的。这个执行的核心逻辑在 &lt;code&gt;maintenance&lt;/code&gt; 「维护」方法中，注意这个方法被标记了注解 &lt;code&gt;@GuardedBy("evictionLock")&lt;/code&gt;，源码中还有多个方法也标记了该注解，执行这些方法时都要获取同步锁，这也是在提醒我们这些方法同时只有由一条线程被执行。因为目前关注的是 &lt;code&gt;put&lt;/code&gt; 方法，所以重点先看维护方法中 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 方法处理写缓冲区中任务的逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;NCPU&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Runtime&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getRuntime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;availableProcessors&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;drainWriteBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 最大循环次数为 writeBuffer 最大容量，直至弹出元素为 null&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Runnable&lt;/span&gt; task &lt;span&gt;=&lt;/span&gt; writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;task &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            task&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 更新状态为 PROCESSING_TO_REQUIRED&lt;/span&gt;
        &lt;span&gt;setDrainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;执行逻辑非常简单，在获取到同步锁之后，在 &lt;code&gt;WriteBuffer&lt;/code&gt; 中获取要被执行的任务并执行。在这里我们能发现「SC 单消费者」的实现使用 &lt;strong&gt;同步锁的机制保证同时只能有一个消费者消费缓冲区中的任务&lt;/strong&gt;。在上文中我们已经知道，调用 &lt;code&gt;put&lt;/code&gt; 方法时向缓冲区 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加的任务为 &lt;code&gt;AddTask&lt;/code&gt;，下面我们看一下该任务的实现：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 节点权重&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;AddTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;weight &lt;span&gt;=&lt;/span&gt; weight&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;node &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"FutureReturnValueIgnored"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 是否指定了驱逐策略&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 更新缓存权重和窗口区权重&lt;/span&gt;
                &lt;span&gt;setWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;setWindowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;windowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新节点的 policyWeight，该字段只有在自定了权重计算规则时才有效&lt;/span&gt;
                &lt;span&gt;// 否则像只定义了固定容量的驱逐策略，使用默认元素权重为 1 是不需要关注该字段的&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                &lt;span&gt;// 检测当前总权重是否超过一半的最大容量&lt;/span&gt;
                &lt;span&gt;long&lt;/span&gt; maximum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 如果超过最大容量&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 执行驱逐操作&lt;/span&gt;
                        &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 延迟加载频率草图 frequencySketch 数据结构，用于统计元素访问频率&lt;/span&gt;
                        &lt;span&gt;long&lt;/span&gt; capacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;mappingCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; maximum&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;capacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新频率统计信息&lt;/span&gt;
                &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 因为频率草图数据结构具有延迟加载机制（权重超过半数）&lt;/span&gt;
                    &lt;span&gt;// 所以实际上在元素权重还未过半未完成初始化时，调用 increment 是没有作用的&lt;/span&gt;
                    &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 增加未命中样本数&lt;/span&gt;
                &lt;span&gt;setMissesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;missesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 同步检测节点是否还有效&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; isAlive&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                isAlive &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;isAlive&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 写后过期策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 过期策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 驱逐策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 如果权重比配置的最大权重大&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 执行固定权重（RemovalCause.SIZE）的驱逐策略&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 如果权重超过窗口区最大权重，则将其放在窗口区头节点&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;windowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerFirst&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 否则放在窗口区尾节点&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 访问后过期策略&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 处理异步计算&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;Async&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isReady&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;CompletableFuture&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;long&lt;/span&gt; expirationTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;ASYNC_EXPIRY&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;根据注释很容易理解该方法的作用，因为我们目前对缓存只定义了固定容量的驱逐策略，所以我们需要在看一下 &lt;code&gt;evictEntry&lt;/code&gt; 方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;"GuardedByChecker"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"NullAway"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"PMD.CollapsibleIfStatements"&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt; cause&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;V&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; removed &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; resurrect &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; keyReference &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; actualCause &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;computeIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keyReference&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n &lt;span&gt;!=&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                &lt;span&gt;// key 或 value 为 null，这种情况下可能使用了 Caffeine.weakKeys, Caffeine.weakValues, or Caffeine.softValues&lt;/span&gt;
                &lt;span&gt;// 导致被垃圾回收了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 标记实际失效原因为垃圾回收 &lt;/span&gt;
                    actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果原因为垃圾回收，记录 resurrect 复活标记为 true&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cause &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 否则记录入参中的原因&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; cause&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 过期驱逐策略判断&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;boolean&lt;/span&gt; expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;expiresAfterAccessNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;expiresAfterWriteNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 固定容量驱逐策略&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; weight &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 通知驱逐策略监听器，调用它的方法&lt;/span&gt;
                &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 将该 key 对应的刷新策略失效&lt;/span&gt;
                &lt;span&gt;discardRefresh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keyReference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 标记该节点被驱逐&lt;/span&gt;
                removed&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 退休准备被垃圾回收&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;retire&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 如果复活标记为 true 那么不被移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 节点已经要被驱逐&lt;/span&gt;
        &lt;span&gt;// 如果在窗口区，那么直接从窗口区移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 如果没在窗口区&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 在试用区直接在试用区移除&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 在保护区则直接从保护区移除&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 将写后失效和时间轮中关于该节点的元素移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;deschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 同步机制将 node 置为 dead&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;logIfAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;makeDead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;removed&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 节点被移除监控计数和节点移除通知回调&lt;/span&gt;
            &lt;span&gt;statsCounter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;recordEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;该方法比较简单，是将节点进行驱逐的逻辑，在后文中它会被多次复用，需要留一个印象。回到 &lt;code&gt;AddTask&lt;/code&gt; 任务的逻辑中，当被添加的元素权重超过最大权重限制时会被直接移除。这种特殊情况试用于指定了权重计算策略的缓存，如果只指定了固定容量，元素权重默认为 1，所以不会直接超过最大缓存数量限制。&lt;/p&gt; 
&lt;p&gt;现在我们已经将 &lt;code&gt;put&lt;/code&gt; 方法中向缓存中添加元素的逻辑介绍完了，接下来需要关注 &lt;code&gt;put&lt;/code&gt; 方法中对已存在的相同 key 值元素的处理逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;MAX_PUT_SPIN_WAIT_ATTEMPTS&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SECONDS&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;@Nullable&lt;/span&gt;
    &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Expiry&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; now &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newWeight &lt;span&gt;=&lt;/span&gt; weigher&lt;span&gt;.&lt;/span&gt;&lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; lookupKey &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newLookupKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; attempts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; attempts&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// ... &lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 元素被读到之后可能已经被驱逐了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 自旋尝试重新从 ConcurrentHashMap 中获取，再获取时如果为 null 则执行新增逻辑&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;attempts &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;MAX_PUT_SPIN_WAIT_ATTEMPTS&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果自旋尝试后元素仍未被删除，校验元素是否处于存活状态&lt;/span&gt;
                &lt;span&gt;// 如果处于非存活状态，那么可能这个元素已经被破坏，无法被移除，抛出异常&lt;/span&gt;
                data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;computeIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;requireIsAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;V&lt;/span&gt; oldValue&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 新的过期时间&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; varTime&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; oldWeight&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; mayUpdate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; exceedsTolerance &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 为元素加同步锁&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 如果此时元素已经失效了，那么需要重新循环&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                oldValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                oldWeight &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// oldValue 为 null 证明它被垃圾回收器回收了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 记录元素创建后的过期时间&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 驱逐监听器回调&lt;/span&gt;
                    &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果元素已经过期了&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 标记过期标志为 true&lt;/span&gt;
                    expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 记录元素创建后的过期时间并回调驱逐监听器&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAftexpireAfterCreateerCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// onlyInAbsent 为 true 时不会对已存在 key 的值进行修改&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    mayUpdate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 记录元素读后过期时间&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 记录元素修改后过期时间&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterUpdate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 需要修改原有 key 的 value 值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    exceedsTolerance &lt;span&gt;=&lt;/span&gt;
                            &lt;span&gt;// 配置了写后过期策略且已经超过写后时间的容忍范围&lt;/span&gt;
                            &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                                    &lt;span&gt;// 或者配置了可变时间过期策略同样判断是否超过时间的容忍范围&lt;/span&gt;
                                    &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;abs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;varTime &lt;span&gt;-&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                    &lt;span&gt;// 更新值，更新权重，更新写时间&lt;/span&gt;
                    prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;valueReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newWeight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                    &lt;span&gt;// 写后刷新策略失效&lt;/span&gt;
                    &lt;span&gt;discardRefresh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新过期时间&lt;/span&gt;
                &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; varTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新访问时间&lt;/span&gt;
                &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 根据不同的情况回调不同的监听器&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* oldValue */&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyOnReplace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 计算写后权重变化&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; weightedDifference &lt;span&gt;=&lt;/span&gt; mayUpdate &lt;span&gt;?&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;newWeight &lt;span&gt;-&lt;/span&gt; oldWeight&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 如果 oldValue 已经被回收，或 权重修改前后发生变更，或 已经过期，添加更新任务&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weightedDifference &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; weightedDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 如果超过了时间容忍范围，添加更新任务&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;onlyIfAbsent &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; exceedsTolerance&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; weightedDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 没有超过时间容忍范围，更新写时间&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 处理读后操作&lt;/span&gt;
                &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt; expired &lt;span&gt;?&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; oldValue&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;对于已有元素的变更，会对节点添加同步锁，更新它的权重等一系列变量，如果超过 1s 的时间容忍范围，则会添加 &lt;code&gt;UpdateTask&lt;/code&gt; 更新任务，至于处理读后操作 &lt;code&gt;afterRead&lt;/code&gt; 在读方法中再去介绍。接下来我们需要重新再看一下 &lt;code&gt;afterWrite&lt;/code&gt; 方法，其中有部分我们在上文中没有介绍的逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 这段逻辑我们在看 AddTask 的逻辑时已经看过了，所以略过&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 以下逻辑用于解决在重试了 100 次后仍然写入失败的问题，它会尝试获取 evictionLock 同步锁&lt;/span&gt;
        &lt;span&gt;// 直接同步执行「维护」方法并执行当前任务，但是它并无法解决某个写入操作执行时间很长的问题&lt;/span&gt;
        &lt;span&gt;// 发生这种情况的原因可能是由于执行器的所有线程都很忙（可能是写入此缓存），写入速率大大超过了消耗速率，优先级反转，或者执行器默默地丢弃了维护任务&lt;/span&gt;
        &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when performing the maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 重新调度异步维护任务，确保维护操作能及时执行&lt;/span&gt;
        &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; remainingNanos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;WARN_AFTER_LOCK_WAIT_NANOS&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; remainingNanos&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; interrupted &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;remainingNanos&lt;span&gt;,&lt;/span&gt; &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NANOSECONDS&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WARNING&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"The cache is experiencing excessive wait times for acquiring "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"the eviction lock. This may indicate that a long-running computation has halted "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"eviction when trying to remove the victim entry. Consider using AsyncCache to "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"decouple the computation from the map operation."&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TimeoutException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;InterruptedException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    remainingNanos &lt;span&gt;=&lt;/span&gt; end &lt;span&gt;-&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    interrupted &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;interrupted&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;currentThread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interrupt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 调用同步的维护方法时，可能发生获取锁超时，那么再重新开启一个异步维护调度&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 校验是否有任务需要被执行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        
        &lt;span&gt;// 默认线程池调度任务执行，这个方法我们在上文中已经详细介绍过&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;executor &lt;span&gt;==&lt;/span&gt; &lt;span&gt;ForkJoinPool&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;commonPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        
        &lt;span&gt;// 如果自定义了线程池，那么会使用自定义的线程池进行处理&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pacer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pacer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pacer &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isScheduled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isScheduled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;executor&lt;span&gt;,&lt;/span&gt; drainBuffersTask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Pacer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;写后操作除了在添加任务到缓冲区成功后会执行维护方法，添加失败（证明写入操作非常频繁）依然会尝试同步执行维护方法和发起异步维护，用于保证缓存中的任务能够被及时执行，使缓存中元素都处于「预期」状态中。接下来我们在看一下 &lt;code&gt;UpdateTask&lt;/code&gt; 更新任务的逻辑：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weightDifference&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;weightDifference &lt;span&gt;=&lt;/span&gt; weightDifference&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;node &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 写后过期和自定义过期逻辑&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 指定了驱逐策略&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 变更节点权重&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; oldWeightedSize &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldWeightedSize &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 如果是窗口区节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 更新窗口区权重&lt;/span&gt;
                    &lt;span&gt;setWindowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;windowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 节点权重超过最大权重限制，直接驱逐&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 节点权重比窗口区最大值小&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;windowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 窗口区包含该节点且该节点的权重大于窗口最大权重，则放到头节点&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;moveToFront&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果是试用区节点&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 节点权重比最大权重限制小&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 否则将该节点驱逐&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果是保护区节点&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProtected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 更新保护区权重&lt;/span&gt;
                    &lt;span&gt;setMainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 同样的逻辑&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新缓存权重大小&lt;/span&gt;
                &lt;span&gt;setWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新完成后超过最大权重限制执行驱逐操作&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 配置了访问后过期&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 更新访问频率&lt;/span&gt;
            &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 如果节点在窗口区，则将其移动到尾节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 在试用区的节点执行 reorderProbation 方法，可能会将该节点从试用区晋升到保护区&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorderProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 否则移动到保护区的尾结点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 更新命中量&lt;/span&gt;
            &lt;span&gt;setHitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了访问过期策略&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了自定义时间过期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;LinkedDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; deque&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果节点存在，将其移动到尾结点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;deque&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            deque&lt;span&gt;.&lt;/span&gt;&lt;span&gt;moveToBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reorderProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 检查试用区是否包含该节点，不包含则证明已经被移除，则不处理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 检查节点的权重是否超过保护区最大值&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;mainProtectedMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 如果超过，将该节点移动到，试用区，尾巴节点，保证超重的节点不会被移动到保护区&lt;/span&gt;
            &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 更新保护区权重大小&lt;/span&gt;
        &lt;span&gt;setMainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在试用区中移除该节点&lt;/span&gt;
        &lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在保护区尾节点中添加&lt;/span&gt;
        &lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 将该节点标记为保护区节点&lt;/span&gt;
        node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;makeMainProtected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;UpdateTask&lt;/code&gt; 修改任务负责变更权重值，并更新节点所在队列的顺序和访问频率，这里我们也能发现，这三个区域的队列采用了 &lt;strong&gt;LRU 算法&lt;/strong&gt;，一般情况下，&lt;strong&gt;最新被访问的元素会被移动到尾节点&lt;/strong&gt;。到现在，向有固定容量限制的缓存中调用 &lt;code&gt;put&lt;/code&gt; 方法添加元素的逻辑基本已经介绍完了，目前对 Caffeine 缓存的了解程度如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine-第 2 页.drawio.png" src="https://oscimg.oschina.net/oscnet//6bcc0e2b5adbb349b35e24c5cb7a2763.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;put&lt;/code&gt; 添加元素时会先直接添加到 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 中，并在 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加 &lt;code&gt;AddTask/UpdateTask&lt;/code&gt; 任务，&lt;code&gt;WriteBuffer&lt;/code&gt; 是一个 &lt;strong&gt;MPSC&lt;/strong&gt; 的缓冲区，添加成功后会有加锁的同步机制在默认的 &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; 线程池中提交 &lt;code&gt;PerformCleanupTask&lt;/code&gt; 任务，&lt;code&gt;PerformCleanupTask&lt;/code&gt; 任务的主要作用是执行 &lt;code&gt;maintenance&lt;/code&gt; 维护方法，该方法执行前需要先获取同步锁，单线程消费 &lt;code&gt;WriteBuffer&lt;/code&gt; 中的任务。执行 &lt;code&gt;AddTask&lt;/code&gt; 任务时会将元素先添加到窗口区，如果是 &lt;code&gt;UpdateTask&lt;/code&gt;，它会修改三个不同区域的双端队列，这些队列采用 LRU 算法，最新被访问的元素会被放在尾节点处，并且试用区的元素被访问后会被晋升到保护区尾节点，元素对应的访问频率也会在频率草图中更新，如果被添加的节点权重超过缓存最大权重会直接被驱逐。（目前维护方法中除了 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 方法外，其他步骤还未详细解释，之后会在后文中不断完善）&lt;/p&gt; 
&lt;hr&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18687082</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18687082</guid>
      <pubDate>Sun, 10 Aug 2025 08:01:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>智谱 AI 发布 GLM-4.5 技术报告</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;上月底，智谱 AI 正式发布&lt;a href="https://www.oschina.net/news/362861/glm-4-5"&gt;新一代旗舰模型 GLM-4.5&lt;/a&gt;，专为智能体应用打造的基础模型。官方称 「GLM-4.5 在包含推理、代码、智能体的综合能力达到开源 SOTA 水平，在真实代码智能体的人工对比评测中，实测国内最佳。」&lt;/p&gt; 
&lt;p&gt;GLM-4.5 不仅首次突破性地在单个模型中实现了推理、编码和智能体能力的原生融合，还在 12 项全球公认的硬核测试中取得了全球第三的综合成绩。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0729/095958_jsN7_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;今天 GLM-4.5 技术报告正式发布。报告不仅详述了 GLM-4.5 的预训练与后训练细节，还介绍了为其打造的开源强化学习（RL）框架 slime，它兼具灵活性、效率与可扩展性，可为模型高效 RL 训练保驾护航。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;em&gt;报告地址：https://arxiv.org/abs/2508.06471&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;智谱 AI 和清华大学研究团队采用了多阶段的训练策略，包括在 23T tokens 数据上进行预训练，以及结合领域特定数据的 「中训练」（Mid-training），最后通过专家模型迭代和强化学习进行 「后训练」（Post-training） 。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0811/155334_fWNH_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;模型的特点是与外部工具交互的 「智能体」（Agentic）能力、解决多步问题的 「推理」（Reasoning）能力，以及处理真实软件工程的 「编码」（Coding）能力，三中能力都很强，填补了没有能同时精通这三大核心领域的开源模型的空白。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365521</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365521</guid>
      <pubDate>Sun, 10 Aug 2025 07:53:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Stripe 报告：AI 经济火箭式增长，营收速度超越 SaaS 三倍</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;金融服务平台 Stripe 发布&lt;span&gt;最新&lt;/span&gt;分析报告，深入剖析其平台上排名前 100 位的 AI 企业的支付数据，揭示了人工智能经济正以前所未有的速度蓬勃发展，并在营收增长、全球市场拓展和商业模式创新方面呈现出显著趋势。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="238" src="https://oscimg.oschina.net/oscnet/up-9f3b8d22b76edac2a6c228349390ab5a922.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;作为 OpenAI、Anthropic、Midjourney 和 Cohere 等知名 AI 企业的金融服务伙伴，Stripe 对这场技术浪潮中 AI 初创公司从「用户需求」到「企业营收」的加速转化拥有独特洞察。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;报告指出，AI 经济的迅猛发展主要由三大关键趋势驱动：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;AI 初创公司实现营收里程碑的速度超越以往任何一代科技公司，包括 SaaS 企业;&lt;/li&gt; 
 &lt;li style="text-align:left"&gt;AI 公司在起步阶段即同步拓展国际市场，具备「天生全球化」的基因;&lt;/li&gt; 
 &lt;li style="text-align:left"&gt;以及层出不穷的创新商业模式和变现策略，加速了营收增长和市场采纳率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;营收增长进入「火箭」模式&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 企业达成关键营收里程碑的速度远超预期。Stripe 平台百强 AI 企业实现&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;100 万美元年化营收&lt;/strong&gt;的中位用时仅为&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;11.5 个月&lt;/strong&gt;，比营收增长最快的 SaaS 企业还快整整&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;4 个月&lt;/strong&gt;。在达到&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;500 万美元年化营收&lt;/strong&gt;时，AI 企业的中位用时为&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;24 个月&lt;/strong&gt;，而 SaaS 企业则需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;37 个月&lt;/strong&gt;，AI 公司在此项上快了近一年。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="466" src="https://oscimg.oschina.net/oscnet/up-1831765c86365a8eaca4a2e293203766e0c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尤其值得注意的是，&lt;strong&gt;2020-2023 年间成立的年轻 AI 公司&lt;/strong&gt;，其营收表现更是惊人:实现&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;100 万美元年化营收&lt;/strong&gt;仅需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;5 个月&lt;/strong&gt;，而&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;500 万美元年化营收&lt;/strong&gt;则需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;13 个月&lt;/strong&gt;。这比 2020 年前成立的 AI 公司分别缩短了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;11 个月&lt;/strong&gt;和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;28 个月&lt;/strong&gt;，平均所需时间减少了三分之二以上。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;强劲的市场需求是推动这一加速增长的根本原因：&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;2023 年，全球企业采用 AI 技术的比例为&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;55%&lt;/strong&gt;，而到 2024 年，这一比例已升至&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;72%&lt;/strong&gt;。&lt;/li&gt; 
 &lt;li&gt;生成式 AI 的企业采纳率在同期更是翻了一番。&lt;/li&gt; 
 &lt;li&gt;截至 2024 年 8 月，美国个人用户对 AI 的采用率，大致是个人电脑与互联网在发展同期的&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;两倍&lt;/strong&gt;。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;报告中不乏高速增长的案例：&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="238" src="https://oscimg.oschina.net/oscnet/up-1d7ef66917eabe1af1c3c171ccb3a21bb92.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;&lt;strong&gt;Bolt&lt;/strong&gt;:一个允许用户通过提示创建、运行、编辑和部署全栈网页及移动应用的平台，仅用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;2 个月&lt;/strong&gt;就达到了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;2000 万美元&lt;/strong&gt;的年度经常性收入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Lovable&lt;/strong&gt;:一个无需编写代码即可构建高质量软件的工具，仅用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;3 个月&lt;/strong&gt;就实现了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;1700 万美元&lt;/strong&gt;的年度经常性收入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Cursor&lt;/strong&gt;:一个 AI 驱动的代码助手，在&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;3 年内&lt;/strong&gt;实现了超过&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;1 亿美元&lt;/strong&gt;的年度经常性收入。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;天生全球化：AI 市场渗透无边界&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;与过去初创企业先深耕本地市场再逐步海外扩张的传统路径不同，AI 公司正打破常规，从成立之初便具备国际化基因。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;数据显示，Stripe 平台上的百强 AI 企业在上线&lt;span&gt;第一&lt;/span&gt;年内销售覆盖的国家数量是同期 SaaS 企业的近&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;两倍&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;（AI 企业平均覆盖&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;55 个国家&lt;/strong&gt;，SaaS 企业为&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;25 个&lt;/strong&gt;）。这一领先优势在随后四年中持续保持，例如上线第四年，AI 企业平均覆盖&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;104 个国家&lt;/strong&gt;，而 SaaS 企业为&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;57 个&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;全球各地对 AI 产品的需求呈现爆发式增长，其中一些增长最快的地区出人意料，如冰岛、爱沙尼亚、卢森堡、瑞士和新加坡，正迅速成为人均 AI 采购密度&lt;span&gt;最高&lt;/span&gt;的新兴热点国家和地区。例如，&lt;strong&gt;Midjourney&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;截至 2024 年的业务已覆盖全球&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;200 多个国家和地区&lt;/strong&gt;，超越了所有其他 Stripe 用户。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;商业应用版图：从通用到垂直，创新变现层出不穷&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前，大多数 AI 公司仍以行业通用工具为主。在 Stripe 平台上的百强 AI 企业中，有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;80 家&lt;/strong&gt;提供内容生成、聊天机器人或 AI 基础设施等横向应用，尚未聚焦于特定行业的深度场景。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;然而，报告也观察到一个明显的转变趋势:AI 企业正逐步转向面向特定行业、契合具体业务流程与客户需求的定制化解决方案，这与早期 SaaS 模式的发展路径如出一辙。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这些垂直化产品不再是对大型语言模型（LLM）的简单包装，而是深度嵌入行业工作流、数据体系与场景语境的「原生」智能工具。典型案例包括:&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;医疗保健领域：&lt;strong&gt;Abridge、Nabla 和 DeepScribe&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;房地产营销：&lt;strong&gt;Studeo&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;建筑行业：&lt;strong&gt;SketchPro&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;餐厅预订：&lt;strong&gt;Slang.ai&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;物业管理：&lt;strong&gt;HostAI&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;法律领域：&lt;strong&gt;Harvey 公司&lt;/strong&gt;的 AI 法律助手，仅在 2024 年一年间，营收就实现了&lt;strong&gt;四倍增长&lt;/strong&gt;，并被众多《财富》500 强企业采用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;随着 AI 行业的逐渐成熟，企业正在加速探索更加多元化的变现路径。除了传统的订阅模式，&lt;strong&gt;按用量计费&lt;/strong&gt;和&lt;strong&gt;按成果计费&lt;/strong&gt;模式正日益流行。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;按用量计费&lt;/strong&gt;:根据客户使用 AI 服务的时长、数据量或 API 调用次数进行收费。这种模式使价格与服务成本挂钩，并降低了客户的使用门槛。例如，协作分析平台&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Hex&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;借助 Stripe 实施了按用量计费模式，在上线后短短几个月内，累计处理了&lt;strong&gt;超过 5 亿次&lt;/strong&gt;使用量计费事件，运营效率显著提升。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;按成果计费&lt;/strong&gt;:客户仅在 AI 产生实际结果时才付费。这种模式尤其适合&lt;strong&gt;智能体工作流 （Agentic Workflows）&lt;/strong&gt;，大幅减少了客户的前期投入风险，鼓励了更多企业尝试使用 AI。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尽管用量和成果计费模式在收入预测性方面面临挑战，但越来越多的 AI 企业开始引入&lt;strong&gt;预付费模式&lt;/strong&gt;，以缓解现金流压力并提升收入可预测性，这对于初创早期的 AI 企业尤为适用。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;智能体商务崛起：AI 重塑交易方式&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 不仅在改变企业销售内容，更在重塑交易方式。&lt;strong&gt;AI 智能体&lt;/strong&gt;正逐步承担传统人工任务，例如产品调研、下单采购、订阅管理等，并以自主化方式执行。例如，&lt;strong&gt;ElevenLabs&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;通过语音自动化 AI 智能体处理订阅与退款事务；&lt;strong&gt;Perplexity 和 Payman&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;则实现了 AI 驱动的无缝支付。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这场转变将深刻改变企业与客户之间的互动方式、交易流程乃至底层商业逻辑。它不仅需要更新商业与定价模式（如按用量计费、按成果付费或按价值定价），还要求企业配备支持安全自主交易的技术基础设施，以匹配 AI 智能体在财务决策中日益重要的角色。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;企业普遍将智能体商务视为未来发展方向。Stripe&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;最新&lt;/span&gt;调研显示，&lt;strong&gt;53%&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的全球企业高管表示正在为智能体商务做准备，而当被问及「未来两年内智能体商务的重要性」时，更有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;63%&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的受访者给出了 7 分或以上的评价（满分 10 分）。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前已有数以千计的开发者开始集成围绕 AI 智能体构建的支付工具，Stripe 的智能体开发工具包每周下载量达数千次，仅 2024 年就有数百家智能体初创公司在 Stripe 上启动运营，预计 2025 年这一数字将进一步攀升。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365520</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365520</guid>
      <pubDate>Sun, 10 Aug 2025 07:50:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>国内首个隧道与地下空间领域垂直大模型发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;由中国中铁隧道局隧道掘进机及智能运维全国重点实验室研发，我国首个隧道与地下空间领域垂直大模型已&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FY7GuioIiJFqrDrYiGqNDJA" target="_blank"&gt;发布&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;据中国中铁隧道局隧道掘进机及智能运维全国重点实验室研发团队负责人介绍，该模型依托盾构/TBM 工程大数据中心 773 条工程线路，1200 亿条工程建造数据，构建了通用大模型调度中小模型驱动的垂直领域大模型技术体系，形成了贯穿隧道与地下空间领域全生命周期场景+AI 的数智互馈赋能技术体系新形态；研发了人机交互深度求索的隧道侠 AI 助手，搭建行业科普、专业问答、行业标准、文本翻译、专项方案和施组辅助编制功能新引擎；突破大模型对齐与微调技术，研发系列知识与数据场景靶向驱动的中小模型，形成隧道设计 BIM 可视化、隧道施工评估、隧道装备选型、隧道运维感知与解译等多个应用数智决策新范式。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="333" src="https://oscimg.oschina.net/oscnet/up-b97d315bfa6693ce8e4c4543c0aa433f3b4.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，该模型已在高原铁路隧道、崇太长江隧道、深江铁路珠江口隧道等工程完成验证，实现隧道建造安全、优质、高效、绿色，推动行业数智化转型升级。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365507</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365507</guid>
      <pubDate>Sun, 10 Aug 2025 07:38:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Debian 14 将改进对中国龙芯 CPU 架构 LoongArch64 的支持</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&amp;nbsp;Debian 13 「trixie」稳定版已发布，同时 Debian 团队&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.debian.org%2Fdebian-devel-announce%2F2025%2F08%2Fmsg00002.html" target="_blank"&gt;宣布&lt;/a&gt;将在计划于 2027 年发布的 Debian 14（代号 「Forky」） 中，显著改进对中国龙芯 CPU 架构 LoongArch64（简称 Loong64）的支持。&lt;/p&gt; 
&lt;p&gt;按照规划，Loong64 的架构资格认证将在 Forky 开发周期后期进行，但相关软件包将很快可以提交到 Forky 版本中。&lt;/p&gt; 
&lt;p&gt;值得关注的要点：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;官方支持推进&lt;/strong&gt;：LoongArch64 目前作为非官方移植架构已存在两年，Debian 14 将在此基础上进一步推动其成为官方支持的架构，类似于 Debian 13 中对 RISC-V 的官方支持。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;开发节奏&lt;/strong&gt;：Debian 14 的 「unstable」 分支即将开放，开发者和维护者可开始提交 LoongArch64 相关软件包。架构资格认证将在开发周期后期完成。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;生态建设&lt;/strong&gt;：目前已有约 200 个软件包完成初步移植，重点在于实现 LoongArch64 架构的「自我托管」能力，即在真实龙芯硬件上独立完成 Debian 软件包的构建。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="1358" src="https://static.oschina.net/uploads/space/2025/0811/153832_qPqH_2720166.png" width="1312" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;LoongArch 是龙芯中科自主研发的 CPU 指令集架构，已在多款处理器（如 3A5000、3A6000）中应用。Debian 对其支持的加强，标志着国产 CPU 在国际主流开源操作系统中的适配进程迈出重要一步，对推动自主可控计算生态具有积极意义。&lt;/p&gt; 
&lt;p&gt;相关链接&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;https://wiki.debian.org/LoongArch&lt;/li&gt; 
 &lt;li&gt;https://wiki.debian.org/Ports/loong64&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365506/debian-14-loong64-loongarch</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365506/debian-14-loong64-loongarch</guid>
      <pubDate>Sun, 10 Aug 2025 07:37:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>守护力向新 | deepin 25 磐石：权限「新」固，核心防护！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//9aa0dd269d1f1dc956527ec4581b7c84.jpg" width="900" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;在数字化办公与开发场景中，系统稳定性与安全性已成为用户核心诉求，基于此 deepin 25 推出磐石系统───以 "只读防护、快照管理、无忧还原" 三大硬核技术为核心，构建从内核层到应用层的全维度稳定性防护体系，致力于为用户带来 「磐石般」 的系统保障。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;本文，我们将为大家深入剖析操作系统常见的稳定性痛点，并详细解读 deepin 25 磐石系统如何依托创新技术，从根源上筑牢系统运行的可靠根基。&lt;/span&gt;&lt;/p&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;一、操作系统常见稳定性问题&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;深入理解系统不稳定的根源，是构建有效防护的前提。以下是几种典型场景：&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;系统核心文件损坏&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表现：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;系统无法启动、服务异常终止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;用户误操作：如通过 sudo rm 命令误删 /usr 等关键目录文件（典型场景：开发者执行高危命令、普通用户误删系统文件）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;恶意软件攻击：病毒、勒索软件篡改或删除系统核心文件（如 /lib 下的动态链接库）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;应用越权修改：部分应用因权限配置错误，尝试写入软件包安装目录（如 /usr/bin），导致文件冲突或覆盖。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;系统更新失败&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表现&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：更新后系统卡在启动界面、功能模块异常、服务无法启动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;部分更新中断：传统系统较为脆弱，若中途断电或其他错误，易导致部分文件未更新完成，系统处于「不完全更新」 状态。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;配置错误与软件兼容性问题&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表现&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：软件闪退、功能异常、系统资源占用过高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;非标准安装包影响：手动安装 .run/.bundle 等非 deb 格式软件时，强制写入系统核心目录，破坏文件一致性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;公共场景下的系统污染&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表现&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：共享设备被安装恶意软件、用户设置混乱、隐私数据残留。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;多用户操作无隔离：公共电脑缺乏有效还原机制，前一用户的操作（如恶意软件安装）影响后续使用者。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;二、磐石系统三大核心技术&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;针对上述核心稳定性挑战，deepin 25 磐石系统提供了一套完整的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;只读防护：核心目录物理级锁定&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;磐石系统将 /usr、/bin、/lib 等关键系统目录设置为只读挂载，通过内核级文件系统权限控制，从底层杜绝恶意软件篡改与用户误操作风险。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;技术实现：采用分层文件系统，系统核心文件的变动处于可控状态，只有授权的行为才能改变。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;稳定价值：解决因误删误改系统核心文件导致的系统崩溃问题。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快照管理：秒级回溯系统任意状态&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;基于 OSTree 的秒级快照技术，实现系统状态的实时备份与快速恢复：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;自动触发：系统更新前默认创建快照，系统永远保留当前状态与上一个系统备份，更新成功后自动覆盖掉历史备份，避免磁盘空间被过度占用；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;精准恢复：若更新失败，系统重启后会自动恢复到更新前状态，且用户数据（/home）不受影响；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;轻量化存储：多快照之间相同文件复用，磁盘空间占用少。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;无忧还原：公共场景的「自净引擎」&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;针对公用电脑、共享终端等场景，无忧还原功能实现「重启即清零」：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;基于 OverlayFS 技术方案，将用户的修改写入临时层，重启后自动丢弃&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;可配置白名单目录（如 /etc/ssh），重启后不丢失数据，从而保留系统必要配置或者部分用户数据；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;性能损失很小，用户使用基本无感知&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;三、安装 deepin，即刻体验&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;磐石系统为各类用户提供开箱即用的稳定保障与灵活控制。对于普通用户来说，deepin25 默认开启只读保护，开机即可享受系统稳定性保护。提供图形化的备份恢复机制，使用简单便捷。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;为满足开发者和社区爱好者深度调试系统的需求，&lt;/span&gt;&lt;span&gt;&lt;span&gt;磐石系统提供了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快捷开启/关闭只读保护&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;的方法，只需简单一条命令即可关闭只读保护。&lt;/span&gt;&lt;/span&gt;&lt;s&gt;&lt;s&gt;&lt;s&gt;关闭后也不影响系统正常使用&lt;/s&gt;&lt;/s&gt;&lt;/s&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 这一设计让您能在系统稳定性和操作自由度之间，根据实际需求灵活把握「黄金平衡」&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快速上手指南&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;安装部署：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;前往 deepin 官网下载 deepin 25 正式版（支持 AMD64/ARM64/LoongArch 架构）。若您是首次安装 deepin 操作系统推荐采用全盘安装，系统盘与数据盘独立分区。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;应用安装：兼容 apt/dpkg 命令，可通过该命令安装/管理 deb 应用。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;关闭/开启只读保护：&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;关闭只读保护：deepin-immutable-writable enable&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;开启只读保护：deepin-immutable-writable disable&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;系统更新：&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;系统更新兼容 apt 命令：apt dist-upgrade&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;以上便是 deepin 25 磐石系统在稳定性与安全性方面的全面解析，从核心文件的只读防护到系统状态的秒级快照回溯，再到公共场景下的无忧还原机制，每一项技术都精准直击操作系统的常见痛点。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;无论你是追求零门槛稳定的普通用户，还是需要灵活开发环境的技术爱好者，都能获得坚实的系统级守护。欢迎前往 deepin 社区论坛分享你的使用感受，你的每一条建议都是我们持续优化的动力！&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365505</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365505</guid>
      <pubDate>Sun, 10 Aug 2025 07:35:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
  </channel>
</rss>
