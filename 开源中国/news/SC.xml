<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 02 Sep 2025 07:47:28 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Firefox 将原生支持 MKV 视频格式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwindowsreport.com%2Fmozilla-firefox-is-officially-getting-mkv-video-support%2F" target="_blank"&gt;据报道&lt;/a&gt;，Firefox 浏览器即将原生支持 &lt;code&gt;.mkv&lt;/code&gt;视频文件播放，用户无需再依赖插件或手动转换格式。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4ae5363247ae1619e30c87b03d4f17b9b25.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Mozilla&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1422891" target="_blank"&gt; 已指派工程师&lt;/a&gt;推动这一功能的开发，预计将按照以下阶段有序推进：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;Nightly 版本做初步测试，针对最常见的音视频组合，例如 H.264 编码的视频 + AAC 音频进行优先支持。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;后期将扩大支持范围，加入 VP9、AV1 等视频编码，以及 Opus 或 FLAC 等音频格式。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在稳定性与兼容性通过全面检测后，会推广至正式版本的 Firefox 用户。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/152017_iqZR_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此前，Firefox 打开 MKV 文件时常常失败或直接触发下载，这在 Windows 10 和 11 已原生支持 MKV 的情况下，显得尤为不便。新功能上线后，Firefox 的多媒体体验将与主流浏览器保持一致。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369866/mozilla-firefox-is-officially-getting-mkv-video-support</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369866/mozilla-firefox-is-officially-getting-mkv-video-support</guid>
      <pubDate>Tue, 02 Sep 2025 07:23:31 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>腾讯开源具备原生 3D 重建能力的超长程世界模型：HunyuanWorld-Voyager</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;腾讯近日正式发布了 HunyuanWorld-Voyager，这是一种创新的视频扩散框架，旨在通过单张输入图像生成具备世界一致性的 3D 点云，支持用户按自定义的相机路径进行沉浸式探索。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="327" src="https://oscimg.oschina.net/oscnet/up-56c2135778b8058ed623697954e8a4f3027.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官方表示，这全球首个具备原生 3D 重建功能的超远距离世界模型，重新定义 AI 驱动的 VR、游戏和仿真空间智能。此模型不仅能够生成精确对齐的深度信息和 RGB 视频，还能够在不进行后处理的情况下，直接用于高质量的三维重建。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;直接 3D 输出：无需 COLMAP 等工具即可将点云视频导出为 3D 格式，实现即时 3D 应用。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;创新的 3D 内存：引入可扩展的世界缓存机制，确保任何摄像机轨迹的几何一致性。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;顶级性能：在斯坦福 WorldScore 测试中排名第一，在视频生成和 3D 重建基准测试中表现出色&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;HunyuanWorld-Voyager 的架构包含两个关键组件。首先是 「世界一致的视频扩散」，该组件提出了一种统一的架构，可以基于已有的世界观测，同时生成准确对齐的 RGB 视频和深度视频序列，从而确保全局场景的一致性。其次是 「长距离世界探索」，它采用了一种高效的世界缓存机制，结合点云剔除和自回归推理能力，支持迭代场景扩展，并通过上下文感知的一致性技术实现平滑的视频采样。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;为了训练 HunyuanWorld-Voyager 模型，研究团队构建了一套可扩展的数据构建引擎。这一自动化视频重建流水线能够对任意输入视频自动估计相机位姿和度量深度，因此无需依赖人工标注，从而实现大规模、多样化训练数据的构建。基于此流水线，HunyuanWorld-Voyager 整合了真实世界采集和虚幻引擎渲染的视频资源，构建了一个包含超过 10 万个视频片段的大规模数据集。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在实验评估中，HunyuanWorld-Voyager 在视频生成质量方面表现出色。与四种开源的相机可控视频生成方法进行了对比，结果显示该模型在 PSNR、SSIM 和 LPIPS 等指标上均优于其他模型，证明了其卓越的视频生成质量。同时，在场景重建方面，HunyuanWorld-Voyager 的生成视频在几何一致性上也显现出更好的效果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，HunyuanWorld-Voyager 在 WorldScore 静态基准测试中获得了最高分，证明了其在相机运动控制和空间一致性方面的优越性。这一成果不仅展示了混元世界模型的潜力，还为未来的 3D 场景生成技术开辟了新路径。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369863</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369863</guid>
      <pubDate>Tue, 02 Sep 2025 07:15:31 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>腾讯优图实验室正式开源智能体框架 Youtu-Agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;9 月 2 日，腾讯优图实验室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW5LFBLCV3qZG0wxTA9Ob-w" target="_blank"&gt;宣布&lt;/a&gt;正式开源智能体框架 Youtu-Agent。该框架以极简设计和高性能表现为核心，旨在为研究人员和开发者提供高效、易用、可复现的智能体开发工具。&lt;/p&gt; 
&lt;p&gt;据介绍，Youtu-Agent 面向实际场景的开源应用框架，能够覆盖文件管理、数据分析、学术研究与广域信息综述等多个方向应用。目前，Youtu-Agent 开源框架已为腾讯云多个产品业务提供支持。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Youtu-Agent 的核心亮点在于，它不需要额外训练模型，也不依赖海外闭源大模型 API，就能在真实场景中展现出优异的效果，比较好地兼顾了科研和应用双重需求。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;验证性能&lt;/strong&gt;：在 WebWalkerQA 上达到 71.47% 的 pass@1，在 GAIA（纯文本子集）上达到 72.8% 的 pass@1，纯粹使用&lt;code&gt;DeepSeek-V3&lt;/code&gt;系列模型（不使用 Claude 或 GPT），建立了强大的开源起点。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;开源友好且成本敏感&lt;/strong&gt;：针对可访问、低成本部署进行了优化，不依赖封闭模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;实际用例&lt;/strong&gt;：开箱即用地支持 CSV 分析、文献综述、个人文件整理以及播客和视频生成等任务。（即将推出）&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;灵活的架构&lt;/strong&gt;：基于 openai-agents 构建，可兼容各种模型 API（从&lt;code&gt;DeepSeek&lt;/code&gt;到&lt;code&gt;gpt-oss&lt;/code&gt;）、工具集成和框架实现。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;自动化与简洁性&lt;/strong&gt;：基于 YAML 的配置、自动智能体生成和简化的设置减少了手动开销。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在性能表现上，Youtu-Agent 已在多个智能体挑战性基准测试中取得领先成绩。例如，&lt;strong&gt;在 WebWalkerQA 基准中，基于 DeepSeek-V3.1 的运行结果达到了 71.47% 的准确率，刷新了开源模型的最新纪录&lt;/strong&gt;；&lt;/p&gt; 
&lt;p&gt;&lt;img height="603" src="https://static.oschina.net/uploads/space/2025/0902/151154_CKYV_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;框架设计方面，Youtu-Agent 完全拥抱开源生态，适配多种可访问的部署环境；其架构灵活，兼容包括 DeepSeek、gpt-oss 在内的多类模型 API 与工具。&lt;/p&gt; 
&lt;p&gt;&lt;img height="738" src="https://static.oschina.net/uploads/space/2025/0902/151229_GBNE_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;开源地址：&lt;em&gt;https://github.com/TencentCloudADP/Youtu-agent&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369860</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369860</guid>
      <pubDate>Tue, 02 Sep 2025 07:13:31 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Cloudflare 推出实时语音 AI 平台：Realtime Agents</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cloudflare 宣布推出&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.cloudflare.com%2Fcloudflare-realtime-voice-ai%2F" target="_blank"&gt;实时语音 AI 平台&lt;/a&gt;（Cloudflare Realtime Agents），正式进军低延迟对话式 AI 领域。该平台依托 Cloudflare 全球 330 多个节点的边缘网络，为开发者提供构建语音交互应用的完整解决方案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ae6ab80f3dac0b047d5a26124ce0a669d2d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;新平台的核心组件包括 Realtime Agents（语音 AI 管道编排运行时）、WebRTC 音频传输支持、Workers AI 的 WebSocket 实时推理，以及 Deepgram 的语音识别/合成模型。通过这些功能，开发者可快速搭建自然流畅的语音代理应用。&lt;/p&gt; 
&lt;p&gt;下面的示例代码展示了如何创建一个继承自 &lt;code&gt;RealtimeAgent&lt;/code&gt; 的 JavaScript 类，以进行以下操作：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;创建 WebRTC 会话&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;管道编排（如：Deepgram STT → 自定义文本处理 Handler → ElevenLabs TTS）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持会议参与者加入/离开的事件处理&lt;br&gt; 这让开发者几乎不需管理底层基础设施，就可快速构建个性化语音代理应用。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code class="language-javascript"&gt;export class MyAgent extends RealtimeAgent&amp;lt;Env&amp;gt; {
constructor(ctx: DurableObjectState, env: Env) {
super(ctx, env);
}

async init(agentId: string ,meetingId: string, authToken: string, workerUrl: string, accountId: string, apiToken: string) {
// Construct your text processor for generating responses to text
const textHandler = new MyTextHandler(this.env);
// Construct a Meeting object to join the RTK meeting
const transport = new RealtimeKitTransport(meetingId, authToken, [
{
media_kind: 'audio',
stream_kind: 'microphone',
},
]);
const { meeting } = transport;

// Construct a pipeline to take in meeting audio, transcribe it using
// Deepgram, and pass our generated responses through ElevenLabs to
// be spoken in the meeting
await this.initPipeline(
[transport, new DeepgramSTT(this.env.DEEPGRAM_API_KEY), textHandler, new ElevenLabsTTS(this.env.ELEVENLABS_API_KEY), transport],
agentId,
workerUrl,
accountId,
apiToken,
);

// The RTK meeting object is accessible to us, so we can register handlers
// on various events like participant joins/leaves, chat, etc.
// This is optional
meeting.participants.joined.on('participantJoined', (participant) =&amp;gt; {
textHandler.speak(`Participant Joined ${participant.name}`);
});
meeting.participants.joined.on('participantLeft', (participant) =&amp;gt; {
textHandler.speak(`Participant Left ${participant.name}`);
});

// Make sure to actually join the meeting after registering all handlers
await meeting.rtkMeeting.join();
}

async deinit() {
// Add any other cleanup logic required
await this.deinitPipeline();
}
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Cloudflare 指出，要让语音交互达到「自然对话」的体验，总延迟需低于 800 毫秒，而其分布式边缘架构正好能满足这一苛刻要求。平台同时兼容多种 AI 模型和第三方服务，支持高度可组合的语音处理管道。&lt;/p&gt; 
&lt;p&gt;目前，Cloudflare Realtime Agents 已开放 Beta 公测，开发者可免费试用并基于该平台开发新一代实时语音 AI 应用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369855/cloudflare-realtime-voice-ai</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369855/cloudflare-realtime-voice-ai</guid>
      <pubDate>Tue, 02 Sep 2025 06:49:31 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Cloudflare 扛下了峰值达 11.5 Tbps 的超大流量 DDoS 攻击</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cloudflare &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCloudflare%2Fstatus%2F1962559687368593552" target="_blank"&gt;宣布&lt;/a&gt;其自动化防御系统在过去几周里成功拦截了数百次超大规模 DDoS 攻击，其中最大一次攻击的峰值达到 11.5 Tbps（51 亿数据包/秒）。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1448" src="https://static.oschina.net/uploads/space/2025/0902/142809_8xYe_2720166.png" width="1280" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据介绍，此次攻击类型为 UDP Flood（UDP 泛洪）攻击，这一峰值刷新了 Cloudflare 自己在 2025 年 5 月创下的 7.3 Tbps 纪录。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cloudflare.com%2Fzh-cn%2Flearning%2Fddos%2Fudp-flood-ddos-attack%2F" target="_blank"&gt;UDP 洪水&lt;/a&gt;是一种拒绝服务攻击，攻击者将大量用户数据报协议 (UDP) 数据包发送到目标服务器，旨在让该设备的处理和响应能力无力承担。由于 UDP 洪水攻击，保护目标服务器的防火墙也可能不堪重负，导致对正常流量拒绝服务。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Cloudflare 表示将在即将发布的技术报告中提供更详细的攻击与防御分析。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369850</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369850</guid>
      <pubDate>Tue, 02 Sep 2025 06:30:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>百度网盘基于 Flink 的实时计算实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;01 概览&lt;/h1&gt; 
&lt;p&gt;随着数字化转型的来临，企业对于数据服务的实时化需求日益增长，在大规模数据和复杂场景的情况下，Flink 在实时计算数据链路中扮演着极为重要的角色，本文介绍了网盘如何通过 Flink 构建实时计算引擎，从而提供高性能、低延迟、稳定的实时计算能力。&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;02 百度网盘实时计算演进&lt;/h1&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.1 百度网盘实时计算演进历程&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ff0daf696dfc0e69e28e45f204abba37d2d.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△百度网盘实时计算演进&lt;/p&gt; 
&lt;p&gt;在 2020 年，网盘主要通过 Spark Streaming 和 Spark Structured Streaming 来用于特定场景的支持，主要是在数据同步场景、实时清洗方面的应用。&lt;/p&gt; 
&lt;p&gt;为了解决 Spark Streaming 存在的监控告警薄弱、接入成本高、时效性低等问题，网盘于 2023 年初首次引入 Flink 实时计算引擎，并基于百度内部 StreamCompute 平台快速建设集指标监控、告警、任务生命周期管理能力；经过调研测试我们发现 Flink 任务从 0 到 1 接入成本高、开发门槛高，因此，我们开始调研实时计算引擎的解决方案，目标是降低开发门槛、配置化任务接入，最终建设网盘内部的实时计算引擎 Tiangong 来为业务提供更好的支持。&lt;/p&gt; 
&lt;p&gt;截止至今，Tiangong 计算引擎目前已在数据团队、反作弊团队、用户增长等场景广泛应用,并支持数百万亿的大流量场景。未来我们也计划将基于 Tiangong 建设网盘一体化实时计算平台，从而赋能网盘内部各个业务线实时计算能力建设。&lt;/p&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.2 为什么选择 Flink&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;网盘实时计算引擎从 Spark Streaming 和 Spark Structured Streaming 演进而来，为什么放弃 Spark 体系选择 Flink 主要从以下几个方面出发：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1b64f0cfcd52025073f9ddb65a663c421ca.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a4a6791fde81a3784568fd35cbec23678b0.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-51f283dc22dd7fa64e59af474f7ba8763c6.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;从&lt;strong&gt;&lt;strong&gt;百度内部实时计算 RoadMap 和状态管理、流批一体、监控告警、任务管理、生态体系&lt;/strong&gt;&lt;/strong&gt;等各方面我们选择基于 Flink 建设网盘内部的实时计算平台。&lt;/p&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.3 实时计算引擎&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_6"&gt;&lt;/span&gt; 
&lt;h3&gt;2.3.1 实时计算引擎接入现状&lt;/h3&gt; 
&lt;p&gt;目前，百度网盘的 Tiangong 计算引擎已接入&lt;strong&gt;&lt;strong&gt;17+应用场景&lt;/strong&gt;&lt;/strong&gt;，高峰时作业处理的吞吐量达到&lt;strong&gt;&lt;strong&gt;千万/s&lt;/strong&gt;&lt;/strong&gt;，而机器规模也已经达到了&lt;strong&gt;&lt;strong&gt;1500 台，资源 5800CU&lt;/strong&gt;&lt;/strong&gt;，并且已经覆盖用商策略、反作弊、主端一刻用增实时投放等多个场景。&lt;/p&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;2.3.2 Flink Tiangong 引擎架构&lt;/h3&gt; 
&lt;p&gt;如下图所示的是网盘 Tiangong 实时计算引擎的架构。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;最下层为&lt;strong&gt;&lt;strong&gt;Runtime 层&lt;/strong&gt;&lt;/strong&gt;，负责 Tiangong 计算任务的部署方式，目前支持 StreamCompute、Kubernetes、Yarn、Local 等方式；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心能力包括&lt;strong&gt;&lt;strong&gt;Source 组件&lt;/strong&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;Sink 组件&lt;/strong&gt;&lt;/strong&gt;以及&lt;strong&gt;&lt;strong&gt;数据转换引擎&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Source 组件：支持 Db、Message Queue、BigData 组件、自定义 Source 等多个异构数据源；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Sink 组件：支持 Db、Message Queue、BigData 组件、自定义 Sink 等多个异构数据目的地；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据转换引擎：支持流批一体、自定义配置化数据清洗、精准一次数据处理、失败容错、IOC 容器化管理、自定义 SQL 拓扑、灵活监控告警等能力；&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-74b109ea6e0d5ddbebe0bd962c9af807613.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ Tiangong 计算引擎&lt;/p&gt; 
&lt;p&gt;从&lt;strong&gt;&lt;strong&gt;功能层面来看&lt;/strong&gt;&lt;/strong&gt;，Tiangong 实时计算引擎主要包括作业管理和资源管理。其中，作业部分包括作业配置、作业上线以及作业生命周期管理三个方面的功能。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;&lt;strong&gt;作业配置&lt;/strong&gt;&lt;/strong&gt;方面，则包括运行环境配置、source 配置、sink 配置、清洗逻辑配置以及作业拓扑结构设置；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"作业名",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"env": {运行环境配置},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sources": [source 端配置],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"udfs": [用户定义函数],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"views": [清洗逻辑],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"coreSql": [核心写入逻辑],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sinks": [sink 端配置],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"customTopology": {自定义作业运行拓扑}
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;&lt;strong&gt;作业发布&lt;/strong&gt;&lt;/strong&gt;方面，则包括作业启动、取消以及删除等；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c2677e04e1a592c6d5a72bb8e32d89797a6.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;作业状态&lt;/strong&gt;则包括自定义规则告警、监控大盘等；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-948683468fce0ec01ef0607dbfb5b63ca3d.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ 自定义规则告警&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c528ec4707296e887eba9063ab6d6a100b8.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ 监控大盘&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;资源管理&lt;/strong&gt;方面，利用 StreamCompute 平台能力支持 Flink 集群动态扩缩容能力与灰度发布能力；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.4 业务场景实践&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;前面提到实时计算引擎演进过程和实时计算引擎对比，可以看出网盘实时计算引擎更多地会关注在&lt;strong&gt;&lt;strong&gt;易用性、稳定性和监控告警体系&lt;/strong&gt;&lt;/strong&gt;等方面，具体体现的应用场景主要涉及服务端日志、埋点日志、DB Binlog 等场景的实时清洗计算。&lt;/p&gt; 
&lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
&lt;h3&gt;2.4.1 网盘实时商业 BI 中心&lt;/h3&gt; 
&lt;p&gt;网盘现阶段缺乏商业收入数据实时分析与商业策略实验实时评估的能力，导致商业策略 AB 实验推全链路往往需要经过周粒度才能完成，建设一套适用于网盘的实时商业 BI 中心有益于加快策略实验迭代与实时商业流水波动分析，助力网盘整体收入增长；&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b78bb1842f1545d8beac3a5569684f6cc8e.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;如上图，通过将收银台行为、商业订单、策略实验埋点数据秒粒度接入至实时数仓 Palo 中后，配合数据可视化平台 Sugar 建设商业实时 BI 中心，以此来助力商业策略、商业 PM 等各个角色快速完成 AB 实验快速推全，&lt;strong&gt;&lt;strong&gt;将天粒度实验收益评估机制优化至分钟粒度，整体实验推全链路由周粒度优化至天粒度；&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-12f751e8070eaf1039286a6aeabcbe754c7.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.1.1 Tiangong 配置化接入&lt;/h4&gt; 
&lt;p&gt;下述案例为 Tiangong 引擎配置化接入商业订单实时流：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;strong&gt;实时流数据源配置&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;"sourceType":&amp;nbsp;"bp_source",
&amp;nbsp;&amp;nbsp;"deserializerType":&amp;nbsp;"STRING",
&amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"parallelism":&amp;nbsp;20,
&amp;nbsp; &amp;nbsp;&amp;nbsp;"operatorName":&amp;nbsp;"xietong_strategy_businessorder_fr_bp_source",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"metaHost":&amp;nbsp;"host:ip",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"cluster":&amp;nbsp;"demo-cluster",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"username":&amp;nbsp;"username",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"password":&amp;nbsp;"password",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"pipeletName":&amp;nbsp;"demo-pipelet-name",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"pipeletNum":&amp;nbsp;"20",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"startingOffset":&amp;nbsp;{},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"startPoint":&amp;nbsp;"LATEST",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"endOffset":&amp;nbsp;{},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"bpWebServiceAddress":&amp;nbsp;"service_address"
&amp;nbsp;&amp;nbsp;}


&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;strong&gt;核心处理逻辑配置&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"netdisk_membership_order_deatils_bp2doris",
&amp;nbsp;&amp;nbsp;"env": {
&amp;nbsp; &amp;nbsp;&amp;nbsp;"streamConfigName":&amp;nbsp;"20p_ck_3s_10fail_env", &amp;nbsp;## 环境配置，主要配置 Checkpoint 间隔和并行度，根据数据量定义，一般为上游消息队列分区倍数
&amp;nbsp; &amp;nbsp;&amp;nbsp;"tableConfig": {}
&amp;nbsp; },
&amp;nbsp;&amp;nbsp;"sources": [
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"configType":&amp;nbsp;"CONFIG",
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceTableName":"membership_order_binlog",&amp;nbsp;## 数据源配置，bigpipei 订单实时流
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;"prod/netdisk_membership_order_bp_source"
&amp;nbsp; &amp;nbsp; },
&amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"configType":&amp;nbsp;"SQL",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"sourceConfig":&amp;nbsp;"CREATE TABLE ods_order_info_rt &amp;nbsp;## 写入目的地配置，palo 写入表
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; order_no &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; string,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; user_id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; dev_uid &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; app_id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client_channel &amp;nbsp; tinyint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pay_channel &amp;nbsp; &amp;nbsp; &amp;nbsp;tinyint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; product_id &amp;nbsp; &amp;nbsp; &amp;nbsp; string,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ....&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) WITH (
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'connector' = 'doris',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'fenodes' = 'host:ip',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'table.identifier' = 'dbName:tableName',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'username' = 'username',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'password' = 'password',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.properties.format' = 'json',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.properties.read_json_by_line' = 'true',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.label-prefix' = 'label-prefix',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.enable-2pc'='true',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.parallelism' = '1'
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;)"
&amp;nbsp; &amp;nbsp; &amp;nbsp;}
&amp;nbsp; ],
&amp;nbsp;&amp;nbsp;"views": [
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"name":&amp;nbsp;"binlog_filter_view", &amp;nbsp;## 核心数据处理逻辑，纯 SQL 接入
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sql":&amp;nbsp;"select CAST(JSON_VALUE(new_values, '$.id') as bigint) &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; as id,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;JSON_VALUE(new_values, '$.business_no') &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;as business_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;JSON_VALUE(new_values, '$.order_no') &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; as order_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;UNIX_TIMESTAMP() &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;as write_timestamp,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; FROM membership_order_binlog,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;LATERAL TABLE(BINLOG_NEWVALUES_FILTER(f0))"&amp;nbsp;## 系统内置 Binlog 清洗 TableFunction
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; ],
&amp;nbsp;&amp;nbsp;"coreSql":&amp;nbsp;"insert into ods_order_info_rt select id, ## 写入下游 palo 表，写入间隔为 Checkpoint 间隔，上述配置为 3 秒，每 3 秒写一批
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; business_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; order_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; user_id,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; write_timestamp from binlog_filter_view"
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;2.4.1.2 可视化监控体系&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Flink 作业 UI 监控&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69cd7c139cb26ff6c4cb22aa26d0a51dac2.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Grafana 监控大盘&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c382bbdb77491e740a37f537c09928bfcee.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;实时任务监控配置&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ae14913e3a48ac003c019e0c77bc2c31803.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c1c8546f688a4e07ed3899c27c96124567e.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;2.4.2 用户商业策略实时特征&lt;/h3&gt; 
&lt;p&gt;基于商业策略实时核心行为相关特征依赖场景，结合核心行为以及用户付费埋点行为数据建设从 0 点实时累计特征与基于滚动窗口的近 X 分钟实时特征有助力策略侧对用户刚需需求的感知，并结合用户刚需行为个性化出价以此促进整体商业收入。&lt;/p&gt; 
&lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.2.1 核心方案&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bc054f9d461927471f7fe77334ba9aedef2.jpg" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如上图，方案二主要将数据流拆为三块，如流数据拼接、热点文件计算、消费行为统计；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;流数据拼接：利用 Tiangong 计算引擎，通过 Flink SQL+行为清洗 UDF 函数，将各类行为数据打平为统一格式，并通过 union all 进行聚合，过滤异常数据后行为行为视图，数据流式产出。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;热点文件计算：实时将各个 file_md5 的消费次数存储 Flink Map 状态中，并根据离线分析得到的热点文件消费阈值判断热点文件，将热点文件流式写入 Bigpipe 与 Palo 中，数据流式产出，最优可做到毫秒级；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;消费行为次数计算：根据热点文件数据流关联用户消费行为，实时对用户消费的文件进行热点/普通归一化处理，后续将每个用户消费不同行为类型的热点/普调次数写入 Flink Map 状态中，累加计算从 0 点至今的文件消费次数，实时写入 Doris 和 Palo 中，最优可做到秒级；&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_14"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.2.2 技术难点&lt;/h4&gt; 
&lt;span id="OSC_h4_15"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;（1）大状态问题&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;问题引入&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;热点文件和用户消费文件次数的计算，都涉及到数据累计的问题，如果将数据存储在共享存储 (例如 Redis/Table) 这类 kv 存储中，每条数据或每个窗口的数据都需要先查一下上次的计算结果，累加后再写入共享存储中，这从而导致每次计算多一次网络读 IO 操作，故利用 Flink 状态机制，将热点文件和用户消费次数存储在 Flink 状态中，每次判断都在 TaskManger 本地或者内存中，不涉及到网络 IO 操作，故性能更好。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据都存入 Flink 状态中也导致 Flink 存在大状态问题，从而导致 Checkpoint 耗时过大从而引起任务背压，最终导致数据处理延迟等问题。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;状态后端优化&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;选择 Rocksdb 作为状态后端，开启增量 Checkpoint&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;配置 changelog 状态机制，防止 Rocksdb 定期 Compaction 导致的 Checkpoint 耗时久问题&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;调整 rocksdb manged 内存大小、rocksdb write buffer 大小&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;快照存储优化&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;开启快照压缩配置&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;状态 TTL 机制&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;长期为更新的状态做小时粒度更新，防止状态持续增大。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
&lt;h4&gt;（2）TableStroage 写入性能差&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;问题引入&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;因厂内 Table API 创建 Table Client 过程中需要根据特定表对应的机器数创建对应个数的 brpc-client-work-thread、brpc-client-io-thread、fairStrategy-timer-thread 等线程，共计 3*机器数个，网盘特征 Table 存储底层表占用 200 台机器，故创建一个 Table Client 需要创建 600+线程，从而导致 Flink 计算节点的底层 martix 容器线程超限，经过和 StreamCompute 同学沟通需限制 Table Client 的 Rpc 线程数为 1，并对应 Flink 集群的计算节点容器最大线程数由 1000-&amp;gt;1500，从而解决线程超限问题。但因限制 Table Client Rpc 线程为 1 导致 Table 整体写入性能偏差。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;细粒度拆分任务，首先对用户各类行为以及消费的热点/普调资源进行实时计算，后续根据 user_id+行为类型 keyby，并开 3s 窗口，取最新的数据落入 Table，将 3s 一个窗口的数据进行压缩。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;优化效果&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;原本天粒度写入 48 亿+次行为特征优化为 2 亿+次，具体效果如下图：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-fdcddf10090d37e3776cde4cb75d57067a2.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;业务场景大致可以分为实时数仓、实时数据复杂聚合计算、DB 业务数据 CDC 等场景，在这几个场景 Flink 本身就提供高性能、高稳定性的能力，再配合网盘 Tiangong 实时计算引擎不熟悉 Flink 的业务方也可以配置化、低代码的方式快速建设起实时应用。&lt;/p&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;03 Flink 技术挑战和解决方案&lt;/strong&gt;&lt;/h1&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;3.1 Flink 底座建设&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d39092554eff2e87316084e6fdcb8f92ea8.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ Flink 基建建设&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;基于 StreamCompute 平台提供的动态扩缩容、任务生命周期管理、Flink 多版本管理、云原生监控告警体系等能力，来快速构建网盘 Flink 实时计算能力。&lt;/p&gt; 
&lt;span id="OSC_h2_19"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;3.2 实时计算平台建设&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69d603f60931ccad9cf0674847f7933474f.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;em&gt;△ Tiangong 计算引擎&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-973c854085abdf3899d3eb3d948b42258a5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以上为 Tiangong 计算引擎能力支持，其作为网盘实时计算平台支持目前厂内大部分异构数据源，使用方可以通过简单的配置快速建设实时计算能力，拿上述业务场景实践中的用户商业策略实时特征项目接入 Tiangong 来看，只需下述配置和少量窗口数据聚合逻辑开发即可：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"business_feature_compute_bp2table",&amp;nbsp;// 作业名
&amp;nbsp; &amp;nbsp;&amp;nbsp;"env": {&amp;nbsp;// 作业运行环境配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"streamConfigName":&amp;nbsp;"300p_ck_30s_5fail_env",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"tableConfig": {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"stateTtlMs":&amp;nbsp;600000
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; },
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sources": [ &amp;nbsp;// source 配置，download 日志
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"configType":&amp;nbsp;"CONFIG",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceTableName":&amp;nbsp;"idc_log_source",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;"prod/business_strategy_idc_bp_source"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"udfs":[ &amp;nbsp;// 数据清洗转换逻辑，SQL 无法完成时通过 UDF
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name":&amp;nbsp;"idc_log_filter_func",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"className":&amp;nbsp;"com.baidu.xxx.IdcLogFilterFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;},
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name":&amp;nbsp;"idc_feature_transform_func",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"className":&amp;nbsp;"com.baidu.xxx.IdcFeatureTransformFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"views": [
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"name":&amp;nbsp;"idc_log_feature_view",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sql":&amp;nbsp;"select feature_data.event_time as event_time,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; from (select idc_feature_transform_func(f0) as feature_data
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; from idc_log_source
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; where idc_log_filter_func(f0) = true) as tmp
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; where feature_data.log_time &amp;lt;&amp;gt; '0' and ....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp; "sinks": [ // 双写 TableStorage、Doris
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "sinkConfigNames": ["prod/netdisk_strategy_idc_feature_mi_table_sink","prod/netdisk_strategy_feature_doris_sink"],
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "transformSQL": "select event_time,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;from&amp;nbsp;idc_log_feature_view",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"watermarkConfig":{ &amp;nbsp;// 涉及开窗逻辑所涉及的 watermark 配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "maxOutOfOrdernessMs": 5000,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "idlenessMs": 10000,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "timeAssignerFunctionName": "row_event_time_assigner"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;},
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 开窗计算逻辑函数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "rowTransformFunc": "strategyFeatureTransformFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; ]
&amp;nbsp; &amp;nbsp; }
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_20"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.3 自定义作业执行计划&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69dbff5a89dc2f05b27a8d085a7fb48d22c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_21"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.1 细粒度算子并行度优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7ad2e5c0f0ed28115a1b75867bc770094b2.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 细粒度算子并行度优化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Tiangong 计算引擎本质基于&lt;/strong&gt;Flink SQL+Table API+DataStream API&lt;strong&gt;做的混合计算引擎，其本质相当于&lt;/strong&gt;Flink SQL，因此一旦定义好 Source 和 Sink 并行度后，其任务所涉及的计算、清洗、聚合等算子都与 Source 端并行度一致，从而导致如果想要增加清洗等算子的并行度需要把 Source 的并行度也增加，从而造成&lt;strong&gt;资源浪费、性能降低&lt;/strong&gt;等问题。&lt;/p&gt; 
&lt;span id="OSC_h3_22"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.2 分区关系优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ea2a39e81c8639ea282035af29524d83c90.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 分区关系优化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;作业内上下游算子连接数过多，会占用较大的 Network buffer 内存，从而影响作业的正常启停，基于自定义 SQL 执行计划能力，我们可以手动将 Rebalance 边修改为 Rescale。&lt;/p&gt; 
&lt;p&gt;比如上图的示例，左边上游算子有 500 个并发，而下游的 Sink 算子只有 200 个并发。在这种场景下，Flink SQL 会默认生成 Rebalance 的连接方式，共需 500*200，共 10 万个逻辑连接。&lt;/p&gt; 
&lt;p&gt;通过自定义 SQL 执行计划能力，我们手动将 Rebalance 设置为 Rescale 后，它只需要 500 个连接，大大降低了 Network buffer 的内存需求。&lt;/p&gt; 
&lt;span id="OSC_h3_23"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.3 资源共享策略优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;span id="OSC_h4_24"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;3.3.3.1 资源共享&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;默认情况下，flink 允许 subtask 共享 slot，即使是不同 task 的 subtask，这样的结果是一个 slot 可以保存作业的整个管道。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果是同一步操作的并行 subtask 需要放到不同的 slot，如果是先后发生的不同的 subtask 可以放在同一个 slot 中，实现 slot 的共享。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-91c2e5c65da10b83eac2d61228780eb003b.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ Slot 与 Task 的关系&lt;/em&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_25"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;3.3.3.2 自定义共享策略&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8a407c1e822cf0460c7731db382dc0e4127.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 资源共享策略优化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;支持按照算子类型将算子划分到一个 slot group 中，从而来减少数据的跨网络传输、提升资源利用率以及提升计算性能等。&lt;/p&gt; 
&lt;span id="OSC_h3_26"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.4 算子名称优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Flink SQL 不支持为每个算子自定义名称，从而导致算子名是根据系统规则来生成的，从而导致算子名称不能够通俗的表示其具体含义。为了便于作业维护和管理，自定义作业执行计划支持算子名称优化。&lt;/p&gt; 
&lt;span id="OSC_h1_27"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;04 未来展望&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-22e9ef42b66827bf729f41397c5a31925c8.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 未来展望&lt;/em&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;4.1 实时计算平台化&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前 Tiangong 计算引擎的使用方式主要在公共代码库提交&lt;strong&gt;任务配置和 UDF 代码&lt;/strong&gt;的方式接入，使用方需要拥有&lt;strong&gt;Tiangong 计算引擎的代码库权限&lt;/strong&gt;，存在&lt;strong&gt;代码安全和任务隔离性差&lt;/strong&gt;等问题，后续我们计划基于 Tiangong 计算引擎搭建网盘自己的实时化计算平台，实现页面低代码方式快速接入实时任务。&lt;/p&gt; 
&lt;span id="OSC_h2_29"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;4.2 实时 DTS 平台&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前网盘主要使用厂内 DTS 平台，通过增量 binlog 和全量 select 快照方式采集数据至下游 AFS，整体链路为 DTS-&amp;gt;AFS-&amp;gt;UDW，一旦上游表格式变化下游的采集任务就会失败，因此整体稳定性、维护成本和性能都过差。因此我们计划基于 Tiangong 计算引擎构建实时 DTS 平台，具体架构如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7e491214027eaa22783681f99487a694842.png" alt="图片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ RealTime-DTS 架构&lt;/em&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18690345</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18690345</guid>
      <pubDate>Tue, 02 Sep 2025 06:28:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>即梦 AI 全面开放 API 服务</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;即梦 AI 与火山引擎近日宣布全面开放 API 服务，将包括文生图 3.0、文生图 3.1、图生图 3.0、视频生成 3.0pro、数字人 OmniHuman 以及动作模仿 DreamActor M1 在内的多款前沿 AI 模型，向企业级用户开放。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此举旨在为企业提供丰富且高质量的图像、视频生成与编辑服务，开发者无需额外申请，即可通过自助下单快速接入。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-f1dba3641ccfa78bbb35c84a477d3be8b85.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;这些开放的即梦 AI 系列模型，均基于字节跳动自研的 Seedream 和 Seedance 等模型持续优化开发而来。它们已在即梦 AI 产品上得到大规模验证，展现出强大的应用能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;目前，这些模型能够广泛适配于多种应用场景，包括但不限于故事短片创作、营销物料制作、游戏素材设计、多媒体课件制作和自媒体玩法拓展等，旨在帮助企业和开发者高效地将创意转化为现实。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369848</guid>
      <pubDate>Tue, 02 Sep 2025 06:26:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通义实验室推出智能体开发框架 AgentScope 1.0</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里通义实验室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7p525jsxZg3hA-qA12mKJA" target="_blank"&gt;宣布&lt;/a&gt;推出新一代智能体开发框架——AgentScope 1.0。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根据介绍，AgentScope 1.0 是一款以开发者为核心，专注于多智能体开发的开源框架。它的核心目标是解决智能体在构建、运行和管理中的难题，提供一套覆盖「开发、部署、监控」全生命周期的生产级解决方案，让智能体应用的开发更简单、运行更安全、监控更透明。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="383" src="https://oscimg.oschina.net/oscnet/up-d60680fa66f2ae6c601ad4b4a681e4c0fcc.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;通义实验室构建了三层技术架构：AgentScope 核心框架负责智能体的构建与应用编排；AgentScope Runtime 提供安全、可靠的智能体运行和部署环境；AgentScope Studio 提供可视化的开发与监控工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在 AgentScope 1.0 体系中，这三层技术架构作为三个独立的开源项目，根据开发者需求可以被单独使用。其中&amp;nbsp;AgentScope Runtime&amp;nbsp;和&amp;nbsp;AgentScope Studio，也可以兼容其他主流多智能体编排框架，如 LangGraph 和 AutoGen。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope 核心框架可以看作是一种面向智能体开发的「编程语言」，致力于高效构建基于大语言模型（LLM）的智能体应用。它采用模块化设计，由&lt;strong&gt;消息&lt;/strong&gt;、&lt;strong&gt;模型&lt;/strong&gt;、&lt;strong&gt;记忆&lt;/strong&gt;和&lt;strong&gt;工具&lt;/strong&gt;四大组件构成，实现高度解耦与灵活扩展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope 1.0 在智能体开发上的关键升级，在于其深度融合的三大能力：&lt;strong&gt;实时的介入控制&lt;/strong&gt;、&lt;strong&gt;智能的上下文管理&lt;/strong&gt;、以及&lt;strong&gt;高效的工具调用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;可以把 AgentScope Runtime 理解为智能体的「操作系统」， 它为支撑智能体应用提供了两大核心基础设施：&amp;nbsp;&lt;strong&gt;安全工具沙箱&lt;/strong&gt;和&lt;strong&gt;部署运行引擎&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope Studio 集成了实时监控与智能体评测两大核心功能， 并为开发者提供了一站式的可视化平台，为智能体装上了一套完整的「性能检测仪表盘」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369841</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369841</guid>
      <pubDate>Tue, 02 Sep 2025 05:55:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>中国教育机器人市场的硬件销售额上半年达 10.7 亿元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;国际数据公司（IDC）发布的最新数据，2025 年上半年，中国教育机器人市场的硬件销售额达到了 10.7 亿元，同比增长 12.5%。预计到 2029 年，市场硬件销售额将达到 39.3 亿元，五年复合增长率为 12.9%。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="254" src="https://oscimg.oschina.net/oscnet/up-1c5c8e5f3fdfefca3103123c2247ed275d1.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;教育机器人被定义为基于计算机自动控制、能联网并具备多种功能的智能产品。根据功能和应用的不同，教育机器人可分为三大类:编程机器人、仿生机器人和交互机器人。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;首先，编程机器人以编程教育为核心，通常由可手动组装的标准化零件和电子模块构成。它们可以通过编程控制运动，如避障、循迹等，代表品牌包括优必选、阿尔法蛋和乐高等。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;其次，仿生机器人模仿人类或动物的形态，具备多关节运动能力，并支持复杂动作编程和场景模拟。国内企业如优必选和可以科技在这一领域表现突出。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;最后，交互机器人则以语音交互和图像识别为核心，能够进行问答、课程讲解和个性化学习辅导，代表厂商包括阿尔法蛋和元萝卜等。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;IDC 指出，教育机器人市场正在经历剧烈的变动。虽然市场格局尚未稳定，但编程机器人在课程和赛事的支持下实现了稳定发展。同时，国内厂商凭借丰富的线下课程和内容积累，展现出强大的竞争力。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在教育场景的细分方面，市场需求也越来越明确。不同的学习场景，如早教、K12 编程启蒙和语言学习，推动了教育机器人的产品分类与功能细化。这使得企业能够更好地满足各类教育需求。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369840</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369840</guid>
      <pubDate>Tue, 02 Sep 2025 05:47:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>AI 岗位月薪下限均值已达 4.7 万元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1842108201627391251%26wfr%3Dspider%26for%3Dpc" target="_blank"&gt;据时代财经报道&lt;/a&gt;，7 月、8 月以来，阿里巴巴、字节跳动、腾讯、美团、京东等公司相继启动 2026 届秋招，不少公司宣布发放的 Offer 数量同比增长。&lt;/p&gt; 
&lt;p&gt;一个更明显的趋势是，2026 届的校招已不再是一场例行的人才补充，而是大厂面向 AI 时代发起的一轮「人才军备竞赛」。多位受访应届生表示，今年人工智能带来的增长预期确实在很大程度上左右了他们的职业选择。对于技术岗，AI 已成为未来业务发展的关键变量；而在非技术岗上，如果公司业务与 AI 挂钩，入职后也几乎离不开相关学习。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b10b0838721b75f8e68388315bb23787867.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;脉脉数据显示，截至 7 月，AI 岗位的招聘薪资下限均值为 4.7 万元/月，较 2024 年初上涨 14.16%；上限均值则达到 7.8 万元/月，同比上涨 8.98%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-29ae1eee802c0dc2b491e8337dc94bf8fcc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;《2026 届校招市场 AI 人才需求报告》也显示，在薪酬方面，大模型算法工程师以 2.48 万元/月的中位值居首，深度学习工程师和自然语言处理工程师紧随其后，均在 2.4 万元/月左右；多模态算法工程师、自动驾驶算法工程师、机器学习工程师、推荐算法工程师薪酬中位值均超过 2.3 万元/月。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-3ef9583a4548c9ce19cdca44511498ab831.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;有猎头在朋友圈感叹，顶尖高校的应届博士年薪逼近 200 万元。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369822</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369822</guid>
      <pubDate>Tue, 02 Sep 2025 03:42:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>阿联酋 AI 公司 G42 据悉寻求芯片供应多元化，避免过于依赖英伟达</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;据消息人士称，阿联酋人工智能（AI）公司 G42 正在与多家科技巨头洽谈，试图吸引它们入驻该国规划的 AI 园区。此外，G42 还计划在芯片供应上实现多元化，而不仅依赖英伟达。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;知情人士透露，G42 目前的洽谈对象包括，亚马逊 AWS、谷歌、Meta、微软以及马斯克的 xAI，其中谷歌的谈判进度最为领先，可能率先签订计算力采购协议。该知情人士还表示，G42 还在寻求 AMD、Cerebras Systems（G42 持有部分股权）和高通等美国芯片制造商，为园区提供部分算力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;今年 5 月，美国总统特朗普在访问阿联酋时，与该国达成合作协议。双方将合作建设一个拥有 5 GW 数据中心的 AI 园区。其中已有 1 GW 项目落地：OpenAI 与阿布扎比的 MGX、日本软银、以及甲骨文合作，宣布将在此建立其首个美国境外星际之门（Stargate）数据中心。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;上述 1 GW 项目将采用英伟达 Grace Blackwell GB300 系统，这是目前英伟达最先进的 AI 芯片。该项目作为阿联酋–美国 AI 园区首个阶段，预计于 2026 年左右上线。虽然星际之门获得了最多关注，但它仅占 AI 园区整体规模的 20%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作为欧佩克（石油输出国组织）的重要成员国之一，阿联酋正在加速推动 AI 发展，以应对来自邻国卡塔尔和沙特阿拉伯的竞争。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;沙特公共投资基金（PIF）支持的 AI 公司 HUMAIN 计划到 2030 年建设 1.9 GW 容量数据中心，并在 2034 年扩展至 6 GW。据 HUMAIN 首席执行官透露，其现有及在建数据中心的算力已全部售罄。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，阿联酋在芯片选择上几乎完全押注美国芯片制造商，而这些算力将主要由美国客户消费和销售。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369821</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369821</guid>
      <pubDate>Tue, 02 Sep 2025 03:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>苹果内部 AI 聊天机器人「Asa」曝光，为零售员工打造专属 AI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;MacRumors 网站的亚伦·佩里斯（Aaron Perris）透露，苹果正在内部测试一款名为「Asa」的 AI 聊天机器人。这款工具旨在赋能 Apple Store 零售员工，帮助他们快速掌握 iPhone 等产品的特色和差异化使用场景，从而提升与顾客互动时的解说能力，改善店内体验。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;佩里斯分享的截图显示，「Asa」已被整合进苹果内部的「SEED」应用服务，该平台原本就作为教育培训和销售辅助工具。引入「Asa」意味着苹果正通过 AI 来强化其零售体验。对员工而言，「Asa」不仅仅是一个简单的常见问题解答（FAQ）系统，它更是一个能够即时响应问题并提供情境化建议的智能工具。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="655" src="https://static.oschina.net/uploads/space/2025/0902/110329_8nvn_4252687.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;苹果一直将其零售店视为品牌体验的关键延伸，它不仅是销售场所，更是传播产品哲学和设计理念的据点。「Asa」的部署旨在迅速提升每位员工的专业知识水平，避免因个人经验差异导致顾客获得不一致的信息。这一做法也符合苹果长期以来在零售端强调「一致体验」的策略。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尽管「Asa」是苹果&lt;span&gt;首次&lt;/span&gt;在内部零售场景大规模引入的 AI 助手，但公司尚未对外发布任何面向消费者的「通用型聊天机器人」。与谷歌、OpenAI 和三星等竞争对手快速整合 AI 服务不同，苹果选择了更为谨慎的步伐。它首先从内部环节入手，确保 AI 的实际价值和可靠性，然后逐步将其扩展到更广泛的产品策略中。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="276" src="https://static.oschina.net/uploads/space/2025/0902/110346_rQTN_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;这引发了外界的猜测，即将到来的 2025 年秋季新品发布会是否会带来更多与 AI 相关的惊喜。苹果过去多次强调设备端 AI（on-device AI）的隐私和性能优势。如果「Asa」在内部证明其价值，或许意味着某种形式的 AI 助手未来将集成到 iPhone 或其他苹果设备中，成为与竞争品牌抗衡的重要武器。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369811</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369811</guid>
      <pubDate>Tue, 02 Sep 2025 03:04:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>基于接口数据变异的 App 健壮性测试实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;本文整理自美团技术沙龙第 77 期《美团亿级流量系统的质量风险防控和稳定性治理实践》，主要介绍了对网络返回数据进行变异的客户端健壮性测试实践经验。文章第一部分介绍客户端健壮性测试的基本概念；第二部分分享了基于接口返回数据变异的 App 健壮性测试方案设计的思路；第三部分主要解读了变异数据的构造和异常检测方案设计；第四部分介绍了精简变异数据的探索方案。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7af175bfec290a4eaf573f8d9af531e6e3a.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;01 什么是客户端健壮性&lt;/h2&gt; 
&lt;p&gt;在维基百科的定义中，健壮性（Robustness）是指一个计算机系统在执行过程中处理错误，以及算法在遭遇输入、运算等异常时继续正常运行的能力。IEEE 中将健壮性定义为系统或组件在存在无效输入或压力环境条件下可以正常运行的程度。早在 1989 年，Barton Miller 首次提出了模糊测试的概念，通过向目标应用抛出随机字符串的方式来测试 UNIX 应用程序的健壮性；而在 1996 年的 Ballista 项目中，研究人员探索根据 API 定义的数据类型，对操作系统或软件接口进行自动化测试方法。两个项目均以「无应用程序崩溃或挂起」作为测试验证通过的标准。&lt;/p&gt; 
&lt;p&gt;在移动端 App 领域，健壮性可以理解为 App 运行时遭遇环境异常或者输入异常时客户端能够继续正常运行的能力。&lt;/p&gt; 
&lt;p&gt;其中，环境异常主要分为操作系统异常、外部环境异常、硬件环境异常三大类。比如内存不足、CPU 负载过高、线程池满载、内存分配失败、网络连接失败等。输入异常主要分为系统输入和用户输入。比如网络接口返回的数据异常、应用内缓存、数据库文件读写异常，这类的异常属于在系统输入异常；在电话号码输入框场景，用户输入的空格、富文本则属于用户输入异常。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/4fdab56f61f04f048402f221d50a7004588446.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;对于这些风险，如果 App 没有处理，理论上都可能会产生展示异常、交互异常、性能、安全等问题，导致用户无法继续使用或在使用过程中产生不好的体验。比如用户操作 App 下单过程中，API 请求出现故障未返回状态码为 200 的响应，App 由于没有获取到预期接口响应的信息而发生崩溃，就会中断用户的使用流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/417e16a588aef8f6887c920f641279b6490396.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;02 基于接口数据变异的 App 健壮性测试方案设计&lt;/h2&gt; 
&lt;p&gt;在实际的客户端测试执行过程中，测试人员会考虑测试异常输入的场景，但由于成本无法做到无穷尽的测试，同时还存在人工执行遗漏的风险。&lt;/p&gt; 
&lt;p&gt;从美团 App 平台业务的历史故障分析中，我们发现：网络请求返回的数据与实现预期不符引发的 Crash 或核心功能缺失问题导致的故障占比最高，且影响面较广。比如接口返回非预期数据时，客户端处理数据类型转换异常导致闪退，即使 5 分钟内操作降级仍影响了百万量级的用户。因此美团平台业务 App 的健壮性测试探索优先从发现网络请求返回数据导致的异常开始。&lt;/p&gt; 
&lt;p&gt;针对于发现请求接口返回客户端非预期数据导致的 Crash，或者核心模块缺失问题这个诉求，我们调研后发现方案的基本原理都是相似的，即以网络请求的原始响应为基础，根据规则进行变异构造，使用代理工具改写响应体返回给客户端，在端上设备做异常检测。但是都存在一些问题不能满足诉求，比如测试变异数据是根据预置或者自定义规则随机生成组合，随机性过大，不能有效拦截健壮性问题；但如果不做随机，产生的用例组合量过大，测试不能在合理时间范围内结束；另外在检测能力方面，不具备发现业务异常或功能模块异常的能力。&lt;/p&gt; 
&lt;p&gt;因此，我们结合通用方案做了一些自定义改造，整体检测方案包含静态检测和动态检测两部分。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;静态检测，主要是指静态代码扫描，将典型代码编写规范问题转化为自定义静态代码扫描规则，管控增量代码，同时长期治理存量风险。比如自定义了 PrimitiveParseDetector、ColorParseDetector，管控业务必须使用健壮性测试通过的工具类。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;动态检测是指结合触发时机，构造并注入变异数据后，识别 App 运行时是否出现崩溃、挂起或业务功能模块异常。比如在集成事件/回归事件触发自动化测试运行，构造触发异常的数据进行动态测试，然后监测是否出现了异常。核心动作包含构造变异数据和完成检测两部分。比如将接口响应体中表示颜色含义的 Key 对应的 Value 值构造成非色值，然后检测客户端请求处理接口数据时是否出现崩溃或挂起。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下文重点介绍端到端的动态检测方案。&lt;/p&gt; 
&lt;h2&gt;03 变异数据的构造和异常检测&lt;/h2&gt; 
&lt;p&gt;对于美团 App 来说，首页有多种形态，对于某种特定形态，除了控制请求数据外还需要控制实验、策略等一系列因素，才能保证测试对象的唯一性。一个页面中包含多个异步请求，因此请求的构造也需要和页面路径关联。这些都是采集变异所需的基础数据时需要关注和控制的。&lt;/p&gt; 
&lt;p&gt;响应体由基本类型数据和复合类型数据组成，相同基本类型的数据可能具备不同的业务语义，需要根据语义的类型做变异规则的区分对待，才能保障业务场景覆盖。&lt;/p&gt; 
&lt;p&gt;因此，如何保障变异数据构造的全面性和准确性，是我们面临的首要挑战。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/fcae8a57bc7fecc23c02e1f003103636490174.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;要解决数据构造全面性问题，首先要解决页面描述方案，这样才能控制获取基础数据的唯一性。在解决方案中，我们构建了页面描述的特征规则，解决用户视角的页面标识问题。需要的信息包含端信息、页面路由信息、实验策略账号信息、页面标识模块合集等。通过页面请求数据自动录制的方式，自动更新迭代请求数据和页面之间的绑定关系，使得基础数据能够随需求迭代更新，从而通过变异规则构造生成的用例也能够自动更新。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/749a8a36e3d6c24f0d93d43c1be36ef3138813.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在用例变异生成构造上，对于响应体里的 Value 设置了语义匹配规则，比如字符串的语义可能代表颜色、页面跳转路由、动静态资源链接（即图片资源数据/视频文件/GIF 文件），需要区分特征分别按语义构造异常数据。比如在图片的变异数据构造里，除了需要构造非图片链接情况外，还要考虑不同图片格式、非图片格式以及非合法的图片剪裁格式拼接等场景。&lt;/p&gt; 
&lt;p&gt;我们对接口返回数据使用脚本做了初步的语义分析，人工二次校正后建立了基本数据类型和语义的映射集合，结合基本数据类型边界值和语义定义了初始的变异规则。然后对历史的线上健壮性问题和线下测试发现的健壮性 Bug 的变异数据进行整理，作为增补的变异规则。&lt;/p&gt; 
&lt;p&gt;在自动化测试执行过程中，我们基于 App 可测性改造提供的能力，对测试场景进行了控制，同时基于布局视图的解析 SDK、App 异常上报 SDK 提供的能力，完成了对 App 异常的通用检测。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/025aa7a5939998f5b79ecebc0b27a2e6596526.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;04 变异数据的精简方案&lt;/h2&gt; 
&lt;p&gt;伴随着变异规则的丰富，自动生成的数据量级是巨大的，数据的变异组合如果按照全覆盖方式来生成组合数量就是指数级增长。比如对于 1 种有 7 种变异取值的变量，如果存在 n 个此类型变量，就会产生 7^n 种数据组合，并且在实际业务场景中很多组合情况是没有意义的。&lt;/p&gt; 
&lt;p&gt;如何在保障用例构造全面性的情况下精简变异构造的用例数，是我们面临的第二个挑战。解决方案包含 2 个策略：1）数组元素结构一致时，删减构造的用例数；2）结构不完全一致的数组元素，引入编辑距离和并查集算法判断节点相似性，节点不相似，可以在一次数据生成里做合并构造。&lt;/p&gt; 
&lt;p&gt;我们可以把请求响应的 JSON 理解成树，第一个解决思路是判断树中节点、路径的相似度，相似节点删减构造。&lt;/p&gt; 
&lt;p&gt;如果路径、节点相似，可以推测路径即业务逻辑也是一致的，比如页面上的一些列表元素，可能是数据结构对象完全一致数组，如果对每个数组对象中的每个元素进行全用例构造，生成的变异数据量极大，且对业务场景或代码逻辑的增量覆盖有限，因此我们决定将构造逻辑优化，进行删减构造。即假如数组中元素的结构完全一致，那么同含义的字段可以为他们分配不同的变异构造值，然后删减掉无效的构造情况。应用这种方法可以有效降低 28% 左右的用例构造数量。&lt;/p&gt; 
&lt;p&gt;如图数组的 3 个元素中均存在「resourceName」键值对，假如每个键值对有 3 种变异取值，按照全排列方式进行用例构造将会生成有 9 份变异数据，在删减构造情况下，可以分别为它们构造一个特定的变异值，这样变异生成用例数量可以从 9 减少为 1。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/1aafbb6221bd6e6d58f9b34b1e6c1740511997.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在对业务接口返回数据的数据结构进行分析后，我们发现在层级越深的场景下，距离根节点越近的两个节点，业务逻辑耦合和结构相似程度越低，它可以进行合并构造，相互逻辑之间不会产生影响，比如有两个键值对，每个键值对的 Value 有 3 种变异取值，在合并构造情况下，可以从排列组合的 6 份数据减少到 3 份数据。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/786c1d604282783c4198fd278d19e96a498897.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于这个个思路，我们在实践中引入了编辑距离和并查集算法，以节点路径为参照，对树的每一层的每两个节点计算编辑距离，生成一个 n*n 矩阵；同时以树的高度减去节点位于的层数作为权重，修正编辑距离。基于这样的计算，会产生多个编辑距离矩阵。&lt;/p&gt; 
&lt;p&gt;为了尝试最大化合并构造用例效果，我们把编辑距离做了 0,1 矩阵转化。其中，由于编辑距离为 1 的两个节点可能存在业务逻辑耦合关系，必须放在同一个组里分别构造，所以我们把编辑距离大于 1 的情况转化成了 0，最后得到了一个 0,1 的编辑距离矩阵。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/b2e4be73269fc8a8120b5b85f7733068439100.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在 0,1 矩阵情况下，我们使用了图的连通性概念，如果 A 和 B 连通，B 和 C 连通，那我们认为 A 和 C 连通，转化到这里的概念就是 A 和 B 相似，B 和 C 相似，那么 A 和 C 相似，它们应该被放在同一个组里分开进行构造，那么在同层元素构造时，我们会从每个分组里取到一个节点，对这些规则进行变异组合构造。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/8db6db32fd1a411833c244aec0607246401141.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基于以上两个策略进行精简后生成的变异数据量较精简前降低了 40%，同时代码覆盖率没有明显变化，并且保持不变的健壮性问题发现能力。&lt;/p&gt; 
&lt;p&gt;美团 App 和优选 App 都接入了这个工具，在新需求阶段可以人工触发运行，还可以结合客户端组件集成事件和回归事件做自动触发。至今应用一年时间内，发现了几十个问题。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/43da284d99ef324da17b87f32a65bf4d80130.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/ef4524ffc0b1bb460dcf5a87d3521492352401.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;05 总结及展望&lt;/h2&gt; 
&lt;p&gt;在健壮性工具建设一期里，我们实现了 App 页面加载展示场景的健壮性问题检测，支持崩溃、卡死和部分功能异常这三类异常检测。另外，基于节点相似性优化变异数据生成策略能够在保持效果不变的情况下有效控制测试时长，但是否有更优的合并算法和推荐算法，还需要更多的尝试。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/f710dd7245adfa4b3eef7441c3821d4f205702.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在后续工具的迭代还会继续围绕异常构造和异常检测这两个方向，支持更丰富的构造能力和检测能力，以及更高效的构造效率。短期建设上，我们将会从业务视角出发丰富自动化变异数据生成建模，完善客户端异常通用异常检测能力，完成通用前后端交互的数据构造类型（比如：长连接消息）的覆盖；长期建设上，需要支持更丰富的数据和环境构造能力，通过智能化用例生成，提升测试效率。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/b5e78a9597644c7ab82fe1ba7dade3a4328067.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/8410e19b1eea87a06f566f582b89f1cb174515.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;06 Q&amp;amp;A&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Q1&lt;/strong&gt;：节点相似的判断依据是什么？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：从实际的 response 分析来说，两个节点的路径完全相似就是从根节点到最终的叶子节点上，它们的路径命名完全相似，数组里两个对象的结构完全一样。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q2&lt;/strong&gt;：用例的生成能举个例子吗？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：比如颜色色值的格式是#+6 位字符，通常运营配置会出现的情况是忘记添加#，或色值复制中少了一位。在这种情况下，我们会构造一个色值，比如没有返回#、色值位数不对、色值添加透明度，把这种场景作为构造情况，在配置里添加上，最后用代码生成。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q3&lt;/strong&gt;：健壮性平时执行的频率是什么样的？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：第一个基于需求维度，需求维度需要人工触发；第二个基于变更维度，当组件发生变更时，可以关联到这段代码或者组件变更的页面，然后触发页面对应的健壮性测试，执行频率会受到组件变更频率的影响；第三个在回归测试时，App 的回归测试两周一次，我们会把所有页面以及它关联的所有的用例都执行一次。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q4&lt;/strong&gt;：对于暴露给前端开发的接口，大部分是人为调用参数的变化，随机性相对比较高，对于必填和非必填参数如何确认用例的范围？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：目前我们在实现的方案里，没有区分参数是必填参数还是非必填参数，所以对于整个数据接口返回里的所有结果都会进行构造，产生的问题是对于非必返回的参数可能产生的问题，到底是否是需要解决的问题，这部分目前通过运营手段做确认。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q5&lt;/strong&gt;：首页可能调用 10 个接口，然后针对每个字段都进行异常验证吗？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：对于首页关联的接口，我们在接口请求、录制过程中和录制完数据后，会对接口进行确认到底有哪些接口是我们需要验证的，这是一次性的成本，录制完成后，会对每个字段都进行异常验证，当然会有一些黑白名单的设置。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q6&lt;/strong&gt;：对色号这种情况有一种生成规则嘛，这个规则是怎么制定？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：刚刚我只是举了一个色号的例子，其实对于图片、请求的资源文件、配置文件、跳转链接，每一个对应到的业务语义，我们都有对应的用例生成规则，我们会根据参考依据，比如第一个是本身我们在通用的基础库里怎么处理这些问题，这里有一个基础的规则；第二个是我们积累了线上问题情况实际可能会产生的错误或者变异情况，生成第一版基础规则，在第一期工具里找相关研发达成共识，这样的话，数据变异是处于合理范围。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q7&lt;/strong&gt;：执行的时候，如何知道页面对应哪些规则提前配置？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：执行时，在测试接入过程中有一个配置过程，它不是配置这个页面和接口的关联关系，而是配置我们要测试哪些页面，自动触发自动化录制过程，就是到这个页面时，会触发哪些接口请求，生成这个页面和这个接口请求的对应关系，给到对应的配置人做确认，保证哪些接口是真正可能想要构造的，哪些接口不需要构造，最后以这个为基准测试，基于录制过程，比如业务迭代里面产生了新接口，我们在录制中能够感知到它关联的接口发生了变化，在发生变化时发消息给对应的测试提交人/负责人，TA 确认这条规则放到黑名单里还是更新到需要构造的接口里。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q8&lt;/strong&gt;：是否有做页面显示的一个校验？怎么做的？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：目前我们在页面里的模块做了「是否展示」校验，基于当前集成到美团的可测性 SDK，这个 SDK 会获取到当前页面是否渲染里是否展示了对应模块的信息，通过请求把对应模块描述传给 SDK，通过返回来校验是否展示。&lt;/p&gt; 
&lt;h2&gt;07 参考资料&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;[1] 健壮性：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRobustness" target="_blank"&gt;https://en.wikipedia.org/wiki/Robustness&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[2] IEEE 健壮性：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fieeexplore.ieee.org%2Fdocument%2F7438745" target="_blank"&gt;https://ieeexplore.ieee.org/document/7438745&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[3] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fusers.ece.cmu.edu%2F%7Ekoopman%2Fballista%2F" target="_blank"&gt;Ballista&lt;/a&gt;：Carnegie Mellon 大学的研究项目，通过黑盒自动化测试的方式，发现导致系统崩溃或异常终止的系统调用或接口调用。&lt;/li&gt; 
 &lt;li&gt;[4] 基于布局视图的解析 SDK：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2021%2F07%2F28%2Fapp-xraysdk.html" target="_blank"&gt;美团 App 页面视图可测性改造实践-XraySDK&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;|&lt;/strong&gt; 在美团公众号菜单栏对话框回复【2023 年货】、【2022 年货】、【2021 年货】、【2020 年货】、【2019 年货】、【2018 年货】、【2017 年货】等关键词，可查看美团技术团队历年技术文章合集。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/b0364d579285ab22aa6235bd100d7c22178175.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;| &lt;a href="https://www.oschina.net/action/GoToLink?url=mailto%3A%E6%9C%AC%E6%96%87%E7%B3%BB%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%87%BA%E5%93%81%EF%BC%8C%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E5%B1%9E%E7%BE%8E%E5%9B%A2%E3%80%82%E6%AC%A2%E8%BF%8E%E5%87%BA%E4%BA%8E%E5%88%86%E4%BA%AB%E5%92%8C%E4%BA%A4%E6%B5%81%E7%AD%89%E9%9D%9E%E5%95%86%E4%B8%9A%E7%9B%AE%E7%9A%84%E8%BD%AC%E8%BD%BD%E6%88%96%E4%BD%BF%E7%94%A8%E6%9C%AC%E6%96%87%E5%86%85%E5%AE%B9%EF%BC%8C%E6%95%AC%E8%AF%B7%E6%B3%A8%E6%98%8E%E2%80%9C%E5%86%85%E5%AE%B9%E8%BD%AC%E8%BD%BD%E8%87%AA%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E2%80%9D%E3%80%82%E6%9C%AC%E6%96%87%E6%9C%AA%E7%BB%8F%E8%AE%B8%E5%8F%AF%EF%BC%8C%E4%B8%8D%E5%BE%97%E8%BF%9B%E8%A1%8C%E5%95%86%E4%B8%9A%E6%80%A7%E8%BD%AC%E8%BD%BD%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E3%80%82%E4%BB%BB%E4%BD%95%E5%95%86%E7%94%A8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E8%AF%B7%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E8%87%B3tech%40meituan.com%E7%94%B3%E8%AF%B7%E6%8E%88%E6%9D%83%E3%80%82" target="_blank"&gt;本文系美团技术团队出品，著作权归属美团。欢迎出于分享和交流等非商业目的转载或使用本文内容，敬请注明「内容转载自美团技术团队」。本文未经许可，不得进行商业性转载或者使用。任何商用行为，请发送邮件至 tech@meituan.com 申请授权。&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/meituantech/blog/11045435</link>
      <guid isPermaLink="false">https://my.oschina.net/meituantech/blog/11045435</guid>
      <pubDate>Tue, 02 Sep 2025 02:59:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>分布式文件系统 FastDFS V6.13 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;分布式文件系统&lt;span&gt;FastDFS V6.13&lt;/span&gt;发布，主要改进包括：支持读写分离和性能优化，具体的改进如下：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;1. storage server&lt;span&gt;支持读写分离，主要用于跨机房灾备场景。&lt;/span&gt;storage &lt;span&gt;启用&lt;/span&gt;server ID&lt;span&gt;的情况下才可以使用这一特性。配置文件&lt;/span&gt;storage_ids.conf&lt;span&gt;的最后一列支持选项：&lt;/span&gt;rw=&amp;lt;both | read | write | none&amp;gt;&lt;span&gt;，不设置&lt;/span&gt;rw&lt;span&gt;时采用默认值&lt;/span&gt; both&lt;span&gt;（可读可写）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;2. &lt;span&gt;性能优化：用拼接字符串的方式替换耗时的&lt;/span&gt;sprintf&lt;span&gt;、&lt;/span&gt;snprintf&lt;span&gt;和&lt;/span&gt;vsprintf&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;3. &lt;span&gt;合并&lt;/span&gt; lystormenvoy&lt;span&gt;提交的&lt;/span&gt;patch #753&lt;span&gt;：&lt;/span&gt;add store_path#_readonly setting to limit write access per storage path&lt;span&gt;。在使用多块硬盘的情况下，逐台服务器更换单块大硬盘进行扩容时，禁止向该盘上传文件。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;4. bug&lt;span&gt;修复：获取连接池中的连接前，需要调用&lt;/span&gt;memset&lt;span&gt;初始化&lt;/span&gt;connection&lt;span&gt;结构体。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;5. &lt;/span&gt;移除无用的&lt;span&gt;HTTP&lt;/span&gt;相关字段和代码。之前尝试内置&lt;span&gt;HTTP&lt;/span&gt;服务，后来觉得没必要，这部分代码就废弃了。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;6. fdfs_monitor&lt;span&gt;的输出更加直观易读，比如像&lt;/span&gt;df&lt;span&gt;那样人性化显示磁盘空间，在&lt;/span&gt;group&lt;span&gt;中显示当前&lt;/span&gt;trunk server&lt;span&gt;等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;FastDFS&lt;/span&gt;项目托管在&lt;span&gt; github &lt;/span&gt;和&lt;span&gt; gitee&lt;/span&gt;，欢迎大家测试和使用&lt;span&gt;V6.13&lt;/span&gt;，建议老用户升级到最新版本。有任何问题和建议欢迎加群交流。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;友情提示&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;1&lt;/span&gt;）&lt;span&gt;V6.11&lt;/span&gt;和&lt;span&gt;V6.12&lt;/span&gt;升级到&lt;span&gt;V6.13&lt;/span&gt;，客户端&lt;span&gt;SDK&lt;/span&gt;可以不升级；因通信协议略有调整，其他版本升级到&lt;span&gt;V6.13&lt;/span&gt;时，客户端&lt;span&gt;SDK&lt;/span&gt;需要同步升级；&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;fastdfs-nginx-module&lt;span&gt;需要升级到最新的&lt;/span&gt;V1.25&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369807/fastdfs-6-13-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369807/fastdfs-6-13-released</guid>
      <pubDate>Tue, 02 Sep 2025 02:49:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>开源图像编辑器 GIMP 3.1.4 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源图像处理软件 GIMP 发布了 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gimp.org%2Fnews%2F2025%2F09%2F01%2Fgimp-3-1-4-released%2F" target="_blank"&gt;3.1.4 开发版&lt;/a&gt;，这是面向未来 GIMP 3.2 的第二个测试版本，带来了两项重量级新功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Link Layers（链接图层）：支持将外部文件（如 SVG）作为图层引入，并能在原文件更新时实时同步到 GIMP，非破坏性支持缩放、旋转等操作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Vector Layers（矢量图层）：终于原生支持矢量形状，用户可自由编辑路径、填充和描边，保证放大时图像依旧清晰。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b0b1b5f0c8b9d61609b1076d73b6db3ee7a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了核心功能外，本次更新还包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;GEGL Filter Browser&lt;/strong&gt;：新的 GEGL 滤镜浏览器界面由 Google Summer of Code 项目贡献。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;MyPaint Brushes 2&lt;/strong&gt;：新增对 MyPaint 支（Paint 2 画笔）的支持。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Text Tool 更新&lt;/strong&gt;：文本工具做出改进。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;插件与格式支持&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;导入签名的 JPEG 2000 文件；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;支持非 DXT PAA 纹理；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;TIFF 文件处理得到改进。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;界面与内部优化&lt;/strong&gt;：包括 UX/UI 改进、各类 bug 修复、内部架构调整、PDB（过程数据库）更新、构建流程优化（如 Nightly Snap 与 aarch64 Flatpak 支持）等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;GIMP 官方提醒，3.1.4 属于开发测试版本，功能强大但可能存在崩溃风险，适合尝鲜用户体验，不建议用于生产环境。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369805/gimp-3-1-4-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369805/gimp-3-1-4-released</guid>
      <pubDate>Tue, 02 Sep 2025 02:45:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>《上海合作组织成员国元首理事会关于进一步深化人工智能国际合作的声明》发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;《上海合作组织成员国元首理事会关于进一步深化人工智能国际合作的声明》&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gov.cn%2Fyaowen%2Fliebiao%2F202509%2Fcontent_7038710.htm" target="_blank"&gt;发布&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="298" src="https://oscimg.oschina.net/oscnet/up-c1e1998ec520ff1faa874f536b3ea15109a.png" width="600" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;其中提到，成员国将采取以下行动：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在充分考虑成员国优先事项和各自国内法律法规的基础上，支持联合国在人工智能决策中的核心作用，欢迎联合国大会通过的「加强人工智能能力建设国际合作」决议，以及「人工智能在为中亚可持续发展创造新机遇方面发挥的作用」的决议；&lt;/li&gt; 
 &lt;li&gt;欢迎提出《人工智能能力建设普惠计划》，成立人工智能能力建设国际合作之友小组，举办「人工智能之旅」国际会议（「AI Journey」），以及其他上合组织成员国人工智能领域倡议；&lt;/li&gt; 
 &lt;li&gt;加强人工智能基础设施合作，促进人工智能基础设施联通，在自愿参加的基础上推动人工智能应用国际合作；&lt;/li&gt; 
 &lt;li&gt;推动人工智能人才培养合作，扩大校际合作与学术交流，促进科研成果和教育资源交流；&lt;/li&gt; 
 &lt;li&gt;推动人工智能领域投资合作，发挥上合组织银联体的作用，充分挖掘上合组织成员国投资潜力，在自愿参加的基础上为成员国人工智能领域投资项目提供资源支持；&lt;/li&gt; 
 &lt;li&gt;在尊重国家主权的基础上发展人工智能领域对话伙伴机制，加强发展战略、治理规则、技术标准的对接协调，发展安全负责任的人工智能，开发可信赖的人工智能系统；&lt;/li&gt; 
 &lt;li&gt;在人工智能全球治理领域推动互惠理念，在人工智能国际监管方面始终坚持发展与安全并重。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;各成员国将努力推动人工智能向更加开放、包容、普惠、公平、向善的方向发展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369799</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369799</guid>
      <pubDate>Tue, 02 Sep 2025 02:40:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>R8 疑难杂症分析实战：外联优化设计缺陷引起的崩溃</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R8 作为谷歌官方的编译优化工具，在编译阶段会对字节码进行大规模修改，以追求包体优化和性能提升。但是 Android 应用开发者数量太过庞大，无论测试流程多么完善，终究难以避免在一些特定场景下出现问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;近期我们在升级项目的 AGP，遇到了一个指向系统 SurfaceTexture 类的 native 崩溃问题。经反编译分析发现问题最终指向了 smali 字节码中多余的一行 new-instance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c5f08cf575756e08466c223dc6283005.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1c03aaa90c06e347c22e752eeb0ccb1d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;该指令创建了一个 SurfaceTexture 对象，但是并未调用其&amp;lt;init&amp;gt;方法，这意味着构造方法没有执行，但是这个类重写了 finalize 方法，后续被 gc 回收时会调用其中的 nativeFinalize 这个 JNI 方法，最终在 native 层执行析构函数时触发了 SIGNALL 11 的内存访问错误.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d639c13a4be57106726e6ea52ee6c3f4.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//2210f4a541d54e36690a7e1fbfb16627.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、复现问题&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们注意到多出来的 new-instance 指令下面紧接着的是对 a0.e 类中的静态方法 i() 的调用，其内部实现就是 SurfaceTexture 的构造方法。这是典型的代码外联操作，即一段相同的代码在工程中多次出现，则会被抽出来单独作为一个静态函数，原先的调用点则替换成该函数的调用，这样可以减小代码体积，是常见的编码思路。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }
}
//外联生成的类
class&amp;nbsp;Activity$Outline{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;log(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们根据这个生成类的类名可以知道是 R8 中 ApiModelOutline 功能生成了这个类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//832dad3a1078a82298590ae249e4c937.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们进到 R8 工程中检索下相关的关键字，再加上 demo 多次尝试，可以确认满足以下条件能够必现该问题:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用了高于当前 minSdkVersion 的系统函数/变量（仅限系统类，自己写的无效）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用 synchronized 或者 try 语句块包裹了该调用，或者给该函数传参时有任何计算行为（除了传局部变量）。例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、问题分析&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在确认复现条件之后，我们带着几个问题来逐个分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 外联是什么？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;R8 中的优化大多数跟包体优化有关，代码外联也是其中一种，但是外联的前提是代码重复的次数满足一定阈值，但是 ApiModel 会对所有调用了高版本系统 API 的代码做外联，包括只调用一次的场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 并非为了包体优化，我们通过 R8 工程的 issueTracker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://issuetracker.google.com/issues/333477035）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;检索到了相关的信息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5020bee9863c252049d9f1d8f055c200.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;译：AGP 新增的 ApiModel 功能是为了防止在低版本设备上不可能执行的代码引起类验证错误，从而降低 App 启动耗时。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从这篇介绍 ART 虚拟机类验证的文档&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://chromium.googlesource.com/chromium/src/+/HEAD/build/android/docs/class_verification_failures.md#chromium_s-solution）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;就能够理解上面这句话的含义：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ART 虚拟机会在 APK 安装之后立刻执行 AOT class verification，即对 dex 文件中所有的类进行验证，如果验证成功则后续运行时将不需要再进行验证，反之若失败，则该 class 会被 ART 打上&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;RetryVerificationAtRuntime&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;的标记，后续运行时还得重新执行类验证。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;同时这些失败的类也将无法被 dex2oat 优化成 oat 格式的优化字节码（oat 字节码的加载和执行速度更快）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5d3b99565c562dff751ba4ac636da574.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是在 MainActivity，启动任务中使用了这些高版本 API，那么在低版本设备 App 启动时就必须额外执行一次类验证（比较耗时，有的类能到 8ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;nbsp;https://issues.chromium.org/issues/40574431&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;），而 ApiModel 外联则是相当于将这些肯定验证失败的函数的调用单独抽到一个生成类中，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这样运行时就能将类验证失败问题彻底隔离在生成类中，从而规避运行时的类验证耗时。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//安装 apk 后验证失败，运行时验证失败，但是能正常执行
class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk&amp;nbsp;&amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 后&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk &amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a0.b();&amp;nbsp;//这样类验证就能成功
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}
//生成的外联类，类验证会失败，但是运行时不可能走到，不影响
class&amp;nbsp;a0{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;b(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;更多关于 ApiModel 的详细介绍，见这篇文章：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://medium.com/androiddevelopers/mitigating-soft-verification-issues-in-r8-and-d8-7e9e06827dfd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么会多生成一个&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;new-instance 指令?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;介绍完 ApiModel 之后，我们已经知道了为什么&amp;lt;init&amp;gt;方法的调用被替换成了一个生成函数的调用，接下来我们再分析下导致崩溃的罪魁祸首 new-instance 指令是如何出现的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们先来了解下 java 文件在编译过程中的格式转换过程，因为 ApiModel 是基于 IRCode 格式（R8 自定义的格式）来做外联。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;文件转换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;javac&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;javac 将 java 文件编译成 class 文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是 sychronized 语句块在 javac 编译之后会为其内部代码生成 try-catch，这是为了确保在语句块抛异常时能够正常释放锁，因此和问题有关的是 try-catch 语句块，和 synchronized 无关。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//36889c510c4d4a88957306d93cdf7d59.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;D8&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;目前 R8 已经整合 D8，因此输入 class 文件之后就会先通过 D8 转为 dex 格式，并持有在内存中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;转换之后的指令基本和 class 字节码基本类似。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//876e7cf561f3a8aa1ee57005986ae7f0.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;IRcode&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了做进一步的优化，会将 dex 格式的代码转化成 R8 自定义的 IRcode 格式，其特点是代码分块。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;案例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b04a46ddb675fd3446029e19aa3fc632.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;问题根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 工程里检索 ApiModel 关键字，最终定位到针对构造函数生成外联函数和指令替换的代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;InstanceInitializerOutliner-&amp;gt;rewriteCode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;执行此方法之前的指令如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java：
new&amp;nbsp;SurfaceTexture(false);&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;dex：
:&amp;nbsp;-1:&amp;nbsp;NewInstance &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1&amp;nbsp;&amp;lt;- &amp;nbsp;android.graphics.SurfaceTexture
: -1: ConstNumber &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v2(0) &amp;lt;- &amp;nbsp;0 (INT)
: -1: Invoke-Direct &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1,&amp;nbsp;v2(0); method:&amp;nbsp;void&amp;nbsp;android.graphics.SurfaceTexture.&amp;lt;init&amp;gt;(boolean)&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;对整个方法中所有的指令从上往下进行遍历，第一次遍历主要是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;检索 &amp;lt;init&amp;gt;方法调用的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;判断该方法的 androidApiLevel 是否高于 minSDK&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;生成包含完整构造函数指令的外联函数，并替换&amp;lt;init&amp;gt;函数调用为外联函数调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;执行完替换逻辑，就记录信息到 map 中，key 是&amp;lt;init&amp;gt;对应的 new-instance 指令，value 是前一步中替换的新指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;经过这一步，字节码会变成这样：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//e6b105ab1ca583830e11bee8baafc4e5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具体替换逻辑如下（可以参考注释理解）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c919c6ad05e651de339fb13da747bfaa.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;第二次遍历则是对 new-instance 指令的处理：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;找到 new-instance 指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;查询 map，确认&amp;lt;init&amp;gt;方法已完成替换&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根据&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;方法返回的结果分为两种场景：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;无类初始化逻辑：直接移除 new-instance 指令，不影响原代码的语义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//f1f56bfb61c5396de49e85cc7eec3a7e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;有类初始化逻辑：生成外联函数，只包含该 new-instance 指令，和前一次遍历一样进行指令替换。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1959f35cfade28f57d11667c652bea3e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具体替换逻辑:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fac201236889edc5ad19870621442c23.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;问题重点就在于&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这个函数的实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;它会检查 new-intance 指令和 invoke &amp;lt;init&amp;gt;指令之间是否存在任何局部变量声明以外的指令，如果存在，他会认为这些指令是这个类初始化的逻辑，因此为了保留源代码的执行顺序，这种情况下就是需要额外执行一次 new-instance 指令来触发类初始化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9fe3bbc584708c6a61e6b7a0d4e808bd.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;但是实际上，如果在调用这个构造函数传参时执行了任何运算（和类加载无关），都会生成相关的指令插在中间，例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;java 写法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new-intance 和 invoke &amp;lt;init&amp;gt;指令之间的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;invoke-virtual &amp;nbsp; v2 &amp;lt;-; method: void xx.xx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;StaticGet &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v3 &amp;lt;- ; field: boolean &amp;nbsp;xxx.xxx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: CheckCast &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v5 &amp;lt;- v3; java.lang.Boolean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: Invoke-Virtual &amp;nbsp; &amp;nbsp; &amp;nbsp; v6 &amp;lt;- v5; method: boolean java.lang.Boolean.booleanValue()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;从作者留下的 todo 也能看出，后续准备扩展这个方法，实现对这些夹在中间的指令的判断，如果是对类初始化无影响的入参计算逻辑，则也将正常移除 new-intance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fa19a3d661f5f19c0bf5fdb01d8c8aba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是，我们最终 APK 里 new-intance 指令并没有被外联，这是因为 SurfaceTexture 这个类本身在安卓 21 之前的版本就已经存在，只是入参为 bool 类型的构造方法是在安卓 26 新增的，所以他其实是被外联之后又被内联回到了调用处，因此看起来像是没有被外联。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//48f375f6e8c147cd435c140b6c8864ba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;小结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;至此，我们就明白了多出来一个看似无用的 new-intance 指令，实际上是为了保全源代码的语义，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;触发类加载&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用的，但是作者没有考虑到这些被优化的类可能重写了 finalize 方法来释放一些本就不存在的资源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;而且不局限于调用 native 函数，只要是重写了 finalize，并在里面访问一些在构造函数中初始化的成员变量，一样可能造成 NPE 等崩溃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 是如何计算出 API 的版本？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d58a071ec92ca506d6e4f3e1ab4c7122.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R83.3 版本开始，它编译时会下载一个.ser 格式的数据库文件，里面记录了所有系统 API、变量与安卓版本号的映射信息，在运行时通过行号和偏移量来寻找各自的版本号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9842b0b5f78805c080d71cbda30f1c44.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么 try-catch&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;也会导致该问题？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前面解释了在构造函数入参中添加函数调用等写法导致的字节码异常原因，但是实际上这次我们遇到的崩溃场景是在 sychronized 里 new 了一个 SurfaceTexture。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//cec26da2ccbd01a385a47d0914cbd615.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前文中已经解释过，sychronized 在编译成 class 后会生成 try-catch 语句块，这段代码改成用 try-catch 语句块包裹，一样会复现崩溃，因此我们跟踪 try-catch 在文件转换过程中对字节码的影响即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;回到 class 文件转 dex 文件的阶段，我们发现 try 语句块中的每一行指令，都会在其后生成一条 FALLTHROUGH 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;dex 格式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//dc87199452140addbab0d7de45794ad8.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 是什么指令，他是做什么的？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 指令表示指令自然流转，没有实际含义，它主要是为了帮助优化器识别哪些指令是可达的。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如下面这种写法，case1 没有写 break，这样会接着执行 case2 的代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;switch&amp;nbsp;(value) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;1:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("One");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 故意不写 break
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;2:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Two");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;3:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Three");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;其字节码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;正常有 break 的话，会对应一条 GOTO 指令跳转到 switch 语句块最后一行，但是没写 break 的话，就会出现：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 12 行执行 goto 13 跳转到 13 行的指令，这种指令毫无意义，且运行时会消耗性能，因此可以替换成 FALLTHROUGH 指令，这样最终在生成 dex 文件时会被移除掉，从而避免浪费性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;switchWithFallthrough(int);
&amp;nbsp; Code:
&amp;nbsp; &amp;nbsp; stack=2, locals=1, args_size=1


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载参数
&amp;nbsp; &amp;nbsp;&amp;nbsp;0: iload_0


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 检查 case 1
&amp;nbsp; &amp;nbsp;&amp;nbsp;1: iconst_1
&amp;nbsp; &amp;nbsp;&amp;nbsp;2: if_icmpne&amp;nbsp;13&amp;nbsp; &amp;nbsp;&amp;nbsp;// 如果不等于 1，跳转到 case 2
&amp;nbsp; &amp;nbsp;&amp;nbsp;5: getstatic #2&amp;nbsp; &amp;nbsp;&amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;8: ldc #3&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// String One
&amp;nbsp; &amp;nbsp;&amp;nbsp;10: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;12:&amp;nbsp;goto&amp;nbsp;13


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 2 (fallthrough 目标)
&amp;nbsp; &amp;nbsp;&amp;nbsp;13: iconst_2
&amp;nbsp; &amp;nbsp;&amp;nbsp;14: if_icmpne&amp;nbsp;28&amp;nbsp; &amp;nbsp;// 如果不等于 2，跳转到 case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;17: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;20: ldc #5&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Two
&amp;nbsp; &amp;nbsp;&amp;nbsp;22: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;25:&amp;nbsp;goto&amp;nbsp;40&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 跳转到 switch 结束


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;28: iconst_3
&amp;nbsp; &amp;nbsp;&amp;nbsp;29: if_icmpne&amp;nbsp;40&amp;nbsp; &amp;nbsp;// 如果不等于 3，跳转到结束
&amp;nbsp; &amp;nbsp;&amp;nbsp;32: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;35: ldc #6&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Three
&amp;nbsp; &amp;nbsp;&amp;nbsp;37: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V


&amp;nbsp; &amp;nbsp;&amp;nbsp;// switch 结束
&amp;nbsp; &amp;nbsp;&amp;nbsp;40:&amp;nbsp;return&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;既然没用为什么还要加这个指令？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;class 文件是通过 Exception table 来指定异常处理的指令范围，而 dex 文件则是通过为每一行可能产生 throwable 的指令后面添加 FALLTHROUGH 指令来实现 try-catch。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这里会把每一行可能崩溃的指令都链接到 catch 指令所在的 block 中，确保任意位置的崩溃都能正常走到 catch 中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//144f461c63929a79f8346da8a6731ecb.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;问题根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 4.0.26 版本，IRCode 翻译器新增了对 FALLTHROUGH 指令的处理，即新建一个 block 并&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;生成一条 GOTO 指令指向新的 block。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//941934987c5518db50e697aacc04d794.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根据前文的结论，GOTO 指令一样会被认为是类初始化相关的逻辑，因此 try-catch 语句块一样会导致最终多出来一个 new-instance 字节码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;为什么只升级 AGP 会导致&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 功能出问题？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我们在数个版本之前就已经单独升级了 R8，正好涵盖了 ApiModel 这个变更，但是直到近期才升级了 AGP。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以看到从 AGP7.3-beta 版本开始，才默认打开 ApiModel 功能，这就解释了为什么升级 AGP 之后才出现此崩溃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//09bde1db3ff6dd55f96188f2c6337b24.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、解决方案&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;禁用 ApiModel&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 通过牺牲些微包体，换来启动阶段类验证耗时，但是从他覆盖的类范围来看，对启动速度的收益微乎其微，因此可以直接通过配置开关关闭整个功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;System.setProperty("com.android.tools.r8.disableApiModeling",&amp;nbsp;"1")&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;虽说这是个实验中的功能，且逻辑相对独立，但是考虑到后续还有内联优化等操作，贸然关闭整个功能无法评估影响面，潜在的稳定性风险较高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;官方修复&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;该问题反馈给 R8 团队后，官方提供了临时规避的方案，即确保高版本 API 在单独的函数中调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://issuetracker.google.com/issues/441137561&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//358c6b1b9714ab22bdff45c27378289c.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;随后不久就提了 MR 针对 SurfaceTexture 这个类禁用了 ApiModel，并未彻底解决此问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://r8-review.googlesource.com/c/r8/+/109044&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//403f68ae953ddd19b67dc90602d69475.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;官方的修复方案比较权威，且影响面较小，但是并未彻底解决问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;自行修复&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果要修复此问题，关键是要将多余的 new-instance 指令替换成一个合适的触发类加载的指令，根据 java 官方文档里的介绍，只有 new 对象，访问静态的成员变量或者函数的指令才能安全的触发类加载，比较理想的方案是改成访问静态变量，但是很多类并没有静态变量，比如 SurfaceTexture 就没有。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//168eeaad61d7b9e162730708773e256d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;因此我们可以考虑结合 getStatic 指令和扫描 finalize 的方式来解决该问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//baa3977f849ce680a7684f38a4d68176.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;虽说可以通过打印日志来约束此改动的影响面，但毕竟要自行修改并编译 R8 的 jar 包，且需要自行长期维护，整体影响面还是偏大，对稳定性要求高的 App 不建议采用该方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;业务改造（推荐）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在前文中提到的外联函数生成处打印日志，即可感知到工程中有哪些类受 ApiModel 影响，如果数量不多，分别让业务改造其相关的写法，确保传参时是局部变量且无 try-catch/synchronized 语句块即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//a7fd6ee2c6b96d340b89116b8a76d5d5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;考虑到 App 整体的稳定性，最终我们采用了业务改造的方式绕过了此问题，并在 R8 异常代码处添加了日志告警来预防后续增量问题，并仿照官方 MR 中的写法补充了类的黑名单，用于应对无法编辑的三方库引入此问题的场景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、总结&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 Android 开发中，即使是 AGP、R8 这样的官方工具链升级，也要保持足够的警惕。毕竟 Android 生态太过复杂，再加上开发者们千奇百怪的代码写法，不论多么完善的测试流程都无法规避这类特定场景的 bug。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;这次的 ApiModel 外联优化问题就是一个很好的例子——它只在特定条件下才会暴露，但一旦出现就是必现的 native 崩溃。所以对于这种影响面无法评估的重大升级，还是需要经过足够长时间的独立灰度验证，才能合入主干分支。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;可扩展系统设计的黄金法则与 Go 语言实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;得物新商品审核链路建设分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;营销会场预览直通车实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;基于 TinyMce 富文本编辑器的客服自研知识库的技术探索和实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;AI 质量专项报告自动分析生成｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 永乐&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18690286</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18690286</guid>
      <pubDate>Tue, 02 Sep 2025 02:30:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>跨平台游戏引擎 Axmol-2.8.0 发布</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;em&gt;Axmol 2.8.0 版本是一个以错误修复和功能改进为主的次要 &lt;code&gt;LTS&lt;/code&gt; 长期支持版本，发布时间: 2025 年 9 月 1 日&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;🙏感谢所有对 axmol 项目的贡献者，包括财务赞助者：@scorewarrior、@peterkharitonov、@duong、@thienphuoc、@bingsoo、@asnagni、 @paulocoutinhox 以及 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsponsors%2Faxmolengine" target="_blank"&gt;历史赞助者&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;仓库地址&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;GitHub (官方): &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol" target="_blank"&gt;https://github.com/axmolengine/axmol&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Gitee (镜像): &lt;a href="https://gitee.com/simdsoft/axmol"&gt;https://gitee.com/simdsoft/axmol&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;错误修复&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;修复 #2669：由于 DriverGL 初始化失败，Windows 11 上的 Windows UWP 无法运行，由 @halx99 修复。&lt;/li&gt; 
 &lt;li&gt;修复 #2655：在 Android 场景包含 ImGui 图层时多点触控不起作用，由 @halx99 修复。&lt;/li&gt; 
 &lt;li&gt;修复 #2674：Linux 上最终应用未链接 OpenSSL，由 @halx99 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2675%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2675）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复从普通模式切换到 SDF 时标签渲染的 FontAtlas 错误，由 @halx99 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2629%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2629）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复 wasm 中 Device::getTextureDataForText 处理空白文本时抛出异常，由 @halx99 修复。&lt;/li&gt; 
 &lt;li&gt;修复 Linux 上当 LabelType 为 STRING_TEXTURE 时标签颜色不正确的问题，由 @halx99 修复。&lt;/li&gt; 
 &lt;li&gt;修复错误的 fmt::format_to 用法，由 @halx99 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2612%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2612）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复 genbindings.ps1 中 LLVM 版本截取逻辑问题，由 @halx99 修复。&lt;/li&gt; 
 &lt;li&gt;修复 Label 的 SDF 在字体缩放时的渲染问题及其他相关错误，由 @halx99 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2625%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2625）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复项目包含 Swift 代码时的编译错误，由 @halx99 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2632%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2632）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复 wasm Downloader 以错误权限打开文件（#2666），由 @AlexandreK38 修复（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2666%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2666）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修复在 CMake 4.1 以 Windows 为目标时「找不到汇编器」的构建失败问题，由 @halx99 修复。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;功能改进&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;改进 Apple iOS 平台的渲染视图创建，由 @halx99 提交（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2600%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2600）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;将 GLView 重命名为 RenderView，由 @halx99 提交（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2602%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2602）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;在 2.6.0 版本发布说明中增加 emsdk 降级提示，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改进 wasm 开发环境配置说明，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;将 &lt;code&gt;GLContextAttrs&lt;/code&gt; 重命名为 &lt;code&gt;GfxContextAttrs&lt;/code&gt;，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;更新 pull_request_template.md，作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2609%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2609）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改进 UTF-8 字符计数，移除 strlen 调用，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2614%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2614）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改进 UTF-8 文本处理，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;移除 sprintf/snprintf 存根，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2615%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2615）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改进 Android SDK 设置，Axmol 指定的 Android SDK 目录优先级：&lt;code&gt;android project local properties&lt;/code&gt; &amp;gt; &lt;code&gt;ANDROID_HOME&lt;/code&gt; &amp;gt; &lt;code&gt;ANDROID_SDK_ROOT&lt;/code&gt; &amp;gt; &lt;code&gt;axmol/tools/external/adt/sdk&lt;/code&gt;，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;更多头文件使用 pragma once，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2616%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2616）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;新增窗口尺寸限制设置支持，作者 @NgVThangBz（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2618%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2618）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;将 cpp-tests 中「Node: Label - New API」重命名为「Node: Label」，作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2627%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2627）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;更新 ImGui 多视口提示信息，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改进测试（统一 cpp-/lua- 测试中的菜单项命名），作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2640%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2640）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;将 SIMD 可用性检测移入独立的 CMake 文件，作者 @j-jorge（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2642%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2642）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;将 CMAKE_MSVC_DEBUG_INFORMATION_FORMAT 设为 Embedded，以解决 PDB 体积过大问题，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改进 NuGet 包管理，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2671%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2671）。&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;SDK 和工具更新&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;AGP: 8.11.0 =&amp;gt; 8.11.1&lt;/li&gt; 
 &lt;li&gt;gradle: 8.14.3 =&amp;gt; 9.0.0&lt;/li&gt; 
 &lt;li&gt;cmake: 4.0.3 =&amp;gt; 4.1.1&lt;/li&gt; 
 &lt;li&gt;webview2 (msedge): 1.0.992.28 =&amp;gt; 1.0.3045.78&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三方库更新&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;curl: 8.13.0 =&amp;gt; 8.15.0&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;发布文件 MD5 校验值&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;axmol-2.8.0.zip&lt;/code&gt;: 0100b8b0a73d25b0fb020590fc2e8a54&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;axmol-bs-2.8.0.zip&lt;/code&gt;: 114afdb56e2f507c831163e6cd6385e8&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;下载&lt;/h2&gt; 
&lt;h3&gt;GitHub&lt;/h3&gt; 
&lt;p&gt;&lt;em&gt;国内用户可尝试复制链接使用迅雷下载&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Freleases%2Fdownload%2Fv2.8.0%2Faxmol-2.8.0.zip" target="_blank"&gt;axmol-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Freleases%2Fdownload%2Fv2.8.0%2Faxmol-bs-2.8.0.zip" target="_blank"&gt;axmol-bs-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;百度网盘&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpan.baidu.com%2Fs%2F1-gWTCIqU8psNrgaLWNFqeg%3Fpwd%3Dj7p7" target="_blank"&gt;axmol-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpan.baidu.com%2Fs%2F1fBdSZZuctwLsEmJH4QgLMg%3Fpwd%3D3bbk" target="_blank"&gt;axmol-bs-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;SourceForge&lt;/h3&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Faxmol-engine.mirror%2Ffiles%2Fv2.8.0%2F" target="_blank"&gt;Axmol-2.8.0&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;本版亮点详解&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;NuGet 包管理优化&lt;/strong&gt;&lt;br&gt; 本版本对 NuGet 包管理进行了改进：Axmol 依赖的 Microsoft Edge WebView2 和 CppWinRT 包将在 CMake 配置阶段统一下载至 &lt;code&gt;&amp;lt;AX_ROOT&amp;gt;/cache/packages&lt;/code&gt; 目录。&lt;br&gt; 这样，即使删除 &lt;code&gt;build&lt;/code&gt; 目录，这些依赖包也无需重新下载。此前版本会将依赖下载到 &lt;code&gt;CMAKE_BINARY_DIR&lt;/code&gt;，导致清理构建目录后需重复下载。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;Axmol 项目最新动态&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;分支管理优化&lt;/strong&gt;&lt;br&gt; 为了让开发者更直观地选择适合生产环境的分支，仓库分支结构进行了调整：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;原 &lt;code&gt;dev&lt;/code&gt; 分支更名为 &lt;code&gt;release/2.x&lt;/code&gt;，作为 &lt;strong&gt;2.x LTS&lt;/strong&gt; 稳定维护与发布分支&lt;/li&gt; 
   &lt;li&gt;原 &lt;code&gt;wip-v3&lt;/code&gt; 分支更名为 &lt;code&gt;dev/v3&lt;/code&gt;，并设为默认开发分支（尚未正式发布，虽处于开发阶段，但依托 CI 持续集成，确保构建与运行始终可用）&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;目录结构优化（dev/v3）&lt;/strong&gt;&lt;br&gt; 将引擎核心代码目录 &lt;code&gt;core&lt;/code&gt; 重命名为 &lt;code&gt;axmol&lt;/code&gt;，并统一替换引擎代码中的 include 语句为 &lt;code&gt;#include "axmol/xxx/xxx.h"&lt;/code&gt;，以简化头文件引用路径。&lt;br&gt; 此调整不仅使代码结构更清晰，还能更方便地与其他代码库协同使用，减少头文件命名冲突的风险。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;渲染后端重构（dev/v3）&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dev/v3&lt;/code&gt; 分支对渲染后端进行了重构，新增 &lt;strong&gt;D3D11 渲染支持&lt;/strong&gt;。在 Windows 平台上，相比原 GLES API，性能提升约 &lt;strong&gt;13.6%&lt;/strong&gt;。&lt;br&gt; 同时，&lt;code&gt;axmol/renderer/backend&lt;/code&gt; 目录已重命名并迁移至 &lt;code&gt;axmol/rhi&lt;/code&gt;，详细说明可参考 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fwiki%2FAbout-RHI-in-axmol-v3" target="_blank"&gt;About-RHI-in-axmol-v3&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;clang-format 增强（dev/v3）&lt;/strong&gt;&lt;br&gt; 为保持引擎核心代码格式统一与规范，增强并完善了 &lt;code&gt;clang-format&lt;/code&gt; Lint CI，对每个 PR 自动检查代码格式是否符合规范。&lt;br&gt; 同时新增 &lt;code&gt;/clang-format&lt;/code&gt; 机器人评论指令：在 PR 评论中发送该指令，机器人将自动修正代码格式并推送至 PR 原分支（需确保提交 PR 时勾选「允许维护者编辑」选项）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369794</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369794</guid>
      <pubDate>Tue, 02 Sep 2025 02:24:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>我国智能算力规模达 788 百亿亿次/秒</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;人民日报北京 9 月 1 日电 &amp;nbsp;（记者刘温馨、郑洋洋）截至今年 6 月底，我国在用算力中心机架总规模达 1085 万标准机架，智能算力规模达 788 百亿亿次/秒 (EFLOPS)；存力规模超过 1680 艾字节 (EB)，相比 2023 年增长约 40%；已发布 1509 个大模型，在全球位居前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="334" src="https://oscimg.oschina.net/oscnet/up-f7c4902ec7cb7f48c81c629fb38170914e5.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;近日，中国算力平台完成山西、辽宁、上海、江苏、浙江、山东、河南、青海、宁夏、新疆 10 个省份分平台接入工作，实现「平台、主体、资源、生态、场景」全面贯通。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作为国家级综合性算力服务平台，中国算力平台集「供、需、服」于一体，可实现不同系统、平台和工具之间的兼容性和互操作性。截至 7 月底，平台运营层注册企业用户超 1000 家，入驻算力服务商逾 100 家，上架优质算力产品 110 余项，接入主流基础大模型和垂类模型 90 余个，累计沉淀数十亿条算力监测大数据。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369793</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369793</guid>
      <pubDate>Tue, 02 Sep 2025 02:23:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智谱上线 Claude Code 专属包月套餐，月费低至 20 元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智谱&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FJKSKSrjw3aqUODEN_LzRMg" target="_blank"&gt;宣布&lt;/a&gt;，自 9 月 1 日起推出 Claude Code 专属「GLM Coding Plan」限时套餐，月费低至 20 元。&lt;/p&gt; 
&lt;p&gt;该套餐适用于智谱最新旗舰模型 GLM-4.5 及 GLM-4.5-Air。用户可通过扫描活动海报二维码，或者登录智谱开放平台&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbigmodel.cn%2Fclaude-code" target="_blank"&gt;bigmodel.cn&lt;/a&gt;，直接购买并获取详细使用攻略。&lt;/p&gt; 
&lt;p&gt;首期主推 Claude Code，未来将拓展到更多 Coding 工具。目前，GLM-4.5 已接入包括 Claude Code、Cline、Gemini CLI、Grok CLI、CodeGeeX、Kilo Code、Roo Code、Trae 在内的多款主流编程工具，全面支持日常开发流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/101910_Nw8D_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369792</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369792</guid>
      <pubDate>Tue, 02 Sep 2025 02:20:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
