<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 简体中文</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已对该 RSS 进行格式化操作：中英字符之间插入空格、使用直角引号、标点符号修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 28 Aug 2025 07:42:49 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>IDC 全球 ICT 市场预测：AI 算力驱动未来五年 7.6 万亿美元市场</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;国际数据公司（IDC）发布了&lt;span&gt;最新&lt;/span&gt;的《全球 ICT 支出指南:行业与企业规模》。根据 IDC 的预测，到 2025 年，全球信息和通信技术 (ICT) 市场总投资规模将接近 5.9 万亿美元，并预计在 2029 年增至 7.6 万亿美元，五年复合增长率 (CAGR) 为 7.0%。特别是在中国，预计到 2029 年，市场规模将接近 8894.3 亿美元，同样保持 7.0% 的复合增长率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="380" src="https://oscimg.oschina.net/oscnet/up-ec3411c02528d7031bf6d5f495b813246aa.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;报告指出，中国的企业级 ICT 市场将在 2025 年达到 3147 亿美元，较 2024 年增长 14.3%，这个增长速度将持续高于 GDP 增速。从 2025 年开始，中国企业级 ICT 市场的年均增长率将达到 12.2%。在这一过程中，人工智能及算力的部署成为了市场增长的重要驱动力。生成式人工智能对算力的需求显著增加，推动了服务器市场的迅速发展。IDC 预测，2024 至 2029 年期间，中国企业级服务器和存储投资的年均复合增长率将达到 21.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，随着国产芯片的不断进步，未来算力的发展将会获得更多市场机遇。同时，人工智能技术正在逐步渗透至各个行业，推动了公有云基础设施即服务（IaaS）市场的快速增长。根据 IDC 的数据，中国 IaaS 支出的年均复合增长率将达到 14.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在国际市场方面，国内云服务厂商正在积极拓展海外市场，尤其是在云与人工智能结合的产品及服务领域。越来越多的云服务企业开始加快布局，积极输出在国内市场积累的经验和技术。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;从技术维度来看，IDC 对市场进行了详细的细分，涵盖了五大技术领域和 120 个细分技术。这些技术的广泛应用为中国企业级 ICT 市场的发展提供了广阔的前景。报告指出，硬件市场支出仍然&lt;span&gt;最大&lt;/span&gt;，预计到 2029 年将超过 2495.5 亿美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在软件和信息服务领域，随着企业数字化转型的加速，相关需求不断增长，预计到 2029 年，企业级软件市场将达到 1506.5 亿美元。教育行业也在积极探索 AI 应用，促进了市场的快速发展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368974</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368974</guid>
      <pubDate>Thu, 28 Aug 2025 07:39:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>可扩展系统设计的黄金法则与 Go 语言实践</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、&amp;nbsp;引言：为什么需要可扩展的系统？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在软件开发领域，需求变更如同家常便饭。一个缺乏扩展性的系统，往往在面对新功能需求或业务调整时，陷入「改一行代码，崩整个系统」的困境。可扩展性设计的核心目标是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;让系统能够以最小的修改成本，适应未来的变化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。对于 Go 语言开发者而言，利用其接口、并发、组合等特性，可以高效构建出适应业务演进的系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;本文将从架构设计原则、编码实践、架构实现模式、验证指标到演进路线，系统讲解如何设计一个「生长型」系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、可扩展系统的核心设计原则&lt;/h1&gt; 
&lt;p style="text-align:center"&gt;&lt;strong&gt;2.1&amp;nbsp; 开闭原则：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;对扩展开放，对修改关闭&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;开闭原则是面向对象设计的基石之一。它要求系统中的模块、类或函数，应该对扩展新功能保持开放，而对修改现有代码保持关闭。这意味着，当需求变更时，我们应通过添加新代码（如新增实现类）来满足需求，而不是修改已有的代码逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过接口（Interface）和组合（Composition）特性，天然支持开闭原则。接口定义了稳定的契约，具体实现可以独立变化；组合则允许通过「搭积木」的方式扩展功能，而无需修改原有结构。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：数据源扩展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设我们需要支持从不同数据源（如 MySQL、S3）读取数据，核心逻辑是「读取数据」，而具体数据源的实现可能频繁变化。此时，我们可以通过接口定义稳定的读取契约：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// DataSource 定义数据读取的稳定接口（契约）
type&amp;nbsp;DataSource&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Read(p []byte) (n&amp;nbsp;int, err&amp;nbsp;error) &amp;nbsp;// 读取数据到缓冲区
&amp;nbsp; &amp;nbsp; Close()&amp;nbsp;error&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 关闭数据源
}


// MySQLDataSource 具体实现：MySQL 数据源
type&amp;nbsp;MySQLDataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; db *sql.DB &amp;nbsp;// 依赖 MySQL 连接
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 实现 MySQL 数据读取逻辑（如执行查询、填充缓冲区）
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.QueryRow("SELECT data FROM table").Scan(&amp;amp;p)
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.Close() &amp;nbsp;// 关闭数据库连接
}


// S3DataSource 新增实现：S3 数据源（无需修改原有代码）
type&amp;nbsp;S3DataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *s3.Client &amp;nbsp;// 依赖 AWS S3 客户端
&amp;nbsp; &amp;nbsp; bucket&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 存储桶名
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 实现 S3 数据读取逻辑（如下载对象到缓冲区）
&amp;nbsp; &amp;nbsp; obj, err := s.client.GetObject(context.Background(), &amp;amp;s3.GetObjectInput{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Bucket: aws.String(s.bucket),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp;aws.String("data.txt"),
&amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;obj.Body.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;obj.Body.Read(p) &amp;nbsp;// 读取数据到缓冲区
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 客户端通常无需显式关闭，可根据需要实现
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;接口定义了所有数据源必须实现的方法（&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Read&lt;/span&gt;&lt;/span&gt;和&amp;nbsp;&lt;span style="background-color:#e5e5e5"&gt;Close&lt;/span&gt;），这是系统的「稳定契约」。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;当需要新增数据源（如 S3）时，只需实现该接口，无需修改现有的 MySQL 数据源或其他依赖&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;的代码。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;这一设计符合开闭原则：系统对扩展（新增 S3 数据源）开放，对修改（无需改动现有代码）关闭。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;2.2 模块化设计：低耦合、高内聚&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模块化设计的核心是将系统拆分为独立的功能模块，模块之间通过明确的接口交互。衡量模块化质量的关键指标是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;耦合度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块之间的依赖程度（越低越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;内聚度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块内部功能的相关性（越高越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理想情况下，模块应满足「高内聚、低耦合」：模块内部功能高度相关（如订单处理模块仅处理订单相关逻辑），模块之间通过接口通信（如订单模块通过接口调用支付模块，而非直接依赖支付模块的实现）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过包（Package）管理模块边界，通过接口隔离依赖。开发者可以通过以下方式提升模块化质量：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;单一职责原则&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：每个模块/包仅负责单一功能（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包处理订单逻辑，&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包处理支付逻辑）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;接口隔离&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模块间通过小而精的接口交互，避免暴露内部实现细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：订单模块的模块化设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// order/order.go：订单核心逻辑（高内聚）
package&amp;nbsp;order


// Order 表示一个订单（核心数据结构）
type&amp;nbsp;Order&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ID &amp;nbsp; &amp;nbsp;&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Items &amp;nbsp;[]Item
&amp;nbsp; &amp;nbsp; Status OrderStatus
}


// Item 表示订单中的商品项
type&amp;nbsp;Item&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ProductID&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Quantity &amp;nbsp;int
&amp;nbsp; &amp;nbsp; Price &amp;nbsp; &amp;nbsp;&amp;nbsp;float64
}


// OrderStatus 订单状态枚举
type&amp;nbsp;OrderStatus&amp;nbsp;string


const&amp;nbsp;(
&amp;nbsp; &amp;nbsp; OrderStatusCreated &amp;nbsp;OrderStatus =&amp;nbsp;"created"
&amp;nbsp; &amp;nbsp; OrderStatusPaid &amp;nbsp; &amp;nbsp; OrderStatus =&amp;nbsp;"paid"
&amp;nbsp; &amp;nbsp; OrderStatusShipped &amp;nbsp;OrderStatus =&amp;nbsp;"shipped"
)


// CalculateTotal 计算订单总金额（核心业务逻辑，无外部依赖）
func&amp;nbsp;(o *Order)&amp;nbsp;CalculateTotal()&amp;nbsp;float64&amp;nbsp;{
&amp;nbsp; &amp;nbsp; total :=&amp;nbsp;0.0
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, item :=&amp;nbsp;range&amp;nbsp;o.Items {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; total += item.Price *&amp;nbsp;float64(item.Quantity)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;total
}


// payment/payment.go：支付模块（独立模块）
package&amp;nbsp;payment


// PaymentService 定义支付接口（与订单模块解耦）
type&amp;nbsp;PaymentService&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 支付操作
}


// AlipayService 支付宝支付实现
type&amp;nbsp;AlipayService&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *alipay.Client &amp;nbsp;// 支付宝 SDK 客户端
}


func&amp;nbsp;(a *AlipayService)&amp;nbsp;Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 调用支付宝 API 完成支付
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;a.client.TradeAppPay(orderID, amount)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;包专注于订单的核心逻辑（如计算总金额），不依赖任何外部支付实现。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;包定义支付接口，具体实现（如支付宝、微信支付）独立存在。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;订单模块通过&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;PaymentService&lt;/span&gt;接口调用支付功能，与具体支付实现解耦。当需要更换支付方式时，只需新增支付实现（如&lt;span style="background-color:#e5e5e5"&gt;WechatPayService&lt;/span&gt;），无需修改订单模块。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、Go 语言的扩展性编码实践&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.1 策略模式：动态切换算法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;策略模式（Strategy Pattern）属于行为型设计模式，用于定义一系列算法（策略），并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用它的客户端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过接口实现策略的抽象，通过上下文（Context）管理策略的切换。这种模式适用于需要动态选择不同算法的场景（如缓存策略、路由策略）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：缓存策略的动态切换&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设系统需要支持多种缓存（Redis、Memcached），且可以根据业务场景动态切换。通过策略模式，可以将缓存的&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;和&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;操作抽象为接口，具体实现由不同缓存提供。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// cache/cache.go：缓存策略接口
package&amp;nbsp;cache


// CacheStrategy 定义缓存操作的接口
type&amp;nbsp;CacheStrategy&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 从缓存获取数据
&amp;nbsp; &amp;nbsp; Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 向缓存写入数据
}
// redis_cache.go：Redis 缓存实现


type&amp;nbsp;RedisCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *redis.Client &amp;nbsp;// Redis 客户端
&amp;nbsp; &amp;nbsp; ttl &amp;nbsp; &amp;nbsp;time.Duration &amp;nbsp;// 默认过期时间
}


func&amp;nbsp;NewRedisCache(client *redis.Client, ttl time.Duration)&amp;nbsp;*RedisCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;RedisCache{client: client, ttl: ttl}
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Get(context.Background(), key).Result()
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Set(context.Background(), key, value, ttl).Err()
}


// memcached_cache.go：Memcached 缓存实现
type&amp;nbsp;MemcachedCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *memcache.Client &amp;nbsp;// Memcached 客户端
}


func&amp;nbsp;NewMemcachedCache(client *memcache.Client)&amp;nbsp;*MemcachedCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;MemcachedCache{client: client}
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; item, err := m.client.Get(key)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;value&amp;nbsp;interface{}
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := json.Unmarshal(item.Value, &amp;amp;value); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;value,&amp;nbsp;nil
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; data, err := json.Marshal(value)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.client.Set(&amp;amp;memcache.Item{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;key,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Value: &amp;nbsp; &amp;nbsp; &amp;nbsp;data,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Expiration:&amp;nbsp;int32(ttl.Seconds()),
&amp;nbsp; &amp;nbsp; }).Err()
}


// cache_context.go：缓存上下文（管理策略切换）
type&amp;nbsp;CacheContext&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; strategy CacheStrategy &amp;nbsp;// 当前使用的缓存策略
}


func&amp;nbsp;NewCacheContext(strategy CacheStrategy)&amp;nbsp;*CacheContext {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;CacheContext{strategy: strategy}
}


// SwitchStrategy 动态切换缓存策略
func&amp;nbsp;(c *CacheContext)&amp;nbsp;SwitchStrategy(strategy CacheStrategy) {
&amp;nbsp; &amp;nbsp; c.strategy = strategy
}


// Get 使用当前策略获取缓存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Get(key)
}


// Set 使用当前策略写入缓存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Set(key, value, ttl)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;接口定义了缓存的核心操作（&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;），所有具体缓存实现必须实现该接口。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;RedisCache&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;MemcachedCache&lt;/span&gt;是具体的策略实现，分别封装了 Redis 和 Memcached 的底层逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;作为上下文，持有当前使用的缓存策略，并提供&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;方法动态切换策略。客户端只需与&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;交互，无需关心具体使用的是哪种缓存。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;当需要新增缓存类型（如本地内存缓存）时，只需实现&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口，无需修改现有代码；切换缓存策略时，只需调用&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;方法，客户端无感知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.2 中间件链：可插拔的请求处理流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;中间件（Middleware）是位于请求处理链中的组件，用于实现横切关注点（如日志记录、限流、鉴权）。中间件链模式允许将多个中间件按顺序组合，形成处理流水线，每个中间件可以处理请求、传递请求或终止请求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过函数类型（&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;func(http.HandlerFunc) http.HandlerFunc&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）定义中间件，通过组合多个中间件形成处理链。这种模式灵活且易于扩展，适用于 HTTP 服务的请求处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：HTTP 中间件链的实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设需要为 Web 服务添加日志记录、限流和鉴权功能，通过中间件链可以将这些功能解耦，按需组合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// middleware/middleware.go：中间件定义
package&amp;nbsp;middleware


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


// Middleware 定义中间件类型：接收 http.HandlerFunc，返回新的 http.HandlerFunc
type&amp;nbsp;Middleware&amp;nbsp;func(http.HandlerFunc)&amp;nbsp;http.HandlerFunc


// LoggingMiddleware 日志中间件：记录请求信息
func&amp;nbsp;LoggingMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; start := time.Now()
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 记录请求方法和路径
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request received:", r.Method, r.URL.Path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 调用下一个中间件或处理函数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 记录请求耗时
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request completed in:", time.Since(start))
&amp;nbsp; &amp;nbsp; }
}


// RateLimitMiddleware 限流中间件：限制请求频率
func&amp;nbsp;RateLimitMiddleware(next http.HandlerFunc, limiter *rate.Limiter)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!limiter.Allow() {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Too Many Requests", http.StatusTooManyRequests)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// AuthMiddleware 鉴权中间件：验证请求令牌
func&amp;nbsp;AuthMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; token := r.Header.Get("Authorization")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;token !=&amp;nbsp;"valid-token"&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Unauthorized", http.StatusUnauthorized)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// chain.go：中间件链组合
func&amp;nbsp;Chain(middlewares ...Middleware)&amp;nbsp;Middleware {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(final http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 反向组合中间件（确保执行顺序正确）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i :=&amp;nbsp;len(middlewares) -&amp;nbsp;1; i &amp;gt;=&amp;nbsp;0; i-- {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final = middlewares[i](final)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;final
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用示例：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：Web 服务入口
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"middleware"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 创建限流器：每秒允许 100 个请求，突发 10 个
&amp;nbsp; &amp;nbsp; limiter := rate.NewLimiter(100,&amp;nbsp;10)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 定义业务处理函数
&amp;nbsp; &amp;nbsp; handleRequest :=&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; w.Write([]byte("Hello, World"))
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 组合中间件链：日志 → 限流 → 鉴权
&amp;nbsp; &amp;nbsp; middlewareChain := middleware.Chain(
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.LoggingMiddleware,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.RateLimitMiddlewareWithLimiter(limiter),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.AuthMiddleware,
&amp;nbsp; &amp;nbsp; )
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 应用中间件链到处理函数
&amp;nbsp; &amp;nbsp; http.HandleFunc("/", middlewareChain(handleRequest))
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 启动服务
&amp;nbsp; &amp;nbsp; http.ListenAndServe(":8080",&amp;nbsp;nil)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;每个中间件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;LoggingMiddleware&lt;/span&gt;、&lt;span style="background-color:#e5e5e5"&gt;RateLimitMiddleware&lt;/span&gt;）专注於单一功能，通过&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;类型定义，确保接口统一。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函数将多个中间件按顺序组合，形成一个处理链。请求会依次经过日志记录、限流、鉴权，最后到达业务处理函数。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;新增中间件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;CORS&lt;/span&gt;跨域中间件）时，只需实现&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;类型，即可通过&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函数轻松加入处理链，无需修改现有中间件或业务逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、可扩展架构的实现模式&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.1 插件化架构：热插拔的功能扩展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件化架构允许系统在运行时动态加载、卸载插件，从而实现功能的灵活扩展。这种架构适用于需要支持第三方扩展或多租户定制的场景（如 IDE 插件、电商平台应用市场）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包支持动态库加载，结合接口定义插件契约，可以实现安全的插件化架构。插件需实现统一的接口，主程序通过接口调用插件功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：插件化系统的实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设需要开发一个支持插件的数据处理系统，主程序可以动态加载处理数据的插件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;json_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// plugin/interface.go：插件接口定义（主程序与插件共享）
package&amp;nbsp;plugin


// DataProcessor 定义数据处理插件的接口
type&amp;nbsp;DataProcessor&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Name()&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件名称（如"csv_parser"）
&amp;nbsp; &amp;nbsp; Process(input []byte) (output []byte, err&amp;nbsp;error) &amp;nbsp;// 处理数据
}


// plugin/csv_parser/csv_processor.go：CSV 处理插件（动态库）
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/csv"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"io"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
)


// CSVProcessor 实现 DataProcessor 接口
type&amp;nbsp;CSVProcessor&amp;nbsp;struct{}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Name()&amp;nbsp;string&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;"csv_parser"
}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Process(input []byte) ([]byte,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 解析 CSV 数据
&amp;nbsp; &amp;nbsp; r := csv.NewReader(bytes.NewReader(input))
&amp;nbsp; &amp;nbsp; records, err := r.ReadAll()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 转换为 JSON 格式输出
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;result []map[string]string
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, record :=&amp;nbsp;range&amp;nbsp;records {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row :=&amp;nbsp;make(map[string]string)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i, field :=&amp;nbsp;range&amp;nbsp;record {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row[fmt.Sprintf("col_%d", i)] = field
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result =&amp;nbsp;append(result, row)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; jsonData, err := json.Marshal(result)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;jsonData,&amp;nbsp;nil
}


// 插件的入口函数（必须命名为"Plugin"，主程序通过此函数获取插件实例）
var&amp;nbsp;Plugin plugin.DataProcessor = &amp;amp;CSVProcessor{}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：主程序（加载插件并调用）
package main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
)


func&amp;nbsp;main() {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件路径（假设编译为 so 文件）
&amp;nbsp; &amp;nbsp; pluginPath :=&amp;nbsp;filepath.Join("plugins",&amp;nbsp;"csv_parser.so")
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载插件
&amp;nbsp; &amp;nbsp; p, err :=&amp;nbsp;plugin.Open(pluginPath)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 获取插件实例（通过接口类型断言）
&amp;nbsp; &amp;nbsp; sym, err :=&amp;nbsp;p.Lookup("Plugin")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; processor, ok :=&amp;nbsp;sym.(plugin.DataProcessor)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic("插件未实现 DataProcessor 接口")
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 使用插件处理数据
&amp;nbsp; &amp;nbsp; inputData :=&amp;nbsp;[]byte("name,age
张三,20
李四,25")
&amp;nbsp; &amp;nbsp; output, err :=&amp;nbsp;processor.Process(inputData)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; fmt.Println(string(output)) &amp;nbsp;// 输出 JSON 格式数据
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;接口定义&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序定义&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，规定插件必须实现的方法（&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Process&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;插件实现&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：插件（如&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）实现&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，并导出名为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Plugin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的全局变量（主程序通过此变量获取插件实例）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;动态加载&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin.Open&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;加载插件，通过&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Lookup&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;获取插件实例，并转换为&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;主程序与插件解耦，插件的添加、删除或升级不影响主程序运行。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;支持热插拔：插件可以在运行时动态加载（需注意 Go 插件的局限性，如版本兼容性）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.2 配置驱动架构：外部化的灵活配置&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理论补充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置驱动架构（Configuration-Driven Architecture）通过将系统行为参数化，使系统可以通过修改配置（而非代码）来适应不同的运行环境或业务需求。这种架构适用于需要支持多环境（开发、测试、生产）、多租户定制或多场景适配的系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言的实现方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 语言通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/yaml&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等包支持配置文件的解析，结合&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;viper&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等第三方库可以实现更复杂的配置管理（如环境变量覆盖、热更新）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：配置驱动的数据库连接&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假设系统需要支持不同环境（开发、生产）的数据库配置，通过配置文件动态加载数据库连接参数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// config/config.go：配置结构体定义
package&amp;nbsp;config


// DBConfig 数据库配置
type&amp;nbsp;DBConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; DSN &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;string&amp;nbsp;`json:"dsn"`&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 数据库连接字符串
&amp;nbsp; &amp;nbsp; MaxOpenConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_open_conn"`&amp;nbsp;// 最大打开连接数
&amp;nbsp; &amp;nbsp; MaxIdleConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_idle_conn"`&amp;nbsp;// 最大空闲连接数
&amp;nbsp; &amp;nbsp; ConnTimeout&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"conn_timeout"`&amp;nbsp;&amp;nbsp;// 连接超时时间（秒）
}


// AppConfig 应用全局配置
type&amp;nbsp;AppConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Env &amp;nbsp;string&amp;nbsp; &amp;nbsp;`json:"env"`&amp;nbsp; &amp;nbsp;// 环境（dev/test/prod）
&amp;nbsp; &amp;nbsp; DB &amp;nbsp; DBConfig&amp;nbsp;`json:"db"`&amp;nbsp; &amp;nbsp;&amp;nbsp;// 数据库配置
&amp;nbsp; &amp;nbsp; Log &amp;nbsp;LogConfig&amp;nbsp;`json:"log"`&amp;nbsp; &amp;nbsp;// 日志配置
}


// LogConfig 日志配置
type&amp;nbsp;LogConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Level&amp;nbsp;string&amp;nbsp;`json:"level"`&amp;nbsp;// 日志级别（debug/info/warn/error）
&amp;nbsp; &amp;nbsp; Path &amp;nbsp;string&amp;nbsp;`json:"path"`&amp;nbsp;&amp;nbsp;// 日志文件路径
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// config/loader.go：配置加载器（支持热更新）
package&amp;nbsp;config


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/json"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"github.com/fsnotify/fsnotify"
)


// LoadConfig 加载配置文件
func&amp;nbsp;LoadConfig(path&amp;nbsp;string)&amp;nbsp;(*AppConfig,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; file, err := os.Open(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;file.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;cfg AppConfig
&amp;nbsp; &amp;nbsp; decoder := json.NewDecoder(file)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := decoder.Decode(&amp;amp;cfg); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;cfg,&amp;nbsp;nil
}


// WatchConfig 监听配置文件变化（热更新）
func&amp;nbsp;WatchConfig(path&amp;nbsp;string, callback&amp;nbsp;func(*AppConfig))&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; watcher, err := fsnotify.NewWatcher()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;watcher.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 监听配置文件所在目录
&amp;nbsp; &amp;nbsp; dir := filepath.Dir(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := watcher.Add(dir); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;event, ok := &amp;lt;-watcher.Events:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 仅处理写事件
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;event.Op&amp;amp;fsnotify.Write == fsnotify.Write {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 重新加载配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; newCfg, err := LoadConfig(path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("加载配置失败:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 触发回调（通知其他模块配置已更新）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(newCfg)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;err, ok := &amp;lt;-watcher.Errors:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("配置监听错误:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 保持程序运行
&amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{}
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：使用配置驱动的数据库连接
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"database/sql"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"config"
&amp;nbsp; &amp;nbsp; _&amp;nbsp;"github.com/go-sql-driver/mysql"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加载初始配置
&amp;nbsp; &amp;nbsp; cfg, err := config.LoadConfig("config.json")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 初始化数据库连接
&amp;nbsp; &amp;nbsp; db, err := sql.Open("mysql", cfg.DB.DSN)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;db.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 设置连接池参数（从配置中读取）
&amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(cfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(cfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(cfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 启动配置监听（热更新）
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err := config.WatchConfig("config.json",&amp;nbsp;func(newCfg *config.AppConfig)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 配置更新时，重新设置数据库连接池参数
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(newCfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(newCfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(newCfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println("配置已更新，数据库连接池参数调整")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 业务逻辑...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;设计说明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置结构化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;AppConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DBConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等结构体定义配置的层次结构，确保配置的清晰性和可维护性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;热更新支持&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;fsnotify&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;监听配置文件变化，触发回调函数重新加载配置，并更新系统状态（如数据库连接池参数）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;多环境适配&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过不同的配置文件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-dev.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-prod.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）或环境变量覆盖，实现不同环境的配置隔离。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优势：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系统行为的调整无需修改代码，只需修改配置文件，降低了维护成本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;支持动态调整关键参数（如数据库连接池大小、日志级别），提升了系统的灵活性和可观测性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、可扩展性的验证与演进&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.1 扩展性验证指标&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;为了确保系统具备良好的扩展性，需要从多个维度进行验证。以下是关键指标及测量方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;指标&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;目标值&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新功能开发周期&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;统计新增一个中等复杂度功能所需的时间（包括设计、编码、测试）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 2 人日&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;修改影响范围&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;统计修改一个功能时，需要修改的模块数量和代码行数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 5 个模块，&amp;lt; 500 行代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置生效延迟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量配置变更到系统完全应用新配置的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 100ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;并发扩展能力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量系统在增加 CPU 核数时，吞吐量的增长比例（理想为线性增长）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;吞吐量增长 ≥ 核数增长 × 80%&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件加载时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;测量动态加载一个插件的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 1 秒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.2 扩展性演进路线&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系统的扩展性不是一蹴而就的，需要随着业务的发展逐步演进。以下是一个典型的演进路线：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;graph TD
&amp;nbsp; &amp;nbsp; A[单体架构]&amp;nbsp;--&amp;gt;|垂直拆分| B[核心服务+支撑服务]
&amp;nbsp; &amp;nbsp; B&amp;nbsp;--&amp;gt;|接口抽象| C[模块化架构]
&amp;nbsp; &amp;nbsp; C&amp;nbsp;--&amp;gt;|策略模式/中间件| D[可扩展的分布式架构]
&amp;nbsp; &amp;nbsp; D&amp;nbsp;--&amp;gt;|插件化/配置驱动| E[云原生可扩展架构]&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 1&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;单体架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：初期业务简单，系统以单体形式存在。此时应注重代码的可读性和可维护性，为后续扩展打下基础。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 2&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心服务+支撑服务&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：随着业务增长，将核心功能（如订单、用户）与非核心功能（如日志、监控）拆分，降低耦合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 3&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模块化架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通过接口抽象和依赖倒置，将系统拆分为高内聚、低耦合的模块，支持独立开发和部署。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 4&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可扩展的分布式架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：引入策略模式、中间件链等模式，支持动态切换算法和处理流程，适应多样化的业务需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;阶段 5&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;云原生可扩展架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：结合容器化（Docker）、编排（Kubernetes）和 Serverless 技术，实现资源的弹性扩展和自动伸缩。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;六、结，语&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可扩展性设计是软件系统的「生命力」所在。通过遵循开闭原则、模块化设计等核心原则，结合策略模式、中间件链、插件化架构等 Go 语言友好的编码模式，开发者可以构建出适应业务变化的「生长型」系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，扩展性设计并非追求「过度设计」，而是在当前需求和未来变化之间找到平衡。建议定期进行架构评审，通过压力测试和代码分析（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;go mod graph&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;查看模块依赖）评估系统的扩展性健康度，及时调整设计策略。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最后，记住：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;优秀的系统不是完美的，而是能够持续进化的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。保持开放的心态，拥抱变化，才能在快速发展的技术领域中立于不败之地。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;得物新商品审核链路建设分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;营销会场预览直通车实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;基于 TinyMce 富文本编辑器的客服自研知识库的技术探索和实践｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;AI 质量专项报告自动分析生成｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;Rust 性能提升「最后一公里」：详解 Profiling 瓶颈定位与优化｜得物技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 悟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;关注得物技术，每周更新技术干货&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未经得物技术许可严禁转载，否则依法追究法律责任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18689869</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18689869</guid>
      <pubDate>Thu, 28 Aug 2025 07:29:39 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>腾讯混元开源端到端视频音效生成模型 HunyuanVideo-Foley</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;腾讯混元宣布开源端到端视频音效生成模型 HunyuanVideo-Foley，&lt;strong&gt;只需输入视频和文字，就能&lt;strong&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;/strong&gt;视频&lt;strong&gt;&lt;strong&gt;匹配&lt;/strong&gt;&lt;/strong&gt;电影级音效&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;比如，输入文本描述"With a faint sound as their hands parted, the two embraced, a soft 'mm' escaping between them.」&lt;/p&gt; 
&lt;p&gt;就会得到一个声色俱佳的视频：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/151052_IFKo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;技术亮点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;泛化能力强&lt;/strong&gt;：适配人物、动物、自然景观、卡通动画等各类视频，生成精准匹配画面的音频。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多模态语义均衡响应&lt;/strong&gt;：创新双流多模态扩散变换器（MMDIT）架构，平衡文本与视频语义，避免「顾文失画」问题。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;专业级音频保真度&lt;/strong&gt;：引入表征对齐（REPA）损失函数，抑制底噪，确保音频质量达到专业制作水准。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-8072afd58fae2af02917f8e2c87f453b039.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方介绍称，HunyuanVideo-Foley 不仅打破了 AI&amp;nbsp;生成的视频只能 「看」 不能 「听」 的局限，让无声 AI 视频成为历史，更是真正做到了 「看懂画面、读懂文字、配准声音」 ，带来沉浸式视听体验。这款音效生成工具可广泛应用于短视频创作、电影制作、广告创意和游戏开发等场景。&lt;/p&gt; 
&lt;p&gt;即日起，用户可在 Github,HuggingFace 下载模型，也可以在混元官网直接体验。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;体验入口：https://hunyuan.tencent.com/video/zh?tabIndex=0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;项目官网：https://szczesnys.github.io/hunyuanvideo-foley/&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;代码：https://github.com/Tencent-Hunyuan/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技术报告：https://arxiv.org/abs/2508.16930&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Hugging Face：https://huggingface.co/tencent/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368967</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368967</guid>
      <pubDate>Thu, 28 Aug 2025 07:12:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源 IDE 项目 Zed 完成 3200 万美元 B 轮融资</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源 IDE 项目 Zed &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fsequoia-backs-zed" target="_blank"&gt;宣布&lt;/a&gt;完成 3200 万美元 B 轮融资，由红杉资本领投，使其累计融资总额突破 4200 万美元。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-08cd4e91d1394290d041152f5dcb7ef153e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zed 最初因「极致性能的代码编辑器」受到关注，而此次融资背后的核心目标，是推动其向协作平台转型。团队提出的重点创新是 DeltaDB ——一种基于操作级别（edit-level）的全新版本控制系统，能够记录每一次字符修改，并与讨论、AI 建议深度绑定。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/150503_ItlB_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;与传统依赖 Git 快照的开发方式不同，DeltaDB 采用 CRDT 技术实现实时同步，并提供「字符级永久链接」，让代码讨论和历史演化可以直接嵌入到 IDE 中。Zed 希望借此打造出一个既能支撑团队协作，也能与 AI 高效共创的开发环境。&lt;/p&gt; 
&lt;p&gt;未来，Zed 与 DeltaDB 都将继续保持开源，并探索付费服务模式。同时，团队也在积极扩招，涵盖字体渲染、GPU Shader、编辑预测模型等方向。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368962/sequoia-backs-zed-32m</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368962/sequoia-backs-zed-32m</guid>
      <pubDate>Thu, 28 Aug 2025 07:06:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>开源代码编辑器 Zed 推出智能体集成协议：Agent Client Protocol (ACP)</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;开源编辑器 &lt;strong&gt;Zed&lt;/strong&gt; 宣布推出全新的 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fbring-your-own-agent-to-zed" target="_blank"&gt;&lt;strong&gt;Agent Client Protocol (ACP)&lt;/strong&gt;&lt;/a&gt;，这一协议让开发者可以在编辑器中自由接入任意第三方智能体（Agent），无需依赖官方内置工具。其理念类似于 &lt;strong&gt;语言服务器协议（LSP）&lt;/strong&gt;，通过解耦编辑器与智能体的交互方式，提供更灵活的扩展能力。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2f621ad18024ec580d997b820ea9139346e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/zed-industries/agent-client-protocol&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;首个落地案例是与 &lt;strong&gt;Google Gemini CLI&lt;/strong&gt; 的合作。Zed 已在终端中集成该工具，并通过 &lt;strong&gt;JSON-RPC&lt;/strong&gt; 替代传统的 ANSI 转义码，实现更精准的交互。这让开发者在 Zed 内获得了更流畅的 AI 编程体验：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;实时可视化的智能编辑体验&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多缓冲区（multi-buffer）查看和审阅&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在代码与智能体交互之间实现流畅导航&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-de6cc0bed05ae096d65f7a6d98e326feab1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，ACP 协议已经以 Apache 开源许可证发布，任何开发者都可基于它集成自己的 AI Agent。目前不仅 Zed 内置的智能体已迁移到这一统一框架，社区中也有人正探索将 ACP 带到 Neovim 等其他编辑器。这意味着所有为内置 Agent 开发的用户界面组件，也会开箱即用支持外部智能体。这种内核与 UI 的清晰分离显著加快了 Zed 的迭代速度。&lt;/p&gt; 
&lt;p&gt;Zed 团队表示，他们希望 ACP 能像 LSP 一样成为行业标准，推动形成一个开放、健康的智能体生态系统。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</guid>
      <pubDate>Thu, 28 Aug 2025 06:51:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>​腾讯开源智能体框架 Youtu-agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;腾讯近日发布了 Youtu-agent，这是一个灵活且高性能的框架，旨在构建、运行和评估自主智能体。该框架不仅在基准测试中表现出色，还提供了强大的智能体能力，如数据分析、文件处理和深入研究，所有这些功能都基于开源模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 的主要特点之一是其经过验证的性能。在 WebWalkerQA 基准测试中，该框架使用 DeepSeek-V3 系列模型达到了 71.47% 的准确率，而在 GAIA 基准测试中，达到了 72.8% 的准确率，显示出开源模型的强大潜力。通过优化框架，Youtu-agent 实现了低成本、便捷的部署，无需依赖封闭模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="398" src="https://oscimg.oschina.net/oscnet/up-df9ff0c7515f666fdb5c9d2c521ef538464.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，Youtu-agent 还支持多种实际应用场景，包括 CSV 分析、文献综述、个人文件整理，以及即将推出的播客和视频生成。它采用了灵活的架构，支持多样的模型 API，从 DeepSeek 到 gpt-oss 都可兼容，方便用户进行扩展和集成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="299" src="https://oscimg.oschina.net/oscnet/up-30ecda52cd4aeefc59ae83bccbe4a385e80.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在自动化和简化操作方面，Youtu-agent 引入了基于 YAML 的配置，用户可以通过简单的配置文件快速生成智能体。其内置的 「元智能体」 能够与用户交互，自动捕捉需求并生成配置。这种方法大大减少了手动设置的工作量，让用户能迅速上手。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 还拥有全异步执行的特性，极大地提高了性能效率，特别是在评估基准时的表现尤为突出。该框架不仅支持用户进行深入研究和数据收集，还能帮助开发者快速构建现实世界中的智能体应用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;为了帮助用户更快上手，Youtu-agent 提供了详细的文档和示例，用户只需简单的脚本便能运行多种智能体，极大地降低了学习曲线。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368953</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368953</guid>
      <pubDate>Thu, 28 Aug 2025 06:41:39 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>互联网标准组织发布新草案，提议网页标注 AI 使用情况</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;互联网工程任务组（IETF）近日发布《AI 内容披露头字段》（AI Content Disclosure Header）草案，提议在网页 HTTP 响应中新增可机读的 AI 使用标记，以说明 AI 在内容生成中的参与情况。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143226_iWtj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;https://www.ietf.org/archive/id/draft-abaris-aicdh-00.html&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;该草案拟为网页服务器响应添加一个新的 HTTP 头字段，用于标记人工智能在网页内容生成中的参与情况，目标是在保持低资源消耗的前提下，让搜索引擎、归档系统及浏览器等能够快速识别 AI 相关内容。&lt;/p&gt; 
&lt;p&gt;此头字段将包含五个主要信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;mode（AI 使用模式）&lt;/li&gt; 
 &lt;li&gt;model（使用的 AI 模型名称）&lt;/li&gt; 
 &lt;li&gt;provider（模型提供方）&lt;/li&gt; 
 &lt;li&gt;reviewed-by（内容审查人）&lt;/li&gt; 
 &lt;li&gt;date（生成或修改日期时间）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其中，mode 有四种取值：none（未使用 AI 生成或修改内容）、ai-modified（原有人类创作，经 AI 修改）、ai-originated（内容由 AI 生成，经人工编辑修改并审核）、machine-generated（几乎完全由 AI 生成，几乎无人为干预）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143133_J3wR_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;与现有的 AI 生成内容提示（如文字声明或图片/视频水印）不同，这一 HTTP 头字段无需依赖人工判断或解析复杂元数据文件，是完全机器可读的，可帮助搜索引擎进行更精准的索引，提升合规审查和数据归档的效率。&lt;/p&gt; 
&lt;p&gt;IETF 指出，这种标准化的标记方式可为网络爬虫、内容分析工具和归档系统提供低延迟的 AI 检测途径，减少不必要的计算和资源浪费。目前，该草案尚未成为正式标准，未来可能根据业界反馈进一步调整和扩展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368947</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368947</guid>
      <pubDate>Tue, 19 Aug 2025 06:32:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>研发提效新选择：Oinone 企业级产品化引擎正式开源 ，邀你体验</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;不少软件企业长期陷于「交付优先」，重复开发、规范难落地、资产难沉淀，既要应对高强度的个性化需求，又要维护统一标品，效率与质量常陷拉扯。解决的关键是将产品迭代与项目交付分离，在统一架构下沉淀可复用的模块与扩展包，让项目逐步转化为可升级、可规模化的标品&lt;/p&gt; 
&lt;p&gt;Oinone 产品化架构&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span style="color:#035dff"&gt;&lt;strong&gt;上层承接客户差异化与行业特性，中层直面市场的标准业务产品，底层沉淀通用能力与标准，确保迭代稳定&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。通过将需求拆解为模块与扩展包，实现标准化与个性化在同一框架内协同；依托低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无代码一体化、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;被集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;原则及国产化全栈支持，保障生态适配与持续演进。现场演示中，标准产品与个性化需求都能快速落地，开发到上线全程在统一规范下完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Oinone demo 体验&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Segoe UI&amp;quot;,Helvetica,Arial,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Liberation Sans&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Wenquanyi Micro Hei&amp;quot;,&amp;quot;WenQuanYi Zen Hei&amp;quot;,&amp;quot;ST Heiti&amp;quot;,SimHei,SimSun,&amp;quot;WenQuanYi Zen Hei Sharp&amp;quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:856px; word-break:initial; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;演示环境&lt;/th&gt; 
   &lt;th&gt;相关视频&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fdemo.oinone.top" target="_blank"&gt;⚡ 直达演示环境&lt;/a&gt;&lt;br&gt; ☕ 账号：admin&lt;br&gt; ☕ 密码：admin&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt; &lt;p&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEts%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 1. [数式 Oinone] #产品化演示# 后端研发与无代码辅助&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1DoMizbECt%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 2. [数式 Oinone] #产品化演示# 前端开发&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RDMizYELg%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 3. [数式 Oinone] #个性化二开# 后端逻辑&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYED1%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 4. [数式 Oinone] #个性化二开# 前端交互&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEdF%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 5. [数式 Oinone] #个性化二开# 无代码模式&lt;/a&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h1&gt;6.2.0 版本正式开源&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;Gitee: 
  &lt;ul&gt; 
   &lt;li&gt;后端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250822 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;修复集成设计器新建或复制 API 时未正确记录日志的问题&lt;/li&gt; 
 &lt;li&gt;修复发布为开放接口时出入参转换异常的问题&lt;/li&gt; 
 &lt;li&gt;修复开放接口调用集成接口时日志保存异常的问题&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250818 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;前端版本升级&lt;/li&gt; 
 &lt;li&gt;集成应用-集成接口新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器集成接口详情页面新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器 body 参数支持保留空值功能&lt;/li&gt; 
 &lt;li&gt;集成设计器的集成接口发布为开放接口后，删除时进行二次确认提示&lt;/li&gt; 
 &lt;li&gt;集成设计器数据库连接支持断开连接和重新连接功能（支持分布式启停）&lt;/li&gt; 
 &lt;li&gt;集成设计器 WebService API 支持 xml 解析功能&lt;/li&gt; 
 &lt;li&gt;修复元数据继承计算未正确处理由界面设计器创建的提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制视图到子模型时无法复制提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制时切换模型时验证不通过的问题&lt;/li&gt; 
 &lt;li&gt;修复从上游生成的菜单无法正确导出的问题&lt;/li&gt; 
 &lt;li&gt;修复集成设计器导出时出现 getDriver 序列化异常的问题&lt;/li&gt; 
 &lt;li&gt;修复数据可视化快捷日期选择错误的问题&lt;/li&gt; 
 &lt;li&gt;开放 dataflow-api 和 eip-designer-api 包&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;doc 教程文档：https://guide.oinone.top/zh-cn/DevManual/Tutorials/#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0%E5%90%8E%E7%AB%AF%E5%92%8C%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368943</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368943</guid>
      <pubDate>Tue, 19 Aug 2025 06:26:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>阿里云百炼部分模型将从限时免费改为限时额度</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里云百炼&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aliyun.com%2Fnotice%2F117503" target="_blank"&gt;宣布&lt;/a&gt;，部分模型调用计费将于北京时间 2025 年 8 月 29 日 03:00 起从限时免费变更为发放限时免费额度。用户将享受 100 万的免费 token 额度，免费额度用尽后平台将自动停止服务。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;本次影响模型范围如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="168" src="https://oscimg.oschina.net/oscnet/up-d9dd38cf3830efd579ab292f1f353d732f6.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368942</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368942</guid>
      <pubDate>Tue, 19 Aug 2025 06:23:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>理想汽车可以写游戏代码，还能直接在车机上玩</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;理想汽车产品线负责人@老汤哥 Tango 在微博发布」理想同学「写游戏代码的视频，从响应需求到游戏生成持续了约 3 分钟时间。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-581559e21893b110ff447556e3176c9d526.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-004e5ec1d909771531577171d2f8b3a2f8a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ff70aabed01e3e77bca5848c5bc95395622.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-786b0c2666f658ebc6f9a070a9111477fa8.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-eda646532086b95eb00c99dde042c4f0d64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;据理想官方介绍，理想同学手机、网页端已正式接入 DeepSeek R1-0528 最新版，切换「DeepSeek 模型」并开启「深度思考」模式即可体验最新的 AI 问答、创作能力。&lt;/p&gt; 
&lt;p&gt;据悉，更新后的 R1 模型在数学、编程与通用逻辑等多个基准测评中取得了当前国内所有模型中首屈一指的优异成绩，并且在整体表现上已接近其他国际顶尖模型，如 o3 与 Gemini-2.5-Pro。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368941</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368941</guid>
      <pubDate>Tue, 19 Aug 2025 06:22:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>a16z 最新 AI 报告：移动端 Top50 的应用中 22 款由中国开发</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;根据风险投资公司 Andreessen Horowitz 最新发布的一份专注于消费者 AI 领域的新&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fa16z.com%2F100-gen-ai-apps-5%2F" target="_blank"&gt;报告&lt;/a&gt;， ChatGPT 的竞争对手，如谷歌的 Gemini、xAI 的 Grok 以及 Meta AI，正在缩小与 ChatGPT 的差距。&lt;/p&gt; 
&lt;p&gt;该报告已是第五次发布。14 家公司第五次出现在顶级 AI 产品榜单上：ChatGPT、Perplexity、Poe、Character AI、Midjourney、Leonardo、Veed、Cutout、ElevenLabs、Photoroom、Gamma、QuillBot、Civitai 和 Hugging Face。&lt;/p&gt; 
&lt;p&gt;&lt;img height="288" src="https://oscimg.oschina.net/oscnet/up-504e271a3f148910434873e07a715ea1259.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该公司指出，除第一份报告外，其他五家公司都出现在了报告中，包括 Claude、DeepAI、Janitor AI、Pixelcut 和 Suno，分别代表通用人工智能应用、陪伴、图像编辑和音乐生成。&lt;/p&gt; 
&lt;p&gt;&lt;img height="305" src="https://oscimg.oschina.net/oscnet/up-2e8fb44cb4232566939732e5f0076528ea9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在本系列报告中，谷歌首次在顶级生成式 AI 消费网络产品榜单上增加了四个席位，分别是 Gemini、AI Studio、NotebookLM 和 Google Labs。这些产品现在拥有各自独立的域名，因此可以分别跟踪它们的增长情况。&lt;/p&gt; 
&lt;p&gt;&lt;img height="378" src="https://oscimg.oschina.net/oscnet/up-752ac9ec98d43bf0cfd8c70cd9bc8752cbd.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，在移动设备上，排名第二的应用 Gemini 正在缩小与排名第一的应用 ChatGPT 的差距，但月活跃用户数几乎只有后者的一半。Gemini 的 AI 技术在 Android 平台上的应用更为广泛，占据了近 90% 的月活跃用户群。在网页端，Gemini 也仅次于 ChatGPT，排名第二，约占 ChatGPT 访问量的 12%。&lt;/p&gt; 
&lt;p&gt;&lt;img height="323" src="https://oscimg.oschina.net/oscnet/up-e433ed7d554499571d95f76fdf1bb182f1c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;该公司的 AI Studio 是一款面向开发人员的 &lt;span style="color:#212623"&gt;sandbox&lt;/span&gt;，用于使用 Gemini 模型进行构建，进入了十大 AI 网络产品榜单，位居第十位；NotebookLM 排名第十三。&lt;/p&gt; 
&lt;p&gt;&lt;img height="335" src="https://oscimg.oschina.net/oscnet/up-1d046af086fb1c731602a315ddfd7f282c1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Grok 在网页端排名第四，移动端排名第 23。考虑到 Grok 从 2024 年底还没有独立应用（在 X 上首次推出）到现在拥有多达 2000 万月活跃用户，这是一个快速的增长。2025 年 7 月， Grok 4 发布后，Grok 的用户增长了近 40% 。&lt;/p&gt; 
&lt;p&gt;&lt;img height="326" src="https://oscimg.oschina.net/oscnet/up-7276f5b0dc0753d758a96bbb20c8d2c2bba.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Meta 的通用助手在网络上排名第 46 位，与 3 月份相同，但它并未进入顶级移动 AI 应用榜单。部分原因是，有消息称 Meta AI 在未经用户知情同意的情况下，公开分享了部分用户的帖子。&lt;/p&gt; 
&lt;p&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-490ce7eaf61c586775a809535a4137b600c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;DeepSeek 和 Claude 在移动端的增长也趋于平缓，前者从峰值下降了 22%。在网页端，DeepSeek 的下降幅度更大，较 2025 年 2 月的峰值下降了 40% 以上。然而，Perplexity 和 Claude 仍在继续增长。&lt;/p&gt; 
&lt;p&gt;其他中国 AI 开发者也进入了网络榜单前 20 名，包括排名第 9 的阿里巴巴 AI 助手夸克（移动榜单第 47 位）；排名第 12 的豆宝（移动榜单第 4 位）；以及排名第 17 的 Kimi。这些公司都拥有中文网站，75% 的流量来自中国。&lt;/p&gt; 
&lt;p&gt;Web 榜单上还有七家公司在中国发展，但将其 AI 技术出口到全球：DeepSeek、Hailuo、Kling、SeaArt、Cutout Pro、Manus 和 Monica。&lt;/p&gt; 
&lt;p&gt;在移动端，排名前 50 的应用中有 22 款由中国开发，但主要在中国使用的只有 3 款。其中，排名靠前的包括美图（Photo &amp;amp; Video Editor, BeautyPlus, BeautyCam, Wink 和 Airbrush）、字节跳动（豆宝和 Cici）、Gauth 和 Hypic。&lt;/p&gt; 
&lt;p&gt;氛围编码初创公司 Lovable 和 Replit 此次首次亮相主榜单，而它们在 a16z 今年 3 月发布的榜单中均未入选。&lt;/p&gt; 
&lt;p&gt;&lt;img height="189" src="https://oscimg.oschina.net/oscnet/up-05006cf5ea2bdd595a0a2b22c96ea9aa400.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Andreessen Horowitz 还花时间列举了即将跻身顶级 AI 应用程序榜单的 AI 应用程序，包括网络上的 PixAI、Bolt、Blackbox AI、Clipchamp 和 Getliner，以及移动设备上的 Talkie、Seekee、Photo AI、AI Mirror 和 Arvin。&lt;/p&gt; 
&lt;p&gt;该公司指出，本月报告中的移动榜单中新上榜的应用（14 个）已经比以前更多，因为两个应用商店早已严厉打击 ChatGPT 的模仿者和克隆产品，从而让更多原创应用找到了立足之地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368938</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368938</guid>
      <pubDate>Tue, 19 Aug 2025 06:13:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Meta 计划推出超级政治行动委员会，力挺 AI 监管轻松化</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 公司计划成立一个新的超级政治行动委员会（PAC），旨在支持那些倡导轻松化人工智能 (AI) 监管的加州候选人。这一消息的发布恰逢其他硅谷巨头，如安德森・霍洛维茨和 OpenAI 的格雷格・布罗克曼，共同承诺为一个新的支持 AI 的超级&amp;nbsp;PAC 提供 1 亿美元的资金。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="242" src="https://oscimg.oschina.net/oscnet/up-e60c86bbcc18a7651619abeab3ca5d668e1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;据悉，Meta 将在其新成立的 PAC 「加州经济转型动员」（Mobilizing Economic Transformation Across California）中投入数千万美元。Meta 公共政策副总裁兼新 PAC 负责人布赖恩・瑞斯 (Brian Rice) 表示，萨克拉门托的监管环境可能会抑制创新，阻碍 AI 进步，并危及加州在科技领域的领导地位。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年早些时候，Meta 的游说力量曾针对加州州参议员斯科特・维纳（Scott Wiener）的 SB-53 法案进行干预，该法案要求 AI 公司公布安全和安保协议，并在发生安全事件时发布报告。去年，Meta 还帮助阻止了广受期待的《儿童在线安全法案》。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 已经向各党派的下级候选人捐款，而这个新 PAC 的成立则表明了其希望在包括 2026 年下任州长选举在内的州级选举中产生影响的意图。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368931</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368931</guid>
      <pubDate>Tue, 19 Aug 2025 05:39:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>正式版发布：Oinone 6.2.0 版本 Oinone 正式开源，邀您体验</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;6.2.0 版本&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Gitee: 
  &lt;ul&gt; 
   &lt;li&gt;后端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250822 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;修复集成设计器新建或复制 API 时未正确记录日志的问题&lt;/li&gt; 
 &lt;li&gt;修复发布为开放接口时出入参转换异常的问题&lt;/li&gt; 
 &lt;li&gt;修复开放接口调用集成接口时日志保存异常的问题&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250818 升级内容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;镜像版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;后端版本升级:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;前端版本升级&lt;/li&gt; 
 &lt;li&gt;集成应用-集成接口新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器集成接口详情页面新增测试功能&lt;/li&gt; 
 &lt;li&gt;集成设计器 body 参数支持保留空值功能&lt;/li&gt; 
 &lt;li&gt;集成设计器的集成接口发布为开放接口后，删除时进行二次确认提示&lt;/li&gt; 
 &lt;li&gt;集成设计器数据库连接支持断开连接和重新连接功能（支持分布式启停）&lt;/li&gt; 
 &lt;li&gt;集成设计器 WebService API 支持 xml 解析功能&lt;/li&gt; 
 &lt;li&gt;修复元数据继承计算未正确处理由界面设计器创建的提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制视图到子模型时无法复制提交动作的问题&lt;/li&gt; 
 &lt;li&gt;修复界面设计器复制时切换模型时验证不通过的问题&lt;/li&gt; 
 &lt;li&gt;修复从上游生成的菜单无法正确导出的问题&lt;/li&gt; 
 &lt;li&gt;修复集成设计器导出时出现 getDriver 序列化异常的问题&lt;/li&gt; 
 &lt;li&gt;修复数据可视化快捷日期选择错误的问题&lt;/li&gt; 
 &lt;li&gt;开放 dataflow-api 和 eip-designer-api 包&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368921</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368921</guid>
      <pubDate>Tue, 19 Aug 2025 04:21:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>英伟达单季营收 467 亿美元暴涨 56%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;英伟达（&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnvidianews.nvidia.com%2Fnews%2Fnvidia-announces-financial-results-for-second-quarter-fiscal-2026" target="_blank"&gt;公布&lt;/a&gt;截至 2025 年 7 月 27 日的第二季度营收为 467 亿美元，环比增长 6%，同比增长 56%。NVIDIA Blackwell 数据中心营收环比增长 17%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第二季度，中国客户未售出 H20 芯片。NVIDIA 受益于此前释放的 1.8 亿美元 H20 库存，这得益于此前向中国境外客户无限制销售约 6.5 亿美元的 H20 芯片。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 毛利率分别为 72.4% 和 72.7%。若不计入 1.8 亿美元释放，本季度非 GAAP 毛利率应为 72.3%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 稀释每股收益分别为 1.08 美元和 1.05 美元。若不计 1.8 亿美元释放及相关税费影响，本季度非 GAAP 稀释每股收益为 1.04 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 创始人兼首席执行官黄仁勋表示：「Blackwell 是全世界翘首以盼的 AI 平台，它实现了非凡的跨越式发展——Blackwell Ultra 的产量正在全速提升，市场需求也异常旺盛。NVIDIA NVLink 机架级计算技术具有革命性，它的到来恰逢推理 AI 模型推动训练和推理性能数量级提升的时代。AI 竞赛已拉开帷幕，而 Blackwell 正是这场竞赛的核心平台。」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2026 财年上半年，NVIDIA 以股票回购和现金股息的形式向股东返还了 243 亿美元。截至第二季度末，公司剩余的股票回购授权金额为 147 亿美元。2025 年 8 月 26 日，董事会批准公司额外增加 600 亿美元的股票回购授权，且该授权金额无有效期。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 将于 2025 年 10 月 2 日向 2025 年 9 月 11 日登记在册的所有股东支付下一季度现金股息，每股 0.01 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="175" src="https://oscimg.oschina.net/oscnet/up-0884edd1756e5c3e624f756bf9373b7e007.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bf88c6496d006ca5fa7f48b7ede76abe46b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 对 2026 财年第三季度的展望如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc"&gt; 
 &lt;li&gt;预计营收为 540 亿美元，上下浮动 2%。该公司在展望中未考虑任何 H20 对华出口。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 毛利率分别为 73.3% 和 73.5%，上下浮动 50 个基点。公司预计今年年底的非 GAAP 毛利率将保持在 70% 左右。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 运营费用分别约为 59 亿美元和 42 亿美元。预计 2026 财年全年运营费用增长率将达到 30% 以上。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 其他收入和支出约为 5 亿美元的收入，不包括非流通股本证券和公开持有的股权证券的损益。&lt;/li&gt; 
 &lt;li&gt;预计 GAAP 和非 GAAP 税率为 16.5%，上下浮动 1%，不包括任何单项项目。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368915</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368915</guid>
      <pubDate>Tue, 19 Aug 2025 03:44:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>智谱开源项目阅读工具 Zread 发布更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/news/361635" target="_blank"&gt;Zread&lt;/a&gt; 是智谱为帮助用户阅读和理解复杂开源项目打造的 AI 工具，其功能类似于 Cognition 推出的 DeepWiki，优点是支持中文，目前已经索引了大部分热门开源项目，冷门代码仓库可以申请发起索引。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-47cb47c2059cdf185a53799496a0fbd8091.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zread 近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FZread_ai%2Fstatus%2F1960734929639145494" target="_blank"&gt;发布更新&lt;/a&gt;增加了三大功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;根据用户设定的主题，提供个性化的代码仓库推荐&lt;/li&gt; 
 &lt;li&gt;支持查看 AI 回答背后的搜索来源，增加透明度&lt;/li&gt; 
 &lt;li&gt;支持一键刷新仓库，以方便用户获取最新的代码更新&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;体验：&lt;em&gt;https://zread.ai/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368914</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368914</guid>
      <pubDate>Tue, 19 Aug 2025 03:43:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>OpenSearch Software Foundation 一周年庆</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;作为 OpenSearch 项目的中立平台，&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;OpenSearch&amp;nbsp;&lt;/span&gt;&lt;span&gt;Software Foundation 庆祝其在 Linux 基金会下成立一周年。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;公告称，成立首年，基金会致力于发展和壮大 OpenSearch 开源平台，推动 AI 驱动的搜索、可观测性和分析技术。通过持续的功能开发、社区参与扩大和行业融合，OpenSearch 已成为现代数据驱动应用的基础技术。随着行业向 Agentic AI 转型，OpenSearch Software Foundation 将继续打造高性能、完全开源的信息检索平台，支持更快、更高效的 AI 开发与实时洞察。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;img height="264" src="https://oscimg.oschina.net/oscnet/up-e3edcc23f4749032fea4ca2f17aba64a082.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;Linux 基金会法律与战略项目高级副总裁 Mike Dolan 表示：「OpenSearch 在 Linux 基金会下的首年进展，展现了开放协作在应对现代数据挑战中的力量。项目增长和社区活跃证明了开源在现代搜索和分析基础设施中的关键作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;自 2024 年 9 月基金会成立以来，OpenSearch 项目下载量同比增长 78%，累计下载超过 10 亿次。首年成果包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;社区活跃度提升，超 400 家活跃贡献组织，贡献超过 8800 次&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;全球协作增强，美国、德国、英国、澳大利亚和印度贡献最多&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;会员扩展至 16 家新组织，新增 ByteDance、DataStax、DTEX 和 Seacom Srl&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;组建由 15 名成员组成的技术指导委员会，涵盖 Aryn、AWS、ByteDance、IBM、Paessler、Salesforce、SAP 和 Uber 等企业与独立机构&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;3.0、3.1 和 3.2 版本亮点：&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量引擎和 Agentic AI 能力增强，推动生成式 AI 创新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量数据库功能增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过 Model Context Protocol (MCP) 和 GPU 加速，支持原生 Agentic AI，简化开发部署&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;支持新型 FP16、Byte 和二进制向量类型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提高资源利用效率，构建更广泛的 GPU 加速应用&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本引入的实验性查询类型，支持自然语言交互，触发基于 Agent 的查询理解、规划与执行&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 记忆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 实验功能，支持 AI 代理利用语义搜索调用历史上下文，提升后续会话质量&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;混合搜索速度和效率提升，实现实时洞察&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;搜索性能增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：OpenSearch 3.2 查询速度较 1.3 版本快 11 倍，混合搜索算法提升查询速度达 65%，吞吐量提升 3.5 倍&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;gRPC 支持正式发布&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：加快数据传输与处理效率&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;近似查询框架升级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本提升分页搜索、实时仪表盘和分析工作负载响应速度，扩展所有数值字段类型的近似查询能力&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;流式聚合功能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 实验功能，基于流式传输，优化资源分配，实现协调器单点扩展&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;高级可观测性功能提升准确性与效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;跨集群 Trace 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支持企业跨集群无缝追踪分析&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Piped Processing Language (PPL) 升级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升复杂查询性能和准确性，简化复杂日志分析流程&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;平台现代化，助力未来社区协作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc; margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;升级 Lucene 10&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升性能和可维护性，支持日益壮大的开源开发者社区贡献&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;OpenSearch Software Foundation 治理委员会主席、AWS 产品管理总监 Carl Meadows 表示：「进入第二年，我们将继续发力，打造 AI 时代最强大的开源搜索、分析和可观测性平台。社区和会员的坚实基础让我们能应对行业挑战，持续交付开发者和企业信赖的技术。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;行业领导者贡献亮点：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;ByteDance&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为 OpenSearch k-NN 贡献派生源功能，并优化分段复制协议性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;IBM DataStax&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献 JVector 引擎，为向量搜索提供纯 Java 实现并支持 AstraDB 集成&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Intel&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献 SIMD 支持，提升 k-NN 在支持硬件上的性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;SAP&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：推动 FIPS 合规支持，满足特定安全规范需求&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Uber&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：贡献基于拉取的采集方式，简化客户端配置，支持 OpenSearch 直接集成现有系统&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368909</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368909</guid>
      <pubDate>Tue, 19 Aug 2025 03:35:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>Linux 内核贡献者借助 AI 判断是否回退补丁到稳定版本</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Linux 长期支持（LTS）分支的维护工作正在尝试引入生成式 AI 技术，以帮助判断哪些补丁需要回退到稳定版本。&lt;/p&gt; 
&lt;p&gt;目前，开发者通常会在补丁中添加 「CC: stable」 标签，提醒维护者将其回退。但不少补丁并未明确标注，导致 LTS 维护负担较重。为此，Linux LTS 联合维护者、现任 NVIDIA 工程师 Sasha Levin &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fstable%2F20250825121505.2983941-5-sashal%40kernel.org%2F" target="_blank"&gt;尝试&lt;/a&gt;了基于大语言模型（LLM）的新流程，让 AI 自动分析补丁的重要性，并生成回退建议与说明。&lt;/p&gt; 
&lt;p&gt;在近期提交的部分补丁中，已经可以看到 AI 生成的提示，例如 「Backport Status: YES」，并附带理由说明，尽管 Levin 也坦言这些解释可能并不完全可靠。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45e58d6544cd83524a2549342d46ca5c1fc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;业内认为，这种做法有望显著减轻维护者压力，加快企业用户获取稳定更新的速度。但也有人担心 AI 可能出现「幻觉」，错误推荐不适合回退的补丁，从而将风险引入 LTS 版本。因此，社区正在讨论如何在流程中明确标注 AI 的参与，并制定相关规范，确保透明与安全。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</guid>
      <pubDate>Tue, 19 Aug 2025 03:31:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
    <item>
      <title>微语 0.9.3 发布，智能客服 AI Agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;微语 - 重复工作自动化&lt;/h1&gt; 
&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;企业级多租户团队协作工具，免费开源 N 件套：企业 IM、在线客服、企业知识库/帮助文档、客户之声、工单系统、AI 对话、工作流、呼叫中心、视频客服、开放平台。&lt;/p&gt; 
&lt;h2&gt;介绍&lt;/h2&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/team/readme.zh.md"&gt;企业 IM&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;局域网即时通讯&lt;/li&gt; 
 &lt;li&gt;企业成员管理&lt;/li&gt; 
 &lt;li&gt;聊天记录监控&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/service/readme.zh.md"&gt;全渠道客服&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;多渠道接入&lt;/li&gt; 
 &lt;li&gt;人工客服&lt;/li&gt; 
 &lt;li&gt;客服 Agent 智能体，对接自有数据，自动执行操作&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/kbase/readme.zh.md"&gt;知识库&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;对接大模型&lt;/li&gt; 
 &lt;li&gt;自定义知识库&lt;/li&gt; 
 &lt;li&gt;Function Calling&lt;/li&gt; 
 &lt;li&gt;Mcp&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/ticket/readme.zh.md"&gt;工单系统&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;工单管理&lt;/li&gt; 
 &lt;li&gt;工单 SLA 管理&lt;/li&gt; 
 &lt;li&gt;工单统计和报表&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/ai/readme.zh.md"&gt;AI Agent&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;Ollama/DeepSeek/ZhipuAI/...&lt;/li&gt; 
 &lt;li&gt;智能体&lt;/li&gt; 
 &lt;li&gt;工作流&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/core/readme.workflow.md"&gt;工作流&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;自定义表单&lt;/li&gt; 
 &lt;li&gt;自定义流程&lt;/li&gt; 
 &lt;li&gt;工单流程可视化&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/voc/readme.zh.md"&gt;客户之声&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;意见反馈&lt;/li&gt; 
 &lt;li&gt;服务投诉&lt;/li&gt; 
 &lt;li&gt;问卷调查&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/freeswitch/readme.zh.md"&gt;呼叫中心&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于 FreeSwitch 的专业呼叫平台&lt;/li&gt; 
 &lt;li&gt;支持来电弹屏、自动分配、通话录音&lt;/li&gt; 
 &lt;li&gt;数据统计，语音与文字服务无缝集成&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/webrtc/readme.zh.md"&gt;视频客服&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;基于 WebRTC 技术的高清视频通话&lt;/li&gt; 
 &lt;li&gt;支持一键视频对话与屏幕共享&lt;/li&gt; 
 &lt;li&gt;适用于需要直观展示的服务场景&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/readme.md"&gt;开放平台&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;提供完整的 RESTful API 接口和 SDK 工具包&lt;/li&gt; 
 &lt;li&gt;支持与第三方系统无缝集成，实现数据互通&lt;/li&gt; 
 &lt;li&gt;多语言 SDK 支持，简化开发集成流程&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;快速开始&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fdocker" target="_blank"&gt;Docker 部署&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fbaota" target="_blank"&gt;宝塔面板部署&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fsource" target="_blank"&gt;源码启动&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;演示&lt;/h2&gt; 
&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本地预览&lt;/p&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;em&gt;# 请将 127.0.0.1 替换为你的服务器 ip&lt;/em&gt;
http://127.0.0.1:9003/
&lt;em&gt;# 开放端口：9003, 9885&lt;/em&gt;
默认用户名: admin@email.com
默认密码: admin&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368903</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368903</guid>
      <pubDate>Tue, 19 Aug 2025 03:23:00 GMT</pubDate>
      <author>来源: 资讯</author>
    </item>
    <item>
      <title>构建 AI 智能体的实用开源技术栈</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;编者按：&lt;/strong&gt; 面对市面上琳琅满目的开源工具，我们往往迷失在选择的焦虑中 —— 哪些工具真正经得起生产环境的考验？哪些只是看起来很酷的演示项目？更重要的是，如何避免把宝贵的开发时间浪费在那些半成品工具上？&lt;/p&gt; 
 &lt;p&gt;我们今天为大家带来的文章，作者的观点是：构建可靠的 AI 智能体需要的不是最新最炫的工具，而是经过实战检验、务实可靠的开源技术栈。&lt;/p&gt; 
 &lt;p&gt;本文作者系统梳理出一套经过实战检验的开源技术栈，涵盖智能体开发的九个核心领域：从用于构建和编排智能体的框架 ，到计算机与浏览器操控、语音交互、文档理解、记忆机制等功能模块；从测试评估到监控部署的全流程工具链；最后还包括仿真环境和垂直领域的专用智能体。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;作者 | Paolo Perrone&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;编译 | 岳扬&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;还记得在某个周末，我坐下来，坚信自己终于能构建一个像样的研究助手智能体原型了。不需要多么高大上 —— 只要它能读取 PDF、提取关键信息、也许还能回答几个后续问题就行。本该很简单对吧？&lt;/p&gt; 
&lt;p&gt;结果，我花了整整两天时间，在文档不全的代码仓库、沉寂的 GitHub issues 和模糊不清的博客文章间反复折腾。有个工具看起来很靠谱，直到我发现它已经八个月没更新了。另一个工具需要启动四个不同的服务，仅仅是为了解析一份文档。最终，我的「智能体」连文件名都几乎读不出来，更别提内容了。&lt;/p&gt; 
&lt;p&gt;但支撑我做下去的不是挫败感 —— 而是好奇。我想知道：真正的智能体开发者究竟在用哪些工具？不是那些创投圈热捧的明星项目，而是那些你会默默安装、保留在你的技术栈中、并真心信赖的工具。那些不需要三页 Notion 文档来解释的工具。&lt;/p&gt; 
&lt;p&gt;这次探索让我发现了一套出乎意料扎实的开源库 —— 这些工具轻量、可靠，且专为开发者而打造。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;所以，如果你还在为智能体跑不通而焦头烂额，本文就是为你准备的。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;01 那么，你准备好构建 AI 智能体了吗？&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;你可能会问：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;人们用什么来构建语音智能体？&lt;/li&gt; 
 &lt;li&gt;解析文档的最佳开源工具是什么？&lt;/li&gt; 
 &lt;li&gt;如何在不把向量数据库（vector DB）像万能胶一样到处粘贴的情况下给我的智能体添加记忆功能？&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;本指南并未试图覆盖市面上所有工具 —— 这是我有意为之。这是一份经过筛选的工具清单，是我真正使用过、保留在我的技术栈中、并在构建智能体原型时会反复使用的工具。不是那些在演示中看起来很酷或在每个炒作帖子里出现的工具，而是那些能帮助我从「想法（idea）」推进到「能工作的东西（working thing）」、而不会让人迷失方向的工具。&lt;/p&gt; 
&lt;p&gt;以下是按类别划分的技术栈：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）用于构建和编排智能体的框架（Frameworks for Building and Orchestrating Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你是从零开始构建智能体，可以从这里开始。这些工具能够帮助你结构化智能体的逻辑 —— 做什么、何时做以及如何处理工具。可以将其视为将原始语言模型转变为更自主的智能体的核心大脑。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）计算机与浏览器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一旦你的智能体能制定计划，它就需要执行操作。这一类工具能让你的智能体点击按钮、在数据字段中键入内容、抓取数据、以及像人类一样操作应用程序或网站。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）语音功能（Voice）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你的智能体需要说话或聆听，这些工具负责处理音频部分 —— 将语音转为文本（speech to text），再将文本转回语音（text to speech）。适用于免提场景或语音优先型智能体（voice-first agents）。有些工具甚至能很好地处理实时对话。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）文档理解（Document Understanding）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;大量现实世界的数据存在于 PDF、扫描文件或其他杂乱格式中。这些工具能够帮助你的智能体读取和理解这些内容 —— 无论是发票、合同还是基于图像的文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）记忆（Memory）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;要实现持续学习的能力，你的智能体就需要记忆功能。这些工具库能帮助智能体记住刚刚发生了什么、你之前告诉过它什么，甚至能随时间的推移构建长期用户画像。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;6）测试与评估（Testing and Evaluation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;系统总会出故障。这些工具可以帮助你在系统上线前发现问题 —— 通过预设用户操作路径、模拟交互，并检查智能体的行为是否符合预期。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;7）监控与可观测性（Monitoring and Observability）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;当智能体正式上线后，你需要知道它在做什么以及表现如何。这些工具能够帮助你跟踪使用情况、调试出现的问题并分析成本或延迟影响。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;8）仿真环境（Simulation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在将智能体投入真实场景前，需要先在安全的沙箱世界中测试它。仿真环境让你能在受控条件中进行实验、优化决策逻辑并发现边界案例。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;9）垂直领域智能体（Vertical Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;并非所有东西都需要从零构建。这些是为特定工作（如编程、研究或客户支持）打造的预置智能体。你可以直接使用它们，或根据你的工作流进行定制。&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;02 用于构建和编排智能体的框架&lt;/strong&gt; &lt;strong&gt;(Frameworks for Building and Orchestrating Agents)&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要打造真正能解决问题的智能体，你需要一个扎实的底层架构 —— 它必须能驾驭工作流、记忆机制和工具协同，而不是沦为一堆东拼西凑的脚本代码。这些框架为你的智能体提供了所需的结构，使其能够准确理解目标、制定可行方案并执行到底。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;CrewAI&lt;/strong&gt;&amp;nbsp;— 协调多个协同工作的智能体。非常适合需要协调和基于角色行为的任务。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agno&lt;/strong&gt;&amp;nbsp;— 专注于记忆机制、工具使用和长期交互。对于需要记忆能力和适应能力的 AI 助手来说非常理想。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Camel&lt;/strong&gt;&amp;nbsp;— 专为多智能体协同、仿真推演和任务分工场景打造。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGPT&lt;/strong&gt;&amp;nbsp;— 通过「规划-执行」闭环实现复杂工作流的自动化运行。最适合需要独立运行的智能体。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGen&lt;/strong&gt;&amp;nbsp;— 让智能体之间进行协作，共同解决复杂问题。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SuperAGI&lt;/strong&gt; — 简化的设置，用于快速构建和部署自主智能体（autonomous agents）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Superagent&lt;/strong&gt;&amp;nbsp;— 一个灵活的开源工具包，用于创建自定义 AI 助手。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain &amp;amp; LlamaIndex&lt;/strong&gt;&amp;nbsp;— 用于智能记忆管理、高效检索和工具链整合的首选工具。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;03 计算机与浏览器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;当你的智能体能推理、思考后，下一步就是让它能采取行动。这意味着智能体要像人类一样与计算机或网络进行交互 —— 点击按钮、填写表单、浏览页面并执行命令。这些工具在推理（reasoning）与行动（action）之间架起了一座桥梁，让智能体能在现实场景中运作。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Open Interpreter&lt;/strong&gt;&amp;nbsp;— 将自然语言翻译成能在你机器上执行的代码。想移动文件或运行脚本？描述需求即可。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Self-Operating Computer&lt;/strong&gt;&amp;nbsp;— 让智能体完全控制你的桌面环境，使其能像真人一样与操作系统（OS）进行交互。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agent-S&lt;/strong&gt;&amp;nbsp;— 这是一个灵活的框架，允许 AI 智能体像真实用户那样操作各类应用程序（apps）、工具（tools）和交互界面（interfaces）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LaVague&lt;/strong&gt;&amp;nbsp;— 使网页智能体（web agents）能够实时浏览网站、填写表单并做出决策，是实现浏览器任务自动化的理想选择。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Playwright&lt;/strong&gt;&amp;nbsp;— 跨浏览器自动化网页操作。适合测试或模拟用户流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Puppeteer&lt;/strong&gt;&amp;nbsp;— 控制 Chrome 或 Firefox 的可靠工具。非常适用于数据抓取和前端行为自动化。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;04 语音功能（Voice）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;语音是人类与 AI 智能体交互最直观的方式之一。这些工具处理语音识别（speech recognition）、语音合成（voice synthesis）及实时交互（real-time interactions） —— 让你的智能体更具「人性化」。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;4.1 语音对话（Speech2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Ultravox&lt;/strong&gt;&amp;nbsp;— 顶级的语音对话模型，可流畅处理实时语音对话。响应迅速灵敏。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Moshi&lt;/strong&gt;&amp;nbsp;— 语音对话任务的另一个强劲选择。在实时语音交互方面表现可靠，但 Ultravox 在性能上更胜一筹。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Pipecat&lt;/strong&gt;&amp;nbsp;— 用于构建语音交互智能体的全栈框架。支持语音转文本、文本转语音，甚至基于视频的交互（video-based interactions）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.2 语音识别（Speech2text）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Whisper&lt;/strong&gt;&amp;nbsp;— OpenAI 的语音转文本模型 —— 适用于跨多语言的转录和语音识别。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Stable-ts&lt;/strong&gt;&amp;nbsp;— 针对 Whisper 的、对开发者更友好的封装工具。添加了时间戳和实时支持，非常适合对话型智能体。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Speaker Diarization 3.1&lt;/strong&gt;&amp;nbsp;— Pyannote 的说话人分离模型。对多人对话及会议类音频等场景至关重要。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.3 语音合成（Text2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;ChatTTS&lt;/strong&gt;&amp;nbsp;— 目前我发现的最佳模型。速度快、稳定，满足大多数生产需求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ElevenLabs（商业版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 当音质要求高于开源产品时，这是首选方案。提供高度自然的拟真语音，并支持多种风格。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Cartesia（商业版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 如果你追求超越开源模型表现的高清语音合成，这是另一个强有力的商业选项。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.4 实用工具（Miscellaneous Tools）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vocode&lt;/strong&gt;&amp;nbsp;— 用于构建语音驱动的大语言模型智能体的工具包。轻松连接语音输入/输出与语言模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 用于测试和评估语音智能体的框架。可调试优化提示词、语音角色（voice persona）或模型配置（model setup）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;05 文档理解（Document Understanding）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;大部分有价值的业务数据仍以非结构化格式存在 —— PDF 文件、扫描文件、基于图像的报表。这些工具能够帮助你的智能体读取、提取并理解这些复杂内容，而无需依赖脆弱的 OCR 处理流程。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Qwen2-VL&lt;/strong&gt;&amp;nbsp;— 阿里巴巴推出的强大视觉语言模型。在处理混合图像与文本的文档任务时，表现优于 GPT-4 和 Claude 3.5 Sonnet，非常适合处理复杂的实际业务格式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DocOwl2&lt;/strong&gt;&amp;nbsp;— 为文档理解场景打造的轻量级多模态模型，无需依赖 OCR。快速高效，且在从杂乱的输入中提取内容结构和语义时准确度惊人。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;06 记忆（Memory）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;没有记忆机制的智能体会陷入一种将每次交互都视为初次接触的循环。这些工具赋予它们回忆过往对话、追踪用户偏好和建立持续交互记忆的能力。正是这种能力，让一次性的助手逐步进化为持续增值的智能伙伴。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Mem0&lt;/strong&gt;&amp;nbsp;— 可自我迭代的记忆层，让智能体能够适配先前的交互。非常适合构建更个性化、持久化的 AI 体验。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Letta（前身为 MemGPT）&lt;/strong&gt; &amp;nbsp;— 为 LLM 智能体增加长期记忆和工具使用能力。可视为智能体的核心支架，使其具备记忆、推理和进化的能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain&lt;/strong&gt;&amp;nbsp;— 包含即插即用的记忆组件，用于追踪对话历史和用户上下文 —— 在构建需跨多轮对话保持连续性的智能体时非常实用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;07 测试与评估（Testing and Evaluation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;当你的智能体不再仅限于聊天，而是开始浏览网页、做出决策、发出语音时，你需要预判它在边界情况中的表现。这些工具可帮助你测试智能体在不同场景下的行为、及早发现 bug，并定位系统故障点。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 测试语音智能体的综合框架，确保语音识别和响应准确且自然。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 用于追踪和通过基准测试测试 AI 智能体的工具集，帮助你在问题影响用户之前发现隐患并优化性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentBench&lt;/strong&gt;&amp;nbsp;— 评估 LLM 智能体的基准测试工具，覆盖从网页浏览到游戏等多种任务场景，确保通用性与有效性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;08 监控与可观测性（Monitoring and Observability）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要确保 AI 智能体大规模地部署运行时能够流畅高效地工作，你需要对它们的性能与资源消耗进行监控。这些工具提供的关键可观测性数据，能够助你监控智能体行为、优化资源，并在问题波及用户前及时拦截。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;openllmetry&lt;/strong&gt;&amp;nbsp;— 基于 OpenTelemetry 为 LLM 应用提供端到端的可观测性，清晰展示性能表现，并帮助你快速排查故障和优化系统。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 一款全面的监控工具，能够追踪智能体性能、成本开支及基准测试数据，确保其高效运行且成本可控。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;09 仿真环境（Simulation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;在部署前模拟真实环境具有突破性意义。这些工具让你能创建受控的虚拟空间，使智能体在其中互动、学习并做出决策，而无需承担在实际环境中可能产生的意外后果。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;AgentVerse&lt;/strong&gt;&amp;nbsp;— 支持在多种应用程序和模拟环境中部署基于 LLM 的多智能体，确保其在各种环境下都能有效运作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Tau-Bench&lt;/strong&gt;&amp;nbsp;— 评估智能体在特定行业（如零售业/航空业）中用户交互表现的基准测试工具，确保专业领域任务的流畅执行。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ChatArena&lt;/strong&gt;&amp;nbsp;— 一个多智能体语言游戏环境，智能体在其中交互协作，适合在安全受控空间内研究智能体的行为模式并优化沟通模式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AI Town&lt;/strong&gt;&amp;nbsp;— AI 角色进行社交互动、决策测试和现实场景模拟的虚拟环境，帮助精细化调优智能体行为。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Generative Agents&lt;/strong&gt;&amp;nbsp;— 斯坦福的智能体项目，专注于模拟人类复杂行为，非常适合在社交语境中测试记忆与决策能力。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;10 垂直领域智能体（Vertical Agents）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;垂直领域智能体是解决特定行业问题或优化专业任务的专用工具。尽管这类工具的生态系统正在不断发展，但还是分享我个人使用过并认为特别有用的几款工具：&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;10.1 编程开发（Coding）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;OpenHands&lt;/strong&gt;&amp;nbsp;— 基于 AI 的软件开发平台，可自动化编程任务并加速开发流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;aider&lt;/strong&gt;&amp;nbsp;— 可直接集成到终端的结对编程工具（pair programming tool），提供直接嵌入编程环境的 AI 协作编程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Engineer&lt;/strong&gt;&amp;nbsp;— 用自然语言构建应用程序；用户只需描述需求，AI 将解析用户意图并生成代码。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;screenshot-to-code&lt;/strong&gt;&amp;nbsp;— 将设计图转换为采用 HTML/Tailwind/React/Vue 的完整网站，快速实现设计稿转代码。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.2 学术研究（Research）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Researcher&lt;/strong&gt;&amp;nbsp;— 一款能够进行全面研究、分析数据并撰写报告的自主智能体（autonomous agent），能够简化研究流程。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.3 数据库交互（SQL）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vanna&lt;/strong&gt;&amp;nbsp;— 使用自然语言查询与 SQL 数据库交互。无需编写复杂的 SQL 命令，提问即可获取数据。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;11 总结（Conclusion）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;回顾我早期构建研究助手时的尝试，我意识到自己当初把问题复杂化了。那个项目最终是一团糟 —— 充斥着过时的代码、半成品的工具，以及连 PDF 这种简单文件都处理得力不从心的系统。&lt;/p&gt; 
&lt;p&gt;但正是在这次失败中我收获最多。&lt;/p&gt; 
&lt;p&gt;关键不在于寻找最完美的工具，而在于坚持有效的方案并保持简单。那次教训让我明白：&lt;strong&gt;构建最可靠的智能体，凭的是务实、直接的技术栈，而非追逐每一款花哨的新工具。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;成功的智能体开发无需重复造轮子。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心在于选择适合目标任务的工具、有条不紊地整合它们，并持续不断地优化智能体原型。&lt;/strong&gt; 无论你是要自动化工作流程、构建语音智能体，还是解析文档，一套精心挑选的技术栈都能让流程更流畅高效。&lt;/p&gt; 
&lt;p&gt;因此，立即行动，大胆尝试，让好奇心引领你前行。技术生态系统正在不断演进，可能性是无穷无尽的。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;应原作者要求，在此放置 Substack 订阅链接和宣传语：&lt;/p&gt; 
&lt;p&gt;&amp;gt; 作为科技内容从业者，还在为粉丝增长发愁？ &amp;gt; &amp;gt; 《The Tech Audience Accelerator》正是为你量身打造的必备指南 —— 专为认真扩大受众群体的科技创作者而生。 &amp;gt; &amp;gt; 这里浓缩了我实现 3000 万+ 曝光量（且持续攀升）的实战方法论、即用模板与高效策略， &amp;gt; &amp;gt; 所有干货，皆经市场验证。 &amp;gt; &amp;gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechaudienceaccelerator.substack.com%2F" target="_blank"&gt;https://techaudienceaccelerator.substack.com/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本期互动内容 🍻&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;❓分享一次你构建 AI 智能体时最让你血压飙升的工具使用踩坑经历！🫠 是文档失踪？还是兼容性噩梦？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本文经原作者授权，由 Baihai IDP 编译。如需转载译文，请联系获取授权。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdecodingml.substack.com%2Fp%2Fthe-open-source-stack-for-ai-agents" target="_blank"&gt;https://decodingml.substack.com/p/the-open-source-stack-for-ai-agents&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/IDP/blog/18689820</link>
      <guid isPermaLink="false">https://my.oschina.net/IDP/blog/18689820</guid>
      <pubDate>Tue, 19 Aug 2025 03:19:00 GMT</pubDate>
      <author>原创</author>
    </item>
    <item>
      <title>Devv 推出 Coding Agent，专注构建 AI 驱动的产品</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Devv Search 团队发布了全新的 Devv Coding Agent，一个专为构建 AI 驱动产品而设计的集成开发平台。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1734" src="https://static.oschina.net/uploads/space/2025/0828/110715_u41G_2720166.png" width="1268" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Ftisoga%2Fstatus%2F1960599099025301756" target="_blank"&gt;官方介绍称&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;与 Lovable 或 Bolt 不同，Devv 不适用于构建精美的登录页面或漂亮的演示。 &amp;nbsp;我们专注于一件事：为您构建真正的 AI 产品 —— 内置 LLM、图像/音频生成、后台作业、身份验证、数据库、电子邮件等功能。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Devv&amp;nbsp; 被定位为「首个帮助交付 AI 驱动产品的 Coding Agent」，其功能类似于 n8n 与 Lovable 的结合。它原生集成了 Auth、Database、Email、LLMs、OpenRouter、Replicate、Stripe 等常用服务，为开发者提供了一站式解决方案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1bceba73f6f0bc01bd9f788fa97e1256947.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;体验：&lt;em&gt;https://devv.ai/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368901</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368901</guid>
      <pubDate>Tue, 19 Aug 2025 03:12:00 GMT</pubDate>
      <author>来源: OSCHINA</author>
    </item>
  </channel>
</rss>
