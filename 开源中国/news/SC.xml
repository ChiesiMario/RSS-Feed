<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-最新资讯</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-最新资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Sun, 23 Mar 2025 16:37:01 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>《AppGallery 版本升级，好用小妙招请查收》</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;近期,鸿蒙应用市场（AppGallery）已升级到 6.0.2 版本。新版本带来了哪些全新变化和实用小技巧？想要一键找到同类型更多应用，并同时高速下载，有什么好方法呢？本期的跟手教程别错过！&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;一、「应用更新」优化，长长的更新列表「不见了」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;针对有用户提到在「我的」页面中看到「应用更新」展示的列表太长、占版面等问题，新版本的 AppGallery 进行了优化。目前进入进入「应用市场&amp;gt;我的」你会发现页面更清爽、长串的待更新应用列表不见了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;那更新列表去哪里了呢？点击进入「应用更新」，你可看到：应用更新列表在这里，且已分成了「待更新」和「最近已更新」两部分展示。「待更新」可提醒大家进行应用升级，「最近已更新」列表能帮助大家随时查看更新记录，了解应用更新后的新特性。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;此外，当所有应用均为最新版本时，在「我的」页面就可以直接看到相应的提示，这对于有 「应用更新强迫症」的朋友来说无疑是一个福音。&amp;nbsp;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;2.png&quot; height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet//9a443ec842a34c20c679ca60a3ce582a.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;二、一键可达同类应用列表&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;接下来的小技巧，必须要敲黑板了！首先新版本的 AppGallery 在应用页增加了&lt;strong&gt;腰部分类胶囊&lt;/strong&gt;的模块，提供了超过 20 个分类胶囊，大家可以通过滑动选择感兴趣的胶囊，找到同类型应用列表；比如点击了「房产与装修」胶囊，常用的找房和装修类 App&amp;nbsp;就出现眼前了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;同类应用太多，该怎么选？可以看看 AppGallery 给你哪些推荐和实用解题思路。回到「房产与装修」列表中，随机选择《贝壳找房》进入详情页，详情页下方可找到「相关专题」栏目，打开专题内容浏览，获取使用技巧，如利用《贝壳找房》搜索短租的资源等。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;让探索更高效，为你的选择提供更有价值的参考，这么好用的技巧要是不知道可真太浪费了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;3.png&quot; height=&quot;610&quot; src=&quot;https://oscimg.oschina.net/oscnet//ec965fbc9f249d96b8a34c622b1d7a69.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;三、应用同时下载能力增强&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;本次更新后， AppGallery 最多可支持同时下载或更新 3 个应用，这一改进将极大地提升大家在使用新机或有批量下载需求时的效率。众所周知，HarmonyOS 5 应用下载速度和使用流畅度都有了很大的提升，如今可支持同时下载多个应用，必然会给大家带来加倍的便利和快乐。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;4.png&quot; height=&quot;735&quot; src=&quot;https://oscimg.oschina.net/oscnet//b3a69f29699edeac988ee2b7dc1dae46.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;四、横滑一下，就可获取更多应用信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;在 AppGallery 版本升级后，应用详情页悄悄发生了变化。在应用信息栏的位置，轻轻往左一滑，就能看到应用分类、开发者信息和应用包体大小，针对「一眼锁定」应用的用户来说可帮了大忙，不用再滑到下面去检索信息。这虽然是一个非常小的改变，但在为用户检索应用时，提供了更多参考维度。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;还要告诉你一个小技巧，应用分类的图标就是一个分类胶囊，点击后即可轻松进入同类应用列表了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;5.png&quot; height=&quot;802&quot; src=&quot;https://oscimg.oschina.net/oscnet//2b4db5f745415945cac452a69f850590.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;五、「下载记录」和「购买记录」中的应用操作办法&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;最后一点可能对应用发烧友来说更感兴趣，新版本的 AppGallery 除了能够常规的管理应用下载记录（长按操作）和购买记录（滑动操作）之外，大家还可以随时取消之前添加的「心愿单」应用，这一功能虽然不常用，但也可解用户所需。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;以上就是 AppGallery6.0.2 版本更新的实用小妙招。如果大家还在使用旧版本，不妨赶紧更新体验一下。当然，AppGallery 的宝藏功能远不止这些，更多惊喜等待你去探索发现！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340252</guid>
            <pubDate>Fri, 21 Mar 2025 10:14:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>OpenAI CEO 奥特曼 ：DeepSeek 教训了我们，GPT-5 将免费开放</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;日前，&amp;nbsp;OpenAI CEO 奥特曼在与硅谷知名分析师 Ben Thompson&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstratechery.com%2F2025%2Fan-interview-with-openai-ceo-sam-altman-about-building-a-consumer-tech-company%2F&quot; target=&quot;_blank&quot;&gt;对谈&lt;/a&gt;&lt;/u&gt;中提到 DeepSeek。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/164748_HXaN_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;奥特曼认为 DeepSeek 确实是个很棒的团队，也做出了很优秀的模型，&lt;strong&gt;但他们真正走红的原因，并不完全是模型本身的能力&lt;/strong&gt;。&lt;br&gt; &amp;nbsp;&lt;br&gt; 「这对我们来说是一个教训，那就是当我们隐藏一个功能时（思维链），我们给其他人留下了获得病毒式传播的机会。这是一个很好的警醒。它也让我重新思考我们在免费层中提供的内容， GPT-5 将可以免费使用」，奥特曼这样看 DeepSeek 的走红。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;奥特曼表示，OpenAI 其实早就有类似能力，只是过去出于谨慎考虑没有对外开放，怕太智能会变得不可控。但现在回头看，这种「保守」反而错失了机会，「我们做的模型更好，但大家没注意到，反而被别人抢走了注意力」，他还透露，GPT-5 会加入更多功能，思维链、联网搜索、甚至更长记忆都有可能下放，算是一个明显的转向。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338735/openai-calls-deepseek-state-controlled&quot; target=&quot;news&quot;&gt;OpenAI 呼吁美国政府禁止 DeepSeek&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338329/openai-chain-of-thought-monitoring&quot; target=&quot;news&quot;&gt;OpenAI 透露 CoT 思维链研究成果：CoT 监控可阻止大模型恶意行为&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/336125/openai-gpt-4-5&quot; target=&quot;news&quot;&gt;OpenAI 正式发布 GPT-4.5 模型&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340236</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340236</guid>
            <pubDate>Fri, 21 Mar 2025 08:48:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>马斯克：2024 年特斯拉 AI 投资约 100 亿美元、FSD 安全水平将超过人类</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;特斯拉公司 CEO 埃隆・马斯克今天在员工大会上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCernBasher%2Fstatus%2F1902918128876544315&quot; target=&quot;_blank&quot;&gt;分享&lt;/a&gt;&lt;/u&gt;了公司在电动汽车、储能、智能辅助驾驶、人工智能计算及人形机器人等业务板块的最新动态。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-39bef0ad1f0e3c05326afa6e48d068ce7c8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;马斯克称，特斯拉用于智能辅助驾驶训练的 Cortex 算力中心目前已有超过 5 万块 GPU，且即将突破 10 万块大关，跻身全球前五大超级计算中心。&lt;/p&gt; 
&lt;p&gt;此外，Dojo 2 超级计算机即将问世，其将比第一代 Dojo 超级计算机强大 10 倍。目前，Dojo 超级计算机已在纽约超级工厂投入运行，承担了特斯拉 5% 至 10% 的智能辅助驾驶训练数据量。&lt;/p&gt; 
&lt;p&gt;马斯克透露，2024 年特斯拉在人工智能方面的投资约达 100 亿美元（现汇率约合 724.51 亿元人民币），其中约一半为内部投入，主要用于特斯拉自研的 AI 推理计算机、所有车辆传感器以及 Dojo 超级计算机。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-caf53effe89e63245f2c7f3bdf2d0223c1b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;特斯拉全系现款在售车型均已搭载 AI 4 智能辅助驾驶硬件。尽管 AI 4 硬件设计于数年前，但至今仍无同类产品超越其性能。AI 4 不仅性能强大，且能耗极低。&lt;strong&gt;未来几年，特斯拉将推出 AI 5、AI 6、AI 7 硬件&lt;/strong&gt;，但马斯克强调，消费者不应因此延迟购买，因为特斯拉的技术进化永无止境，早入手即可早享受，现阶段的 AI 4 对于特斯拉智能辅助驾驶硬件来说已经足够。&lt;/p&gt; 
&lt;p&gt;马斯克还表示，特斯拉的智能辅助驾驶系统在行驶过程中所需的干预越来越少，&lt;strong&gt;最终将完全无需人工干预，且行驶安全水平将超过人类驾驶，达到比人类安全 10 倍的水平&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;目前，在北美地区，特斯拉的智能辅助驾驶系统（北美称 FSD）已经能够实现从弗里蒙特工厂下线的车辆在无人驾驶情况下自行开往目的地停车场，等待装车长途运输。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/339990/blackrock-ai-infrastructure-partnership&quot; target=&quot;news&quot;&gt;马斯克 xAI 和微软、贝莱德等组成新联盟，共建 300 亿美元 AI 基础设施项目&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334522/xai-grok3&quot; target=&quot;news&quot;&gt;马斯克旗下 xAI 发布 Grok 3 推理模型，声称超越 o1、R1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340233</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340233</guid>
            <pubDate>Fri, 21 Mar 2025 08:38:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Minesweeper MCP Server —— 扫雷 MCP 服务器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Minesweeper MCP Server 是一个扫雷 MCP 服务器，让 Claude 可以玩扫雷游戏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0d7a16d356b0beb3c58ab8498176657e2fd.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/minesweeper-mcp-server</link>
            <guid isPermaLink="false">https://www.oschina.net/p/minesweeper-mcp-server</guid>
            <pubDate>Fri, 21 Mar 2025 08:32:00 GMT</pubDate>
        </item>
        <item>
            <title>刘强东：技术算法不应压榨最底层兄弟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 21 日，据网传截图显示，近日刘强东在朋友圈发文评价京东为快递员缴纳五险一金一事，对此，界面新闻向京东求证，对方回应，截图内容属实。刘强东称，去年是创业 20 年以来最有成就感的时候，因为仅仅快递小哥就有 1200 多个兄弟退休了。每人可领取数十万公积金、每月 5350 元退休金，并享受医保全覆盖。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;刘强东称，我们所学的知识、商业模式、技术算法都不应该是用来压榨社会最底层的兄弟们的，我们的利润、市值和财富更不应该建立在底层百姓无保障的生活之上的。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;刘强东呼吁所有快递员和骑手都可以获得五险一金待遇，因为今天中国几大平台的利润和市值完全可以支撑，期待各阶层一起幸福生活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;512&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/163026_g23O_4252687.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340231</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340231</guid>
            <pubDate>Fri, 21 Mar 2025 08:30:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>浏览器崩溃的第一性原理：内存管理的艺术</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;79&quot; data-source-title=&quot;&quot;&gt; 
  &lt;section class=&quot;js_blockquote_digest&quot;&gt; 
   &lt;section&gt;
     你是否曾经遇到过浏览器突然卡顿，甚至崩溃的情况？尤其是在打开多个标签页或运行复杂的网页应用时，浏览器似乎变得异常脆弱。这种崩溃的背后，往往与内存管理息息相关。 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/blockquote&gt; 
 &lt;section style=&quot;text-indent: 0em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;浏览器的内存管理机制决定了它能否高效地分配和释放资源，而 JavaScript 引擎 V8 正是这一机制的核心。&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;本文将探讨 V8 的内存管理机制，帮助你理解浏览器崩溃的根源，并学会如何优化内存使用，避免类似问题的发生。&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;3&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;一、内存管理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;底层语言（如 C 语言）拥有手动的内存管理原语，例如：&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;ree()&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;。相反，JavaScript 是在创建对象时自动分配内存，并在不再使用时自动释放内存（垃圾回收）。这种自动化机制虽然方便，但也容易让我们产生误解，认为不需要关心内存管理，从而忽略潜在的内存问题。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;5&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;二、内存生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;无论使用何种编程语言，内存的生命周期通常都遵循以下步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ul data-nodeid=&quot;7&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;182&quot;&gt;分配内存&lt;/strong&gt;：根据需求分配所需的内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;187&quot;&gt;使用内存&lt;/strong&gt;：对分配的内存进行读写操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;192&quot;&gt;释放内存&lt;/strong&gt;：在内存不再需要时将其释放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;在底层语言中，内存的分配和释放是显式的，开发者需要手动管理。而在高级语言如 JavaScript 中，内存的分配和释放大多是隐式的，由垃圾回收机制自动处理。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;15&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1 内存分配&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_4&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;16&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1.1 值的初始化&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;为了不让我们费心内存分配，JavaScript 在值初次声明时自动分配内存。&lt;/span&gt;&lt;/p&gt; 
 &lt;pre data-nodeid=&quot;18&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;28&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为数值分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为字符串分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; o = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为对象及其包含的值分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 为数组及其包含的值分配内存（就像对象一样）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为函数（可调用的对象）分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 函数表达式也会分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;someElement.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;click&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    someElement.style.backgroundColor = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;19&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2.1 通过函数调用分配内存&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些函数调用的结果是为对象分配内存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;21&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为 Date 对象分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; e = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;div&quot;&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 为 DOM 元素分配内存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些方法为新值或新对象分配内存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;23&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;azerty&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s2 = s.substr(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// s2 是一个新的字符串&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 因为字符串是不可变的值，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// JavaScript 可能决定不分配内存，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 只是存储了 [0-3] 的范围。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yeah yeah&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a2 = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;generation&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a3 = a.concat(a2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 有四个元素的新数组，由 a 和 a2 其中的元素连接而成。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;24&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2 变量读取&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用值通常涉及对分配的内存进行读写操作。无论是读取变量值、访问对象属性，还是传递函数参数，都会使用到内存中的值。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;26&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.3 内存回收（垃圾回收）&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;当内存不再需要时，系统会将其释放。大多数内存管理问题都出现在这一阶段，尤其是如何确定已分配的内存何时不再需要。在底层语言中，开发者需要手动判断并释放内存，而 JavaScript 则通过垃圾回收机制自动完成这一任务。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;28&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;三、V8 的垃圾回收&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;垃圾回收的核心任务是识别内存中的「死区」，即不再使用的内存。一旦识别出这些区域，它们可以被重新用于新的内存分配或释放回操作系统。一个对象如果不再被根对象或活跃对象引用，则被视为「死的」。根对象通常是活跃的，例如局部变量、全局对象或浏览器对象（如 DOM 元素）。&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;例如：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;31&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; obj = { &lt;span class=&quot;code-snippet__attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  g(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// might contain an infinite loop.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj.x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于无法精确判断对象是否会被再次引用（这相当于停机问题），垃圾回收器采用了一种宽松的定义：如果对象可以通过某个指针链从根对象到达，则该对象是活跃的，否则就是垃圾。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;33&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.1 V8 内存结构&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;V8 的内存分为以下几个主要部分：&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028741&quot; data-ratio=&quot;0.7166882276843467&quot; src=&quot;https://oscimg.oschina.net/oscnet/ca11da54-bc8b-4a09-9c14-3c4399c0411a.png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;35&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;219&quot;&gt;堆内存（Heap）&lt;/strong&gt;：&lt;br&gt;堆内存是 V8 中用于动态分配内存的区域，存储 JavaScript 对象、闭包、函数等数据。堆内存进一步分为以下几个区域：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;38&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;226&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;新生代&lt;/span&gt;&lt;/strong&gt;：用于存储生命周期较短的对象（如临时变量、局部变量等）。分为两个半空间（From Space 和 To Space），采用 Scavenge 算法进行垃圾回收。新生代空间较小，垃圾回收频率较高。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;233&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;老生代&lt;/span&gt;&lt;/strong&gt;：：用于存储生命周期较长的对象（如全局变量、闭包等）。采用标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）算法进行垃圾回收。老生代空间较大，垃圾回收频率较低。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;240&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;代码空间&lt;/span&gt;&lt;/strong&gt;：专门用于存储 JIT（Just-In-Time）编译生成的机器代码。代码空间与其他空间分离，因为代码的生命周期通常较长，且需要高效访问。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;247&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;大对象空间&lt;/span&gt;&lt;/strong&gt;：用于存储较大的对象（如大数组、大字符串），避免频繁复制。采用标记-清除和标记-整理算法进行垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;254&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;单元空间、属性单元空间和映射空间&lt;/span&gt;&lt;/strong&gt;：些空间分别包含 Cells、PropertyCells 和 Maps。每个空间都包含大小相同的对象，并且对它们指向的对象类型有一定的限制，从而简化了垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;260&quot;&gt;栈内存（Stack）&lt;/strong&gt;&lt;br&gt;栈内存用于存储函数调用时的局部变量、参数和返回地址。栈内存的特点是分配和释放速度快，但空间有限。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;51&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2 V8 垃圾回收机制&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;52&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.1 栈数据的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028742&quot; data-ratio=&quot;0.4969097651421508&quot; src=&quot;https://oscimg.oschina.net/oscnet/dd9587a0-84da-4c35-ab5e-3b2f0a559e6e.png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;栈数据的「垃圾回收」是通过函数调用和返回机制自动完成的。栈帧的内存释放是隐式的，栈是连续的内存区域，内存分配和释放通过指针移动实现。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;55&quot; style=&quot;text-align: left;&quot;&gt;&lt;code&gt;
   
   
   &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;38&quot; data-source-title=&quot;&quot;&gt;
 
    
    
    &lt;section class=&quot;js_blockquote_digest&quot;&gt;
  
     
     
     &lt;section&gt;
      
      
      
   为什么需要区分「堆」和「栈」两个存储空间？为什么不将所有数据直接存放在栈中？
  
     
     
     &lt;/section&gt;
 
    
    
    &lt;/section&gt;

   
   
   &lt;/blockquote&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;JavaScript 引擎需要用栈来维护程序执行期间的上下文状态。如果栈空间过大，所有数据都存放在栈中，会影响上下文切换的效率，进而影响整个程序的执行效率。例如，当函数执行结束时，JavaScript 引擎只需将指针下移到上一个执行上下文的地址即可，栈帧的内存会自动回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_12&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;57&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.2 堆数据的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;代际假说是垃圾回收领域的一个重要理论，V8 的垃圾回收策略正是基于这一假说。代际假说包含两个核心观点：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;59&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;大多数对象的生命周期很短，分配后很快变得不可访问。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;少数对象会存活较长时间。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;基于此，V8 将堆内存分为新生代和老生代两个区域。新生代存放生命周期短的对象，老生代存放生命周期长的对象。V8 的垃圾回收器分为主垃圾回收器和副垃圾回收器。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h5_13&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;65&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器主要负责新生代的垃圾回收。由于大多数小对象都分配在新生代，因此该区域的垃圾回收频率较高。&lt;br&gt;新生代采用 Scavenge 算法，进行垃圾回收。该算法将新生代空间对半划分为对象区域和空闲区域。&lt;br&gt;&lt;/span&gt;&lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028740&quot; data-ratio=&quot;0.5777063236870311&quot; src=&quot;https://oscimg.oschina.net/oscnet/20a6d122-d24b-4ae0-90ec-ec263472ba5c.png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;新加入的对象存放在对象区域。当对象区域快满时，副垃圾回收器会执行以下步骤：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;67&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;标记对象区域中的存活对象。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;将存活对象复制到空闲区域，并有序排列，消除内存碎片。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;角色翻转：对象区域变为空闲区域，空闲区域变为对象区域。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于 &lt;strong data-nodeid=&quot;298&quot;&gt;Scavenge 算法&lt;/strong&gt;需要复制存活对象，如果新生代空间过大，复制操作会耗费较多时间。因此，新生代空间通常较小。为了应对新生代空间不足的问题，V8 采用了对象晋升策略：经过两次垃圾回收后仍然存活的对象会被移动到老生代。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_14&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;75&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;主垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;老生代的对象通常较大，使用 &lt;strong data-nodeid=&quot;313&quot;&gt;Scavenge 算法&lt;/strong&gt;进行垃圾回收效率较低。因此，主垃圾回收器采用&lt;strong data-nodeid=&quot;314&quot;&gt;标记-清除&lt;/strong&gt;和&lt;strong data-nodeid=&quot;315&quot;&gt;标记-整理&lt;/strong&gt;算法。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;标记-清除：首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历调用栈，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。标记过程和清除过程就是标记 - 清除算法 Mark-Sweep ，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028743&quot; data-ratio=&quot;0.4945770065075922&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed116503-4d1e-493b-8d7f-3457262b4501.png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法—标记-整理（Mark-Compact）&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。V8 研究团队 2016 年的一篇博文：在一次完整的垃圾回收之后，V8 的堆增长策略会根据活动对象的数量外加一些余量来确定何时再进行垃圾回收。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028739&quot; data-ratio=&quot;0.4106029106029106&quot; src=&quot;https://oscimg.oschina.net/oscnet/7d262ac7-2d6e-4dff-9074-41b2a5be869f.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_15&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;80&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;全停顿和增量标记&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有研究数据表明，如果堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028745&quot; data-ratio=&quot;0.2915506035283194&quot; src=&quot;https://oscimg.oschina.net/oscnet/e32c7d49-8a28-410a-a60f-f0f1f13ba6dc.png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;83&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section style=&quot;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;
   
   
   &lt;code&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。&lt;br&gt;&lt;/span&gt;&lt;/code&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法，&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028744&quot; data-ratio=&quot;0.3201663201663202&quot; src=&quot;https://oscimg.oschina.net/oscnet/0d30149e-d536-4d77-ac3a-0c1865d98a4b.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;86&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;四、内存泄漏与优化&lt;/span&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_17&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;88&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1 常见的内存泄漏场景及优化方案&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_18&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;89&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.1 意外的全局变量&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未使用 var、let 或 const 声明的变量会隐式变为全局变量，直到页面关闭才会被释放。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;92&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;leak&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  leakedVar = &lt;span class=&quot;code-snippet__string&quot;&gt;&#39;This is a global variable&#39;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 意外的全局变量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;351&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;始终使用 var、let 或 const 声明变量。启用严格模式（&quot;use strict&quot;），避免意外创建全局变量。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_19&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;94&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.2 未清理的定时器或回调函数&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未清除的 setInterval 或 setTimeout 会持续持有引用，导致相关对象无法被回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;97&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; data = getData();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;setInterval(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  process(data); &lt;span class=&quot;code-snippet__comment&quot;&gt;// data 一直被引用，无法释放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;360&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 clearInterval 或 clearTimeout 清除定时器。在组件销毁或页面卸载时清理定时器。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;99&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.3 未解绑的事件监听器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未移除的事件监听器会持续持有对 DOM 元素或对象的引用，导致内存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;102&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; button = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myButton&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;button.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;Button clicked&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果 button 被移除，但未解绑事件监听器，会导致内存泄漏&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;369&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 removeEventListener 解绑事件监听器。在组件销毁或页面卸载时解绑事件。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_21&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;104&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.4 闭包中的引用&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;闭包会捕获外部函数的变量，如果闭包未被释放，这些变量也会一直存在。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;107&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;createClosure&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; largeData = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1000000&lt;/span&gt;).fill(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(largeData[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;code-snippet__comment&quot;&gt;// largeData 一直被闭包引用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; closure = createClosure();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;378&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;免在闭包中捕获不必要的变量。在不再需要闭包时，手动解除引用（例如将闭包设置为 null）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;109&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.5 DOM 引用未释放&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果 JavaScript 中保留了 DOM 元素的引用，即使该元素从页面中移除，也无法被垃圾回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;112&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; element = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.removeChild(element); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 从 DOM 中移除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// element 仍然被引用，无法释放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;387&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;在移除 DOM 元素后，将其引用设置为 null：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;114&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;element&lt;/span&gt; = null;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_23&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;115&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.6 缓存未清理&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;缓存对象（如 Map 或 WeakMap）如果未正确清理，会导致内存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;118&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; cache = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCache&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;key, value&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache.set(key, value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果缓存未清理，会持续增长&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;396&quot;&gt;优化：&lt;/strong&gt;&lt;br&gt;使用 WeakMap 或 WeakSet，它们不会阻止键对象的垃圾回收。定期清理缓存。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_24&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;120&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2 内存泄漏检查&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_25&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;121&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.1 使用 Chrome 任务管理器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 自带的任务管理器可以帮助你快速发现内存占用异常的任务。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;内存&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028747&quot; data-ratio=&quot;0.6096885813148789&quot; src=&quot;https://oscimg.oschina.net/oscnet/4a266a6f-5f33-4576-8745-89dbad18ebff.png&quot; data-type=&quot;png&quot; data-w=&quot;2890&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;124&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打开 Chrome 任务管理器：点击 Chrome 右上角的三个点（菜单按钮） &amp;gt; 更多工具 &amp;gt; 任务管理器。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查看内存占用：关注内存占用异常高的任务（如标签页、扩展程序、辅助框架等）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;检查内存增长：观察某个任务的内存占用是否持续增长（即使页面没有操作）。如果某个任务的内存占用不断增加，可能是内存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_26&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;131&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.2 使用 Chrome 开发者工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 的开发者工具提供了强大的内存分析功能，可以帮助你定位内存泄漏。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028746&quot; data-ratio=&quot;0.6623970722781336&quot; src=&quot;https://oscimg.oschina.net/oscnet/243ee5e7-4a79-4326-8fd1-68e8488a7f46.png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;br&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步骤：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;133&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打开开发者工具：右键点击页面，选择，检查，或者使用快捷键：Ctrl + Shift + I（Windows/Linux）或 Cmd + Option + I（Mac）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用 Memory 面板：切换到 Memory 标签。选择以下工具之一进行分析：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;138&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Heap Snapshot：拍摄堆内存快照，分析内存分配情况。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation instrumentation on timeline：记录内存分配的时间线，查看内存增长情况。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation sampling：通过采样分析内存分配。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;分析内存泄漏：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;147&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;拍摄多个堆内存快照，比较快照之间的内存变化。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查找未被释放的对象（如 DOM 节点、事件监听器等）。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;检查 Retainers（持有者），找到导致内存泄漏的代码。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_27&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;154&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.3 使用第三方工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;除了 Chrome 自带的工具，还可以使用以下第三方工具进行内存分析：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;156&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Lighthouse：Chrome 的 Lighthouse 工具可以检测页面性能问题，包括内存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;MemLab：Facebook 开源的 JavaScript 内存分析工具，专门用于检测内存泄漏。&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h2_28&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;161&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;五、从崩溃到优化：内存管理的终极目标&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;浏览器的崩溃往往源于内存管理的不足，而 V8 引擎的内存管理机制正是解决这一问题的关键。通过理解 V8 的内存分配、垃圾回收机制以及常见的内存泄漏场景，我们可以更好地优化代码，避免内存浪费和性能瓶颈。无论是开发者还是普通用户，了解这些原理都能帮助我们更好地应对浏览器崩溃问题，提升应用的整体性能和用户体验。&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_29&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;163&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;六、 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;本文通过从常见的浏览器崩溃场景引出本篇文章的分享主题：V8 的内存管理， 文章主要介绍了 V8 垃圾回收的原理、常见的内存泄漏场景及其预防方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;最后，最重要的一点：欢迎评论区互动，一起交流学习，共同成长&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;img alt=&quot;图片&quot; class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-imgfileid=&quot;100028749&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fc371ec9-2b7f-4b7f-b317-4e6e306662bf.png&quot; data-type=&quot;webp&quot; data-w=&quot;396&quot; style=&quot;pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;扫一扫，加入技术交流群&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 16px;&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公众号 - 京东云开发者（JDT_Developers）。&lt;br&gt;如有侵权，请联系 support@oschina.cn 删除。&lt;br&gt;本文参与「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源创计划&lt;/a&gt;」，欢迎正在阅读的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/17955030</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/17955030</guid>
            <pubDate>Fri, 21 Mar 2025 08:29:00 GMT</pubDate>
            <author>京东云开发者</author>
        </item>
        <item>
            <title>Linux 内核越界写入漏洞致权限提升</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcybersecuritynews.com%2Flinux-kernel-out-of-bounds-write-vulnerability%2F&quot; target=&quot;_blank&quot;&gt;Linux 内核存在近 20 年的严重漏洞&lt;/a&gt;&lt;/u&gt;，允许本地用户获取 root 权限，影响多版本系统。&lt;/p&gt; 
&lt;p&gt;该漏洞被分配的编号为 CVE-2025-0927，在 Linux 内核 HFS+文件系统驱动程序中存在越界写入漏洞，影响运行至 6.12.0 版本内核的系统，已确认 Ubuntu 22.04 带有 Linux 内核 6.5.0-18-generic 版本的系统存在漏洞。&lt;/p&gt; 
&lt;p&gt;根据 SSD 的安全公告，该漏洞存在于 HFS+驱动程序中，该驱动程序支持 Apple 的过时文件系统格式，该格式在 2017 年被 APFS 取代之前一直是 MacOS X 的主要文件系统。&lt;/p&gt; 
&lt;p&gt;该漏洞自初始 git 仓库构建 1da177 以来一直存在，并且自 Linux 内核 2.6.12-rc2 版本以来一直未被检测到。&lt;/p&gt; 
&lt;p&gt;该漏洞的核心在于 B 树节点处理中的缓冲区溢出。易受攻击的函数 fs/hfsplus/bnode.c 中的 hfs_bnode_read_key 未能正确验证键大小的边界条件：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2f9a4d0f8d837764ff162322f00ccb86e82.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在该代码中，函数未实现适当的边界检查，允许攻击者触发越界写操作，从而破坏内核内存。&lt;/p&gt; 
&lt;p&gt;Ubuntu 已发布修复程序，管理员需立即更新。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</guid>
            <pubDate>Fri, 21 Mar 2025 08:28:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>AI 组件 ComfyUI 易被黑产盯上</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;随着近几年大模型的迅猛发展，以及安全对抗技术的持续迭代升级，黑产团伙逐渐将攻击目标从传统服务转移到了 AI 相关服务。&lt;/p&gt; 
&lt;p&gt;近日，百度安全团队捕获到了一起&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIPzuok7ej_ghTn59R9PRbA&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;针对大模型相关组件 ComfyUI 的攻击事件&lt;/strong&gt;&lt;/a&gt;&lt;/u&gt;，经过深入分析，该事件背后团伙已实际针对国内不少公网 ComfyUI 进行了入侵。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;关于 ComfyUI&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;‌ComfyUI 是一款基于节点流程的 Stable Diffusion 操作界面，专为图像生成任务设计。‌它通过将深度学习模型的工作流程简化为图形化节点，使用户操作更加直观和易于理解。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 提供了高度的可视化和扩展性，用户可以通过拖放操作来构建和调整图像生成流程，无需编写代码。‌作为大模型图像生成领域的最热门框架之一，其在 GitHub 斩获了接近 7W Star，备受开发者喜爱，根据网络空间测绘数据，全网共有近 2700 例 ComfyUI 服务，其中不乏无需密码直接访问的案例。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 后台支持加载用户指定的模型文件，同时用户可以方便地管理模型。但给用户带来便利的同时，也存在一些安全隐患。&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;376&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161939_EGHc_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;百度安全在捕获的攻击事件中发现，攻击者利用 ComfyUI 用户错误配置问题，在无需认证的情况下进入到 ComfyUI 后台，同时利用后台模型加载功能安装攻击者提前上传在 Hugging Face 的投毒模型文件，以便利用模型加载时的 pickle 反序列化逻辑，控制受害者机器，进一步渗透目标内网。&lt;/p&gt; 
&lt;p&gt;本次事件攻击者主要利用了 ComfyUI 控制枱无身份鉴权的配置错误问题进入控制后台，并通过 ComfyUI-Manager 插件中的远程下载功能从 Hugging Face 及其镜像站等相关模型仓库拉取投毒模型（.pth 后缀的文件），使得开发者在使用 ComfyUI 加载投毒模型时会因自身的 pickle 反序列化逻辑触发恶意的 Loader，进而执行恶意 Bash 脚本，脚本会从攻击者的服务器上拉取 C2 木马进行远程控制，C2 域名为 cloudflare.com 提供给普通用户使用的隧道服务（用户可以无需外部域名和 ip 就可以把内网的服务映射到外部），攻击者滥用该服务，达成隐蔽控制的目的。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;696&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/162047_QvnF_2720166.png&quot; width=&quot;941&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;据 CVE 官方披露，ComfyUI 历史存在多种漏洞类型，包括：任意文件读取漏洞、远程代码执行漏洞、存储 XSS 漏洞等。&lt;/p&gt; 
&lt;p&gt;相关漏洞已分配如下 CVE 编号：CVE-2024-10099、CVE-2024-21574、CVE-2024-21575、CVE-2024-21576、CVE-2024-21577。&lt;/p&gt; 
&lt;p&gt;本次事件主要利用的 ComfyUI 默认无身份鉴权机制的&quot;特性&quot;，从而直接访问 ComfyUI 后台。但该「特性」官方并不认为是安全漏洞，归因为用户错误配置，在使用上官方始终认为使用者应自行注意，不要将 ComfyUI 对公网暴露或应该通过沙箱环境运行，以确保 ComfyUI 安全。&lt;/p&gt; 
&lt;p&gt;参考&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomfyanonymous%2FComfyUI%2Fdiscussions%2F5165&quot; target=&quot;_blank&quot;&gt;https://github.com/comfyanonymous/ComfyUI/discussions/5165&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340226</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340226</guid>
            <pubDate>Fri, 21 Mar 2025 08:21:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>CleanRL —— 深度强化学习库</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CleanRL 是一个深度强化学习库，提供具有研究友好功能的高质量 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;single-file&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实现。该实现简洁明了，但我们可以使用 AWS Batch 对其进行扩展以运行数千次实验。CleanRL 的亮点包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;Single-file&amp;nbsp;&lt;/span&gt;实现

&lt;ul&gt;
&lt;li&gt;关于算法变体的每个细节都被放入一个独立的文件中。&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;ppo_atari.py&lt;/code&gt;只有 340 行代码，但包含了 PPO 如何与 Atari 游戏配合使用的所有实现细节，&lt;strong&gt;因此对于不想阅读整个模块库的人来说，它是一个很好的参考实现&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://benchmark.cleanrl.dev/&quot;&gt;基准测试实施（ https://benchmark.cleanrl.dev&lt;/a&gt;上的 7 种以上算法和 34 种以上游戏）&lt;/li&gt;
&lt;li&gt;Tensorboard&amp;nbsp;Logging&lt;/li&gt;
&lt;li&gt;Local Reproducibility via Seeding&lt;/li&gt;
&lt;li&gt;游戏视频捕捉&lt;/li&gt;
&lt;li&gt;利用&lt;a href=&quot;https://wandb.ai/site&quot;&gt;权重和偏差进行实验管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;与 Docker 和 AWS 进行云集成&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/cleanrl</link>
            <guid isPermaLink="false">https://www.oschina.net/p/cleanrl</guid>
            <pubDate>Fri, 21 Mar 2025 08:20:00 GMT</pubDate>
        </item>
        <item>
            <title>快手搜索已全面接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;快手搜索官方宣布已全面接入 DeepSeek R1 的大模型能力，优化搜索效果与用户体验，未来也会持续探索智能搜索场景的商业化变现能力。&lt;/p&gt; 
&lt;p&gt;此前，快手已宣布&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fir.kuaishou.com%2Fzh-hans%2Fnews-releases%2Fnews-release-details%2Fkuaishou-kling-ai-integrates-deepseek-lowering-entry-barrier-ai%2F&quot; target=&quot;_blank&quot;&gt;可灵 AI 已全面接入 DeepSeek-R1&lt;/a&gt;&lt;/u&gt;，在视频生成、图片生成等场景下，用户可通过 DeepSeek 协助生成或者优化提示词，将灵感转化为专业提示词，打造高质量创意视频。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;3436&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161226_9Zcs_2720166.png&quot; width=&quot;2324&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340224</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340224</guid>
            <pubDate>Fri, 21 Mar 2025 08:12:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>印度人工智能快速发展隐忧犹存</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在美国斯坦福大学 2024 年底发布的《全球人工智能实力排行榜》上，印度在全球 36 个国家 AI 活跃度综合评估中排名第四位，仅次于美国、中国和英国。今年 2 月，印度总理莫迪提出了印度的「双重 AI」愿景。第一重「AI」是人工智能（Artificial Intelligence），第二重「AI」是有雄心的印度（Aspirational India）。随后印度与法国在巴黎联合主办了「人工智能行动峰会」，向全世界展示了印度希望通过人工智能推动经济转型升级，实现跨越发展的目标。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度政府近年来不断加大对人工智能领域的投入。2024 年 3 月，印度政府启动「印度人工智能使命（India AI Mission）」，这是一项国家产业发展规划，为印度人工智能初创企业提供包括 GPU（图形处理器）关键算力在内的数字基础设施服务以及政策和资金支持，计划推动印度人工智能市场在 2024 年至 2027 年之间年均增长率达到 25% 至 35%，并在 2027 年创造 170 亿美元的价值。全球统计数据库（Statista）预计，2025 年，印度人工智能市场规模将超过 80 亿美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度拥有庞大的人口基数和多样化的市场需求，为人工智能技术应用提供了广阔空间。在政府大力扶持下，阿达尼、塔塔、信实集团等印度本国大企业近年来不断加大人工智能和数据中心建设投资，助推印度数字经济发展。威普罗（Wipro）、菲尔洛普（Verloop）等印度本土私营人工智能企业也加大研发投资和应用推广，加速拓展本土和周边国家市场，特别是印度企业凭借本国语言多样性优势，训练适用广泛的多语言数据模型，已经成功拿下多个东南亚、南亚国家政府订单。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但相较而言，印度自主研发人工智能技术面临较大挑战。研发偏基础研究而非应用研究，基础编程人员多，应用研究人才少，同时大量技术人才流失，大多流向美西方科技企业，研发投入整体仍显不足，推动研究成果商业化的生态系统有待完善。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对本国企业在技术研发能力上的不足，印度政府借助与世界顶尖人工智能研究机构和企业合作，利用世界现有先进技术实现应用层面的创新，加速自身技术突破。近年来，谷歌、微软、亚马逊、AMD 等国际科技企业高层频频造访印度，科技巨头们也纷纷宣布大规模投资印度人工智能和大数据项目。今年 2 月初，OpenAI 首席执行官萨姆·奥尔特曼在会见印度铁道、通信以及电子和信息技术部长阿什维尼·瓦伊什瑙时表示，印度是人工智能领域重要的市场，应当成为人工智能革命的领导者之一。在中国开源人工智能模型深度求索（DeepSeek）推出后，印度政府表示，将在本土服务器上部署 DeepSeek，并计划再用 6 个月至 10 个月的时间，根据不同文化和语言需求设计开发出印度自己的开源人工智能基础大模型。印度政府希望，届时印度将在人工智能领域具备更强的国际竞争力，能够为世界提供「另一个有希望的替代方案」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;不过，在印度人工智能市场快速发展的背后也存在隐忧。有专家指出，人工智能热潮可能冲击印度以服务业为主的产业结构，人工智能的替代效应可能造成规模性失业和消费下滑，抑制人口红利释放，加大印度政府通过劳动密集型产业推动工业化的难度。一旦人工智能发展不能与工业制造业发展兼容，印度可能错过本轮产业升级窗口期。 （经济日报记者，王宝锟）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340223</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340223</guid>
            <pubDate>Fri, 21 Mar 2025 08:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Midjourney 核心开发者离职，加入 Cursor 负责开发 AI 编程 Agents</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;负责 Midjourney V2 至 V7 模型开发的核心工程师 theseriousadult 在 X 上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fgallabytes%2Fstatus%2F1902864672728158610&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;&lt;/u&gt;已从公司离职。&lt;/p&gt; 
&lt;p&gt;theseriousadult 写道：「&lt;strong&gt;&lt;em&gt;我几乎从第一天起就一直在使用 Cursor，我真的很高兴能开始从事长期以来在我的工作流程中如此重要的事情。语言模型将改变我们构建代码和与代码交互的方式，我想将其推向极限。&lt;/em&gt;&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2593&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/154821_Ouez_2720166.png&quot; width=&quot;1304&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;这位开发者在 Midjourney 的三年时间里，主导了多个版本的模型迭代，以其对美学与创意的专注而闻名，其工作成果深受业界赞誉。离职后，theseriousadult 加入 Cursor 负责开发 AI 编程 Agents。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;阅读更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/337993/anysphere-in-talks-for-close-to-10-billion-valuation&quot; target=&quot;news&quot;&gt;AI 编程神器 &quot;Cursor&quot; 估值达百亿美元&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/320498/anysphere-acquires-supermaven&quot; target=&quot;news&quot;&gt;Cursor 母公司 Anysphere 收购 AI 编码助手 Supermaven&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340219</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340219</guid>
            <pubDate>Fri, 21 Mar 2025 07:53:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>腾讯元宝新技能：支持分析复杂 Excel 表格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;腾讯元宝&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FV3c4L5T9jvSMACo2JRtrxw&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;推出一项新功能，能够帮助用户分析复杂 Excel。「你只需要把表格给到元宝，元宝就能直接算、直接答，还能画重点。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在过去，处理 Excel 表格往往需要用户记住大量的函数和公式，稍有不慎就可能导致错误。现在，用户只需将表格上传至元宝平台，元宝就能直接进行分析，无需用户手动输入公式或进行复杂的操作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;394&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7eae121ba5a814f0370a2c7d0fc4f138ce3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在碰到体量很大、需要做复杂计算的表格时，可以切换到 Hunyuan，并关闭深度思考。这样，快思考模型混元 Turbo S 就可以用代码的方式进行快速分析。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，腾讯元宝不仅支持本地上传表格，还支持从微信和腾讯文档直接导入。无论是电脑版、Web 版还是移动端，用户都可以无缝切换。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338559&quot; target=&quot;news&quot;&gt;腾讯元宝宣布支持上传、导出腾讯文档&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340214</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340214</guid>
            <pubDate>Fri, 21 Mar 2025 07:36:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>百度：任何人无权触碰用户数据</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在就 「谢广军女儿开盒」 事件发布声明后，百度于 3 月 20 日下午召开信息安全沟通会，针对事件的调查过程及结果进行现场说明，并展示经三方公证的「（2025）京精诚内经证字第 1642 号」公证书。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;492&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d450818c480c7db9cb2aaf28a87e1384093.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度安全负责人陈洋表示，&lt;strong&gt;百度任何职级的员工及高管均无权限触碰用户数据&lt;/strong&gt;。同时披露了事件调查结果：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;事件发生以来，百度对当事员工的「历史数据申请记录」、「权限记录」、「数据查询」等多项权限和操作日志进行了调查与审计，确认其没有百度用户个人身份信息的数据权限，也未登录任何百度数据库与服务器。经核实，确认开盒信息并非从百度泄露。该过程，全程经过三方现场公证。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;针对「开盒事件」发生后网上流传的「当事人承认家长给她数据库」截图，经核实发现，该截图的信息内容不实，事实为博主收到家人红包后，在平台晒出红包截图，博主回复「我家长给的」，本意是想说明红包的来源，与「开盒」无关，事件发生后的大量传播信息均为不实。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;并详细讲解了百度针对数据安全的多项防护措施：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户注册账号阶段，即实施假名化处理，降低数据泄露风险，提高数据合规性；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;对数据实施加密，对敏感数据进行严格隔离，并依托数据安全管理平台，实现数据管理、权限控制及安全审计的统一管控；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;遵循国际公认的风险控制理念，建立「基础防守」、「制度&amp;amp;能力&amp;amp;风险专项」、「稽查&amp;amp;内部审计」三道安全防线。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度表示，在相关政府部门的指导下，积极响应和倡议推进「反开盒」联盟的成立，共同加强数据隐私防护，严厉打击非法数据窃取及泄露行为，筑牢网络安全防线，共同维护清朗网络空间。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相关阅读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/339949&quot; target=&quot;_blank&quot;&gt;百度就 「谢广军女儿开盒」 事件发布声明&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340213</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340213</guid>
            <pubDate>Fri, 21 Mar 2025 07:22:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>13 年后，AlexNet 源代码终于公开</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌首席科学家 Jeff Dean 宣布，他们与计算机历史博物馆（CHM）合作，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcomputerhistory.org%2Fblog%2Fchm-releases-alexnet-source-code%2F&quot; target=&quot;_blank&quot;&gt;共同发布了 AlexNet 的源代码&lt;/a&gt;&lt;/u&gt;，并将长期保存这些代码。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150916_mJ2m_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;开放后的代码库如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;520&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/150931_Gm2o_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;GitHub 链接：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomputerhistory%2FAlexNet-Source-Code&quot; target=&quot;_blank&quot;&gt;https://github.com/computerhistory/AlexNet-Source-Code&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;AlexNet 是一个人工神经网络，用于识别照片内容。它由当时的多伦多大学研究生 Alex Krizhevsky 和 Ilya Sutskever 以及他们的导师 Geoffrey Hinton 于 2012 年开发。&lt;/p&gt; 
&lt;p&gt;在计算机历史上，AlexNet 的出现有着划时代的意义。在它出现之前，很少有机器学习研究人员使用神经网络。但在 AlexNet 出现之后，几乎所有研究人员都会使用神经网络。从 2012 年到 2022 年，神经网络不断取得进步，包括合成可信的人类声音、击败围棋冠军选手、模拟人类语言并生成艺术作品…… 最终，OpenAI 于 2022 年发布 ChatGPT…… 它是这一系列故事的重要起点。&lt;/p&gt; 
&lt;p&gt;「谷歌很高兴将具有开创性意义的 AlexNet 项目的源代码贡献给计算机历史博物馆」，Jeff Dean 说，「这段代码是 Alex Krizhevsky、Ilya Sutskever 和 Geoffrey Hinton 撰写的标志性论文《ImageNet Classification with Deep Convolutional Neural Networks》的基础，该论文革新了计算机视觉领域，是有史以来被引用次数最多的论文之一。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/151006_C9sF_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Google Scholar 数据显示，AlexNet 相关论文被引量已经超过 17 万。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;除了代码本身的价值，HuggingFace 联合创始人 Thomas Wolf 还发现，代码中的注释也非常有启发性。他说，「也许真正的历史记录是 AlexNet 代码中每个实验配置文件末尾的实验记录注释。一个开创性的神经网络正在诞生……」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1454&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/151021_yhzH_2720166.png&quot; width=&quot;1204&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</guid>
            <pubDate>Fri, 21 Mar 2025 07:11:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 上线 OpenAI.fm 网站</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;今天凌晨，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/340143/openai-next-generation-audio-models&quot;&gt;OpenAI 上线了全新语音模型 API&lt;/a&gt;&lt;/u&gt;，具体包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-transcribe (语音转文本)&lt;/strong&gt;：单词错误率 (WER) 显著降低，在多个基准测试中优于现有 Whisper 模型&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-mini-transcribe (语音转文本)&lt;/strong&gt;：gpt-4o-transcribe 的精简版本，速度更快、效率更高&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-mini-tts (文本转语音)&lt;/strong&gt;：首次支持「可引导性」(steerability)，开发者不仅能指定「说什么」，还能控制「如何说」&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为了让用户体验这些全新的语音模型，OpenAI 上线了一个新网站：&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.openai.fm%2F&quot; target=&quot;_blank&quot;&gt;https://www.openai.fm/&lt;/a&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;用户可以在 OpenAI.fm 网站上体验并制作 gpt-4o-mini-tts 的相关音频，这个演示网站可谓是功能齐全，其中包含了官方的预设模板，提供&lt;strong&gt;人设、语气、方言、发音&lt;/strong&gt;等设置。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150127_tnfp_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3249e7adafd64b35ea62bad76f0f6934b7d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;值得一提的是，OpenAI 还举办了一个广播比赛。用户可以在 http://OpenAI.fm 制作音频，接着使用 OpenAI.fm 上的「分享」按钮生成链接，然后在 X 平台分享该链接。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3604eb6d4cae2ec616dfdca711e05d376bb.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;最具创意的前三名将各获一台限量版 Teenage Engineering OB-4。音频时长建议控制在 30 秒左右，可在语音、表达、发音或剧本语调变化上尽情发挥创意。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340209/openai-fm</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340209/openai-fm</guid>
            <pubDate>Fri, 21 Mar 2025 07:05:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>苹果因 Apple Intelligence 功能延迟面临集体诉讼</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;苹果公司在美国加州圣荷西的联邦法院遭到了一起集体诉讼，原告指控苹果在多个 「Apple Intelligence」 功能的宣传中存在虚假广告行为。诉讼于周三提交，原告寻求对购买了具备 Apple Intelligence 功能的 iPhone 及其他设备的消费者进行赔偿。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;244&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7761c132a0cc697735299b460941837b6de.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据原告的投诉，他们认为苹果的广告为消费者树立了一个清晰且合理的期望，即这些革命性的功能将在 iPhone 发布时可用。然而，原告表示，用户所实际体验到的苹果智能功能远未达到这些宣传的水平，存在明显的限制，甚至有些功能完全没有实现。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;原告的律师在投诉中指出：「苹果的广告让消费者误以为这些先进的人工智能功能会在产品发布时全面可用，但实际上，产品所提供的功能却大大低于消费者的预期，这严重误导了消费者对其实际效用和性能的理解。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此诉讼的提出正值苹果在推向市场的 Apple Intelligence 功能遭遇困难之际。据彭博社报道，苹果首席执行官蒂姆・库克对负责产品开发的人工智能主管约翰・贾安德雷亚的执行能力表示失去信心。这使得苹果在推进这些备受期待的功能上遭遇了不小的挑战，也给公司带来了新的压力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340205/apple-suit-false-advertising-ai-intelligence</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340205/apple-suit-false-advertising-ai-intelligence</guid>
            <pubDate>Fri, 21 Mar 2025 06:53:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>哈佛研究：Go 商业价值达 8.03 亿美元，开源经济价值达 8.8 万亿美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;哈佛商学院发布的一项&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.hbs.edu%2Fris%2FPublication%2520Files%2F24-038_51f8444f-502c-4139-8bf2-56eb4b65c58a.pdf&quot; target=&quot;_blank&quot;&gt;研究报告指出&lt;/a&gt;，开源软件的经济价值高达 8.8 万亿美元。如果没有开源程序，公司在软件上的花费将增加约 3.5 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由于开源应用程序大多免费，而且其使用数据只能在有限范围内测量，价值无法通过价格与销售额的乘积来确定。因此研究人员计算的是供给价值，即开发新开源程序的成本。另一方面还计算了需求价值；即如果公司必须自己开发每个开源应用程序，他们将承担的成本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;352&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-51527f4c243c759bfdf8a25bc1280adaaa9.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根据研究人员的计算，供给价值为 41.5 亿美元；需求价值则高出 2000 倍，为 8.8 万亿美元。相比之下，2020 年全球软件支出约为 3.4 万亿美元。此外，约 5% 的开发人员占供给价值的约 93%，占需求价值的 96%。研究报告的作者认为，这种不均衡的分布是少数开发者使用众多资源库的结果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;研究人员还研究了不同编程语言和标记语言的商业价值。例如，Go 语言的报价价值约为 8.03 亿美元。其次是 JavaScript（7.58 亿美元）、Java（6.58 亿美元）和 C（4.06 亿美元）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;尽管 Python 近两年来广受欢迎，但其供给价值仅为 5500 万美元。在需求方面，Go 的价值最高，超过 5 万亿美元，是排在第二位的 JavaScript 的四倍多。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;为了确定公司对开源软件的使用情况，研究人员使用了两组不同的数据集。其中一组识别出公司产品中包含的开源代码。第二组数据集显示公司网站上可用的代码。但是，这些数据并不包括所有开源项目。研究人员没有记录开源操作系统。为了计算经济价值，研究作者使用了 GitHub 上用户份额最高的 30 个国家的薪资数据。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，研究人员还警告称，开源软件是现代社会的共同利益。不应被过度使用，并敦促企业考虑到开源程序的经济价值，为其自身的发展做出贡献；且政治决策者有责任推动开源项目的发展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;详情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.hbs.edu%2Fris%2FPublication%2520Files%2F24-038_51f8444f-502c-4139-8bf2-56eb4b65c58a.pdf&quot; target=&quot;_blank&quot;&gt;查看完整报告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340203/value-open-source-software</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340203/value-open-source-software</guid>
            <pubDate>Fri, 21 Mar 2025 06:44:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>数据思维 = 会写 SQL 或 Python？</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;OSCHINA 编辑部【OSC 有问必答】栏目，每周一会，聚焦开发者提出的实际问题，邀请行业专家、技术大咖或资深开发者进行深度剖析和解答，人话版呈现开发者们最关心的问题。&lt;/p&gt; 
 &lt;p&gt;欢迎各位开发者说出你最关心的技术难题，也欢迎资深开发 er、行业专家、学者大咖们自荐！&lt;/p&gt; 
 &lt;p&gt;交流可添加微信：JunoHsu1122&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;p&gt;数据驱动的时代，开发者们面临的挑战不仅仅是技术实现，更是如何将数据转化为实际的业务价值。&lt;/p&gt; 
 &lt;p&gt;数据思维，作为连接技术与业务的桥梁，正逐渐成为开发者们的必备能力。&lt;/p&gt; 
 &lt;p&gt;本期【OSC 有问必答】栏目，我们邀请到了拥有十年银行数据分析项目经验的资深专家钱兴会，他将从实战角度出发，深入探讨数据思维的本质、应用场景以及如何在银行业务中落地。&lt;/p&gt; 
&lt;/div&gt; 
&lt;blockquote&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;本期嘉宾：&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;钱兴会&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;Fintech&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt; Career 社区主理人、北京市人工智能行业协会专家、清华大数据产业联盟专家委员会专家、广东大数据产业联盟专家委员、拥有超过十年银行&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;数据分析&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;项目经验的资深专业人士，服务了数十家大型银行。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;在金融领域的多个数据驱动项目中发挥了关键作用，擅长通过&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;数据挖掘&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;与分析提升业务效率与决策质量。专业背景涵盖了风险管理、客户行为分析以及产品优化等多个领域。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;通过构建高效的数据模型，帮助银行实现了&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;信贷&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;审批流程的优化和客户关系的精细化管理。除了技术能力，还具备出色的项目管理和团队协作能力，曾带领团队成功完成多个大型&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;数据分析&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;项目。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;数据思维破壁：从&quot;会写 SQL&quot;到&quot;驱动业务增长&quot;&lt;/h2&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;问：许多开发者认为「数据思维=会写 SQL 或 Python」，您如何看待这种说法？我们可以从哪些维度重新定义数据能力？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;这其实是个挺常见的误解。会写 SQL、Python 只是数据能力的基础，但远远不等于数据思维。很多人能用 SQL 查询数据，或者用 Python 画个图，但如果不懂数据的业务背景、分析方法、甚至数据质量，最终只能停留在「执行任务」的层面，而不是「用数据创造价值」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如果要真正定义数据能力，可以从这几个维度来思考：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;数据理解：不仅是数据本身，还包括它的业务背景、来源、质量、限制等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据分析：能够用合适的方法分析数据，而不是简单的统计汇总。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据应用：能把数据分析结果转化为实际的业务决策或优化方案。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据沟通：能把复杂的分析结论用清晰、易懂的方式表达给不同角色的人，比如业务人员、管理层。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据策略：能站在全局角度思考，如何用数据驱动业务增长，而不是只做单次分析。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;所以，数据思维是个更全面的能力，而不仅仅是「会写代码」这件事。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：与传统技术思维相比，数据思维最关键的差异点是什么？开发者如何避免将数据分析仅视为「工具」，而是升级为系统性思维？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最大的区别在于「结果导向」和「闭环思维」。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;传统技术思维，更关注「我能不能做出一个系统」「代码能不能跑」「接口能不能通」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据思维，关注的是「这个数据分析能不能带来实际价值」「业务能不能用数据做更好的决策」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;建立数据反馈闭环：不是做完数据分析就结束，而是要观察这个数据分析带来的业务变化，有没有帮助决策改进？有没有后续可以优化的地方？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;业务驱动的数据应用：先理解业务痛点，再用数据来解释和优化，而不是只为了分析而分析。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;数据产品化思维：能不能让数据分析变成一个可复用的工具，而不是每次都临时做个报表？&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;数据分析不是终点，而是让业务变好的起点。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：数据可视化常被简化为「图表生成」，还有其他方式可以让数据结果真正驱动业务行动吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;很多人觉得数据可视化就是「做个图表」，但实际上，数据可视化的目的是让决策更直观、更容易落地。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;更好的方式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;异常数据自动报警：不要只是做图表，而是让关键数据出现异常时自动提醒相关人员。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;决策建议+可视化结合：不仅仅展示「销售下降了 20%」，而是直接告诉你「下降的原因是哪些产品销售变差」并给出优化建议。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;场景化数据呈现：让数据和业务流程结合，比如在银行审批系统里，直接可视化企业的信用评分趋势，而不是让审批员去查一堆表。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：数据思维为什么还需要业务翻译能力，开发者如何快速构建业务知识图谱，并将数据思维融入其中？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;数据分析做得好不好，70% 靠对业务的理解，但很多开发者的痛点是——「业务方听不懂技术，技术方搞不懂业务」，所以需要**「业务翻译能力」**。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;关于为什么需要业务翻译能力？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;业务人员可能会提一些模糊的需求，比如「帮我们看看这个产品的活跃度」，但没有明确数据指标。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技术团队如果不理解业务，就容易查一堆无关数据，最后的分析报告业务方根本看不懂。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：如何快速构建业务知识图谱？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;梳理关键业务流程：比如在银行的贷款审批流程中，核心数据是什么？哪些指标能影响业务决策？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;搭建业务-数据映射关系：比如「贷款审批成功率」=「审批通过人数/申请人数」，让数据与业务语言对齐。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;知识沉淀：把常见的业务数据问题和分析框架形成数据文档，方便新团队成员快速上手。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;数据思维的终极目标是让数据变成「业务资产」，而不是一堆表、一堆代码。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;银行实战场景：当数据思维遇上模糊需求&lt;/h3&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：银行开发者常面临业务部门需求模糊的问题。如何用数据思维反向推动业务方清晰表达需求？能否分享一个成功案例？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;银行业务方经常丢给开发者一个很模糊的需求，比如：「帮我们分析一下贷款用户的活跃度」&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如果开发者直接去查数据，十有八九会查出一堆没啥用的表，最后业务方还会说「这不是我们想要的」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;用数据思维引导业务方明确需求，确保数据分析有价值。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;第一步，追问业务目标：直接问业务方——你们想通过这个数据分析做什么决策？是想提高贷款转化率？还是优化营销策略？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第二步，定义关键指标：根据目标，先列出可能的衡量指标，比如「贷款用户 7 天留存率」「申请到审批通过的转化率」等，让业务方选出最相关的指标。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第三步，提供数据示例：先用小样本数据跑个初步分析，让业务方看到大概的趋势，然后再调整具体的数据需求。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;某银行信用卡审批优化，以前，风控部门总是要求「优化信用卡审批流程」，但从来不给明确的衡量标准。后来，技术团队用数据思维反向提问：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;你们是想降低坏账率，还是想提高审批效率？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;现有审批流程中，哪些步骤最容易导致用户流失？&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最终，大家发现问题其实是**「高信用评分用户的审批流程太长，导致用户流失」**，于是用数据优化了审批规则，审批时长缩短了 40%，但坏账率基本没变。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;所以，开发者不是等着业务方给需求，而是主动用数据思维，帮他们找到真正的问题。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：银行普遍存在数据孤岛问题，开发者如何通过数据思维推动跨部门协作？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;银行的数据孤岛问题很严重，比如贷款部门的数据和信用卡部门的数据互不相通，导致很多高信用客户的二次转化机会被浪费。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;开发者可以这样推动跨部门协作：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;用数据案例说服业务方：拿出一个实际的数据例子，比如「如果信用卡用户的高信用群体能更快审批贷款，预计能提升 20% 的贷款转化率」，让不同部门看到数据共享的直接价值。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;推动数据标准化：不同部门的数据口径不同，要先建立标准，比如「统一的用户 ID、统一的信用评分模型」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;借助低代码或数据中台：有些银行已经开始用低代码或数据中台，让不同部门的数据能够更方便地交互，减少开发工作量。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;数据孤岛不是技术问题，而是组织问题。解决方案是让业务方看到数据共享的直接好处。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：对公业务数据分析复杂度更高，如何通过数据思维帮助开发者从「流程自动化」进阶到「业务洞察自动化」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;对公业务数据涉及多个维度，比如企业的现金流、信用状况、行业趋势等，光是做流程自动化（比如审批流程、报表自动生成）是不够的，还需要做「业务洞察自动化」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如何进阶？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;从被动分析转向主动推荐：比如企业申请贷款时，系统可以自动分析企业财务数据，并给出「最合适的贷款方案」推荐。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;结合外部数据，形成完整视角：不仅仅看企业在银行的交易数据，还可以结合行业数据、供应链数据，让分析更加准确。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;做可解释的智能分析：对公业务决策往往需要人工审批，所以数据分析结果需要清晰可解释，不能是黑箱。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;举个例子：智能风控，某银行以前的风控策略是「手动审核企业财务报表」，但后来用数据智能分析，结合历史交易、行业对比等，自动给出「高风险信号预警」，大大提升了审批效率。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;技术人进阶指南：从「数据工具人」到「业务驱动者」&lt;/h3&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：在数据驱动的决策流程中，技术团队如何平衡「快速响应业务」与「保证数据建模严谨性」的矛盾？是否存在「最小可行数据产品」方法论？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最好的方法是**「最小可行数据产品（MVDP）」**，即：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;先做一个可验证的小规模数据模型，看数据是否真的有价值&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;快速测试，持续优化，而不是一开始就做一个庞大的数据模型&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;业务和数据团队协作迭代，数据团队提供初步模型，业务团队反馈后再优化&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;关键思路：小步快跑，快速验证，持续优化。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：建议开发者掌握哪些「高性价比」数据分析工具链？如何避免陷入技术选型内耗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;其实工具只是手段，核心还是看业务需求和实际场景。如果追求高性价比，建议采用「通用工具+行业专用工具」的思路&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;通用型数据分析工具（适合大多数银行开发者）&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;SQL（PostgreSQL / MySQL / ClickHouse） → 数据查询和 ETL 的基础&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Python（Pandas、NumPy、Scikit-Learn） → 数据清洗、分析、建模的主力工具&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BI 工具（Tableau / Power BI / Metabase） → 数据可视化和业务报表&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;适用于银行场景的工具&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;金融大数据处理：Spark（大数据计算）、Flink（流式计算）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;智能风控与反欺诈：GraphDB（图数据库）、Neo4j（社交关系分析）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;自动化数据治理：DataHub / Apache Atlas（数据目录管理）&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;关于如何避免技术选型内耗？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;以业务需求为导向：先搞清楚问题是什么，再选工具，而不是因为「这个工具火」就去用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;避免重复造轮子：很多银行内部都有数据中台，尽量复用已有的数据基础设施。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;先小规模试点，再推广：比如尝试用 ClickHouse 替换传统 OLAP 查询，如果效果好再推广，而不是一上来就做大迁移。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：AI 大模型（如生成式 AI、多模态模型）正在颠覆传统的数据分析范式。您认为这对银行从业者的「数据思维」提出了哪些新要求？是否需要从「因果分析」转向「关联洞察」为主？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;大模型的出现，确实让传统数据分析逻辑发生了变化：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;以前的分析是「基于规则和统计」，我们关注因果关系，比如「存款利率提高 → 储蓄账户开通数量增加」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;但现在的 AI 大模型更擅长从复杂数据中发现隐藏的模式和关联，比如「某种用户行为 → 可能意味着更高的信用风险」，但这个模式未必能直接解释「因果逻辑」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;新的数据思维要求：从因果分析向「关联洞察」拓展&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;传统数据分析=「A→B 的因果关系」&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;AI 数据分析=「A、B、C…有强相关性，可能影响业务」&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;银行可以利用 AI 提前发现风险信号，而不仅仅依赖已有的规则。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;让 AI 成为业务分析助手，而不是替代传统分析&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;生成式 AI 可以自动总结数据趋势，但分析员仍需验证 AI 的结论是否合理。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;加强数据治理，确保 AI 洞察的可解释性&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;AI 大模型让银行的「数据思维」从因果逻辑拓展到了「全局模式发现」，但开发者仍然需要结合因果推理，避免过度依赖「黑箱相关性」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;问：AI 大模型能自动生成分析报告甚至决策建议。这是否会导致开发者过度依赖 AI 工具，反而弱化数据思维的培养？如何设计人机协作的边界？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;AI 确实可以帮我们生成分析报告、图表，甚至自动做决策建议，但完全依赖 AI 是不现实的。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;潜在风险：AI 的分析结果不一定正确；AI 的分析是基于历史数据训练的，如果数据有偏差，AI 的结论也可能有误。比如 AI 可能会误判「某类贷款用户的风险更高」，但其实只是历史数据里这类用户较少。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;AI 缺乏业务上下文：AI 可以总结数据趋势，但它不知道「这个趋势是否符合市场变化」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;例如，如果 AI 发现「2023 年房贷违约率下降」，它不会考虑是不是因为政府推出了新的购房政策。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如何设计「人机协作」的边界？最佳方案：让 AI 成为数据分析的「助手」，但最终决策仍然由人来做。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;让 AI 自动生成初步分析，但让人类去验证并最终调整。 v 设定「人机协作的检查机制」，比如在 AI 给出金融风控建议时，风控团队要有一套人工审核机制，确保 AI 不会做出错误判断。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4489239/blog/17963082</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/17963082</guid>
            <pubDate>Fri, 21 Mar 2025 06:40:00 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>Anthropic 为 Claude 增加联网搜索功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Anthropic &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fweb-search&quot; target=&quot;_blank&quot;&gt;宣布&lt;/a&gt;&lt;/u&gt;为旗下 Claude 聊天机器人增加 Web 搜索功能，启用该功能后，Claude 会自动联网搜索信息，并在反馈结果中会提供引用出处，以便用户核实来源。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/143104_Yw2o_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-eedcd8f5f771ae0e8c0be9db894e9397cfc.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;据悉，搜索功能目前已面向美国 Cladue 付费用户推出预览版，不久将向免费用户和其他国家提供支持。用户可以在 Cladue 的个人档案设置中开启 Web 搜索，Cladue 会自动搜索各个网站，为回复提供信息来源。&lt;/p&gt; 
&lt;p&gt;与 ChatGPT 不同，Claude 并未在输入框中设置专门的「搜索」按钮，用户需在个人设置中开启联网搜索功能。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/143726_vIPC_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 表示，Web 搜索目前只能在 Claude 的最新模型中使用，即 Claude 3.7 Sonnet。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340196/anthropic-claude-web-search</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340196/anthropic-claude-web-search</guid>
            <pubDate>Fri, 21 Mar 2025 06:29:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
    </channel>
</rss>