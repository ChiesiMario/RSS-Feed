<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>开源中国-最新资讯</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>开源中国-最新资讯 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Thu, 05 Sep 2024 13:47:10 GMT</lastBuildDate>
        <ttl>180</ttl>
        <item>
            <title>开源日报 | Qwen 在 GitHub 上显示 404；KK 预测人工智能三大趋势；IBM 败走中国；智谱 AI 又融资了；OpenBMC 成服务器固件发展的「事实标准」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2024.9.5&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要闻&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310448/qwenlm-github-repo-404&quot;&gt;阿里通义千问全系列大模型被 GitHub 下架，所有仓库页面「404」&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p&gt;9 月 5 日早上，有开发者在社交平台上称在 GitHub 上打开阿里云 Qwen 页面后显示 404。&lt;/p&gt; 
 &lt;p&gt;阿里高级算法专家林俊旸在社交媒体上表示：「GitHub 因未知原因标记了我们的组织，我们正在尝试与他们联系以寻求解决方案。」&lt;/p&gt; 
 &lt;p&gt;直到当天下午，阿里通义千问全系列大模型的开源代码仓库恢复正常访问。&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FQwenLM&quot; target=&quot;_blank&quot;&gt;https://github.com/QwenLM&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;blockquote&gt; 
  &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2024/0905/175943_6ZHA_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;/blockquote&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310410/01-ai-yi-coder&quot;&gt;零一万物开源 Yi-Coder 系列编程助手模型&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;零一万物正式开源了 Yi-Coder 系列编程模型。Yi-Coder 系列模型专为编码任务而生，提供 1.5B 和 9B 两种参数。其中，Yi-Coder-9B 的表现号称 「优于其他 10B 参数以下的模型」，如 CodeQwen1.5 7B 和 CodeGeex4 9B，甚至能够 「与 DeepSeek-Coder 33B 相媲美」。&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;Yi-Coder 能够处理最长 128K tokens 的上下文内容，适用于复杂项目级代码的理解和生成。Yi-Coder 还支持 52 种主要编程语言。&lt;/p&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtcuQJ56sxH8dL_2NJ3sUiw&quot; target=&quot;_blank&quot;&gt;微软在 Windows 11 集成中国开源大模型架构 RWKV、装机量近 5 亿&lt;/a&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;2024 年 9 月 ，RWKV 社区成员发现：Office 系统在自动更新后（版本 2407 及以后）已自带 RWKV 运行库。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;在 Windows 系统的&amp;nbsp;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\OFFICE16&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;目录，可以找到一系列&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;rwkv&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;dll（动态链接库） 文件。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;RWKV dll in Windows&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-in-windows-os.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;由于正版 Windows 大多预装了 Office 365，因此，全球大多数 Windows 10 和 11 机器现已搭载 RWKV，包括线下商店中售卖的 Windows 机器。这意味着 RWKV 的装机量可达几亿台。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;RWKV 是真正的开源架构（目前在&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flfaidata.foundation%2Fprojects%2Frwkv%2F&quot; target=&quot;_blank&quot;&gt;Linux Foundation 旗下&lt;/a&gt;），遵循 Apache 2.0 协议，可用于商业，欢迎大家在各个项目使用。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;strong&gt;RWKV 的最新架构为 RWKV-6，且 RWKV-7 即将公布。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/310590&quot; target=&quot;news&quot;&gt;著名未来学家凯文·凯利（KK）预测人工智能三大趋势&lt;/a&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;2024 Inclusion・外滩大会今天在上海黄浦世博园区开幕。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;著名未来学家、《连线》杂志创始主编、《5000 天后的世界》作者凯文・凯利（Kevin Kelly，「KK」）在开幕主论坛上的演讲中指出，当人工智能深刻影响经济和文化，必将涌现三大趋势：&lt;strong&gt;全球主义、创新加速和 AI 驱动生成&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-971603e73b5d38d489dc052d6f0f031beb7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日观察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fxueqiu.com%2F3261990793%2F303707299&quot; target=&quot;_blank&quot;&gt;大鱼吃小鱼!AI 芯片初创公司，前景不妙 &lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt; 
       &lt;div&gt; 
        &lt;p&gt;从谷歌的 TPU、苹果的 M1 和 M2、微软 Maia 100 和 Cobalt 100、Meta 的 MTIA、亚马逊的 Trainium 和 Inferentia、特斯拉的 Dojo，到英特尔的 FPGA 系列、AMD 的 MI300 系列……巨头们一次次冲击着英伟达的帝国围墙。&lt;/p&gt; 
        &lt;p&gt;而在 AI 竞速的大时代里，涌现了一大批初创 GPU、AI 芯片公司，这些从业者和科技厂商们无不在找寻突破口。全球初创企业如今正试图证明它们可以在某些应用领域提供比行业巨头英伟达更好的芯片解决方案。虽然英伟达的 GPU 继续主导人工智能（AI）领域，但 AI 初创企业认为，GPU 的高能耗和庞大的设计留下了市场空隙，供新兴企业填补，希望分享 AI 技术繁荣带来的利益。&lt;/p&gt; 
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span&gt;- &lt;strong&gt;半导体产业纵横&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1658606840%2FOvw3582XP%3Frefer_flag%3D1001030103_&quot; target=&quot;_blank&quot;&gt;RWKV.cpp 是底层 C++实现通过传统 C 接口暴露带 Python 调用入口的 loader&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;p&gt;所以 RWKV 是基于 RNN 但达到 Transformer 性能的模型架构，而这个 RWKV.cpp 是底层 C++实现通过传统 C 接口暴露带 Python 调用入口的 loader。特点就是可以在 CPU 上通过 SSE 啊 NEON 啊这些指令集跑得飞快，当然也兼容 GPU，所以低耗高效。好的好的，C++项目我喜欢，不管三七二十一先 fork 一个先&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;&lt;span&gt;wingc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2Fttarticle%2Fp%2Fshow%3Fid%3D2309405075207596671014&quot; target=&quot;_blank&quot;&gt;第一个 100% 开源的 MoE 大模型，7B 的参数，1B 的推理成本&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;p&gt;训练代码、中间 checkpoint、训练日志和训练数据都已经开源。&lt;/p&gt; 
    &lt;p&gt;尽管大语言模型 (LM) 在各种任务上取得了重大进展，但在训练和推理方面，性能和成本之间仍然需要权衡。&lt;/p&gt; 
    &lt;p&gt;对于许多学者和开发人员来说，高性能的 LM 是无法访问的，因为它们的构建和部署成本过高。改善成本 - 性能的一种方法是使用稀疏激活混合专家 (MoE)。MoE 在每一层都有几个专家，每次只激活其中的一个子集（参见图 2）。这使得 MoE 比具有相似参数量的密集模型更有效，因为密集模型为每个输入激活所有参数。&lt;/p&gt; 
    &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;&lt;span&gt;机器之心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7825731473%2FOvtOXuNy0&quot; target=&quot;_blank&quot;&gt;LakeSoul 提供了原生的 Python 接口&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt;
     LakeSoul 提供了原生的 Python 接口，可以很方便地将数据湖的数据跟模型训练进行挂钩；LakeSoul 也支持向量检索，对外会提供一个融合检索服务层，支持向量检索、sql 检索、文件检索于一体的多模态融合检索，能极致赋能大模型在行业应用的落地。
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;朱亚东-数元灵&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fk.sina.com.cn%2Farticle_6192937794_17120bb4202002b75s.html&quot; target=&quot;_blank&quot;&gt;IBM 败走中国&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt; 
       &lt;p&gt;在过去二十年间，IBM 犯了一系列战略错误，包括在云计算领域的布局起步较晚，错过利用开源生态系统构建其产品和服务的机遇；传统业务市场被云计算和现代化服务替代者抢占；备受期待的人工智能平台 Watson 商业化应用不达预期。&lt;/p&gt; 
       &lt;p&gt;2012 年开始，IBM 全年营收开始逐年下降，2013 年营收跌破千亿。到 2023 年，IBM 营收仅有 618 亿美元。&lt;/p&gt; 
       &lt;p&gt;业绩下滑原因系传统硬件业务销售下滑，云计算和软件业务逐渐成为 IBM 的核心收入来源，新兴业务虽然增长迅速，但未能完全弥补传统业务下滑的影响。&lt;/p&gt; 
       &lt;p&gt;而在中国，IBM 要面临更为复杂的境况。&lt;/p&gt; 
       &lt;p&gt;美国对中国的技术出口限制、对中国企业的制裁，导致外企在中美之间的研发合作、技术转移和跨境数据流动变得比以往更加困难。在移动互联网兴起的十年前，人们认为世界会越来越「平」，随着信息高速流通，国家之间的鸿沟将被逐渐弥合。但十年后的今天，全球化开始退潮，「地球村」的畅想已成明日黄花。&lt;/p&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;-&amp;nbsp;&lt;strong&gt;界面新闻&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8cd4fMakARr&quot; target=&quot;_blank&quot;&gt;智谱 AI，又融资了&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;p&gt;今日，伴随中关村科学城公司通过公众号宣布以投前 200 亿元估值，领投智谱新一轮融资，方才尘埃落定。&lt;/p&gt; 
  &lt;p&gt;对于投后估值以及更多融资信息，智谱官方未给予置评。而这也是智谱，连续两年，年内被曝完成 3 轮融资。去年至今，该公司已完成 6 轮融资。&lt;/p&gt; 
  &lt;p&gt;值得一提的是，智谱先后获得阿里、腾讯、美团、小米等诸多互联网大厂押注，以及红杉、高瓴、君联、顺为等知名机构的投资，在 AI 大模型公司中，可谓一枝独秀。&lt;/p&gt; 
  &lt;p&gt;成立至今，智谱一直是市场上炙手可热的存在。早在 2019 年 8 月，成立仅 2 个月，华控基金、中科创星等就已火速入股。2021-2021 年，该公司则先后在 9 月份获得 A、B 轮融资。&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;猎云网&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.prnasia.com%2Fstory%2F459676-1.shtml&quot; target=&quot;_blank&quot;&gt;阿里云、字节、浪潮信息、英特尔、电标院：OpenBMC 成服务器固件发展的「事实标准」&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;传统 BMC 虽然可以实现部分管理，但是在快速迭代的当今尤其是在 AI 技术的驱动下，存在开发周期长、交付困难、应用单一等难题，并且由于其代码闭源也会导致隐藏的安全漏洞无法及时识别，限制了用户定制开发。OpenBMC 凭借领先的开源理念、可扩展的软件架构，被大型互联网厂商广泛应用，并带动了产业连上下游共同探索，逐步成为服务器固件发展的&quot;事实标准&quot;。&lt;/p&gt; 
 &lt;p&gt;在日前召开的 2024 开放计算中国峰会上，来自阿里云、字节跳动、浪潮信息、英特尔以及电子标准院的专家，从自身探索和实践的角度，现身说法各家在 OpenBMC 方面的最新进展及未来规划。&lt;/p&gt; 
 &lt;div&gt; 
  &lt;div style=&quot;text-align:right&quot;&gt;
   &lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt; 
   &lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;美通社&lt;/span&gt;&lt;/strong&gt;
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcj.sina.com.cn%2Farticles%2Fview%2F2853016445%2Faa0d937d02000ztnm&quot; target=&quot;_blank&quot;&gt;通信效率超 98%！壁仞科技实现中国首个三种异构芯片混训技术&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;为了解决用户需求和技术挑战，壁仞科技团队攻坚异构 GPU 训练难点，自主研发出原创异构 GPU 协同训练方案 HGCT，通过异构调度、异构通信、异构拆分三层架构，实现了一套统一方案支持多种不同型号、不同厂商的 GPU，业界首次支持 3 种及以上异构 GPU 混合训练同一个大模型。&lt;/p&gt; 
 &lt;p&gt;壁仞科技表示，这一异构 GPU 协同训练方案对于行业端有两个意义：1、该方案最终价值实现了国产 GPU 和英伟达 GPU 的异构共存，突破异构算力孤岛难题，加快国产 GPU 的落地迁移，助力国产大模型落地；2、该方案赋能整个算力产业发展，壁仞 HGCT 方案具备普适性、易用性、兼容性，助力最终客户实现多种异构算力聚合，最大化异构 GPU 集群利用效率。&lt;/p&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt; &lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;钛媒体&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F19LhsTqTbrK4mlnnBB6JHA&quot; target=&quot;_blank&quot;&gt;「稚晖君」 停更这一年：想赢下人形机器人，要像运营大公司那样去创业&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p&gt;「在学校里学习更多是自底向上，先打好基础然后做上层应用，出了校园之后更多是自顶向下，以项目导向，缺啥学啥。」 彭志辉说。聊到时间管理方法，他说是 「操作系统中的抢占式调度」，动态调整任务优先级，允许打断，但是任何时间都专注于当前的任务。&lt;/p&gt; 
   &lt;p&gt;他不喜欢 「天才少年」 的称呼，他觉得教科书中那些能改变人类发展进程的科学家才是天才。&lt;/p&gt; 
   &lt;p&gt;相比过去用几个月就能独自完成的小型项目，参与创办一家公司开发成功的产品要难得多。他要从单兵作战走向带团队协作，做出来的东西不能只是酷，还要能赚钱。这是一场新的、更复杂的学习。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;晚点 LatePost&lt;/strong&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://my.oschina.net/u/5783135/blog/15671421&quot; target=&quot;news&quot;&gt;深入理解 Babel - 微内核架构与 ECMAScript 标准化&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p&gt;随着浏览器版本的持续更新，浏览器对 JavaScript 的支持越来越强大，Babel 的重要性显得较低了。但 Babel 的设计思路、背后依赖的 ECMAScript 标准化思想仍然值得借鉴。&lt;/p&gt; 
   &lt;p&gt;本文涉及的 Babel 版本主要是 V7.16 及以下，截至发文时，Babel 最新发布的版本是 V7.25.6，未出现大版本更新，近 2 年也进入了稳定迭代期，本文的分析思路基本适用目前的 Babel 设计。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;hr&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;开源之声&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F98boIfNzaXHKZpvBC8Wt_g&quot; target=&quot;_blank&quot;&gt;Vue 3.5「天元突破红莲螺岩」正式发布&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：还在用 vue2.x， 也挺好&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：上月入职一公司。我之前学了 vue3，但公司项目是 vue2，写的我真难受，很不习惯&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FtL1KN4cMEUcGcMzwDy1KcA&quot; target=&quot;_blank&quot;&gt;阿里通义千问 (QwenLM) 全系列大模型被 GitHub 下架，访问 repo 显示「404」&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：已经快 5 年不用 github 了，中心化的东西一蹦全瘫痪了&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：应该是美国当局怀疑大模型背后有暗门，当心他们本国用户下载使用后被标记定位或外传数据，他们自己的大模型可是严格管控的。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：吓得我立刻备份 github 所有私有库&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;最后，欢迎扫码下载「开源中国 APP」，阅读海量技术报告、程序员极客分享！&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d27cc3636c021c266537f4729dc0f84fdc3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310600</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310600</guid>
            <pubDate>Thu, 05 Sep 2024 11:53:54 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>著名未来学家凯文·凯利（KK）预测人工智能三大趋势</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;2024 Inclusion·外滩大会今天在上海黄浦世博园区开幕。&lt;/p&gt; 
&lt;p&gt;著名未来学家、《连线》杂志创始主编、《5000 天后的世界》作者凯文·凯利（Kevin Kelly，「KK」）在开幕主论坛上的演讲中指出，当人工智能深刻影响经济和文化，必将涌现三大趋势：&lt;strong&gt;全球主义、创新加速和 AI 驱动生成&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-971603e73b5d38d489dc052d6f0f031beb7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;全球主义&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;全球正在共同构建一个基于技术的「超级有机体」，将全球的设备连接成巨大的计算系统，所有数字技术包括人工智能都运行在这个新平台上。&lt;/li&gt; 
 &lt;li&gt;全球主义推进推动了新兴的全球文化，人们的生活方式和穿着逐渐趋同，底层需求达成一致。&lt;/li&gt; 
 &lt;li&gt;人工智能将实现真正的「实时翻译」，打破全球语言障碍，加上增强现实（VR）技术，全球化「劳动力」将第一次出现。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;创新加速&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;AI 技术加速了创新的步伐，体现在新发明和新思想传播速度加快，通过增强现实（AR）和虚拟现实（VR）技术提高学习效率，AI 通过机器及其他传感器感知世界，以及 ChatGPT 等人工智能工具加快人们学习速度。&lt;/li&gt; 
 &lt;li&gt;当答案易得时，提出正确问题和掌握正确思维方式变得更有价值，「学会如何学习」将成为未来毕业生的核心技能。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;AI 驱动生成&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;人工智能能帮助人们摆脱机械、枯燥的工作，完成无法独立完成的任务，甚至生成超乎人类想象的全新事物。&lt;/li&gt; 
 &lt;li&gt;人工智能系统正在生成新事物且不断完善，人工智能是多样的，将填补许多智能领域。&lt;/li&gt; 
 &lt;li&gt;从人工智能工具中获益最多的是表现一般或较差的员工，人工智能工具能帮助他们更好地完成工作。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;回答中国网友提问：人类正在通过人工智能重塑文明&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 2024 外滩大会开幕之前，凯文·凯利通过外滩大会官方微信，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FpIyyX-CR3HQs51Ot90H1TQ&quot; target=&quot;_blank&quot;&gt;向中国读者征集了关于 AI 的问题&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;5 日，外滩大会官方公布了凯文·凯利的回答。&lt;/p&gt; 
&lt;p&gt;对于&lt;strong&gt;人工智能是不是人类的下一个进化阶段&lt;/strong&gt;，凯文·凯利给出了肯定的答案，他认为，人工智能的重要性不亚于火、印刷术和工业革命，这将是广泛而巨大的变革。但至少需要一个世纪的时间来实现，甚至可能更长，不可能一蹴而就。&lt;/p&gt; 
&lt;p&gt;「人类正在通过人工智能重塑文明。」凯文·凯利说，也许一百万年来，我们一直是这个星球上唯一的智慧物种。但如今，我们正在创造人造「外星人」，就像他们来自遥远的星球，前来拜访我们一样。这些「外星人」的思想将被引入我们的世界，从而创造出一种新的文化。&lt;/p&gt; 
&lt;p&gt;对于&lt;strong&gt;如何确保人工智能带来的未来是有益的，而不是加剧不平等&lt;/strong&gt;，凯文·凯利表示，我们有理由对任何新技术保持谨慎，人工智能也不例外。「我认为，未来最大的问题之一可能会源自人工智能。但我们今天所担心的许多问题，或许并不是最难解决的，那些问题是可以应对的。真正的挑战可能是我们还未曾想象到的未知问题。」&lt;/p&gt; 
&lt;p&gt;他认为，首先要利用技术去引导它的发展，要实现我们期望的由人工智能驱动的未来，最好的途径之一就是积极参与其中，而不是试图禁止它或将其排斥在外。其次，应尽可能推动人工智能技术的开源化。开源模式赋予更多人参与的机会，形成一种更具包容性的技术生态系统。&lt;/p&gt; 
&lt;p&gt;在回答&lt;strong&gt;「未来哪些工作不会被人工智能取代」&lt;/strong&gt;时，凯文·凯利表示，正如当今就像几乎没有工作是不需要使用某种能源一样，未来几乎所有的工作都会使用某种程度的人工智能，但这并不意味着它们会被人工智能完全取代。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310590</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310590</guid>
            <pubDate>Thu, 05 Sep 2024 10:43:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>深入理解 Babel - 微内核架构与 ECMAScript 标准化｜得物技术</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;&lt;em&gt;随着浏览器版本的持续更新，浏览器对 JavaScript 的支持越来越强大，Babel 的重要性显得较低了。但 Babel 的设计思路、背后依赖的 ECMAScript 标准化思想仍然值得借鉴。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;本文涉及的 Babel 版本主要是 V7.16 及以下，截至发文时，Babel 最新发布的版本是 V7.25.6，未出现大版本更新，近 2 年也进入了稳定迭代期，本文的分析思路基本适用目前的 Babel 设计。&lt;/em&gt;&lt;/p&gt; 
&lt;h1&gt;一、Babel 简介&lt;/h1&gt; 
&lt;h2&gt;Babel 是什么&lt;/h2&gt; 
&lt;p&gt;Babel 是 JavaScript 转译器，通过 Babel，开发者可以自由使用下一代 ECMAScript 语法。高版本 ECMAScript 语法将被转译为低版本语法，以便顺利运行在各类环境，如低版本浏览器、低版本 Node.js 等。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Babel 是转译器，不是编译器。下面是转译和编译的区别:&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;编译，一般指将一种语言转换为另一种语法和抽象程度等都不同的语言，常见的比如 gcc 编译器。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;转译，一般指将一种语言转换为不同版本或者抽象程度相同的语言，比如 Babel 可以把 ECMAScript 6 语法转译为 ECMAScript 5 语法。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;利用 Babel，开发者可以使用 ECMAScript 的各种新特性进行开发，同时花极少的精力关注浏览器或其他 JS 运行环境对新特性的支持。甚至，开发者可以根据自身需要，创造属于自己的 JavaScript 语法。&lt;/p&gt; 
&lt;p&gt;Babel 在转译的时候，会对源码进行以下处理: 语法转译 (Syntax) 和添加 API Polyfill。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/01_1725449415228.jpg&quot; alt=&quot;01.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;语法 (Syntax) 部分 Babel 支持识别高版本语法，并通过插件将源码从高版本语法转译为低版本语法，如:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;箭头函数 () =&amp;gt; {} 转为普通函数 function() {}。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;const / let 转译为 var&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;API Polyfill&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;有些运行时相关的 API，语法转译无法解决它们对低版本浏览器等环境的兼容性问题，因此 Babel 通过与 core-js 等工具的配合，实现 API 部分对目标环境 (通常是低版本浏览器等) 的兼容。&lt;/p&gt; 
&lt;p&gt;例如[1, 2, 3].include、Promise 等 API，Babel 在处理时，如果目标环节可能不支持原生的 include / Promise 的话，Babel 会在转译结果中嵌入 include / Promise 的自定义实现。&lt;/p&gt; 
&lt;p&gt;有多种方式可以使用 Babel，如: 命令行 (babel-cli、babel-node)、浏览器 (babel-standalone)、API 调用 (babel-core)、webpack loader(babel-loader) 等。&lt;/p&gt; 
&lt;h2&gt;转译过程&lt;/h2&gt; 
&lt;p&gt;和多数转译器相同，Babel 运行的生命周期主要是 3 个阶段: 解析、转换、代码生成。&lt;/p&gt; 
&lt;p&gt;这个过程涉及抽象语法树:&lt;/p&gt; 
&lt;p&gt;抽象语法树 (Abstract Syntax Tree，AST)，或简称语法树 (Syntax tree)，是源代码语法结构的一种抽象表示。&lt;/p&gt; 
&lt;p&gt;AST 是树形对象，以结构化的形式表示编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/02_1725514960565.jpg&quot; alt=&quot;02.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;源码字符串需要经转译器生成 AST，转译器有很多种，不同转译器，生成的 AST 对象格式细节可能有差异，但共同点为: 都是树形对象、该树形对象描述了节点特征、各节点之间的关系（兄弟、父子等）。&lt;/p&gt; 
&lt;p&gt;以下是 Babel 生命周期的三个过程:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;解析 (Parsing): Code1 ==&amp;gt; 抽象语法树 1 解析过程包括 2 个环节: 词法解析、语法解析，最终生成抽象语法树。 词法解析阶段，代码字符串被解析为 token 令牌数组，数组项是一个对象，包括: 代码字符碎片的值、位置、类型等信息。 token 数组是平铺式的数组，没有嵌套的结构信息，它是为语法解析阶段做准备的。 语法解析阶段，token 令牌数组被解析为结构化的抽放语法树对象 (AST)。 babel-parser 完成该阶段的主要功能。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/03_1725515016480.jpg&quot; alt=&quot;03.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;转换 (Transformation): AST1 ==&amp;gt; AST2 Babel 生成 AST 后，会对 AST 进行遍历，遍历过程中，各类插件对原 AST 对象进行增删改查等操作，AST 结构被修改。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/04_1725515063201.jpg&quot; alt=&quot;04.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;代码生成 (Generation): AST2 ==&amp;gt; Code2 Babel 将修改后的 AST 对象转目标代码字符串。 babel-generator 完成该阶段的主要功能。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/05_1725515093407.jpg&quot; alt=&quot;05.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h1&gt;二、Babel 微内核架构&lt;/h1&gt; 
&lt;h2&gt;微内核架构&lt;/h2&gt; 
&lt;p&gt;Babel 采用微内核架构，其内核保留核心功能，其余功能利用外部工具和插件机制实现，也体现了&quot;开放-封闭&quot;的设计原则。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/06_1725515126255.jpg&quot; alt=&quot;06.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;除了微内核设计架构，Babel 的模块设计也可以做如下分类:&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/07_1725515157896.jpg&quot; alt=&quot;07.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;转译模块&lt;/h2&gt; 
&lt;p&gt;转译模块位于 Babel 微内核架构的&quot;微内核&quot;部分，该部分主要负责代码转译，也就是上面提到的&quot;解析-转换-代码生成&quot;过程。&lt;/p&gt; 
&lt;p&gt;该模块主要包括: babel-parser、babel-traverse、babel-generator。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;babel-parser 负责将代码字符串转为 AST 对象。 有 2 点值得一提:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;babel-parser 本身并不会对 AST 做转换操作，只是负责解析出 AST。AST 转换部分交由各类 plugins 和 presets 处理。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;babel-parser 内置了对 ESNext/TypeScript/JSX/Flow 最新版本语法的支持，但很多默认是不开启的，目前没有开放插件机制扩展新语法。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-traverse 在转译过程中，babel-traverse 负责遍历 AST 节点，并根据配置的 plugins/presets，在遍历过程中，对各个 AST 节点进行增删改查的操作。 AST 是一个树形对象，遍历 AST 对象的过程也是一个深度优先遍历的过程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-generator 负责将 AST 节点，转为代码字符串，同时也可以生成 source-map。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;插件模块&lt;/h2&gt; 
&lt;p&gt;插件模块包括 plugins、presets。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;plugins 丰富的插件，帮助 Babel 成为一个非常成功的转译工具。 对 AST 的遍历、转换是 Babel 转译的核心功能，但 Babel 本身并不参与该过程，将这些功能作为插件引入到运行时。 具体来说，babel-core 作为核心工具，不提供对 AST 的修改逻辑，通过调用各类插件，实现对 AST 的修改。 Babel 的插件分为语法插件和转换插件。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;语法插件，值得注意的是，babel-parser 负责将 JavaScript 代码解析出抽象语法树 (AST)，它支持全面识别 ESNext/TypeScript/JSX/Flow 等语法，目前由 Babel 团队开发维护，不支持插件化。 Babel 插件生态中的语法插件，其功能就是作为&quot;开关&quot;，配置是否开启 babel-parser 的某些语法转译功能。 语法插件在 Babel 源码中，以 babel-plugin-syntax 开头。 举个例子:&lt;/p&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;babel-plugin-syntax-decorators 负责开启 babel-parser 对装饰器的语法支持。&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;babel-plugin-syntax-dynamic-import 负责开启 babel-parser 对 import 语句的语法支持。&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;babel-plugin-syntax-jsx 负责开启 babel-parser 对 jsx 语法的支持。&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;转换插件，转换插件就是社区里常说的 Babel 插件，负责转换 AST 节点。 在介绍 babel-traverse 时提到，它负责遍历 AST 对象，每个 AST 节点会被访问到，等待转换，转换的部分，由&quot;转换插件&quot;负责。 转换插件会提供一个叫做&quot;Visitor&quot;的对象，该对象的 Key 为节点名称，Value 部分提供进入该节点时、离开该节点时的回调函数，在回调函数里，可以对该节点进行一系列操作。 &quot;Visitor&quot; 又称为 &quot;访问者&quot;。&lt;/p&gt; &lt;p&gt;// plugin 提供 visitor，在 visitor 中对 AST 节点操作 const visitor = { Program: { enter() {}, exit() {}, },&lt;/p&gt; &lt;pre&gt;&lt;code&gt;CallExpression: {
    enter() {},
    exit() {},
},

NumberLiteral: {
    enter() {},
    exit() {},
}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;}; traverse(ast, visitor);&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;转换插件在 Babel 源码中，以 babel-plugin-transform 开头。&lt;/p&gt; 
&lt;p&gt;举个例子:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-plugin-transform-strict-mode&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;该插件拦截 Program 节点，也就是整个程序的根节点，添加 &quot;use strict&quot;指令。&lt;/p&gt; 
&lt;p&gt;visitor 节点值为函数时，是 enter 回调的快捷方式。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    name: &quot;transform-strict-mode&quot;,

    visitor: {
      Program(path) {
        const { node } = path;

        for (const directive of node.directives) {
          if (directive.value.value === &quot;use strict&quot;) return;
        }

        path.unshiftContainer(
          &quot;directives&quot;,
          t.directive(t.directiveLiteral(&quot;use strict&quot;)),
        );
      },
    },
  };
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-plugin-transform-object-assign&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;该插件负责拦截函数调用表达式节点 CallExpression，将 Object.assign 转为 extends 写法。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    name: &quot;transform-object-assign&quot;,

    visitor: {
      CallExpression(path, file) {
        if (path.get(&quot;callee&quot;).matchesPattern(&quot;Object.assign&quot;)) {
          path.node.callee = file.addHelper(&quot;extends&quot;);
        }
      },
    },
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;Presets&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Babel 插件的功能是细粒度的，大部分插件承担了单一功能。&lt;/p&gt; 
&lt;p&gt;而在实际开发过程中，往往需要支持对各类语法的支持。此时，有两种做法:&lt;/p&gt; 
&lt;p&gt;A. 需要支持哪些特性，就分别引入支持该特性的插件&lt;/p&gt; 
&lt;p&gt;B. 直接引入一个插件集合，涵盖所需的各类插件功能&lt;/p&gt; 
&lt;p&gt;很显然，第一种做法是相对麻烦的。针对第二种做法，Babel 提供了插件集 preset。&lt;/p&gt; 
&lt;p&gt;preset 在 Babel 源码中，以 babel-preset 开头。&lt;/p&gt; 
&lt;p&gt;例如，Babel 已经提供了几种常用的 preset 供开发者使用:&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;babel-preset-env&lt;/li&gt; 
 &lt;li&gt;babel-preset-react&lt;/li&gt; 
 &lt;li&gt;babel-preset-flow&lt;/li&gt; 
 &lt;li&gt;babel-preset-typescript&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;插件运行顺序&lt;/strong&gt; Babel 配置项中，plugins 和 presets 均以数组的形式配置，执行时有先后顺序。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;plugins 在 presets 之前运行&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;plugins 按照数组正序执行&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;presets 按照数组倒序执行&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/08_1725519262475.jpg&quot; alt=&quot;08.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;工具模块&lt;/h2&gt; 
&lt;p&gt;工具模块提供 Babel 相关模块所需的各类工具，以下一一简要介绍:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;babel-core babel-core 对外提供了 Babel 多项功能的 API，如转译文件、转译代码、创建/获取配置等，在 Babel 官方文档介绍的比较详细，不再赘述。 值得注意的是，转译类的 API 均提供了同步和异步版本，如 transformSync/transfomAsync、parseSync/parseAsync。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-cli Babel 的命令行工具，可以直接转译文件夹/文件，它也提供了很多配置项做其他工作，官方文档介绍的比较详细，感兴趣的同学可以去 Babel 官网查看详细配置。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-standalone Babel 对外服务的很多包是基于 node 环境下使用的，babel-standalone 提供了浏览器下转译的方案。 babel-standalone 内置了所有 Babel 插件，所以体积还是比较大的，而且在浏览器端转译需要时间，比较适合开发、学习使用，不适合在生产环境使用。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;举个例子:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;test babel-standalone&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/babel&quot;&amp;gt;
      const arr = [1, 2, 3];
      console.log(...arr);
&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在浏览器运行该 html，可以看到，页面结构变成了:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;test babel-standalone&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/babel&quot;&amp;gt;
      const arr = [1, 2, 3];
      console.log(...arr);
&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      &quot;use strict&quot;;
      var _console;
      var arr = [1, 2, 3];
      (_console = console).log.apply(_console, arr); //# sourceMappingURL=data:application/json;charset=utf-8;base64...
&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-node 提供在命令行执行高级语法的环境。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;例如:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// index.js 里可以使用高级语法     
babel-node -e index.js
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;index.js 文件以及被其引入的其他文件均可以使用高级语法了。和 babel-cli 不同的是，babel-cli 只负责转换，不在 node 运行时执行；babel-node 会在 node 运行时执行转换，不适合生产环境使用。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-register&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在源文件中，引入 babel-register，如 index.js:&lt;/p&gt; 
&lt;p&gt;index.js&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;require(&#39;babel-register&#39;);     
require(&#39;./run&#39;);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;run.js&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import fs from &#39;fs&#39;;     
console.log(fs);
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;执行 node index 时，run.js 就不需要被转码了。&lt;/p&gt; 
&lt;p&gt;babel-register 通过拦截 node require 方法，为 node 运行时引入了 Babel 的转译能力。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-loader&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;babel-loader 是利用 babel-core 的 API 封装的 webpack loader，用于 webpack 构建过程。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-types&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;babel-types 是一个非常强大的工具集合，它集成了节点校验、增删改查等功能，是 Babel 核心模块开发、插件开发等场景下不可或缺的工具。&lt;/p&gt; 
&lt;p&gt;例如:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;const t = require(&#39;@babel/types&#39;);
const binaryExpression = t.binaryExpression(&#39;+&#39;, t.numericLiteral(1), t.numericLiteral(2));
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-template&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;模板引擎，负责将代码字符串转为 AST 节点对象。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    import { smart as template } from &#39;@babel/template&#39;;
    import generate from &#39;@babel/generator&#39;;
    import * as t from &#39;@babel/types&#39;;

    const buildRequire = template(      var %%importName%% = require(%%source%%);    );

    const ast = buildRequire({
        importName: t.identifier(&#39;myModule&#39;),
        source: t.stringLiteral(&quot;my-module&quot;),
    });

    const code = generate(ast).code

    console.log(code)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;运行结果:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;var myModule = require(&quot;my-module&quot;);
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-code-frame&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;负责打印出错的代码位置，例如:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;const { codeFrameColumns } = require(&#39;@babel/code-frame&#39;);

const testCode = `
class Run {
    constructor() {}
}
`;

const location = {
    start: {
        line: 2,
        column: 2,
    }
};

const result = codeFrameColumns(testCode, location);

console.log(result);

  1 | class Run {
&amp;gt; 2 |     constructor() {}
    |  ^
  3 | }
  4 |
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;babel-highlight&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;向控制枱输出有颜色的代码片段。该工具可以识别 JavaScript 中的操作符号、标识符、保留字等类型的词法单元，并在终端环境下显示不同的颜色。&lt;/p&gt; 
&lt;h2&gt;运行时相关模块&lt;/h2&gt; 
&lt;p&gt;Babel 配合其插件可以对静态代码进行转译，但有一些遗漏点:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;对于运行时涉及的一些高版本 API，并没有提供兼容目标环境的 Polyfill。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;转译产物代码可能有些臃肿。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;为此，运行时模块 (runtime) 关注的是转译产物的运行时环境，对运行时提供 API polyfill、代码优化等，该模块涉及几个子包:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;babel-preset-env&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-plugin-transform-runtime&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-runtime&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-runtime-corejs2/3&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;core-js&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;接下来以案例解释 runtime 模块的作用。&lt;/p&gt; 
&lt;p&gt;源码文件 index.js 的内容:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;const a = 1; // const 为语法部分
class Base {} // class 为语法部分
new Promise() // Promise 为 API 部分
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这段源码包含了语法和 API 部分:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;const、class 为语法部分&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Promise 为 API 部分&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;如果希望这段源码转为 ES5 版本，使构建产物可以运行在不支持 ES6 和 Promise 的环境里，该怎么做呢？&lt;/p&gt; 
&lt;p&gt;用 babel 命令行执行转译，其中源文件为 index.js，转译产物文件为 index-compiled.js。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;npx babel index.js --out-file index-compiled.js
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;需要配置.babelrc 帮助 Babel 完成语法和 API 部分的转译:&lt;/p&gt; 
&lt;p&gt;.babelrc:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
    &quot;presets&quot;: [
        [ 
            &quot;@babel/preset-env&quot;
        ]
    ],
    &quot;plugins&quot;: [
        [
            &quot;@babel/plugin-transform-runtime&quot;,
            {
                &quot;corejs&quot;: 3
            }
        ]
    ]
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;简要解释下该配置的原理:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;babel-preset-env 可以完成语法部分转译，即 const 转译为 var 但构建产物中，有些辅助代码如 _classCallCheck 是以硬编码的形式直接写入转译产物的:&lt;/p&gt; &lt;p&gt;&quot;use strict&quot;;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&quot;Cannot call a class as a function&quot;); } }

  var a = 1;

  var Base = function Base() {
      _classCallCheck(this, Base);
  };

  new Promise();
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;这样的后果就是构建产物比较臃肿。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;babel-plugin-transform-runtime 可以将上述 _classCallCheck 置于通用包中，以引用的形式写入转译产物:&lt;/p&gt; &lt;p&gt;&quot;use strict&quot;;&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  var _interopRequireDefault = require(&quot;@babel/runtime/helpers/interopRequireDefault&quot;);

  var _classCallCheck2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/classCallCheck&quot;));

  var a = 1;

  var Base = function Base() {
      (0, _classCallCheck2[&quot;default&quot;])(this, Base);
  };

  new Promise();
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;babel-plugin-transform-runtime 的配置参数 corejs 用于转译 API 部分，如 Promsie&lt;/p&gt; &lt;pre&gt;&lt;code&gt;  &quot;use strict&quot;;

  var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);

  var _promise = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/promise&quot;));

  var _classCallCheck2 = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/helpers/classCallCheck&quot;));

  var a = 1;

  var Base = function Base() {
      (0, _classCallCheck2[&quot;default&quot;])(this, Base);
  };

  new _promise&quot;default&quot;;
&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Babel 转译过程的运行时优化是一个繁琐的过程，为此将单独用一章讲解运行时优化，感兴趣的同学可以直接阅读 &quot;Babel Runtime&quot; 章节详细了解。&lt;/p&gt; 
&lt;h1&gt;三、标准化&lt;/h1&gt; 
&lt;p&gt;Babel 生态涉及的一些标准化组织。无论是 JavaScript、HTML、DOM、URL 等领域，均需要统一的标准，才能在不同的运行环境下有统一的表现。Babel 转译也需要遵循这些标准，包括 ECMAScript、web 标准等。&lt;/p&gt; 
&lt;h2&gt;ECMAScript&lt;/h2&gt; 
&lt;h3&gt;JavaScript 诞生&lt;/h3&gt; 
&lt;p&gt;1995 年，JavaScript 的第一个版本发布。用时间线的方式描述 JavaScript 的诞生过程会更清晰:&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/09_1725519904874.jpg&quot; alt=&quot;09.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;ECMAScript 发布&lt;/h3&gt; 
&lt;p&gt;1996 年，微软模仿 JavaScript 实现了 JScript 并内置在 IE3.0，随后，Netscape 公司着手推动 JavaScript 标准化。&lt;/p&gt; 
&lt;p&gt;这里涉及几个组织:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Ecma International Ecma International 是一家国际性会员制度的信息和电信标准组织。1994 年之前，名为欧洲计算机制造商协会（European Computer Manufacturers Association）。因为计算机的国际化，组织的标准牵涉到很多其他国家，因此组织决定改名表明其国际性。 Ecma International 的任务包括与有关组织合作开发通信技术和消费电子标准、鼓励准确的标准落实、和标准文件与相关技术报告的出版。 Ecma International 负责多个国际标准的制定:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;CD-ROM 格式（之后被国际标准化组织批准为 ISO 9660）&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;C# 语言规范&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;C++/CLI 语言规范&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;通用语言架构（CLI）&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;Eiffel 语言&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;电子产品环境化设计要素&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;Universal 3D 标准&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;OOXML&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;Dart 语言规范&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;ECMAScript 语言规范（以 JavaScript 为基础）ECMA-262 其中就包括 JavaScript 标准语言规范 ECMAScript。 cma International 拥有 ECMAScript 的商标。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;ECMA TC39 「TC39」全称「Technical Committee 39」译为「第 39 号技术委员会」，是 Ecma International 组织架构中的一部分。 TC39 负责迭代和发展 ECMAScript，它的成员由各个主流浏览器厂商的代表组成，通常每年召开约 6 次会议来讨论未决提案的进展情况，会议的每一项决议必须得到大部分人的赞同，并且没有人强烈反对才可以通过。 TC39 负责:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;维护和更新 ECMAScript 语言标准&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;识别、开发、维护 ECMAScript 的扩展功能库&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;开发测试套件&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;为 ISO/IEC JTC 1 提供标准&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;评估和考虑新添加的标准&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;ISO&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;国际标准化组织（英语: International Organization for Standardization，简称: ISO）成立于 1947 年 2 月 23 日，制定全世界工商业国际标准的国际标准建立机构。&lt;/p&gt; 
&lt;p&gt;ISO 的国际标准以数字表示，例如: &quot;ISO 11180:1993&quot; 的 &quot;11180&quot; 是标准号码，而 &quot;1993&quot; 是出版年份。&lt;/p&gt; 
&lt;p&gt;ISO/IEC JTC 1 是国际标准化组织和国际电工委员会联合技术委员会。其目的是开发、维护和促进信息技术以及信息和通信技术领域的标准。JTC 1 负责了许多关键的 IT 标准，从 MPEG 视频格式到 C++ 编程语言。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/10_1725520572128.jpg&quot; alt=&quot;10.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMAScript 发展过程中的关键节点&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/11_1725520594519.jpg&quot; alt=&quot;11.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;ECMAScript 各版本&lt;/h3&gt; 
&lt;p&gt;ECMAScript 经历了多个版本，每个版本有自己的特点，简单列举如下:&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/12_1725520728091.jpg&quot; alt=&quot;12.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/13_1725520738100.jpg&quot; alt=&quot;13.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;ECMAScript 迭代过程&lt;/h3&gt; 
&lt;p&gt;一个 ECMAScript 标准的制作过程，包含了 Stage 0 到 Stage 4 共 5 个阶段，每个阶段提交至下一阶段都需要 TC39 审批通过。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/14_1725520848631.jpg&quot; alt=&quot;14.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/15_1725520864402.jpg&quot; alt=&quot;15.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;特性进入 Stage-4 后，才有可能被加入标准中，还需要 ECMA General Assembly 表决通过才能进入下一次的 ECMAScript 标准中。&lt;/p&gt; 
&lt;h2&gt;如何阅读 ECMAScript&lt;/h2&gt; 
&lt;h3&gt;ECMAScript 文档结构&lt;/h3&gt; 
&lt;p&gt;ECMAScript 的规格，可以在 ECMA 国际标准组织的官方网站免费下载和在线阅读。&lt;/p&gt; 
&lt;p&gt;查看 ECMAScript 不同版本的地址：&lt;em&gt;++&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fecma-international.org%2Fpublications-and-standards%2Fstandards%2Fecma-262%2F%2B%2B&quot; target=&quot;_blank&quot;&gt;https://ecma-international.org/publications-and-standards/standards/ecma-262/++&lt;/a&gt;&lt;/em&gt;。&lt;/p&gt; 
&lt;p&gt;截至 2023 年底，已发布的版本如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262 5.1 edition, June 2011&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F5.1%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/5.1/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 6th edition, June 2015&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F6.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/6.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 7th edition, June 2016&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F7.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/7.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 8th edition, June 2017&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F8.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/8.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 9th edition, June 2018&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F9.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/9.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 10th edition, June 2019&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F10.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/10.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 11th edition, June 2020&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F11.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/11.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 12th edition, June 2021&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F12.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/12.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 13th edition, June 2022&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F13.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/13.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ECMA-262, 14th edition, June 2023&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F14.0%2Findex.html%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/14.0/index.html）&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;每个版本有独立的网址，格式为: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F%7Bversion%7D%2F%EF%BC%8C%E6%AF%94%E5%A6%82&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/{version}/，比如&lt;/a&gt; ECMAScript 14.0 版本的网址为 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F262.ecma-international.org%2F14.0%2F%E3%80%82&quot; target=&quot;_blank&quot;&gt;https://262.ecma-international.org/14.0/。&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;从章节数量上，ECMAScript 6.0、ECMAScript 7.0 有 26 章，之后的版本有 27-29 章，虽然章节数量不同，规格章节的分布是保持一定规律的，以 ECMAScript 11.0 版本为例:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Introduction: 介绍部分&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;该章节简要描述了: JavaScript 和 ECMAScript 的发展历史、不同 ECMAScript 规格的主要更新内容。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;第 1 章到第 3 章: 描述了规格文件本身，而非语言&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;第 1 章用一句话描述了该规格的描述范围。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;第 2 章描述了基于规格的&quot;实现&quot;的一致性要求:&lt;/p&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;&quot;实现&quot;必须支持规格中描述的所有类型、值、对象、属性、函数以及程序的语法和语义&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&quot;实现&quot;必须按照 Unicode 标准和 ISO/IEC 10646 的最新版本处理文本输入&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&quot;实现&quot;如果提供了应用程序编程接口（API），那么该 API 需要适应不同的人文语言和国家差异，且必须实现最新版本的 ECMA-402 所定义的与本规范相兼容的接口&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&quot;实现&quot;可以支持该规格中没有提及的类型、值、对象、属性、函数、正则表达式语法以及其他编程写法&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;&quot;实现&quot;不能实现该规格中禁止的写法&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 3 章描述了该规格的一些参考资料:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;ISO/IEC 10646&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;ECMA-402&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;EMCA-404 JSON 数据交换格式规范&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 4 章: 对这门语言总体设计的描述。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 5 章到第 8 章: 语言宏观层面的描述。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 6 章介绍数据类型。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 7 章介绍语言内部用到的抽象操作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 8 章介绍代码如何运行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第 9 章到第 27 章: 介绍具体的语法。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;一般而言，除非写编译器，开发者无需阅读 ECMAScript 的规格，规格的内容非常多，如无必要也无需通读。只是在遇到一些奇怪的问题时，阅读官方规格，是最稳妥的办法。&lt;/p&gt; 
&lt;h3&gt;通过阅读规格解决一些问题（以 ECMAScript 11.0 为例）&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;识别关键词和保留字，并高亮 Babel 工具集中的 babel-highlight，可以实现在终端对代码块中的目标字符单元显示不同的颜色。这里需要识别不同字符单元的类型，如关键字、保留字、标识符、数字、字符串等。 标识符、数字、字符串都很好理解和识别，但哪些字符应该被识别为关键字、保留字，而不是标识符呢？ 此时可以阅读 ECMAScript 规格了，ECMAScript 11.0 规格的 11.6.2 节介绍了关键词和保留字列表。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;关键词（keywords） 关键词首先是标识符，同时有语义，包括 if、while、async、await...，个别关键词是可以用作变量名的。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;保留字（reserved word） 保留字首先是标识符，但不能用作变量名。 部分关键词是保留字，但部分不是: if、while 是保留字；await 只有在 async 方法和模块中才是保留字；async 不是保留字，它可以作为普通的变量名使用。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;保留字列表&lt;/p&gt; &lt;p&gt;await break case catch class const continue debugger default delete do else enum export extends false finally for function if import in instanceof new null returns uper switch this throw true try typeof var void while with yield&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;读完上述规格，也就知道哪些字符单元是需要识别为保留字与关键词，并高亮的了。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;识别全局对象，并高亮，继续使用 babel-highlight 实现代码块中的全局对象高亮，那么，我们需要知道哪些是规格中描述的全局变量。 规格的 18 章介绍了全局对象，通过该章的描述，可以知道:&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;全局属性，全局属性有: globalThis、Infinity、NaN、    。&lt;/p&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;全局方法，全局方法有: eval(x)、isFinite、isNaN、parseFloat、parseInt、decodeURIComponent、encodeURIComponent 等。&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;全局构造函数，全局的构造函数有:&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;p&gt;Array ArrayBuffer BigInt BigInt64Array BigUnit64Array Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise Proxy RangeError ReferenceError RegExp Set SharedArrayBuffer String Symbol SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;其他的全局属性 Atomics、JSON、Math、Reflect。 很显然，当字符单元的名称是上述名称中的一员时，我们可以对其进行高亮处理了（若上下文中无重新定义的同名变量）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;自定义 Error babel-loader 自身维护了私有的 LoaderError 对象，该对象继承自原生 Error 类，并且订制了部分实例属性。代码如下:&lt;/p&gt; &lt;p&gt;class LoaderError extends Error { constructor(err) { super();&lt;/p&gt; &lt;pre&gt;&lt;code&gt;      const { name, message, codeFrame, hideStack } = format(err);

      this.name = &quot;BabelLoaderError&quot;;

      this.message = ${name ? ${name}: ` : &quot;&quot;}${message}\n\n${codeFrame}\n`;

      this.hideStack = hideStack;

      Error.captureStackTrace(this, this.constructor);
  }
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;}&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;可以看到，babel-loader 自定义了错误实例的 name、message、hideStack 属性，那么，问题是，原生的 Error 类有哪些属性和方法，哪些是开发者可以自定义的呢？&lt;/p&gt; 
&lt;p&gt;规格的 19.5 章节，详细介绍了 Error 的各类规范:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Error 作为函数被调用时（Error(...)），表现和 new Error(...) 一致，均会创建并返回 Error 的新实例&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Error 可以被继承，比如通过 extends 的方式，子类必须提供 constructor 方法，且该方法内必须提供 super() 调用&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Error 构造函数必须有 prototype 属性&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;Error.prototype 属性需有以下属性：&lt;/p&gt; 
    &lt;ul&gt; 
     &lt;li&gt; &lt;p&gt;Error.prototype.constructor: 指向构造函数&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;Error.prototype.message: 描述错误信息，默认是空字符串&lt;/p&gt; &lt;/li&gt; 
     &lt;li&gt; &lt;p&gt;Error.prototype.name: 描述错误名称，默认值是 Error&lt;/p&gt; &lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;从 LoaderError 的源码可以看到，LoaderError 做了以下几件事情:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;LoaderError 继承自 Error&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;实例自定义了 name、message 属性，明确 babel-loader 的信息&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;实例自定义的 hideStack 属性是非标准属性，用于 babel-loader 内部&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;web 标准&lt;/h2&gt; 
&lt;p&gt;是在解决 API Polyfil 的时候，Babel 配合使用的 core-js 除了提供 ECMAScript 标准下的 JavaScript API 实现，也提供了 DOM/URL 等实现。而 DOM/URL 所属的 web 标准，由 W3C/WHATWG 制定。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/16_1725521927064.jpg&quot; alt=&quot;16.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;经过多年发展，WHATWG 和 W3C 目前是合作关系，其中，WHATWG 维护 HTML 和 DOM 标准，W3C 使用 WHATWG 存储库中的 HTML 和 DOM 标准描述，W3C 在 HTML 部分的工作集中在 XHTML/XML 上。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/17_1725521957624.jpg&quot; alt=&quot;17.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h1&gt;总结&lt;/h1&gt; 
&lt;p&gt;本文介绍了 Babel 的概述/微内核架构/ECMAScript 标准化方面的设计思想和部分实现原理。&lt;/p&gt; 
&lt;p&gt;上述内容其实在很早之前就已经成型了，笔者也查看了 Babel 最近的迭代内容，发现并没有太大的变化。至于代码转译领域，目前是 Babel 还是其他工具哪个更有优势，不在本文的讨论范围内。除了比较社区哪些工具更好而言，&quot;Babel 的设计思路、其与标准规范是怎么配合的&quot;等也是很值得学习的地方，也是这篇文章的产生背景。&lt;/p&gt; 
&lt;p&gt;希望本文对你有所帮助！&lt;/p&gt; 
&lt;p&gt;*&lt;strong&gt;文 / hoperyy&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;本文属得物技术原创，更多精彩文章请看：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com%2F&quot; target=&quot;_blank&quot;&gt;得物技术&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;未经得物技术许可严禁转载，否则依法追究法律责任！&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/5783135/blog/15671421</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/15671421</guid>
            <pubDate>Thu, 05 Sep 2024 07:49:12 GMT</pubDate>
            <author>得物技术</author>
        </item>
        <item>
            <title>《中国 MaaS（模型即服务）平台市场概览报告》发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;OSCHINA 发布了《中国 MaaS（模型即服务）平台市场概览报告》。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1540&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0905/150111_ySdv_2720166.png&quot; width=&quot;2728&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;主要内容包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;国内 MaaS 平台在互联网平台的声量对比&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;开发者对 MaaS 平台的关注度与需求分析&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;中国主流 MaaS 平台营销活动形式&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#16a085&quot;&gt;&lt;strong&gt;报告亮点速览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;我们发现，当前 MaaS 平台的主要用户群体是开发者和技术负责人，他们的关注点集中在平台的技术创新性、使用门槛、算力资源支持以及实际的开发应用能力上。&lt;/p&gt; 
&lt;p&gt;搜索关键词分析则进一步强化了这一点，用户普遍关心的是 MaaS 平台的先进技术、资源配备以及实际的应用价值。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2024/0905/150702_R0dY_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://report.oschina.net/api/files/jhim80u9qm1ofsw/jljf6vr8m1tlk9m/maa_s_dAgI0VpoJH.pdf&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;在线阅读地址&lt;/em&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;div&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;该报告已上传至开源中国 APP，欢迎前往&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#27ae60&quot;&gt;「开源中国 APP - 报告模块」&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;查看更多深度内容。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;img height=&quot;1426&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0905/151256_svsk_2720166.png&quot; width=&quot;2540&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;「开源中国 APP」下载地址：&lt;br&gt; &lt;a href=&quot;https://www.oschina.net/app&quot; target=&quot;_blank&quot;&gt;https://www.oschina.net/app&lt;/a&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8ab7bb9f45ecaae87f7a862ea446ae1dacf.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310487</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310487</guid>
            <pubDate>Thu, 05 Sep 2024 07:28:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>bboss v7.2.7 发布，新增 nacos 支持</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;ETL &amp;amp; 流批一体化框架 bboss v7.2.7 发布 --- 简版 Flink,&lt;/span&gt;新增 nacos 支持，喜欢 nacos 的用户有福了。&lt;/p&gt; 
&lt;h1&gt;&lt;span style=&quot;color:#34495e&quot;&gt;v7.2.7 功能改进&lt;/span&gt;&lt;/h1&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;http 服务框架改进：http-proxy 增加&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fhttpproxy%3Fid%3D_4%25ef%25bc%2589%25e5%258a%25a0%25e8%25bd%25bdnacos%25e9%2585%258d%25e7%25bd%25ae%25e5%2590%25af%25e5%258a%25a8httpproxy&quot; target=&quot;_blank&quot;&gt;nacos 配置中心支持以及基于 nacos 服务发现功能&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;es 客户端改进：增加&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fnacos-config%3Fid%3D_1elasticsearch%25e5%25ae%25a2%25e6%2588%25b7%25e7%25ab%25af%25e4%25b8%258enacos%25e5%25af%25b9%25e6%258e%25a5&quot; target=&quot;_blank&quot;&gt;nacos 配置中心支持以及基于 nacos 的 es 节点发现功能&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;es 客户端改进：es 数据源停止后，相应的 ClientInterface api 抛出 es 数据源停止异常；数据源重启后，相应的 ClientInterface api 即可恢复正常调用，提供相应的测试用例&lt;a href=&quot;https://gitee.com/bboss/eshelloword-booter/blob/master/src/test/java/org/bboss/elasticsearchtest/custominit/CustormInitAndBoot1.java&quot; target=&quot;_blank&quot;&gt;CustormInitAndBoot1&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;基础框架改进：属性配置管理增加 nacos 插件支持，参考 Apollo 配置中心插件，支持基于 nacos 管理配置，从 nacos 加载 ioc 配置、属性配置,参考文档：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fnacos-config&quot; target=&quot;_blank&quot;&gt;https://esdoc.bbossgroups.com/#/nacos-config&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;问题修复：修复 apollo 和 nacos 配置管理属性不能热加载问题&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#34495e&quot;&gt;基于 nacos 配置中心案例工程&lt;/span&gt;&lt;/h2&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;maven 工程-elasticsearch java client 案例&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbbossgroups%2Felasticsearch-example-nacos&quot; target=&quot;_blank&quot;&gt;https://github.com/bbossgroups/elasticsearch-example-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://gitee.com/bboss/elasticsearch-example-nacos&quot;&gt;https://gitee.com/bboss/elasticsearch-example-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;maven 工程-http proxy 案例&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbbossgroups%2Fhttpproxy-nacos&quot; target=&quot;_blank&quot;&gt;https://github.com/bbossgroups/httpproxy-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://gitee.com/bboss/httpproxy-nacos&quot;&gt;https://gitee.com/bboss/httpproxy-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;db 数据源管理案例&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbbossgroups%2Fdb-db-job3-nacos&quot; target=&quot;_blank&quot;&gt;https://github.com/bbossgroups/db-db-job3-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#34495e; text-align:start&quot;&gt;&lt;a href=&quot;https://gitee.com/bboss/db-db-job3-nacos&quot;&gt;https://gitee.com/bboss/db-db-job3-nacos&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;strong&gt;数据采集 ETL 工具使用集成指南&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fdb-es-tool&quot; target=&quot;_blank&quot;&gt;https://esdoc.bbossgroups.com/#/db-es-tool&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;strong&gt;数据采集 &amp;amp; 流批一体化处理使用指南&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fetl-metrics&quot; target=&quot;_blank&quot;&gt;https://esdoc.bbossgroups.com/#/etl-metrics&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;strong&gt;bboss-datatran 插件清单&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fdatatran-plugins&quot; target=&quot;_blank&quot;&gt;https://esdoc.bbossgroups.com/#/datatran-plugins&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;strong&gt;基于源码构建 bboss&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fesdoc.bbossgroups.com%2F%23%2Fbboss-build&quot; target=&quot;_blank&quot;&gt;https://esdoc.bbossgroups.com/#/bboss-build&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310467/bboss-7-2-7-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310467/bboss-7-2-7-released</guid>
            <pubDate>Thu, 05 Sep 2024 06:30:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>阿里通义千问全系列大模型被 GitHub 下架，所有仓库页面「404」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;阿里通义千问 (QwenLM) 全系列大模型的代码仓库被 GitHub 下架，访问其 repo 页面和 GitHub 主页均显示「404」。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FQwenLM%2FQwen2&quot; target=&quot;_blank&quot;&gt;https://github.com/QwenLM/Qwen2&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FQwenLM%2F&quot; target=&quot;_blank&quot;&gt;https://github.com/QwenLM/&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height=&quot;1162&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0905/120524_ghDH_2720166.png&quot; width=&quot;2482&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1250&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0905/121025_Yi1H_2720166.png&quot; width=&quot;2438&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;阿里云通义千问负责人回应称没有跑路，显示「404」原因是突然被 GitHub 官方标记。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2024/0905/120307_MIcX_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1230&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0905/133245_4Ie4_2720166.png&quot; width=&quot;1274&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;span&gt;来源：&lt;/span&gt;&lt;/em&gt;&lt;span style=&quot;color:#888888&quot;&gt;&lt;em&gt;&lt;span&gt;https://x.com/JustinLin610/status/1831489956512198862&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310448/qwenlm-github-repo-404</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310448/qwenlm-github-repo-404</guid>
            <pubDate>Thu, 05 Sep 2024 04:15:00 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>RWKV 模型已部署到 5 亿台 Windows 电脑？真正开源的新一代 AI 架构</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;2024 年 9 月 ，RWKV 社区成员发现：Office 系统在自动更新后（版本 2407 及以后）已自带 RWKV 运行库。&lt;/p&gt; 
&lt;p&gt;在 Windows 系统的&amp;nbsp; &lt;code&gt;C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\OFFICE16&lt;/code&gt; 目录，可以找到一系列 &lt;code&gt;rwkv&lt;/code&gt; dll（动态链接库） 文件。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;RWKV dll in Windows&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-in-windows-os.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;由于正版 Windows 大多预装了 Office 365，因此，全球大多数 Windows 10 和 11 机器现已搭载 RWKV，包括线下商店中售卖的 Windows 机器。这意味着 RWKV 的装机量可达几亿台。&lt;/p&gt; 
 &lt;p&gt;RWKV 是真正的开源架构（目前在 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flfaidata.foundation%2Fprojects%2Frwkv%2F&quot; target=&quot;_blank&quot;&gt;Linux Foundation 旗下&lt;/a&gt;），遵循 Apache 2.0 协议，可用于商业，欢迎大家在各个项目使用。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;RWKV 的最新架构为 RWKV-6，且 RWKV-7 即将公布。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;从 dll 的文件属性，可以明确这是 RWKV 模型的加载器：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;dll 文件属性&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-property.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此外，微软提供的协议中也明确出现了 rwkv.cpp 的仓库地址 ：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;带 rwkv.cpp 的许可证&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-cpp-license.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;随后，社区开发者对 dll 文件进行解析，发现 dll 中的函数确实是来自 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FRWKV%2Frwkv.cpp&quot; target=&quot;_blank&quot;&gt;rwkv.cpp 库&lt;/a&gt;中的 RWKV 模型相关函数：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;dll 文件中的函数&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-export.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;该发现在多方社交媒体上引起了激烈的讨论：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;RWKV 官方推文&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-x-rwkv-ai.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/RWKV-dll-x-wangtiezhen.webp&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;知乎上的讨论：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F666097016&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/666097016&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;RWKV 在 Windows 系统中的角色&lt;/h3&gt; 
&lt;p&gt;目前，微软方面未公布 RWKV 模型会用于 Windows 系统中的哪些功能。&lt;/p&gt; 
&lt;p&gt;尽管 RWKV 系列 dll 文件存放在 Microsoft Office 目录中，但它们其实是操作系统的一部分，而不仅限于 Microsoft Office 。&lt;/p&gt; 
&lt;p&gt;出于 RWKV 恒定的显存/内存占用、支持全球 100 多种语言、「能耗最低的模型」等特性，我们推测 RWKV 可能会用于以下 Windows 系统功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;本地 copilot&lt;/li&gt; 
 &lt;li&gt;作为 Windows 系统的本地记忆回调器&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;code&gt;Local memory recall&lt;/code&gt; 是让操作系统记住你过去的操作或输入信息，在需要时再次使用这些记忆。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;RWKV 的 llama.cpp 用法&lt;/h2&gt; 
&lt;p&gt;随着 RWKV 社区成员 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMollySophia&quot; target=&quot;_blank&quot;&gt;@MollySophia&lt;/a&gt; 的工作，llama.cpp 现已适配 &lt;code&gt;RWKV-6&lt;/code&gt; 模型。&lt;/p&gt; 
&lt;p&gt;接下来，我们一起看看如何在 llama.cpp 中使用 RWKV-6 模型进行推理：&lt;/p&gt; 
&lt;h3&gt;第一步：获取 gguf 格式模型&lt;/h3&gt; 
&lt;p&gt;llama.cpp 支持 &lt;code&gt;.gguf&lt;/code&gt; 格式的模型，但 RWKV 官方仅发布了 &lt;code&gt;.pth&lt;/code&gt; 格式模型。因此，我们需要使用以下两种方法获取 gguf 格式的 RWKV 模型。&lt;/p&gt; 
&lt;h4&gt;方法 1：从 HF 下载现成 gguf 模型（推荐）&lt;/h4&gt; 
&lt;p&gt;可以从 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Flatestissue&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/latestissue&lt;/a&gt; 下载已量化并转化成 gguf 格式的 RWKV 模型&lt;/p&gt; 
&lt;h4&gt;方法 2：从 HF 格式转换成 &lt;code&gt;.gguf&lt;/code&gt; 格式&lt;/h4&gt; 
&lt;p&gt;首先，从 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FRWKV&quot; target=&quot;_blank&quot;&gt;RWKV 官方 HF 仓库&lt;/a&gt;下载一个 Hugging Face 格式的 RWKV 模型，如 &lt;code&gt;RWKV/v6-Finch-1B6-HF&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt;然后在 llama.cpp 目录运行此命令，将 Hugging Face 模型转成 gguf 格式：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;python llama.cpp/convert_hf_to_gguf.py ./v6-Finch-1B6-HF

&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;量化方法：（可选）&lt;/h4&gt; 
&lt;p&gt;运行以下命令，对 .gguf 模型进行量化：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;./build-cuda-rel/bin/llama-quantize v6-Finch-1B6-HF/v6-Finch-1.6B-HF-F16.gguf（量化前的 gguf 模型路径） ./v6-Finch-1B6-HF/v6-Finch-1.6B-HF-Q5_1.gguf（量化后的 gguf 模型路径） Q5_1（量化精度）

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;所有可选的量化精度：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;可选的量化精度&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-quantization-type.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;建议使用以下两种量化精度： &lt;code&gt;Q5_1&lt;/code&gt;、 &lt;code&gt;Q8_0&lt;/code&gt;。&lt;/p&gt; 
&lt;h3&gt;第二步：本地构建 llama.cpp&lt;/h3&gt; 
&lt;p&gt;可以选择从 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fggerganov%2Fllama.cpp%2Freleases&quot; target=&quot;_blank&quot;&gt;llama.cpp 的 release 页面&lt;/a&gt;下载已编译的 llama.cpp 程序。&lt;/p&gt; 
&lt;p&gt;也可以参照 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fggerganov%2Fllama.cpp%2Fblob%2Fmaster%2Fdocs%2Fbuild.md&quot; target=&quot;_blank&quot;&gt;llama.cpp 官方构建文档&lt;/a&gt;，选择适合的方法本地编译构建。&lt;/p&gt; 
&lt;h3&gt;第三步：运行 RWKV 模型推理&lt;/h3&gt; 
&lt;p&gt;在 llama.cpp 目录运行以下命令，可驱动 RWKV 模型基于 prompt 生成文本：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;./build/bin/llama-cli -m ./v6-Finch-1B6-HF/v6-Finch-1.6B-HF-F16.gguf --no-warmup -p &quot;User: Write me a poem\n\nAssistant:&quot; -t 8 -ngl 25 -n 500

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这条命令通过 llama-cli 运行 RWKV 模型，使用 8 个线程、跳过预热、并根据给定的 prompt 生成最多 500 个 token。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;RWKV 模型推理&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-RWKV-inference-single-prompt.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;参数解释：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;./build/bin/llama-cli&lt;/code&gt;：编译好的 llama-cli 程序，打开命令化界面&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;-m ./v6-Finch-1B6-HF/v6-Finch-1.6B-HF-F16.gguf&lt;/code&gt;：模型的路径参数&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;--no-warmup&lt;/code&gt;：跳过「预热」阶段，直接开始生成文本（以少量性能换取速度）&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;-p &quot;User: Write me a poem\n\nAssistant:&quot;&lt;/code&gt;： prompt 参数，模型根据该提示词生成文本。&quot;User: Write me a poem\n\nAssistant:&quot; 是符合 RWKV 模型格式的 prompt，更多 RWKV prompt 格式请在&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frwkv.cn%2FRWKV-Prompts%2FChat-Prompts&quot; target=&quot;_blank&quot;&gt;RWKV 文档-提示词指南&lt;/a&gt;中查看。&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;-t 8&lt;/code&gt;：-t 指定线程数，建议根据可用的物理 CPU 核心数调整&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;- ngl&lt;/code&gt;：指定模型使用的 n-gpu-layers ，25 是在 GPU 上运行 25 层（1.6B 的 24 层 + head 算一层）。可以无脑设定 &lt;code&gt;-ngl 99&lt;/code&gt;，使 llama.cpp 加载 RWKV 模型所有层&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;-n 500&lt;/code&gt;：-n 参数表示生成的最大 token 数&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;完整的参数列表可以在 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fggerganov%2Fllama.cpp%2Fblob%2Fmaster%2Fexamples%2Fmain%2FREADME.md&quot; target=&quot;_blank&quot;&gt;llama.cpp 参数文档&lt;/a&gt;中查看。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;批量推理生成&lt;/h4&gt; 
&lt;p&gt;使用以下命令，以进行批量推理：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;使用 &lt;code&gt;\n&lt;/code&gt; 隔开不同的 prompt&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code&gt;./build/bin/llama-parallel -ns 4 -np 4 -m v6-Finch-1B6-HF/v6-Finch-1.6B-HF-F16.gguf --no-warmup -ngl 25 -n 500 -p &quot;Who are you?\nWhat do we have for dinner?\nWhat&#39;s the meaning of life\nHello\nWhat is the end of the universe?&quot;

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img alt=&quot;批量推理生成&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-RWKV-inference-parallel.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;参数解释：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;-ns 4&lt;/code&gt;: n_sequence，推理序列的数量&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;-np 4&lt;/code&gt;: n_parallel，并行推理的数量&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;启动 Web 服务&lt;/h3&gt; 
&lt;p&gt;使用以下命令，以启动 llama.cpp 的 Web 服务：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;./build/bin/llama-server -m v6-Finch-1B6-HF/v6-Finch-1.6B-HF-F16.gguf --no-warmup -ngl 25

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img alt=&quot;llama.cpp 的 Web 服务&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-start-webui.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;启动后，可以访问 &lt;code&gt;http://127.0.0.1:8080&lt;/code&gt; 以检查 Web 页面：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;WebUI&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-webui-old-version.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;chatUI&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-chatui-old-version.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;点击右上方的 &lt;code&gt;New Ul&lt;/code&gt;按钮，或者直接访问 &lt;code&gt;http://127.0.0.1:8080/index-new.html&lt;/code&gt;，可以打开新版本的 WebUI&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;新版本的 WebUI&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-webui-new-version.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;新版本的 chatUI&quot; src=&quot;https://oscimg.oschina.net/oscnet/llama.cpp-chatui-new-version.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;RWKV 模型介绍&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;RWKV 是一种创新的深度学习网络架构，它将 Transformer 与 RNN 各自的优点相结合，同时实现高度并行化训练与高效推理，时间复杂度为线性复杂度，在长序列推理场景下具有优于 Transformer 的性能潜力。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;RWKV 模型架构论文：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;RWKV 4：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2305.13048&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/2305.13048&lt;/a&gt;&lt;br&gt; RWKV-5/6（Eagle &amp;amp; Finch）：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2404.05892%C2%A0&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/2404.05892&amp;nbsp;&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;RWKV 模型的最新版本是 RWKV-6 ，架构图如下：&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;1496&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b5e602a3b0574972f4d3e381acae509c1f0.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#444444&quot;&gt;相对&amp;nbsp;&lt;span&gt;Transformer 架构，&lt;/span&gt;RWKV 架构的推理成本降低 2~10 倍，训练成本降低 2~3 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;加入 RWKV 社区&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&amp;nbsp;RWKV 中文文档：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.rwkv.cn&quot; target=&quot;_blank&quot;&gt;https://www.rwkv.cn&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;QQ 频道：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpd.qq.com%2Fs%2F9n21eravc&quot; target=&quot;_blank&quot;&gt;https://pd.qq.com/s/9n21eravc&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310440</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310440</guid>
            <pubDate>Thu, 05 Sep 2024 03:47:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>WPS Office for Linux 12 个人版上线 deepin 23 商店！</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fwps-office-for-linux-12-deepin-23%2F&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;查看原文&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;全新 WPS Office For Linux 个人版（12.1.0.17881）与 deepin 23 的 AI 功能深度融合，正式上架在社区商店啦！&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;383&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/WHLUG%E6%B4%BB%E5%8A%A8900x383.png&quot; width=&quot;900&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;这是 Linux 版本的一次里程碑式的重大更新。在产品能力层面上，在 deepin 23 上 WPS Office 几乎实现了与 Windows 版本的无缝对接，无论是界面布局、功能实现还是操作流畅度，都为用户带来了高度一致且卓越的体验。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;718&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905094056.jpg&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;亮点功能&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;UI 视觉重构升级：新版本使用全新的视觉设计，在延续了 WPS 设计风格的同时，通过调整布局、模块化设计等方式，在视觉效果、使用逻辑方面进行了深度优化，帮助用户以更低的学习成本快速掌握使用技巧。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;892&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905094100-1.jpg&quot; width=&quot;1527&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;WPS 演示&lt;/h2&gt; 
&lt;p&gt;1、支持「主题生成」「大纲生成」「文档生成」多种模式一键生成并美化 PPT。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;675&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103211.png&quot; width=&quot;1205&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;2、输出为图片：支持文件批量输出为图片，支持逐页输出或输出为长图。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;667&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103322.png&quot; width=&quot;1201&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;3、输出为视频：演示组件支持将 PPT 输出为视频。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;672&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103326.png&quot; width=&quot;1202&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;WPS 文字&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;文字支持「帮我写」「帮我改」，AI 快速生成和润色文本。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;672&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103326-1.png&quot; width=&quot;1202&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;WPS 表格&lt;/h2&gt; 
&lt;p&gt;表格 AI 写公式：一键生成复杂公式，快速解决数据处理难题。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;491&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/5-%E8%A1%A8%E6%A0%BCAI%E5%86%99%E5%85%AC%E5%BC%8F.gif&quot; width=&quot;873&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;文档云同步&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;支持本地文档同步至云端，实现实时保存，多端共享、跨端编辑。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;1078&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/6-%E6%96%87%E6%A1%A3%E4%BA%91%E5%90%8C%E6%AD%A5.gif&quot; width=&quot;1918&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;协作编辑&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;支持本地编辑与在线编辑模式切换，实时与团队共同编辑文档。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;1078&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/7-%E5%8D%8F%E4%BD%9C%E7%BC%96%E8%BE%91.gif&quot; width=&quot;1918&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;稻壳资源&lt;/strong&gt;&lt;/h2&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;提供文字、表格、演示等多组件模板；覆盖图片、图标、字体等素材。&lt;img alt=&quot;&quot; height=&quot;676&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103550.png&quot; width=&quot;1201&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;PDF 转换&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;新增增值服务选项卡，支持 PDF 转换、输出为图片等增值功能，解决了 23 下无法查看 PDF 的问题。&lt;/p&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;738&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240905103318.png&quot; width=&quot;1315&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;更多功能等你发现啦&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;注：本次提供的增值功能 / 增值服务均需登录会员账号后使用，无会员权益时不会展示对应功能入口；Linux 个人版暂不支持会员购买，可在 WPS 官网购买后，在 deepin 23 端上使用。&lt;/p&gt; 
&lt;p&gt;针对此版本的 WPS AI，UOS AI 也进行了深度调优并与 WPS 表格、WPS 文字、WPS 演示、WPS PDF 等应用进行了紧密适配。通过利用 UOS AI 的 AI 端侧模型搭载本地向量数据库用户可以将保存本地的 WPS 办公格式文档做成个人知识库实现智能化的知识管理、检索和应用。这一创新功能不仅提高了用户的知识管理效率还为用户提供了更加便捷、智能的办公体验。&lt;/p&gt; 
&lt;p&gt;我们相信，在未来的日子里，deepin 与 WPS Office 将携手并进，共同坚守创新、开放、共享的理念，致力于为更广泛的用户群体打造更加卓越、智能的办公体验。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;（1）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Ftable.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;deepin 全版本镜像（含 deepin V15）&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;（2）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-community-monthly-report-2024-08%2F&quot; target=&quot;_blank&quot;&gt;deepin（社区）8 月月度汇报&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;（3）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-use-minicom-and-cutecom%2F&quot; target=&quot;_blank&quot;&gt;网络工程师使用 deepin 必需掌握的两个工具 minicom 和 cutecom&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310425/wps-office-for-linux-12-deepin-23</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310425/wps-office-for-linux-12-deepin-23</guid>
            <pubDate>Thu, 05 Sep 2024 03:07:32 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>智谱完成新一轮数十亿元融资</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2936418849201025&quot; target=&quot;_blank&quot;&gt;根据 36 氪的独家报道&lt;/a&gt;&lt;/u&gt;，近日中国大模型独角兽智谱以 200 亿元的投前估值，完成了新一轮融资，金额达数十亿元。&lt;/p&gt; 
&lt;p&gt;本轮领投方为中关村科学城公司，其为海淀区政府设立的市场化投资平台。&lt;/p&gt; 
&lt;p&gt;对上述消息，对方表示不予置评。&lt;/p&gt; 
&lt;p&gt;根据公开信息，新一轮融资是 2024 年以来智谱完成的第三笔。目前，智谱的股东阵容包括高瓴资本、启明创投、君联资本等知名投资机构以及美团、阿里、腾讯、小米在内的互联网大厂。&lt;/p&gt; 
&lt;p&gt;目前智谱的商业化，在 B 端主要有几种模式：API，云端私有化，以及本地私有化。根据智谱在 6 月 Open Day 上公开的讯息，其面向开发者和企业客户的大模型开放平台 bigmodel.cn 拥有超过 50 万客户。&lt;/p&gt; 
&lt;p&gt;相关人士对 36 氪透露，目前智谱在 B 端的商业化成绩是独角兽企业中最好的，并且营收领先了第二名一个数量级。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;而在 C 端，2024 年，智谱在 ToC 产品「智谱清言」上，也做了订阅付费的试水。根据官方数据，在「智谱清言」上线的视频生成模型「清影」也启用了「付费会员」，2 周内有 100 万人使用。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310414</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310414</guid>
            <pubDate>Thu, 05 Sep 2024 02:25:42 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>零一万物开源 Yi-Coder 系列编程助手模型</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;零一万物正式开源了 Yi-Coder 系列编程模型。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/img/202409/05101606_4Poj.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Yi-Coder 系列模型专为编码任务而生，提供 1.5B 和 9B 两种参数。其中，Yi-Coder-9B 的表现号称「优于其他 10B 参数以下的模型」，如 CodeQwen1.5 7B 和 CodeGeex4 9B，甚至能够「与 DeepSeek-Coder 33B 相媲美」。&lt;/p&gt; 
&lt;p&gt;Yi-Coder 能够处理最长 128K tokens 的上下文内容，适用于复杂项目级代码的理解和生成。Yi-Coder 还支持 52 种主要编程语言。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型简介&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Yi-Coder 系列模型&lt;strong&gt;专为编码任务而生&lt;/strong&gt;，提供 1.5B 和 9B 两种参数。其中，Yi-Coder-9B 的表现优于其他 10B 参数以下的模型，如 CodeQwen1.5 7B 和 CodeGeex4 9B，甚至能够与 DeepSeek-Coder 33B 相媲美。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型特点&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;小参数，强性能&lt;/strong&gt;：尽管 Yi-Coder 的参数量相对较小，但它在各种任务，包括代码生成、代码理解、代码调试和代码补全中的表现十分出色。10B 以下的大小也让它易于使用，方便端侧部署。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;128K 长序列建模&lt;/strong&gt;：Yi-Coder 能够处理长达 128K tokens 的上下文内容，有效捕捉长期依赖关系，适用于复杂项目级代码的理解和生成。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;强大的代码生成能力&lt;/strong&gt;：支持 52 种主要编程语言，Yi-Coder 在代码生成和跨文件代码补全方面表现优异。&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310410/01-ai-yi-coder</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310410/01-ai-yi-coder</guid>
            <pubDate>Thu, 05 Sep 2024 02:16:42 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>开源日报 | 2024 年最流行的编程语言；微软程序员基本工资 12 万美元起；Vue 3.5 发布；Win11 集成国产开源大模型；K8s 深渊图</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2024.9.4&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要闻&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310263/vue-3-5&quot;&gt;Vue 3.5 正式发布，代号「天元突破红莲螺岩」&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;Vue 3.5 「天元突破红莲螺岩」(Tengen Toppa Gurren Lagann) 版本发布！&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;在 3.5 中，Vue 的响应式系统经历了又一次重大重构，实现了更好的性能和显著减少了内存占用 (-56%)，且没有行为变化。这次重构还解决了 SSR 过程中由于悬挂的计算属性导致的过时计算值和内存问题。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnbeta.com.tw%2Farticles%2Ftech%2F1444541.htm&quot; target=&quot;_blank&quot;&gt;2024 年最流行的编程语言&lt;/a&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#a1a1aa; text-align:start&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0fe9f9b6dcf72228ffb3c19032539db8583.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310261/firefox-130-released&quot;&gt;Mozilla 发布 Firefox 130&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;Mozilla 正式发布了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Firefox 130&lt;/strong&gt;，引入了一系列新功能，以提升用户体验。其中最引人注目的新增功能是&lt;strong&gt;自动画中画（Picture-in-Picture, PiP）模式&lt;/strong&gt;。该功能允许用户在切换标签页时，视频可以自动继续在一个单独的可调整大小的窗口中播放，使得用户在进行多任务处理时不会错过内容。&lt;/p&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310283/recall-uninstall-option-in-windows-11-is-just-a-bug&quot;&gt;微软称 Windows 11 中出现「Recall」卸载选项是 Bug&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#424242&quot;&gt;上周用户在微软最新的&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;Windows 11&lt;span style=&quot;background-color:#ffffff; color:#424242&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;版本中发现，&lt;/span&gt;&lt;strong&gt;可在 「打开和关闭 Windows 功能」 设置中删除备受争议的 Recall 功能&lt;/strong&gt;。然而对于这个功能选项，微软称这是 Bug 而不是特性——因为 Recall 功能在正式发布后将无法卸载。&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;微软高级产品经理 Brandon LeBlanc 向 The Verge 透露，公司「意识到一个问题，即在控制面板的‘打开或关闭 Windows 功能’对话框中，Recall 被错误地列为一个选项，这个问题将在即将发布的更新中得到修复。」&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2024/0904/152812_zWUZ_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日观察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6105753431%2FOvqIkrPhl&quot; target=&quot;_blank&quot;&gt;微软 Win11 中发现国产开源大模型&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;p&gt;微软正尝试在 Office 中集成国产开源大模型 RWKV！RWKV 官方甚至直接发了个推文表示：RWKV.cpp，现已在全球五亿系统中部署。&lt;/p&gt; 
      &lt;p&gt;之所以这么说，是因为他们发现最新版 Windows 11 系统的 Office 文件夹中有以 rwkv 命名的 DLL 文件，包含 GPU、CPU 版本。&lt;/p&gt; 
      &lt;p&gt;人人都可以将 Windows 11 更新到最新版本，通过以下路径自行验证：C:\Program Files\Microsoft Office\root\vfs\ProgramFilesCommonX64\Microsoft Shared\OFFICE16&lt;/p&gt; 
      &lt;p&gt;或者，也可以在 IT 商店的任何「copilot Windows 11」设备上搜索系统文件中的 rwkv。&lt;/p&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span&gt;- 微信&amp;nbsp;&lt;strong&gt;量子位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2194035935%2FOvpPSjdal&quot; target=&quot;_blank&quot;&gt;K8s 深渊图&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ce6a5610a28eeb3addac6c6e5e5cdb3539d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;&lt;span&gt;蚁工厂&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7616053865%2FOvnMdge7e%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;IT 大厂里面，最厉害的人不是拿最高绩效的&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;p&gt;我觉得在 IT 大厂里面，最厉害的人不是拿最高绩效的，而是每天相对清闲拿中等绩效且还能保持不被炒的。&lt;/p&gt; 
   &lt;p&gt;这样的人既保住了基本饭碗，又不至于为了一个工作而卖命，甚至可以在工作之余追求自己的梦想——而不是在资本设置的单一评判体系里面拼命内斗。&lt;/p&gt; 
   &lt;p&gt;此状态实际操作难度较大，因为要达成（1）不被炒（2）不太卖命这两个有点冲突的目标，对平衡能力、审时度势能力、人际关系等都有着很高的要求。&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;业余早睡选手&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F7817295402%2FOvcqh3ybk&quot; target=&quot;_blank&quot;&gt;青少年编程入门什么语言比较合适？&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;不知道题主孩子多大，编程语言和自然语言也有相通的地方，如果自然语言能力和数学/逻辑能力比较强，编程就更容易上手一些。很多 syntax 的问题如果不是拼写 typo，那就是理解的还不到位，逻辑上没搞明白，变量 scope 不清楚之类的。&lt;/p&gt; 
  &lt;p&gt;Block 编程当然可以的，能学一些基本概念，不过最终还是要学编程语言的，如果 debug 嫌麻烦可以用 chatGPT 帮忙，会给你讲的很详细，学编程的过程肯定够用了。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博 &lt;strong&gt;recky_yy&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F2144454703%2FOvnWRFwQ2&quot; target=&quot;_blank&quot;&gt;1% 的网络丢包率就会带来 50% 的算力损失&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt;
     1， 1% 的网络丢包率就会带来 50% 的算力损失
     &lt;br&gt; 2，传输距离每增加 10km，通信时延增加 10ms
     &lt;br&gt; 3，数据显示，当网络的丢包率大于 10-3 时，RDMA 有效吞吐将急剧下降；2% 的丢包率会使 RDMA 吞吐率下降为 0。因此，要使得 RDMA 吞吐不受影响，丢包率必须保证在十万分之一以下，最好为零丢包
     &lt;br&gt; ～～～from 中国电信，分布式智算中心无损网络技术白皮书 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博 &lt;strong&gt;WinnieS 的微博&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.leiphone.com%2Fcategory%2Fai%2FGE0YVTuWYCVqrbUp.html&quot; target=&quot;_blank&quot;&gt;贾扬清一吐为快:要想赚钱，AI 模型到底该大该小?&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;p&gt;对于贾扬清这样的 AI Infra 创业者，模型大小的潮流变化对他的商业模式有什么影响？这个问题，要分不同情况分析。&lt;/p&gt; 
     &lt;p&gt;如果模型参数量越大，提供模型服务的门槛越高（参考 Llama 405B），其客单价自然也就越大；另一方面，由于很多小模型实际是在大模型的基础上蒸馏而得到，模型小了，所需的计算资源并没有等幅度减少；&lt;/p&gt; 
     &lt;p&gt;由于较小的模型更容易部署在不同的设备和平台上，这可能会带来应用场景的增加，虽然客单价可能降低，但在需求数量上的增加反而可能使得总收入增加；对于贾扬清来说，META 的开源路线使得贾扬清的服务对象扩大，因此开源对他来说更有利。&lt;/p&gt; 
     &lt;p&gt;看来不管未来模型规模怎么不变化，贾扬清都有机会凭借技术升级稳坐钓鱼台。这有点像之前的中国股市，不管什么消息，都是「利好茅台」啊。&lt;/p&gt; 
     &lt;p&gt;这恐怕就是贾扬清最近在推特上为什么这么活跃发表看法的原因？你看好贾扬清这种 AI Infra 的创业路线吗？&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;-&amp;nbsp;&lt;strong&gt;雷峰网&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffinance.sina.com.cn%2Froll%2F2024-09-04%2Fdoc-incmyqsn9641727.shtml&quot; target=&quot;_blank&quot;&gt;对话 MiniMax 创始人闫俊杰：打不赢，就应该被淘汰&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt; 
       &lt;p&gt;在 MiniMax 成立以来的第一场媒体见面会，创始人闫俊杰分享了基于 MOE（混合专家模型）+ Linear Attention（线性注意力）的新一代模型技术的应用，并展示了 MiniMax 最新音乐模型、视频模型的研发成果。&lt;/p&gt; 
       &lt;p&gt;最为引人关注的是，MiniMax 发布了一支名为《魔法硬币》的 2 分钟视频。其所有场景画面全部由大模型生成，没有进行任何人类加工，效果惊艳。&lt;/p&gt; 
       &lt;p&gt;「科学技术是第一生产力，这是 MiniMax 坚持技术创新的最底层原因。」闫俊杰说，MiniMax 将持续通过技术突破推动 AI 加速发展，拓展人类智慧的边界，真正实现 Intelligence with Everyone。&lt;/p&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;网易科技&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.thepaper.cn%2FnewsDetail_forward_28627514&quot; target=&quot;_blank&quot;&gt;人工智能大模型开源面临的问题及数据保护&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;在人工智能发展过程中，人工智能大模型研制已成为科技创新重要内容之一。人工智能大模型技术的运作原理主要是以海量数据为依托，并通过数据训练、算法优化等技术捕捉和学习更复杂的内容，从而促进人工智能大模型持续优化与性能提升。&lt;/p&gt; 
 &lt;p&gt;然而，人工智能大模型开源的数据不可避免地存在「原罪」，即，直接体现为部分训练数据未获得合法授权，简称数据「原罪」。它主要指在人工智能大模型训练过程中，所使用的大量数据可能来源于未经授权的数据或数据集。这些数据可能涉及个人隐私或受版权保护。未经授权使用这些数据可能侵犯相关主体的合法权益，易引发法律和伦理问题。&lt;/p&gt; 
 &lt;div&gt; 
  &lt;div style=&quot;text-align:right&quot;&gt;
   &lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;
   &lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;澎湃新闻&lt;/span&gt;&lt;/strong&gt;
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.huxiu.com%2Farticle%2F3431358.html&quot; target=&quot;_blank&quot;&gt;一个人，13 年，70 个创业项目，独立开发的超级传奇&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;一人公司正在成为一种趋势，Pieter Levels 是这个领域里的超级玩家。&lt;/p&gt; 
 &lt;p&gt;自学成才，独立开发，从 2012 年到 2021 年，启动了 70 个创业项目，成功运营 40 个，其中只有 4 个让他赚了很多钱。最成功的，Nomad List，一年盈利 210 万美金。2021 年后，做了几个 AI 产品，MRR 十几万美元。&lt;/p&gt; 
 &lt;p&gt;95% 的项目都失败了，他自我总结，5% 的「命中率」，所以只要做得够多就行。&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;极客公园&lt;/strong&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://my.oschina.net/u/4090830/blog/15656404&quot;&gt;万字长文浅谈三高系统建设方法论和实践&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt;
   整个软件的发展历程是一部软件复杂性对抗史，软件的复杂性分为技术复杂性和业务复杂性，业务复杂性主要是建模和抽象设计，技术复杂性主要是三高（高性能，高并发，高可用）的应对，C 端的业务一般以技术复杂性为主，业务复杂性为辅，而 B 端或者 M 端的业务通常以业务复杂性为主，技术复杂性为辅。本篇文章主要是从后端研发的视角结合自己多年的 B C 端系统建设实践谈下三高系统的建设方法论和实践。
   &lt;br&gt; &amp;nbsp;
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;hr&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;开源之声&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBkQTxsxqmUnFb4yOoNuXvA&quot; target=&quot;_blank&quot;&gt;微软程序员基本工资 12 万美元起&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：微软中国只有 1/4 都不到&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：要符合国内国情，工资高了不利于我们努力[旺柴]&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPH7MQ_L9e_vWzFdfraphXQ&quot; target=&quot;_blank&quot;&gt;中科院女工程师开源 AI 模型对抗 deepfake：用 AI 打败 AI &lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：只要稍微了解一些人工智能和对抗性训练的知识，就会知道这种对抗会把 deepfake 模型训练得越来越聪明，越来越逼真。&lt;br&gt; 这不是解决问题的根本之道。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：蹭热度罢了。监测出是 fake 的又怎样，合成的和看的人会在乎么。社会实践、法律问题和技术层面基本无关。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：会用模型的多吗&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;最后，欢迎扫码下载「开源中国 APP」，阅读海量技术报告、程序员极客分享！&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d27cc3636c021c266537f4729dc0f84fdc3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310339</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310339</guid>
            <pubDate>Wed, 04 Sep 2024 11:39:44 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>微软称 Windows 11 中出现「Recall」卸载选项是 Bug</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#424242&quot;&gt;上周用户在微软最新的&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;Windows 11&lt;span style=&quot;background-color:#ffffff; color:#424242&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;版本中发现，&lt;/span&gt;&lt;strong&gt;可在「打开和关闭 Windows 功能」设置中删除备受争议的 Recall 功能&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1156&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0904/152812_zWUZ_2720166.png&quot; width=&quot;1374&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Recall 是微软在今年 5 月首次宣布的 AI 功能，它会每 5 秒钟截屏 1 次，由此记录用户操作电脑的行为，让大模型记忆并随时帮助用户回忆，因为涉及到个人隐私和商业机密，Recall 功能引发了巨大争议。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-89e1e1875216c7caeef77deb084816df26c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;虽然微软表示 Recall 收集的数据不会上传到云端或与微软或第三方共享，但这些数据以未加密的形式存储在本地目录中，容易被潜在攻击者访问。&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;这一发现导致微软推迟了 Recall 功能的发布，&lt;strong&gt;直到最近才确认该功能将于今年 10 月开始公开预览&lt;/strong&gt;。微软承诺，当 Recall 功能正式发布时，其将更加安全且完全可选。&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5300b891d866738283f6f50df3a018e0031.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;然而对于 Windows 11 最新版可卸载「Recall」的功能选项，微软称这是 Bug 不是特性。&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;微软高级产品经理 Brandon LeBlanc &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2F2024%2F9%2F2%2F24233992%2Fmicrosoft-recall-windows-11-uninstall-feature-bug&quot; target=&quot;_blank&quot;&gt;向 The Verge 透露&lt;/a&gt;&lt;/u&gt;，公司「意识到一个问题，即在控制面板的‘打开或关闭 Windows 功能’对话框中，&lt;strong&gt;Recall 被错误地列为一个选项，这个问题将在即将发布的更新中得到修复&lt;/strong&gt;。」&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;strong&gt;这并不意味着 Recall 功能将强制安装，只是该应用程序本身无法从系统中轻松删除&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style=&quot;color:#424242; margin-left:0; margin-right:0; text-align:justify&quot;&gt;用户仍然可以在设置 PC 时选择禁用 Recall 功能，并随时通过开始菜单中的 Recall 应用程序启用。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310283/recall-uninstall-option-in-windows-11-is-just-a-bug</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310283/recall-uninstall-option-in-windows-11-is-just-a-bug</guid>
            <pubDate>Wed, 04 Sep 2024 07:24:39 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Rust 开发的高成长性的数据服务平台 —— GrowthStore 发布</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f1f1f&quot;&gt;GrowthStore 是一个基于 Rust 体系的成长型的企业级后台服务的开发框架。它提供了 「约定大于配置，配置即服务」 的开发理念，采用统一的约定、灵活的配置来实现绝大多数的业务，通过灵活高效的扩展体系，来满足各种特殊化的业务需求，快速应对企业的业务成长需要。GrowthStore 的出现，为企业级后端开发注入了新鲜的血液。&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt;
  GrowthStore 有一套统一的服务语言，即它的 InvokeURI 统一调用服务语言，使得它的各种功能可以使用一套统一化的 URI 来进行表示，而前端只需要根据这些 URI 的规范即可知道 GrowthStore 的具体提供服务。因此，GrowthStore 可以为前端开发人员提供更好的开发范式，让前端开发人员与后台服务开发更容易达成一致。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  GrowthStore 提供了支持多种关系型数据库的映射能力，如 MySQL、PostgreSQL、MSSQL Server 等，GrowthStore 提供了可配置性的数据库表及查询的映射方式，可以支持类似于 1..1, 1..N， N..N 之类的表与表之间的关系型映射，并提供基于 CRUD 的 11 种操作和查询模式。我们可以使用 GrowthStore 快速开发数据库应用，而无需写后台的代码。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  同样的，GrowthStore 提供了对 MQTT、Kafka、Redis、ElasticSearch 等多种流行的第三方应用提供了支持，并通过插件形式，提供了基于 RESTful 接口的支持，以满足各种业务系统的对接需求。GrowthStore 可以很方便的开发对各种第三方软件的支持插件，并通过脚本语方、Hook 机制、事件机制等多种形式完成与第三方软件的集成，进而与企业的 IT 整体架构共同成长。
 &lt;/div&gt; 
&lt;/div&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310267</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310267</guid>
            <pubDate>Wed, 04 Sep 2024 03:42:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>Vue 3.5 正式发布，代号「天元突破红莲螺岩」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;本文转载自：「前端圈」微信公众号&lt;/p&gt; 
 &lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FRXBLDfWzUxR5Oebktd2HrA&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/RXBLDfWzUxR5Oebktd2HrA&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Vue 官方今天发布 &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.vuejs.org%2Fposts%2Fvue-3-5&quot; target=&quot;_blank&quot;&gt;Vue 3.5 正式版&lt;/a&gt;&lt;/u&gt;，我们一起来看看都有哪些变化？&lt;/p&gt; 
&lt;p&gt;今天我们很兴奋地宣布 Vue 3.5「天元突破红莲螺岩」(Tengen Toppa Gurren Lagann) 版本发布！这个小版本不包含任何破坏性变更，同时包括了内部改进和实用的新功能。&lt;/p&gt; 
&lt;p&gt;我们将在这篇博文中介绍一些亮点 - 如需完整的变更和新功能列表，请参阅 GitHub 上的完整更新日志。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fmain%2FCHANGELOG.md&quot; target=&quot;_blank&quot;&gt;https://github.com/vuejs/core/blob/main/CHANGELOG.md&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;响应式系统优化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;在 3.5 中，Vue 的响应式系统经历了又一次重大重构，实现了更好的性能和显著减少了内存占用 (-56%)，且没有行为变化。这次重构还解决了 SSR 过程中由于悬挂的计算属性导致的过时计算值和内存问题。&lt;/p&gt; 
&lt;p&gt;此外，3.5 还优化了对大型、深度响应式数组的响应式追踪，在某些情况下使此类操作的速度提高了多达 10 倍。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;响应式 Props 解构&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;响应式 Props 解构在 3.5 中已经稳定。该功能现在默认启用，在&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;/code&gt;中从&lt;code&gt;defineProps&lt;/code&gt;调用解构的变量现在是响应式的。值得注意的是，这个功能通过利用 JavaScript 的原生默认值语法，大大简化了声明带有默认值的 props：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Before&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;const props = withDefaults(
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;After&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;const { count = 0, msg = &#39;hello&#39; } = defineProps&amp;lt;{
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;访问解构变量 (例如&lt;code&gt;count&lt;/code&gt;) 时，编译器会自动将其编译为&lt;code&gt;props.count&lt;/code&gt;，因此它们在访问时会被追踪。与&lt;code&gt;props.count&lt;/code&gt;类似，如果要观察解构的 prop 变量或将其传递给组合式函数并保持响应性，需要将其包装在一个 getter 中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;watch(count /* ... */)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;对于那些更喜欢将解构的 props 与普通变量区分开来的人，&lt;code&gt;@vue/language-tools&lt;/code&gt;2.1 版本已经发布了一个可选设置，可以为它们启用内联提示：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-93abddfff7716aecdc2d8b1aba3cf26238a.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;详情：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;使用方法和注意事项请参阅文档。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;有关此功能的历史和设计理念，请参阅 RFC#502。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvuejs.org%2Fguide%2Fcomponents%2Fprops.html%23reactive-props-destructure&quot; target=&quot;_blank&quot;&gt;https://vuejs.org/guide/components/props.html#reactive-props-destructure&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Frfcs%2Fdiscussions%2F502&quot; target=&quot;_blank&quot;&gt;https://github.com/vuejs/rfcs/discussions/502&lt;/a&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;SSR 改进&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.5 为服务器端渲染 (SSR) 带来了一些期待已久的改进。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Lazy Hydration &amp;nbsp;懒加载水合&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;异步组件现在可以通过&lt;code&gt;defineAsyncComponent()&lt;/code&gt;API 的&lt;code&gt;hydrate&lt;/code&gt;选项来控制何时进行水合。例如，只在组件变为可见时才进行水合：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import { defineAsyncComponent, hydrateOnVisible } from &#39;vue&#39;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;核心 API 故意设计得比较底层，Nuxt 团队已经在这个功能之上构建了更高级的语法糖。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;code&gt;useId()&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;code&gt;useId()&lt;/code&gt;&amp;nbsp;是一个可以用来生成应用内唯一 ID 的 API，这些 ID 保证在服务器和客户端渲染之间保持稳定。它们可以用于生成表单元素和无障碍属性的 ID，并且可以在 SSR 应用中使用而不会导致水合不匹配：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;code&gt;data-allow-mismatch&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;在客户端值不可避免地与其服务器端对应值不同的情况下 (例如日期)，我们现在可以使用&lt;code&gt;data-allow-mismatch&lt;/code&gt;属性来抑制由此产生的水合不匹配警告：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;span data-allow-mismatch&amp;gt;{{ data.toLocaleString() }}&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;您还可以通过为该属性提供一个值来限制允许哪些类型的不匹配，可能的值包括&lt;code&gt;text&lt;/code&gt;、&lt;code&gt;children&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt;、&lt;code&gt;style&lt;/code&gt;和&lt;code&gt;attribute&lt;/code&gt;。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;自定义元素改进&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;3.5 修复了许多与&lt;code&gt;defineCustomElement()&lt;/code&gt;API 相关的长期存在的问题，并为使用 Vue 创建自定义元素添加了一些新功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;通过&lt;code&gt;configureApp&lt;/code&gt;选项支持自定义元素的应用配置。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;添加&lt;code&gt;useHost()&lt;/code&gt;、&lt;code&gt;useShadowRoot()&lt;/code&gt;和&lt;code&gt;this.$host&lt;/code&gt;API，用于访问自定义元素的宿主元素和影子根。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;通过传递&lt;code&gt;shadowRoot: false&lt;/code&gt;支持挂载不带影子 DOM 的自定义元素。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持提供&lt;code&gt;nonce&lt;/code&gt;选项，该选项将附加到自定义元素注入的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;标签上。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;这些新的仅用于自定义元素的选项可以通过第二个参数传递给&lt;code&gt;defineCustomElement&lt;/code&gt;：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import MyElement from &#39;./MyElement.ce.vue&#39;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;strong&gt;其他值得关注的特性&lt;/strong&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;code&gt;useTemplateRef()&lt;/code&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;3.5 引入了一种通过&lt;code&gt;useTemplateRef()&lt;/code&gt;API 获取模板引用的新方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在 3.5 之前，我们建议使用普通的 ref，其变量名与静态&lt;code&gt;ref&lt;/code&gt;属性匹配。旧方法要求&lt;code&gt;ref&lt;/code&gt;属性可以被编译器分析，因此仅限于静态&lt;code&gt;ref&lt;/code&gt;属性。相比之下，&lt;code&gt;useTemplateRef()&lt;/code&gt;通过运行时字符串 ID 匹配 ref，因此支持动态 ref 绑定到变化的 ID。&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;@vue/language-tools&lt;/code&gt;2.1 也为新语法实现了特殊支持，因此在使用&lt;code&gt;useTemplateRef()&lt;/code&gt;时，根据 ref 属性存在与否会有自动完成和警告出现：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-baa56f2b68546be7d60ee8af2ef856d524c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Deferred Teleport&amp;nbsp;&amp;nbsp;&lt;strong&gt;延迟传送门&lt;/strong&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;内置&lt;code&gt;&amp;lt;Teleport&amp;gt;&lt;/code&gt;组件的一个已知限制是，其目标元素必须在传送门组件挂载时存在。这阻止了用户将内容传送到 Vue 在传送门之后渲染的其他元素。&lt;/p&gt; 
&lt;p&gt;在 3.5 中，我们为&lt;code&gt;&amp;lt;Teleport&amp;gt;&lt;/code&gt;引入了一个 defer 属性，它会在当前渲染周期之后挂载传送门，所以现在这样做是可行的：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;Teleport defer to=&quot;#container&quot;&amp;gt;...&amp;lt;/Teleport&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;这种行为需要&lt;code&gt;defer&lt;/code&gt;属性,因为默认行为需要向后兼容。&lt;/p&gt; 
&lt;p&gt;有关 3.5 中变更和功能的完整列表，请查看 GitHub 上的完整更新日志。&lt;br&gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fmain%2FCHANGELOG.md&quot; target=&quot;_blank&quot;&gt;https://github.com/vuejs/core/blob/main/CHANGELOG.md&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310263/vue-3-5</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310263/vue-3-5</guid>
            <pubDate>Wed, 04 Sep 2024 02:43:44 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>Mozilla 发布 Firefox 130，推出自动画中画功能，增强多任务处理能力</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Mozilla 正式发布了 &lt;strong&gt;Firefox 130&lt;/strong&gt;，引入了一系列新功能，以提升用户体验。其中最引人注目的新增功能是&lt;strong&gt;自动画中画（Picture-in-Picture, PiP）模式&lt;/strong&gt;。该功能允许用户在切换标签页时，视频可以自动继续在一个单独的可调整大小的窗口中播放，使得用户在进行多任务处理时不会错过内容。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;自动画中画：无缝多任务处理&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;通过&lt;strong&gt;自动画中画&lt;/strong&gt;模式，Firefox 130 将媒体播放体验提升到了一个新水平。该功能的工作原理是：当用户离开正在播放视频的标签页时，画中画会自动激活。视频将弹出一个小窗口，用户可以在浏览其他标签页时继续观看视频。当用户返回原标签页时，画中画窗口会自动关闭，确保用户顺畅地回到原来的页面观看体验。这个新功能可以通过设置中的 &lt;strong&gt;Firefox Labs&lt;/strong&gt; 部分启用，Mozilla 允许用户在此测试即将推出的功能。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;720&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-37c33cb443f570a0aced7548efbcb172873.png&quot; width=&quot;1366&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Firefox 130 的其他重要增强功能&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;除了自动画中画功能之外，Firefox 130 还提供了其他多项改进：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;文本翻译&lt;/strong&gt;：用户现在可以直接在浏览器中翻译网页的特定文本。内置的翻译工具新增了对加泰罗尼亚语、克罗地亚语和越南语等语言的支持，进一步扩大了 Firefox 的全球覆盖范围。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Firefox Labs&lt;/strong&gt;：设置中新增的实验性功能区允许用户试用包括自动 PiP 和 AI 聊天机器人集成等实验功能。Mozilla 鼓励用户探索这些创新功能，以增强浏览体验。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;性能与安全修复&lt;/strong&gt;：Firefox 130 修复了多个安全漏洞并优化了性能，特别是改进了右键菜单中的复制粘贴功能。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Linux 版滚动动画&lt;/strong&gt;：Linux 用户将受益于默认启用的滚动动画，使得滚动浏览内容时的视觉体验更加顺畅和精致。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;多任务处理和媒体消费的进步&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Firefox 130 旨在为需要灵活处理媒体和多任务的用户提供现代化的浏览器体验。通过引入自动画中画、增强的文本翻译功能以及持续的性能更新，Mozilla 确保 Firefox 在竞争激烈的浏览器市场中保持竞争力。&lt;/p&gt; 
&lt;p&gt;用户可以直接从 Mozilla 官网下载 Firefox 130，或通过浏览器菜单更新现有版本。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310261/firefox-130-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310261/firefox-130-released</guid>
            <pubDate>Wed, 04 Sep 2024 02:39:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>2024 年，向量数据库「凉凉」了？</title>
            <description>《从零构建向量数据库》是市面上首本原创的「向量数据库」图书，因为封面上的主图是珊瑚得名而来。</description>
            <link>https://mp.weixin.qq.com/s/aa-bC7Hg_tEinVjJc2ipXA</link>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s/aa-bC7Hg_tEinVjJc2ipXA</guid>
            <pubDate>Wed, 04 Sep 2024 02:31:26 GMT</pubDate>
        </item>
        <item>
            <title>开源日报 | 女工程师开源 AI 模型对抗 deepfake；苹果回应 iPhone 16 不支持微信；Python 开发者调查；「天」系列工业软件</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;欢迎阅读 OSCHINA 编辑部出品的开源日报，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2024.9.3&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要闻&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F5666579547%2FOuXW94G8R&quot; target=&quot;_blank&quot;&gt;中科院女工程师开源 AI 模型对抗 deepfake：用 AI 打败 AI&lt;/a&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;近日「深度伪造」犯罪在韩国引起女性恐慌，中科院女工程师张欣怡（微博名「啦啦啦啦啦啦啦 0-0」）表示：&lt;/span&gt;&lt;br&gt; &lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;经团队同意，已将近期参加在上海举办的外滩大会 AI 创新赛·全球 Deepfake（深度伪造技术）攻防挑战赛的 AI 模型向全球开源，让所有有需要的人都可以免费使用模型来对抗 deepfake，希望通过技术手段，为每一个可能受到伤害的人提供保护。&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;后续还会尽快开发相关应用，降低大家的使用门槛。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ec7fa44426d2ac1d2734b706417228d7a67.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310110/making-a-3d-modeler-in-in-a-week&quot;&gt;C 语言，一周，写一个 3D 建模器&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#a1a1aa; text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;开发者 Daniel Hooper 在一周内使用 C 语言和 raylib 库完成了一个 3D 建模器项目 ShapeUp，代码行数：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul style=&quot;list-style-type:disc; margin-left:0; margin-right:0&quot;&gt; 
  &lt;li style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 行 C 代码&lt;/span&gt;&lt;/li&gt; 
  &lt;li style=&quot;text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;250 行 GLSL 代码&lt;/span&gt;&lt;/li&gt; 
  &lt;li style=&quot;text-align:start&quot;&gt; &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;总数 2274 行&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;Daniel Hooper 发布了一篇关于他在一周内使用 C 语言创建 3D 模型器 ShapeUp 的文章。ShapeUp 使用了 signed distance fields (SDFs) 和 ray marching 技术来快速实现 3D 渲染，这使得在短时间内从头开始创建 3D 项目成为可能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;898&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0903/104721_Xrho_3820517.png&quot; width=&quot;1362&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#d83931&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/310109&quot;&gt;WPS Office for Linux 12（个人版）正式上线&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;WPS Office for Linux 12 个人版现已在&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flinux.wps.cn%2F&quot; target=&quot;_blank&quot;&gt;WPS&amp;nbsp;Office 官网上线&lt;/a&gt;，迎来 UI 视觉重构升级，以及新增多项 AI 功能，具体版本号为&amp;nbsp;&lt;strong&gt;12.1.0.17881&lt;/strong&gt;。&lt;/p&gt; 
  &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8ca8e9ca03f572cdbf8d385808afd877a1f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.pingwest.com%2Fw%2F297982&quot; target=&quot;_blank&quot;&gt;苹果中国回应 iPhone 16 不支持微信：正与腾讯积极沟通应用商店抽成事宜&lt;/a&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;据贝壳财经报道，针对网传 iPhone 16 不支持微信这一传闻，苹果中国区技术顾问表示，目前苹果正在与腾讯积极沟通，来确认后续腾讯是否还会继续向苹果应用商店提供软件下载的抽成。 iPhone16 不支持微信的说法，苹果目前没有得到官方的通知。&lt;/p&gt; 
  &lt;p&gt;该顾问表示，微信作为一个比较大众的软件，双方也都会为了自己相应的效益做出一定处理，所以暂时不用担心。微信是客户非常常用的一个 APP，iPhone 新品不会把之前顾客正常使用的 APP 权限关闭剥夺。&lt;/p&gt; 
  &lt;p&gt;根据苹果的规定，APP 开发者在苹果应用商店上架软件，当软件达到一定下载量后，后续只要有用户下载一次这个软件，开发者就得向苹果支付一定费用。&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.pingwest.com%2Fw%2F298019&quot; target=&quot;_blank&quot;&gt;阶跃星辰上线图像生成大模型 Step-1X&lt;/a&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p&gt;阶跃星辰今天宣布，推出 step-1x 系列生图模型。该模型拥有强大的图像生成能力，支持文本描述作为输入方式。具备原生的中文支持，能够更好的理解和处理中文文本描述，并且能够更准确地捕捉文本描述中的语义信息，并将其转化为图像特征，从而实现更精准的图像生成。模型能够根据输入生成高分辨率、高质量的图像，并具备一定的风格迁移能力。&lt;/p&gt; 
   &lt;p&gt;需要注意的是，step-1x 系列模型限制了单次请求生成的图像数量，单次最多可请求生成 1 张图像。同时根据输入的复杂性和模型的计算能力，生成图像可能需要一些时间。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日观察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FmUoeQv6lrSX-M0w8LNqH7w&quot; target=&quot;_blank&quot;&gt;对谈硅基流动创始人袁进辉与独立开发者 idoubi&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;p&gt;AI 正在以前所未有的速度重塑各行各业, 而站在这场变革最前沿的, 莫过于 AI 工程师们。&lt;/p&gt; 
      &lt;p&gt;在这一期内容中, 从底层技术到应用开发, 从大公司到独立创业, 袁进辉和 idoubi 为我们全方位解析了 AI 工程师的现状与未来、机遇与挑战，以及如何在这个快速变化的领域保持竞争力。&lt;/p&gt; 
      &lt;p&gt;此外, 两位嘉宾还分享了他们对 AI 未来发展趋势的预测。他们认为, 尽管短期内 AI 工具类应用将迎来爆发, 但从长远来看, AI Native 应用才是未来的主流。无论你是已经身在 AI 行业, 还是正考虑转型成为 AI 工程师, 相信这期内容都会给你带来启发。&lt;/p&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
   &lt;p style=&quot;text-align:right&quot;&gt;&lt;span&gt;- 微信&amp;nbsp;&lt;strong&gt;十字路口 Crossing&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6306053186%2FOuwrcaeCj&quot; target=&quot;_blank&quot;&gt;开源中文字体有多了一种选择，还是字重可变&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt; 
       &lt;div&gt; 
        &lt;p&gt;微软更新为终端和编程设计的开源字体家族 Cascadia，新增了支持简繁中文和日文的 Cascadia Next。Cascadia Next 简体中文的字符集包含 ASCII、GB2312 以及大量网络常用汉字。&lt;/p&gt; 
        &lt;p&gt;该字体以 SIL 开源协议发布，可以在 Github 上下载 https://github.com/microsoft/cascadia-code/releases/tag/cascadia-next&lt;/p&gt; 
        &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-89425c442d9910d1774b52bb4ecd9d44d37.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;&lt;span&gt;美和园字社&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnew.qq.com%2Frain%2Fa%2F20240903A0148W00&quot; target=&quot;_blank&quot;&gt;Python 开发者调查：55% 使用 Linux，6% 仍在使用 Python 2&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt;
     尽管 Python 2 在 2020 年 4 月已经达到了「生命周期结束」的状态，但去年的调查发现仍有 7% 的受访者在使用 Python 2。今年的调查发现，这一数字终于下降了——但只是降到了 6%。
     &lt;br&gt; 调查结果指出：「几乎一半的 Python 2 坚持者年龄在 21 岁以下，三分之一是学生。也许课程仍在使用 Python 2？」
     &lt;br&gt; 与此同时，73% 的开发者正在使用 Python 的最后三个版本之一（3.10、3.11 或 3.12）。 &amp;nbsp; &amp;nbsp;
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;-&amp;nbsp;&lt;strong&gt;水哥&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F5198011111%2FOuwfq69S4%3Frefer_flag%3D1001030103_&quot; target=&quot;_blank&quot;&gt;免费开源的卡片工具&lt;/a&gt;&lt;/h4&gt; 
  &lt;div&gt; 
   &lt;p&gt;流光卡片：https://fireflycard.shushiai.com/&lt;/p&gt; 
   &lt;p&gt;一个免费开源的卡片工具，可以将文字、图片、代码等内容包装成精美的卡片，能直接下载或分享。&lt;/p&gt; 
   &lt;p&gt;它有 6 种不同的卡片模板和丰富的颜色主题可选，可自定义尺寸、边距和字体大小样式；还支持修改图标、日期、标题、作者、字数等内容，非常便捷。&lt;/p&gt; 
   &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-74895a77f4d8d13179fd121def90d4b1e83.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博 &lt;strong&gt;班叔&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒体观察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8cZMHUriY8V&quot; target=&quot;_blank&quot;&gt;独家对话生成式 AI 之父：中国将在几年内缩小差距&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p&gt;心智观察所：中国的生成式 AI 产业仍处于早期发展阶段，但成长迅速，并且中国推出了越来越多的大语言模型。您认为中国应该怎么做才能缩小与美国在 AI 加速器（用于训练和 AI 推理的 GPU）方面的差距？&lt;/p&gt; 
   &lt;p&gt;尤尔根·施密德胡贝尔：我认为中国已经在大力投资建设自己的自主可控的 AI 硬件，试图模仿目前只有荷兰的 ASML 能够做到的事情，因为美国政府在阻止 ASML 向中国交付其最新的芯片制造所需要的光刻机。&lt;/p&gt; 
   &lt;p&gt;总体而言，历史证明，一个主要大国在技术上追赶另一个大国可能只需要几年时间。例如，德国在 1938 年发现了核裂变（原子弹的原理），仅仅 7 年后，美国就拥有了可用的核武器。而再过 4 年，苏联也有了核武器。到如今，许多国家都拥有核武器。值得注意的是，中国目前在人工智能领域发表的论文和获得的专利数量超过了其他任何国家。如果中国在未来几年内没有缩小硬件差距，我会对此感到十分惊讶。&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;-&amp;nbsp;&lt;strong&gt;观察者网&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gkong.com%2Fnews%2F118288.html&quot; target=&quot;_blank&quot;&gt;航天领域公布 12 款「天」系列工业软件&lt;/a&gt;&lt;/h4&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;p&gt;从 8 月 31 日举办的第二届「领航杯」工业软件科技创新设计大赛决赛上获悉，我国 12 款「天」系列工业软件和航天领域首款智慧物联操作系统——「天鸿」操作系统成功发布。&lt;/p&gt; 
     &lt;p&gt;工业软件作为关键软件的核心组成，已经成为型号研制必不可少的工具手段。「天」系列工业软件是中国航天科技集团有限公司第一研究院第一设计部（以下简称「第一设计部」）基于丰富的航天系统工程研制经验，结合通用型号研发设计需求，围绕专业特色设计、通用工程仿真和数字主线贯通三个方向孵化的软件产品，也是第一设计部首次将自研自用工具作为数字产品对外推广，并依托工业软件搭建了「产、学、研、用」的生态平台，在满足型号研制需求的基础上，推动软件的产品化，催生数字化产业，打造数字化能力输出的新窗口。&lt;/p&gt; 
     &lt;p&gt;「天鸿」操作系统，是北京航天万源科技有限公司专为航天应用场景打造的操作系统，可实现航天领域万物互联智能协作，推动航天装备的协同能力迈向新高度，其技术底座源自开源鸿蒙。&lt;/p&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;光明日报&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6105753431%2FOv5XjjLOL&quot; target=&quot;_blank&quot;&gt;开源提示词让 LLM 更具创造力&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;GitHub 上开源了一个提示词，用户只需将这些提示词输入 LLM，就能解锁 LLM 的「思维发散」模式，让 LLM 提出更多新颖的想法，当你做需要做创作力的任务时，尤为好用。&lt;/p&gt; 
 &lt;p&gt;这就是 Rohan Paul 花费好几个月制作的「SuperPrompt」项目，如果你看不懂提示词也没关系，其本质就是使用&#39;&amp;lt;&amp;gt;&#39;标签，定义了 LLM 的一系列行为，包括其想法、动作、内核、分析、验证等过程。&lt;/p&gt; 
 &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;量子位&lt;/strong&gt;&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推荐&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://my.oschina.net/u/2340880/blog/15616643&quot; target=&quot;news&quot;&gt;UIInteraction：iOS 中强大的视图交互能力&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;UIInteraction 是 iOS 开发框架中提供的一个协议，此协议可以为视图增加非常强大的交互能力，例如进行文字的识别和提取，图片的分析、物理按键的拍摄处理等等。本章将总结目前系统提供的遵守了 UIInteraction 协议的交互类，介绍这些系统交互的使用方法，希望可以对你有所启发，将这些能力应用到具体的业务场景中去。&lt;/p&gt; 
 &lt;hr&gt; 
 &lt;div&gt; 
  &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;开源之声&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户观点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fb8vfN98LeG3FBjgleQJfZQ&quot; target=&quot;_blank&quot;&gt;FreeBSD 社区正在为是否「锈化」而激辩&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：你说得对，但是 Rust 是由 Mozilla 自主研发的一款全新内存安全编程语言。编译将发生在一个被称作「卡尔构」的构建系统，在这里，被引用的指针将被授予「生命周期」，导引安全之力。你将扮演一位名为「开发者」的神秘角色在编程的搏斗中邂逅骨骼惊奇的报错，绕开它们通过编译同时，逐步发掘「Rust」的真相。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：直觉告诉我，现在如火如荼的锈化旨在解决 rust 程序员就业问题，除此之外折腾来折腾去没有实际意义的事情&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：对于内核编写而言，C 已经足够好，而不需要更好的 Rust 语言，但是对于应用编写而言，Rust 相比其他更加容易上手的语言又不够好&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FY_YLr06PnGgB9yAdY3Uffg&quot; target=&quot;_blank&quot;&gt;「微信、iPhone 二选一？」——多年前的代码已经给出了答案&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 1：「关于推广大众消费领域智能手机所搭载操作系统的若干意见」&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 2：苹果不会放弃微信的，毕竟装了微信 256GB 的 iPhone 才能卖得出去&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;观点 3：都是些软蛋，瞅瞅欧盟&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/blockquote&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;最后，欢迎扫码下载「开源中国 APP」，阅读海量技术报告、程序员极客分享！&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d27cc3636c021c266537f4729dc0f84fdc3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310215</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310215</guid>
            <pubDate>Tue, 03 Sep 2024 13:15:15 GMT</pubDate>
            <author>来源: OSCHINA</author>
        </item>
        <item>
            <title>UIInteraction：iOS 中强大的视图交互能力</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;h1&gt;UIInteraction：iOS 中强大的视图交互能力&lt;/h1&gt; 
&lt;p&gt;UIInteraction 是 iOS 开发框架中提供的一个协议，此协议可以为视图增加非常强大的交互能力，例如进行文字的识别和提取，图片的分析、物理按键的拍摄处理等等。本章将总结目前系统提供的遵守了 UIInteraction 协议的交互类，介绍这些系统交互的使用方法，希望可以对你有所启发，将这些能力应用到具体的业务场景中去。&lt;/p&gt; 
&lt;h2&gt;概览&lt;/h2&gt; 
&lt;p&gt;AVCaptureEventInteraction：相机拍照事件捕获交互（物理按键）。&lt;/p&gt; 
&lt;p&gt;ImageAnalysisInteraction：为图片添加识别文本，条形码和其他对象的交互。&lt;/p&gt; 
&lt;p&gt;UIContextMenuInteraction：显示与用户关注点内容相关的菜单交互，例如进行长按时弹出交互菜单。&lt;/p&gt; 
&lt;p&gt;UIEditMenuInteraction：编辑类菜单交互，主要用在文本输入类的组件上。&lt;/p&gt; 
&lt;p&gt;UIFindInteraction：进行文本查找与替换的交互。&lt;/p&gt; 
&lt;p&gt;UILargeContentViewerInteraction：大内容查看交互，例如将某个小组件进行方法查看。&lt;/p&gt; 
&lt;p&gt;UIFeedbackGenerator：用户交互反击的生成器类，用来统一的处理用户的交互返回（各种震动效果），后续详细介绍。&lt;/p&gt; 
&lt;p&gt;UIDragInteraction：对组件进行拖拽交互，是可以支持跨应用的。&lt;/p&gt; 
&lt;p&gt;UIDropInteraction：将组件拖拽放置的交互，是可以支持跨应用的。&lt;/p&gt; 
&lt;p&gt;UITextInteraction：对自定义的文本组件提供原生体验一致的手势交互，如文本选择。&lt;/p&gt; 
&lt;p&gt;UITextSelectionDisplayInteraction：选中文本展示的 UI 交互。&lt;/p&gt; 
&lt;p&gt;UISpringLoadedInteraction：拖拽时提供动态导航交互，简单说就是当拖转组件到一个元素时，可以动态的触发元素的点击跳转。&lt;/p&gt; 
&lt;p&gt;UIBandSelectionInteraction：跟踪指针位置选中项目的交互，在有鼠标或其他指针的场景中需要用到此种交互，本文不做探讨。&lt;/p&gt; 
&lt;p&gt;UIToolTipInteraction：指针悬停在组件上展示提示 UI 的交互，本文不做讨论。&lt;/p&gt; 
&lt;p&gt;UIPencilInteraction：Apple Pencil 的交互，某些型号的笔可以进行挤压和双击交互，本文不做讨论。&lt;/p&gt; 
&lt;p&gt;UIIndirectScribbleInteraction：非常规的输入类视图的用户交互，主要是手写跟踪，本文不做讨论。&lt;/p&gt; 
&lt;p&gt;UIPointerInteraction：定义鼠标指针外观的交互，本文不做讨论。&lt;/p&gt; 
&lt;p&gt;UIScribbleInteraction：提供涂写交互能力，本文不做讨论。&lt;/p&gt; 
&lt;p&gt;GCEventInteraction：GameController 交互，涉及到 GameController 框架，这里不做讨论。&lt;/p&gt; 
&lt;p&gt;BETextInteraction：浏览器文本视图相关交互，涉及到 BrowserEngineKit 框架，iOS17.4 之后支持三方开发浏览器软件，这不再本篇文章的讨论范围&lt;/p&gt; 
&lt;p&gt;上面所列举出的类都是遵守了 UIInteraction 类，并提供了相关交互能力。本篇文章主要介绍其中与 iPhone 设备上应用体验相关的交互，对 Vision 设备，iPad 和 Mac 等可以手写和处理指针的交互不做过多的讨论。下面我们会逐一对这些交互能力的使用进行介绍。&lt;/p&gt; 
&lt;h2&gt;AVCaptureEventInteraction 相机拍照事件捕获交互&lt;/h2&gt; 
&lt;p&gt;在 iPhone 设备上，系统的相机有一个非常好用的功能，即可以通过按下任意的音量键来执行拍照动作，这也是自拍杆之所以无需点击虚拟拍照按钮就可以控制系统相机拍照的原因。AVCaptureEventInteraction 提供了交互接口，可以让用户在自己的应用中实现这一功能。首先 AVCaptureEventInteraction 提供的本质上是物理按键的监听能力，因此必须要求在应用捕获摄像头的视频流时才能使用。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;非常重要：AVCaptureEventInteraction 的相关 API 只能用在相机捕获实时影像的场景中，只有当摄像头正在使用时系统才会正常的发送硬件事件，在后台的应用以及没有使用摄像头的应用都无法接收到这个事件。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;示例代码：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;import UIKit
import AVKit

class ViewController: UIViewController, AVCaptureVideoDataOutputSampleBufferDelegate {

    /// A capture event interaction to handle hardware button presses.
    private var eventInteraction: AVCaptureEventInteraction!
    
    
    var captureSession: AVCaptureSession!
    var videoPreviewLayer: AVCaptureVideoPreviewLayer!
     
    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .white
        // Configure the app to take a photo on hardware button press.
        configureHardwareInteraction()
        // 设置相机会话
        captureSession = AVCaptureSession()
        captureSession.beginConfiguration()
        captureSession.sessionPreset = .high
 
        guard let videoDevice = AVCaptureDevice.default(for: .video) else { return }
        guard let videoInput = try? AVCaptureDeviceInput(device: videoDevice) else { return }
 
        if captureSession.canAddInput(videoInput) {
            captureSession.addInput(videoInput)
        }
 
        let videoOutput = AVCaptureVideoDataOutput()
        videoOutput.setSampleBufferDelegate(self, queue: DispatchQueue(label: &quot;videoQueue&quot;))
        if captureSession.canAddOutput(videoOutput) {
            captureSession.addOutput(videoOutput)
        }
 
        captureSession.commitConfiguration()
        captureSession.startRunning()
 
        // 创建视频预览层
        videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession)
        videoPreviewLayer.frame = view.bounds
        view.layer.addSublayer(videoPreviewLayer)
    }
 
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        videoPreviewLayer.frame = view.bounds
    }
    
    private func configureHardwareInteraction() {
        // 处理硬件事件触发逻辑的逻辑
        // 可以读取当前的视频流进行拍摄
        eventInteraction = AVCaptureEventInteraction { event in
            print(&quot;事件阶段状态 - &quot;, event.phase)
        } secondary: { event in
            print(&quot;事件阶段状态 - &quot;, event.phase)
        }
        eventInteraction.isEnabled = true
        view.addInteraction(eventInteraction)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;nbsp;AVCaptureEventInteraction 类的定义本身非常简单：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 17.2, *)
open class AVCaptureEventInteraction : NSObject, UIInteraction {
    // 初始化方法，注册一个事件回调
    public init(handler: @escaping (AVCaptureEvent) -&amp;gt; Void)
    // 初始化方法，注册一个事件回调，回调中的两个参数分别对应音量上和下两个按钮的点击
    public init(primary primaryHandler: @escaping (AVCaptureEvent) -&amp;gt; Void, secondary secondaryHandler: @escaping (AVCaptureEvent) -&amp;gt; Void)
    // 设置此交互行为是否生效
    open var isEnabled: Bool
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其回调中的 AVCaptureEvent 会标识事件的状态：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 17.2, *)
open class AVCaptureEvent : NSObject {
    // 事件的状态
    open var phase: AVCaptureEventPhase { get }
}

@available(iOS 17.2, *)
public enum AVCaptureEventPhase : UInt, @unchecked Sendable {
    // 点击开始
    case began = 0
    // 点击结束
    case ended = 1
    // 事件取消
    case cancelled = 2
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;需要注意，所有的 AVCaptureEventInteraction 接口都在 iOS17.2 之后可用。&lt;/p&gt; 
&lt;h2&gt;ImageAnalysisInteraction 图片识别交互&lt;/h2&gt; 
&lt;p&gt;图片中往往包含了许多标准化的信息，如文本信息，二维码信息等。在使用 iOS 系统的图库软件时，用户可以直接长按图片来提取图片中的信息，如进行文本的复制，二维码的识别等。ImageAnalysisInteraction 类即可提供这种交互能力。&lt;/p&gt; 
&lt;p&gt;ImageAnalysisInteraction 交互有很多应用场景，可以复制图片中的文本，可以快捷拨打电话、翻译、识别链接和二维码等。ImageAnalysisInteraction 是基于 VersionKit 框架实现的，VersionKit 是 Apple 提供的一套与视觉处理相关功能的框架。&lt;/p&gt; 
&lt;p&gt;需要注意，ImageAnalysisInteraction 本身只是提供了一套识别后的用户交互，具体的分析任务是由 ImageAnalyzer 类实现的。ImageAnalyzer 只能在 A12 及以上的芯片设备上使用，因此在使用此功能前，需要先做下可用性判断。&lt;/p&gt; 
&lt;p&gt;ImageAnalysisInteraction 的交互官网示例图如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-70723799539872d29f6cf73c33367d017a0.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;当 ImageAnalyzer 对图片分析完成后，可以将结果传递给 ImageAnalysisInteraction，此时 UIImageView 的组件的右下角会显示一个扫描样式的图标，单击此图标即可查看分析的结果，图片中会将识别出的元素区域进行高亮，并支持用户操作。&lt;/p&gt; 
&lt;p&gt;示例代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;import VisionKit
class ViewController: UIViewController, ImageAnalysisInteractionDelegate {
    
    let interaction = ImageAnalysisInteraction()
    let imageDataAnalyzer = ImageAnalyzer()
    let imageView = UIImageView(image: UIImage(named: &quot;img&quot;))
    
    override func viewDidLoad() {
        super.viewDidLoad()
        imageView.contentMode = .scaleAspectFit
        view.addSubview(imageView)
        imageView.frame = view.bounds
        if ImageAnalyzer.isSupported {
            imageView.addInteraction(interaction)
            interaction.delegate = self
            // 设置预期接收的交互
            interaction.preferredInteractionTypes = [.automatic]
            Task {
                // 配置 configuration 对象
                let configuration = ImageAnalyzer.Configuration([.text, .machineReadableCode])
                do {
                    // 开始执行分析
                    let analysis = try await imageDataAnalyzer.analyze(imageView.image!, configuration: configuration)
                    // 分析信息结果接收
                    interaction.analysis = analysis
                } catch {
                 // 处理异常
                }
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;找一测试图片进行识别，效果如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-e88a623f3ae3fc9192c6934dafb91271751.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下面，我们再来详细解析下 ImageAnalysisInteraction 接口的功能，ImageAnalyzer 的识别能力本身，这里就不再赘述，&lt;/p&gt; 
&lt;p&gt;ImageAnalysisInteraction 交互可以直接添加在 UIImageView 上，如果我们不使用 UIImageView 组件来展示图片，也可以手动设置图片渲染的区域，ImageAnalysisInteraction 会将交互内容映射到对应组件的正确位置上。&lt;/p&gt; 
&lt;p&gt;ImageAnalysisInteraction 类中的核心属性和方法如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, macCatalyst 17.0, *)
@MainActor @objc final public class ImageAnalysisInteraction : NSObject, UIInteraction {
    // 设置代理
    @MainActor weak final public var delegate: (any ImageAnalysisInteractionDelegate)?
    // 图片分析的结果，分析完成后对此属性进行赋值
    @MainActor final public var analysis: ImageAnalysis?
    // 设置期望支持的交互的类型
    @MainActor final public var preferredInteractionTypes: ImageAnalysisInteraction.InteractionTypes
    // 目前所激活的交互类型
    @MainActor final public var activeInteractionTypes: ImageAnalysisInteraction.InteractionTypes { get }
    // 可选择的元素是否高亮，内部会自己管理此属性的值
    @MainActor final public var selectableItemsHighlighted: Bool
    // 是否有激活被选中的文本
    @MainActor final public var hasActiveTextSelection: Bool { get }
    // 清空所有选中的文本
    @MainActor final public func resetTextSelection()
    // 图片中的文本
    @MainActor final public var text: String { get }
    // 被选中的文本
    @MainActor final public var selectedText: String { get }
    // 选中的文本的 attribute 属性
    @MainActor final public var selectedAttributedText: AttributedString { get }
    // 选中的文本的范围
    @MainActor final public var selectedRanges: [Range&amp;lt;String.Index&amp;gt;]
    // 当不使用 UIImageView 来展示图片时，图片的渲染区域如果有修改，需要调用此方法通知交互层来对应的更新
    @MainActor final public func setContentsRectNeedsUpdate()
    // 单位空间内的描述交互区域的矩形
    @MainActor final public var contentsRect: CGRect { get }
    // 视图的某个位置是否有可交互元素
    @MainActor final public func hasInteractiveItem(at point: CGPoint) -&amp;gt; Bool
    // 视图的某个位置是否有文本
    @MainActor final public func hasText(at point: CGPoint) -&amp;gt; Bool
    // 视图的某个位置是否有检测到数据
    @MainActor final public func hasDataDetector(at point: CGPoint) -&amp;gt; Bool
    // 实时文本按钮是否可见，右下角的按钮
    @MainActor final public var liveTextButtonVisible: Bool { get }
    // 识别出的所有主题的集合
    @MainActor final public var subjects: Set&amp;lt;ImageAnalysisInteraction.Subject&amp;gt; { get async }
    // 高亮的主题集合
    @MainActor final public var highlightedSubjects: Set&amp;lt;ImageAnalysisInteraction.Subject&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;通过 InteractionTypes 可以设置预期支持的交互类型以及可以获取到最终识别出的交互类型，此类型定义如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;public struct InteractionTypes : OptionSet {
    // 自动，支持任意类型
    public static let automatic: ImageAnalysisInteraction.InteractionTypes
    // 文本类的所有类型
    public static let automaticTextOnly: ImageAnalysisInteraction.InteractionTypes
    // 文本选择类，包括选中，拷贝和翻译
    public static let textSelection: ImageAnalysisInteraction.InteractionTypes
    // 数据类，包括链接，邮箱，地址
    public static let dataDetectors: ImageAnalysisInteraction.InteractionTypes
    // 图片主题类，包括抠图等
    public static let imageSubject: ImageAnalysisInteraction.InteractionTypes
    // 支持更多的图片选项，如图片的分类
    public static let visualLookUp: ImageAnalysisInteraction.InteractionTypes
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;开发者也可以参与到交互的流程中，通过 ImageAnalysisInteractionDelegate 协议可以更精细化的控制交互行为:&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, macCatalyst 17.0, *)
public protocol ImageAnalysisInteractionDelegate : AnyObject {
    // 返回一个布尔值，可以控制某个位置是否允许交互
    func interaction(_ interaction: ImageAnalysisInteraction, shouldBeginAt point: CGPoint, for interactionType: ImageAnalysisInteraction.InteractionTypes) -&amp;gt; Bool
    // 对于非 UIImageView 的组件，此代理可以返回一个渲染区域，用来告诉交互层要渲染的位置
    func contentsRect(for interaction: ImageAnalysisInteraction) -&amp;gt; CGRect
    // 自定义设置用来渲染图片的视图
    func contentView(for interaction: ImageAnalysisInteraction) -&amp;gt; UIView?
    // 设置一个视图控制器用来承接可交互元素的弹出跳转，默认为 Window 的根视图
    func presentingViewController(for interaction: ImageAnalysisInteraction) -&amp;gt; UIViewController?
    // 当实时文本的可见性变化时会回调
    func interaction(_ interaction: ImageAnalysisInteraction, liveTextButtonDidChangeToVisible visible: Bool)
    // 选中的高亮元素变化时回调
    func interaction(_ interaction: ImageAnalysisInteraction, highlightSelectedItemsDidChange highlightSelectedItems: Bool)
    // 选中的文本变化时回调
    func textSelectionDidChange(_ interaction: ImageAnalysisInteraction)
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;UIContextMenuInteraction 上下文菜单交互&lt;/h2&gt; 
&lt;p&gt;当我们在系统的浏览器中对某个链接触发 3D Touch 或长按操作时，可以看到会在当前页面弹出一个浮层，浮层会对超链接进行预览展示，并提供一些操作菜单项。这其实就是 UIContextMenuInteraction 提供的交互能力。&lt;/p&gt; 
&lt;p&gt;UIContextMenuInteraction 可以为某个可交互控件提供浮层预览和菜单能力。&lt;/p&gt; 
&lt;p&gt;先来看一个示例：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class ViewController: UIViewController, UIContextMenuInteractionDelegate {
    func contextMenuInteraction(_ interaction: UIContextMenuInteraction, configurationForMenuAtLocation location: CGPoint) -&amp;gt; UIContextMenuConfiguration? {
        return .init(identifier: nil) {
            // 设置预览控制器，返回空则不展示额外的预览
            nil
        } actionProvider: { elements in
            // 设置菜单项
            let favoriteAction = UIAction(title: &quot;喜欢&quot;, image: UIImage(systemName: &quot;heart.fill&quot;), state: .off) { (action) in
                }
            let shareAction = UIAction(title: &quot;分享&quot;, image: UIImage(systemName: &quot;square.and.arrow.up.fill&quot;), state: .off) { (action) in
                
            }
            let deleteAction = UIAction(title: &quot;删除&quot;, image: UIImage(systemName: &quot;trash.fill&quot;),
                                        attributes: [.destructive], state: .on) { (action) in
                
            }
            return UIMenu(title: &quot;菜单&quot;, children: [favoriteAction, shareAction, deleteAction])
        }
    }
    
    
    let imageView = UIImageView(image: UIImage(named: &quot;img&quot;))
    
    override func viewDidLoad() {
        super.viewDidLoad()
        imageView.isUserInteractionEnabled = true
        imageView.contentMode = .scaleAspectFill
        view.addSubview(imageView)
        imageView.frame = CGRect(x: view.frame.width / 2 - 150, y: view.frame.height / 2 - 150, width: 300.0, height: 300.0)
        let interaction = UIContextMenuInteraction(delegate: self)
        // 为图片控件添加 UIContextMenuInteraction 交互
        imageView.addInteraction(interaction)
    }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;运行代码效果如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-71f5661070fe1d816cbef1762732bcac944.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在代码配置中，并没有设置预览控制器，因此其触发 UIContextMenuInteraction 交互时，会将原组件进行高亮，并将其他背景进行模糊。需要注意，UIContextMenuInteraction 交互需要在 iOS13 及以上系统重使用。UIContextMenuInteraction 本身比较简单，定义如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 13.0, *)
@MainActor open class UIContextMenuInteraction : NSObject, UIInteraction {
    // 代理
    weak open var delegate: (any UIContextMenuInteractionDelegate)? { get }
    // 菜单当前是否正在展示
    @available(iOS 14.0, *)
    open var menuAppearance: UIContextMenuInteraction.appearance { get }
    // 初始化方法
    public init(delegate: any UIContextMenuInteractionDelegate)
    // 这是一个抽象方法，子类可以重写，从而控制菜单弹出的位置
    open func location(in view: UIView?) -&amp;gt; CGPoint
    // 这是一个抽象方法，更新菜单可见性时会调用
    @available(iOS 14.0, *)
    open func updateVisibleMenu(_ block: (UIMenu) -&amp;gt; UIMenu)
    // 将当前已经显示的菜单隐藏掉
    open func dismissMenu()
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体弹出的预览视图和菜单项，需要在代理方法中进行设置，UIContextMenuInteractionDelegate 中定义的方法如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 13.0, *)
@MainActor public protocol UIContextMenuInteractionDelegate : NSObjectProtocol {
    // 配置菜单和预览项，UIContextMenuConfiguration 后面介绍
    func contextMenuInteraction(_ interaction: UIContextMenuInteraction, configurationForMenuAtLocation location: CGPoint) -&amp;gt; UIContextMenuConfiguration?
    @available(iOS 16.0, *)
    // 上下文交互开始时回调
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, highlightPreviewForItemWithIdentifier identifier: any NSCopying) -&amp;gt; UITargetedPreview?
    // 上下文交互消失时回调
    @available(iOS 16.0, *)
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, dismissalPreviewForItemWithIdentifier identifier: any NSCopying) -&amp;gt; UITargetedPreview?
    // 预览操作开始时回调
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, willPerformPreviewActionForMenuWith configuration: UIContextMenuConfiguration, animator: any UIContextMenuInteractionCommitAnimating)
    // 菜单开始显示时回调
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, willDisplayMenuFor configuration: UIContextMenuConfiguration, animator: (any UIContextMenuInteractionAnimating)?)
    // 交互结束时回调
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, willEndFor configuration: UIContextMenuConfiguration, animator: (any UIContextMenuInteractionAnimating)?)
    // 配置菜单高亮时使用的预览视图
    @available(iOS, introduced: 13.0, deprecated: 16.0)
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, previewForHighlightingMenuWithConfiguration configuration: UIContextMenuConfiguration) -&amp;gt; UITargetedPreview?
    // 配置菜单隐藏时使用的预览视图
    @available(iOS, introduced: 13.0, deprecated: 16.0)
    optional func contextMenuInteraction(_ interaction: UIContextMenuInteraction, previewForDismissingMenuWithConfiguration configuration: UIContextMenuConfiguration) -&amp;gt; UITargetedPreview?
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其中 UIContextMenuConfiguration 类用来做具体的交互配置，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 13.0, *)
@MainActor open class UIContextMenuConfiguration : NSObject {
    // 唯一标识
    open var identifier: any NSCopying { get }
    // 一组标识符，标识每个副项
    @available(iOS 16.0, *)
    open var secondaryItemIdentifiers: Set&amp;lt;AnyHashable&amp;gt;
    // 徽章数
    @available(iOS 16.0, *)
    open var badgeCount: Int
    // 排序
    @available(iOS 16.0, *)
    open var preferredMenuElementOrder: UIContextMenuConfiguration.ElementOrder
}

@available(iOS 13.0, tvOS 17.0, *)
extension UIContextMenuConfiguration {
    // 初始化方法，配置预览视图与一组菜单项
    @MainActor public convenience init(identifier: (any NSCopying)? = nil, previewProvider: UIContextMenuContentPreviewProvider? = nil, actionProvider: UIContextMenuActionProvider? = nil)
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;UIEditMenuInteraction 编辑类菜单交互&lt;/h2&gt; 
&lt;p&gt;UIEditMenuInteraction 是对 UIMenuController 的一种代替，UIEditMenuInteraction 的整体设计架构更加合理，使用也更加直观简单。默认 UITextView 与 UITextField 已经集成了 UIEditMenuInteraction 交互。UIEditMenuInteraction 交互用来提供诸如剪切、拷贝、粘贴等编辑选项。&lt;/p&gt; 
&lt;p&gt;示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class ViewController: UIViewController, UIEditMenuInteractionDelegate {
    
    func editMenuInteraction(_ interaction: UIEditMenuInteraction, menuFor configuration: UIEditMenuConfiguration, suggestedActions: [UIMenuElement]) -&amp;gt; UIMenu? {
        // 进行菜单项的配置
        let favorite = UIAction(title: &quot;Favorite&quot;) { _ in
            print(&quot;favorite&quot;)
        }
        let share = UIAction(title: &quot;Share&quot;) { _ in
            print(&quot;share&quot;)
        }
        let delete = UIAction(title: &quot;Delete&quot;, attributes: [.destructive]) { _ in
            print(&quot;delete&quot;)
        }
        return UIMenu(children: [favorite, share, delete])
    }
    
    let imageView = UIImageView(image: UIImage(named: &quot;img&quot;))
    var interaction: UIEditMenuInteraction!
    override func viewDidLoad() {
        super.viewDidLoad()
        interaction = UIEditMenuInteraction(delegate: self)
        imageView.isUserInteractionEnabled = true
        imageView.layer.masksToBounds = true
        imageView.contentMode = .scaleAspectFill
        view.addSubview(imageView)
        imageView.frame = CGRect(x: view.frame.width / 2 - 150, y: view.frame.height / 2 - 150, width: 300.0, height: 300.0)
        // 为图片控件添加 UIEditMenuInteraction 交互
        imageView.addInteraction(interaction)
        let longPress = UILongPressGestureRecognizer(target: self, action: #selector(didLongPress(_:)))
        imageView.addGestureRecognizer(longPress)
    }
    
    @objc func didLongPress(_ recognizer: UIGestureRecognizer) {
        let location = recognizer.location(in: imageView)
        let configuration = UIEditMenuConfiguration(identifier: nil, sourcePoint: location)
        // 使用交互对象弹出菜单
        interaction.presentEditMenu(with: configuration)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面代码中，对 UIImageView 视图添加了一个长按手势，手势触发时，弹出编辑菜单。效果如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-eb33ad55714e3e6798125142a5ae30c5662.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;UIEditMenuInteraction 类解析如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, *)
@MainActor open class UIEditMenuInteraction : NSObject, UIInteraction {
    // 初始化方法，设置代理
    public init(delegate: (any UIEditMenuInteractionDelegate)?)
    // 弹出编辑菜单
    open func presentEditMenu(with configuration: UIEditMenuConfiguration)
    // 隐藏菜单
    open func dismissMenu()
    // 刷新可见的菜单
    open func reloadVisibleMenu()
    // 刷新可见菜单位置，可以带动画
    open func updateVisibleMenuPosition(animated: Bool)
    // 获取交互点的座标
    open func location(in view: UIView?) -&amp;gt; CGPoint
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;UIEditMenuInteractionDelegate 代理对菜单的数据源进行提供，并有生命周期的相关回调：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, *)
public protocol UIEditMenuInteractionDelegate : NSObjectProtocol {
    // 配置菜单
    optional func editMenuInteraction(_ interaction: UIEditMenuInteraction, menuFor configuration: UIEditMenuConfiguration, suggestedActions: [UIMenuElement]) -&amp;gt; UIMenu?
    // 配置菜单展示的位置
    optional func editMenuInteraction(_ interaction: UIEditMenuInteraction, targetRectFor configuration: UIEditMenuConfiguration) -&amp;gt; CGRect
    // 交互即将弹出菜单时的回调
    optional func editMenuInteraction(_ interaction: UIEditMenuInteraction, willPresentMenuFor configuration: UIEditMenuConfiguration, animator: any UIEditMenuInteractionAnimating)
    // 交互即将隐藏菜单时的回调
    optional func editMenuInteraction(_ interaction: UIEditMenuInteraction, willDismissMenuFor configuration: UIEditMenuConfiguration, animator: any UIEditMenuInteractionAnimating)
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;UIFindInteraction 文本查找替换交互&lt;/h2&gt; 
&lt;p&gt;UIFindInteraction 顾名思义，用来进行查找相关的交互，其提供了一个系统的查找面板，可以在文本展示类控件中进行文本的查找或替换操作。默认系统的 UITextView，WKWebView 与 PDFView 都集成了此交互，只需要将其 isFindInteractionEnabled 属性设置为 true 即可。另外，对于完全自定义的文本渲染类组件，如果要实现此交互，则需要手动实现一个文本查找的协议，这里我们只看下如何使用系统提供的这些类来实现 UIFindInteraction 交互。&lt;/p&gt; 
&lt;p&gt;示例代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class ViewController: UIViewController {
    lazy var textView: UITextView = {
        let textView = UITextView(frame: CGRect(x: 0, y: 200, width: view.bounds.width, height: 600))
        textView.text = &quot;&quot;&quot;
        UIInteraction 是 iOS 开发框架中提供的一个协议，此协议可以为视图增加非常强大的交互能力，例如进行文字的识别和提取，图片的分析、物理按键的拍摄处理等等。本章将总结目前系统提供的遵守了 UIInteraction 协议的交互类，介绍这些系统交互的使用方法，希望可以对你有所启发，将这些能力应用到具体的业务场景中去。
        &quot;&quot;&quot;
        textView.center = view.center
        // 打开 UIFindInteraction
        textView.isFindInteractionEnabled = true
        // 添加长按手势
        let longPress = UILongPressGestureRecognizer(target: self, action: #selector(didLongPress))
        textView.addGestureRecognizer(longPress)
        return textView
    }()

    override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(textView)
    }

    // MARK: 长按手势响应事件
    @objc func didLongPress(_ recognizer: UIGestureRecognizer) {
        // 弹出查找和替换面板，会弹出键盘
        textView.findInteraction?.presentFindNavigator(showingReplace: true)
    }

    override func touchesBegan(_ touches: Set&amp;lt;UITouch&amp;gt;, with event: UIEvent?) {
        // 退出面板
        textView.findInteraction?.dismissFindNavigator()
    }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;运行代码，在文本区域长按，效果如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d2e3457f23b3375d56b8c87391eacab9345.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;如果进行文本替换，会直接对 UITextView 中的内容进行修改。UIFindInteraction 相对复杂，其中常用属性方法列举如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, *)
@MainActor open class UIFindInteraction : NSObject, UIInteraction {
    // 查找的交互 UI 是否可见
    open var isFindNavigatorVisible: Bool { get }
    // 当前激活的 UIFindSession，UIFindSession 具体用来进行管理查找功能
    open var activeFindSession: UIFindSession? { get }
    // 要查找的文本
    open var searchText: String?
    // 替换为的文本
    open var replacementText: String?
    // 可选的菜单
    open var optionsMenuProvider: (([UIMenuElement]) -&amp;gt; UIMenu?)?
    // 代理与初始化方法
    weak open var delegate: (any UIFindInteractionDelegate)? { get }
    public init(sessionDelegate: any UIFindInteractionDelegate)
    // 弹出查找面板，可选是否支持替换
    open func presentFindNavigator(showingReplace: Bool)
    // 隐藏查找面板
    open func dismissFindNavigator()
    // 使用代码查找下一个结果
    open func findNext()
    // 使用代码查找上一个结果
    open func findPrevious()
    // 更新结果数量
    open func updateResultCount()
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;UIFindInteractionDelegat 定义如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 16.0, *)
@MainActor public protocol UIFindInteractionDelegate : NSObjectProtocol {
    // 提供 UIFindSession 对象，管理查找
    func findInteraction(_ interaction: UIFindInteraction, sessionFor view: UIView) -&amp;gt; UIFindSession?
    // 交互开始时的回调
    optional func findInteraction(_ interaction: UIFindInteraction, didBegin session: UIFindSession)
    // 交互结束时的回调
    optional func findInteraction(_ interaction: UIFindInteraction, didEnd session: UIFindSession)
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其中 UIFindSession 一般无需我们单独实现，如果使用的文本组件非上述的三种，则需要手动实现 UIFindSession 功能。&lt;/p&gt; 
&lt;h2&gt;UILargeContentViewerInteraction 大内容查看交互&lt;/h2&gt; 
&lt;p&gt;UILargeContentViewerInteraction 会用在无障碍相关的功能中，iOS 设备会为视觉障碍用户提供无障碍功能，在系统的设置中可以使用放大字体，如此设置后，即可对动态大小的字体进行放大，但是动态字体的放大功能并非会作用于所有的元素，在某些元素上动态字体功能是不生效的，例如导航栏上的文字、TabBar 栏上的文字等，针对这种场景，我们可以对某些视图设置 UILargeContentViewerInteraction 交互，在开启动态放大字体功能时，设置了 UILargeContentViewerInteraction 的组件产生用户行为时，会显示一个大的内容面板，此面板上的图标和文案可以提示用户此按钮的功能。&lt;/p&gt; 
&lt;p&gt;示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class ViewController: UIViewController, UILargeContentViewerInteractionDelegate {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        let l = UIButton(type: .system)
        l.titleLabel?.font = .systemFont(ofSize: 10)
        l.setTitle(&quot;文字很小&quot;, for: .normal)
        l.setTitleColor(.red, for: .normal)
        l.frame = CGRect(x: view.frame.width / 2 - 50.0, y: 600, width: 100, height: 30)
        view.addSubview(l)
        // 设置开启大内容交互，以及要显示的内容和图标
        l.showsLargeContentViewer = true
        l.largeContentTitle = &quot;放大&quot;
        l.largeContentImage = UIImage(systemName: &quot;star.fill&quot;)
        // 直接添加交互即可
        l.addInteraction(UILargeContentViewerInteraction(delegate: self))
    }
    
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;UILargeContentViewerInteraction 的使用非常简单：&lt;/p&gt; 
&lt;p&gt;1. 对需要的组件开启 showsLargeContentViewer 属性&lt;/p&gt; 
&lt;p&gt;2. 对要展示的大内容标题和图片进行设置&lt;/p&gt; 
&lt;p&gt;3. 为对应组件添加 UILargeContentViewerInteraction 交互&lt;/p&gt; 
&lt;p&gt;showsLargeContentViewer 属性实际上是 UILargeContentViewerItem 协议中约定的，协议如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;extension UIView : UILargeContentViewerItem {
    // 是否要开启大内容展示功能
    open var showsLargeContentViewer: Bool
    // 设置标题
    open var largeContentTitle: String?
    // 设置图片
    open var largeContentImage: UIImage?
    // 设置图片是否缩放
    open var scalesLargeContentImage: Bool
    // 设置图片边距
    open var largeContentImageInsets: UIEdgeInsets
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;UIView 类默认实现了 UILargeContentViewerItem 协议，因此理论上所有 UIView 的子类都可以直接使用 UILargeContentViewerInteraction 交互。&lt;/p&gt; 
&lt;p&gt;要对 UILargeContentViewerInteraction 进行测试也很简单，我们可以在真机上开启无障碍来进行测试，也可以在模拟器上运行，在 Debug 时对环境进行覆盖，选择动态字体，如下图：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6f4cf30b95cc2b68dd7294455a2dd3e6987.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此时，在模拟器中对示例的按钮进行按住不放，即可看到大内容面板的展示效果，如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-cc23a1770e063a3d482abdf5cce1bba1edb.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;UILargeContentViewerInteractionDelegate 协议中定义了大内容面板展示的相关生命周期，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@available(iOS 13.0, *)
@MainActor public protocol UILargeContentViewerInteractionDelegate : NSObjectProtocol {
    // 大内容交互手势结束时回调
    optional func largeContentViewerInteraction(_ interaction: UILargeContentViewerInteraction, didEndOn item: (any UILargeContentViewerItem)?, at point: CGPoint)
    // 出发交互时的位置回调，可以返回一个实现了 UILargeContentViewerItem 的对象
    optional func largeContentViewerInteraction(_ interaction: UILargeContentViewerInteraction, itemAt point: CGPoint) -&amp;gt; (any UILargeContentViewerItem)?
    // 设置要展示大内容面板的 controller
    optional func viewController(for interaction: UILargeContentViewerInteraction) -&amp;gt; UIViewController
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;UIFeedbackGenerator 用户触感反馈交互&lt;/h2&gt; 
&lt;p&gt;UIFeedbackGenerator 是 iOS 系统提供的一套触感反馈，其预定义了一些震动模式，开发者可以在不同的场景触发不同的触感反馈，增强用户的使用体验。&lt;/p&gt; 
&lt;p&gt;需要注意，UIFeedbackGenerator 是一个抽象类，我们不能对它直接进行实例化使用，也不可以自定义其子类。系统预置了几种震动模式的子类：&lt;/p&gt; 
&lt;p&gt;1.&amp;nbsp;UIImpactFeedbackGenerator&lt;/p&gt; 
&lt;p&gt;撞击类反馈，例如用户界面发生碰撞、卡槽入位等场景可以使用。&lt;/p&gt; 
&lt;p&gt;2.&amp;nbsp;UISelectionFeedbackGenerator&lt;/p&gt; 
&lt;p&gt;选中反馈，例如选择器选项的更改。&lt;/p&gt; 
&lt;p&gt;3.&amp;nbsp;UINotificationFeedbackGenerator&lt;/p&gt; 
&lt;p&gt;通知反馈，收到通知产生反馈。&lt;/p&gt; 
&lt;p&gt;4.&amp;nbsp;UICanvasFeedbackGenerator&lt;/p&gt; 
&lt;p&gt;画布的反馈，如参考线和标尺的到位等。&lt;/p&gt; 
&lt;p&gt;这几种子类的解析如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;@MainActor open class UIImpactFeedbackGenerator : UIFeedbackGenerator {
    // 反馈类型，强度不同
    public enum FeedbackStyle : Int, @unchecked Sendable {
        case light = 0
        case medium = 1
        case heavy = 2
        @available(iOS 13.0, *)
        case soft = 3
        @available(iOS 13.0, *)
        case rigid = 4
    }
    // 初始化方法
    public convenience init(style: UIImpactFeedbackGenerator.FeedbackStyle, view: UIView)
    public init(style: UIImpactFeedbackGenerator.FeedbackStyle)
    // 触发反馈
    open func impactOccurred()
    open func impactOccurred(at location: CGPoint)
    open func impactOccurred(intensity: CGFloat)
    open func impactOccurred(intensity: CGFloat, at location: CGPoint)
}


@MainActor open class UISelectionFeedbackGenerator : UIFeedbackGenerator {
    // 触发反馈
    open func selectionChanged()
    open func selectionChanged(at location: CGPoint)
}

@MainActor open class UINotificationFeedbackGenerator : UIFeedbackGenerator {
    public enum FeedbackType : Int, @unchecked Sendable {
        case success = 0
        case warning = 1
        case error = 2
    }
    // 触发反馈
    open func notificationOccurred(_ notificationType: UINotificationFeedbackGenerator.FeedbackType)
    open func notificationOccurred(_ notificationType: UINotificationFeedbackGenerator.FeedbackType, at location: CGPoint)
}

@MainActor open class UICanvasFeedbackGenerator : UIFeedbackGenerator {
    // 触发反馈
    open func alignmentOccurred(at location: CGPoint)
    open func pathCompleted(at location: CGPoint)
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;UIDragInteraction 与 UIDropInteraction 拖拽交互&lt;/h2&gt; 
&lt;p&gt;这两个交互分别处理组件的拖拽与放置，其可以在不同的应用程序间实现拖拽传输数据，非常方便。关于这两个交互的用法，在之前的文章中有详细介绍，可以参阅：&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/u/2340880/blog/1554045&quot;&gt;https://my.oschina.net/u/2340880/blog/1554045&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;其他&lt;/h2&gt; 
&lt;p&gt;UITextInteraction 与 UITextSelectionDisplayInteraction 的功能都是对文本编辑类组件添加交互，UITextInteraction 可以让自定义的文本输入控件实现类似系统 UITextView 类似的手势体验。自定义文本编辑组件需要对 UITextInput 协议进行实现，本身比较复杂，这里不在讨论。另外，与 Apple Pencil、带鼠标指针等相关外设的交互功能，也不再继续讨论，有机会后面再聊。最后，感谢你花时间阅读本文，希望能带给你预期的收获。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/2340880/blog/15616643</link>
            <guid isPermaLink="false">https://my.oschina.net/u/2340880/blog/15616643</guid>
            <pubDate>Tue, 03 Sep 2024 08:11:10 GMT</pubDate>
            <author>原创</author>
        </item>
        <item>
            <title>🎉【AI 新纪元】Xinference 0.14.4！新增视频模型+多项改进，AI 体验再升级！🔥</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Xorbits Inference（Xinference）是一个，性能强大且功能全面的，分布式，推理框架。可用于大语言模型（LLM），语音识别模型，多模态模型等各种模型的推理。通过 Xorbits Inference，你可以轻松地，一键部署你自己的模型或内置的前沿开源模型 - https://github.com/xorbitsai/inference。无论你是研究者，开发者，或是数据科学家，都可以通过 Xorbits Inference 与最前沿的 AI 模型，发掘更多可能。&lt;br&gt; &amp;nbsp;&lt;br&gt; Xinference 的功能和亮点有：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;* 🌟 模型推理，轻而易举：大语言模型，语音识别模型，多模态模型的部署流程被大大简化。一个命令即可完成模型的部署工作。&lt;/li&gt; 
 &lt;li&gt;* ⚡️ 前沿模型，应有尽有：框架内置众多中英文的前沿大语言模型，包括 baichuan，chatglm2 等，一键即可体验！内置模型列表还在快速更新中！&lt;/li&gt; 
 &lt;li&gt;* 🖥 异构硬件，快如闪电：通过 ggml，同时使用你的 GPU 与 CPU 进行推理，降低延迟，提高吞吐！&lt;/li&gt; 
 &lt;li&gt;* ⚙️ 接口调用，灵活多样：提供多种使用模型的接口，包括 OpenAI 兼容的 RESTful API（包括 Function Calling），RPC，命令行，web UI 等等。方便模型的管理与交互。&lt;/li&gt; 
 &lt;li&gt;* 🌐 集群计算，分布协同：支持分布式部署，通过内置的资源调度器，让不同大小的模型按需调度到不同机器，充分使用集群资源。&lt;/li&gt; 
 &lt;li&gt;* 🔌 开放生态，无缝对接：与流行的三方库无缝对接，包括 LangChain， LlamaIndex， Dify，以及 Chatbox。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr&gt; 
&lt;p&gt;🎉 Xinference 0.14.4 🚀 发布，新增了 CogVideoX 5B 🎥 视频模型的支持。&lt;/p&gt; 
&lt;p&gt;更新指南&lt;br&gt; * pip：pip install &#39;xinference==0.14.4&#39; 📦&lt;br&gt; * Docker：拉取最新版本即可 🐳&lt;/p&gt; 
&lt;p&gt;更新日志&lt;br&gt; * 新增内置支持模型&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 视频模型 CogVideoX-5b 🎞️&lt;br&gt; * 新功能&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * sd 系列图像模型支持 padding 🖼️&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * cosyvoice-300m-instruct 语音模型支持无需 instruction 🎤&lt;br&gt; * BUG 修复&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复 transformers 推理引擎无法加载 lora 的问题 💡&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复 docker compose 无法拉起的问题 🔄&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复 image-to-text 模型健康检查带来的问题 🛠️&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复 sglang 不同版本参数不同的问题 📈&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复注册模型列表错误的问题 📋&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复列举视频模型的问题 📝&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * 修复 VL 模型显存占用问题 🖥️&lt;br&gt; * 即将废弃：&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * v0.15.0 xinference 内置客户端 chat 接口即将废弃 prompt, system_prompt 和 chat_history 参数，这三个参数将被 messages 参数替代，与 openai 形式保持一致. ⚠️&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * v0.15.0 Qwen 系列的 react 形式的 tool call 功能将移除，由 OpenAI API 形式的 tool call 代替。移除 qwen-chat 1 代的 tool call 能力（不影响 qwen1.5-chat 和 qwen2）. 🚫&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; * v0.15.0 将移除 chatglm3。因其官方已基本不更新同时各规格接口不一致，glm 系列模型推荐直接使用 glm4-chat. 🗑️&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;我们感谢每一位参与的社区伙伴对 Xinference 的帮助和支持，也欢迎更多使用者和开发者参与体验和使用 Xinference。&lt;br&gt; &amp;nbsp;&lt;br&gt; 欢迎您在 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxorbitsai%2Finference&quot; target=&quot;_blank&quot;&gt;https://github.com/xorbitsai/inference&lt;/a&gt; 给我们一个，星标，这样你就可以在 GitHub 上及时收到每个新版本的通知。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310120</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310120</guid>
            <pubDate>Tue, 03 Sep 2024 03:43:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
        <item>
            <title>deepin 社区月报｜deepin 23 正式发布、DistroWatch 国际排名第 9......</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-community-monthly-report-2024-08%2F&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;查看原文&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;8 月社区数据总览&lt;/strong&gt;&lt;/h1&gt; 
&lt;p style=&quot;text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;720&quot; src=&quot;https://www.deepin.org/wp-content/uploads/2024/09/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240903100618.jpg&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;社区产品&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;1、deepin 23 正式发布&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;2024 年 8 月 15 日，deepin 23 发布，集成 Linux 6.6 LTS 内核及 6.9 主线双内核、AI 技术，带来 200 多项优化和新功能，旨在提供个性化和智能化的操作系统体验。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-23-is-officially-released%2F&quot; target=&quot;_blank&quot;&gt;查看 deepin 23 发行注记&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、deepin IDE 全新版本重磅更新&lt;/strong&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;deepin-IDE 研发团队根据用户的反馈和需求，推出的全新版本 deepin IDE 对 AI 智能化和顶部导航以及各种工具进行升级，也已支持玲珑构建。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-ide-update-2024-08%2F&quot; target=&quot;_blank&quot;&gt;查看 deepin-IDE 更新详情&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3、deepin 深度适配 RISC-V 架构，打造全面兼容与高性能的开源桌面操作系统&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Ftable.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;作为目前国际 Linux 发行版排名最高的国产操作系统，&lt;/a&gt;deepin 一直致力于为用户提供广泛的硬件支持。自 2022 年 2 月起，deepin 就开始了 RISC-V 架构的适配工作，现已成功支持了 x86、ARM、LoongArch 以及 RISC-V 等主流 CPU 架构。在 RISC-V 硬件生态方面，deepin 已与多家领先的板卡厂商完成了适配合作，进一步拓宽了其支持的硬件范围。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdownload%2F&quot; target=&quot;_blank&quot;&gt;deepin 23 RISC-V 各架构镜像（LicheePi 4A、VisionFive2 等）&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4、深度适配龙架构，国产 CPU 与开源操作系统新融合&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;deepin 23 版本已完成龙架构 (LoongArch) 适配，龙架构是由国内自主 CPU 引领者龙芯中科所研发处理器使用的指令集架构，其产品包括 3A6000、3A5000、3B5000 等多款高性能多核心桌面处理器。这一重要里程碑不仅标志着国产 CPU 与开源操作系统的融合迈上了新的台阶，同时也为龙架构计算机用户提供了更加稳定、高效的操作系统选择。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-v23-loongarch%2F&quot; target=&quot;_blank&quot;&gt;deepin 23 与 LoongArch 深度适配成果&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5、deepin 23 携手 Intel Ultra 平台，引领 AI PC 技术创新&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在数字化转型的浪潮中，操作系统作为连接硬件与软件的桥梁，其性能与兼容性的每一次飞跃，都标志着计算技术迈出了坚实的一步。deepin 23 版本将支持 Intel 最新的 Ultra 平台，这使得 deepin 23 有望成为当前市场最适合 AI PC 的操作系统之一，在推动开源操作系统与先进硬件技术融合方面迈出了历史性的一步。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fdeepin-v23-with-intel-ultra%2F&quot; target=&quot;_blank&quot;&gt; deepin 23 &amp;amp; Intel Ultra 强强联合&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;6、deepin 23 获得海外 13 家科技媒体报道，DistroWatch 国际排名第 9，国际影响力大幅提升！&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;deepin&amp;nbsp;23&amp;nbsp;发布的消息被国外多家新闻媒体报道，包括&amp;nbsp;&lt;strong&gt;It&#39;s&amp;nbsp;Foss&lt;/strong&gt;、&lt;strong&gt;LinuxMagazine&lt;/strong&gt;、&lt;strong&gt;LinuxJournal&lt;/strong&gt; 和 &lt;strong&gt;MeuLinux&lt;/strong&gt; 等 &lt;strong&gt;Linux &lt;/strong&gt;领域知名媒体平台。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Ftable.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;查看 deepin 实时国际排名&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;7、深度之家&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;2024 年 8 月，深度之家共收到用户 bug 及需求反馈 733 条：当中 bug 反馈 596 个，需求反馈 137 个，已修复 64 个，确认系统 bug 118 个；&lt;/li&gt; 
 &lt;li&gt;已修复的 bug 包括用户反馈的&lt;strong&gt;【工作区切换无效】、【 dde-shell 内存泄漏严重】、【玲珑版本 QQ 输入异常】&lt;/strong&gt;等问题。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;SIG 组 8 月进展&lt;/strong&gt;&lt;/h1&gt; 
&lt;h2&gt;&lt;strong&gt;8 月 SIG 组重点动态&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;deepin LoongArch SIG：旧世界固件支持介绍&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;来自安同开源社区的王邈实现了 Linux 内核和 GRUB 引导器的「旧世界」固件引导兼容性，支持在联想开天 M540z 及国光 4C5LG 服务器等早期龙架构设备上引导与启动 deepin 23 正式版，让这些本「无缘」使用「新世界」的设备通过更新「新世界」系统享受到了更强大的软件和硬件兼容性。此外，LoongArch SIG 还为 deepin 适配了 os-prober 相关修改，支持 deepin 23（「新世界」）和 UOS V20 （「旧世界」）系统的双启动，让用户更自由地选用自己需要的系统环境。&lt;/p&gt; 
&lt;p&gt;如同 libLoL 和内核方面的工作，这一兼容性机制的引入和完善将进一步降低「新世界」生态的入门门槛，让更多用户有信心、有能力、有动力切换到性能更高、兼容性更强和更开放可持续的「新世界」生态中。&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh%2Fdocs%2Fsig%2Fsig%2Fdeepin-LoongArch%2FREADME.md&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/deepin-LoongArch/README.md&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;其他小组动态&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;1、deepin-ports SIG:&lt;/strong&gt;&amp;nbsp; 逐步支持各大 RISCV 设备硬件编解码&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh%2Fdocs%2Fsig%2Fsig%2Fdeepin-ports%2FREADME.md&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/deepin-ports/README.md&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、deepin-sysdev-team：&lt;/strong&gt;与各个 SIG 协同，持续维护与更新仓库软件包&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh%2Fdocs%2Fsig%2Fsig%2Fdeepin-sysdev-team%2FREADME.md&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/deepin-sysdev-team/README.md&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3、DDE SIG：&lt;/strong&gt;集成最终供发布的 deepin 23 DDE 项目&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh%2Fdocs%2Fsig%2Fsig%2Fdde%2FREADME.md&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/dde/README.md&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4、dde-port SIG：&lt;/strong&gt;持续推进&amp;nbsp;dde&amp;nbsp;在各个发行版的移植&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Findex%2Fzh%2Fdocs%2Fsig%2Fsig%2Fdde-porting%2FREADME.md&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/dde-porting/README.md&lt;/em&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5、deepin-kernel SIG：&lt;/strong&gt;完善现有硬件支持情况；为&amp;nbsp;deepin&amp;nbsp;内核提供更好的国产化硬件支持&lt;/p&gt; 
&lt;p&gt;SIG 详情：&lt;em&gt;https://www.deepin.org/index/zh/docs/sig/sig/deepin-kernel/README.md&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;社区生态&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;8 月，deepin 应用商店共完成&lt;strong&gt; 693&lt;/strong&gt;&amp;nbsp;个应用上架，其中玲珑包 &lt;strong&gt;239 &lt;/strong&gt;个，原生 deb 应用 &lt;strong&gt;454&lt;/strong&gt; 个；&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;新应用上架&lt;strong&gt; 599 &lt;/strong&gt;款，其中 163 款玲珑应用上架社区 deepin 23 ；新上架多款包含 AI 功能的应用，包括 X-AI 、稿定 AI、小智搜搜等；&lt;/li&gt; 
 &lt;li&gt;更新应用 &lt;strong&gt;94&lt;/strong&gt; 个，其中包括哔哩哔哩 bilibili，印象笔记、Duolingo 多邻国、UOS 应用迁移助手（ wine 运行器）、GIMP-图像处理、Chrome-谷歌浏览器、雷鸟邮件客户端等。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;社区活动&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;1、deepin 23 发布会&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;8 月 15 日 deepin 23 成功发布！本次版本围绕「聚 AI 而生，大有不同」为主题进行了国内外线上直播发布，这次更新带来了全新 DDE 视界、AI For OS、「如意玲珑」应用生态、「 deepin IDE 」等重要更新。同时配合此次版本也设计系列宣发内容与活动，全网整体曝光量 1520W+。&lt;/p&gt; 
&lt;p&gt;来自中国、意大利、美国、丹麦、菲律宾、法国和荷兰的开源爱好者在社交媒体平台上分享了他们对 deepin 23 的积极评价：在性能、界面设计、新功能等方面得到较大的提升，但同时也存在一些需要改进的地方，如稳定性和兼容性问题。社区的积极响应和修复问题的态度也赢得了用户的肯定。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2、deepin 23 Release Party 暨 WHLUG 8 月活动&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;2024 年 8 月 24 日，deepin 23 Release Party 暨 WHLUG 8 月活动在龙芯中科（武汉）技术有限公司的支持下成功举办，本次活动邀请到了来自统信软件、deepin（深度）社区、龙芯中科的各位专业的技术老师为到场的 30 余位开源爱好者们做分享和交流。&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2F2024-08-whlug%2F&quot; target=&quot;_blank&quot;&gt;deepin 23 Release Party 活动回顾&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fcategory%2Fnews%25ef%25bc%2588chinese%25ef%25bc%2589%2Fwhlug-news%2F&quot; target=&quot;_blank&quot;&gt;往期 WHLUG 活动回顾&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3、产品面对面&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;随着 8 月 deepin 23 的正式发布，产品面对面也将本次 deepin 23 发布的亮点之一&lt;strong&gt;「全新的 DDE 桌面环境」&lt;/strong&gt;作为 8 月栏目的主题。本次，邀请到了 deepin 社区高级产品经理梅毅翔，通过论坛发文以及微信视频号&amp;amp;B 站直播间双平台直播的方式，为广大 deepin 用户来带 deepin 23 托盘及新增插件功能的分享。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;deepin 论坛&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;8 月 deepin 论坛共发布了 &lt;strong&gt;14950&lt;/strong&gt; 帖子，共发布主题帖 &lt;strong&gt;2224 &lt;/strong&gt;个，超过&lt;strong&gt; 1100+ &lt;/strong&gt;新朋友加入到 deepin 论坛。&lt;/p&gt; 
&lt;p&gt;当中，最受论坛用户欢迎的帖子 Top5 为：&lt;/p&gt; 
&lt;p&gt;1. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F276603&quot; target=&quot;_blank&quot;&gt;2024 年 8 月 15 日 deepin 23 正式版发布公告&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;2. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F276491&quot; target=&quot;_blank&quot;&gt;聚 AI 而生，大有不同 —— deepin 23 正式发布直播倒计时！&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;3.&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F276621&quot; target=&quot;_blank&quot;&gt; 写在 deepin 23 发布之前&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;4.&amp;nbsp; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F276254&quot; target=&quot;_blank&quot;&gt;[详细介绍]玲珑是什么?它从哪里来，又要到哪里去?&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;5. &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.deepin.org%2Fpost%2F277352&quot; target=&quot;_blank&quot;&gt;全网刷屏的《黑神话：悟空》，在 deepin 23 上玩是一种什么样的体验&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;社区鸣谢&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;strong&gt;论坛最活跃小伙伴&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;阿尼樱奈奈&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;neko&lt;/li&gt; 
 &lt;li&gt;晚秋（lateautumn）&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;内测最活跃小伙伴&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;hotime&lt;/li&gt; 
 &lt;li&gt;鲜衣怒马&lt;/li&gt; 
 &lt;li&gt;autty&lt;/li&gt; 
 &lt;li&gt;tagerw&lt;/li&gt; 
 &lt;li&gt;fslong&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;PR 贡献最活跃小伙伴&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;ice909&lt;/li&gt; 
 &lt;li&gt;leoliu-oc&lt;/li&gt; 
 &lt;li&gt;Cherrling&lt;/li&gt; 
 &lt;li&gt;wojiaohamliyang&lt;/li&gt; 
 &lt;li&gt;alongnice&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;（1）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Findex.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;deepin 全版本镜像下载（含 deepin V15）&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;（2）&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2Fcategory%2Fnews%25ef%25bc%2588chinese%25ef%25bc%2589%2Fdeepin-monthly-report%2F&quot; target=&quot;_blank&quot;&gt;deepin（社区）月度汇报&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/310114</link>
            <guid isPermaLink="false">https://www.oschina.net/news/310114</guid>
            <pubDate>Tue, 03 Sep 2024 03:12:00 GMT</pubDate>
            <author>来源: 投稿</author>
        </item>
    </channel>
</rss>