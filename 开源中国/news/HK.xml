<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Wed, 17 Sep 2025 07:49:05 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>自由職業服務市場 ​Fiverr 裁員 30%，轉型為 「AI 優先」 公司</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;自由職業服務市場 Fiverr 近日宣佈將裁員約 250 名員工，約佔其總員工的 30%。公司創始人兼首席執行官米哈伊・考夫曼在社交平台 X 上表示，AI 技術的引入將促使 Fiverr 進行根本性的重塑，重新回到 「初創模式」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;他強調，這一轉型將需要痛苦的重置過程，因此將與來自不同部門的員工分道揚鑣，最終形成一個更小、更扁平化的組織結構。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="339" src="https://oscimg.oschina.net/oscnet/up-3afbc6b00ea5d0d1596fad055e3e436158c.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;考夫曼指出，AI 的應用可以 「解放人類，使其擺脱繁瑣的手動任務」，並 「開啓歷史上不可能或成本過高的能力」。為了緩解離職員工的壓力，他承諾將提供遣散費和延長的健康保險。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;由於對 AI 技術的擔憂，許多企業已在此領域投入了近 400 億美元的資金。與此同時，其他科技公司也面臨着因 AI 而導致的大規模裁員，如印度服務巨頭塔塔諮詢服務（TCS）最近裁減了超過 10000 名員工，並提高了留任員工的工資。Fiverr 的最新舉措也似乎意在提升公司的股價。在 2021 年 2 月，Fiverr 的市場資本一度達到 110 億美元，但如今的股價僅徘徊在 23 美元附近，在裁員消息公佈後稍有下滑。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;考夫曼早在今年 5 月就已向員工發出警告，表示 AI 正在侵襲每個人的工作。他鼓勵員工利用 AI 替代工作中的繁瑣任務，甚至希望他們實現 「100% 自動化」。他表示，管理層的期望是每個員工在單位時間內的輸出和質量都要翻倍或三倍提升。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;最後，考夫曼提到，AI 實際上迫使我們重新發現人性，強調每個人獨特的價值和特殊屬性。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372760</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372760</guid>
      <pubDate>Wed, 17 Sep 2025 07:40:11 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬斯克宣佈將在數週後開始訓練 Grok 5 模型，並稱有機會實現 AGI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;馬斯克社交平台&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1968196086193066365" target="_blank"&gt;預告&lt;/a&gt;了 xAI 下一代大模型的消息，表示將在幾周後開始訓練 Grok 5。他上個月曾説過 Grok 5 將在今年年底前推出。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/151342_o1bd_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;馬斯克還説道，「&lt;strong&gt;我現在認為 xAI 有機會通過 Grok 5 實現 AGI，此前從未有過這種想法。&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/151300_lnoo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;今年 7 月，&lt;span style="background-color:#ffffff; color:#333333"&gt;&lt;a href="https://www.oschina.net/news/359656/xai-grok4" target="_blank"&gt;馬斯克正式發佈了 Grok 4&lt;/a&gt;，聲稱是全球最強 AI 模型，在處理學術問題上的表現已達到博士級別。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0710/145628_93z7_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Grok 4 系列包括兩個版本：Grok 4 和 Grok 4 Heavy。兩者都是純推理模型，沒有非推理模式。Grok 4 是單代理（single agent）版本，而 Grok 4 Heavy 是多代理版本（multi agents），支持四個代理同時工作。上下文窗口最高支持 256k tokens。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372757</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372757</guid>
      <pubDate>Wed, 17 Sep 2025 07:19:11 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源 BI 工具 DataEase v2.10.13 LTS 發佈，AI 智能問數能力全面升級</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;2025 年 9 月 16 日，人人可用的開源 BI 工具 DataEase 正式發佈 v2.10.13 LTS 版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;重要更新：AI 智能問數能力全面升級&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase v2.10.13 LTS 版本重磅引入全新的開源智能問數系統 SQLBot（&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;https://github.com/dataease/SQLBot&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;），完全替代 DataEase 原有的 Copilot 功能。SQLBot 是基於大語言模型和 RAG（Retrieval Augmented Generation，檢索增強生成）的開源智能問數系統，幫助用户實現數據的即問即答，有效提升數據查詢的智能化水平。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;與同類產品相比，SQLBot 的優勢體現在以下方面：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;更快速：通過自然語言即可快速生成複雜的 SQL 查詢；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;更精準：智能理解業務意圖，大幅減少查詢錯誤；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;更開放：基於開源架構，支持社區貢獻和自定義擴展。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase 嵌入 SQLBot 後將全面升級用户的智能問數體驗，輔助用户高效挖掘數據價值，讓數據分析變得更加簡單和直觀。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img alt="" height="624" src="https://oscimg.oschina.net/oscnet/up-f64c3442dd72aa8d64c1f32e10f15f7c206.png" width="1189" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;span&gt;▲圖 1 SQLBot 智能問數工作原理&lt;/span&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="632" src="https://oscimg.oschina.net/oscnet/up-e4fe0c4f7f4af508eb1087d48ee26a0b6e6.png" width="1230" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;span&gt;▲圖 2 DataEase 嵌入 SQLBot 智能問數系統&lt;/span&gt; 
&lt;/div&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;DataEase v2.10.13 LTS 版本的其他功能變動包括：&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;查詢組件&lt;/span&gt;&lt;/strong&gt;方面，日期查詢組件增加快捷選項；&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;儀錶板/數據大屏&lt;/span&gt;&lt;/strong&gt;方面，通用配色增加斑馬紋配色；&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;系統設置&lt;/span&gt;&lt;/strong&gt;方面，系統變量值支持設置別名。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;X-Pack 增強包&lt;/span&gt;&lt;/strong&gt;的功能變動包括：&lt;strong&gt;&lt;span style="color:#0a7be0"&gt;數據填報&lt;/span&gt;&lt;/strong&gt;方面，內置數據源增加支持數據填報功能配置。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;新增功能&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（系統參數）：支持 SQLBot 嵌入設置；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（儀錶板、數據大屏）：通用配色增加斑馬紋配色；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（查詢組件）：日期查詢組件增加快捷選項；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（系統設置）：系統變量值支持設置別名（#16713）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;feature（X-Pack，數據填報）：內置數據源增加支持數據填報功能配置。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;功能優化&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（圖表）：優化移動端跳轉問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（數據大屏、儀錶板）：資源發佈時，清理無用數據（#16749）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，定時報告）：定時報告頁面增加額外等待時間設置；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，用户管理）：創建用户 API 接口返回數據增加用户 ID（#16825）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;refactor（X-Pack，同步管理）：使用 Quartz 統一管理任務調度；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：對 Elasticsearch 數據源時間類型字段進行優化，默認映射為 Doris 的 String 類型；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：優化任務狀態刷新機制；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：優化同步日誌提示信息；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor（X-Pack，同步管理）：優化同步配置參數傳遞邏輯；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;refactor：更新移動端樣式。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;Bug 修復&lt;/h1&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復放大 Tab 中圖表並執行導出圖片操作後，輪播提示顯示異常的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復明細表合併單元格後，維度存在空值時導出失敗的問題（#16777）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復明細表基礎樣式勾選「自動換行」選項後，表頭會出現部分信息不顯示的問題（#16804）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復明細表字段全都是維度時，導出的 Excel 文件中單元格合併失效的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復水波圖標籤被裁剪的問題（#16798）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復查詢組件首選項會影響跳轉條件的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復透視表列維度為空時，帶格式導出會失敗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：開啓輪播提示的圖表啓用縮略軸時，禁用輪播提示；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復透視表自定義彙總時，通過搜索添加字段會報錯的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復地圖中福州與福清、平潭的連線出現多餘連接線的問題（#16877）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：字段自定義排序去除空值（#16307）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（圖表）：修復明細表隱藏列後，導出數據出現錯亂的問題（#16785）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復設置默認值和必填項，同時隱藏查詢按鈕時，輸入任意值回車後均會重置為默認值的問題（#16750）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復手動輸入型選項值在查看時，默認值顯示為未勾選狀態的問題（#16709）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復開啓首選項時未關閉查詢按鈕，導致查詢按鈕失效的問題（#16894）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復文本搜索需兩次回車才能返回結果，首次觸發顯示「暫無數據」的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復時間範圍組件默認值提示「超出日期篩選範圍」的問題（#16914）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（查詢組件）：修復行權限與過濾組件「首項」默認值同時使用時，會導致過濾功能失效的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（儀錶板）：修復手動輸入型查詢組件出現樣式錯位的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（儀錶板）：修復儀錶板縮放模式切換為「按組件比例縮放」後，保存發佈再次查看不生效問題（#16885）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（數據大屏）：修復 Tab 及內部組件的右鍵菜單定位偏移問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（儀錶板、數據大屏）：修復設置圖表背景圖時出現多餘滾動條問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復調整瀏覽器窗口大小時，Excel 字段選擇器的選中狀態被隱藏的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復無數據源時點擊「創建數據集」按鈕，頁面卡死且控制枱報錯的問題（#16831）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復飛書渠道查看更新記錄提示異常的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復 SQL Server 數據過濾異常的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復 Calcite 轉 SQL Server 時 CONCAT 函數異常的問題（#16860）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據源）：修復 SQL Server 下拉樹組件報錯問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據集）：修復字段表達式引用新建計算參數失效的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（數據集）：修復自定義 SQL 未保存直接關閉時缺少提示信息的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（系統設置）：修復三方嵌入配置僅保存不驗證時，錯誤觸發應用狀態變更的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（系統設置）：修復彈窗層級顯示異常的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修復 SQL 查詢驗證錯誤；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修復 SQL Server 表名含@符號時任務創建失敗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修復下次執行時間計算錯亂問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修復數據源異常時同步日誌丟失的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack，同步管理）：修復 SQL Server uniqueidentifier 字段導致定時任務創建失敗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（X-Pack，同步管理）：修復字段數量過多導致任務創建失敗的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修復「權限配置」→「按用户配置」時，用户量過大導致頁面卡頓的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修復移動儀錶板後，後台緩存未即時刷新的問題；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（X-Pack）：修復在「組織管理」模塊中修改名稱需刷新瀏覽器才能生效的問題（#16751）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（漏洞）：修復 DB2 LDAP 存在的 SSRF 漏洞（CVE-2025-58045）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;fix（漏洞）：修復 Impala 數據源 JDBC 攻擊漏洞（CVE-2025-58046）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix（漏洞）：修復 Redshift JDBC 繞過漏洞（CVE-2025-58748）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：修復模板市場地址提示錯誤（#16858）；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：統一數據大屏與儀錶板事件觸發規則，編輯狀態下禁止觸發；&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; text-align:start"&gt;&lt;span&gt;&lt;span style="color:#0a7be0"&gt;■&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;fix：修復存儲單位判斷腳本中非 GB 單位的處理問題。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4736111/blog/18692091</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4736111/blog/18692091</guid>
      <pubDate>Wed, 17 Sep 2025 07:03:11 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>香港已預留十億港元，於明年成立「香港人工智能研發院」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;香港特區行政長官李家超今日（9 月 17 日）在香港特區立法會綜合大樓會議廳發表《行政長官 2025 年施政報告》，這是李家超任期內的第四份施政報告。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李家超表示，香港具備科研、資金、數據、人才的優勢，並有豐富應用場景，有望成為全球 AI（人工智能）發展樞紐。特區政府會加大推動 AI 作為香港未來發展的核心產業，以「加強基建，推動應用導向」為策略，在重視防範安全風險的意識下，推進 AI+發展，促進 AI 在各行業廣泛深度融合，實現「AI 產業化、產業 AI 化」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;據介紹，香港已預留 10 億港元，於 2026 年成立「香港人工智能研發院」，促進 AI 上游研發、中下游成果轉化及開拓應用場景。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="285" src="https://oscimg.oschina.net/oscnet/up-b76eed8addde7663069b00ddc554f15d3f3.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李家超還稱，繼數碼港設立人工智能超算中心及特區政府推出「人工智能資助計劃」後，今年內香港還會推出北區沙嶺約 10 公頃數據園區發展用地作市場招標，提供先進算力設施，推動數據及 AI 相關產業發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;香港金融管理局與數碼港推出的第二期 AI 沙盒計劃將推廣至更多金融機構。據悉，香港金融管理局亦正建立 AI 模型評估方法，強化金融系統安全測試。香港特區發展局將資助私營工程應用 AI。香港律政司亦將成立跨部門工作小組，檢視更廣泛應用 AI 所需的法律配套。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372748</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372748</guid>
      <pubDate>Wed, 17 Sep 2025 07:00:11 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>甲骨文 MySQL 團隊大規模裁員，引發創始人和社區擔憂</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theregister.com%2F2025%2F09%2F11%2Foracle_slammed_for_mysql_job%2F" target="_blank"&gt;根據 The Register 的報道&lt;/a&gt;，甲骨文近日對其 MySQL 團隊進行了大規模裁員，約有 70 名員工受到影響，其中不乏核心和資深開發者。&lt;/p&gt; 
&lt;p&gt;MySQL 聯合創始人 Monty Widenius 表示對此「感到悲傷」，雖然對 Oracle 走向商業化和雲端產品並不意外，但仍擔心 MySQL 社區版未來受到威脅。&lt;/p&gt; 
&lt;p&gt;Widenius 還提到，當初創建 MariaDB 的目的之一就是「為下一代 MySQL」提供一個更穩定、更可持續的開源未來。現在這些事件被視為驗證了他的擔憂。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-7999b55d49242e1ba5dbcd77f53a7f88d75.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;曾在 MySQL 擔任性能工程師的知名社區成員 Peter Zaitsev 也對裁員&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.linkedin.com%2Fposts%2Fpeterzaitsev_mysql-opensource-activity-7370819205702664193-5gPl" target="_blank"&gt;表示強烈批評&lt;/a&gt;，擔憂這是 Oracle 在削弱 MySQL 社區版（Community Edition）的影響力，甚至可能在「慢慢地殺掉」 MySQL 社區版本。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/144156_3NuF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;消息稱 MySQL 團隊已被併入 Oracle Heatwave 業務單元，未來開發重點將轉向雲端分析和 AI 相關功能，而非傳統的社區版本迭代&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;業內擔心，這可能意味着 Oracle 正在邊緣化 MySQL 社區版，鼓勵用户轉向其商業產品。Widenius 也藉機提醒用户關注 MariaDB 等替代方案，以保障 MySQL 的開源精神得以延續。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372738</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372738</guid>
      <pubDate>Sun, 14 Sep 2025 06:33:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里巴巴推出端到端語音識別大模型 FunAudio-ASR</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里巴巴通義實驗室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7l5EPTU7cpz7GSN4RP91rg" target="_blank"&gt;宣佈&lt;/a&gt;正式推出 FunAudio-ASR —— 一款專為解決企業落地難題而生的端到端語音識別大模型。它不僅擁有高精度的通用識別能力，還通過創新的 Context 增強模塊，針對性優化了「幻覺」、「串語種」等工業場景中的關鍵問題。&lt;/p&gt; 
&lt;p&gt;這個模型的最大亮點在於它的創新 「Context 模塊」，讓高噪聲環境下的語音識別準確率得到了顯著提升，幻覺率從 78.5% 大幅降低至 10.7%，降幅近乎 70%。這一技術突破為語音識別行業樹立了新的標杆，尤其適用於嘈雜的場合，如會議、公共場所等。&lt;/p&gt; 
&lt;p&gt;FunAudio-ASR 模型在訓練過程中使用了數千萬小時的音頻數據，並將大語言模型的語義理解能力融入其中，使其在遠場、嘈雜和多説話人等複雜條件下的表現，已經超越了諸如 Seed-ASR、KimiAudio-8B 等眾多主流語音識別系統。通過這一技術的應用，用户在進行語音識別時，能夠享受到更清晰、更精準的識別效果。&lt;/p&gt; 
&lt;p&gt;&lt;img height="362" src="https://oscimg.oschina.net/oscnet/up-29ceac6995b94410187f31d4aaa6288579d.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了完整版本外，阿里還推出了輕量化版本 FunAudio-ASR-nano。該版本在保持高識別準確率的同時，降低了推理成本，適合那些對資源要求較高的部署環境。無論是大企業還是小型團隊，都能找到適合自己的解決方案。&lt;/p&gt; 
&lt;p&gt;&lt;img height="202" src="https://oscimg.oschina.net/oscnet/up-b13a7f60c07f8b458e99b254fcfe6ec0b29.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;目前，FunAudio-ASR 已經在釘釘的 「AI 聽記」 功能、視頻會議以及 DingTalk A1 硬件中得到了實際應用。此外，其 API 也已在阿里雲百鍊平台上正式上線，方便開發者進行集成和使用。對於企業用户而言，這意味着他們可以利用這一先進技術提升會議效率，增強溝通效果。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372731</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372731</guid>
      <pubDate>Sun, 14 Sep 2025 06:14:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Java 25 的新特性</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;&amp;gt;Java 語言特性系列&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417288" target="_blank"&gt;Java5 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417536" target="_blank"&gt;Java6 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004417830" target="_blank"&gt;Java7 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004419611" target="_blank"&gt;Java8 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIsm1CvP9swYtkQzH_EYQ4A" target="_blank"&gt;Java9 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FMUyTbO2M68-TfCt1CFTHHA" target="_blank"&gt;Java10 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFBoIM3eP-iqhquizlOETYw" target="_blank"&gt;Java11 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FoXMNQcy7mi_GaZEdm6l8Yw" target="_blank"&gt;Java12 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FrN8RYiN-mKnju1riM2yKuA" target="_blank"&gt;Java13 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQjs4MiT0MRTj5QkeNNB66A" target="_blank"&gt;Java14 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBO7fYDQjK_00CGZJ8JQGjA" target="_blank"&gt;Java15 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FhVRTYsiKPU8Nz_mbzSTU0Q" target="_blank"&gt;Java16 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3FZOUqZcFqd-1n1NSooERA" target="_blank"&gt;Java17 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fanrq5HzNW5FCvnSv2cyiEg" target="_blank"&gt;Java18 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FUS9on700dYcZOfO2JX8-qA" target="_blank"&gt;Java19 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FCmpz2KCyW9HyOpz_I9Zkww" target="_blank"&gt;Java20 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FuuXx5e1XuAaTECaXCUf-rg" target="_blank"&gt;Java21 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FQBy-xWcYOCvx8e7540Y-RA" target="_blank"&gt;Java22 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Ftc5t_OgsspUMBjMpbX9X6Q" target="_blank"&gt;Java23 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FvAzN3WueWUSJQ5Q69kBFkQ" target="_blank"&gt;Java24 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfaMVnVP5Hwyil2-qmGCv7A" target="_blank"&gt;Java25 的新特性&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://my.oschina.net/go4it/blog/%60%E5%BE%85%E8%A1%A5%E5%85%85%60"&gt;Java26 的新特性&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;序&lt;/h1&gt; 
&lt;p&gt;本文主要講述一下 Java25 的新特性&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;版本號&lt;/h1&gt; 
&lt;pre&gt;&lt;code&gt;openjdk version "25" 2025-09-16
OpenJDK Runtime Environment (build 25+36-3489)
OpenJDK 64-Bit Server VM (build 25+36-3489, mixed mode, sharing)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;從 version 信息可以看出是 build 25+36&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;特性列表&lt;/h1&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F470" target="_blank"&gt;JEP 470: PEM Encodings of Cryptographic Objects (Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性為 Java 平台引入了一套簡潔、易用且線程安全的 API(Preview 版本)，用於在 PEM（Privacy-Enhanced Mail）文本與各類密碼學對象（密鑰、證書、CRL 等）之間進行雙向轉換，解決開發者長期需要手寫解析/格式化邏輯的痛點。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;DEREncodable 標記接口，統一標識可參與 PEM 編解碼的已有類型： AsymmetricKey、X509Certificate、X509CRL、KeyPair、EncryptedPrivateKeyInfo、PKCS8EncodedKeySpec、X509EncodedKeySpec 以及新引入的 PEMRecord。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;PEMEncoder / PEMDecoder 不可變、可複用、線程安全。 支持直接編解碼字符串或字節流，提供 encode(DerEncodable) / decode(String/InputStream) 等便捷方法。 通過 withEncryption(char[] password) / withDecryption(...) 一鍵加解密私鑰；默認算法可在安全屬性文件中配置（當前為 PBEWithHmacSHA256AndAES_128）。 通過 withFactory(Provider) 可指定特定加密提供者。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;PEMRecord 記錄類，用於處理平台暫無對應 API 的 PEM 類型（如 PKCS#10 請求）或需要保留 PEM 首部前導數據的場景。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;EncryptedPrivateKeyInfo 增強，新增靜態工廠方法 encryptKey(...) 與實例方法 getKey(...)，方便先加密成 EncryptedPrivateKeyInfo 再編碼為 PEM，或解碼後直接解密拿到 PrivateKey。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PEMEncoding {
    public static void main() throws NoSuchAlgorithmException {
        // Enable preview features: --enable-preview --release 25

        // 1. Generate an EC key pair
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC");
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // 2. Encode public key to PEM
        String publicKeyPEM = PEMEncoder.of()
                .encodeToString(keyPair.getPublic());
        System.out.println("Public Key PEM:\n" + publicKeyPEM);

        // 3. Encode a private key to encrypted PEM
        char[] password = "secret".toCharArray();
        String privateKeyPEM = PEMEncoder.of()
                .withEncryption(password)
                .encodeToString(keyPair.getPrivate());
        System.out.println("Encrypted Private Key PEM:\n" + privateKeyPEM);

        // 4. Decode a public key
        PublicKey decodedPubKey = PEMDecoder.of()
                .decode(publicKeyPEM, PublicKey.class);
        System.out.println("Decoded Public Key Algo: " + decodedPubKey.getAlgorithm());

        // 5. Decode encrypted private key
        PrivateKey decodedPrivateKey = PEMDecoder.of()
                .withDecryption(password)
                .decode(privateKeyPEM, PrivateKey.class);
        System.out.println("Decoded Private Key Algo: " + decodedPrivateKey.getAlgorithm());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;編譯及運行&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;javac --release 25 --enable-preview PEMEncoding.java
java  --enable-preview PEMEncoding
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F502" target="_blank"&gt;JEP 502: Stable Values (Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了一種名為 Stable Values（穩定值） 的 API，用於支持延遲初始化的不可變數據持有者對象。這一特性在 JDK 25 中以預覽功能形式提供，旨在提升 Java 應用的啓動性能與併發安全性，同時保留 final 字段的優化能力（如常量摺疊）。 Stable Values 填補了 final 字段與可變字段之間的空白，在保持不可變性和線程安全的同時，支持按需初始化，特別適用於啓動時需要延遲加載資源的大型應用場景。&lt;/p&gt; 
&lt;p&gt;使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class OrderController {

    // OLD:
    // private Logger logger = null;

    // NEW:
    private final StableValue&amp;lt;logger&amp;gt; logger = StableValue.of();

    Logger getLogger() {
        return logger.orElseSet(() -&amp;amp;gt; Logger.create(OrderController.class));
    }

    void submitOrder(User user, List&amp;lt;product&amp;gt; products) {
        getLogger().info("order started");
        ...
        getLogger().info("order submitted");
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;由於是預覽版本，所以需要&lt;code&gt;--enable-preview&lt;/code&gt;啓用&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;javac --release 25 --enable-preview Main.java
java --enable-preview Main
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F503" target="_blank"&gt;JEP 503: Remove the 32-bit x86 Port&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F449" target="_blank"&gt;JEP 449: Deprecate the Windows 32-bit x86 Port for Removal&lt;/a&gt;已經廢棄了對 Windows 32 位 x86 的移植，在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F479" target="_blank"&gt;JEP 479: Remove the Windows 32-bit x86 Port&lt;/a&gt;刪除了相關源代碼、移除了對 windows 32 位相關構建支持，在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F501" target="_blank"&gt;JEP 501: Deprecate the 32-bit x86 Port for Removal&lt;/a&gt;廢棄了對 32 位 x86 的移植，但是可以通過&lt;code&gt;--enable-deprecated-ports=yes&lt;/code&gt;來啓用構建，在 JDK25Z 則刪除了相關源代碼、移除了相關構建支持&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F505" target="_blank"&gt;JEP 505: Structured Concurrency (Fifth Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F428" target="_blank"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;作為第一次 incubator &amp;gt;JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F437" target="_blank"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;作為第二次 incubator &amp;gt;JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F453" target="_blank"&gt;JEP 453: Structured Concurrency (Preview)&lt;/a&gt;作為首次 preview &amp;gt;JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F462" target="_blank"&gt;JEP 462: Structured Concurrency (Second Preview)&lt;/a&gt;作為第二次 preview &amp;gt;JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F480" target="_blank"&gt;JEP 480: Structured Concurrency (Third Preview)&lt;/a&gt;作為第三次 preview &amp;gt;JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F499" target="_blank"&gt;JEP 499: Structured Concurrency (Fourth Preview)&lt;/a&gt;作為第四次 preview &amp;gt;JDK25 作為第五次 preview&lt;/p&gt; 
&lt;p&gt;使用示例如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;Response handle() throws InterruptedException {

    try (var scope = StructuredTaskScope.open()) {

        Subtask&amp;lt;string&amp;gt; user = scope.fork(() -&amp;amp;gt; findUser());
        Subtask&amp;lt;integer&amp;gt; order = scope.fork(() -&amp;amp;gt; fetchOrder());

        scope.join();   // Join subtasks, propagating exceptions

        // Both subtasks have succeeded, so compose their results
        return new Response(user.get(), order.get());

    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F506" target="_blank"&gt;JEP 506: Scoped Values&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F428" target="_blank"&gt;JEP 428: Structured Concurrency (Incubator)&lt;/a&gt;作為第一次 incubator JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F437" target="_blank"&gt;JEP 437: Structured Concurrency (Second Incubator)&lt;/a&gt;作為第二次 incubator JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F453" target="_blank"&gt;JEP 453: Structured Concurrency (Preview)&lt;/a&gt;作為首次 preview JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F462" target="_blank"&gt;JEP 462: Structured Concurrency (Second Preview)&lt;/a&gt;作為第二次 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F480" target="_blank"&gt;JEP 480: Structured Concurrency (Third Preview)&lt;/a&gt;作為第三次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F487" target="_blank"&gt;JEP 487: Scoped Values (Fourth Preview)&lt;/a&gt;作為第四次 preview，與 JDK23 不同的是 callWhere 以及 runWhere 方法從 ScopedValue 類中移除，可以使用 ScopedValue.where() 再鏈式調用 run(Runnable) 或者 call(Callable)&lt;/p&gt; 
&lt;p&gt;JDK25 作為第五次 preview，有個改動就是 ScopedValue.orElse 方法不再接受 null 作為參數&lt;/p&gt; 
&lt;p&gt;示例：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class Framework {

    private static final ScopedValue&amp;lt;frameworkcontext&amp;gt; CONTEXT
                        = ScopedValue.newInstance();    // (1)

    void serve(Request request, Response response) {
        var context = createContext(request);
        where(CONTEXT, context)                         // (2)
                   .run(() -&amp;amp;gt; Application.handle(request, response));
    }
    
    public PersistedObject readKey(String key) {
        var context = CONTEXT.get();                    // (3)
        var db = getDBConnection(context);
        db.readKey(key);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;在 (1) 中，框架聲明瞭一個作用域值，而不是一個 thread local 變量。在 (2)，serve 方法調用 where ... run 而不是 thread local 的 set 方法。run 方法提供了數據的單向共享 serve 方法到 readKey 方法。(3) 讀取的值是由 Framework.serve 的時候寫入的。&lt;/p&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F507" target="_blank"&gt;JEP 507: Primitive Types in Patterns, instanceof, and switch (Third Preview)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F405" target="_blank"&gt;JEP 405: Record Patterns (Preview)&lt;/a&gt;將 Record 的模式匹配作為第一次 preview JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F432" target="_blank"&gt;JEP 432: Record Patterns (Second Preview)&lt;/a&gt;作為 Record 模式匹配第二次 preview JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F440" target="_blank"&gt;JEP 440: Record Patterns&lt;/a&gt;則將 Record 模式匹配正式發佈 JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F455" target="_blank"&gt;JEP 455: Primitive Types in Patterns, instanceof, and switch (Preview)&lt;/a&gt;將原始類型的匹配作為第一次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F488" target="_blank"&gt;JEP 488: Primitive Types in Patterns, instanceof, and switch (Second Preview)&lt;/a&gt;作為第二次 preview JDK25 作為第三次 preview&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;record Point(int x, int y) {}

// As of Java 21
static void printSum(Object obj) {
    if (obj instanceof Point(int x, int y)) {
        System.out.println(x+y);
    }
}

enum Color { RED, GREEN, BLUE }
record ColoredPoint(Point p, Color c) {}
record Rectangle(ColoredPoint upperLeft, ColoredPoint lowerRight) {}
// As of Java 21
static void printUpperLeftColoredPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint ul, ColoredPoint lr)) {
         System.out.println(ul.c());
    }
}

static void printColorOfUpperLeftPoint(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),
                               ColoredPoint lr)) {
        System.out.println(c);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;但是這個只是支持 Record 類型&lt;/p&gt; 
&lt;p&gt;在 JDK14&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F305" target="_blank"&gt;JEP 305: Pattern Matching for instanceof (Preview)&lt;/a&gt;作為 preview 在 JDK15&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F375" target="_blank"&gt;JEP 375: Pattern Matching for instanceof (Second Preview)&lt;/a&gt;作為第二輪的 preview 在 JDK16&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F394" target="_blank"&gt;JEP 394: Pattern Matching for instanceof&lt;/a&gt;轉正 JDK17 引入&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F406" target="_blank"&gt;JEP 406: Pattern Matching for switch (Preview)&lt;/a&gt; JDK18 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F420" target="_blank"&gt;JEP 420: Pattern Matching for switch (Second Preview)&lt;/a&gt;則作為第二輪 preview JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F427" target="_blank"&gt;JEP 427: Pattern Matching for switch (Third Preview)&lt;/a&gt;作為第三輪 preview JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F433" target="_blank"&gt;JEP 433: Pattern Matching for switch (Fourth Preview)&lt;/a&gt;作為第四輪 preview JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F441" target="_blank"&gt;JEP 441: Pattern Matching for switch&lt;/a&gt;將 Pattern Matching for switch 作為正式版本發佈，示例如下&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// Prior to Java 21
static String formatter(Object obj) {
    String formatted = "unknown";
    if (obj instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (obj instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (obj instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (obj instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}

// As of Java 21
static String formatterPatternSwitch(Object obj) {
    return switch (obj) {
        case Integer i -&amp;amp;gt; String.format("int %d", i);
        case Long l    -&amp;amp;gt; String.format("long %d", l);
        case Double d  -&amp;amp;gt; String.format("double %f", d);
        case String s  -&amp;amp;gt; String.format("String %s", s);
        default        -&amp;amp;gt; obj.toString();
    };
}

// As of Java 21
static void testFooBarNew(String s) {
    switch (s) {
        case null         -&amp;amp;gt; System.out.println("Oops");
        case "Foo", "Bar" -&amp;amp;gt; System.out.println("Great");
        default           -&amp;amp;gt; System.out.println("Ok");
    }
}

// As of Java 21
static void testStringEnhanced(String response) {
    switch (response) {
        case null -&amp;amp;gt; { }
        case "y", "Y" -&amp;amp;gt; {
            System.out.println("You got it");
        }
        case "n", "N" -&amp;amp;gt; {
            System.out.println("Shame");
        }
        case String s
        when s.equalsIgnoreCase("YES") -&amp;amp;gt; {
            System.out.println("You got it");
        }
        case String s
        when s.equalsIgnoreCase("NO") -&amp;amp;gt; {
            System.out.println("Shame");
        }
        case String s -&amp;amp;gt; {
            System.out.println("Sorry?");
        }
    }
}

// As of Java 21
static void exhaustiveSwitchWithBetterEnumSupport(CardClassification c) {
    switch (c) {
        case Suit.CLUBS -&amp;amp;gt; {
            System.out.println("It's clubs");
        }
        case Suit.DIAMONDS -&amp;amp;gt; {
            System.out.println("It's diamonds");
        }
        case Suit.HEARTS -&amp;amp;gt; {
            System.out.println("It's hearts");
        }
        case Suit.SPADES -&amp;amp;gt; {
            System.out.println("It's spades");
        }
        case Tarot t -&amp;amp;gt; {
            System.out.println("It's a tarot");
        }
    }
}

// As of Java 21
sealed interface Currency permits Coin {}
enum Coin implements Currency { HEADS, TAILS } 

static void goodEnumSwitch1(Currency c) {
    switch (c) {
        case Coin.HEADS -&amp;amp;gt; {    // Qualified name of enum constant as a label
            System.out.println("Heads");
        }
        case Coin.TAILS -&amp;amp;gt; {
            System.out.println("Tails");
        }
    }
}

static void goodEnumSwitch2(Coin c) {
    switch (c) {
        case HEADS -&amp;amp;gt; {
            System.out.println("Heads");
        }
        case Coin.TAILS -&amp;amp;gt; {    // Unnecessary qualification but allowed
            System.out.println("Tails");
        }
    }
}

// As of Java 21
static void testNew(Object obj) {
    switch (obj) {
        case String s when s.length() == 1 -&amp;amp;gt; ...
        case String s                      -&amp;amp;gt; ...
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;但是 JDK21 還不支持原始類型的匹配&lt;/p&gt; 
&lt;p&gt;而支持原始類型的匹配使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;switch (x.getStatus()) {
    case 0 -&amp;amp;gt; "okay";
    case 1 -&amp;amp;gt; "warning";
    case 2 -&amp;amp;gt; "error";
    default -&amp;amp;gt; "unknown status: " + x.getStatus();
}

switch (x.getStatus()) {
    case 0 -&amp;amp;gt; "okay";
    case 1 -&amp;amp;gt; "warning";
    case 2 -&amp;amp;gt; "error";
    case int i -&amp;amp;gt; "unknown status: " + i;
}

switch (x.getYearlyFlights()) {
    case 0 -&amp;amp;gt; ...;
    case 1 -&amp;amp;gt; ...;
    case 2 -&amp;amp;gt; issueDiscount();
    case int i when i &amp;amp;gt;= 100 -&amp;amp;gt; issueGoldCard();
    case int i -&amp;amp;gt; ... appropriate action when i &amp;amp;gt; 2 &amp;amp;amp;&amp;amp;amp; i &amp;amp;lt; 100 ...
}

long v = ...;
switch (v) {
    case 1L              -&amp;amp;gt; ...;
    case 2L              -&amp;amp;gt; ...;
    case 10_000_000_000L -&amp;amp;gt; ...;
    case 20_000_000_000L -&amp;amp;gt; ...;
    case long x          -&amp;amp;gt; ... x ...;
}

if (roomSize instanceof byte) { // check if value of roomSize fits in a byte
    ... (byte) roomSize ... // yes, it fits! but cast is required
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;另外針對 instanceof 示例如下:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;byte b = 42;
b instanceof int;         // true (unconditionally exact)

int i = 42;
i instanceof byte;        // true (exact)

int i = 1000;
i instanceof byte;        // false (not exact)

int i = 16_777_217;       // 2^24 + 1
i instanceof float;       // false (not exact)
i instanceof double;      // true (unconditionally exact)
i instanceof Integer;     // true (unconditionally exact)
i instanceof Number;      // true (unconditionally exact)

float f = 1000.0f;
f instanceof byte;        // false
f instanceof int;         // true (exact)
f instanceof double;      // true (unconditionally exact)

double d = 1000.0d;
d instanceof byte;        // false
d instanceof int;         // true (exact)
d instanceof float;       // true (exact)

Integer ii = 1000;
ii instanceof int;        // true (exact)
ii instanceof float;      // true (exact)
ii instanceof double;     // true (exact)

Integer ii = 16_777_217;
ii instanceof float;      // false (not exact)
ii instanceof double;     // true (exact)
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F508" target="_blank"&gt;JEP 508: Vector API (Tenth Incubator)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK16 引入了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F338" target="_blank"&gt;JEP 338: Vector API (Incubator)&lt;/a&gt;提供了 jdk.incubator.vector 來用於矢量計算 JDK17 進行改進並作為第二輪的 incubator&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.java.net%2Fjeps%2F414" target="_blank"&gt;JEP 414: Vector API (Second Incubator)&lt;/a&gt; JDK18 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F417" target="_blank"&gt;JEP 417: Vector API (Third Incubator)&lt;/a&gt;進行改進並作為第三輪的 incubator JDK19 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F426" target="_blank"&gt;JEP 426:Vector API (Fourth Incubator)&lt;/a&gt;作為第四輪的 incubator JDK20 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F438" target="_blank"&gt;JEP 438: Vector API (Fifth Incubator)&lt;/a&gt;作為第五輪的 incubator JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F448" target="_blank"&gt;JEP 448: Vector API (Sixth Incubator)&lt;/a&gt;作為第六輪的 incubator JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F460" target="_blank"&gt;JEP 460: Vector API (Seventh Incubator)&lt;/a&gt;作為第七輪的 incubator JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F469" target="_blank"&gt;JEP 469: Vector API (Eighth Incubator)&lt;/a&gt;作為第八輪 incubator JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F489" target="_blank"&gt;JEP 489: Vector API (Ninth Incubator)&lt;/a&gt;則作為第九輪 incubator，與 JDK23 相比做了一些變動：比如引入了一個新的基於值的類 Float16，用於表示 IEEE 754 二進制 16 格式的 16 位浮點數。&lt;/p&gt; 
&lt;p&gt;JDK25 作為第十輪 incubator，主要變化是：VectorShuffle 現在支持訪問和訪問 MemorySegment，該實現是通過 Foreign Function &amp;amp; Memory API (JEP 454) 而不是通過 HotSpot 內部的 C++代碼，提高了可維護性，另外對 Float16 值的加法、減法、除法、乘法、平方根和 fused 乘法/加法運算現在支持 x64 cpu 自動矢量化&lt;/p&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F509" target="_blank"&gt;JEP 509: JFR CPU-Time Profiling (Experimental)&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了實驗版的 CPU-Time Profiling，可以捕獲更準確的 CPU 時間分析信息，使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=true,filename=profile.jfr ...
$ jfr view cpu-time-hot-methods profile.jfr
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;配合 jcmd 使用如下&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;jcmd &amp;lt;pid&amp;gt; JFR.start settings=/tmp/cpu_profile.jfc duration=4m
jcmd &amp;lt;pid&amp;gt; JFR.stop
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F510" target="_blank"&gt;JEP 510: Key Derivation Function API&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK 21 中包含的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F452" target="_blank"&gt;KEM API（JEP 452）&lt;/a&gt;是 HPKE 的一個組成部分，標誌着 Java 朝着 HPKE 邁出的第一步，併為後量子挑戰做好了準備。 在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F478" target="_blank"&gt;JEP 478: Key Derivation Function API (Preview)&lt;/a&gt;中提出了 HPKE 的另一個組成部分，作為這一方向上的下一步：密鑰派生函數（KDFs）的 API，作為預覽版本，在 JDK25 轉為正式版，無需&lt;code&gt;--enable-preview&lt;/code&gt;參數&lt;/p&gt; 
&lt;p&gt;使用示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// Create a KDF object for the specified algorithm
KDF hkdf = KDF.getInstance("HKDF-SHA256"); 

// Create an ExtractExpand parameter specification
AlgorithmParameterSpec params =
    HKDFParameterSpec.ofExtract()
                     .addIKM(initialKeyMaterial)
                     .addSalt(salt).thenExpand(info, 32);

// Derive a 32-byte AES key
SecretKey key = hkdf.deriveKey("AES", params);

// Additional deriveKey calls can be made with the same KDF object
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F511" target="_blank"&gt;JEP 511: Module Import Declarations&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;&amp;gt;與&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F477" target="_blank"&gt;JEP 477: Implicitly Declared Classes and Instance Main Methods (Third Preview)&lt;/a&gt;類似，本特性主要是為了簡化語法方便新手使用，通過新引入 module 的 import，來一次性導入 module 下所有 package 底下的類&lt;/p&gt; 
&lt;p&gt;JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F476" target="_blank"&gt;JEP 476: Module Import Declarations (Preview)&lt;/a&gt;作為第一個 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F494" target="_blank"&gt;JEP 494: Module Import Declarations (Second Preview)&lt;/a&gt;作為第二次 preview，與 JDK23 不同的是取消了模塊不允許聲明對 java.base 模塊傳遞依賴的限制，並修訂了 java.se 模塊聲明，使其傳遞性地依賴於 java.base 模塊。這些變化意味着導入 java.se 模塊將按需導入整個 Java SE API。此外，現在允許按需聲明的類型導入聲明覆蓋模塊導入聲明。 JDK25 作為正式版，沒有變化&lt;/p&gt; 
&lt;p&gt;示例:&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;import module java.base;  // 包含了 import java.io.*; import java.util.*;

import module java.base;      // exports java.util, which has a public Date class
import module java.sql;       // exports java.sql, which has a public Date class

import java.sql.Date;         // resolve the ambiguity of the simple name Date!

...
Date d = ...                  // Ok!  Date is resolved to java.sql.Date
...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;由於是正式版，不再需要使用&lt;code&gt;--enable-preview&lt;/code&gt;參數來開啓&lt;/p&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F512" target="_blank"&gt;JEP 512: Compact Source Files and Instance Main Methods&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK21 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F445" target="_blank"&gt;JEP 445: Unnamed Classes and Instance Main Methods (Preview)&lt;/a&gt;作為首次 preview，引入了未命名的類和實例 main 方法特性可以簡化 hello world 示例，方便 java 新手入門 JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F463" target="_blank"&gt;JEP 463: Implicitly Declared Classes and Instance Main Methods (Second Preview)&lt;/a&gt;作為第二次的 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F477" target="_blank"&gt;JEP 477: Implicitly Declared Classes and Instance Main Methods (Third Preview)&lt;/a&gt;作為第三次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F495" target="_blank"&gt;JEP 495: Simple Source Files and Instance Main Methods (Fourth Preview)&lt;/a&gt;則作為第四次 preview JDK25 作為正式版本，有些改動：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;console I/O 的新 IO 類現在位於 java.lang，而不是 java.io 包，現在隱式導入到每個源文件&lt;/li&gt; 
 &lt;li&gt;IO 類的靜態方法不再隱式導入 compact source files，需要顯示導入&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxn--IOSystem-k20m619e5ejyy6e4xh1wv.xn--outSystem-dc8o.in" target="_blank"&gt;IO 類的實現基於 System.out 及 System.in&lt;/a&gt;，而非 java.io.Console 類&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;示例如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;void main() {
    String name = IO.readln("Please enter your name: ");
    IO.print("Pleased to meet you, ");
    IO.println(name);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F513" target="_blank"&gt;JEP 513: Flexible Constructor Bodies&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;JDK22 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F447" target="_blank"&gt;JEP 447: Statements before super(...) (Preview)&lt;/a&gt;作為第一次 preview JDK23 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F482" target="_blank"&gt;JEP 482: Flexible Constructor Bodies (Second Preview)&lt;/a&gt;作為第二次 preview JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F492" target="_blank"&gt;JEP 492: Flexible Constructor Bodies (Third Preview)&lt;/a&gt;作為第三次 preview JDK25 作為正式版本，沒有變化&lt;/p&gt; 
&lt;p&gt;比如在 JEP 447 之前的代碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PositiveBigInteger extends BigInteger {

    public PositiveBigInteger(long value) {
        super(value);               // Potentially unnecessary work
        if (value &amp;amp;lt;= 0)
            throw new IllegalArgumentException(non-positive value);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在 JEP 447 之後代碼可以如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class PositiveBigInteger extends BigInteger {

    public PositiveBigInteger(long value) {
        if (value &amp;amp;lt;= 0)
            throw new IllegalArgumentException(non-positive value);
        super(value);
    }

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F514" target="_blank"&gt;JEP 514: Ahead-of-Time Command-Line Ergonomics&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F483" target="_blank"&gt;JEP 483: Ahead-of-Time Class Loading &amp;amp; Linking&lt;/a&gt;支持了通過 Ahead-of-Time Cache 來存儲已經讀取、解析、加載和鏈接的類，在 JDK25 則通過簡化常見用例所需的命令來加速 java 應用程序的啓動。&lt;/p&gt; 
&lt;p&gt;在 JDK24 時分兩步創建 AOT 緩存：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先運行 application 來記錄 AOT 配置:&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;接着使用該配置來創建 AOT 緩存：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf -XX:AOTCache=app.aot -cp app.jar
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;最後使用 AOT 緩存啓動：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;AOT 緩存將讀取、解析、加載和鏈接（通常在程序執行期間即時完成）的任務提前到緩存創建的早期階段。因此，在執行階段，程序啓動速度更快，因為其類可以從緩存中快速訪問。其性能提升可以高達 42%。 &amp;gt;但是需要運行 2 次來創建 AOT 緩存。留下 AOT 配置文件也很不方便，它只是一個臨時文件，生產運行不需要，可以刪除。&lt;/p&gt; 
&lt;p&gt;JDK25 通過引入&lt;code&gt;AOTCacheOutput&lt;/code&gt;將兩步合為一步，它實際上將其調用拆分為兩個子調用: 第一個執行訓練運行 (AOTMode=record)，然後第二個創建 AOT 緩存 (AOTMode=create)，可以通過新的環境變量 JDK_AOT_VM_OPTIONS 來覆蓋傳遞給 cache create 這個子過程的 VM 命令。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCacheOutput=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;gt;當以這種方式操作時，JVM 為 AOT 配置創建臨時文件，並在完成時刪除該文件。&lt;/p&gt; 
&lt;p&gt;使用的時候一樣：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java -XX:AOTCache=app.aot -cp app.jar com.example.App ...
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_17"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F515" target="_blank"&gt;JEP 515: Ahead-of-Time Method Profiling&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F483" target="_blank"&gt;JEP 483: Ahead-of-Time Class Loading &amp;amp; Linking&lt;/a&gt;支持了通過 Ahead-of-Time Cache 來存儲已經讀取、解析、加載和鏈接的類 JVM 可以識別執行最頻繁或消耗最多 CPU 時間的代碼，並通過將其編譯為本機代碼來優化此代碼。此過程稱為分析。簡單來説，配置文件是與方法相關的有用信息的集合，例如已執行的次數。當應用程序以通常的方式 (沒有 AOT 緩存) 運行時，這些配置文件在應用程序執行開始時收集。這個 JEP 背後的概念是，我們可以在訓練運行期間收集配置文件，然後在後續運行中重複使用它們。這意味着在以後的執行中，無需在啓動後收集配置文件，從而可以立即開始代碼編譯。訓練運行的質量會顯着影響應用程序預熱時間的改善。訓練跑得越好，在隨後的跑中獲得的性能增強就越大。 本特性將生產環境做的 Method Profiling 挪到了 Ahead-of-Time Cache 階段，使得生產環境啓動的時候就讀取這些數據，JIT 立即對真正的熱點方法進行編譯，無需邊跑邊收集。&lt;/p&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F518" target="_blank"&gt;JEP 518: JFR Cooperative Sampling&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性提高 JFR 異步採樣 Java 線程堆棧時的穩定性，通過僅在安全點處遍歷調用堆棧來實現此目的，同時最大程度地減少安全點偏差。&lt;/p&gt; 
&lt;span id="OSC_h2_19"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F519" target="_blank"&gt;JEP 519: Compact Object Headers&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F450" target="_blank"&gt;JEP 450: Compact Object Headers (Experimental)&lt;/a&gt;特性中，在 64 位架構上，將 HotSpot JVM 中的對象標頭大小從 96 到 128 位減少到 64 位。在 SPECjbb2015 的測試中減少了 22% 的堆空間和 8% 的 CPU 時間，完成的垃圾收集數量為減少 15%，一個高度並行的 JSON 解析器基準運行時間減少 10%。 在 JDK25 轉為正式版，無需&lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;命令&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-XX:+UseCompactObjectHeaders
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_20"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F520" target="_blank"&gt;JEP 520: JFR Method Timing &amp;amp; Tracing&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;本特性引入了兩個新的 JFR 事件，jdk.MethodTiming 和 jdk.MethodTrace，通過字節碼織入來追蹤方法，使用示例&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;$ java -XX:StartFlightRecording:jdk.MethodTrace#filter=java.util.HashMap::resize,filename=recording.jfr ...
$ jfr print --events jdk.MethodTrace --stack-depth 20 recording.jfr
jdk.MethodTrace {
    startTime = 00:39:26.379 (2025-03-05)
    duration = 0.00113 ms
    method = java.util.HashMap.resize()
    eventThread = "main" (javaThreadId = 3)
    stackTrace = [
      java.util.HashMap.putVal(int, Object, Object, boolean, boolean) line: 636
      java.util.HashMap.put(Object, Object) line: 619
      sun.awt.AppContext.put(Object, Object) line: 598
      sun.awt.AppContext.&amp;lt;init&amp;gt;(ThreadGroup) line: 240
      sun.awt.SunToolkit.createNewAppContext(ThreadGroup) line: 282
      sun.awt.AppContext.initMainAppContext() line: 260
      sun.awt.AppContext.getAppContext() line: 295
      sun.awt.SunToolkit.getSystemEventQueueImplPP() line: 1024
      sun.awt.SunToolkit.getSystemEventQueueImpl() line: 1019
      java.awt.Toolkit.getEventQueue() line: 1375
      java.awt.EventQueue.invokeLater(Runnable) line: 1257
      javax.swing.SwingUtilities.invokeLater(Runnable) line: 1415
      java2d.J2Ddemo.main(String[]) line: 674
    ]
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_21"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F521" target="_blank"&gt;JEP 521: Generational Shenandoah&lt;/a&gt;&lt;/h2&gt; 
&lt;p&gt;在 JDK24 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F404" target="_blank"&gt;JEP 404: Generational Shenandoah (Experimental)&lt;/a&gt;提供了一個實驗性的分代模式，與其他分代收集器一樣分為年輕代和年老代，在 JDK25 轉為正式版本，不再需要&lt;code&gt;-XX:+UnlockExperimentalVMOptions&lt;/code&gt;命令&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h1_22"&gt;&lt;/span&gt; 
&lt;h1&gt;細項解讀&lt;/h1&gt; 
&lt;p&gt;上面列出的是大方面的特性，除此之外還有一些 api 的更新及廢棄，主要見&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2F25%2Frelease-notes" target="_blank"&gt;JDK 25 Release Notes&lt;/a&gt;，這裏舉幾個例子。&lt;/p&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt; 
&lt;h2&gt;添加項&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Support for reading all remaining characters from a Reader (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8354724" target="_blank"&gt;JDK-8354724&lt;/a&gt;) &amp;gt;java.io.Reader 新增了方法 readAllAsString 可以讀取剩餘字符到 String，新增 readAllLines 讀取剩餘字符到&lt;code&gt;List&amp;lt;string&amp;gt;&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;New connectionLabel Method in java.net.http.HttpResponse to Identify Connections (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350279" target="_blank"&gt;JDK-8350279&lt;/a&gt;) &amp;gt;對 HttpResponse 新增了 connectionLabel 方法用於關聯 connection&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;New Property to Construct ZIP FileSystem as Read-only (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350880" target="_blank"&gt;JDK-8350880&lt;/a&gt;) &amp;gt;新增 readOnly 支持 FileSystems.newFileSystem(pathToZipFile, Map.of("accessMode","readOnly"))&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Updates to ForkJoinPool and CompletableFuture (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8319447" target="_blank"&gt;JDK-8319447&lt;/a&gt;) &amp;gt;ForkJoinPool 做了更新以實現 ScheduledExecutorService，新增了 submitWithTimeout 方法支持 timeout 參數&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Thread Dumps Generated by HotSpotDiagnosticMXBean.dumpThreads and jcmd Thread.dump_to_file Updated to Include Lock Information (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8356870" target="_blank"&gt;JDK-8356870&lt;/a&gt;) &amp;gt;com.sun.management.HotSpotDiagnosticMXBean.dumpThreads 以及 jcmd &amp;lt;pid&amp;gt; Thread.dump_to_file 生成的線程堆棧現在包含了鎖信息&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;G1 Reduces Remembered Set Overhead by Grouping Regions into Shared Card Sets (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8343782" target="_blank"&gt;JDK-8343782&lt;/a&gt;) &amp;gt;以前每個 Region 都維護自己的 G1CardSet，導致內存佔用高，新設計在 Remark 階段之後，把預計會一起被清空的 Region 歸為一組，並分配同一個共享的 G1CardSet，省去了它們之間逐一跟蹤引用的開銷。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_24"&gt;&lt;/span&gt; 
&lt;h2&gt;移除項&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;java.net.Socket Constructors Can No Longer Be Used to Create a Datagram Socket (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8356154" target="_blank"&gt;JDK-8356154&lt;/a&gt;) &amp;gt;java.net.Socket 廢棄了兩個構造器，不再支持創建 datagram sockets，需要改為 java.net.DatagramSocket 替代&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Removal of PerfData Sampling (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8241678" target="_blank"&gt;JDK-8241678&lt;/a&gt;) &amp;gt;-XX:PerfDataSamplingInterval 這個被移除了&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_25"&gt;&lt;/span&gt; 
&lt;h2&gt;廢棄項&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Deprecate the Use of java.locale.useOldISOCodes System Property (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8353118" target="_blank"&gt;JDK-8353118&lt;/a&gt;) &amp;gt;java.locale.useOldISOCodes 這個屬性被廢棄了&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;The UseCompressedClassPointers Option is Deprecated (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350753" target="_blank"&gt;JDK-8350753&lt;/a&gt;) &amp;gt;UseCompressedClassPointers 這個參數被廢棄了，接下來將默認開啓壓縮類指針&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Various Permission Classes Deprecated for Removal (JDK-8348967, JDK-8353641, JDK-8353642, JDK-8353856, JDK-8347985, JDK-8351224, JDK-8351310) 以下這些 Permission 相關的類被標記廢棄&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;java.security.UnresolvedPermission
javax.net.ssl.SSLPermission
javax.security.auth.AuthPermission
javax.security.auth.PrivateCredentialPermission
javax.security.auth.kerberos.DelegationPermission
javax.security.auth.kerberos.ServicePermission
com.sun.security.jgss.InquireSecContextPermission
java.lang.RuntimePermission
java.lang.reflect.ReflectPermission
java.io.FilePermission
java.io.SerializablePermission
java.nio.file.LinkPermission
java.util.logging.LoggingPermission
java.util.PropertyPermission
jdk.jfr.FlightRecorderPermission
java.net.NetPermission
java.net.URLPermission
jdk.net.NetworkPermission
com.sun.tools.attach.AttachPermission
com.sun.jdi.JDIPermission
java.lang.management.ManagementPermission
javax.management.MBeanPermission
javax.management.MBeanTrustPermission
javax.management.MBeanServerPermission
javax.management.remote.SubjectDelegationPermission
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_26"&gt;&lt;/span&gt; 
&lt;h2&gt;已知問題修復&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;ZGC Now Avoids String Deduplication for Short-Lived Strings (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8347337" target="_blank"&gt;JDK-8347337&lt;/a&gt;) &amp;gt;ZGC 將避免對一些生命週期短的 String 進行 Deduplication，避免不必要的開銷&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;G1 Reduces Pause Time Spikes by Improving Region Selection (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8351405" target="_blank"&gt;JDK-8351405&lt;/a&gt;) &amp;gt;G1 在 Mixed GC 的時候會引起 pause time 飆升，此次通過 region 選擇進行了優化&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;No More OutOfMemoryErrors Due to JNI in Serial/Parallel GC (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8192647" target="_blank"&gt;JDK-8192647&lt;/a&gt;) &amp;gt;修復了 Serial/Parallel GC 因為 JNI 導致的 OOM&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_27"&gt;&lt;/span&gt; 
&lt;h2&gt;已知問題&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Regression in Serialization of LocalDate Class Objects (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8367031" target="_blank"&gt;JDK-8367031&lt;/a&gt;) 在 java.time 包中，若干類的序列化 Class 對象在 JDK 25 與早期版本之間不再兼容。受影響的具體類包括：LocalDate、YearMonth、MonthDay、HijrahDate 兼容性規則：如果把上述某個類的 Class 對象在早期版本序列化，再到 JDK 25 反序列化，或者反向操作，都會拋出 InvalidClassException，例如&lt;code&gt;writeObject(LocalDate.class)&lt;/code&gt; 但如果是序列化實例，則不受影響&lt;code&gt;writeObject(LocalDate.now())&lt;/code&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Performance Regression in java.lang.ClassValue::get (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8358535" target="_blank"&gt;JDK-8358535&lt;/a&gt;) 在 JDK 25 中，為了增強 ClassValue 在各種併發場景下的健壯性，JDK-8351996 對其進行了更新。 然而，這次改動導致：在調用 ClassValue.remove 之後，ClassValue.get 的執行速度明顯變慢。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;大多數應用不會直接使用 ClassValue，因此不會感知到這一退化。&lt;/li&gt; 
   &lt;li&gt;但若某個庫同時調用 ClassValue.get 與 remove（例如 Scala 2.12 的標準庫），就可能受到性能影響。 該性能回退已在 JDK-8358535 中被修復。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;-XX:+UseTransparentHugePages Fails to Enable Huge Pages for G1 (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8366434" target="_blank"&gt;JDK-8366434&lt;/a&gt;) 在把 Transparent Huge Pages（THP）模式設置為 madvise 的系統上， 即使啓動參數里加了 -XX:+UseTransparentHugePages，默認垃圾回收器 G1 也不會實際啓用大頁。臨時解決辦法：把 THP 模式改成 always，即可讓 G1 正常使用 Transparent Huge Pages：&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;# echo always &amp;amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;其他事項&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;Disabled SHA-1 in TLS 1.2 and DTLS 1.2 Handshake Signatures (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8340321" target="_blank"&gt;JDK-8340321&lt;/a&gt;)&lt;/li&gt; 
 &lt;li&gt;Compact Object Headers CDS Archive Generation and jlink Instruction (&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugs.openjdk.org%2Fbrowse%2FJDK-8350457" target="_blank"&gt;JDK-8350457&lt;/a&gt;)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_29"&gt;&lt;/span&gt; 
&lt;h1&gt;小結&lt;/h1&gt; 
&lt;p&gt;Java25 主要有如下幾個特性，其中核心庫改動有 JEP 502、JEP 505、JEP 506、JEP 508，語言規範類的有 JEP507、JEP 511、JEP 512、JEP 513。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F470" target="_blank"&gt;JEP 470: PEM Encodings of Cryptographic Objects (Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F502" target="_blank"&gt;JEP 502: Stable Values (Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F503" target="_blank"&gt;JEP 503: Remove the 32-bit x86 Port&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F505" target="_blank"&gt;JEP 505: Structured Concurrency (Fifth Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F506" target="_blank"&gt;JEP 506: Scoped Values&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F507" target="_blank"&gt;JEP 507: Primitive Types in Patterns, instanceof, and switch (Third Preview)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F508" target="_blank"&gt;JEP 508: Vector API (Tenth Incubator)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F509" target="_blank"&gt;JEP 509: JFR CPU-Time Profiling (Experimental)&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F510" target="_blank"&gt;JEP 510: Key Derivation Function API&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F511" target="_blank"&gt;JEP 511: Module Import Declarations&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F512" target="_blank"&gt;JEP 512: Compact Source Files and Instance Main Methods&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F513" target="_blank"&gt;JEP 513: Flexible Constructor Bodies&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F514" target="_blank"&gt;JEP 514: Ahead-of-Time Command-Line Ergonomics&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F515" target="_blank"&gt;JEP 515: Ahead-of-Time Method Profiling&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F518" target="_blank"&gt;JEP 518: JFR Cooperative Sampling&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F519" target="_blank"&gt;JEP 519: Compact Object Headers&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F520" target="_blank"&gt;JEP 520: JFR Method Timing &amp;amp; Tracing&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fjeps%2F521" target="_blank"&gt;JEP 521: Generational Shenandoah&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;gt;此次發佈了 18 個 JEP，整體概括如下： &amp;gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;JEP&lt;/th&gt; 
   &lt;th&gt;Title&lt;/th&gt; 
   &lt;th&gt;Status&lt;/th&gt; 
   &lt;th&gt;Project&lt;/th&gt; 
   &lt;th&gt;Feature Type&lt;/th&gt; 
   &lt;th&gt;Changes since Java 24&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;470&lt;/td&gt; 
   &lt;td&gt;PEM Encodings of Cryptographic Objects&lt;/td&gt; 
   &lt;td&gt;Preview&lt;/td&gt; 
   &lt;td&gt;Security Libs&lt;/td&gt; 
   &lt;td&gt;Security&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;502&lt;/td&gt; 
   &lt;td&gt;Stable Values&lt;/td&gt; 
   &lt;td&gt;Preview&lt;/td&gt; 
   &lt;td&gt;Core Libs&lt;/td&gt; 
   &lt;td&gt;New API&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;503&lt;/td&gt; 
   &lt;td&gt;Remove the 32-bit x86 Port&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot&lt;/td&gt; 
   &lt;td&gt;Deprecation&lt;/td&gt; 
   &lt;td&gt;Removal&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;505&lt;/td&gt; 
   &lt;td&gt;Structured Concurrency&lt;/td&gt; 
   &lt;td&gt;Fifth Preview&lt;/td&gt; 
   &lt;td&gt;Loom&lt;/td&gt; 
   &lt;td&gt;Concurrency&lt;/td&gt; 
   &lt;td&gt;Major&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;506&lt;/td&gt; 
   &lt;td&gt;Scoped Values&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Loom&lt;/td&gt; 
   &lt;td&gt;Concurrency&lt;/td&gt; 
   &lt;td&gt;Minor&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;507&lt;/td&gt; 
   &lt;td&gt;Primitive Types in Patterns, instanceof, and switch&lt;/td&gt; 
   &lt;td&gt;Third Preview&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;508&lt;/td&gt; 
   &lt;td&gt;Vector API&lt;/td&gt; 
   &lt;td&gt;Tenth Incubator&lt;/td&gt; 
   &lt;td&gt;Panama&lt;/td&gt; 
   &lt;td&gt;New API&lt;/td&gt; 
   &lt;td&gt;Minor&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;509&lt;/td&gt; 
   &lt;td&gt;JFR CPU-Time Profiling&lt;/td&gt; 
   &lt;td&gt;Experimental&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;510&lt;/td&gt; 
   &lt;td&gt;Key Derivation Function API&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Security Libs&lt;/td&gt; 
   &lt;td&gt;Security&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;511&lt;/td&gt; 
   &lt;td&gt;Module Import Declarations&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;512&lt;/td&gt; 
   &lt;td&gt;Compact Source Files and Instance Main Methods&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;Major&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;513&lt;/td&gt; 
   &lt;td&gt;Flexible Constructor Bodies&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Amber&lt;/td&gt; 
   &lt;td&gt;Language&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;514&lt;/td&gt; 
   &lt;td&gt;Ahead-of-Time Command-Line Ergonomics&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Leyden&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;515&lt;/td&gt; 
   &lt;td&gt;Ahead-of-Time Method Profiling&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;Leyden&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;518&lt;/td&gt; 
   &lt;td&gt;JFR Cooperative Sampling&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;519&lt;/td&gt; 
   &lt;td&gt;Compact Object Headers&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;None&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;520&lt;/td&gt; 
   &lt;td&gt;JFR Method Timing &amp;amp; Tracing&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / JFR&lt;/td&gt; 
   &lt;td&gt;Profiling&lt;/td&gt; 
   &lt;td&gt;New feature&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;521&lt;/td&gt; 
   &lt;td&gt;Generational Shenandoah&lt;/td&gt; 
   &lt;td&gt;&lt;/td&gt; 
   &lt;td&gt;HotSpot / GC&lt;/td&gt; 
   &lt;td&gt;Performance&lt;/td&gt; 
   &lt;td&gt;Stability and performance improvements&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;span id="OSC_h1_30"&gt;&lt;/span&gt; 
&lt;h1&gt;doc&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenjdk.org%2Fprojects%2Fjdk%2F25%2F" target="_blank"&gt;JDK 25 Features&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjdk.java.net%2F25%2Frelease-notes" target="_blank"&gt;JDK 25 Release Notes&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oracle.com%2Fjava%2Ftechnologies%2Fjavase%2F25all-relnotes.html" target="_blank"&gt;Consolidated JDK 25 Release Notes&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcr.openjdk.org%2F%7Eiris%2Fse%2F25%2FlatestSpec%2Fapi%2Fdeprecated-list.html" target="_blank"&gt;Java SE 25 deprecated-list&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.oracle.com%2Fjava%2Fpost%2Fthe-arrival-of-java-25" target="_blank"&gt;The Arrival of Java 25&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoq.com%2Fnews%2F2025%2F09%2Fjava25-released%2F" target="_blank"&gt;Java 25, the Next LTS Release, Delivers Finalized Features and Focus on Performance and Runtime&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoq.com%2Fnews%2F2025%2F08%2Fjava-25-so-far%2F" target="_blank"&gt;JDK 25 and JDK 26: What We Know So Far&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fjavaalmanac.io%2Fjdk%2F25%2F" target="_blank"&gt;The Java Version Almanac Java25&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ffoojay.io%2Ftoday%2Fheres-java-25-ready-to-perform-to-the-limit%2F" target="_blank"&gt;Here’s Java 25, Ready to Perform to the Limit&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsoftwaremill.com%2Fwhats-new-in-project-leyden-jep-514-and-jep-515-explained%2F" target="_blank"&gt;What's New in Project Leyden - JEP 514 and JEP 515 Explained&lt;/a&gt;&amp;lt;/pid&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/init&amp;gt;&amp;lt;/pid&amp;gt;&amp;lt;/pid&amp;gt;&amp;lt;/frameworkcontext&amp;gt;&amp;lt;/integer&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/product&amp;gt;&amp;lt;/logger&amp;gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/go4it/blog/18692176</link>
      <guid isPermaLink="false">https://my.oschina.net/go4it/blog/18692176</guid>
      <pubDate>Sun, 14 Sep 2025 05:58:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>OpenAI 聘請前 xAI 財務主管，強化算力預算管理</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.google.com%2Furl%3Fsa%3Di%26url%3Dhttps%253A%252F%252Fwww.reuters.com%252Fbusiness%252Fopenai-hires-former-xai-cfo-mike-liberatore-business-finance-officer-2025-09-16%252F%26psig%3DAOvVaw1QknnG70qRnWga8gudvwQg%26ust%3D1758167915712000%26source%3Dimages%26cd%3Dvfe%26opi%3D89978449%26ved%3D0CBkQjhxqFwoTCMCGror03o8DFQAAAAAdAAAAABAL" target="_blank"&gt;據報道&lt;/a&gt;，OpenAI 已任命 Mike Liberatore 為新任業務財務主管。他曾擔任埃隆·馬斯克旗下 AI 初創公司 xAI 的首席財務官，在任期間主導了 xAI 100 億美元融資，並推動數據中心規模擴張，於今年 7 月離職。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-d159e90d3a3da5826eaed3a33d5930373f1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據 OpenAI 透露，Liberatore 將向首席財務官 Sarah Friar 彙報，負責統籌公司數據中心與基礎設施的快速增長預算，並與 Greg Brockman 團隊緊密協作，管理算力戰略相關的合同與投資。&lt;/p&gt; 
&lt;p&gt;當前 OpenAI 估值已達 5000 億美元，此前剛與甲骨文簽署價值 3000 億美元的雲服務協議，此次人事任命被視為強化算力資源財務規劃的重要舉措。行業分析指出，隨着 AI 算力競爭加劇，具備大型算力項目資金運作經驗的人才愈發成為科技公司爭搶的焦點。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372713</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372713</guid>
      <pubDate>Sun, 14 Sep 2025 03:59:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>迪士尼、環球影業和華納兄弟起訴 MiniMax 涉嫌侵權</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;據《好萊塢報道者》消息，迪士尼、華納兄弟探索公司和環球影業已在加州聯邦法院正式起訴中國 AI 公司 MiniMax，指控其圖像與視頻生成服務「海螺 AI」大規模侵權，未經授權使用經典影視 IP 訓練模型並輸出作品。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;訴狀稱，MiniMax 以「口袋裏的好萊塢」自居，允許用户輸入「達斯·維德」或「小黃人」等知名角色生成畫面甚至短視頻，部分生成結果還帶有 MiniMax 水印。三大工作室指控，若無大規模盜用版權內容，MiniMax 無法實現此等輸出能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-a50b6ad55409cec1a43fbd40a0ba4474079.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;這起訴訟被視為好萊塢對生成式 AI 公司的一次高調反擊。近年來，從作家、唱片公司到新聞機構，多家版權方指控 AI 企業在未支付費用的情況下抓取、訓練、再創作，侵蝕了原有內容需求。就在本月初，華納、迪士尼和環球還共同起訴 Midjourney 涉嫌用影視作品訓練 AI 模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;美國電影協會（MPA）首席執行官 Charles Rivkin 在聲明中表示：「無論這些 AI 公司位於何處，我們都將讓其為侵犯美國創作者權益負責。若放任不管，版權侵權將威脅整個美國電影產業。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;訴狀中警告，隨着技術進步，「海螺 AI」未來可能生成與完整電影或劇集時長相當的未經授權視頻，構成對好萊塢的「生存威脅」。三大工作室要求法院判令 MiniMax 停止使用其知識產權並交出非法所得。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372711</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372711</guid>
      <pubDate>Sun, 14 Sep 2025 03:41:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>人形機器人公司 Figure 新一輪融資金額超 10 億美元，投後估值 390 億美元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;人工智能機器人公司 Figure&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.figure.ai%2Fnews%2Fseries-c" target="_blank"&gt;宣佈&lt;/a&gt;其 C 輪融資已獲超 10 億美元承諾資本，投後估值達 390 億美元。這筆資金將加速該公司將通用人形機器人大規模應用於現實環境的進程。&lt;/p&gt; 
&lt;p&gt;本輪融資由 Parkway Venture Capital 領投，博楓、英偉達、麥格理資本、英特爾資本、Salesforce 等公司參投。&lt;/p&gt; 
&lt;p&gt;Figure 成立於 2022 年，2023 年 3 月發佈首款通用人形機器人 Figure 01，曾獲 OpenAI、微軟、英偉達、英特爾以及亞馬遜創始人貝佐斯等投資，並在今年初終止了與 OpenAI 合作。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0917/112541_zLm4_2720166.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;本輪融資將推動公司 AI 平台 Helix 和 BotQ 製造體系的規模化擴張，推動人形機器人進入家庭和商業運營、建設新一代 GPU 基礎設施加速訓練與仿真，以及啓動先進數據收集計劃。&lt;/p&gt; 
&lt;p&gt;Figure 表示，此次融資將用於三個核心領域：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;將人形機器人擴展到家庭和商業運營。其正在擴大 BotQ 的生產製造和實際部署，使機器人能夠協助完成家庭和商業工作。&lt;/li&gt; 
 &lt;li&gt;構建下一代 GPU 基礎架構，加速訓練和模擬。該計算基礎將為 Helix 的感知、推理和控制核心模型提供支持。&lt;/li&gt; 
 &lt;li&gt;啓動先進的數據收集工作。這些工作包括收集人類視頻和多模態傳感輸入的數據，以提升機器人在複雜動態環境中的理解和操作能力，這些真實世界的數據集對於擴展 Helix 的功能至關重要。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;公開信息顯示，Figure 已經推出了兩款機器人產品，分別是 2023 年 10 月推出的 Figure01 以及 2024 年 8 月推出的 Figure02。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372709/figure-ai-series-c</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372709/figure-ai-series-c</guid>
      <pubDate>Sun, 14 Sep 2025 03:27:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Anthropic 的 Claude AI 正式上線 Xcode 26</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;Anthropic &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fclaude-in-xcode" target="_blank"&gt;宣佈&lt;/a&gt;其 AI 助手 Claude 現已在 Xcode 中正式發佈。Xcode 是 Apple 的集成開發環境 (IDE)，提供開發、測試和分發 Apple 平台 app 所需的工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此集成使開發者能夠直接在其工作流程中使用 Claude 的編碼功能，從而加速 Apple 平台 app 的開發。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-f1b1f259b122dd9bb17e50753c081ef8e97.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;當用户在 Xcode 中登錄其 Claude 帳户時，將可以訪問由 Claude Sonnet 4 提供支持的編碼智能功能，包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;編碼助手：使用自然語言與你的代碼交互。Claude 會自動收集您項目中的上下文，並支持對話歷史記錄和文件附件，以幫助調試、重構和構建功能。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;編碼工具：為代碼生成文檔，獲取高亮顯示部分的解釋，創建 SwiftUI 預覽和遊樂場，並直接在編輯器中進行內聯代碼更改&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Claude 在 Xcode 中的上線與現有訂閲計劃緊密相連，使用限制在各個平台間共享，併為 Xcode 集成分配了一部分額度。該功能對 Pro 和 Max 計劃用户開放，同時也適用於擁有 Claude Code 的 Team 和 Enterprise 客户的高級座位。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:auto; margin-right:auto; text-align:start"&gt;&lt;span style="color:#000000"&gt;要在 Xcode 中開始使用 Claude：&lt;/span&gt;&lt;/p&gt; 
&lt;ol style="margin-left:auto; margin-right:auto"&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;從 Mac App Store 下載&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fapps.apple.com%2Fus%2Fapp%2Fxcode%2Fid497799835%3Fmt%3D12" target="_blank"&gt;Xcode 26&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;打開 Xcode 首選項設置並導航至 Intelligence 設置&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;使用你的 Claude 帳户登錄&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372706/claude-in-xcode</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372706/claude-in-xcode</guid>
      <pubDate>Sun, 14 Sep 2025 03:18:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>MySQL 單表為何別超 2000 萬行？揭秘 B + 樹與 16KB 頁的生死博弈</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、前，言&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;本文核心介紹，為何業界會有這樣的説法？—— 「MySQL 單表存儲數據量最好別超過千萬級別」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;當然這裏是有前提條件的，也是我們最常使用到的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;InnoDB 存儲引擎；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用的是默認索引數據結構——B+樹;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;正常普通表數據（列數量控制在幾個到一二十個，普通字段類型及長度）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;接下來咱們就探究一下原因，逐步揭開答案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、MySQL 是如何存儲數據的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心結構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：B+樹 + 16KB 數據頁&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這裏如下，建一張普通表 user：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;TABLE&amp;nbsp;`user` (
&amp;nbsp; `id`&amp;nbsp;int(10) unsigned&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;AUTO_INCREMENT COMMENT&amp;nbsp;'主鍵',
&amp;nbsp; `name`&amp;nbsp;varchar(100)&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;DEFAULT&amp;nbsp;''&amp;nbsp;COMMENT&amp;nbsp;'名字',
&amp;nbsp; `age`&amp;nbsp;int(11)&amp;nbsp;NOT&amp;nbsp;NULL&amp;nbsp;DEFAULT&amp;nbsp;'0'&amp;nbsp;COMMENT&amp;nbsp;'年齡',
&amp;nbsp;&amp;nbsp;PRIMARY&amp;nbsp;KEY (`id`),
&amp;nbsp; KEY `idx_age` (`age`)
) ENGINE=InnoDB AUTO_INCREMENT=1&amp;nbsp;DEFAULT&amp;nbsp;CHARSET=utf8;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;數據頁（Page）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;介紹&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;InnoDB 存儲的最小單位，固定為 16KB 。每頁存儲表數據（行記錄）、索引、元信息等。數據加載到內存時以頁為單位，減少磁盤 I/O 次數。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;頁的結構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設我們有這麼一張 user 數據表。其中 id 是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;唯一主鍵&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。這看起來的一行行數據，為了方便，我們後面就叫它們&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;record&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;吧。這張表看起來就跟個 excel 表格一樣。excel 的數據在硬盤上是一個 xx.excel 的文件。而上面 user 表數據，在硬盤上其實也是類似，放在了 user.&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ibd&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文件下。含義是 user 表的 innodb data 文件，又叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;表空間&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。雖然在數據表裏，它們看起來是挨在一起的。但實際上在 user.ibd 裏他們被分成很多小份的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;數據頁&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，每份大小 16k。類似於下面這樣。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9b9aed13809533763885cd45c2c3c452.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ibd 文件內部有大量的頁，我們把視角聚焦一下，放到頁上面。整個頁 16k，不大，但 record 這麼多，一頁肯定放不下，所以會分開放到很多頁裏。並且這 16k，也不可能全用來放 record 對吧。因為 record 們被分成好多份，放到好多頁裏了，為了唯一標識具體是哪一頁，那就需要引入&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;頁號&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（其實是一個表空間的地址偏移量）。同時為了把這些數據頁給關聯起來，於是引入了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前後指針&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，用於指向前後的頁。這些都被加到了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;頁頭&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;裏。頁是需要讀寫的，16k 説小也不小，寫一半電源線被拔了也是有可能發生的，所以為了保證數據頁的正確性，還引入了校驗碼。這個被加到了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;頁尾&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。那剩下的空間，才是用來放我們的 record 的。而 record 如果行數特別多的話，進入到頁內時挨個遍歷，效率也不太行，所以為這些數據生成了一個&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;頁目錄&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，具體實現細節不重要。只需要知道，它可以通過&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;二分查找&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的方式將查找效率&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;從 O(n) 變成 O(lgn)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5644e7c12d54b5405bdbc8af995203e7.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;從頁到索引—B+樹索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果想查一條 record，我們可以把表空間裏每一頁都撈出來（全表掃描），再把裏面的 record 撈出來挨個判斷是不是我們要找的。行數量小的時候，這麼操作也沒啥問題。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行數量大了，性能就慢了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，於是為了加速搜索，我們可以在每個數據頁裏選出&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主鍵 id 最小&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的 record，而且只需要它們的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主鍵 id 和所在頁的頁號&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。組成&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新的 record&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，放入到一個新生成的一個數據頁中，這個&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新數據頁跟之前的頁結構沒啥區別，而且大小還是 16k&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。但為了跟之前的數據頁進行區分。數據頁里加入了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;頁層級（page level）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的信息，從 0 開始往上算。於是頁與頁之間就有了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上下層級&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的概念，就像下面這樣。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d641ebd9ddee61101bb3edff7f27edf2.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;突然頁跟頁之間看起來就像是一棵倒過來的樹了。也就是我們常説的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;樹索引。最下面那一層，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;page level 為 0&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，也就是所謂的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;葉子結點&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，其餘都叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非葉子結點&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。上面展示的是兩層的樹，如果數據變多了，我們還可以再通過類似的方法，再往上構建一層。就成了三層的樹。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;聚簇索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：數據按主鍵組織成一棵 B+樹。葉子節點存儲完整行數據 ，非葉子節點存儲主鍵值+指向子頁的指針（類似目錄）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;二級索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：葉子節點存儲主鍵值，查詢時需回表（根據主鍵回聚簇索引查數據）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行格式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;COMPACT&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;格式，行數據包含&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;事務 ID&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;回滾指針&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;列值&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等信息。&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;行大小影響單頁存儲的行數&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;存入數據如下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;比如表數據已存在 id 為 1-10 的數據存儲，簡單比方如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b4d13ed1425d3f157f13749219d2aba9.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;然後需要插入 id=11 的數據：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;加載 1 號數據頁入內存，分析判定；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;id=11 的數據大於 id=10，那麼鎖定頁號 5，判定 5 號頁是否還可以存下數據 11；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以存下，將 id=11 的數據寫入到 5 號頁中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5b6dacd1a27fdcf9e5b876addc310822.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;關鍵原理總結&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;所有數據通過 B+樹有序組織，數據存儲在數據頁上，頁與頁之間以雙向鏈表連接，非葉子節點提供快速定位路徑，葉子節點存儲實際的數據。&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、MySQL 是如何查詢到數據的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上面我們已經介紹了 MySQL 中使用頁存儲數據，以及 B+樹索引數據的結構，那現在我們就可以通過這樣一棵 B+樹加速查詢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;舉個例子：select *&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;from table where id = 5&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;比方説我們想要查找行數據 5。會先從頂層頁的 record 們入手。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;record 裏包含了主鍵 id 和頁號（頁地址）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如下圖所示，左邊 2 號頁最小 id 是 1，向右 3 號頁最小 id 是 4，然後 4 號頁最小是 7，最後 5 號頁最小是 10。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c8994b6f3c261d86ffb79ee6e1aab7c6.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那 id=5 的數據如果存在，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;5 大於 4 小於 7，那必定在 3 號頁裏面&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。於是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;順着的 record 的頁地址就到了 3 號數據頁裏&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，於是加載 3 號數據頁到內存。在數據頁裏找到 id=5 的數據行，完成查詢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;另外需要注意的是，上面的頁的頁號並不是連續的，它們在磁盤裏也不一定是挨在一起的。這個過程中查詢了 2 個頁（1 號跟 3 號），如果這三個頁都在磁盤中（沒有被提前加載到內存中），那麼&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最多&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要經歷兩次&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盤 IO 查詢&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，它們才能被加載到內存中。（如果考慮 1 號如果是 root 常駐內存，那麼需要磁盤 IO 一次即可定位到）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//0183a1e293ff7baff192716d58a437d0.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;查詢步驟總結&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;以聚簇索引搜索為例（假設 id 是主鍵）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;從根頁開始搜索 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;加載根頁（常駐內存）到 Buffer Pool，根據指針找到下一層節點。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;逐層定位葉子節點 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在非葉子節點頁（存儲主鍵+指針）中二分查找 ，定位 id=5 所在範圍的子頁（如頁 A）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;重複此過程，直到葉子節點頁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;葉子節點二分查找 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在葉子頁內通過主鍵二分查找定位到行記錄，返回完整數據。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;I/O 次數分析 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;樹高為 3 時：根頁 + 中間頁 + 葉子頁 = 3 次磁盤 I/O （若頁不在內存中）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹矮胖特性 ：3 層即可支撐千萬級數據（接下來分析），是高效查詢的基礎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、2000 萬這個上限值如何算出來的？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在我們清楚了 MySQL 是如何存儲及查詢數據後，那麼 2000 萬這個數值又是如何得來的呢？超過 2000 萬比如存儲一億數據會如何？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹承載的記錄數量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;從上面的結構裏可以看出 B+樹的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最末級葉子結點&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;裏放了 record 數據。而&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非葉子結點&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;裏則放了用來加速查詢的索引數據。也就是説同樣一個 16k 的頁，非葉子節點裏每一條數據都指向一個新的頁，而新的頁有兩種可能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是末級葉子節點的話，那麼裏面放的就是一行行 record 數據。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是非葉子節點，那麼就會循環繼續指向新的數據頁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非葉子節點內指向其他內存頁的指針數量為 x（非葉子節點指針扇出值）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;葉子節點內能容納的 record 數量為 y（葉子節點單頁行數）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹的層數為 z（樹高）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那這棵 B+樹放的&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;行數據總量等於 (x ^ (z-1)) * y&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心公式：&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;單表最大行數 = 非葉節點扇出指針數 ^ (樹高-1) × 單頁行數&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;非葉子節點指針扇出值—x 怎麼算？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們回去看數據頁的結構。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b0e2c5fe5bd7722205025f6d096c4165.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;非葉子節點裏主要放索引查詢相關的數據，放的是主鍵和指向頁號。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;主鍵假設是 bigint（8Byte），而頁號在源碼裏叫 FIL_PAGE_OFFSET（4Byte），那麼非葉子節點裏的一條數據是 12Byte 左右。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;整個數據頁 16k， 頁頭頁尾那部分數據全加起來大概 128Byte，加上頁目錄毛估佔 1k 吧。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那剩下的 15k 除以 12Byte，等於 1280，也就是可以指向 x=1280 頁。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們常説的二叉樹指的是一個結點可以發散出兩個新的結點。m 叉樹一個節點能指向 m 個新的結點。這個指向新節點的操作就叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;扇出（fanout）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。而上面的 B+樹，它能指向 1280 個新的節點，恐怖如斯，可以説&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;扇出非常高&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;單頁行數—y 的計算&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;葉子節點和非葉子節點的數據結構是一樣的，所以也假設剩下 15kb 可以發揮。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;葉子節點裏放的是真正的行數據。假設一條行數據 1kb，所以一頁裏能放&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;y=15 行&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;行總數計算&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;回到 (x ^ (z-1)) * y 這個公式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;已知 x=1280，y=15。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設 B+樹是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;兩層&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，那 z=2。則是 (1280 ^ (2-1)) * 15 ≈ 2w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設 B+樹是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;三層&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;，那 z=3。則是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;(1280 ^ (3-1)) * 15 ≈ 2.5kw&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這個 2.5kw，就是我們常説的單表建議最大行數 2kw 的由來。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;畢竟再加一層，數據就大得有點離譜了。三層數據頁對應最多三次磁盤 IO，也比較合理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;臨界點 ：當行數突破約 2000 萬時，樹高可能從 3 層變為 4 層：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;樹高=4 時：最大行數 ≈ 1280^3 × 15 結果已超過百億（遠大於 2000 萬）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;性能斷崖 ：樹高從 3→4，查詢 I/O 次數從 3 次增至 4 次 （多一次磁盤尋址），尤其在回表查詢、高併發、深分頁時性能驟降。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;行數超一億就慢了嗎？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;上面假設單行數據用了 1kb，所以一個數據頁能放個 15 行數據。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果我單行數據用不了這麼多，比如只用了 250byte。那麼單個數據頁能放 60 行數據。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;那同樣是三層 B+樹，單表支持的行數就是 (1280 ^ (3-1)) * 60 ≈ 1 個億。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;你看我一個億的數據，其實也就三層 B+樹，在這個 B+樹裏要查到某行數據，最多也是三次磁盤 IO。所以並不慢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;B 樹承載的記錄數量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們都知道，現在 MySQL 的索引都是 B+樹，而有一種樹，跟 B+樹很像，叫&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B 樹，也叫 B-樹&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;它跟 B+樹最大的區別在於，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹只在末級葉子結點處放數據錶行數據，而 B 樹則會在葉子和非葉子結點上都放。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;於是，B 樹的結構就類似這樣：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//0e4feea3dedf77739c444c8427ea9bcf.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B 樹將行數據都存在非葉子節點上，假設每個數據頁還是 16kb，掐頭去尾每頁剩 15kb，並且一條數據錶行數據還是佔 1kb，就算不考慮各種頁指針的情況下，也只能放個 15 條數據。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;數據頁扇出明顯變少了&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;計算可承載的總行數的公式也變成了一個&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;等比數列&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;15 + 15^2 +15^3 + ... + 15^z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;其中&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;z 還是層數&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;的意思。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;為了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;能放 2kw 左右的數據，需要 z&amp;gt;=6&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。也就是樹需要有 6 層，查一次要訪問 6 個頁。假設這 6 個頁並不連續，為了查詢其中一條數據，最壞情況需要進行&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;6 次磁盤 IO&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;而 B+樹同樣情況下放 2kw 數據左右，查一次最多是&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;3 次磁盤 IO&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盤 IO 越多則越慢，這兩者在性能上差距略大。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;為此，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹比 B 樹更適合成為 MySQL 的索引&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、總結：生死博弈的核心&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹葉子和非葉子結點的數據頁都是 16k，且數據結構一致，區別在於葉子節點放的是真實的行數據，而非葉子結點放的是主鍵和下一個頁的地址。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;B+樹一般有兩到三層，由於其高扇出，三層就能支持 2kw 以上的數據，且一次查詢最多 1~3 次磁盤 IO，性能也還行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;存儲同樣量級的數據，B 樹比 B+樹層級更高，因此磁盤 IO 也更多，所以 B+樹更適合成為 MySQL 索引。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;索引結構不會影響單表最大行數，2kw 也只是推薦值，超過了這個值可能會導致 B+樹層級更高，影響查詢性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;單表最大值還受主鍵大小和磁盤大小限制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;16KB 頁與 B+樹的平衡 ：頁大小限制了單頁行數和指針數，B+樹通過多階平衡確保低樹高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;2000 萬不是絕對 ：若行小於 1KB（如只存 ID），上限可到 5000 萬+；若行較大（如含大字段），可能 500 萬就性能下降。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;優化建議：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;控制單行大小（避免&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;TEXT/BLOB&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;直接入表）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;分庫分表：單表接近千萬級時提前規劃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;冷熱分離：歷史數據歸檔。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;本質：通過頁大小和 B+樹結構，MySQL 在磁盤 I/O 和內存效率之間取得平衡。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;超出平衡點時，性能從「平緩下降」變為「斷崖下跌」。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;六、拓展問題&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;為啥設計單頁大小 16k?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;MySQL 索引採用的是 B+樹數據結構，每個葉子節點（葉子塊）存儲一個索引條目的信息。而 MySQL 使用的是頁式存儲（Paged storage）技術，將磁盤上的數據劃分為一個個固定大小的頁面，每個頁面包含若干個索引條目。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;為了提高索引查詢效率和降低磁盤 I/O 的頻率，MySQL 設置了 16KB 的單頁大小。這是因為在 MySQL 中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;內存大小限制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：MySQL 的索引需要放在內存中進行查詢，如果頁面過大，將導致索引無法完全加載到內存中，從而影響查詢效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;磁盤 I/O 限制：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;當需要查詢一個索引時，MySQL 需要把相關的頁面加載到內存中進行處理，如果頁面過大，將增加磁盤 I/O 的開銷，降低查詢效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;索引效率限制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：在 B+樹數據結構中，每個葉子節點存儲着一個索引條目，因此如果每個頁面能夠存放更多索引條目，就可以減少 B+樹結構的深度，從而提高索引查詢效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;綜上所述，MySQL 索引單頁大小設置為 16KB 可以兼顧內存大小、磁盤 I/O 和索引查詢效率等多方面因素，是一種比較優化的方案。需要注意的是，對於某些特殊的應用場景，可能需要根據實際情況對單頁大小進行調整。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;字符串怎麼做索引?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 MySQL 中，可以通過 B+樹索引結構對字符串類型的列進行排序。具體來説，當使用 B+樹索引進行排序時，MySQL 會根據字符串的字典序（Lexicographic Order）進行排序。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;字典序是指將字符串中的每個字符依次比較，直到找到不同的字符為止。如果兩個字符串在相同的位置上具有不同的字符，則以這兩個字符的 ASCII 碼值比較大小，並按照升序或降序排列。例如，字符串"abc"和"def"比較大小時，先比較'a'和'd'的 ASCII 碼，因為'd'的 ASCII 碼大於'a'，所以"def"大於"abc"。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，如果對長字符串進行排序，可能會影響索引查詢的性能，因此可以考慮使用前綴索引或全文索引來優化。同時，在實際開發中，還需要注意選擇適當的字符集和排序規則，以確保排序結果正確和穩定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;中文字符串怎麼做索引?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;中文字符串排序在 MySQL 中可以使用多種方式，最常見的有以下兩種：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;按拼音排序：對於中文字符串，可以按照拼音進行排序。可以使用拼音排序插件，如 pinyin 或 zhuyin 插件，來實現中文字符串按照拼音進行排序。這些插件會將中文字符串轉換為拼音或注音後，再進行排序。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如，先安裝 pinyin 插件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;INSTALL&amp;nbsp;PLUGIN pinyin SONAME&amp;nbsp;'ha_pinyin.so';&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;然後創建對應的索引並按拼音排序：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;INDEX idx_name_pinyin&amp;nbsp;ON&amp;nbsp;mytable(name)&amp;nbsp;USING&amp;nbsp;BTREE&amp;nbsp;WITH&amp;nbsp;PARSER pinyin;
SELECT&amp;nbsp;*&amp;nbsp;FROM&amp;nbsp;mytable&amp;nbsp;ORDER&amp;nbsp;BY&amp;nbsp;name&amp;nbsp;COLLATE&amp;nbsp;pinyin;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;按 Unicode 碼點排序：可以使用 UTF-8 字符集，並選擇 utf8mb4_unicode_ci 排序規則，在使用此排序規則時，MySQL 會按照 Unicode 碼點進行排序，適合於較為通用的中文字符串排序需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CREATE&amp;nbsp;INDEX idx_name_unicode&amp;nbsp;ON&amp;nbsp;mytable(name)&amp;nbsp;USING&amp;nbsp;BTREE;
SELECT&amp;nbsp;*&amp;nbsp;FROM&amp;nbsp;mytable&amp;nbsp;ORDER&amp;nbsp;BY&amp;nbsp;name&amp;nbsp;COLLATE&amp;nbsp;utf8mb4_unicode_ci;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，不同的排序方式可能會對性能產生影響，因此需要根據具體需求選擇合適的排序方式，並進行必要的測試和驗證。同時，在進行中文字符串排序時，還需要考慮到中文字符的複雜性，例如同音字、繁簡體等問題，以確保排序結果正確和穩定。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;索引字段的長度有限制嗎?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 MySQL 中，索引的長度通常是由三個因素決定的：數據類型、字符集和存儲引擎。不同的數據類型、字符集和存儲引擎所支持的最大索引長度也有所不同。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;一般情況下，索引的長度不應該超過存儲引擎所支持的最大索引長度。在 InnoDB 存儲引擎中，單個索引所能包含的最大字節數為 767 個字節（前綴索引除外）。如果索引的長度超過了最大長度，則會導致創建索引失敗。因此，在設計表結構時，需要根據索引列的數據類型和字符集等因素，合理設置索引長度，以充分利用索引的優勢。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;對於字符串類型的索引，還需要注意以下幾點：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;對於 UTF-8 字符集，每個字符佔用 1-4 個字節，因此索引長度需要根據實際情況進行計算。例如，一個 VARCHAR(255) 類型的列在 utf8mb4 字符集下的最大長度為 255*4=1020 個字節。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以使用前綴索引來減少索引的大小，提高索引查詢效率。在創建前綴索引時需要指定前綴長度。例如，可以在創建索引時使用 name(10) 來指定 name 列的前 10 個字符作為索引。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在使用全文索引對字符串進行搜索時，MySQL 會將文本內容分割成單個詞彙後建立倒排索引。在建立索引時需要考慮到中英文分詞的問題，以確保全文索引的準確性和查詢效率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;綜上所述，索引的長度需要根據數據類型、字符集和存儲引擎等多個因素進行綜合考慮，併合理設置索引長度，以提高索引查詢效率和利用率。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顧&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1. 0 基礎帶你精通 Java 對象序列化--以 Hessian 為例｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2. 前端日誌回撈系統的性能優化實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3. 得物靈犀搜索推薦詞分發平台演進 3.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4. R8 疑難雜症分析實戰：外聯優化設計缺陷引起的崩潰｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5. 可擴展系統設計的黃金法則與 Go 語言實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;文 / 太空&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:center"&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18691996</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18691996</guid>
      <pubDate>Sun, 14 Sep 2025 03:02:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>全球首個 AI Agent 交易市場「MuleRun」正式上線</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fmulerun_ai%2Fstatus%2F1967623169180852241" target="_blank"&gt;據 Mulerun 官方消息&lt;/a&gt;，全球首個 AI Agent 交易市場 MuleRun（騾子快跑）正式上線，為 AI 數字勞動力提供一站式交易服務，鏈接全球 Agent 創作者與用户。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f576ceaaa2d77e9886ceed60e1de842ad4e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://mulerun.com/&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;自 8 月 14 日內測以來，平台已湧現多款熱門 Agent 產品，涵蓋遊戲自動化、3D 建模、美股研報生成、社交媒體內容創作等場景。中國創作者 Laughing 的遊戲任務助手、芋頭小寶的 3D 建模工具等已實現商業化變現。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0917/104332_mrJD_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;為扶持全球創作者，MuleRun 推出三重支持計劃：現金激勵最高達 1 萬美元，配套全球社交媒體流量曝光，並提供從開發到上架的全流程技術工具。新用户註冊可獲 1000 積分，邀請好友再得 500 積分，可用於體驗平台內 Agent 服務。該平台的上線標誌着 AI 數字勞動力進入規模化商用階段。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372699</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372699</guid>
      <pubDate>Sun, 14 Sep 2025 02:44:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>粵港澳大灣區生成式人工智能安全發展聯合實驗室正式成立</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;粵港澳大灣區生成式人工智能安全發展聯合實驗室（以下簡稱「聯合實驗室」）揭牌儀式 15 日在深圳舉行。&lt;/p&gt; 
&lt;p&gt;該實驗室將通過制定行業安全發展標準、搭建粵語語料庫資源平台、支撐模型備案安全評估、舉辦前沿技術成果發佈等多元形式，服務企業發展、推動產業落地、加強安全監管，助力大灣區成為智能技術創新的策源地、智能產業融合的增長極、智能安全治理的先行區。&lt;/p&gt; 
&lt;p&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-852af8bd4285a36f57b575c545439f8a231.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;聯合實驗室是一個適應人工智能時代敏捷、彈性、高效的創新治理聯合體，由國家互聯網應急中心作為指導單位，廣東省委網信辦和國家互聯網應急中心廣東分中心聯合牽頭，粵港澳大灣區相關部門、企業、高校、科研機構、媒體等共同參與建設，運行主體常設在河套深港科技創新合作區，並視情在香港、澳門、廣州、珠海、東莞等地設立地方服務站。&lt;/p&gt; 
&lt;p&gt;「這兩年人工智能發展日新月異，在產業快速發展的同時，安全和可控的重要性也日益凸顯。」聯合實驗室理事、廣州雲蝶科技有限公司創始人田雪松表示，聯合實驗室的建設，將進一步提升廣東省內人工智能和大模型企業的軟實力，在全國乃至全球的競爭中形成差異化優勢，助力廣東人工智能和大模型產業發展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372698</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372698</guid>
      <pubDate>Sun, 14 Sep 2025 02:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>龍芯首款 GPGPU 芯片 9A1000 預計在三季度內交付流片</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;龍芯科技 9A1000 顯卡於 2023 年開始研發，如今距離最終定稿又近了一步。龍芯中科近日在互動平台回覆稱，龍芯首款 GPGPU 芯片 9A1000 的研發基本完成，三季度內會交付流片。成功與否需待流片回來後的測試結果。&lt;/p&gt; 
&lt;p&gt;9A1000 是龍芯的首款顯卡，對於這家此前主要專注於處理器的中國製造商來説，這是一個重要的里程碑。該公司將 9A1000 定位為支持 AI 加速的入門級顯卡。因此，它與另一款據稱可與 GeForce RTX 4060 匹敵的中國顯卡 Lisuan G100 並不在同一細分市場競爭。&lt;/p&gt; 
&lt;p&gt;依據此前的官方資料報道，龍芯 9A1000 顯卡芯片的一大亮點在於對 PCIe 4.0 系統總線的支持，並且適配 128-bit LPDDR4X 高速顯存。儘管具體的計算核數、顯存規模、運作頻率及功耗數據尚未公佈，但從已曝光的結構圖中可窺見其佈局了八大計算集羣，輔以片上互聯網絡與二級緩存機制，預示着不俗的內部架構設計。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-cabb7c2678084d3f57350c795c9369bf4b7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在軟件兼容層面，龍芯 9A1000 全面擁抱 OpenGL 4.0、OpenCL 3.0 等行業主流圖形與計算 API，內置專業級視頻處理組件，硬解碼能力覆蓋 H.264、H.265 編解碼標準，同時支持 HDMI 2.1、DisplayPort 1.4 以及經典的 VGA 等多種顯示輸出協議。&lt;/p&gt; 
&lt;p&gt;深入剖析其性能規格，龍芯 9A1000 擁有高達 16GP/s（每秒 160 億個像素點）的像素填充速率，紋理填充速率為 32GT/s（每秒 320 億個紋理元素），浮點運算能力可達 FP32 精度下 1TFLOPS（每秒 1 萬億次）、FP64 精度下 64GFLOPs（每秒 640 億次），而在 INT8 整數運算環境下則飆升至 32TFLOPS（每秒 32 萬億次）。這些指標共同描繪了一個兼顧圖形渲染與深度學習加速的強大計算平台輪廓。&lt;/p&gt; 
&lt;p&gt;9A1000 的最新更新表明，龍芯已將流處理器的面積縮小了 20%。製造商還聲稱，9A1000 的工作頻率提高了 25%，同時輕負載下的功耗優化了 70%。在功能方面，9A1000 支持 OpenGL 4.0 和 OpenCL ES 3.2 API。&lt;/p&gt; 
&lt;p&gt;龍芯表示，9A1000 的速度比 2K3000 處理器內置的集成顯卡 LG200 快 4 倍。9A1000 還提供高達 40 TOPS 的 AI 計算能力，略低於 AMD Ryzen AI Max+（代號 Strix Halo）芯片內置的 XDNA 2 NPU（高達 50 TOPS）。&lt;/p&gt; 
&lt;p&gt;9A1000 並非龍芯唯一的顯卡產品。該公司還在研發 9A2000，據稱其速度比 9A1000 快 10 倍，性能水平堪比 GeForce RTX 2080。此外，龍芯還計劃推出 9A3000，作為 9A2000 的後續產品，但目前尚不清楚具體規格。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372696</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372696</guid>
      <pubDate>Sun, 14 Sep 2025 02:39:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通義推出開源 Web Agent：Tongyi DeepResearch</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通義實驗室發佈並開源了 Tongyi DeepResearch，據稱是首個性能對標 OpenAI Deep Research 的開源 Web Agent。&lt;/p&gt; 
&lt;p&gt;這是一款採用 30B 總參數、每 token 僅激活 3B 的 MoE 結構的模型。它擁有 128K 的上下文長度，並支持 ReAct 與 IterResearch 兩種推理範式。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-c92bc06df52b3f054ac8a570b944b55cf72.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Tongyi DeepResearch 作為完全開源的 Web Agent。該項目的核心貢獻不僅在於模型本身，更在於一套完整的、端到端的智能體訓練方法論 。其關鍵技術包括：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;全流程數據合成：不依賴昂貴的人工標註，通過創新的數據合成方案，為智能體的持續預訓練（CPT）、監督微調（SFT）和強化學習（RL）提供海量高質量數據 。&lt;/li&gt; 
 &lt;li&gt;端到端訓練框架：建立了一個從「智能體持續預訓練」到「智能體強化學習」的無縫訓練循環，並採用定製化的在策略（on-policy）強化學習算法（GRPO）來對齊模型行為 。&lt;/li&gt; 
 &lt;li&gt;創新的推理模式：除了標準的 ReAct 模式，還開發了基於 IterResearch 範式的「重模式」（Heavy Mode），通過解構任務和重組工作區來克服長程任務中的「認知窒息」問題，從而最大化模型的推理和規劃潛力 。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;該模型及其全套解決方案已在 GitHub、HuggingFace 與 ModelScope 上線。配套的 Python 3.10 環境、JSONL 評測腳本以及 benchmark 評估工具也已一併開源，方便開發者使用和評估。&lt;/p&gt; 
&lt;p&gt;首頁：https://tongyi-agent.github.io&amp;nbsp;&lt;br&gt; 博客: https://tongyi-agent.github.io/blog/introdung-tongyi-deep-research/&amp;nbsp;&lt;br&gt; GitHub 倉庫: https://github.com/Alibaba-NLP/DeepResearch&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372685/tongyi-deep-research</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372685/tongyi-deep-research</guid>
      <pubDate>Sun, 14 Sep 2025 02:18:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>國內首個 AI 大模型眾測結果出爐，發現 281 個安全漏洞</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在第 22 屆中國網絡安全年會（暨國家網絡安全宣傳週網絡安全協同防禦分論壇）上，國內&lt;span&gt;首次&lt;/span&gt;針對 AI 大模型的眾測結果揭曉。此次活動由中央網信辦網絡安全協調局指導，國家計算機網絡應急技術處理協調中心主辦，吸引了 559 名白帽子安全專家參與，對 15 款 AI 大模型和應用產品進行了全面的安全漏洞測試。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這項測試涵蓋了從基礎大模型到智能體和模型開發平台等多種產品，旨在從攻擊者的角度發掘潛在的安全隱患。結果顯示，共發現各類安全漏洞高達 281 個，其中大模型特有漏洞就有 177 個，比例超過 60%。這説明，AI 大模型在安全性方面面臨着傳統安全領域之外的許多新興風險。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;測試中揭示的典型漏洞風險包括:部分產品存在嚴重的輸出不當漏洞，信息泄露類漏洞頻發，提示注入類漏洞也是一種普遍風險。此外，儘管一些大模型產品已經具備一定的防護能力，但對抗無限制消耗攻擊的措施仍需加強。值得注意的是，傳統的安全漏洞依然普遍，必須引起足夠的重視。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在參與測試的主流大模型產品中，騰訊的混元大模型、百度的文心一言和阿里巴巴的通義 App 等，發現的漏洞相對較少，顯示出較高的安全防護水平。這一結果為廣大用户和開發者帶來了信心。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;活動最後，官方提出了四項 AI 大模型安全治理工作要求，強調了未來的防護措施和漏洞管理的重要性，包括加強安全防護、制定漏洞分類標準、鼓勵社會白帽力量的參與，以及在 AI 系統全生命週期中融入安全管理。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372683</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372683</guid>
      <pubDate>Sun, 14 Sep 2025 02:06:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>第二屆「AI 寧波」人工智能賦能產業大賽火熱報名中</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;為推動人工智能技術與產業深度融合，賦能產業創新發展，第二屆 「AI 寧波」 人工智能賦能產業大賽正式向全球發出邀請 —— 誠邀人工智能領域的精英團隊、科研人才踴躍報名，共赴這場 AI 賦能產業的創新盛宴！&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0917/095632_fuFY_2720166.jpeg" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372679</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372679</guid>
      <pubDate>Sun, 14 Sep 2025 01:56:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>🚀 效率革命！AI 低代碼引擎發佈 0.13.25 版本，設計師和開發者終於能説同一種</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;blockquote&gt; 
 &lt;p style="margin-left:0; margin-right:0"&gt;一鍵複製粘貼跨頁面，17 個快捷鍵讓開發效率飆升 50%&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;業內領先的開源 AI 低代碼開發引擎&lt;strong&gt;VTJ.PRO&lt;/strong&gt;再次帶來重磅更新！最新發布的 0.13.25 版本中，編輯器正式&lt;strong&gt;支持快捷鍵操作&lt;/strong&gt;和&lt;strong&gt;跨頁面複製粘貼&lt;/strong&gt;功能，這將徹底改變企業級應用開發的協作方式。&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//4ec53c4f836fdfc9cd097cd2be744ba9.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;設計師的流暢感，開發者的高效率&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;想象一下：在使用 Figma 或 Sketch 設計時，那種行雲流水的快捷鍵操作體驗，現在終於在應用開發領域實現了！&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;VTJ.PRO 此次更新包含了 17 個精心設計的快捷鍵，覆蓋了從基礎操作到複雜交互的全場景：&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;全局操作快捷鍵&lt;/strong&gt;讓保存（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;S&lt;/code&gt;）、預覽（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;P&lt;/code&gt;）、撤銷（&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;）、重做（&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;）等高頻操作觸手可及，不再需要頻繁點擊工具欄。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;組件操作快捷鍵&lt;/strong&gt;更是精妙：刪除、複製、剪切、粘貼這些操作與常用設計軟件保持一致，大大降低了學習成本。方向鍵選擇組件的設計讓精準選擇變得異常簡單。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;最令人驚喜的是&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↑&lt;/code&gt;/&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;快捷鍵，允許開發者在同級組件中快速調整順序，這在進行精細佈局調整時尤其有用。&lt;br&gt; &lt;br&gt; &lt;img alt="" height="1055" src="https://oscimg.oschina.net/oscnet/up-d4c83ed961f4790fe3c75e0b4173459ac09.png" width="1920" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;跨頁面複製粘貼：打破界限的創新&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;此次更新中最具革命性的功能非&lt;strong&gt;跨頁面複製粘貼&lt;/strong&gt;莫屬。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;以往開發過程中，在不同頁面間複用組件需要多次導出導入，或者重新編寫代碼。現在，只需簡單的&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;C&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;和&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;V&lt;/code&gt;，就能將組件甚至整個模塊從一個頁面複製到另一個頁面，&lt;strong&gt;真正實現了資源的無縫流動&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;這項功能對於大型項目尤其有價值：設計系統的一致性得到了保證，開發效率大幅提升，維護成本顯著降低。&lt;/p&gt; 
&lt;h2&gt;實際效益：數字説話&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;早期測試數據顯示，使用快捷鍵和跨頁面複製功能後：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;常規操作時間減少約 50%&lt;/li&gt; 
 &lt;li&gt;組件複用效率提升 60%&lt;/li&gt; 
 &lt;li&gt;整體開發週期縮短 30%&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;某金融科技公司的前端團隊負責人表示："這不僅僅是增加了幾個快捷鍵，而是真正理解了開發者的工作流程和痛點。我們現在可以在不同項目間快速遷移組件，建立統一的設計語言系統，這是以前難以想象的。"&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//8dceb323f7088c0225a1c00ccdc23bea.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;低代碼領域的又一次飛躍&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;VTJ.PRO&lt;/strong&gt;一直秉持"降低複雜度，不降低自由度"的理念，這次更新再次證明瞭這一點。快捷鍵功能的加入沒有犧牲任何靈活性，反而讓開發者既能享受可視化開發的便捷，又能保持代碼級控制的精確度。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;隨着企業數字化進程加速，對應用開發效率的要求越來越高。&lt;strong&gt;VTJ.PRO&lt;/strong&gt;通過這次更新，進一步鞏固了其在企業級低代碼開發領域的領先地位。&lt;br&gt; &lt;br&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet//3e9b48348a4313be44affbe6ab83bebc.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;立即體驗&lt;/h2&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;VTJ.PRO&lt;/strong&gt;完全開源且無商業限制，開發者現在就可以通過以下方式體驗新功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;訪問在線設計器：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvtj.pro%2F" target="_blank"&gt;https://vtj.pro&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;使用腳手架創建本地項目：&lt;code&gt;npm create vtj@latest&lt;/code&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;此次更新只是 VTJ.PRO roadmap 中的一步，開發團隊表示未來將繼續深化 AI 輔助開發能力，進一步打通設計與開發之間的壁壘。&lt;/p&gt; 
&lt;p style="color:#3c3c43; margin-left:0; margin-right:0; text-align:start"&gt;&lt;strong&gt;開發者的效率革命已經到來，你準備好了嗎？&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;快捷鍵清單&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;任意時機&lt;/strong&gt;： 
  &lt;ul&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;S&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;保存&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;P&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;預覽&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;撤銷&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;Z&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;重做&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;R&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;刷新&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;A&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;選中組件根節點&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;選擇任意組件後：&lt;/strong&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;code&gt;Backspace&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;刪除組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;C&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;複製組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;V&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;粘貼組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⌘&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;X&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;剪切組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;↑&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向外層選擇組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向內層選擇組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;←&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向同級左向選擇組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;→&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;向同級右向選擇組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;Escape&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;取消選擇組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↑&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;同級向上/左移動組件&lt;/li&gt; 
   &lt;li&gt;&lt;code&gt;⇧&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;↓&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;同級向下/右移動組件&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372664</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372664</guid>
      <pubDate>Sun, 14 Sep 2025 01:00:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>🔥httpsok-v1.18.2-SSL 證書自動續簽</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;&lt;span&gt;🔥httpsok-v1.18.2-SSL 證書自動續簽&lt;/span&gt;&lt;/h1&gt; 
&lt;h2&gt;&lt;span&gt;介紹&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;httpsok&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 是一個便捷的 HTTPS 證書自動續簽工具，專為 Nginx 、OpenResty 服務器設計。已服務眾多中小企業，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;穩定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可靠&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一行命令，一分鐘輕鬆搞定 SSL 證書自動續期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;&lt;code&gt;v1.18.2&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 版本新特性&lt;/span&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;📚支持 docker 鏡像快速部署&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;🤖DNS 異步檢測，支持 &lt;/span&gt;&lt;span&gt;&lt;code&gt;西部數碼&lt;/code&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;🌐nginx 支持單域名申請&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;span&gt;docker 證書自動續期&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;我們以 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnginx%2Fdocker-nginx%2F" target="_blank"&gt;&lt;span&gt;nginx 官方鏡像&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 為基礎，製作了集成 httpsok 的 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhub.docker.com%2Fr%2Fhttpsok%2Fnginx" target="_blank"&gt;&lt;span&gt;nginx 自動續簽鏡像&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;快速開始&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;設置環境變量：&lt;/span&gt;&lt;span&gt;&lt;code&gt;HTTPSOK_TOKEN&lt;/code&gt;&lt;/span&gt;&lt;span&gt;，從 &lt;/span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2F" target="_blank"&gt;&lt;span&gt;httpsok.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt; 控制枱獲取（點擊【複製腳本】按鈕）&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span&gt;compose.yml &lt;/span&gt;&lt;/h3&gt; 
&lt;pre&gt;&lt;span&gt;&lt;span style="color:#221199"&gt;services&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt;  httpsok-nginx&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  container_name&lt;/span&gt;&lt;span style="color:#555555"&gt;: &lt;/span&gt;httpsok-nginx&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  image&lt;/span&gt;&lt;span style="color:#555555"&gt;: &lt;/span&gt;httpsok/nginx&lt;span style="color:#555555"&gt;:&lt;/span&gt;1.28.0-alpine&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  ports&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;&lt;span style="color:#22a2c9"&gt;"80:80"&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;&lt;span style="color:#22a2c9"&gt;"443:443"&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  volumes&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./conf.d:/etc/nginx/conf.d&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./html:/var/html/&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;./certs:/etc/nginx/certs&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#221199"&gt; &amp;nbsp;  environment&lt;/span&gt;&lt;span style="color:#555555"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;TZ=Asia/Shanghai&lt;/span&gt;
&lt;span&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;span style="color:#aa5500"&gt;# 設置 TOKEN，從 httpsok.com 控制枱獲取&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&lt;span style="color:#555555"&gt; &amp;nbsp; &amp;nbsp;  - &lt;/span&gt;HTTPSOK_TOKEN=&lt;/span&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;span&gt;支持的鏡像版本&lt;/span&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.28.0-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.28.0&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.27.5-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.27.5&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.26.2-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.26.2&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.25.5-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.25.5&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.24.0-alpine&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;httpsok/nginx:1.24.0&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;span&gt;成功示例&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;&lt;img alt="image-20250917021634188" src="https://oscimg.oschina.net/oscnet//80aeb7a2b848e13a1990c10d85c19098.png" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span&gt;文檔&lt;/span&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhttpsok%2Fhttpsok" target="_blank"&gt;&lt;span&gt;倉庫地址-github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://gitee.com/httpsok/httpsok"&gt;&lt;span&gt;倉庫地址-gitee.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fquickstart.html" target="_blank"&gt;&lt;span&gt;nginx 證書一鍵自動續期&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fapply.html" target="_blank"&gt;&lt;span&gt;免費申請 SSL 通配符證書&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fcdn.html" target="_blank"&gt;&lt;span&gt;CDN 證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Foss.html" target="_blank"&gt;&lt;span&gt;OSS（對象存儲）證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Flb.html" target="_blank"&gt;&lt;span&gt;LB（負載均衡）證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;span&gt;結束&lt;/span&gt;&lt;/h3&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;如果您覺得 &lt;/span&gt;&lt;span&gt;&lt;code&gt;httpsok&lt;/code&gt;&lt;/span&gt;&lt;span&gt; 對您帶來了幫助，還請動動 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;您的發財小手&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 給項目點點 &lt;/span&gt;&lt;span&gt;&lt;code&gt;star&lt;/code&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;也可以把我們的工具，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享給您的小夥伴&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#34495e; margin-left:.8em; margin-right:.8em; text-align:start"&gt;&lt;span&gt;非常感謝大家的認可和支持🙏🙏🙏。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhttpsok%2Fhttpsok" target="_blank"&gt;&lt;span&gt;倉庫地址-github.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://gitee.com/httpsok/httpsok"&gt;&lt;span&gt;倉庫地址-gitee.com&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fquickstart.html" target="_blank"&gt;&lt;span&gt;nginx 證書一鍵自動續期&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fapply.html" target="_blank"&gt;&lt;span&gt;免費申請 SSL 通配符證書&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Fcdn.html" target="_blank"&gt;&lt;span&gt;CDN 證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Foss.html" target="_blank"&gt;&lt;span&gt;OSS（對象存儲）證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:.5rem; margin-right:0"&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhttpsok.com%2Fdoc%2Fguide%2Flb.html" target="_blank"&gt;&lt;span&gt;LB（負載均衡）證書部署&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/372655</link>
      <guid isPermaLink="false">https://www.oschina.net/news/372655</guid>
      <pubDate>Sat, 13 Sep 2025 20:12:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
  </channel>
</rss>
