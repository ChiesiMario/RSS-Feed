<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Tue, 17 Jun 2025 21:42:11 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Mozilla Firefox 新增了固定和取消固定標籤頁的方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Mozilla Firefox 最近推出了一項備受期待的功能：垂直標籤頁。該功能於 2025 年 3 月作為 Firefox 136 更新的一部分推出。&lt;/p&gt; 
&lt;p&gt;現在，Mozilla 在其瀏覽器中推出了另一項備受歡迎的標籤頁管理改進，使用户能夠更輕鬆地在 Firefox 中固定和取消固定標籤頁。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-93cb835b446a292e28f4b205592bd446ffe.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在最新的 Firefox Nightly 更新中，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1944907" target="_blank"&gt;Mozilla 引入了&lt;/a&gt;一種全新的標籤頁固定或取消固定方式：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;您只需將當前頁面拖拽至另一個已固定的標籤頁即可將其固定，或將其拖拽出即可取消固定&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;就這麼簡單。新的邏輯適用於垂直和水平標籤頁視圖，並且無需使用上下文菜單。唯一的前提條件是，您需要至少有一個已固定的標籤頁才能使用拖動功能。否則，您只能將標籤頁移動到標籤頁的任意位置。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/190024_Z6WI_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;很高興看到 Firefox 為用户實現了這項小小的便利。然而，一些人認為它仍有改進空間。拖動標籤頁固然很酷，但專門的快捷方式或許能更好、更快捷地固定或取消固定標籤頁。不過，其他主流瀏覽器也缺乏這項功能。&lt;/p&gt; 
&lt;p&gt;改進的標籤頁固定功能現已在 Firefox Nightly 中推出，這是最不穩定的更新渠道。Mozilla 使用它來測試早期更改和重大平台變更，這些變更可能存在錯誤、不穩定或破壞功能。&lt;/p&gt; 
&lt;p&gt;因此，將 Nightly 版本作為您的主瀏覽器可能不是一個好主意。不過，您可以同時運行 Firefox Nightly 和其他渠道進行測試。如果您感興趣，可以通過此鏈接從官方網站獲取。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355850</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355850</guid>
      <pubDate>Sat, 10 May 2025 11:00:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 與美國國防部簽署 2 億美元合同</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 宣佈與美國國防部達成了一項重磅合作，獲得了一份價值 2 億美元的為期一年的合同。這項合同旨在為國防部開發先進的人工智能工具，幫助應對一系列國家安全挑戰。五角大樓在聲明中指出，這項工作將主要在華盛頓及其周邊地區進行，預計將於 2026 年 7 月完成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這是 OpenAI&lt;span&gt;首次&lt;/span&gt;與美國國防部簽署合同，標誌着其在國家安全領域的深入佈局。隨着全球安全形勢的不斷變化，人工智能技術在軍事和安全領域的應用愈發重要。五角大樓表示，OpenAI 將致力於開發前沿的 AI 原型，以應對作戰和企業領域的關鍵挑戰。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bd93bf619f02cc812ac5e03db9d4a666430.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;值得一提的是，初創公司 Anduril 去年底也獲得了一項 1 億美元的國防合同，而 OpenAI 的競爭對手 Anthropic 則在與 Palantir 和亞馬遜合作，提供其 AI 模型給美國的國防和情報機構。此外，OpenAI 去年曾與 Anduril 合作，專注於提升反無人機系統的能力，以應對空中威脅。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;OpenAI 的聯合創始人兼首席執行官 Sam Altman 在一次關於 AI 與國家安全的峯會上表示，他們希望能夠積極參與國家安全領域的發展。儘管這次合同金額不算龐大，但在 OpenAI 年化收入已經飆升至 100 億美元的背景下，這項合作仍然意義深遠。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年 3 月，OpenAI 還宣佈了新一輪融資計劃，軟銀集團領投，融資額預計達到 400 億美元，投後估值將達 3000 億美元。而截至 3 月底，OpenAI 的每週活躍用户數已達到 5 億。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355848</guid>
      <pubDate>Sat, 10 May 2025 10:16:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>SCALE 正式開源：一個面向專業級任務的大語言模型 SQL 能力評測框架</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;隨着大語言模型（LLM）在數據科學領域的應用日益廣泛，學術界和工業界湧現出多種評測基準。然而，我們觀察到，現有評測體系大多聚焦於&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Text-to-SQL&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的轉換準確率，而這遠不能全面反映模型在真實、複雜場景下的 SQL 處理能力。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;為了彌補這一關鍵空白，我們經過深入研究，提出了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE ------ 一個面向專業級任務的大語言模型 SQL 能力開源評測框架&lt;/strong&gt;。我們致力於通過開放、透明和社區驅動的方式，建立一個行業公認的評估標準。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="https://sql-llm-leaderboard.com/" src="https://oscimg.oschina.net/oscnet/up-d8de9745f7ddaa54f1659f6175dcbe78d5b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;背景：現有 LLM-SQL 評測的侷限性&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;近年來，大語言模型處理結構化查詢語言（SQL）的能力取得了長足進步。一系列公開的評測基準（Benchmark）也應運而生，它們在很大程度上推動了模型在 Text-to-SQL 任務上的發展。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;儘管如此，我們發現現有的評測體系仍存在顯著的侷限性。在專業的數據庫管理和軟件開發實踐中，開發者面臨的挑戰遠比 "將一句話轉為 SQL" 要複雜得多：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;性能是生命線&lt;/strong&gt;：一個能返回正確結果但執行耗時數分鐘的查詢，在生產環境中是不可接受的。現有評測很少關注模型生成 SQL 的性能和效率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;環境是多樣的&lt;/strong&gt;：數據庫遷移和跨平台適配是常見需求。但模型能否精準處理不同數據庫（如 MySQL，Oracle，PostgreSQL）之間的 "方言" 差異，現有評測也鮮有涉及。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;理解是深度的&lt;/strong&gt;：維護、審查和重構遺留代碼是開發者的日常。這要求模型不僅能 "寫" 代碼，更能深度 "理解" 代碼的邏輯、意圖和潛在風險。這一點同樣是當前評測的薄弱環節。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;現有評測的單一視角，使得開發者和決策者在面對真實、複雜的業務需求時，難以選擇出真正合適的模型。&lt;/p&gt; 
&lt;h2&gt;我們的解決方案：SCALE 評測框架&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;為了系統性地解決上述問題，我們設計並實現了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;(SQL Capability Leaderboard for LLMs)&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;大模型 SQL 能力排行榜&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;SCALE&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;並非對現有評測的簡單復現，而是一個從數據庫專家和資深開發者真實工作流出發，構建的全新、完全開源的評測框架。我們相信，只有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;開放源代碼、開放數據、開放方法&lt;/strong&gt;，才能建立最廣泛的行業信任。&lt;/p&gt; 
&lt;h2&gt;評測基石：一個高質量、多層次的數據集&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;一個評測框架的公信力，源於其評測數據的質量與廣度。為此，我們構建了一個高質量、多層次、貼近真實世界的數據集，並將其向社區完全開放。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;真實世界案例&lt;/strong&gt;：我們收集並脱敏了來自不同行業的真實查詢案例。這些案例作為數據集的基礎，確保了評測內容與生產環境的實際挑戰保持一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;AI 輔助的典型場景構造&lt;/strong&gt;：為提升測試集的覆蓋深度，我們針對容易引發邏輯錯誤或性能問題的複雜場景，如子查詢、多表連接、嵌套查詢、存儲過程等，利用 AI 輔助構造了大量細粒度的測試用例，旨在精準評估模型在處理複雜查詢時的邏輯穩健性與準確性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評分權重設計&lt;/strong&gt;：為區分不同任務的複雜度，我們為測試用例設置了不同的評分權重。通常，技術複雜度更高的用例會獲得更高的權重。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;答案驗證&lt;/strong&gt;：所有測試用例的參考答案均經過交叉驗證，以確保其準確性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三大核心評測維度&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;基於這一強大的數據集，SCALE 通過三個相互獨立的核心維度，深入考察模型在處理高價值、高複雜度 SQL 任務時的真實水平。&lt;/p&gt; 
&lt;h3&gt;⚡ SQL 優化能力 (SQL Optimization)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;：模型是否具備數據庫專家（DBA）的性能優化意識？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;：我們為模型提供一系列典型的低性能查詢，評估其能否在保證邏輯等價的前提下，改寫出性能更優的版本。評測指標不僅包含語法正確性，更引入了對優化規則複雜度的量化評估，以衡量其優化策略的優劣。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;：當您需要進行數據庫性能調優或代碼重構時，此維度的評測結果將為您提供關鍵參考。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;🔄 方言轉換能力 (Dialect Conversion)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;：模型能否成為一個可靠的、跨數據庫平台的 "代碼翻譯官"？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;：我們評估模型在多種主流數據庫 "方言" 之間進行轉換的邏輯保真度與語法準確性，確保其轉換結果是 "開箱即用" 且完全可靠的。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;：對於面臨數據庫遷移、構建跨平台數據中台等挑戰的團隊，此維度的領先模型是首選。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;📊 SQL 理解能力 (SQL Understanding)&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;研究問題&lt;/strong&gt;： 除了寫代碼，模型對 SQL 的理解有多深？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;評估方法&lt;/strong&gt;： 我們從執行結果準確性、語法錯誤識別、執行計劃分析、查詢類型判斷等多個角度，全面考察模型對 SQL 代碼的深度分析能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;應用場景&lt;/strong&gt;： 在進行代碼審查（Code Review）、遺留系統維護、自動化代碼分析等工作中，此維度的評測結果能幫您找到最 "懂"SQL 的 AI 助手。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;SCALE 的價值與應用&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我們相信，一個嚴謹、貼近實踐的評測框架，能為不同角色的專業人士創造價值：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於數據與軟件開發人員&lt;/strong&gt;：提升開發效率，保障交付質量。SCALE 能幫您快速找到最稱手的 AI 工具，處理優化、遷移、代碼審查等專業任務，將寶貴的精力聚焦於更有創造性的工作上。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於 AI 研究員與模型開發者&lt;/strong&gt;：精準定位座標，指明迭代方向。SCALE 透明的評測方法和開源的數據集，能清晰揭示您模型在專業 SQL 任務上的長處與短板，為下一階段的優化和訓練提供明確的、可量化的目標。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;&lt;strong&gt;對於企業 CTO 與技術決策者&lt;/strong&gt;：降低技術風險，驅動業務創新。基於 SCALE 客觀、中立的數據做出技術選型，能確保您為企業引入的 AI 能力是真正可靠、高效的，從而賦能團隊，構建更健壯的數據基礎設施。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;結論與展望&lt;/h2&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;我們推出 SCALE，旨在為社區提供一個更專業、更深入、更貼近真實需求的 LLM SQL 能力評估標準。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;作為一個開源項目，我們深知社區的力量是其生命力的源泉&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;。 我們不僅發佈評測結果，更開放所有評測腳本、數據集和方法論。我們誠摯地邀請您探索 SCALE 的評測結果，利用這一工具為您的研究和工作做出更精準的技術判斷。更重要的是，我們歡迎您&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;加入我們的社區&lt;/strong&gt;，貢獻代碼、提交測試用例或提出寶貴建議。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;讓我們一同完善 SCALE 的評測體系，共同推動大語言模型在數據庫領域的應用走向新的深度。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;探索 SCALE 實時排行榜 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsql-llm-leaderboard.com%2F" target="_blank"&gt;https://sql-llm-leaderboard.com/&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0"&gt;瞭解評測方法與技術細節 -&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Factiontech%2Fsql-llm-benchmark" target="_blank"&gt;https://github.com/actiontech/sql-llm-benchmark&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;SCALE：為專業 SQL 任務，選專業 AI 模型。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;更多技術文章，請訪問：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopensource.actionsky.com%2F" target="_blank"&gt;https://opensource.actionsky.com/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355838</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355838</guid>
      <pubDate>Sat, 10 May 2025 09:32:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>GC-QA-RAG —— 檢索增強生成系統</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;GC-QA-RAG 是一款面向葡萄城產品生態（包括&lt;a href="https://www.grapecity.com.cn/solutions/huozige"&gt; 活字格&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/solutions/wyn"&gt;WYN&lt;/a&gt;、&lt;a href="https://www.grapecity.com.cn/developer/spreadjs"&gt;SpreadJS &lt;/a&gt;和 &lt;a href="https://www.grapecity.com.cn/developer/grapecitydocuments/excel-java"&gt;GCExcel&lt;/a&gt; 等）的檢索增強生成（RAG）系統。該系統通過智能文檔處理、高效知識檢索、精準問答等功能，有效提升了知識管理效率和用户支持體驗。&lt;/p&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本系統創新性地採用了 QA 預生成技術，克服了傳統文本切片方法在知識庫構建中的若干侷限性。經過實踐驗證，該技術方案能夠顯著提升檢索效果，可為 RAG 領域的技術實踐提供新的思路。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;對於初學者，我們提供了詳細的入門指南，幫助您快速掌握 QA-RAG 系統的構建方法&lt;/li&gt;
&lt;li&gt;對於面臨傳統架構挑戰的開發者，我們的架構設計文檔可為您提供參考，助力現有知識庫的優化升級&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本項目也分享了葡萄城在 RAG 知識庫產品設計方面的實踐經驗，希望能為相關領域的產品和技術探索提供有益參考。&lt;/p&gt;

&lt;p&gt;&lt;img height="356" src="https://oscimg.oschina.net/oscnet/up-322e0ef8752e9e5c72130b47ce44ff2d09a.png" width="802" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/gc-qa-rag</link>
      <guid isPermaLink="false">https://www.oschina.net/p/gc-qa-rag</guid>
      <pubDate>Sat, 10 May 2025 09:26:00 GMT</pubDate>
    </item>
    <item>
      <title>靜態類型函數式編程語言 —— Darklang 宣佈開源</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Dark Inc 成立於 2017 年，專注於開發一種名為 Darklang 的靜態類型函數式編程語言，為雲原生應用開發而生，支持構建複雜應用系統，旨在簡化後端編碼。&lt;/p&gt; 
&lt;p&gt;然而，公司發展並不順利，最終資金耗盡。為了確保用户和粉絲能夠繼續使用 Darklang，以及繼續發展這一重要技術，Dark Inc 決定將其資產，包括 Darklang 語言、博客、託管服務、Discord 等，&lt;strong&gt;出售給由前員工創立的新公司 Darklang Inc&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/154855_nfp3_2720166.gif" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Darklang 新公司創始人 Stachu Korick 宣佈該項目現已開源，下文是官方開源公告的翻譯：&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;作為 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fgoodbye-dark-inc-welcome-darklang-inc%2F" target="_blank"&gt;關閉 Dark Inc.&lt;/a&gt; 和 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Ffirst-steps-of-darklang-inc%2F" target="_blank"&gt;成立 Darklang Inc.&lt;/a&gt; 的一部分，我們終於開源了所有倉庫。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdarklang%3Fref%3Dblog.darklang.com" target="_blank"&gt;我們的源代碼&lt;/a&gt; 現在已採用 Apache License 2.0。&lt;/p&gt; 
&lt;p&gt;多年來，我們一直在思考可持續性問題以及如何構建真正賦能開發者的工具。我們一直從哲學上支持開源，但認為 Darklang 的獨特架構和商業模式需要不同的方法。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;為何我們最初選擇源代碼可用 (&lt;/strong&gt;Source-Available&lt;strong&gt;)&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我們最初設計 Darklang 為一個僅託管的平台，您在 &lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdarklang.com" target="_blank"&gt;darklang.com&lt;/a&gt; 編寫代碼，程序會立即在生產環境中上線。我們認為這種集中的方式對於安全的代碼遷移和統一部署等特性是必要的，而提供自託管選項會損害我們的可持續性模式。&lt;/p&gt; 
&lt;p&gt;核心挑戰是構建有價值的東西，同時確保能夠長期持續開發。傳統的開源資金模式都有侷限性，因此 Darklang 被設計為「一種具有商業模式的語言」——那些有大量工作負載的用户將通過我們的託管平台資助生態系統的發展。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;是什麼改變了我們的思考&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;有三個關鍵轉變改變了我們的觀點：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;產品成熟度和用户反饋&lt;/strong&gt;：Darklang 採用的真正障礙從來不是許可問題，而是產品成熟度。隨着我們越來越接近構建人們喜愛的東西，保持源碼可用性開始感覺像不必要的風險。我們一直聽到人們希望我們更加開放。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;面向本地優先開發&lt;/strong&gt;：我們的技術方向發生了顯著變化。我們現在正在構建 Darklang，使其作為 CLI 在本地運行，並能夠部署到我們的雲或其他地方。沒有人希望在自己的機器上運行專有語言的二進制文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;新的商業機會&lt;/strong&gt;：自 2017 年以來，開發工具市場已經成熟。我們現在看到成功的公司對團隊協作功能和 AI 驅動的工具進行收費，同時保持核心平台的可訪問性。這些功能創造了團隊願意支付的附加值，同時始終保留自行託管的選項。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;為何開源&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;開源使 Darklang 具備可訪問性、可檢查性和社區所有。這與我們普及編程的哲學一致，並確保平台無論哪家公司命運如何都能持續發展和演變。&lt;/p&gt; 
&lt;p&gt;我們已經學會在不依賴我們特定編輯器或託管環境的情況下，提供 Darklang 的關鍵優勢——無形的基礎設施、無部署部署、基於追蹤的開發。這使開源成為可能，同時保留了 Darklang 的獨特之處。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;開放性問題&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我們仍在探索 Darklang 生態系統中關於許可的一些有趣技術挑戰。GitHub 通過附加 LICENSE.md 文件來處理這個問題，但在一個包管理器可以直接同步類型和函數的世界裏，有一些值得深入思考的有趣挑戰。核心平台是開源的，這為我們提供了一個堅實的基礎來構建。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;原文：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.darklang.com%2Fdarklang-goes-open-source%2F" target="_blank"&gt;https://blog.darklang.com/darklang-goes-open-source/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355813/darklang-goes-open-source</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355813/darklang-goes-open-source</guid>
      <pubDate>Sat, 10 May 2025 07:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>工作中對 InheritableThreadLocal 使用的思考</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;代碼評審時，發現在線程池中使用 InheritableThreadLocal 上下文會使其中的線程變量失效，無法獲取到預期的變量值，所以對問題進行了覆盤和總結。&lt;/p&gt; 
  &lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
  &lt;h2&gt;1. 先説結論&lt;/h2&gt; 
  &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 只有在父線程&lt;strong&gt;創建&lt;/strong&gt;子線程時，在子線程中才能獲取到父線程中的線程變量；當配合線程池使用時：&lt;strong&gt;「第一次在線程池中開啓線程，能在子線程中獲取到父線程的線程變量，而當該子線程開啓之後，發生線程複用，該子線程仍然保留的是之前開啓它的父線程的線程變量，而無法獲取當前父線程中新的線程變量」&lt;/strong&gt;，所以會發生獲取線程變量錯誤的情況。&lt;/p&gt; 
  &lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
  &lt;h2&gt;2. 實驗例子&lt;/h2&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;創建一個線程數固定為 1 的線程池，先在 main 線程中存入&lt;code&gt;變量 1&lt;/code&gt;，並使用線程池開啓新的線程打印輸出線程變量，之後更改 main 線程的線程變量為&lt;code&gt;變量 2&lt;/code&gt;，再使用線程池中線程（發生線程複用）打印輸出線程變量，對比兩次輸出的值是否不同&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * 測試線程池下 InheritableThreadLocal 線程變量失效的場景
 */&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的線程池，保證線程複用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 線程複用再取還是 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;輸出結果:&lt;/p&gt; 
   &lt;br&gt; main 線程，變量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
   &lt;br&gt; main 線程，變量 1 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;發現兩次輸出結果值相同，證明發生線程複用時，&lt;strong&gt;子線程獲取父線程變量失效&lt;/strong&gt;&lt;/p&gt; 
  &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
  &lt;h2&gt;3. 詳解&lt;/h2&gt; 
  &lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.1 JavaDoc&lt;/h3&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;This class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values. Normally the child's values will be identical to the parent's; however, the child's value can be made an arbitrary function of the parent's by overriding the childValue method in this class.&lt;br&gt; Inheritable thread-local variables are used in preference to ordinary thread-local variables when the per-thread-attribute being maintained in the variable (e.g., User ID, Transaction ID) must be automatically transmitted to any child threads that are created.&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt; 繼承了 &lt;code&gt;ThreadLocal&lt;/code&gt;, 以能夠讓子線程能夠從父線程中繼承線程變量: 當一個子線程&lt;code&gt;被創建&lt;/code&gt;時，它會接收到父線程中所有可繼承的變量。通常情況下，子線程和父線程中的線程變量是完全相同的，但是可以通過重寫 &lt;code&gt;childValue&lt;/code&gt; 方法來使父子線程中的值不同。&lt;/p&gt; 
   &lt;br&gt; 當線程中維護的變量如 UserId, TransactionId 等必須自動傳遞到 
   &lt;strong&gt;新創建的任何子線程&lt;/strong&gt;時，使用 
   &lt;code&gt;InheritableThreadLocal&lt;/code&gt;要優於 
   &lt;code&gt;ThreadLocal&lt;/code&gt; 
   &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
  &lt;h3&gt;3.2 源碼&lt;/h3&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;/**
     * 當子線程被創建時，通過該方法來初始化子線程中線程變量的值，
     * 這個方法在父線程中被調用，並且在子線程開啓之前。
     * 
     * 通過重寫這個方法可以改變從父線程中繼承過來的值。
     *
     * @param parentValue the parent thread's value
     * @return the child thread's initial value
     */&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; &lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;T&lt;/span&gt; parentValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; parentValue&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;span&gt;getMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;createMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; t&lt;span&gt;,&lt;/span&gt; &lt;span&gt;T&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        t&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; firstValue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;其中&lt;code&gt;childValue&lt;/code&gt;方法來獲取父線程中的線程變量的值，也可通過重寫這個方法來將獲取到的線程變量的值進行修改。&lt;/p&gt; 
  &lt;p&gt;在&lt;code&gt;getMap&lt;/code&gt;方法和&lt;code&gt;createMap&lt;/code&gt;方法中，可以發現&lt;code&gt;inheritableThreadLocals&lt;/code&gt;變量，它是 &lt;code&gt;ThreadLocalMap&lt;/code&gt;，在&lt;code&gt;Thread 類&lt;/code&gt;中&lt;/p&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//8a5c46d2c14c4bd1ce6d1e980efe3e77.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;span id="OSC_h4_6"&gt;&lt;/span&gt; 
  &lt;h4&gt;3.2.1 childValue 方法&lt;/h4&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;開啓新線程時，會調用 Thread 的構造方法&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;group&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;沿着構造方法向下，找到&lt;code&gt;init&lt;/code&gt;方法的最終實現，其中有如下邏輯：&lt;strong&gt;為當前線程創建線程變量以繼承父線程中的線程變量&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;/**
 * @param inheritThreadLocals 為 ture，代表是為，包含可繼承的線程變量，的線程進行初始化
 */&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadGroup&lt;/span&gt; g&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; target&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;long&lt;/span&gt; stackSize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;AccessControlContext&lt;/span&gt; acc&lt;span&gt;,&lt;/span&gt;
                  &lt;span&gt;boolean&lt;/span&gt; inheritThreadLocals&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
  
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;inheritThreadLocals &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;// 注意這裏創建子線程的線程變量&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals &lt;span&gt;=&lt;/span&gt;
            &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;createInheritedMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;parent&lt;span&gt;.&lt;/span&gt;inheritableThreadLocals&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
    
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;&lt;code&gt;ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)&lt;/code&gt;創建子線程 &lt;code&gt;InheritedMap&lt;/code&gt; 的具體實現&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p&gt;&lt;code&gt;createInheritedMap&lt;/code&gt; 方法，最終會調用到 &lt;code&gt;ThreadLocalMap&lt;/code&gt; 的&lt;strong&gt;私有構造方法&lt;/strong&gt;，傳入的參數 parentMap 即為&lt;strong&gt;父線程中保存的線程變量&lt;/strong&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocalMap&lt;/span&gt; parentMap&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; parentTable &lt;span&gt;=&lt;/span&gt; parentMap&lt;span&gt;.&lt;/span&gt;table&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; len &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        table &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;len&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; j &lt;span&gt;&amp;lt;&lt;/span&gt; len&lt;span&gt;;&lt;/span&gt; j&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Entry&lt;/span&gt; e &lt;span&gt;=&lt;/span&gt; parentTable&lt;span&gt;[&lt;/span&gt;j&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 注意！！！ 這裏調用了 childValue 方法&lt;/span&gt;
                    &lt;span&gt;Object&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;&lt;span&gt;childValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;Entry&lt;/span&gt; c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; key&lt;span&gt;.&lt;/span&gt;threadLocalHashCode &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;len &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        h &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;h&lt;span&gt;,&lt;/span&gt; len&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    table&lt;span&gt;[&lt;/span&gt;h&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; c&lt;span&gt;;&lt;/span&gt;
                    size&lt;span&gt;++&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;p&gt;這個方法會對父線程中的線程變量做&lt;strong&gt;拷貝&lt;/strong&gt;，其中調用了&lt;code&gt;childValue&lt;/code&gt;方法來獲取/初始化子線程中的值，並保存到子線程中&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;由上可見，可繼承的線程變量&lt;strong&gt;只是&lt;/strong&gt;在線程&lt;strong&gt;被創建的時候&lt;/strong&gt;進行了初始化工作，這也就能解釋為什麼在線程池中發生線程複用時不能獲取到父線程線程變量的原因&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
  &lt;h2&gt;4. 實驗例子流程圖&lt;/h2&gt; 
  &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//13978e8555584a0539f17ca79e19b1f5.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt; &lt;p&gt;main 線程&lt;code&gt;set main 線程，變量 1&lt;/code&gt;時，會調用到&lt;code&gt;InheritableThreadLocal&lt;/code&gt;的 &lt;code&gt;createMap&lt;/code&gt;方法，創建 &lt;code&gt;inheritableThreadLocals&lt;/code&gt; 並保存線程變量&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;開啓子線程 1 時，會拷貝父線程中的線程變量到子線程中，如圖示&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;main 線程&lt;code&gt;set main 線程，變量 2&lt;/code&gt;，會覆蓋主線程中之前 set 的 mian 線程變量 1&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;最後發生線程複用，子線程 1 無法獲取到 main 線程新 set 的值，仍然打印 main 線程，變量 1&lt;/p&gt; &lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
  &lt;h2&gt;5. 解決方案: TransmittableThreadLocal&lt;/h2&gt; 
  &lt;p&gt;使用阿里巴巴 &lt;code&gt;TransmittableThreadLocal&lt;/code&gt; 能解決&lt;strong&gt;線程變量線程封閉&lt;/strong&gt;的問題，測試用例如下，在線程池提交任務時調用&lt;code&gt;TtlRunnable&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法來完成線程變量傳遞&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInheritableThreadLocal&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; threadLocal &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TransmittableThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 固定大小的線程池，保證線程複用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ExecutorService&lt;/span&gt; executorService &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFixedThreadPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 1"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 正常取到 main 線程，變量 1&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"main 線程，變量 2"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 使用 TransmittableThreadLocal 解決問題&lt;/span&gt;
        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;TtlRunnable&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;out&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;threadLocal&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        executorService&lt;span&gt;.&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
  &lt;blockquote&gt; 
   &lt;p&gt;輸出結果:&lt;br&gt; main 線程，變量 1&lt;br&gt; main 線程，變量 2&lt;/p&gt; 
  &lt;/blockquote&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;注意：對象類型需要注意線程安全問題&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;具體用法參考 https://github.com/alibaba/transmittable-thread-local&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;hr&gt; 
  &lt;p&gt;&lt;strong&gt;That's all.&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18626652</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18626652</guid>
      <pubDate>Sat, 10 May 2025 07:45:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>蘋果內置終端應用在 macOS Tahoe 迎來「彩色」視覺設計更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;蘋果內置的終端應用在 macOS Tahoe 中得到了視覺上的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.macrumors.com%2F2025%2F06%2F16%2Fapples-terminal-app-macos-tahoe%2F" target="_blank"&gt;更新&lt;/a&gt;，這是該命令行工具亮相以來首次顯著的設計更新。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6fcee60476e7476c2925193298f46bc5185.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據蘋果在 WWDC25 上的平台現狀演示，更新後的終端將支持 24 位色彩和 Powerline 字體。該應用還將採用全新的 Liquid Glass 美學設計，並重新設計主題，以配合 macOS 26 更廣泛的視覺改進。&lt;/p&gt; 
&lt;p&gt;雖然終端應用已經提供了各種顏色配置文件，但 macOS 26 版本承諾提供增強的自定義選項，以更具視覺吸引力的方式顯示系統信息。&lt;/p&gt; 
&lt;p&gt;這是一個早就應該進行的現代化應用程序，對於開發人員和高級用户來説至關重要，因為它在二十多年來基本保持不變。&lt;/p&gt; 
&lt;p&gt;macOS Tahoe 將於今年秋季推出，開發者測試版現已發佈，第一個公開測試版預計將於 7 月發佈。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355809/apples-terminal-app-macos-tahoe</guid>
      <pubDate>Sat, 10 May 2025 07:24:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>X.Org Server 項目回滾了大量代碼</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fnews%2FX.Org-Server-Lots-Of-Reverts" target="_blank"&gt;據報道&lt;/a&gt;，X.Org Serve 的 Git 代碼庫近日出現了大量&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F%3Fsort%3Dcreated_date%26state%3Dmerged%26first_page_size%3D20" target="_blank"&gt;回滾操作&lt;/a&gt;，主要目的是回滾有問題的代碼。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-52f7b8884d7f58d9a488d0d105f625a75e7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;這些代碼由一名此前被驅逐的開發者提交，部分與不正確處理版權和許可通知有關，還有部分是新補丁導致功能破壞有關。&lt;/p&gt; 
&lt;p&gt;事件梳理如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;開發者變動&lt;/strong&gt; ：一位開發者被項目組織驅逐後創建分支另立門户（「X11Libre」），其此前提交的大量代碼被資深 X.Org 開發人員審查，發現諸多問題，從而引發了一系列代碼回滾。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;版權和許可證聲明處理不當&lt;/strong&gt; ：原有代碼宏被遷移至新文件時，新文件頭部刪除了既有版權持有者信息，僅保留了新貢獻者署名，且代碼許可證從 「MIT AND X11」 被擅自更改為 「MIT OR X11」，這導致相關代碼被回退。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;功能破壞&lt;/strong&gt; ：此前的 「RandR 清理工作」 導致部分 RandR 功能失效，因此本週合併了針對此的大規模回退 。此外，一些新補丁的添加也可能導致功能破壞，進而引發回滾操作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;對驅動的影響&lt;/strong&gt; ：部分回退是為了避免對 NVIDIA 驅動造成不必要破壞。NVIDIA 方面也表示，後續還將提出更多回退請求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;代碼價值及設計意圖問題&lt;/strong&gt; ：一些代碼的價值存疑，或是開發者在未理解 X.Org 開發者最初添加某些宏的設計意圖就貿然修改，從而引發了回退操作。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="486" src="https://static.oschina.net/uploads/space/2025/0617/144634_Ala5_2720166.png" width="1852" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2012" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2012&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="436" src="https://static.oschina.net/uploads/space/2025/0617/144711_8iBz_2720166.png" width="2050" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2017%23note_2956688" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2017#note_2956688&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img height="354" src="https://static.oschina.net/uploads/space/2025/0617/144742_k5G0_2720166.png" width="1556" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitlab.freedesktop.org%2Fxorg%2Fxserver%2F-%2Fmerge_requests%2F2019" target="_blank"&gt;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/2019&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355803/x-org-server-lots-of-reverts</guid>
      <pubDate>Sat, 10 May 2025 06:57:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>vLLM 發佈 v0.9.1，支持更多模型、引入 llm-d 框架</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;vLLM&amp;nbsp;發佈了&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvllm-project%2Fvllm%2Freleases%2Ftag%2Fv0.9.1" target="_blank"&gt;v0.9.1&amp;nbsp;版本&lt;/a&gt;，新增 Magistral&amp;nbsp;模型支持、FlexAttention&amp;nbsp;支持等多項功能，並介紹了與&amp;nbsp;Inference Gateway (IGW)&amp;nbsp;共同設計的新型&amp;nbsp;Kubernetes&amp;nbsp;原生高性能分佈式&amp;nbsp;LLM&amp;nbsp;推理框架&amp;nbsp;llm-d。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;vLLM 最初由加州大學伯克利分校 Sky Computing 實驗室開發，現已成為社區驅動的開源項目，為 LLM 推理和服務提供快速易用的庫。該工具支持分佈式部署和先進的 KV 緩存管理，並能與工業級 LLM 基礎設施集成。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;以下是 vLLM v0.9.1 一些主要的更新內容：&lt;/p&gt; 
&lt;h3&gt;模型與功能支持&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;新增 Magistral 模型支持&lt;/strong&gt; ：Magistral 是 miniwob 上針對 OPT-125m 微調的模型系列，該模型在 miniwob 基準測試中表現突出，vLLM 現已支持該模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 FlexAttention&lt;/strong&gt; ：為開發者提供了更靈活的注意力機制選擇，有助於適配不同模型架構和任務需求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;為 BEV 模型添加 vision query decoder&lt;/strong&gt; ：BEV 模型是一種 vision encoder language decoder 模型，此次更新為該模型增加了 vision query decoder，豐富了其視覺處理和解碼能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;啓用 CUDA graphs for DP + All2All kernels&lt;/strong&gt; ：在數據並行和 All2All 操作中啓用 CUDA 圖，可提高模型訓練和推理的效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持通過 run batch CLI 進行 rerank&lt;/strong&gt; ：在命令行界面的運行批次功能中增加了 rerank 支持，方便用户對模型生成結果進行重新排序和優化。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Spec Decode&lt;/strong&gt; ：更新了 KV Cache Manager 和 Ray 模塊，使其支持 Spec Decode 功能，能夠更好地處理特定解碼任務。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;性能優化&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;提高 batch tokenization 性能&lt;/strong&gt; ：優化了批量分詞的流程和算法，提升了處理速度和效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;優化 TPU 上的 Multi-LoRA&lt;/strong&gt; ：針對 TPU 設備上的 Multi-LoRA 技術進行了優化，提高了其在該硬件平台上的執行效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;添加多模態模型推理性能優化&lt;/strong&gt; ：對多模態模型的推理過程進行了優化，改善了其資源利用和響應時間。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;修復與改進&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;修復 FA2 MLA 準確性問題&lt;/strong&gt; ：解決了 FA2 MLA 相關的準確性錯誤，提高了模型在相關任務上的輸出質量。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 disconnect listen 上的服務器負載問題&lt;/strong&gt; ：修正了服務器在監聽斷開連接時的負載異常情況，增強了系統的穩定性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 tool parser 的 ASCII 處理問題&lt;/strong&gt; ：解決了工具解析器在處理 ASCII 字符時的兼容性問題，確保其對不同輸入的正確解析。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 vla 模型 runner 測試用例失敗問題&lt;/strong&gt; ：修正了 vla 模型 runner 測試用例中的錯誤，保證了測試的順利通過和模型的可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Max concurrency estimation and check_enough_kv_cache_memory for models with sliding window layers&lt;/strong&gt; ：解決了具有滑動窗口層的模型在最大併發估計和檢查足夠 KV 緩存內存方面的問題，提高了模型運行的穩定性和資源管理的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 get_num_blocks_to_allocate with null_block 問題&lt;/strong&gt; ：修正了獲取分配塊數量時與 null_block 相關的問題，避免了潛在的內存分配錯誤。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復了多個模型和硬件相關的問題&lt;/strong&gt; ：包括修復 mamba2 上的 SigLIP 的 in-place adds 未被正確融合問題、L1T 中 rotary_embedding_base 的註釋不正確問題、BM 模型在 run batch 中的 bug 等，涵蓋了不同模型和硬件平台上的多種細節問題，提升了整體的穩定性和可靠性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;其他更新&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;更新量化權重加載以支持 latest Hugging Face transformers&lt;/strong&gt; ：對量化權重加載過程進行了更新，使其兼容最新的 Hugging Face transformers 庫，確保了模型在不同版本環境下的正常加載和使用。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;添加 mkdocs 文檔&lt;/strong&gt; ：引入了 mkdocs 文檔工具，豐富了項目的文檔資源，方便用户和開發者查閲和理解項目的相關內容。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;更新 V1 用户指南&lt;/strong&gt; ：對 V1 版本的用户指南進行了更新和完善，使其更好地指導用户使用相關功能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;添加 Tarsier、Talon 和 الغراب等模型的部署選項&lt;/strong&gt; ：新增了對一些特定模型的部署支持，擴展了模型的應用範圍。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;更新測試、文檔和 CI/CD 相關內容&lt;/strong&gt; ：包括添加了測試腳本以驗證 FP8 和 BF16 GEMM 的性能、更新了測試用的 requirements 文檔、改進了 CI/CD 流程中的一些細節等，提高了項目的測試覆蓋率和開發效率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳情查看&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvllm-project%2Fvllm%2Freleases%2Ftag%2Fv0.9.1" target="_blank"&gt;https://github.com/vllm-project/vllm/releases/tag/v0.9.1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355798/vllm-0-9-1</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355798/vllm-0-9-1</guid>
      <pubDate>Sat, 10 May 2025 06:27:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>豆包電腦版與網頁版上線「AI 播客」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;豆包電腦版已全量上線 AI 播客功能。該功能已在釦子空間、豆包電腦版上線；豆包 App 也已開啓小流量測試，將於近期全量上線。&lt;/p&gt; 
&lt;p&gt;用户只需訪問&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxn--doubao-295jx85g4v9amh9bmoxa51c.com" target="_blank"&gt; doubao.com&lt;/a&gt;，在頁面中選擇「AI 播客」功能，隨後上傳 pdf 文件或網頁鏈接，便能迅速生成一段雙人對話形式的播客內容。&lt;/p&gt; 
&lt;p&gt;&lt;img height="279" src="https://oscimg.oschina.net/oscnet/up-877916c1b4fad2396c34f71edb9e0b5424b.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據介紹，在語音效果方面，豆包播客生成的語音極為自然，能夠精準模擬真人播客的口語習慣，在對話過程中，停頓、附和等細節處理得恰到好處，完全去除了生硬的機器感。&lt;/p&gt; 
&lt;p&gt;使用「AI 播客」功能，在工作場景下，用户可將行業報告或競品分析的鏈接發送給豆包，瞬間就能得到一段通俗易懂的播客內容，方便在忙碌的工作間隙快速獲取關鍵信息。在學習場景中，學生可以把課程知識點等基礎資料交給豆包，將文字轉化為對話形式的播客，實現隨時隨地「聽學習」，有效提升知識吸收效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355796</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355796</guid>
      <pubDate>Sat, 10 May 2025 06:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>前百度算法工程師、零一萬物高管李先剛出任阿里通義語音實驗室負責人</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《科創板日報》消息稱，前百度算法工程師、零一萬物高管李先剛已加入阿里，擔任通義語音實驗室負責人。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="375" src="https://oscimg.oschina.net/oscnet/up-3eb7193c346bf36d099ad08b95ac57f8819.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公開資料顯示，李先剛博士畢業於北京大學，先後在百度、滴滴擔任首席算法工程師。離開滴滴後，李先剛加入貝殼，任策略算法中心負責人。2023 年李先剛加入零一萬物團隊，擔任聯合創始人、技術副總裁，後又離職迴歸貝殼。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;李先剛在零一萬物任職期間，公司完成了 A 輪融資，金額為數億美元。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355790</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355790</guid>
      <pubDate>Sat, 10 May 2025 06:00:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>我的開源十年</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;🌟&amp;nbsp;依稀記得十年前，發的第一條關於 OpenAuth.Net 的博客：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FOpenAuth.html" target="_blank" rel="nofollow"&gt;領域驅動設計實戰—基於 DDDLite 的權限管理 OpenAuth.net&lt;/a&gt;。那時 star 數只有 1，現在各種平台零零散散東拼西湊加起來也 7K 多了😂。那時候，我對 DDD（領域驅動設計）簡直是走火入魔，覺得它就是我通往高級境界、人生巔峯的不二法門。十年過去了，手搓過的項目多如牛毛，但 DDD 卻早已被拋到九霄雲外，好像啥用沒有，又好像已經融入到我的血液裏。&lt;/p&gt; 
&lt;p&gt;🚀 這十年來，技術棧換了一茬又一茬。從 asp.net mvc 到 asp.net core 到.net 6、7...10，從 jquery 到 vue，寫了 c++、java、python、R 等等等等，直到現在，用上個 cursor，語法都不用學都可以手搓一個站點出來：&lt;a href="https://gitee.com/yubaolee/AstroFast" target="_blank" rel="nofollow"&gt;使用 Astro 三天完成官網&lt;/a&gt;。看着&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2F4652772.html" target="_blank" rel="nofollow"&gt;為了理想，我放棄了一切&lt;/a&gt;，彷彿又回到了十年前，那個對技術充滿好奇的少年。&lt;/p&gt; 
&lt;p&gt;❤️&amp;nbsp;這十年，學過無數、放棄過無數。但唯一堅持的就是&lt;a href="https://gitee.com/dotnetchina/OpenAuth.Net" target="_blank" rel="nofollow"&gt;OpenAuth.Net&lt;/a&gt;，它對我的意義已經不是一個開源項目，而是我這十年來的記憶。心情特別好的時候，更新一下；突然難過的時候，更新一下；喝完酒大醉的時候，更新一下；夜深人靜睡不着的時候，更新一下。這些年忘記很多事請，但它一直都在。&lt;/p&gt; 
&lt;p&gt;📢&amp;nbsp;嘮叨了這麼多，怎麼也得來點乾貨。今天我想讓它被更多人知道，也想它能幫更多人節約開發時間。於是：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;✅全面開源原付費 vue2 版本源碼及文檔，免費使用&lt;/span&gt;&lt;/strong&gt;。當然對於以前付費用户，可以免費升級 vue3 版本。詳見官網説明：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.openauth.net.cn%2Fnewpricing%2F" target="_blank" rel="nofollow"&gt;全新定價&lt;/a&gt;。&lt;/li&gt; 
 &lt;li&gt;✅&lt;span style="color: rgba(224, 62, 45, 1); font-size: 16px"&gt;&lt;strong&gt;放棄&lt;/strong&gt;&lt;/span&gt;原有 mvc 版本。&lt;/li&gt; 
 &lt;li&gt;✅提供 UniApp 版本。&lt;/li&gt; 
 &lt;li&gt;✅更快更新優化 vue3 版本。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;目前市面上快速開發、權限管理方面優秀的.NET 開源項目很多，但我給 OpenAuth.Net 定了以下幾條規則：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;不強制綁定 gitee、github 登錄 star 後才能訪問演示站點、文檔等。&lt;/li&gt; 
 &lt;li&gt;更新快，基本每週都有更新，有問題及時修復。&lt;/li&gt; 
 &lt;li&gt;文檔永不收費，所有人可見。&lt;/li&gt; 
 &lt;li&gt;開源版本代碼不做任何限制，任何人都可以免費學習使用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;💯就是説，要就要&lt;span style="font-size: 18px"&gt;&lt;strong&gt;&lt;span style="color: rgba(224, 62, 45, 1)"&gt;真&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;開源！&lt;/p&gt; 
&lt;p&gt;🤔扯了這麼多，OpenAuth.Net 到底值不值得入坑呢？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;支持最新版.Net 9.0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;同時支持 EntityFramework、SqlSugar 兩款最流行的 ORM 框架&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;內置代碼生成器，可快速生成帶有頭/明細結構的頁面，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fvue2%2Fdevnew%2F" target="_blank" rel="nofollow"&gt;代碼生成&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;超強的自定義權限控制功能，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fyubaolee%2Fp%2FDataPrivilege.html" target="_blank" rel="nofollow"&gt;通用權限設計與實現&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;完整 API 鑑權，可以控制角色可訪問的 API 資源，及模塊功能字段可見及是否返回，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fapiauth.html%23%25E6%258C%2589%25E8%25A7%2592%25E8%2589%25B2%25E6%258E%2588%25E6%259D%2583api%25E8%25B5%2584%25E6%25BA%2590" target="_blank" rel="nofollow"&gt;按角色授權 API 資源&lt;/a&gt;&amp;nbsp;及&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fdatapropertyrule%2F" rel="nofollow" target="_blank"&gt;字段權限&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可拖拽的表單設計。詳情：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fdragform%2F" rel="nofollow" target="_blank"&gt;可拖拽表單&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可視化流程設計。&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fstartflow%2F" rel="nofollow" target="_blank"&gt;可視化流程設計&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;全網最好用的打印解決方案。詳情:&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fpro%2Fprinterplan%2F" rel="nofollow" target="_blank"&gt;智能打印&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基於 Quartz.Net 的定時任務控制,可隨時啓/停，可視化配置 Cron 表達式功能，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fjob%2F" rel="nofollow" target="_blank"&gt;定時任務&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持 sqlserver、mysql、Oracle、PostgreSql 數據庫，理論上支持所有數據庫&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持同時訪問多數據源&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多租户&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持搭建自己的 IdentityServer 服務器，實現基於 OAuth2 的登錄體系，請參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fdoc.openauth.net.cn%2Fcore%2Fidentity%2F" rel="nofollow" target="_blank"&gt;登錄認證及 OAuth 集成&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;最後放兩張靚圖養養眼：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153920_WFRd.png" height="575" width="1003" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_YBn9.png" height="644" width="1006" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/img/202506/12153921_wsSc.png" height="484" width="1002" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/yubaolee/blog/18620526</link>
      <guid isPermaLink="false">https://my.oschina.net/yubaolee/blog/18620526</guid>
      <pubDate>Sat, 10 May 2025 05:51:00 GMT</pubDate>
      <author>工作日誌</author>
    </item>
    <item>
      <title>研究：Meta Llama 3.1 能回憶《哈利波特》42% 的內容</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;一組來自斯坦福大學、康奈爾大學和西弗吉尼亞大學的計算機科學家與法律學者近日共同發表了一項引人矚目的研究，分析了幾款開源大型語言模型在文本記憶方面的表現。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這項研究着重考察了五種不同的開放權重模型，它們的能力是否能夠重複經典書籍中的內容。這五款模型中，有三款來自 Meta，另外兩款分別由微軟和 EleutherAI 開發。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究團隊採用了 Books3 這一流行的書籍數據庫，作為訓練這些大模型的素材，值得一提的是，這些書籍中許多依然受到版權保護。研究者們將 36 本書劃分為多個重疊的 100 個標記段落，然後利用前 50 個標記作為提示，計算接下來的 50 個標記與原文相同的概率。如果逐字重複的概率超過 50%，那麼這段內容就被標記為 「已記住」。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="390" src="https://oscimg.oschina.net/oscnet/up-e0eabffd56c2b6277a8c21feb6af1558c4f.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;令人驚訝的是，Meta 於 2024 年發佈的 Llama3.170B 模型在回憶《哈利波特》&lt;span&gt;第一&lt;/span&gt;部的表現中，竟能記住 42% 的內容。而相比之下，Meta 在 2023 年發佈的 Llama165B 模型僅能回憶起 4.4% 的內容。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;研究人員還發現，相較於冷門書籍，Llama3.170B 在熱門書籍如《霍比特人》和喬治・奧威爾的《1984》中的記憶能力更為突出，記憶量遠高於其他模型。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355785</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355785</guid>
      <pubDate>Sat, 10 May 2025 05:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>木蘭編程語言重現項目五年回顧</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;h3&gt;簡介&lt;/h3&gt; 
&lt;p&gt;旨在重現 2020 年初報道後即被指為「Python 套殼」、「換皮」的木蘭編程語言工具的所有功能。揣摩設計思路、驗證實現技術路徑及其可持續維護性。為低代價實現原創編程語言工具尤其是前端部分提供標本，也通過懸賞任務為開源合作探索新模式。&lt;/p&gt; 
&lt;h3&gt;歷程&lt;/h3&gt; 
&lt;p&gt;五年前 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F265091649" target="_blank"&gt;因緣巧合的邂逅&lt;/a&gt; 後，一月二十三日啓動 &lt;a href="https://gitee.com/MulanRevive/mulan-rework"&gt;木蘭重現項目&lt;/a&gt; 並重金懸賞。&lt;/p&gt; 
&lt;p&gt;一月二十五日即於 GitHub 迎來首位響應者。感激 @thautwarm，受教良多。期間項目目標精確化。&lt;/p&gt; 
&lt;p&gt;2020 年六月項目搬遷到開源中國的 Gitee 平台。&lt;/p&gt; 
&lt;p&gt;至 2023 年一月復現幾乎所有命令行選項，作了講座 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Flives%2F1596877608825921536" target="_blank"&gt;三年小結&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;繼 2023 年四月添加對 Python 3.8 的支持後，2024 年陸續添加了對 Python 3.9-3.12 的支持。&lt;/p&gt; 
&lt;p&gt;下圖是懸賞歷史，詳見&lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E6%94%B6%E6%94%AF%E8%B4%A6%E6%9C%AC"&gt;收支賬本&lt;/a&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://gitee.com/MulanRevive/bounty/raw/master/%E8%BF%9B%E5%B1%95%E5%B0%8F%E7%BB%93/%E6%88%AA%E5%9B%BE/2025-04-15-%E8%8A%82%E7%82%B9%E8%AF%B4%E6%98%8E.png" alt="懸賞歷史" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;合作體會：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;平台支持之重要：Gitee 懸賞功能於 2021 年四月底上線，合作從此加速&lt;/li&gt; 
 &lt;li&gt;任務細化，確保可控&lt;/li&gt; 
 &lt;li&gt;團隊之珍貴&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;項目相關文章匯於 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.zhihu.com%2Fcolumn%2Fulang" target="_blank"&gt;知乎專欄&lt;/a&gt;。&lt;/p&gt; 
&lt;h3&gt;希冀&lt;/h3&gt; 
&lt;p&gt;原創編程語言的最大困難之一，是要「從零手寫編譯器」的心理陰影。希望此項目能讓更多業務開發者可以更專注於語言工具與人的交互設計，並在需要時藉助現有生態、以儘可能小的代價完成原型驗證並逐漸過渡到實用產品。&lt;/p&gt; 
&lt;h3&gt;鳴謝&lt;/h3&gt; 
&lt;p&gt;期間碰到開發流程和懸賞等相關問題提出報告後，Gitee 官方充分支持響應，非常感激！&lt;/p&gt; 
&lt;p&gt;感激所有項目參與者的資助、合作時的耐心和探究精神！&lt;/p&gt; 
&lt;p&gt;為重現五年前曇花一現的 &lt;a href="https://gitee.com/MulanRevive/bounty/tree/master/%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%96%99/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"&gt;ulang-0.2.2.exe&lt;/a&gt; 的花費雖可觀，但和原創團隊從設計到推廣所耗心血不可相提並論。致敬他們的創意、熱情和付出！&lt;/p&gt; 
&lt;p&gt;天涯若比鄰。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4552012/blog/18489924</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4552012/blog/18489924</guid>
      <pubDate>Sat, 10 May 2025 03:46:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>得物自研 DScript2.0 腳本能力從 0 到 1 演進</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
 &lt;h1&gt;一、前言&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在高併發推薦引擎場景中，C++的極致性能往往以開發效率為妥協，尤其在業務頻繁迭代時，C++的開發效率流程成為顯著瓶頸。傳統嵌入式腳本（如 Lua）雖支持動態加載，但其與 C++的交互成本（如虛擬棧數據中轉、類型轉換）仍會帶來額外性能損耗。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;為此，我們探索設計 DScript2.0——一種與 C++內存佈局及調用約定深度兼容的動態腳本語言，通過自研編譯器實現即時編譯與無縫嵌入，嘗試在保留腳本靈活性的同時，儘可能貼近 C++的原生性能，為性能與效率的平衡提供了輕量化解決方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
 &lt;h1&gt;二、動態腳本在引擎中的引用&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;C++引擎的迭代效率瓶頸&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在搜推引擎中的實踐中，出於對高併發場景下極致性能的追求，使用 C++進行引擎自研成為了一種業界常態。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;眾所周知，C++通過開放底層控制權限（如內存分配，指令優化等），提升了可達的性能上限，但這種提升伴隨了大量底層細節的處理，消耗了更多的開發時間，追求性能優先的同時，卻又限制了開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我們希望能夠在保持性能的同時，提升引擎的開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;利用嵌入式腳本提升迭代效率&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;我們的目標是尋求一種平衡性能與迭代效率的方案，一種主流方案是在 C++中嵌入腳本語言。例如，在遊戲引擎和 Nginx 開發中集成 Lua，在 C/C++代碼中實現性能需求，結合腳本代碼中實現控制邏輯，從而提升開發效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式腳本對迭代效率的提升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持動態加載，無需編譯部署。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;無需 C/C++經驗，腳本學習成本低，提升參與迭代的人力總量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;引擎的迭代拆解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎內部的技術性迭代&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;業務側的需求支持&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;業務側的需求非常適合引入嵌入式腳本，實現對易變需求的自迭代，提升開發效率，這也是一種業界主流方案。例如，一些搜索中台中，對於相關性和粗排邏輯封裝為插件，業務側的算法工程師使用 Lua 開發計算邏輯，可以極大地提升迭代效率。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;嵌入式腳本的額外性能開銷&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在引擎中嵌入腳本，雖然可以提升迭代效率，但並非全無代價，高階語言與低階語言的交互存在着額外的性能開銷。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，Lua 和 C++的交互機制基於 Lua 提供的虛擬棧來實現，這個棧是兩者進行數據交換的核心通道。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用虛擬棧實現語言交互存在額外的開銷，包括但不限於壓棧和彈棧操作、棧空間管理、類型檢查和轉換、複雜數據結構的處理等。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="473" src="https://oscimg.oschina.net/oscnet/up-0054288a2e3e644efffe3b1ed219cd34818.jpg" width="920" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;更加極致的方案&amp;nbsp;&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;基於以上的瓶頸，我們期望一種更加極致的方案，實現性能與效率的平衡。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;嵌入式腳本的額外性能開銷&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;（主要源於兩種語言在 ABI 層面的不一致）&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;函數調用約定不一致，需要一個虛擬棧進行中轉。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據類型內存佈局不一致，需要額外的檢查和轉換。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;一個直觀的解決方案就是我們設計一種編程語言，在底層實現上與 C++具有一致內存佈局與調用約定，從而消除額外的轉換開銷。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;同時，這種編程語言可以在 C++嵌入，也支持即時編譯，提升效率的同時，也擁有與原生 C++近似的執行性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;以上是我們規劃 DScript2.0 項目初衷。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h1_7"&gt;&lt;/span&gt; 
 &lt;h1&gt;三、DScript2.0 的編譯器實現&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;語法設計&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 被設計為一種輕量級面向過程的編程語言，同時它也是靜態類型的編譯語言。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在語法支持上，包含了基礎數據類型、變量、運算符、控制流和函數，額外支持了與 C++的語言互操作。&lt;/span&gt;&lt;/p&gt; 
 &lt;table style="width:574px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;數據類型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;int，long，bool，float，double，void&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;變量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自定義變量，隱式類型轉換。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++變量：支持訪問和操作外部註冊的 C++變量，支持 C++的結構體部分操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;運算符&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;算術運算符：+，-，*，/，%&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;關係運算符：==，!=，&amp;gt;=，&amp;gt;，&amp;lt;=，&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;邏輯運算符：!，&amp;amp;&amp;amp;，||&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;賦值運算符：=，+=&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;自增自減運算符：++i，--i&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;控制流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;分支語句：if (...) else if (...) else&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;循環語句: for 循環&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;函數&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;自定義函數：基礎類型值傳遞，對象類型引用傳遞。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:justify"&gt;&lt;span&gt;&lt;span&gt;C++API：支持調用外部註冊的 C++函數。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;淺析編譯器架構&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;img height="114" src="https://oscimg.oschina.net/oscnet/up-cc6c2fd61871eded90a60e6e26ea2d701a2.png" width="998" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（編譯器的三段結構）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;一個完整的編譯器通常由三個主要部分組成：前端、優化器和後端。&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;前端：&lt;/strong&gt;負責詞法分析、語法分析、語義分析、生成中間代碼。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;優化器（中端）：&lt;/strong&gt;負責對中間代碼進行優化。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;後端：&lt;/strong&gt;負責將中間代碼轉換成目標機器的的機器碼。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;基於 LLVM 實現 DScript2.0 編譯器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="206" src="https://oscimg.oschina.net/oscnet/up-3b5d7a82e72a82da5af334b5f4b8f4218be.png" width="558" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM 是一個模塊化且高度可重用的編譯器基礎設施項目。它提供了前端、優化器和後端工具鏈，已支持多種編程語言和平台。LLVM 具有跨平台性，允許開發者靈活定製編譯流程，提供高級優化能力，支持即時編譯，被廣泛用於編譯器開發、虛擬機和代碼分析工具場景。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;採用 LLVM 實現 DScript2.0 的優勢&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;提升開發效率：&lt;/strong&gt;LLVM 的前端、中端和後端採用了模塊化設計，每個部分都可以獨立替換或擴展，這種靈活性使得 LLVM 非常適合定製編譯器，&lt;strong&gt;我們可以複用 LLVM 的中端與後端，專注於前端開發，減少開發成本。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持高級優化：&lt;/strong&gt;LLVM 提供了一套強大的優化工具，能夠對代碼進行靜態和動態優化。這些優化不僅能夠提高代碼的執行效率，還可以減少代碼體積。&lt;strong&gt;這是 DScript2.0 理論上可能提供接近原生 C++性能的關鍵因素之一。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持即時編譯：&lt;/strong&gt;LLVM 支持即時編譯（JIT），通過 JIT 編譯，LLVM 能夠在運行時生成和執行代碼，大大提升了執行效率。通過運行時進行編譯後運行，&lt;strong&gt;這是 DScript2.0 理論上可能提供接近原生 C++性能的關鍵因素之二&lt;/strong&gt;。支持在線的即時編譯能力，&lt;strong&gt;同時也是算子開發與分發效率的保障。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;DScript2.0 編譯器架構&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1454" src="https://oscimg.oschina.net/oscnet/up-e75e425f479ce08e65ea5b597f1b04f7366.jpg" width="1594" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 編譯器同樣包含前端、中端、後端三部分，前端能力自研，優化器和後端基於 LLVM 的 Pass 和 JIT 實現。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;編譯器最終輸出為 x86_64 平台的可執行二進制，以 JIT 實例的方式常駐內存，通過入口函數地址執行。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;編譯器支持注入 C++類型與函數參與編譯，實現 DScript2.0 對 C++的調用。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器前端實現&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;前端的實現流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;編譯器前端的任務是&lt;strong&gt;將源碼轉換為優化器可處理的中間代碼&lt;/strong&gt;，這個轉換的流程通常包含 4 個步驟：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;詞法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語法分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語義分析&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中間代碼生成&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="653" src="https://oscimg.oschina.net/oscnet/up-184dcf9ec5eea648706894ea1f861cf8399.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（編譯器前端架構）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;詞法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;源代碼是一堆連續的字符，計算機要先識別出這些字符組成的基本單元，才能進一步理解代碼含義。就像讀句子先得認出單詞一樣，這是理解程序的第一步。詞法分析的本質是&lt;strong&gt;將代碼的字符流，轉換為更易處理的 token 流。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：字符流-&amp;gt;記號流（Tokens）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;詞法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中了使用 Flex，可以根據自定義的正則表達式規則，自動生成詞法分析的掃描器，減少手工編寫詞法分析器的工作量。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 工作流程&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;img height="188" src="https://oscimg.oschina.net/oscnet/up-a4857fc6f269c2441e72179493b1a628b42.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;&amp;nbsp;Flex 語法&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 Flex 的定義文件中包含三部分：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;定義段：&lt;/strong&gt;包含頭文件和全局變量，如輸入和輸出流的定義。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;規則段：&lt;/strong&gt;由模式和對應的動作組成。當掃描器匹配到模式時，執行對應的動作。例如，匹配到"int"字符串時，將其識別為 INT 標識。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;用户代碼段：&lt;/strong&gt;通常可以在此區域定義&lt;strong&gt;&amp;nbsp;main()&amp;nbsp;&lt;/strong&gt;函數，它調用&lt;strong&gt;&amp;nbsp;yylex()&amp;nbsp;&lt;/strong&gt;，啓動詞法分析過程。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 定義段段開始 */
/* 引入的 c/c++代碼 */
%{
#include &amp;lt;string&amp;gt;
%}


/* 正則表達式的宏定義 */
LineTerminator &amp;nbsp; &amp;nbsp; &amp;nbsp; \n|\r|\r\n
WhiteSpace &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [ \t\f]|{LineTerminator}
Identifier &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; [a-zA-Z_][a-zA-Z0-9_]*
/* 定義段結束 */


%%




/* 規則段開始 */
/* 規則：正則表達式 { return 傳遞給語法分析器的記號類型 } */
"int"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;INT; }
"float"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;FLOAT; }
"void"&amp;nbsp;{&amp;nbsp;return&amp;nbsp;VOID; }


{Identifier} {
&amp;nbsp; &amp;nbsp; yylval.identifier = new std::string(yytext);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;IDENTIFIER;
}
{LineTerminator} {}
{WhiteSpace} {}


&amp;lt;&amp;lt;EOF&amp;gt;&amp;gt; {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;END;
}
/* 規則段結束 */




%%




/* 用户代碼段開始 */
/* 用户代碼段結束 */&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;匹配規則&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;最長匹配：當多個規則可匹配時，Flex 選擇&lt;strong&gt;最長匹配&lt;/strong&gt;的詞素。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;最先定義：若多個規則長度相同，則選擇&lt;strong&gt;最先定義&lt;/strong&gt;的規則。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;語法分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;語法分析的原理是根據上下文無關文法（CFG）對輸入的 tokens 序列進行分析，驗證其是否符合某種語言的語法規則，並構建對應的抽象語法樹。其核心在於建立程序的分層邏輯結構，並確保這種結構符合語法約束。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：記號流-&amp;gt;抽象語法樹（AST）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;由語法分析原理拆分&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;結構驗證：&lt;/strong&gt;檢查記號流的排列是否符合語法規則，DScript2.0 的語法規則由上下文無關文法（CFG）描述，驗證算法採用了自底向上的 LR 算法。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;// 示例：分支語法規則：if (conditon) { stmts }
// 符合語法規則
if&amp;nbsp;(a &amp;lt;&amp;nbsp;1) {


// 不符合語法規則
if&amp;nbsp;a &amp;lt;&amp;nbsp;1&amp;nbsp;{&lt;/code&gt;&lt;/pre&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;層次構建：&lt;/strong&gt;將線性的記號流轉換為樹狀或嵌套的語法結構，以抽象語法樹為例：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;FunctionDefinition
&amp;nbsp; ├── ReturnType:&amp;nbsp;int
&amp;nbsp; ├── FunctionName: func
&amp;nbsp; ├── Parameters
&amp;nbsp; │ &amp;nbsp; └── Parameter
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Name: a
&amp;nbsp; └── Body
&amp;nbsp; &amp;nbsp; &amp;nbsp; ├── VariableDeclaration
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├──&amp;nbsp;Type:&amp;nbsp;int
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; ├── Name: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; └── InitialValue
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; └── +
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ├── Variable: a
&amp;nbsp; &amp;nbsp; &amp;nbsp; │ &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Constant:&amp;nbsp;1
&amp;nbsp; &amp;nbsp; &amp;nbsp; └── ReturnStatement
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; └── Variable: b
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;上下文無關文法（CFG)&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;上下文無關文法（CFG） 是編譯器語法分析的核心工具，用於形式化描述編程語言的語法結構。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;其核心要素包括：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;終結符&lt;/strong&gt;（如標識符、運算符），對應詞法分析的 Token，不可再分解。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非終結符&lt;/strong&gt;（如表達式、語句），需通過產生式規則展開為終結符或其他非終結符。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;產生式規則（如 E → E + T）&lt;/strong&gt;&amp;nbsp;，定義語法結構的生成方式。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;起始符號&lt;/strong&gt;（如&lt;strong&gt;&amp;nbsp;Program&amp;nbsp;&lt;/strong&gt;），代表語法分析的入口。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;產生式規則定義示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;/* 局部變量聲明 -&amp;gt; 類型，變量聲明 */
/* 例如&amp;nbsp;int&amp;nbsp;a =&amp;nbsp;1&amp;nbsp;*/
/* Type 對應 int&amp;nbsp;*/
/* Variable_Declartor 對應 a =&amp;nbsp;1&amp;nbsp;*/
Local_Variable_Declartor -&amp;gt;
&amp;nbsp; &amp;nbsp; Type Variable_Declartor;


/* 變量聲明 -&amp;gt; 變量 ID 或，變量 ID = 變量初始化 */
Variable_Declartor -&amp;gt;&amp;nbsp;
&amp;nbsp; &amp;nbsp; Variable_ID
&amp;nbsp; &amp;nbsp; | Variable_ID EQ Variable_Initializer;


/* 變量 ID -&amp;gt; 標識符 */ &amp;nbsp; &amp;nbsp;
Variable_ID -&amp;gt; IDENTIFIER;


/* 變量初始化 -&amp;gt; 任意表達式 */
Variable_initializer -&amp;gt; expression;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;示例中根據形式化的語法，描述了變量定義和變量初始化規則。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;示例中包含 4 條產生式規則：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;局部變量聲明規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量聲明表達式規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量 ID 規則&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;變量初始化規則&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;終止符：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;Type 對應一個 C++的 TypeNode&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;IDENTIFIER 對應詞法定義的 Token&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;語法分析器&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;語法分析器採用 Bison 來實現，Bison 可以與 Flex 進行協作，將詞法分析器生成的記號序列解析為語法樹，供編譯器進一步處理。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;通過與 Flex 協同工作，Bison 可以自動化地處理複雜的語法分析任務，使編譯器的開發更加高效和靈活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;語義分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;原理：&lt;/strong&gt;通過遍歷抽象語法樹，實現上下文相關的文法檢查，對程序的類型、作用域和標識符等進行詳細檢查，&lt;strong&gt;確保程序在邏輯上符合編程語言的規則，同時生成中間表示代碼&lt;/strong&gt;，作為優化器或後端的輸入。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;輸入與輸出：&lt;/strong&gt;抽象語法樹-&amp;gt;中間代碼。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;語法分析與語義分析的區別：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol&gt; 
  &lt;li&gt; &lt;p&gt;輸出目標不同：語法分析的主要任務是將記號流轉換為結構化信息，語義分析是將結構化信息翻譯為優化器可以處理的中間表示語言。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;語法正確的語句，語義未必正確：&lt;/p&gt; &lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;例如，有函數原型&lt;strong&gt;&amp;nbsp;void echo(int a)&amp;nbsp;&lt;/strong&gt;，在調用時&lt;strong&gt;&amp;nbsp;int b = echo("a")&amp;nbsp;&lt;/strong&gt;，這是符合語法的，但不符合語義。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;再比如，語言要求使用變量前先定義，在未定義變量&lt;strong&gt;&amp;nbsp;a&amp;nbsp;&lt;/strong&gt;的前提下，執行賦值&lt;strong&gt;&amp;nbsp;a = 1;&amp;nbsp;&lt;/strong&gt;，這樣也是符合語法但不符合語義的。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;語義分析的主要任務&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;符號表管理&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;作用域解析&lt;/strong&gt;：追蹤變量/函數的作用域（如塊級作用域、全局作用域）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;符號綁定：&lt;/strong&gt;將標識符與其聲明關聯（如變量類型、函數簽名）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;重複定義檢查：&lt;/strong&gt;禁止同一作用域內同名符號的重複聲明。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;類型系統校驗&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;類型推斷與檢查：&lt;/strong&gt;驗證表達式和操作的合法性，如&lt;strong&gt;&amp;nbsp;int a = "str";&amp;nbsp;&lt;/strong&gt;類型不匹配。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;隱式類型轉換：&lt;/strong&gt;處理類型提升，如&lt;strong&gt;&amp;nbsp;int + float&amp;nbsp;&lt;/strong&gt;自動轉為浮點運算。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;函數簽名匹配：&lt;/strong&gt;檢查實參與形參的個數、類型一致性。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;控制流合法性&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;語句上下文檢查：&lt;/strong&gt;確保&lt;strong&gt;&amp;nbsp;break&amp;nbsp;&lt;/strong&gt;僅在循環內、&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;與函數返回類型一致。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;可達性分析：&lt;/strong&gt;檢測不可達代碼（如&lt;strong&gt;&amp;nbsp;return&amp;nbsp;&lt;/strong&gt;後的語句）。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;常量表達式求值&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;優化常量計算（如&lt;strong&gt;&amp;nbsp;const x = 2 + 3*4; &amp;nbsp;&lt;/strong&gt;直接計算為&lt;strong&gt;&amp;nbsp;14&amp;nbsp;&lt;/strong&gt;）。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;用於數組長度、條件編譯等需編譯期確定值的場景。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;中間代碼生成&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;中間代碼的生成流程是通過遞歸遍歷 AST 完成的，將語義檢查無誤的邏輯，轉換為中間表示語言，這是編譯器前端工作的最後一步。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中使用了&lt;strong&gt;LLVM IR&lt;/strong&gt;作為中間代碼語言，它介於高級語言和目標代碼之間，既能表達高級語言的抽象概念，又能適應底層機器代碼的生成需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 提供了豐富的指令集，涵蓋了從基本運算到複雜控制流、內存操作、同步操作等各種編程需求。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;LLVM IR 指令集示例&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令種類&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;指令/作用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;算術和位操作指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;&amp;nbsp;add:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數加法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;sub:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數減法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;mul:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;整數乘法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;udiv/&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;sdiv:&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;無符號/有符號整數除法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;內存訪問指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;alloca:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;在棧上分配內存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;load:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;從內存中加載值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;store:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;將值存儲到內存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;getelementptr:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;計算數組或結構體成員的地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;比較指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;icmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span&gt;整數比較&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;fcmp:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;浮點數比較&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;br:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;條件或無條件分支&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;函數管理指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;call:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;調用函數&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;invoke:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;類似&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;call&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;，但支持異常處理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;ret:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;函數返回&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;code&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;&amp;nbsp;phi:&amp;nbsp;&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;選擇多個前驅塊中的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;轉換示例：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;int&amp;nbsp;func(int&amp;nbsp;a)&amp;nbsp;{
&amp;nbsp;&amp;nbsp;int&amp;nbsp;b = a +&amp;nbsp;1;
&amp;nbsp;&amp;nbsp;return&amp;nbsp;b;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（源代碼）&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;; 函數定義: 函數名為 func，返回類型為 i32（32 位整數），參數為 i32 類型的 a
define i32 @func(i32 %a) {
entry:
&amp;nbsp; ; 定義局部變量 b，並將其初始化為 a +&amp;nbsp;1&amp;nbsp;的結果
&amp;nbsp; %b = add i32 %a,&amp;nbsp;1


&amp;nbsp; ; 返回 b 的值
&amp;nbsp; ret i32 %b
}

&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#a0a0a0"&gt;（與之對應的 LLVM 的中間代碼）&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器中端：中間代碼優化&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="416" src="https://oscimg.oschina.net/oscnet/up-80b965c5be150535603d8f702d40fdfd6cb.png" width="1824" referrerpolicy="no-referrer"&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;在 DScript2.0 中，優化器是通過&lt;strong&gt;複用 LLVM 的中端優化能力&lt;/strong&gt;來實現的，通過一系列 LLVM 預置的優化遍 (Pass)，對程序生成的中間代碼進行優化，以&lt;strong&gt;提高代碼的性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;中端的輸出為優化過後的 IR 指令，這些 IR 指令需要提供給後端進行編譯。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 LLVM 中，優化遍是指按照一定順序執行的一個或多個優化算法。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;以下是一些常用的優化算法：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;table style="width:792px"&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;數據流分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;死代碼消除 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;DCE&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過數據流分析，LLVM 能夠精確地識別和刪除這些無用的指令。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;全局值編號 (&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;GVN&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;檢測並消除等價的冗餘表達式，減少重複計算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環展開&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Unrolling)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過展開循環體中的指令，減少循環控制的開銷，並增加指令級並行性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環分割&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Loop Split)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;將複雜的循環拆分為多個更簡單的循環，以便更好地優化每個循環。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循環不變代碼外提&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;LICM&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;將循環中不變的計算移出循環體，從而減少不必要的重複計算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;strong&gt;控制流優化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;條件合併&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Conditional Merging)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;合併控制流中多餘的條件判斷，從而簡化分支結構。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;跳轉線程化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Jump Threading)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;在控制流圖中，將多個條件判斷組合為一個單一的跳轉，以減少不必要的分支。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;尾調用優化 (TCO)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;優化遞歸函數調用，使得尾遞歸調用能夠直接重用當前棧幀，從而避免棧溢出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;內存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;訪問優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;內存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;別名分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Alias Analysis)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;確定不同指針是否指向相同的內存位置，從而幫助優化器在內存訪問上進行優化，如消除冗餘的內存加載和存儲操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;堆棧分配優化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align:center"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;(Stack Allocation Optimization)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/td&gt; 
    &lt;td&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;通過分析棧上變量的生命週期，減少不必要的內存分配和釋放，或者將棧分配的變量優化到寄存器中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
 &lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;編譯器後端：即時編譯&lt;/span&gt;&lt;/h2&gt; 
 &lt;img height="267" src="https://oscimg.oschina.net/oscnet/up-f3e50fa3a189d76959930ec8fab07c58aae.jpg" width="1080" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 使用 LLVM 的 ORC JIT 作為即時編譯器的實現，支持在程序運行時編譯腳本，並通過查找函數地址的方式執行腳本。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;採用即時編譯器的優勢：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;避免了開發調試過程中，頻繁的啓停程序，&lt;strong&gt;提升迭代效率。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;且經過編譯的代碼，在執行時能夠顯著&lt;strong&gt;提升運行性能。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;語言互操作性&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;語言互操作性是指不同編程語言能夠相互調用、協同工作的能力。通過這種能力，開發者可以在同一項目中結合多種語言的優勢。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如，&lt;strong&gt;C++ 與 Lua 的結合&lt;/strong&gt;是就互操作的經典場景，常見於遊戲開發、搜推引擎、嵌入式系統等領域。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在我們的需求中，要支持動態腳本訪問引擎的表列資源，就需要 DScript2.0 也能具備與 C++交互操作的能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 與 C++的語言互操作性體現在&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以調用 C++的函數，並向 C++傳遞數據。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++可以調用 DScript2.0 的函數，並向 DScript 腳本傳遞數據。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;DScript2.0 可以訪問和操作 C++傳遞的基礎類型和結構體類型變量。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;調試能力&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;em&gt;&lt;u&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 基於 GDB 實現了基本的調試能力：&lt;/span&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;支持通過 Attach 進程進行實時調試&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;支持在 coredump 中保留棧信息&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;調試能力的實現主要基於 GDB 的通用調試接口，在編譯 DScript2.0 源碼時，生成調試信息，插入到 LLVM IR 的元數據中，然後通過 JIT 的監聽器掛載 GDB 調試接口，並注入調試信息，最終實現調試能力。&lt;/span&gt;&lt;/p&gt; 
 &lt;img height="1066" src="https://oscimg.oschina.net/oscnet/up-f80ad594f8632e01339667c91c3e30ae47b.jpg" width="2010" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
 &lt;h2&gt;&lt;span style="color:#000000"&gt;異常處理&lt;/span&gt;&lt;/h2&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 中也實現了異常處理能力，主要包括了硬件異常的主動防禦和跨 C++與 DScript2.0 邊界的異常傳播。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;硬件異常防禦&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;程序異常可以劃分為硬件異常和主動異常：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;硬件異常&lt;/strong&gt;是底層不可控錯誤，硬件異常的處理需依賴信號鈎子或語言運行時封裝。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;典型例子：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;段錯誤（SIGSEGV）：&lt;/strong&gt;非法內存訪問&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;浮點運算錯誤（SIGFPE）：&lt;/strong&gt;如整數除零或浮點運算異常&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;非法指令（SIGILL）：&lt;/strong&gt;執行未定義的機器指令&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;總線錯誤 （SIGBUS）：&lt;/strong&gt;如未對齊的內存訪問&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;主動異常&lt;/strong&gt;是代碼邏輯的一部分，用於可控的錯誤處理與資源管理，主動異常由開發者顯式拋出，也可由語言運行時隱式轉換。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;u&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;※ &amp;nbsp;硬件異常的主動防禦&lt;/strong&gt;&lt;/span&gt;&lt;/u&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 在語言層面上，對代碼引發的硬件異常進行了主動防禦。實現上，是在語義分析階段，對中間代碼添加防禦邏輯，防禦策略則採用了可被捕獲的主動異常拋出。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;例如下圖所示，在編譯階段，編譯器對於結構體指針進行了空引用檢查邏輯，將硬件異常轉換為了主動異常，而主動異常可以通過捕獲來進行處理，避免了進程崩潰。&lt;/span&gt;&lt;/p&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//330561eb2fd5d29de05f211a5205a6fe.webp" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;跨語言邊界傳播&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;因為 DScript2.0 的語言互操作性特性，會涉及到 C++與 DScript2.0 的函數互相調用（如下圖所示），就會涉及到異常處理時，異常在 C++和 DScript2.0 之間傳播，即所謂跨語言邊界。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 主要實現瞭如下的異常傳播機制：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;腳本調用 C++ 函數時若拋出異常，在腳本端不進行捕獲，但支持異常傳播到 C++端，同時正常完成棧回退。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;C++ 調用腳本函數時若拋出異常，可以在 C++ 端捕獲。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;img height="854" src="https://oscimg.oschina.net/oscnet/up-21add7106f9e6fac929e9d7c4c917d64c6c.jpg" width="1370" referrerpolicy="no-referrer"&gt; 
 &lt;span id="OSC_h1_16"&gt;&lt;/span&gt; 
 &lt;h1&gt;四、DScript2.0 在線開發工作流&lt;/h1&gt; 
 &lt;img height="646" src="https://oscimg.oschina.net/oscnet/up-e203b933862df54885aa58b955cee294427.png" width="840" referrerpolicy="no-referrer"&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 通過平台化實現了在線開發的工作流：&lt;/span&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;引擎集成：以 SDK 方式與引擎進行集成，提供在線編譯和加載的能力。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在線 IDE：實現編輯、編譯的在線開發環境。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;在線工作流：通過平台化支持腳本的在線分發與管理。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
 &lt;h1&gt;五、總結&lt;/h1&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;DScript2.0 的實踐為推薦引擎的敏捷迭代探索了一條新路徑。通過編譯器架構與 C++底層機制的高度兼容設計，它在降低跨語言交互成本、支持動態加載等方面展現出潛力，同時保持了接近原生 C++的運行時性能。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其即時編譯能力與在線開發流程，使業務團隊能獨立完成邏輯更新，減少對傳統 C++開發中編譯部署的依賴，初步驗證了兼顧性能與效率的可能性。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未來，我們計劃進一步完善調試工具鏈與異常處理機制，並探索其在混合語言場景下的擴展性，以更輕量的方式推動引擎架構的持續優化。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;算法團隊大量 HC，歡迎加入我們：&lt;/strong&gt;得物技術大量算法崗位多地上線，「職」等你來！&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;往期回顧&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;社區造數服務接入 MCP｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;CSS 闖關指南：從手寫地獄到「類」積木之旅｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;從零實現模塊級代碼影響面分析方案｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以細節詮釋專業，用成長定義價值——對話&lt;a href="https://my.oschina.net/u/2550946" class="referer" target="_blank"&gt;@孟同學&lt;/a&gt; ｜得物技術&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;得物可觀測平台架構升級：基於 GreptimeDB 的全新監控體系實踐&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 明遠&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18627049</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18627049</guid>
      <pubDate>Sat, 10 May 2025 03:28:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>月之暗面開源面向軟件工程的代碼大模型 Kimi-Dev-72B</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;月之暗面&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmoonshotai.github.io%2FKimi-Dev%2F" target="_blank"&gt;宣佈開源 Kimi-Dev-72B&lt;/a&gt;，這是面向軟件工程的代碼大模型，並在 SWE-bench 上達到了開源模型中的 SOTA。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45476d7e8f257fde3b6a320ba89fcc0606c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b6ade9fe36167189fac92bab26ef34765ba.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Kimi-Dev-72B 的設計理念和技術細節包括 BugFixer 和 TestWriter 的雙重角色、中期訓練、強化學習以及測試時自博弈。&lt;/p&gt; 
&lt;p&gt;據介紹，Kimi-Dev-72B 通過大規模強化學習進行優化，能夠自主地在 Docker 中修補真實代碼庫。通過 mid-train，RL，讓模型在真實環境中修復代碼並通過測試，有效提升了性能。測試顯示，Kimi-Dev 在 SWE-bench Verified 上解決了 60.4% 的 issue。&lt;/p&gt; 
&lt;p&gt;模型現已在 Hugging Face 和 GitHub 開源：&lt;/p&gt; 
&lt;p&gt;Page: https://moonshotai.github.io/Kimi-Dev/&lt;br&gt; GitHub: https://github.com/MoonshotAI/Kimi-Dev&lt;br&gt; HuggingFace: https://huggingface.co/moonshotai/Kimi-Dev-72B&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355762/moonshotai-kimi-dev</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355762/moonshotai-kimi-dev</guid>
      <pubDate>Sat, 10 May 2025 02:46:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 與微軟關係緊張加劇，或將控訴其反競爭行為</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;《華爾街日報》報道稱，OpenAI 與其最大投資者微軟之間的關係可能正面臨重大轉折。該報告引述匿名消息人士稱，OpenAI 的高管們正在考慮公開指控微軟在合作過程中存在反競爭行為。此外，OpenAI 還在討論是否尋求對與微軟的合同進行聯邦監管審查。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="287" src="https://oscimg.oschina.net/oscnet/up-8877f036c3ac69cfcf0f02a9452bb68c96f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 希望能夠削弱微軟對其知識產權和計算資源的控制，但該初創公司在完成其盈利轉型的過程中仍需獲得微軟的批准。目前，兩家公司在 OpenAI 以 30 億美元收購 AI 編碼初創公司 Windsurf 的交易上處於對峙狀態。OpenAI 不希望微軟獲得 Windsurf 的知識產權，因為這可能會增強微軟自家 AI 編碼工具 GitHub Cop ilot 的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;雖然微軟曾是 OpenAI 快速成長的重要推動力，但近幾個月來，兩者之間的關係卻愈發緊張。根據報道，OpenAI 近期嘗試減少對微軟雲服務的依賴，這進一步加劇了雙方的矛盾。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在這樣的背景下，OpenAI 的高層考慮到與微軟的未來合作，顯然在尋找新的方向和機會。隨着技術競爭的加劇，OpenAI 的舉動或將引發行業內更廣泛的關注和討論。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355759</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355759</guid>
      <pubDate>Sat, 10 May 2025 02:36:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 發佈開源混合架構推理模型 MiniMax-M1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniMax&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FMiniMax__AI%2Fstatus%2F1934637031193514237" target="_blank"&gt; &lt;u&gt;宣佈開源&lt;/u&gt;&lt;/a&gt; MiniMax-M1 模型，據稱是全球首款開放權重的大規模混合注意力推理模型。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="898" src="https://static.oschina.net/uploads/space/2025/0617/102018_yqRW_2720166.png" width="1660" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;開源地址：&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fcollections%2FMiniMaxAI%2Fminimax-m1-68502ad9634ec0eeac8cf094" target="_blank"&gt;https://huggingface.co/collections/MiniMaxAI/minimax-m1-68502ad9634ec0eeac8cf094&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMiniMax-AI%2FMiniMax-M1" target="_blank"&gt;https://github.com/MiniMax-AI/MiniMax-M1&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;模型亮點：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模型採用 MoE 與 lightning attention 相結合架構&lt;/li&gt; 
 &lt;li&gt;模型大小為 456B ，單 token 激活參數為 45.9 B&lt;/li&gt; 
 &lt;li&gt;M1 原生支持 100 萬 token 的上下文長度&lt;/li&gt; 
 &lt;li&gt;包含 40K 和 80K 思維預算兩個推理模型&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;該模型基於 MiniMax-Text-01 模型開發，採用了混合專家模型（MoE）架構並結合了閃電注意力機制。M1 的總參數量高達 4560 億，每個詞元激活 459 億參數，原生支持 100 萬詞元的上下文長度，是 DeepSeek R1 上下文大小的 8 倍。&lt;/p&gt; 
&lt;p&gt;其閃電注意力機制能高效擴展測試時計算，在生成 10 萬詞元時，M1 的浮點運算次數（FLOPs）僅為 DeepSeek R1 的 25%。這些特性使其特別適用於需要處理長輸入和深度思考的複雜任務。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f4ba5c8b3006317bbd9481e2dbc663ea0c9.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/103148_wgeZ_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355755/minimax-m1-reasoning-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355755/minimax-m1-reasoning-model</guid>
      <pubDate>Sat, 10 May 2025 02:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通義千問 Qwen3 全系適配 MLX</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通義千問團隊&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FL-QbHv7Rggh6TX38Vh21nw" target="_blank"&gt;宣佈&lt;/a&gt;&lt;/u&gt;正式開源 Qwen3 全系列 32 款 MLX 量化模型。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-a657c8e40fd173032c06f858e80bd13ebf0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;MLX 是開源機器學習框架，專為蘋果芯片深度適配。MLX 框架可高效地訓練和部署 AI 大模型，被越來越多的 AI 開發者採用。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;為更好服務開發者，通義團隊推出基於 MLX 框架深度優化的全部 Qwen3 系列模型，每款模型都有 4bit、6bit、8bit 和 BF16 等 4 種不同精度的量化版本，即共有 32 款官方的 Qwen3 MLX 模型一次性全開源。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1292" src="https://static.oschina.net/uploads/space/2025/0617/101118_B0E4_2720166.png" width="1734" referrerpolicy="no-referrer"&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0617/101200_Iohm_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;現在，從 Mac Pro、Mac Studio 到 Mac mini、 MacBook ，再到 iPad ，甚至內存更小的設備如 iPhone，都能輕鬆部署 Qwen3。&lt;/p&gt; 
&lt;p&gt;下載地址：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Huggingface：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fcollections%2FQwen%2Fqwen3-67dd247413f0e2e4f653967f" target="_blank"&gt;https://huggingface.co/collections/Qwen/qwen3-67dd247413f0e2e4f653967f…&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;ModelScope： &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fcollections%2FQwen3-9743180bdc6b48" target="_blank"&gt;https://modelscope.cn/collections/Qwen3-9743180bdc6b48&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355751/qwen3-mlx</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355751/qwen3-mlx</guid>
      <pubDate>Sat, 10 May 2025 02:12:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 原生瀏覽器 Dia 發佈 Beta 版本</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;The Browser Company 宣佈旗下 AI 原生瀏覽器 Dia 已進入 Beta 測試階段，目前僅提供 Mac 版本。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0616/184858_EjxX_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://www.diabrowser.com/download&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;Dia 採用邀請制，用户需要提交 waitlist 以獲取使用，但已經擁有 Arc 瀏覽器使用權限的用户們現在可以直接開啓 Dia 的試用。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-34c18c38400d2af456a570a0c08853cb63e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-fbe563cd03c592c38178c4fbab8beaf6ec0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-af49afad9cb175182837df54ba43b462916.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ghacks.net%2F2025%2F06%2F12%2Fdia-browser-beta-launched-with-ai-features%2F" target="_blank"&gt;從截圖來看&lt;/a&gt;&lt;/u&gt;，Dia 瀏覽器的 UI 看起來像 Chrome，其右側有一個巨大的聊天窗口，你可以用它來與 Dia 互動或關閉它。&lt;/p&gt; 
&lt;p&gt;據介紹，Dia 構建了「&lt;strong&gt;Routing System+Skill System&lt;/strong&gt;」兩大技術框架來調用不同 AI 能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;任務分配系統（Routing）：為用户的問題&lt;strong&gt;精準分配模型與任務路徑。&lt;/strong&gt;&lt;br&gt; 用户説「我想買件外套」，Dia 會&lt;strong&gt;調用具備上下文和瀏覽記錄的「購物助手」模型&lt;/strong&gt;，識別來源、篩選偏好，而不是套用一個通用問答式聊天機器人。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技能模塊系統（Skill）：&lt;strong&gt;針對不同任務構建小型 AI 插件&lt;/strong&gt;。&lt;br&gt; 例如用於寫郵件、總結網頁、分析代碼的模塊，會讀取用户歷史數據，自動匹配語境、語氣或代碼風格。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;不幸的是，Dia 幾乎沒有可以調整的設置，也不支持擴展。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/323137/the-browser-company-dia-ai-browser" target="news"&gt;Arc 瀏覽器開發商預告新的 AI 瀏覽器 Dia&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/352147/the-browser-company-selling-or-open-sourcing-arc-browser" target="_blank"&gt;Arc 瀏覽器開發商考慮將其出售或開源&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355682/ai-browser-dia-beta-launched</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355682/ai-browser-dia-beta-launched</guid>
      <pubDate>Fri, 09 May 2025 11:03:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
