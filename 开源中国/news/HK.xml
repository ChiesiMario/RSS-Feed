<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Tue, 02 Sep 2025 07:47:28 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Firefox 將原生支持 MKV 視頻格式</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwindowsreport.com%2Fmozilla-firefox-is-officially-getting-mkv-video-support%2F" target="_blank"&gt;據報道&lt;/a&gt;，Firefox 瀏覽器即將原生支持 &lt;code&gt;.mkv&lt;/code&gt;視頻文件播放，用户無需再依賴插件或手動轉換格式。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4ae5363247ae1619e30c87b03d4f17b9b25.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Mozilla&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1422891" target="_blank"&gt; 已指派工程師&lt;/a&gt;推動這一功能的開發，預計將按照以下階段有序推進：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;Nightly 版本做初步測試，針對最常見的音視頻組合，例如 H.264 編碼的視頻 + AAC 音頻進行優先支持。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;後期將擴大支持範圍，加入 VP9、AV1 等視頻編碼，以及 Opus 或 FLAC 等音頻格式。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在穩定性與兼容性通過全面檢測後，會推廣至正式版本的 Firefox 用户。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/152017_iqZR_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此前，Firefox 打開 MKV 文件時常常失敗或直接觸發下載，這在 Windows 10 和 11 已原生支持 MKV 的情況下，顯得尤為不便。新功能上線後，Firefox 的多媒體體驗將與主流瀏覽器保持一致。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369866/mozilla-firefox-is-officially-getting-mkv-video-support</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369866/mozilla-firefox-is-officially-getting-mkv-video-support</guid>
      <pubDate>Tue, 02 Sep 2025 07:23:31 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>騰訊開源具備原生 3D 重建能力的超長程世界模型：HunyuanWorld-Voyager</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;騰訊近日正式發佈了 HunyuanWorld-Voyager，這是一種創新的視頻擴散框架，旨在通過單張輸入圖像生成具備世界一致性的 3D 點雲，支持用户按自定義的相機路徑進行沉浸式探索。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="327" src="https://oscimg.oschina.net/oscnet/up-56c2135778b8058ed623697954e8a4f3027.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官方表示，這全球首個具備原生 3D 重建功能的超遠距離世界模型，重新定義 AI 驅動的 VR、遊戲和仿真空間智能。此模型不僅能夠生成精確對齊的深度信息和 RGB 視頻，還能夠在不進行後處理的情況下，直接用於高質量的三維重建。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;直接 3D 輸出：無需 COLMAP 等工具即可將點雲視頻導出為 3D 格式，實現即時 3D 應用。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;創新的 3D 內存：引入可擴展的世界緩存機制，確保任何攝像機軌跡的幾何一致性。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;頂級性能：在斯坦福 WorldScore 測試中排名第一，在視頻生成和 3D 重建基準測試中表現出色&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;HunyuanWorld-Voyager 的架構包含兩個關鍵組件。首先是 「世界一致的視頻擴散」，該組件提出了一種統一的架構，可以基於已有的世界觀測，同時生成準確對齊的 RGB 視頻和深度視頻序列，從而確保全局場景的一致性。其次是 「長距離世界探索」，它採用了一種高效的世界緩存機制，結合點雲剔除和自迴歸推理能力，支持迭代場景擴展，並通過上下文感知的一致性技術實現平滑的視頻採樣。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;為了訓練 HunyuanWorld-Voyager 模型，研究團隊構建了一套可擴展的數據構建引擎。這一自動化視頻重建流水線能夠對任意輸入視頻自動估計相機位姿和度量深度，因此無需依賴人工標註，從而實現大規模、多樣化訓練數據的構建。基於此流水線，HunyuanWorld-Voyager 整合了真實世界採集和虛幻引擎渲染的視頻資源，構建了一個包含超過 10 萬個視頻片段的大規模數據集。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在實驗評估中，HunyuanWorld-Voyager 在視頻生成質量方面表現出色。與四種開源的相機可控視頻生成方法進行了對比，結果顯示該模型在 PSNR、SSIM 和 LPIPS 等指標上均優於其他模型，證明瞭其卓越的視頻生成質量。同時，在場景重建方面，HunyuanWorld-Voyager 的生成視頻在幾何一致性上也顯現出更好的效果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，HunyuanWorld-Voyager 在 WorldScore 靜態基準測試中獲得了最高分，證明瞭其在相機運動控制和空間一致性方面的優越性。這一成果不僅展示了混元世界模型的潛力，還為未來的 3D 場景生成技術開闢了新路徑。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369863</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369863</guid>
      <pubDate>Tue, 02 Sep 2025 07:15:31 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>騰訊優圖實驗室正式開源智能體框架 Youtu-Agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;9 月 2 日，騰訊優圖實驗室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW5LFBLCV3qZG0wxTA9Ob-w" target="_blank"&gt;宣佈&lt;/a&gt;正式開源智能體框架 Youtu-Agent。該框架以極簡設計和高性能表現為核心，旨在為研究人員和開發者提供高效、易用、可復現的智能體開發工具。&lt;/p&gt; 
&lt;p&gt;據介紹，Youtu-Agent 面向實際場景的開源應用框架，能夠覆蓋文件管理、數據分析、學術研究與廣域信息綜述等多個方向應用。目前，Youtu-Agent 開源框架已為騰訊雲多個產品業務提供支持。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;Youtu-Agent 的核心亮點在於，它不需要額外訓練模型，也不依賴海外閉源大模型 API，就能在真實場景中展現出優異的效果，比較好地兼顧了科研和應用雙重需求。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;驗證性能&lt;/strong&gt;：在 WebWalkerQA 上達到 71.47% 的 pass@1，在 GAIA（純文本子集）上達到 72.8% 的 pass@1，純粹使用&lt;code&gt;DeepSeek-V3&lt;/code&gt;系列模型（不使用 Claude 或 GPT），建立了強大的開源起點。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;開源友好且成本敏感&lt;/strong&gt;：針對可訪問、低成本部署進行了優化，不依賴封閉模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;實際用例&lt;/strong&gt;：開箱即用地支持 CSV 分析、文獻綜述、個人文件整理以及播客和視頻生成等任務。（即將推出）&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;靈活的架構&lt;/strong&gt;：基於 openai-agents 構建，可兼容各種模型 API（從&lt;code&gt;DeepSeek&lt;/code&gt;到&lt;code&gt;gpt-oss&lt;/code&gt;）、工具集成和框架實現。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;自動化與簡潔性&lt;/strong&gt;：基於 YAML 的配置、自動智能體生成和簡化的設置減少了手動開銷。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;在性能表現上，Youtu-Agent 已在多個智能體挑戰性基準測試中取得領先成績。例如，&lt;strong&gt;在 WebWalkerQA 基準中，基於 DeepSeek-V3.1 的運行結果達到了 71.47% 的準確率，刷新了開源模型的最新紀錄&lt;/strong&gt;；&lt;/p&gt; 
&lt;p&gt;&lt;img height="603" src="https://static.oschina.net/uploads/space/2025/0902/151154_CKYV_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;框架設計方面，Youtu-Agent 完全擁抱開源生態，適配多種可訪問的部署環境；其架構靈活，兼容包括 DeepSeek、gpt-oss 在內的多類模型 API 與工具。&lt;/p&gt; 
&lt;p&gt;&lt;img height="738" src="https://static.oschina.net/uploads/space/2025/0902/151229_GBNE_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;開源地址：&lt;em&gt;https://github.com/TencentCloudADP/Youtu-agent&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369860</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369860</guid>
      <pubDate>Tue, 02 Sep 2025 07:13:31 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Cloudflare 推出實時語音 AI 平台：Realtime Agents</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cloudflare 宣佈推出&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.cloudflare.com%2Fcloudflare-realtime-voice-ai%2F" target="_blank"&gt;實時語音 AI 平台&lt;/a&gt;（Cloudflare Realtime Agents），正式進軍低延遲對話式 AI 領域。該平台依託 Cloudflare 全球 330 多個節點的邊緣網絡，為開發者提供構建語音交互應用的完整解決方案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ae6ab80f3dac0b047d5a26124ce0a669d2d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;新平台的核心組件包括 Realtime Agents（語音 AI 管道編排運行時）、WebRTC 音頻傳輸支持、Workers AI 的 WebSocket 實時推理，以及 Deepgram 的語音識別/合成模型。通過這些功能，開發者可快速搭建自然流暢的語音代理應用。&lt;/p&gt; 
&lt;p&gt;下面的示例代碼展示瞭如何創建一個繼承自 &lt;code&gt;RealtimeAgent&lt;/code&gt; 的 JavaScript 類，以進行以下操作：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;創建 WebRTC 會話&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;管道編排（如：Deepgram STT → 自定義文本處理 Handler → ElevenLabs TTS）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持會議參與者加入/離開的事件處理&lt;br&gt; 這讓開發者幾乎不需管理底層基礎設施，就可快速構建個性化語音代理應用。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code class="language-javascript"&gt;export class MyAgent extends RealtimeAgent&amp;lt;Env&amp;gt; {
constructor(ctx: DurableObjectState, env: Env) {
super(ctx, env);
}

async init(agentId: string ,meetingId: string, authToken: string, workerUrl: string, accountId: string, apiToken: string) {
// Construct your text processor for generating responses to text
const textHandler = new MyTextHandler(this.env);
// Construct a Meeting object to join the RTK meeting
const transport = new RealtimeKitTransport(meetingId, authToken, [
{
media_kind: 'audio',
stream_kind: 'microphone',
},
]);
const { meeting } = transport;

// Construct a pipeline to take in meeting audio, transcribe it using
// Deepgram, and pass our generated responses through ElevenLabs to
// be spoken in the meeting
await this.initPipeline(
[transport, new DeepgramSTT(this.env.DEEPGRAM_API_KEY), textHandler, new ElevenLabsTTS(this.env.ELEVENLABS_API_KEY), transport],
agentId,
workerUrl,
accountId,
apiToken,
);

// The RTK meeting object is accessible to us, so we can register handlers
// on various events like participant joins/leaves, chat, etc.
// This is optional
meeting.participants.joined.on('participantJoined', (participant) =&amp;gt; {
textHandler.speak(`Participant Joined ${participant.name}`);
});
meeting.participants.joined.on('participantLeft', (participant) =&amp;gt; {
textHandler.speak(`Participant Left ${participant.name}`);
});

// Make sure to actually join the meeting after registering all handlers
await meeting.rtkMeeting.join();
}

async deinit() {
// Add any other cleanup logic required
await this.deinitPipeline();
}
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;Cloudflare 指出，要讓語音交互達到「自然對話」的體驗，總延遲需低於 800 毫秒，而其分佈式邊緣架構正好能滿足這一苛刻要求。平台同時兼容多種 AI 模型和第三方服務，支持高度可組合的語音處理管道。&lt;/p&gt; 
&lt;p&gt;目前，Cloudflare Realtime Agents 已開放 Beta 公測，開發者可免費試用並基於該平台開發新一代實時語音 AI 應用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369855/cloudflare-realtime-voice-ai</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369855/cloudflare-realtime-voice-ai</guid>
      <pubDate>Tue, 02 Sep 2025 06:49:31 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Cloudflare 扛下了峯值達 11.5 Tbps 的超大流量 DDoS 攻擊</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cloudflare &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCloudflare%2Fstatus%2F1962559687368593552" target="_blank"&gt;宣佈&lt;/a&gt;其自動化防禦系統在過去幾周裏成功攔截了數百次超大規模 DDoS 攻擊，其中最大一次攻擊的峯值達到 11.5 Tbps（51 億數據包/秒）。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1448" src="https://static.oschina.net/uploads/space/2025/0902/142809_8xYe_2720166.png" width="1280" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，此次攻擊類型為 UDP Flood（UDP 泛洪）攻擊，這一峯值刷新了 Cloudflare 自己在 2025 年 5 月創下的 7.3 Tbps 紀錄。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cloudflare.com%2Fzh-cn%2Flearning%2Fddos%2Fudp-flood-ddos-attack%2F" target="_blank"&gt;UDP 洪水&lt;/a&gt;是一種拒絕服務攻擊，攻擊者將大量用户數據報協議 (UDP) 數據包發送到目標服務器，旨在讓該設備的處理和響應能力無力承擔。由於 UDP 洪水攻擊，保護目標服務器的防火牆也可能不堪重負，導致對正常流量拒絕服務。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Cloudflare 表示將在即將發佈的技術報告中提供更詳細的攻擊與防禦分析。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369850</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369850</guid>
      <pubDate>Tue, 02 Sep 2025 06:30:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>百度網盤基於 Flink 的實時計算實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;01 概覽&lt;/h1&gt; 
&lt;p&gt;隨着數字化轉型的來臨，企業對於數據服務的實時化需求日益增長，在大規模數據和複雜場景的情況下，Flink 在實時計算數據鏈路中扮演着極為重要的角色，本文介紹了網盤如何通過 Flink 構建實時計算引擎，從而提供高性能、低延遲、穩定的實時計算能力。&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;02 百度網盤實時計算演進&lt;/h1&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.1 百度網盤實時計算演進歷程&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ff0daf696dfc0e69e28e45f204abba37d2d.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△百度網盤實時計算演進&lt;/p&gt; 
&lt;p&gt;在 2020 年，網盤主要通過 Spark Streaming 和 Spark Structured Streaming 來用於特定場景的支持，主要是在數據同步場景、實時清洗方面的應用。&lt;/p&gt; 
&lt;p&gt;為瞭解決 Spark Streaming 存在的監控告警薄弱、接入成本高、時效性低等問題，網盤於 2023 年初首次引入 Flink 實時計算引擎，並基於百度內部 StreamCompute 平台快速建設集指標監控、告警、任務生命週期管理能力；經過調研測試我們發現 Flink 任務從 0 到 1 接入成本高、開發門檻高，因此，我們開始調研實時計算引擎的解決方案，目標是降低開發門檻、配置化任務接入，最終建設網盤內部的實時計算引擎 Tiangong 來為業務提供更好的支持。&lt;/p&gt; 
&lt;p&gt;截止至今，Tiangong 計算引擎目前已在數據團隊、反作弊團隊、用户增長等場景廣泛應用,並支持數百萬億的大流量場景。未來我們也計劃將基於 Tiangong 建設網盤一體化實時計算平台，從而賦能網盤內部各個業務線實時計算能力建設。&lt;/p&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.2 為什麼選擇 Flink&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;網盤實時計算引擎從 Spark Streaming 和 Spark Structured Streaming 演進而來，為什麼放棄 Spark 體系選擇 Flink 主要從以下幾個方面出發：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1b64f0cfcd52025073f9ddb65a663c421ca.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-a4a6791fde81a3784568fd35cbec23678b0.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-51f283dc22dd7fa64e59af474f7ba8763c6.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;從&lt;strong&gt;&lt;strong&gt;百度內部實時計算 RoadMap 和狀態管理、流批一體、監控告警、任務管理、生態體系&lt;/strong&gt;&lt;/strong&gt;等各方面我們選擇基於 Flink 建設網盤內部的實時計算平台。&lt;/p&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.3 實時計算引擎&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_6"&gt;&lt;/span&gt; 
&lt;h3&gt;2.3.1 實時計算引擎接入現狀&lt;/h3&gt; 
&lt;p&gt;目前，百度網盤的 Tiangong 計算引擎已接入&lt;strong&gt;&lt;strong&gt;17+應用場景&lt;/strong&gt;&lt;/strong&gt;，高峯時作業處理的吞吐量達到&lt;strong&gt;&lt;strong&gt;千萬/s&lt;/strong&gt;&lt;/strong&gt;，而機器規模也已經達到了&lt;strong&gt;&lt;strong&gt;1500 台，資源 5800CU&lt;/strong&gt;&lt;/strong&gt;，並且已經覆蓋用商策略、反作弊、主端一刻用增實時投放等多個場景。&lt;/p&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;2.3.2 Flink Tiangong 引擎架構&lt;/h3&gt; 
&lt;p&gt;如下圖所示的是網盤 Tiangong 實時計算引擎的架構。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;最下層為&lt;strong&gt;&lt;strong&gt;Runtime 層&lt;/strong&gt;&lt;/strong&gt;，負責 Tiangong 計算任務的部署方式，目前支持 StreamCompute、Kubernetes、Yarn、Local 等方式；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;核心能力包括&lt;strong&gt;&lt;strong&gt;Source 組件&lt;/strong&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;strong&gt;Sink 組件&lt;/strong&gt;&lt;/strong&gt;以及&lt;strong&gt;&lt;strong&gt;數據轉換引擎&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Source 組件：支持 Db、Message Queue、BigData 組件、自定義 Source 等多個異構數據源；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Sink 組件：支持 Db、Message Queue、BigData 組件、自定義 Sink 等多個異構數據目的地；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據轉換引擎：支持流批一體、自定義配置化數據清洗、精準一次數據處理、失敗容錯、IOC 容器化管理、自定義 SQL 拓撲、靈活監控告警等能力；&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-74b109ea6e0d5ddbebe0bd962c9af807613.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ Tiangong 計算引擎&lt;/p&gt; 
&lt;p&gt;從&lt;strong&gt;&lt;strong&gt;功能層面來看&lt;/strong&gt;&lt;/strong&gt;，Tiangong 實時計算引擎主要包括作業管理和資源管理。其中，作業部分包括作業配置、作業上線以及作業生命週期管理三個方面的功能。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;&lt;strong&gt;作業配置&lt;/strong&gt;&lt;/strong&gt;方面，則包括運行環境配置、source 配置、sink 配置、清洗邏輯配置以及作業拓撲結構設置；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"作業名",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"env": {運行環境配置},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sources": [source 端配置],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"udfs": [用户定義函數],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"views": [清洗邏輯],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"coreSql": [核心寫入邏輯],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sinks": [sink 端配置],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"customTopology": {自定義作業運行拓撲}
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;&lt;strong&gt;作業發佈&lt;/strong&gt;&lt;/strong&gt;方面，則包括作業啓動、取消以及刪除等；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c2677e04e1a592c6d5a72bb8e32d89797a6.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;作業狀態&lt;/strong&gt;則包括自定義規則告警、監控大盤等；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-948683468fce0ec01ef0607dbfb5b63ca3d.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ 自定義規則告警&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c528ec4707296e887eba9063ab6d6a100b8.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;△ 監控大盤&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在&lt;strong&gt;資源管理&lt;/strong&gt;方面，利用 StreamCompute 平台能力支持 Flink 集羣動態擴縮容能力與灰度發佈能力；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.4 業務場景實踐&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;前面提到實時計算引擎演進過程和實時計算引擎對比，可以看出網盤實時計算引擎更多地會關注在&lt;strong&gt;&lt;strong&gt;易用性、穩定性和監控告警體系&lt;/strong&gt;&lt;/strong&gt;等方面，具體體現的應用場景主要涉及服務端日誌、埋點日誌、DB Binlog 等場景的實時清洗計算。&lt;/p&gt; 
&lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
&lt;h3&gt;2.4.1 網盤實時商業 BI 中心&lt;/h3&gt; 
&lt;p&gt;網盤現階段缺乏商業收入數據實時分析與商業策略實驗實時評估的能力，導致商業策略 AB 實驗推全鏈路往往需要經過周粒度才能完成，建設一套適用於網盤的實時商業 BI 中心有益於加快策略實驗迭代與實時商業流水波動分析，助力網盤整體收入增長；&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-b78bb1842f1545d8beac3a5569684f6cc8e.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;如上圖，通過將收銀台行為、商業訂單、策略實驗埋點數據秒粒度接入至實時數倉 Palo 中後，配合數據可視化平台 Sugar 建設商業實時 BI 中心，以此來助力商業策略、商業 PM 等各個角色快速完成 AB 實驗快速推全，&lt;strong&gt;&lt;strong&gt;將天粒度實驗收益評估機制優化至分鐘粒度，整體實驗推全鏈路由周粒度優化至天粒度；&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-12f751e8070eaf1039286a6aeabcbe754c7.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.1.1 Tiangong 配置化接入&lt;/h4&gt; 
&lt;p&gt;下述案例為 Tiangong 引擎配置化接入商業訂單實時流：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;strong&gt;實時流數據源配置&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;"sourceType":&amp;nbsp;"bp_source",
&amp;nbsp;&amp;nbsp;"deserializerType":&amp;nbsp;"STRING",
&amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"parallelism":&amp;nbsp;20,
&amp;nbsp; &amp;nbsp;&amp;nbsp;"operatorName":&amp;nbsp;"xietong_strategy_businessorder_fr_bp_source",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"metaHost":&amp;nbsp;"host:ip",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"cluster":&amp;nbsp;"demo-cluster",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"username":&amp;nbsp;"username",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"password":&amp;nbsp;"password",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"pipeletName":&amp;nbsp;"demo-pipelet-name",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"pipeletNum":&amp;nbsp;"20",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"startingOffset":&amp;nbsp;{},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"startPoint":&amp;nbsp;"LATEST",
&amp;nbsp; &amp;nbsp;&amp;nbsp;"endOffset":&amp;nbsp;{},
&amp;nbsp; &amp;nbsp;&amp;nbsp;"bpWebServiceAddress":&amp;nbsp;"service_address"
&amp;nbsp;&amp;nbsp;}


&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;strong&gt;核心處理邏輯配置&lt;/strong&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"netdisk_membership_order_deatils_bp2doris",
&amp;nbsp;&amp;nbsp;"env": {
&amp;nbsp; &amp;nbsp;&amp;nbsp;"streamConfigName":&amp;nbsp;"20p_ck_3s_10fail_env", &amp;nbsp;## 環境配置，主要配置 Checkpoint 間隔和並行度，根據數據量定義，一般為上游消息隊列分區倍數
&amp;nbsp; &amp;nbsp;&amp;nbsp;"tableConfig": {}
&amp;nbsp; },
&amp;nbsp;&amp;nbsp;"sources": [
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"configType":&amp;nbsp;"CONFIG",
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceTableName":"membership_order_binlog",&amp;nbsp;## 數據源配置，bigpipei 訂單實時流
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;"prod/netdisk_membership_order_bp_source"
&amp;nbsp; &amp;nbsp; },
&amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"configType":&amp;nbsp;"SQL",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"sourceConfig":&amp;nbsp;"CREATE TABLE ods_order_info_rt &amp;nbsp;## 寫入目的地配置，palo 寫入表
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; order_no &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; string,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; user_id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; dev_uid &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; app_id &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; bigint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client_channel &amp;nbsp; tinyint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pay_channel &amp;nbsp; &amp;nbsp; &amp;nbsp;tinyint,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; product_id &amp;nbsp; &amp;nbsp; &amp;nbsp; string,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ....&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) WITH (
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'connector' = 'doris',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'fenodes' = 'host:ip',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'table.identifier' = 'dbName:tableName',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'username' = 'username',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'password' = 'password',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.properties.format' = 'json',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.properties.read_json_by_line' = 'true',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.label-prefix' = 'label-prefix',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.enable-2pc'='true',
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;'sink.parallelism' = '1'
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;)"
&amp;nbsp; &amp;nbsp; &amp;nbsp;}
&amp;nbsp; ],
&amp;nbsp;&amp;nbsp;"views": [
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"name":&amp;nbsp;"binlog_filter_view", &amp;nbsp;## 核心數據處理邏輯，純 SQL 接入
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sql":&amp;nbsp;"select CAST(JSON_VALUE(new_values, '$.id') as bigint) &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; as id,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;JSON_VALUE(new_values, '$.business_no') &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;as business_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;JSON_VALUE(new_values, '$.order_no') &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; as order_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;UNIX_TIMESTAMP() &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;as write_timestamp,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; FROM membership_order_binlog,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;LATERAL TABLE(BINLOG_NEWVALUES_FILTER(f0))"&amp;nbsp;## 系統內置 Binlog 清洗 TableFunction
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; ],
&amp;nbsp;&amp;nbsp;"coreSql":&amp;nbsp;"insert into ods_order_info_rt select id, ## 寫入下游 palo 表，寫入間隔為 Checkpoint 間隔，上述配置為 3 秒，每 3 秒寫一批
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; business_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; order_no,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; user_id,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; write_timestamp from binlog_filter_view"
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;2.4.1.2 可視化監控體系&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Flink 作業 UI 監控&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69cd7c139cb26ff6c4cb22aa26d0a51dac2.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Grafana 監控大盤&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c382bbdb77491e740a37f537c09928bfcee.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;實時任務監控配置&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ae14913e3a48ac003c019e0c77bc2c31803.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c1c8546f688a4e07ed3899c27c96124567e.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;2.4.2 用户商業策略實時特徵&lt;/h3&gt; 
&lt;p&gt;基於商業策略實時核心行為相關特徵依賴場景，結合核心行為以及用户付費埋點行為數據建設從 0 點實時累計特徵與基於滾動窗口的近 X 分鐘實時特徵有助力策略側對用户剛需需求的感知，並結合用户剛需行為個性化出價以此促進整體商業收入。&lt;/p&gt; 
&lt;span id="OSC_h4_13"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.2.1 核心方案&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bc054f9d461927471f7fe77334ba9aedef2.jpg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如上圖，方案二主要將數據流拆為三塊，如流數據拼接、熱點文件計算、消費行為統計；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;流數據拼接：利用 Tiangong 計算引擎，通過 Flink SQL+行為清洗 UDF 函數，將各類行為數據打平為統一格式，並通過 union all 進行聚合，過濾異常數據後行為行為視圖，數據流式產出。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;熱點文件計算：實時將各個 file_md5 的消費次數存儲 Flink Map 狀態中，並根據離線分析得到的熱點文件消費閾值判斷熱點文件，將熱點文件流式寫入 Bigpipe 與 Palo 中，數據流式產出，最優可做到毫秒級；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;消費行為次數計算：根據熱點文件數據流關聯用户消費行為，實時對用户消費的文件進行熱點/普通歸一化處理，後續將每個用户消費不同行為類型的熱點/普調次數寫入 Flink Map 狀態中，累加計算從 0 點至今的文件消費次數，實時寫入 Doris 和 Palo 中，最優可做到秒級；&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_14"&gt;&lt;/span&gt; 
&lt;h4&gt;2.4.2.2 技術難點&lt;/h4&gt; 
&lt;span id="OSC_h4_15"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;（1）大狀態問題&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;問題引入&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;熱點文件和用户消費文件次數的計算，都涉及到數據累計的問題，如果將數據存儲在共享存儲 (例如 Redis/Table) 這類 kv 存儲中，每條數據或每個窗口的數據都需要先查一下上次的計算結果，累加後再寫入共享存儲中，這從而導致每次計算多一次網絡讀 IO 操作，故利用 Flink 狀態機制，將熱點文件和用户消費次數存儲在 Flink 狀態中，每次判斷都在 TaskManger 本地或者內存中，不涉及到網絡 IO 操作，故性能更好。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據都存入 Flink 狀態中也導致 Flink 存在大狀態問題，從而導致 Checkpoint 耗時過大從而引起任務背壓，最終導致數據處理延遲等問題。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;解決方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;狀態後端優化&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;選擇 Rocksdb 作為狀態後端，開啓增量 Checkpoint&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;配置 changelog 狀態機制，防止 Rocksdb 定期 Compaction 導致的 Checkpoint 耗時久問題&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;調整 rocksdb manged 內存大小、rocksdb write buffer 大小&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;快照存儲優化&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;開啓快照壓縮配置&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;狀態 TTL 機制&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;長期為更新的狀態做小時粒度更新，防止狀態持續增大。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_16"&gt;&lt;/span&gt; 
&lt;h4&gt;（2）TableStroage 寫入性能差&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;問題引入&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;因廠內 Table API 創建 Table Client 過程中需要根據特定表對應的機器數創建對應個數的 brpc-client-work-thread、brpc-client-io-thread、fairStrategy-timer-thread 等線程，共計 3*機器數個，網盤特徵 Table 存儲底層表佔用 200 台機器，故創建一個 Table Client 需要創建 600+線程，從而導致 Flink 計算節點的底層 martix 容器線程超限，經過和 StreamCompute 同學溝通需限制 Table Client 的 Rpc 線程數為 1，並對應 Flink 集羣的計算節點容器最大線程數由 1000-&amp;gt;1500，從而解決線程超限問題。但因限制 Table Client Rpc 線程為 1 導致 Table 整體寫入性能偏差。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;解決方案&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;細粒度拆分任務，首先對用户各類行為以及消費的熱點/普調資源進行實時計算，後續根據 user_id+行為類型 keyby，並開 3s 窗口，取最新的數據落入 Table，將 3s 一個窗口的數據進行壓縮。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;優化效果&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;原本天粒度寫入 48 億+次行為特徵優化為 2 億+次，具體效果如下圖：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-fdcddf10090d37e3776cde4cb75d57067a2.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;業務場景大致可以分為實時數倉、實時數據複雜聚合計算、DB 業務數據 CDC 等場景，在這幾個場景 Flink 本身就提供高性能、高穩定性的能力，再配合網盤 Tiangong 實時計算引擎不熟悉 Flink 的業務方也可以配置化、低代碼的方式快速建設起實時應用。&lt;/p&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;03 Flink 技術挑戰和解決方案&lt;/strong&gt;&lt;/h1&gt; 
&lt;span id="OSC_h2_18"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;3.1 Flink 底座建設&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d39092554eff2e87316084e6fdcb8f92ea8.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ Flink 基建建設&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;基於 StreamCompute 平台提供的動態擴縮容、任務生命週期管理、Flink 多版本管理、雲原生監控告警體系等能力，來快速構建網盤 Flink 實時計算能力。&lt;/p&gt; 
&lt;span id="OSC_h2_19"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;3.2 實時計算平台建設&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69d603f60931ccad9cf0674847f7933474f.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;em&gt;△ Tiangong 計算引擎&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-973c854085abdf3899d3eb3d948b42258a5.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以上為 Tiangong 計算引擎能力支持，其作為網盤實時計算平台支持目前廠內大部分異構數據源，使用方可以通過簡單的配置快速建設實時計算能力，拿上述業務場景實踐中的用户商業策略實時特徵項目接入 Tiangong 來看，只需下述配置和少量窗口數據聚合邏輯開發即可：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;"jobName":&amp;nbsp;"business_feature_compute_bp2table",&amp;nbsp;// 作業名
&amp;nbsp; &amp;nbsp;&amp;nbsp;"env": {&amp;nbsp;// 作業運行環境配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"streamConfigName":&amp;nbsp;"300p_ck_30s_5fail_env",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"tableConfig": {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"stateTtlMs":&amp;nbsp;600000
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; },
&amp;nbsp; &amp;nbsp;&amp;nbsp;"sources": [ &amp;nbsp;// source 配置，download 日誌
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"configType":&amp;nbsp;"CONFIG",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceTableName":&amp;nbsp;"idc_log_source",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sourceConfig":&amp;nbsp;"prod/business_strategy_idc_bp_source"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"udfs":[ &amp;nbsp;// 數據清洗轉換邏輯，SQL 無法完成時通過 UDF
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name":&amp;nbsp;"idc_log_filter_func",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"className":&amp;nbsp;"com.baidu.xxx.IdcLogFilterFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;},
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"name":&amp;nbsp;"idc_feature_transform_func",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"className":&amp;nbsp;"com.baidu.xxx.IdcFeatureTransformFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;}
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;],
&amp;nbsp; &amp;nbsp;&amp;nbsp;"views": [
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"name":&amp;nbsp;"idc_log_feature_view",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"sql":&amp;nbsp;"select feature_data.event_time as event_time,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; from (select idc_feature_transform_func(f0) as feature_data
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; from idc_log_source
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; where idc_log_filter_func(f0) = true) as tmp
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; where feature_data.log_time &amp;lt;&amp;gt; '0' and ....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp; "sinks": [ // 雙寫 TableStorage、Doris
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "sinkConfigNames": ["prod/netdisk_strategy_idc_feature_mi_table_sink","prod/netdisk_strategy_feature_doris_sink"],
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "transformSQL": "select event_time,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;.....
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;from&amp;nbsp;idc_log_feature_view",
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"watermarkConfig":{ &amp;nbsp;// 涉及開窗邏輯所涉及的 watermark 配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "maxOutOfOrdernessMs": 5000,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "idlenessMs": 10000,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "timeAssignerFunctionName": "row_event_time_assigner"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;},
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// 開窗計算邏輯函數
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; "rowTransformFunc": "strategyFeatureTransformFunction"
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; ]
&amp;nbsp; &amp;nbsp; }
}


&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_20"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.3 自定義作業執行計劃&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-69dbff5a89dc2f05b27a8d085a7fb48d22c.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_21"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.1 細粒度算子並行度優化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7ad2e5c0f0ed28115a1b75867bc770094b2.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 細粒度算子並行度優化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Tiangong 計算引擎本質基於&lt;/strong&gt;Flink SQL+Table API+DataStream API&lt;strong&gt;做的混合計算引擎，其本質相當於&lt;/strong&gt;Flink SQL，因此一旦定義好 Source 和 Sink 並行度後，其任務所涉及的計算、清洗、聚合等算子都與 Source 端並行度一致，從而導致如果想要增加清洗等算子的並行度需要把 Source 的並行度也增加，從而造成&lt;strong&gt;資源浪費、性能降低&lt;/strong&gt;等問題。&lt;/p&gt; 
&lt;span id="OSC_h3_22"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.2 分區關係優化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-ea2a39e81c8639ea282035af29524d83c90.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 分區關係優化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;作業內上下游算子連接數過多，會佔用較大的 Network buffer 內存，從而影響作業的正常啓停，基於自定義 SQL 執行計劃能力，我們可以手動將 Rebalance 邊修改為 Rescale。&lt;/p&gt; 
&lt;p&gt;比如上圖的示例，左邊上游算子有 500 個併發，而下游的 Sink 算子只有 200 個併發。在這種場景下，Flink SQL 會默認生成 Rebalance 的連接方式，共需 500*200，共 10 萬個邏輯連接。&lt;/p&gt; 
&lt;p&gt;通過自定義 SQL 執行計劃能力，我們手動將 Rebalance 設置為 Rescale 後，它只需要 500 個連接，大大降低了 Network buffer 的內存需求。&lt;/p&gt; 
&lt;span id="OSC_h3_23"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.3 資源共享策略優化&lt;/strong&gt;&lt;/h3&gt; 
&lt;span id="OSC_h4_24"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;3.3.3.1 資源共享&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;默認情況下，flink 允許 subtask 共享 slot，即使是不同 task 的 subtask，這樣的結果是一個 slot 可以保存作業的整個管道。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果是同一步操作的並行 subtask 需要放到不同的 slot，如果是先後發生的不同的 subtask 可以放在同一個 slot 中，實現 slot 的共享。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-91c2e5c65da10b83eac2d61228780eb003b.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ Slot 與 Task 的關係&lt;/em&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_25"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;3.3.3.2 自定義共享策略&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8a407c1e822cf0460c7731db382dc0e4127.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 資源共享策略優化&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;支持按照算子類型將算子劃分到一個 slot group 中，從而來減少數據的跨網絡傳輸、提升資源利用率以及提升計算性能等。&lt;/p&gt; 
&lt;span id="OSC_h3_26"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;3.3.4 算子名稱優化&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;Flink SQL 不支持為每個算子自定義名稱，從而導致算子名是根據系統規則來生成的，從而導致算子名稱不能夠通俗的表示其具體含義。為了便於作業維護和管理，自定義作業執行計劃支持算子名稱優化。&lt;/p&gt; 
&lt;span id="OSC_h1_27"&gt;&lt;/span&gt; 
&lt;h1&gt;&lt;strong&gt;04 未來展望&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-22e9ef42b66827bf729f41397c5a31925c8.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ 未來展望&lt;/em&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;4.1 實時計算平台化&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前 Tiangong 計算引擎的使用方式主要在公共代碼庫提交&lt;strong&gt;任務配置和 UDF 代碼&lt;/strong&gt;的方式接入，使用方需要擁有&lt;strong&gt;Tiangong 計算引擎的代碼庫權限&lt;/strong&gt;，存在&lt;strong&gt;代碼安全和任務隔離性差&lt;/strong&gt;等問題，後續我們計劃基於 Tiangong 計算引擎搭建網盤自己的實時化計算平台，實現頁面低代碼方式快速接入實時任務。&lt;/p&gt; 
&lt;span id="OSC_h2_29"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;4.2 實時 DTS 平台&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前網盤主要使用廠內 DTS 平台，通過增量 binlog 和全量 select 快照方式採集數據至下游 AFS，整體鏈路為 DTS-&amp;gt;AFS-&amp;gt;UDW，一旦上游表格式變化下游的採集任務就會失敗，因此整體穩定性、維護成本和性能都過差。因此我們計劃基於 Tiangong 計算引擎構建實時 DTS 平台，具體架構如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7e491214027eaa22783681f99487a694842.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;△ RealTime-DTS 架構&lt;/em&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18690345</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18690345</guid>
      <pubDate>Tue, 02 Sep 2025 06:28:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>即夢 AI 全面開放 API 服務</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;即夢 AI 與火山引擎近日宣佈全面開放 API 服務，將包括文生圖 3.0、文生圖 3.1、圖生圖 3.0、視頻生成 3.0pro、數字人 OmniHuman 以及動作模仿 DreamActor M1 在內的多款前沿 AI 模型，向企業級用户開放。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此舉旨在為企業提供豐富且高質量的圖像、視頻生成與編輯服務，開發者無需額外申請，即可通過自助下單快速接入。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="280" src="https://oscimg.oschina.net/oscnet/up-f1dba3641ccfa78bbb35c84a477d3be8b85.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;這些開放的即夢 AI 系列模型，均基於字節跳動自研的 Seedream 和 Seedance 等模型持續優化開發而來。它們已在即夢 AI 產品上得到大規模驗證，展現出強大的應用能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;目前，這些模型能夠廣泛適配於多種應用場景，包括但不限於故事短片創作、營銷物料製作、遊戲素材設計、多媒體課件製作和自媒體玩法拓展等，旨在幫助企業和開發者高效地將創意轉化為現實。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369848</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369848</guid>
      <pubDate>Tue, 02 Sep 2025 06:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通義實驗室推出智能體開發框架 AgentScope 1.0</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里通義實驗室&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F7p525jsxZg3hA-qA12mKJA" target="_blank"&gt;宣佈&lt;/a&gt;推出新一代智能體開發框架——AgentScope 1.0。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;根據介紹，AgentScope 1.0 是一款以開發者為核心，專注於多智能體開發的開源框架。它的核心目標是解決智能體在構建、運行和管理中的難題，提供一套覆蓋「開發、部署、監控」全生命週期的生產級解決方案，讓智能體應用的開發更簡單、運行更安全、監控更透明。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="383" src="https://oscimg.oschina.net/oscnet/up-d60680fa66f2ae6c601ad4b4a681e4c0fcc.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;通義實驗室構建了三層技術架構：AgentScope 核心框架負責智能體的構建與應用編排；AgentScope Runtime 提供安全、可靠的智能體運行和部署環境；AgentScope Studio 提供可視化的開發與監控工具。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在 AgentScope 1.0 體系中，這三層技術架構作為三個獨立的開源項目，根據開發者需求可以被單獨使用。其中&amp;nbsp;AgentScope Runtime&amp;nbsp;和&amp;nbsp;AgentScope Studio，也可以兼容其他主流多智能體編排框架，如 LangGraph 和 AutoGen。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope 核心框架可以看作是一種面向智能體開發的「編程語言」，致力於高效構建基於大語言模型（LLM）的智能體應用。它採用模塊化設計，由&lt;strong&gt;消息&lt;/strong&gt;、&lt;strong&gt;模型&lt;/strong&gt;、&lt;strong&gt;記憶&lt;/strong&gt;和&lt;strong&gt;工具&lt;/strong&gt;四大組件構成，實現高度解耦與靈活擴展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope 1.0 在智能體開發上的關鍵升級，在於其深度融合的三大能力：&lt;strong&gt;實時的介入控制&lt;/strong&gt;、&lt;strong&gt;智能的上下文管理&lt;/strong&gt;、以及&lt;strong&gt;高效的工具調用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;可以把 AgentScope Runtime 理解為智能體的「操作系統」， 它為支撐智能體應用提供了兩大核心基礎設施：&amp;nbsp;&lt;strong&gt;安全工具沙箱&lt;/strong&gt;和&lt;strong&gt;部署運行引擎&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;AgentScope Studio 集成了實時監控與智能體評測兩大核心功能， 併為開發者提供了一站式的可視化平台，為智能體裝上了一套完整的「性能檢測儀表盤」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369841</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369841</guid>
      <pubDate>Tue, 02 Sep 2025 05:55:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>中國教育機器人市場的硬件銷售額上半年達 10.7 億元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;國際數據公司（IDC）發佈的最新數據，2025 年上半年，中國教育機器人市場的硬件銷售額達到了 10.7 億元，同比增長 12.5%。預計到 2029 年，市場硬件銷售額將達到 39.3 億元，五年複合增長率為 12.9%。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="254" src="https://oscimg.oschina.net/oscnet/up-1c5c8e5f3fdfefca3103123c2247ed275d1.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;教育機器人被定義為基於計算機自動控制、能聯網並具備多種功能的智能產品。根據功能和應用的不同，教育機器人可分為三大類:編程機器人、仿生機器人和交互機器人。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;首先，編程機器人以編程教育為核心，通常由可手動組裝的標準化零件和電子模塊構成。它們可以通過編程控制運動，如避障、循跡等，代表品牌包括優必選、阿爾法蛋和樂高等。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;其次，仿生機器人模仿人類或動物的形態，具備多關節運動能力，並支持複雜動作編程和場景模擬。國內企業如優必選和可以科技在這一領域表現突出。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;最後，交互機器人則以語音交互和圖像識別為核心，能夠進行問答、課程講解和個性化學習輔導，代表廠商包括阿爾法蛋和元蘿蔔等。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;IDC 指出，教育機器人市場正在經歷劇烈的變動。雖然市場格局尚未穩定，但編程機器人在課程和賽事的支持下實現了穩定發展。同時，國內廠商憑藉豐富的線下課程和內容積累，展現出強大的競爭力。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在教育場景的細分方面，市場需求也越來越明確。不同的學習場景，如早教、K12 編程啓蒙和語言學習，推動了教育機器人的產品分類與功能細化。這使得企業能夠更好地滿足各類教育需求。&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369840</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369840</guid>
      <pubDate>Tue, 02 Sep 2025 05:47:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 崗位月薪下限均值已達 4.7 萬元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1842108201627391251%26wfr%3Dspider%26for%3Dpc" target="_blank"&gt;據時代財經報道&lt;/a&gt;，7 月、8 月以來，阿里巴巴、字節跳動、騰訊、美團、京東等公司相繼啓動 2026 屆秋招，不少公司宣佈發放的 Offer 數量同比增長。&lt;/p&gt; 
&lt;p&gt;一個更明顯的趨勢是，2026 屆的校招已不再是一場例行的人才補充，而是大廠面向 AI 時代發起的一輪「人才軍備競賽」。多位受訪應屆生表示，今年人工智能帶來的增長預期確實在很大程度上左右了他們的職業選擇。對於技術崗，AI 已成為未來業務發展的關鍵變量；而在非技術崗上，如果公司業務與 AI 掛鈎，入職後也幾乎離不開相關學習。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b10b0838721b75f8e68388315bb23787867.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;脈脈數據顯示，截至 7 月，AI 崗位的招聘薪資下限均值為 4.7 萬元/月，較 2024 年初上漲 14.16%；上限均值則達到 7.8 萬元/月，同比上漲 8.98%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-29ae1eee802c0dc2b491e8337dc94bf8fcc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;《2026 屆校招市場 AI 人才需求報告》也顯示，在薪酬方面，大模型算法工程師以 2.48 萬元/月的中位值居首，深度學習工程師和自然語言處理工程師緊隨其後，均在 2.4 萬元/月左右；多模態算法工程師、自動駕駛算法工程師、機器學習工程師、推薦算法工程師薪酬中位值均超過 2.3 萬元/月。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-3ef9583a4548c9ce19cdca44511498ab831.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;有獵頭在朋友圈感嘆，頂尖高校的應屆博士年薪逼近 200 萬元。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369822</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369822</guid>
      <pubDate>Tue, 02 Sep 2025 03:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿聯酋 AI 公司 G42 據悉尋求芯片供應多元化，避免過於依賴英偉達</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;據消息人士稱，阿聯酋人工智能（AI）公司 G42 正在與多家科技巨頭洽談，試圖吸引它們入駐該國規劃的 AI 園區。此外，G42 還計劃在芯片供應上實現多元化，而不僅依賴英偉達。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;知情人士透露，G42 目前的洽談對象包括，亞馬遜 AWS、谷歌、Meta、微軟以及馬斯克的 xAI，其中谷歌的談判進度最為領先，可能率先簽訂計算力採購協議。該知情人士還表示，G42 還在尋求 AMD、Cerebras Systems（G42 持有部分股權）和高通等美國芯片製造商，為園區提供部分算力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;今年 5 月，美國總統特朗普在訪問阿聯酋時，與該國達成合作協議。雙方將合作建設一個擁有 5 GW 數據中心的 AI 園區。其中已有 1 GW 項目落地：OpenAI 與阿布扎比的 MGX、日本軟銀、以及甲骨文合作，宣佈將在此建立其首個美國境外星際之門（Stargate）數據中心。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;上述 1 GW 項目將採用英偉達 Grace Blackwell GB300 系統，這是目前英偉達最先進的 AI 芯片。該項目作為阿聯酋–美國 AI 園區首個階段，預計於 2026 年左右上線。雖然星際之門獲得了最多關注，但它僅佔 AI 園區整體規模的 20%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作為歐佩克（石油輸出國組織）的重要成員國之一，阿聯酋正在加速推動 AI 發展，以應對來自鄰國卡塔爾和沙特阿拉伯的競爭。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;沙特公共投資基金（PIF）支持的 AI 公司 HUMAIN 計劃到 2030 年建設 1.9 GW 容量數據中心，並在 2034 年擴展至 6 GW。據 HUMAIN 首席執行官透露，其現有及在建數據中心的算力已全部售罄。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，阿聯酋在芯片選擇上幾乎完全押注美國芯片製造商，而這些算力將主要由美國客户消費和銷售。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369821</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369821</guid>
      <pubDate>Tue, 02 Sep 2025 03:40:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>蘋果內部 AI 聊天機器人「Asa」曝光，為零售員工打造專屬 AI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;MacRumors 網站的亞倫·佩里斯（Aaron Perris）透露，蘋果正在內部測試一款名為「Asa」的 AI 聊天機器人。這款工具旨在賦能 Apple Store 零售員工，幫助他們快速掌握 iPhone 等產品的特色和差異化使用場景，從而提升與顧客互動時的解説能力，改善店內體驗。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;佩里斯分享的截圖顯示，「Asa」已被整合進蘋果內部的「SEED」應用服務，該平台原本就作為教育培訓和銷售輔助工具。引入「Asa」意味着蘋果正通過 AI 來強化其零售體驗。對員工而言，「Asa」不僅僅是一個簡單的常見問題解答（FAQ）系統，它更是一個能夠即時響應問題並提供情境化建議的智能工具。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="655" src="https://static.oschina.net/uploads/space/2025/0902/110329_8nvn_4252687.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;蘋果一直將其零售店視為品牌體驗的關鍵延伸，它不僅是銷售場所，更是傳播產品哲學和設計理念的據點。「Asa」的部署旨在迅速提升每位員工的專業知識水平，避免因個人經驗差異導致顧客獲得不一致的信息。這一做法也符合蘋果長期以來在零售端強調「一致體驗」的策略。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;儘管「Asa」是蘋果&lt;span&gt;首次&lt;/span&gt;在內部零售場景大規模引入的 AI 助手，但公司尚未對外發布任何面向消費者的「通用型聊天機器人」。與谷歌、OpenAI 和三星等競爭對手快速整合 AI 服務不同，蘋果選擇了更為謹慎的步伐。它首先從內部環節入手，確保 AI 的實際價值和可靠性，然後逐步將其擴展到更廣泛的產品策略中。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="276" src="https://static.oschina.net/uploads/space/2025/0902/110346_rQTN_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這引發了外界的猜測，即將到來的 2025 年秋季新品發佈會是否會帶來更多與 AI 相關的驚喜。蘋果過去多次強調設備端 AI（on-device AI）的隱私和性能優勢。如果「Asa」在內部證明其價值，或許意味着某種形式的 AI 助手未來將集成到 iPhone 或其他蘋果設備中，成為與競爭品牌抗衡的重要武器。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369811</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369811</guid>
      <pubDate>Tue, 02 Sep 2025 03:04:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>基於接口數據變異的 App 健壯性測試實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;本文整理自美團技術沙龍第 77 期《美團億級流量系統的質量風險防控和穩定性治理實踐》，主要介紹了對網絡返回數據進行變異的客户端健壯性測試實踐經驗。文章第一部分介紹客户端健壯性測試的基本概念；第二部分分享了基於接口返回數據變異的 App 健壯性測試方案設計的思路；第三部分主要解讀了變異數據的構造和異常檢測方案設計；第四部分介紹了精簡變異數據的探索方案。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-7af175bfec290a4eaf573f8d9af531e6e3a.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;01 什麼是客户端健壯性&lt;/h2&gt; 
&lt;p&gt;在維基百科的定義中，健壯性（Robustness）是指一個計算機系統在執行過程中處理錯誤，以及算法在遭遇輸入、運算等異常時繼續正常運行的能力。IEEE 中將健壯性定義為系統或組件在存在無效輸入或壓力環境條件下可以正常運行的程度。早在 1989 年，Barton Miller 首次提出了模糊測試的概念，通過向目標應用拋出隨機字符串的方式來測試 UNIX 應用程序的健壯性；而在 1996 年的 Ballista 項目中，研究人員探索根據 API 定義的數據類型，對操作系統或軟件接口進行自動化測試方法。兩個項目均以「無應用程序崩潰或掛起」作為測試驗證通過的標準。&lt;/p&gt; 
&lt;p&gt;在移動端 App 領域，健壯性可以理解為 App 運行時遭遇環境異常或者輸入異常時客户端能夠繼續正常運行的能力。&lt;/p&gt; 
&lt;p&gt;其中，環境異常主要分為操作系統異常、外部環境異常、硬件環境異常三大類。比如內存不足、CPU 負載過高、線程池滿載、內存分配失敗、網絡連接失敗等。輸入異常主要分為系統輸入和用户輸入。比如網絡接口返回的數據異常、應用內緩存、數據庫文件讀寫異常，這類的異常屬於在系統輸入異常；在電話號碼輸入框場景，用户輸入的空格、富文本則屬於用户輸入異常。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/4fdab56f61f04f048402f221d50a7004588446.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;對於這些風險，如果 App 沒有處理，理論上都可能會產生展示異常、交互異常、性能、安全等問題，導致用户無法繼續使用或在使用過程中產生不好的體驗。比如用户操作 App 下單過程中，API 請求出現故障未返回狀態碼為 200 的響應，App 由於沒有獲取到預期接口響應的信息而發生崩潰，就會中斷用户的使用流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/417e16a588aef8f6887c920f641279b6490396.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;02 基於接口數據變異的 App 健壯性測試方案設計&lt;/h2&gt; 
&lt;p&gt;在實際的客户端測試執行過程中，測試人員會考慮測試異常輸入的場景，但由於成本無法做到無窮盡的測試，同時還存在人工執行遺漏的風險。&lt;/p&gt; 
&lt;p&gt;從美團 App 平台業務的歷史故障分析中，我們發現：網絡請求返回的數據與實現預期不符引發的 Crash 或核心功能缺失問題導致的故障佔比最高，且影響面較廣。比如接口返回非預期數據時，客户端處理數據類型轉換異常導致閃退，即使 5 分鐘內操作降級仍影響了百萬量級的用户。因此美團平台業務 App 的健壯性測試探索優先從發現網絡請求返回數據導致的異常開始。&lt;/p&gt; 
&lt;p&gt;針對於發現請求接口返回客户端非預期數據導致的 Crash，或者核心模塊缺失問題這個訴求，我們調研後發現方案的基本原理都是相似的，即以網絡請求的原始響應為基礎，根據規則進行變異構造，使用代理工具改寫響應體返回給客户端，在端上設備做異常檢測。但是都存在一些問題不能滿足訴求，比如測試變異數據是根據預置或者自定義規則隨機生成組合，隨機性過大，不能有效攔截健壯性問題；但如果不做隨機，產生的用例組合量過大，測試不能在合理時間範圍內結束；另外在檢測能力方面，不具備發現業務異常或功能模塊異常的能力。&lt;/p&gt; 
&lt;p&gt;因此，我們結合通用方案做了一些自定義改造，整體檢測方案包含靜態檢測和動態檢測兩部分。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;靜態檢測，主要是指靜態代碼掃描，將典型代碼編寫規範問題轉化為自定義靜態代碼掃描規則，管控增量代碼，同時長期治理存量風險。比如自定義了 PrimitiveParseDetector、ColorParseDetector，管控業務必須使用健壯性測試通過的工具類。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;動態檢測是指結合觸發時機，構造並注入變異數據後，識別 App 運行時是否出現崩潰、掛起或業務功能模塊異常。比如在集成事件/迴歸事件觸發自動化測試運行，構造觸發異常的數據進行動態測試，然後監測是否出現了異常。核心動作包含構造變異數據和完成檢測兩部分。比如將接口響應體中表示顏色含義的 Key 對應的 Value 值構造成非色值，然後檢測客户端請求處理接口數據時是否出現崩潰或掛起。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下文重點介紹端到端的動態檢測方案。&lt;/p&gt; 
&lt;h2&gt;03 變異數據的構造和異常檢測&lt;/h2&gt; 
&lt;p&gt;對於美團 App 來説，首頁有多種形態，對於某種特定形態，除了控制請求數據外還需要控制實驗、策略等一系列因素，才能保證測試對象的唯一性。一個頁面中包含多個異步請求，因此請求的構造也需要和頁面路徑關聯。這些都是採集變異所需的基礎數據時需要關注和控制的。&lt;/p&gt; 
&lt;p&gt;響應體由基本類型數據和複合類型數據組成，相同基本類型的數據可能具備不同的業務語義，需要根據語義的類型做變異規則的區分對待，才能保障業務場景覆蓋。&lt;/p&gt; 
&lt;p&gt;因此，如何保障變異數據構造的全面性和準確性，是我們面臨的首要挑戰。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/fcae8a57bc7fecc23c02e1f003103636490174.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;要解決數據構造全面性問題，首先要解決頁面描述方案，這樣才能控制獲取基礎數據的唯一性。在解決方案中，我們構建了頁面描述的特徵規則，解決用户視角的頁面標識問題。需要的信息包含端信息、頁面路由信息、實驗策略賬號信息、頁面標識模塊合集等。通過頁面請求數據自動錄製的方式，自動更新迭代請求數據和頁面之間的綁定關係，使得基礎數據能夠隨需求迭代更新，從而通過變異規則構造生成的用例也能夠自動更新。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/749a8a36e3d6c24f0d93d43c1be36ef3138813.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在用例變異生成構造上，對於響應體裏的 Value 設置了語義匹配規則，比如字符串的語義可能代表顏色、頁面跳轉路由、動靜態資源鏈接（即圖片資源數據/視頻文件/GIF 文件），需要區分特徵分別按語義構造異常數據。比如在圖片的變異數據構造裏，除了需要構造非圖片鏈接情況外，還要考慮不同圖片格式、非圖片格式以及非合法的圖片剪裁格式拼接等場景。&lt;/p&gt; 
&lt;p&gt;我們對接口返回數據使用腳本做了初步的語義分析，人工二次校正後建立了基本數據類型和語義的映射集合，結合基本數據類型邊界值和語義定義了初始的變異規則。然後對歷史的線上健壯性問題和線下測試發現的健壯性 Bug 的變異數據進行整理，作為增補的變異規則。&lt;/p&gt; 
&lt;p&gt;在自動化測試執行過程中，我們基於 App 可測性改造提供的能力，對測試場景進行了控制，同時基於佈局視圖的解析 SDK、App 異常上報 SDK 提供的能力，完成了對 App 異常的通用檢測。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/025aa7a5939998f5b79ecebc0b27a2e6596526.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;04 變異數據的精簡方案&lt;/h2&gt; 
&lt;p&gt;伴隨着變異規則的豐富，自動生成的數據量級是巨大的，數據的變異組合如果按照全覆蓋方式來生成組合數量就是指數級增長。比如對於 1 種有 7 種變異取值的變量，如果存在 n 個此類型變量，就會產生 7^n 種數據組合，並且在實際業務場景中很多組合情況是沒有意義的。&lt;/p&gt; 
&lt;p&gt;如何在保障用例構造全面性的情況下精簡變異構造的用例數，是我們面臨的第二個挑戰。解決方案包含 2 個策略：1）數組元素結構一致時，刪減構造的用例數；2）結構不完全一致的數組元素，引入編輯距離和並查集算法判斷節點相似性，節點不相似，可以在一次數據生成裏做合併構造。&lt;/p&gt; 
&lt;p&gt;我們可以把請求響應的 JSON 理解成樹，第一個解決思路是判斷樹中節點、路徑的相似度，相似節點刪減構造。&lt;/p&gt; 
&lt;p&gt;如果路徑、節點相似，可以推測路徑即業務邏輯也是一致的，比如頁面上的一些列表元素，可能是數據結構對象完全一致數組，如果對每個數組對象中的每個元素進行全用例構造，生成的變異數據量極大，且對業務場景或代碼邏輯的增量覆蓋有限，因此我們決定將構造邏輯優化，進行刪減構造。即假如數組中元素的結構完全一致，那麼同含義的字段可以為他們分配不同的變異構造值，然後刪減掉無效的構造情況。應用這種方法可以有效降低 28% 左右的用例構造數量。&lt;/p&gt; 
&lt;p&gt;如圖數組的 3 個元素中均存在「resourceName」鍵值對，假如每個鍵值對有 3 種變異取值，按照全排列方式進行用例構造將會生成有 9 份變異數據，在刪減構造情況下，可以分別為它們構造一個特定的變異值，這樣變異生成用例數量可以從 9 減少為 1。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/1aafbb6221bd6e6d58f9b34b1e6c1740511997.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在對業務接口返回數據的數據結構進行分析後，我們發現在層級越深的場景下，距離根節點越近的兩個節點，業務邏輯耦合和結構相似程度越低，它可以進行合併構造，相互邏輯之間不會產生影響，比如有兩個鍵值對，每個鍵值對的 Value 有 3 種變異取值，在合併構造情況下，可以從排列組合的 6 份數據減少到 3 份數據。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/786c1d604282783c4198fd278d19e96a498897.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基於這個個思路，我們在實踐中引入了編輯距離和並查集算法，以節點路徑為參照，對樹的每一層的每兩個節點計算編輯距離，生成一個 n*n 矩陣；同時以樹的高度減去節點位於的層數作為權重，修正編輯距離。基於這樣的計算，會產生多個編輯距離矩陣。&lt;/p&gt; 
&lt;p&gt;為了嘗試最大化合並構造用例效果，我們把編輯距離做了 0,1 矩陣轉化。其中，由於編輯距離為 1 的兩個節點可能存在業務邏輯耦合關係，必須放在同一個組裏分別構造，所以我們把編輯距離大於 1 的情況轉化成了 0，最後得到了一個 0,1 的編輯距離矩陣。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/b2e4be73269fc8a8120b5b85f7733068439100.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在 0,1 矩陣情況下，我們使用了圖的連通性概念，如果 A 和 B 連通，B 和 C 連通，那我們認為 A 和 C 連通，轉化到這裏的概念就是 A 和 B 相似，B 和 C 相似，那麼 A 和 C 相似，它們應該被放在同一個組裏分開進行構造，那麼在同層元素構造時，我們會從每個分組裏取到一個節點，對這些規則進行變異組合構造。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/8db6db32fd1a411833c244aec0607246401141.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;基於以上兩個策略進行精簡後生成的變異數據量較精簡前降低了 40%，同時代碼覆蓋率沒有明顯變化，並且保持不變的健壯性問題發現能力。&lt;/p&gt; 
&lt;p&gt;美團 App 和優選 App 都接入了這個工具，在新需求階段可以人工觸發運行，還可以結合客户端組件集成事件和迴歸事件做自動觸發。至今應用一年時間內，發現了幾十個問題。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/43da284d99ef324da17b87f32a65bf4d80130.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/ef4524ffc0b1bb460dcf5a87d3521492352401.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;05 總結及展望&lt;/h2&gt; 
&lt;p&gt;在健壯性工具建設一期裏，我們實現了 App 頁面加載展示場景的健壯性問題檢測，支持崩潰、卡死和部分功能異常這三類異常檢測。另外，基於節點相似性優化變異數據生成策略能夠在保持效果不變的情況下有效控制測試時長，但是否有更優的合併算法和推薦算法，還需要更多的嘗試。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/f710dd7245adfa4b3eef7441c3821d4f205702.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在後續工具的迭代還會繼續圍繞異常構造和異常檢測這兩個方向，支持更豐富的構造能力和檢測能力，以及更高效的構造效率。短期建設上，我們將會從業務視角出發豐富自動化變異數據生成建模，完善客户端異常通用異常檢測能力，完成通用前後端交互的數據構造類型（比如：長連接消息）的覆蓋；長期建設上，需要支持更豐富的數據和環境構造能力，通過智能化用例生成，提升測試效率。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/b5e78a9597644c7ab82fe1ba7dade3a4328067.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p0.meituan.net/travelcube/8410e19b1eea87a06f566f582b89f1cb174515.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;06 Q&amp;amp;A&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Q1&lt;/strong&gt;：節點相似的判斷依據是什麼？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：從實際的 response 分析來説，兩個節點的路徑完全相似就是從根節點到最終的葉子節點上，它們的路徑命名完全相似，數組裏兩個對象的結構完全一樣。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q2&lt;/strong&gt;：用例的生成能舉個例子嗎？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：比如顏色色值的格式是#+6 位字符，通常運營配置會出現的情況是忘記添加#，或色值複製中少了一位。在這種情況下，我們會構造一個色值，比如沒有返回#、色值位數不對、色值添加透明度，把這種場景作為構造情況，在配置裏添加上，最後用代碼生成。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q3&lt;/strong&gt;：健壯性平時執行的頻率是什麼樣的？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：第一個基於需求維度，需求維度需要人工觸發；第二個基於變更維度，當組件發生變更時，可以關聯到這段代碼或者組件變更的頁面，然後觸發頁面對應的健壯性測試，執行頻率會受到組件變更頻率的影響；第三個在迴歸測試時，App 的迴歸測試兩週一次，我們會把所有頁面以及它關聯的所有的用例都執行一次。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q4&lt;/strong&gt;：對於暴露給前端開發的接口，大部分是人為調用參數的變化，隨機性相對比較高，對於必填和非必填參數如何確認用例的範圍？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：目前我們在實現的方案裏，沒有區分參數是必填參數還是非必填參數，所以對於整個數據接口返回裏的所有結果都會進行構造，產生的問題是對於非必返回的參數可能產生的問題，到底是否是需要解決的問題，這部分目前通過運營手段做確認。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q5&lt;/strong&gt;：首頁可能調用 10 個接口，然後針對每個字段都進行異常驗證嗎？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：對於首頁關聯的接口，我們在接口請求、錄製過程中和錄製完數據後，會對接口進行確認到底有哪些接口是我們需要驗證的，這是一次性的成本，錄製完成後，會對每個字段都進行異常驗證，當然會有一些黑白名單的設置。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q6&lt;/strong&gt;：對色號這種情況有一種生成規則嘛，這個規則是怎麼制定？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：剛剛我只是舉了一個色號的例子，其實對於圖片、請求的資源文件、配置文件、跳轉鏈接，每一個對應到的業務語義，我們都有對應的用例生成規則，我們會根據參考依據，比如第一個是本身我們在通用的基礎庫裏怎麼處理這些問題，這裏有一個基礎的規則；第二個是我們積累了線上問題情況實際可能會產生的錯誤或者變異情況，生成第一版基礎規則，在第一期工具裏找相關研發達成共識，這樣的話，數據變異是處於合理範圍。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q7&lt;/strong&gt;：執行的時候，如何知道頁面對應哪些規則提前配置？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：執行時，在測試接入過程中有一個配置過程，它不是配置這個頁面和接口的關聯關係，而是配置我們要測試哪些頁面，自動觸發自動化錄製過程，就是到這個頁面時，會觸發哪些接口請求，生成這個頁面和這個接口請求的對應關係，給到對應的配置人做確認，保證哪些接口是真正可能想要構造的，哪些接口不需要構造，最後以這個為基準測試，基於錄製過程，比如業務迭代裏面產生了新接口，我們在錄製中能夠感知到它關聯的接口發生了變化，在發生變化時發消息給對應的測試提交人/負責人，TA 確認這條規則放到黑名單裏還是更新到需要構造的接口裏。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Q8&lt;/strong&gt;：是否有做頁面顯示的一個校驗？怎麼做的？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;：目前我們在頁面裏的模塊做了「是否展示」校驗，基於當前集成到美團的可測性 SDK，這個 SDK 會獲取到當前頁面是否渲染裏是否展示了對應模塊的信息，通過請求把對應模塊描述傳給 SDK，通過返回來校驗是否展示。&lt;/p&gt; 
&lt;h2&gt;07 參考資料&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;[1] 健壯性：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRobustness" target="_blank"&gt;https://en.wikipedia.org/wiki/Robustness&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[2] IEEE 健壯性：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fieeexplore.ieee.org%2Fdocument%2F7438745" target="_blank"&gt;https://ieeexplore.ieee.org/document/7438745&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;[3] &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fusers.ece.cmu.edu%2F%7Ekoopman%2Fballista%2F" target="_blank"&gt;Ballista&lt;/a&gt;：Carnegie Mellon 大學的研究項目，通過黑盒自動化測試的方式，發現導致系統崩潰或異常終止的系統調用或接口調用。&lt;/li&gt; 
 &lt;li&gt;[4] 基於佈局視圖的解析 SDK：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.meituan.com%2F2021%2F07%2F28%2Fapp-xraysdk.html" target="_blank"&gt;美團 App 頁面視圖可測性改造實踐-XraySDK&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;|&lt;/strong&gt; 在美團公眾號菜單欄對話框回覆【2023 年貨】、【2022 年貨】、【2021 年貨】、【2020 年貨】、【2019 年貨】、【2018 年貨】、【2017 年貨】等關鍵詞，可查看美團技術團隊歷年技術文章合集。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://p1.meituan.net/travelcube/b0364d579285ab22aa6235bd100d7c22178175.png" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;| &lt;a href="https://www.oschina.net/action/GoToLink?url=mailto%3A%E6%9C%AC%E6%96%87%E7%B3%BB%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E5%87%BA%E5%93%81%EF%BC%8C%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E5%B1%9E%E7%BE%8E%E5%9B%A2%E3%80%82%E6%AC%A2%E8%BF%8E%E5%87%BA%E4%BA%8E%E5%88%86%E4%BA%AB%E5%92%8C%E4%BA%A4%E6%B5%81%E7%AD%89%E9%9D%9E%E5%95%86%E4%B8%9A%E7%9B%AE%E7%9A%84%E8%BD%AC%E8%BD%BD%E6%88%96%E4%BD%BF%E7%94%A8%E6%9C%AC%E6%96%87%E5%86%85%E5%AE%B9%EF%BC%8C%E6%95%AC%E8%AF%B7%E6%B3%A8%E6%98%8E%E2%80%9C%E5%86%85%E5%AE%B9%E8%BD%AC%E8%BD%BD%E8%87%AA%E7%BE%8E%E5%9B%A2%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F%E2%80%9D%E3%80%82%E6%9C%AC%E6%96%87%E6%9C%AA%E7%BB%8F%E8%AE%B8%E5%8F%AF%EF%BC%8C%E4%B8%8D%E5%BE%97%E8%BF%9B%E8%A1%8C%E5%95%86%E4%B8%9A%E6%80%A7%E8%BD%AC%E8%BD%BD%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E3%80%82%E4%BB%BB%E4%BD%95%E5%95%86%E7%94%A8%E8%A1%8C%E4%B8%BA%EF%BC%8C%E8%AF%B7%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E8%87%B3tech%40meituan.com%E7%94%B3%E8%AF%B7%E6%8E%88%E6%9D%83%E3%80%82" target="_blank"&gt;本文系美團技術團隊出品，著作權歸屬美團。歡迎出於分享和交流等非商業目的轉載或使用本文內容，敬請註明「內容轉載自美團技術團隊」。本文未經許可，不得進行商業性轉載或者使用。任何商用行為，請發送郵件至 tech@meituan.com 申請授權。&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/meituantech/blog/11045435</link>
      <guid isPermaLink="false">https://my.oschina.net/meituantech/blog/11045435</guid>
      <pubDate>Tue, 02 Sep 2025 02:59:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>分佈式文件系統 FastDFS V6.13 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;分佈式文件系統&lt;span&gt;FastDFS V6.13&lt;/span&gt;發佈，主要改進包括：支持讀寫分離和性能優化，具體的改進如下：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;1. storage server&lt;span&gt;支持讀寫分離，主要用於跨機房災備場景。&lt;/span&gt;storage &lt;span&gt;啓用&lt;/span&gt;server ID&lt;span&gt;的情況下才可以使用這一特性。配置文件&lt;/span&gt;storage_ids.conf&lt;span&gt;的最後一列支持選項：&lt;/span&gt;rw=&amp;lt;both | read | write | none&amp;gt;&lt;span&gt;，不設置&lt;/span&gt;rw&lt;span&gt;時採用默認值&lt;/span&gt; both&lt;span&gt;（可讀可寫）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;2. &lt;span&gt;性能優化：用拼接字符串的方式替換耗時的&lt;/span&gt;sprintf&lt;span&gt;、&lt;/span&gt;snprintf&lt;span&gt;和&lt;/span&gt;vsprintf&lt;span&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;3. &lt;span&gt;合併&lt;/span&gt; lystormenvoy&lt;span&gt;提交的&lt;/span&gt;patch #753&lt;span&gt;：&lt;/span&gt;add store_path#_readonly setting to limit write access per storage path&lt;span&gt;。在使用多塊硬盤的情況下，逐台服務器更換單塊大硬盤進行擴容時，禁止向該盤上傳文件。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;4. bug&lt;span&gt;修復：獲取連接池中的連接前，需要調用&lt;/span&gt;memset&lt;span&gt;初始化&lt;/span&gt;connection&lt;span&gt;結構體。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;5. &lt;/span&gt;移除無用的&lt;span&gt;HTTP&lt;/span&gt;相關字段和代碼。之前嘗試內置&lt;span&gt;HTTP&lt;/span&gt;服務，後來覺得沒必要，這部分代碼就廢棄了。&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;6. fdfs_monitor&lt;span&gt;的輸出更加直觀易讀，比如像&lt;/span&gt;df&lt;span&gt;那樣人性化顯示磁盤空間，在&lt;/span&gt;group&lt;span&gt;中顯示當前&lt;/span&gt;trunk server&lt;span&gt;等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;FastDFS&lt;/span&gt;項目託管在&lt;span&gt; github &lt;/span&gt;和&lt;span&gt; gitee&lt;/span&gt;，歡迎大家測試和使用&lt;span&gt;V6.13&lt;/span&gt;，建議老用户升級到最新版本。有任何問題和建議歡迎加羣交流。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;友情提示&lt;/strong&gt;：&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;1&lt;/span&gt;）&lt;span&gt;V6.11&lt;/span&gt;和&lt;span&gt;V6.12&lt;/span&gt;升級到&lt;span&gt;V6.13&lt;/span&gt;，客户端&lt;span&gt;SDK&lt;/span&gt;可以不升級；因通信協議略有調整，其他版本升級到&lt;span&gt;V6.13&lt;/span&gt;時，客户端&lt;span&gt;SDK&lt;/span&gt;需要同步升級；&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;&amp;nbsp; &amp;nbsp; &lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;fastdfs-nginx-module&lt;span&gt;需要升級到最新的&lt;/span&gt;V1.25&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369807/fastdfs-6-13-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369807/fastdfs-6-13-released</guid>
      <pubDate>Tue, 02 Sep 2025 02:49:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>開源圖像編輯器 GIMP 3.1.4 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源圖像處理軟件 GIMP 發佈了 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gimp.org%2Fnews%2F2025%2F09%2F01%2Fgimp-3-1-4-released%2F" target="_blank"&gt;3.1.4 開發版&lt;/a&gt;，這是面向未來 GIMP 3.2 的第二個測試版本，帶來了兩項重量級新功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Link Layers（鏈接圖層）：支持將外部文件（如 SVG）作為圖層引入，並能在原文件更新時實時同步到 GIMP，非破壞性支持縮放、旋轉等操作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Vector Layers（矢量圖層）：終於原生支持矢量形狀，用户可自由編輯路徑、填充和描邊，保證放大時圖像依舊清晰。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-b0b1b5f0c8b9d61609b1076d73b6db3ee7a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了核心功能外，本次更新還包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;GEGL Filter Browser&lt;/strong&gt;：新的 GEGL 濾鏡瀏覽器界面由 Google Summer of Code 項目貢獻。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;MyPaint Brushes 2&lt;/strong&gt;：新增對 MyPaint 支（Paint 2 畫筆）的支持。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Text Tool 更新&lt;/strong&gt;：文本工具做出改進。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;插件與格式支持&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;導入簽名的 JPEG 2000 文件；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;支持非 DXT PAA 紋理；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;TIFF 文件處理得到改進。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;界面與內部優化&lt;/strong&gt;：包括 UX/UI 改進、各類 bug 修復、內部架構調整、PDB（過程數據庫）更新、構建流程優化（如 Nightly Snap 與 aarch64 Flatpak 支持）等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;GIMP 官方提醒，3.1.4 屬於開發測試版本，功能強大但可能存在崩潰風險，適合嚐鮮用户體驗，不建議用於生產環境。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369805/gimp-3-1-4-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369805/gimp-3-1-4-released</guid>
      <pubDate>Tue, 02 Sep 2025 02:45:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>《上海合作組織成員國元首理事會關於進一步深化人工智能國際合作的聲明》發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;《上海合作組織成員國元首理事會關於進一步深化人工智能國際合作的聲明》&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.gov.cn%2Fyaowen%2Fliebiao%2F202509%2Fcontent_7038710.htm" target="_blank"&gt;發佈&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img height="298" src="https://oscimg.oschina.net/oscnet/up-c1e1998ec520ff1faa874f536b3ea15109a.png" width="600" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;其中提到，成員國將採取以下行動：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;在充分考慮成員國優先事項和各自國內法律法規的基礎上，支持聯合國在人工智能決策中的核心作用，歡迎聯合國大會通過的「加強人工智能能力建設國際合作」決議，以及「人工智能在為中亞可持續發展創造新機遇方面發揮的作用」的決議；&lt;/li&gt; 
 &lt;li&gt;歡迎提出《人工智能能力建設普惠計劃》，成立人工智能能力建設國際合作之友小組，舉辦「人工智能之旅」國際會議（「AI Journey」），以及其他上合組織成員國人工智能領域倡議；&lt;/li&gt; 
 &lt;li&gt;加強人工智能基礎設施合作，促進人工智能基礎設施聯通，在自願參加的基礎上推動人工智能應用國際合作；&lt;/li&gt; 
 &lt;li&gt;推動人工智能人才培養合作，擴大校際合作與學術交流，促進科研成果和教育資源交流；&lt;/li&gt; 
 &lt;li&gt;推動人工智能領域投資合作，發揮上合組織銀聯體的作用，充分挖掘上合組織成員國投資潛力，在自願參加的基礎上為成員國人工智能領域投資項目提供資源支持；&lt;/li&gt; 
 &lt;li&gt;在尊重國家主權的基礎上發展人工智能領域對話夥伴機制，加強發展戰略、治理規則、技術標準的對接協調，發展安全負責任的人工智能，開發可信賴的人工智能系統；&lt;/li&gt; 
 &lt;li&gt;在人工智能全球治理領域推動互惠理念，在人工智能國際監管方面始終堅持發展與安全並重。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;各成員國將努力推動人工智能向更加開放、包容、普惠、公平、向善的方向發展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369799</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369799</guid>
      <pubDate>Tue, 02 Sep 2025 02:40:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>R8 疑難雜症分析實戰：外聯優化設計缺陷引起的崩潰</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R8 作為谷歌官方的編譯優化工具，在編譯階段會對字節碼進行大規模修改，以追求包體優化和性能提升。但是 Android 應用開發者數量太過龐大，無論測試流程多麼完善，終究難以避免在一些特定場景下出現問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;近期我們在升級項目的 AGP，遇到了一個指向系統 SurfaceTexture 類的 native 崩潰問題。經反編譯分析發現問題最終指向了 smali 字節碼中多餘的一行 new-instance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c5f08cf575756e08466c223dc6283005.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1c03aaa90c06e347c22e752eeb0ccb1d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;該指令創建了一個 SurfaceTexture 對象，但是並未調用其&amp;lt;init&amp;gt;方法，這意味着構造方法沒有執行，但是這個類重寫了 finalize 方法，後續被 gc 回收時會調用其中的 nativeFinalize 這個 JNI 方法，最終在 native 層執行析構函數時觸發了 SIGNALL 11 的內存訪問錯誤.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d639c13a4be57106726e6ea52ee6c3f4.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//2210f4a541d54e36690a7e1fbfb16627.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、復現問題&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們注意到多出來的 new-instance 指令下面緊接着的是對 a0.e 類中的靜態方法 i() 的調用，其內部實現就是 SurfaceTexture 的構造方法。這是典型的代碼外聯操作，即一段相同的代碼在工程中多次出現，則會被抽出來單獨作為一個靜態函數，原先的調用點則替換成該函數的調用，這樣可以減小代碼體積，是常見的編碼思路。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;Activity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onReusme(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// ...
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Activity$Outline.log();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;//...
&amp;nbsp; &amp;nbsp; }
}
//外聯生成的類
class&amp;nbsp;Activity$Outline{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;log(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;a = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;String&amp;nbsp;b = xx.xxx();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;Log.e("log",a+b);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們根據這個生成類的類名可以知道是 R8 中 ApiModelOutline 功能生成了這個類。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//832dad3a1078a82298590ae249e4c937.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們進到 R8 工程中檢索下相關的關鍵字，再加上 demo 多次嘗試，可以確認滿足以下條件能夠必現該問題:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用了高於當前 minSdkVersion 的系統函數/變量（僅限系統類，自己寫的無效）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用 synchronized 或者 try 語句塊包裹了該調用，或者給該函數傳參時有任何計算行為（除了傳局部變量）。例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、問題分析&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在確認復現條件之後，我們帶着幾個問題來逐個分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 外聯是什麼？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;R8 中的優化大多數跟包體優化有關，代碼外聯也是其中一種，但是外聯的前提是代碼重複的次數滿足一定閾值，但是 ApiModel 會對所有調用了高版本系統 API 的代碼做外聯，包括只調用一次的場景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 並非為了包體優化，我們通過 R8 工程的 issueTracker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://issuetracker.google.com/issues/333477035）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;檢索到了相關的信息：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5020bee9863c252049d9f1d8f055c200.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;譯：AGP 新增的 ApiModel 功能是為了防止在低版本設備上不可能執行的代碼引起類驗證錯誤，從而降低 App 啓動耗時。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;從這篇介紹 ART 虛擬機類驗證的文檔&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;（https://chromium.googlesource.com/chromium/src/+/HEAD/build/android/docs/class_verification_failures.md#chromium_s-solution）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;就能夠理解上面這句話的含義：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ART 虛擬機會在 APK 安裝之後立刻執行 AOT class verification，即對 dex 文件中所有的類進行驗證，如果驗證成功則後續運行時將不需要再進行驗證，反之若失敗，則該 class 會被 ART 打上&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;RetryVerificationAtRuntime&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;的標記，後續運行時還得重新執行類驗證。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;同時這些失敗的類也將無法被 dex2oat 優化成 oat 格式的優化字節碼（oat 字節碼的加載和執行速度更快）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//5d3b99565c562dff751ba4ac636da574.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果是在 MainActivity，啓動任務中使用了這些高版本 API，那麼在低版本設備 App 啓動時就必須額外執行一次類驗證（比較耗時，有的類能到 8ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;nbsp;https://issues.chromium.org/issues/40574431&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;），而 ApiModel 外聯則是相當於將這些肯定驗證失敗的函數的調用單獨抽到一個生成類中，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這樣運行時就能將類驗證失敗問題徹底隔離在生成類中，從而規避運行時的類驗證耗時。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//安裝 apk 後驗證失敗，運行時驗證失敗，但是能正常執行
class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk&amp;nbsp;&amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 後&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;class&amp;nbsp;MainActivity{
&amp;nbsp; &amp;nbsp;&amp;nbsp;void&amp;nbsp;onCreate(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if(android.sdk &amp;gt;&amp;nbsp;26){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; a0.b();&amp;nbsp;//這樣類驗證就能成功
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
}
//生成的外聯類，類驗證會失敗，但是運行時不可能走到，不影響
class&amp;nbsp;a0{
&amp;nbsp; &amp;nbsp;&amp;nbsp;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;b(){
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;new&amp;nbsp;SurfaceTexture(false);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;更多關於 ApiModel 的詳細介紹，見這篇文章：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://medium.com/androiddevelopers/mitigating-soft-verification-issues-in-r8-and-d8-7e9e06827dfd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;為什麼會多生成一個&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;new-instance 指令?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;介紹完 ApiModel 之後，我們已經知道了為什麼&amp;lt;init&amp;gt;方法的調用被替換成了一個生成函數的調用，接下來我們再分析下導致崩潰的罪魁禍首 new-instance 指令是如何出現的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們先來瞭解下 java 文件在編譯過程中的格式轉換過程，因為 ApiModel 是基於 IRCode 格式（R8 自定義的格式）來做外聯。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;文件轉換&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;javac&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;javac 將 java 文件編譯成 class 文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是 sychronized 語句塊在 javac 編譯之後會為其內部代碼生成 try-catch，這是為了確保在語句塊拋異常時能夠正常釋放鎖，因此和問題有關的是 try-catch 語句塊，和 synchronized 無關。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//36889c510c4d4a88957306d93cdf7d59.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;D8&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#ffffff"&gt;目前 R8 已經整合 D8，因此輸入 class 文件之後就會先通過 D8 轉為 dex 格式，並持有在內存中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;轉換之後的指令基本和 class 字節碼基本類似。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//876e7cf561f3a8aa1ee57005986ae7f0.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;IRcode&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;為了做進一步的優化，會將 dex 格式的代碼轉化成 R8 自定義的 IRcode 格式，其特點是代碼分塊。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;案例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//b04a46ddb675fd3446029e19aa3fc632.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;問題根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 工程裏檢索 ApiModel 關鍵字，最終定位到針對構造函數生成外聯函數和指令替換的代碼：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;InstanceInitializerOutliner-&amp;gt;rewriteCode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;執行此方法之前的指令如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;java：
new&amp;nbsp;SurfaceTexture(false);&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;dex：
:&amp;nbsp;-1:&amp;nbsp;NewInstance &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1&amp;nbsp;&amp;lt;- &amp;nbsp;android.graphics.SurfaceTexture
: -1: ConstNumber &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v2(0) &amp;lt;- &amp;nbsp;0 (INT)
: -1: Invoke-Direct &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v1,&amp;nbsp;v2(0); method:&amp;nbsp;void&amp;nbsp;android.graphics.SurfaceTexture.&amp;lt;init&amp;gt;(boolean)&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;對整個方法中所有的指令從上往下進行遍歷，第一次遍歷主要是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;檢索 &amp;lt;init&amp;gt;方法調用的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;判斷該方法的 androidApiLevel 是否高於 minSDK&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;生成包含完整構造函數指令的外聯函數，並替換&amp;lt;init&amp;gt;函數調用為外聯函數調用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;執行完替換邏輯，就記錄信息到 map 中，key 是&amp;lt;init&amp;gt;對應的 new-instance 指令，value 是前一步中替換的新指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;經過這一步，字節碼會變成這樣：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//e6b105ab1ca583830e11bee8baafc4e5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具體替換邏輯如下（可以參考註釋理解）：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//c919c6ad05e651de339fb13da747bfaa.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;第二次遍歷則是對 new-instance 指令的處理：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;找到 new-instance 指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;查詢 map，確認&amp;lt;init&amp;gt;方法已完成替換&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根據&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;方法返回的結果分為兩種場景：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;無類初始化邏輯：直接移除 new-instance 指令，不影響原代碼的語義。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//f1f56bfb61c5396de49e85cc7eec3a7e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;ul&gt; 
   &lt;li&gt; 
    &lt;ul&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;有類初始化邏輯：生成外聯函數，只包含該 new-instance 指令，和前一次遍歷一樣進行指令替換。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//1959f35cfade28f57d11667c652bea3e.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;具體替換邏輯:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fac201236889edc5ad19870621442c23.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;問題重點就在於&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;canSkipClInit&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這個函數的實現。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;它會檢查 new-intance 指令和 invoke &amp;lt;init&amp;gt;指令之間是否存在任何局部變量聲明以外的指令，如果存在，他會認為這些指令是這個類初始化的邏輯，因此為了保留源代碼的執行順序，這種情況下就是需要額外執行一次 new-instance 指令來觸發類初始化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9fe3bbc584708c6a61e6b7a0d4e808bd.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;但是實際上，如果在調用這個構造函數傳參時執行了任何運算（和類加載無關），都會生成相關的指令插在中間，例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;java 寫法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new-intance 和 invoke &amp;lt;init&amp;gt;指令之間的指令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( getParmas() )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;invoke-virtual &amp;nbsp; v2 &amp;lt;-; method: void xx.xx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture( if(enable) 1 : 2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;StaticGet &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v3 &amp;lt;- ; field: boolean &amp;nbsp;xxx.xxx.xx&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;new SurfaceTexture ( (boolean) enable )&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: CheckCast &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;v5 &amp;lt;- v3; java.lang.Boolean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;: -1: Invoke-Virtual &amp;nbsp; &amp;nbsp; &amp;nbsp; v6 &amp;lt;- v5; method: boolean java.lang.Boolean.booleanValue()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;從作者留下的 todo 也能看出，後續準備擴展這個方法，實現對這些夾在中間的指令的判斷，如果是對類初始化無影響的入參計算邏輯，則也將正常移除 new-intance 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//fa19a3d661f5f19c0bf5fdb01d8c8aba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;值得一提的是，我們最終 APK 裏 new-intance 指令並沒有被外聯，這是因為 SurfaceTexture 這個類本身在安卓 21 之前的版本就已經存在，只是入參為 bool 類型的構造方法是在安卓 26 新增的，所以他其實是被外聯之後又被內聯回到了調用處，因此看起來像是沒有被外聯。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//48f375f6e8c147cd435c140b6c8864ba.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;小結&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;至此，我們就明白了多出來一個看似無用的 new-intance 指令，實際上是為了保全源代碼的語義，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;觸發類加載&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;用的，但是作者沒有考慮到這些被優化的類可能重寫了 finalize 方法來釋放一些本就不存在的資源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;而且不侷限於調用 native 函數，只要是重寫了 finalize，並在裏面訪問一些在構造函數中初始化的成員變量，一樣可能造成 NPE 等崩潰。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 是如何計算出 API 的版本？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//d58a071ec92ca506d6e4f3e1ab4c7122.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;R83.3 版本開始，它編譯時會下載一個.ser 格式的數據庫文件，裏面記錄了所有系統 API、變量與安卓版本號的映射信息，在運行時通過行號和偏移量來尋找各自的版本號。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//9842b0b5f78805c080d71cbda30f1c44.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;為什麼 try-catch&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;也會導致該問題？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前面解釋了在構造函數入參中添加函數調用等寫法導致的字節碼異常原因，但是實際上這次我們遇到的崩潰場景是在 sychronized 裏 new 了一個 SurfaceTexture。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//cec26da2ccbd01a385a47d0914cbd615.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;前文中已經解釋過，sychronized 在編譯成 class 後會生成 try-catch 語句塊，這段代碼改成用 try-catch 語句塊包裹，一樣會復現崩潰，因此我們跟蹤 try-catch 在文件轉換過程中對字節碼的影響即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;回到 class 文件轉 dex 文件的階段，我們發現 try 語句塊中的每一行指令，都會在其後生成一條 FALLTHROUGH 指令。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;dex 格式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//dc87199452140addbab0d7de45794ad8.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 是什麼指令，他是做什麼的？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;FALLTHROUGH 指令表示指令自然流轉，沒有實際含義，它主要是為了幫助優化器識別哪些指令是可達的。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;例如下面這種寫法，case1 沒有寫 break，這樣會接着執行 case2 的代碼：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;switch&amp;nbsp;(value) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;1:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("One");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 故意不寫 break
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;2:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Two");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;3:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; System.out.println("Three");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;其字節碼如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;正常有 break 的話，會對應一條 GOTO 指令跳轉到 switch 語句塊最後一行，但是沒寫 break 的話，就會出現：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 12 行執行 goto 13 跳轉到 13 行的指令，這種指令毫無意義，且運行時會消耗性能，因此可以替換成 FALLTHROUGH 指令，這樣最終在生成 dex 文件時會被移除掉，從而避免浪費性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public&amp;nbsp;static&amp;nbsp;void&amp;nbsp;switchWithFallthrough(int);
&amp;nbsp; Code:
&amp;nbsp; &amp;nbsp; stack=2, locals=1, args_size=1


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加載參數
&amp;nbsp; &amp;nbsp;&amp;nbsp;0: iload_0


&amp;nbsp; &amp;nbsp;&amp;nbsp;// 檢查 case 1
&amp;nbsp; &amp;nbsp;&amp;nbsp;1: iconst_1
&amp;nbsp; &amp;nbsp;&amp;nbsp;2: if_icmpne&amp;nbsp;13&amp;nbsp; &amp;nbsp;&amp;nbsp;// 如果不等於 1，跳轉到 case 2
&amp;nbsp; &amp;nbsp;&amp;nbsp;5: getstatic #2&amp;nbsp; &amp;nbsp;&amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;8: ldc #3&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// String One
&amp;nbsp; &amp;nbsp;&amp;nbsp;10: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;12:&amp;nbsp;goto&amp;nbsp;13


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 2 (fallthrough 目標)
&amp;nbsp; &amp;nbsp;&amp;nbsp;13: iconst_2
&amp;nbsp; &amp;nbsp;&amp;nbsp;14: if_icmpne&amp;nbsp;28&amp;nbsp; &amp;nbsp;// 如果不等於 2，跳轉到 case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;17: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;20: ldc #5&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Two
&amp;nbsp; &amp;nbsp;&amp;nbsp;22: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&amp;nbsp; &amp;nbsp;&amp;nbsp;25:&amp;nbsp;goto&amp;nbsp;40&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 跳轉到 switch 結束


&amp;nbsp; &amp;nbsp;&amp;nbsp;// case 3
&amp;nbsp; &amp;nbsp;&amp;nbsp;28: iconst_3
&amp;nbsp; &amp;nbsp;&amp;nbsp;29: if_icmpne&amp;nbsp;40&amp;nbsp; &amp;nbsp;// 如果不等於 3，跳轉到結束
&amp;nbsp; &amp;nbsp;&amp;nbsp;32: getstatic #2&amp;nbsp; &amp;nbsp;// Field java/lang/System.out:Ljava/io/PrintStream;
&amp;nbsp; &amp;nbsp;&amp;nbsp;35: ldc #6&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;// String Three
&amp;nbsp; &amp;nbsp;&amp;nbsp;37: invokevirtual #4&amp;nbsp;// Method java/io/PrintStream.println:(Ljava/lang/String;)V


&amp;nbsp; &amp;nbsp;&amp;nbsp;// switch 結束
&amp;nbsp; &amp;nbsp;&amp;nbsp;40:&amp;nbsp;return&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;既然沒用為什麼還要加這個指令？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;class 文件是通過 Exception table 來指定異常處理的指令範圍，而 dex 文件則是通過為每一行可能產生 throwable 的指令後面添加 FALLTHROUGH 指令來實現 try-catch。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這裏會把每一行可能崩潰的指令都鏈接到 catch 指令所在的 block 中，確保任意位置的崩潰都能正常走到 catch 中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//144f461c63929a79f8346da8a6731ecb.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;問題根因&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 R8 4.0.26 版本，IRCode 翻譯器新增了對 FALLTHROUGH 指令的處理，即新建一個 block 並&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;生成一條 GOTO 指令指向新的 block。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//941934987c5518db50e697aacc04d794.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;根據前文的結論，GOTO 指令一樣會被認為是類初始化相關的邏輯，因此 try-catch 語句塊一樣會導致最終多出來一個 new-instance 字節碼。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;為什麼只升級 AGP 會導致&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;R8 功能出問題？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;我們在數個版本之前就已經單獨升級了 R8，正好涵蓋了 ApiModel 這個變更，但是直到近期才升級了 AGP。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可以看到從 AGP7.3-beta 版本開始，才默認打開 ApiModel 功能，這就解釋了為什麼升級 AGP 之後才出現此崩潰。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//09bde1db3ff6dd55f96188f2c6337b24.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、解決方案&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;禁用 ApiModel&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;ApiModel 通過犧牲些微包體，換來啓動階段類驗證耗時，但是從他覆蓋的類範圍來看，對啓動速度的收益微乎其微，因此可以直接通過配置開關關閉整個功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;System.setProperty("com.android.tools.r8.disableApiModeling",&amp;nbsp;"1")&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;雖説這是個實驗中的功能，且邏輯相對獨立，但是考慮到後續還有內聯優化等操作，貿然關閉整個功能無法評估影響面，潛在的穩定性風險較高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;官方修復&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;該問題反饋給 R8 團隊後，官方提供了臨時規避的方案，即確保高版本 API 在單獨的函數中調用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://issuetracker.google.com/issues/441137561&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//358c6b1b9714ab22bdff45c27378289c.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;隨後不久就提了 MR 針對 SurfaceTexture 這個類禁用了 ApiModel，並未徹底解決此問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://r8-review.googlesource.com/c/r8/+/109044&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//403f68ae953ddd19b67dc90602d69475.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;官方的修復方案比較權威，且影響面較小，但是並未徹底解決問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;自行修復&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;如果要修復此問題，關鍵是要將多餘的 new-instance 指令替換成一個合適的觸發類加載的指令，根據 java 官方文檔裏的介紹，只有 new 對象，訪問靜態的成員變量或者函數的指令才能安全的觸發類加載，比較理想的方案是改成訪問靜態變量，但是很多類並沒有靜態變量，比如 SurfaceTexture 就沒有。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//168eeaad61d7b9e162730708773e256d.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;因此我們可以考慮結合 getStatic 指令和掃描 finalize 的方式來解決該問題：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//baa3977f849ce680a7684f38a4d68176.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;雖説可以通過打印日誌來約束此改動的影響面，但畢竟要自行修改並編譯 R8 的 jar 包，且需要自行長期維護，整體影響面還是偏大，對穩定性要求高的 App 不建議採用該方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;業務改造（推薦）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在前文中提到的外聯函數生成處打印日誌，即可感知到工程中有哪些類受 ApiModel 影響，如果數量不多，分別讓業務改造其相關的寫法，確保傳參時是局部變量且無 try-catch/synchronized 語句塊即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src="https://oscimg.oschina.net/oscnet//a7fd6ee2c6b96d340b89116b8a76d5d5.jpg" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;考慮到 App 整體的穩定性，最終我們採用了業務改造的方式繞過了此問題，並在 R8 異常代碼處添加了日誌告警來預防後續增量問題，並仿照官方 MR 中的寫法補充了類的黑名單，用於應對無法編輯的三方庫引入此問題的場景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、總結&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在 Android 開發中，即使是 AGP、R8 這樣的官方工具鏈升級，也要保持足夠的警惕。畢竟 Android 生態太過複雜，再加上開發者們千奇百怪的代碼寫法，不論多麼完善的測試流程都無法規避這類特定場景的 bug。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;這次的 ApiModel 外聯優化問題就是一個很好的例子——它只在特定條件下才會暴露，但一旦出現就是必現的 native 崩潰。所以對於這種影響面無法評估的重大升級，還是需要經過足夠長時間的獨立灰度驗證，才能合入主幹分支。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顧&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;可擴展系統設計的黃金法則與 Go 語言實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;得物新商品審核鏈路建設分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;營銷會場預覽直通車實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;基於 TinyMce 富文本編輯器的客服自研知識庫的技術探索和實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;AI 質量專項報告自動分析生成｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 永樂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18690286</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18690286</guid>
      <pubDate>Tue, 02 Sep 2025 02:30:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>跨平台遊戲引擎 Axmol-2.8.0 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;em&gt;Axmol 2.8.0 版本是一個以錯誤修復和功能改進為主的次要 &lt;code&gt;LTS&lt;/code&gt; 長期支持版本，發佈時間: 2025 年 9 月 1 日&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;🙏感謝所有對 axmol 項目的貢獻者，包括財務贊助者：@scorewarrior、@peterkharitonov、@duong、@thienphuoc、@bingsoo、@asnagni、 @paulocoutinhox 以及 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsponsors%2Faxmolengine" target="_blank"&gt;歷史贊助者&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;倉庫地址&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;GitHub (官方): &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol" target="_blank"&gt;https://github.com/axmolengine/axmol&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Gitee (鏡像): &lt;a href="https://gitee.com/simdsoft/axmol"&gt;https://gitee.com/simdsoft/axmol&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;錯誤修復&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;修復 #2669：由於 DriverGL 初始化失敗，Windows 11 上的 Windows UWP 無法運行，由 @halx99 修復。&lt;/li&gt; 
 &lt;li&gt;修復 #2655：在 Android 場景包含 ImGui 圖層時多點觸控不起作用，由 @halx99 修復。&lt;/li&gt; 
 &lt;li&gt;修復 #2674：Linux 上最終應用未鏈接 OpenSSL，由 @halx99 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2675%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2675）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復從普通模式切換到 SDF 時標籤渲染的 FontAtlas 錯誤，由 @halx99 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2629%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2629）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復 wasm 中 Device::getTextureDataForText 處理空白文本時拋出異常，由 @halx99 修復。&lt;/li&gt; 
 &lt;li&gt;修復 Linux 上當 LabelType 為 STRING_TEXTURE 時標籤顏色不正確的問題，由 @halx99 修復。&lt;/li&gt; 
 &lt;li&gt;修復錯誤的 fmt::format_to 用法，由 @halx99 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2612%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2612）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復 genbindings.ps1 中 LLVM 版本截取邏輯問題，由 @halx99 修復。&lt;/li&gt; 
 &lt;li&gt;修復 Label 的 SDF 在字體縮放時的渲染問題及其他相關錯誤，由 @halx99 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2625%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2625）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復項目包含 Swift 代碼時的編譯錯誤，由 @halx99 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2632%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2632）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復 wasm Downloader 以錯誤權限打開文件（#2666），由 @AlexandreK38 修復（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2666%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2666）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復在 CMake 4.1 以 Windows 為目標時「找不到彙編器」的構建失敗問題，由 @halx99 修復。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;功能改進&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;改進 Apple iOS 平台的渲染視圖創建，由 @halx99 提交（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2600%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2600）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;將 GLView 重命名為 RenderView，由 @halx99 提交（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2602%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2602）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;在 2.6.0 版本發佈説明中增加 emsdk 降級提示，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改進 wasm 開發環境配置説明，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;將 &lt;code&gt;GLContextAttrs&lt;/code&gt; 重命名為 &lt;code&gt;GfxContextAttrs&lt;/code&gt;，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;更新 pull_request_template.md，作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2609%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2609）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改進 UTF-8 字符計數，移除 strlen 調用，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2614%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2614）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改進 UTF-8 文本處理，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;移除 sprintf/snprintf 存根，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2615%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2615）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改進 Android SDK 設置，Axmol 指定的 Android SDK 目錄優先級：&lt;code&gt;android project local properties&lt;/code&gt; &amp;gt; &lt;code&gt;ANDROID_HOME&lt;/code&gt; &amp;gt; &lt;code&gt;ANDROID_SDK_ROOT&lt;/code&gt; &amp;gt; &lt;code&gt;axmol/tools/external/adt/sdk&lt;/code&gt;，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;更多頭文件使用 pragma once，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2616%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2616）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;新增窗口尺寸限制設置支持，作者 @NgVThangBz（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2618%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2618）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;將 cpp-tests 中「Node: Label - New API」重命名為「Node: Label」，作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2627%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2627）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;更新 ImGui 多視口提示信息，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改進測試（統一 cpp-/lua- 測試中的菜單項命名），作者 @aismann（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2640%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2640）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;將 SIMD 可用性檢測移入獨立的 CMake 文件，作者 @j-jorge（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2642%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2642）。&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;將 CMAKE_MSVC_DEBUG_INFORMATION_FORMAT 設為 Embedded，以解決 PDB 體積過大問題，作者 @halx99。&lt;/li&gt; 
 &lt;li&gt;改進 NuGet 包管理，作者 @halx99（PR：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fpull%2F2671%25EF%25BC%2589%25E3%2580%2582" target="_blank"&gt;https://github.com/axmolengine/axmol/pull/2671）。&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;SDK 和工具更新&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;AGP: 8.11.0 =&amp;gt; 8.11.1&lt;/li&gt; 
 &lt;li&gt;gradle: 8.14.3 =&amp;gt; 9.0.0&lt;/li&gt; 
 &lt;li&gt;cmake: 4.0.3 =&amp;gt; 4.1.1&lt;/li&gt; 
 &lt;li&gt;webview2 (msedge): 1.0.992.28 =&amp;gt; 1.0.3045.78&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;三方庫更新&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;curl: 8.13.0 =&amp;gt; 8.15.0&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;發佈文件 MD5 校驗值&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;code&gt;axmol-2.8.0.zip&lt;/code&gt;: 0100b8b0a73d25b0fb020590fc2e8a54&lt;/li&gt; 
 &lt;li&gt;&lt;code&gt;axmol-bs-2.8.0.zip&lt;/code&gt;: 114afdb56e2f507c831163e6cd6385e8&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;下載&lt;/h2&gt; 
&lt;h3&gt;GitHub&lt;/h3&gt; 
&lt;p&gt;&lt;em&gt;國內用户可嘗試複製鏈接使用迅雷下載&lt;/em&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Freleases%2Fdownload%2Fv2.8.0%2Faxmol-2.8.0.zip" target="_blank"&gt;axmol-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Freleases%2Fdownload%2Fv2.8.0%2Faxmol-bs-2.8.0.zip" target="_blank"&gt;axmol-bs-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;百度網盤&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpan.baidu.com%2Fs%2F1-gWTCIqU8psNrgaLWNFqeg%3Fpwd%3Dj7p7" target="_blank"&gt;axmol-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpan.baidu.com%2Fs%2F1fBdSZZuctwLsEmJH4QgLMg%3Fpwd%3D3bbk" target="_blank"&gt;axmol-bs-2.8.0.zip&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;SourceForge&lt;/h3&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsourceforge.net%2Fprojects%2Faxmol-engine.mirror%2Ffiles%2Fv2.8.0%2F" target="_blank"&gt;Axmol-2.8.0&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;本版亮點詳解&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;NuGet 包管理優化&lt;/strong&gt;&lt;br&gt; 本版本對 NuGet 包管理進行了改進：Axmol 依賴的 Microsoft Edge WebView2 和 CppWinRT 包將在 CMake 配置階段統一下載至 &lt;code&gt;&amp;lt;AX_ROOT&amp;gt;/cache/packages&lt;/code&gt; 目錄。&lt;br&gt; 這樣，即使刪除 &lt;code&gt;build&lt;/code&gt; 目錄，這些依賴包也無需重新下載。此前版本會將依賴下載到 &lt;code&gt;CMAKE_BINARY_DIR&lt;/code&gt;，導致清理構建目錄後需重複下載。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;Axmol 項目最新動態&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;分支管理優化&lt;/strong&gt;&lt;br&gt; 為了讓開發者更直觀地選擇適合生產環境的分支，倉庫分支結構進行了調整：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;原 &lt;code&gt;dev&lt;/code&gt; 分支更名為 &lt;code&gt;release/2.x&lt;/code&gt;，作為 &lt;strong&gt;2.x LTS&lt;/strong&gt; 穩定維護與發佈分支&lt;/li&gt; 
   &lt;li&gt;原 &lt;code&gt;wip-v3&lt;/code&gt; 分支更名為 &lt;code&gt;dev/v3&lt;/code&gt;，並設為默認開發分支（尚未正式發佈，雖處於開發階段，但依託 CI 持續集成，確保構建與運行始終可用）&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;目錄結構優化（dev/v3）&lt;/strong&gt;&lt;br&gt; 將引擎核心代碼目錄 &lt;code&gt;core&lt;/code&gt; 重命名為 &lt;code&gt;axmol&lt;/code&gt;，並統一替換引擎代碼中的 include 語句為 &lt;code&gt;#include "axmol/xxx/xxx.h"&lt;/code&gt;，以簡化頭文件引用路徑。&lt;br&gt; 此調整不僅使代碼結構更清晰，還能更方便地與其他代碼庫協同使用，減少頭文件命名衝突的風險。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;渲染後端重構（dev/v3）&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dev/v3&lt;/code&gt; 分支對渲染後端進行了重構，新增 &lt;strong&gt;D3D11 渲染支持&lt;/strong&gt;。在 Windows 平台上，相比原 GLES API，性能提升約 &lt;strong&gt;13.6%&lt;/strong&gt;。&lt;br&gt; 同時，&lt;code&gt;axmol/renderer/backend&lt;/code&gt; 目錄已重命名並遷移至 &lt;code&gt;axmol/rhi&lt;/code&gt;，詳細説明可參考 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Faxmolengine%2Faxmol%2Fwiki%2FAbout-RHI-in-axmol-v3" target="_blank"&gt;About-RHI-in-axmol-v3&lt;/a&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;clang-format 增強（dev/v3）&lt;/strong&gt;&lt;br&gt; 為保持引擎核心代碼格式統一與規範，增強並完善了 &lt;code&gt;clang-format&lt;/code&gt; Lint CI，對每個 PR 自動檢查代碼格式是否符合規範。&lt;br&gt; 同時新增 &lt;code&gt;/clang-format&lt;/code&gt; 機器人評論指令：在 PR 評論中發送該指令，機器人將自動修正代碼格式並推送至 PR 原分支（需確保提交 PR 時勾選「允許維護者編輯」選項）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369794</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369794</guid>
      <pubDate>Tue, 02 Sep 2025 02:24:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>我國智能算力規模達 788 百億億次/秒</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;人民日報北京 9 月 1 日電 &amp;nbsp;（記者劉温馨、鄭洋洋）截至今年 6 月底，我國在用算力中心機架總規模達 1085 萬標準機架，智能算力規模達 788 百億億次/秒 (EFLOPS)；存力規模超過 1680 艾字節 (EB)，相比 2023 年增長約 40%；已發佈 1509 個大模型，在全球位居前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="334" src="https://oscimg.oschina.net/oscnet/up-f7c4902ec7cb7f48c81c629fb38170914e5.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;近日，中國算力平台完成山西、遼寧、上海、江蘇、浙江、山東、河南、青海、寧夏、新疆 10 個省份分平台接入工作，實現「平台、主體、資源、生態、場景」全面貫通。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;作為國家級綜合性算力服務平台，中國算力平台集「供、需、服」於一體，可實現不同系統、平台和工具之間的兼容性和互操作性。截至 7 月底，平台運營層註冊企業用户超 1000 家，入駐算力服務商逾 100 家，上架優質算力產品 110 餘項，接入主流基礎大模型和垂類模型 90 餘個，累計沉澱數十億條算力監測大數據。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369793</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369793</guid>
      <pubDate>Tue, 02 Sep 2025 02:23:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>智譜上線 Claude Code 專屬包月套餐，月費低至 20 元</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;智譜&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FJKSKSrjw3aqUODEN_LzRMg" target="_blank"&gt;宣佈&lt;/a&gt;，自 9 月 1 日起推出 Claude Code 專屬「GLM Coding Plan」限時套餐，月費低至 20 元。&lt;/p&gt; 
&lt;p&gt;該套餐適用於智譜最新旗艦模型 GLM-4.5 及 GLM-4.5-Air。用户可通過掃描活動海報二維碼，或者登錄智譜開放平台&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbigmodel.cn%2Fclaude-code" target="_blank"&gt;bigmodel.cn&lt;/a&gt;，直接購買並獲取詳細使用攻略。&lt;/p&gt; 
&lt;p&gt;首期主推 Claude Code，未來將拓展到更多 Coding 工具。目前，GLM-4.5 已接入包括 Claude Code、Cline、Gemini CLI、Grok CLI、CodeGeeX、Kilo Code、Roo Code、Trae 在內的多款主流編程工具，全面支持日常開發流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0902/101910_Nw8D_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/369792</link>
      <guid isPermaLink="false">https://www.oschina.net/news/369792</guid>
      <pubDate>Tue, 02 Sep 2025 02:20:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
