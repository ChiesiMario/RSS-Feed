<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Sun, 23 Mar 2025 16:37:01 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>《AppGallery 版本升級，好用小妙招請查收》</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;近期,鴻蒙應用市場（AppGallery）已升級到 6.0.2 版本。新版本帶來了哪些全新變化和實用小技巧？想要一鍵找到同類型更多應用，並同時高速下載，有什麼好方法呢？本期的跟手教程別錯過！&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;一、「應用更新」優化，長長的更新列表「不見了」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;針對有用户提到在「我的」頁面中看到「應用更新」展示的列表太長、佔版面等問題，新版本的 AppGallery 進行了優化。目前進入進入「應用市場&amp;gt;我的」你會發現頁面更清爽、長串的待更新應用列表不見了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;那更新列表去哪裏了呢？點擊進入「應用更新」，你可看到：應用更新列表在這裏，且已分成了「待更新」和「最近已更新」兩部分展示。「待更新」可提醒大家進行應用升級，「最近已更新」列表能幫助大家隨時查看更新記錄，瞭解應用更新後的新特性。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;此外，當所有應用均為最新版本時，在「我的」頁面就可以直接看到相應的提示，這對於有 「應用更新強迫症」的朋友來説無疑是一個福音。&amp;nbsp;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;2.png&quot; height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet//9a443ec842a34c20c679ca60a3ce582a.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;二、一鍵可達同類應用列表&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;接下來的小技巧，必須要敲黑板了！首先新版本的 AppGallery 在應用頁增加了&lt;strong&gt;腰部分類膠囊&lt;/strong&gt;的模塊，提供了超過 20 個分類膠囊，大家可以通過滑動選擇感興趣的膠囊，找到同類型應用列表；比如點擊了「房產與裝修」膠囊，常用的找房和裝修類 App&amp;nbsp;就出現眼前了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;同類應用太多，該怎麼選？可以看看 AppGallery 給你哪些推薦和實用解題思路。回到「房產與裝修」列表中，隨機選擇《貝殼找房》進入詳情頁，詳情頁下方可找到「相關專題」欄目，打開專題內容瀏覽，獲取使用技巧，如利用《貝殼找房》搜索短租的資源等。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;讓探索更高效，為你的選擇提供更有價值的參考，這麼好用的技巧要是不知道可真太浪費了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;3.png&quot; height=&quot;610&quot; src=&quot;https://oscimg.oschina.net/oscnet//ec965fbc9f249d96b8a34c622b1d7a69.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;三、應用同時下載能力增強&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;本次更新後， AppGallery 最多可支持同時下載或更新 3 個應用，這一改進將極大地提升大家在使用新機或有批量下載需求時的效率。眾所周知，HarmonyOS 5 應用下載速度和使用流暢度都有了很大的提升，如今可支持同時下載多個應用，必然會給大家帶來加倍的便利和快樂。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;4.png&quot; height=&quot;735&quot; src=&quot;https://oscimg.oschina.net/oscnet//b3a69f29699edeac988ee2b7dc1dae46.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;四、橫滑一下，就可獲取更多應用信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;在 AppGallery 版本升級後，應用詳情頁悄悄發生了變化。在應用信息欄的位置，輕輕往左一滑，就能看到應用分類、開發者信息和應用包體大小，針對「一眼鎖定」應用的用户來説可幫了大忙，不用再滑到下面去檢索信息。這雖然是一個非常小的改變，但在為用户檢索應用時，提供了更多參考維度。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;還要告訴你一個小技巧，應用分類的圖標就是一個分類膠囊，點擊後即可輕鬆進入同類應用列表了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;5.png&quot; height=&quot;802&quot; src=&quot;https://oscimg.oschina.net/oscnet//2b4db5f745415945cac452a69f850590.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;五、「下載記錄」和「購買記錄」中的應用操作辦法&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;最後一點可能對應用發燒友來説更感興趣，新版本的 AppGallery 除了能夠常規的管理應用下載記錄（長按操作）和購買記錄（滑動操作）之外，大家還可以隨時取消之前添加的「心願單」應用，這一功能雖然不常用，但也可解用户所需。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;以上就是 AppGallery6.0.2 版本更新的實用小妙招。如果大家還在使用舊版本，不妨趕緊更新體驗一下。當然，AppGallery 的寶藏功能遠不止這些，更多驚喜等待你去探索發現！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340252</guid>
            <pubDate>Fri, 21 Mar 2025 10:14:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>OpenAI CEO 奧特曼 ：DeepSeek 教訓了我們，GPT-5 將免費開放</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;日前，&amp;nbsp;OpenAI CEO 奧特曼在與硅谷知名分析師 Ben Thompson&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstratechery.com%2F2025%2Fan-interview-with-openai-ceo-sam-altman-about-building-a-consumer-tech-company%2F&quot; target=&quot;_blank&quot;&gt;對談&lt;/a&gt;&lt;/u&gt;中提到 DeepSeek。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/164748_HXaN_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;奧特曼認為 DeepSeek 確實是個很棒的團隊，也做出了很優秀的模型，&lt;strong&gt;但他們真正走紅的原因，並不完全是模型本身的能力&lt;/strong&gt;。&lt;br&gt; &amp;nbsp;&lt;br&gt; 「這對我們來説是一個教訓，那就是當我們隱藏一個功能時（思維鏈），我們給其他人留下了獲得病毒式傳播的機會。這是一個很好的警醒。它也讓我重新思考我們在免費層中提供的內容， GPT-5 將可以免費使用」，奧特曼這樣看 DeepSeek 的走紅。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;奧特曼表示，OpenAI 其實早就有類似能力，只是過去出於謹慎考慮沒有對外開放，怕太智能會變得不可控。但現在回頭看，這種「保守」反而錯失了機會，「我們做的模型更好，但大家沒注意到，反而被別人搶走了注意力」，他還透露，GPT-5 會加入更多功能，思維鏈、聯網搜索、甚至更長記憶都有可能下放，算是一個明顯的轉向。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338735/openai-calls-deepseek-state-controlled&quot; target=&quot;news&quot;&gt;OpenAI 呼籲美國政府禁止 DeepSeek&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338329/openai-chain-of-thought-monitoring&quot; target=&quot;news&quot;&gt;OpenAI 透露 CoT 思維鏈研究成果：CoT 監控可阻止大模型惡意行為&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/336125/openai-gpt-4-5&quot; target=&quot;news&quot;&gt;OpenAI 正式發佈 GPT-4.5 模型&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340236</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340236</guid>
            <pubDate>Fri, 21 Mar 2025 08:48:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>馬斯克：2024 年特斯拉 AI 投資約 100 億美元、FSD 安全水平將超過人類</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;特斯拉公司 CEO 埃隆・馬斯克今天在員工大會上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCernBasher%2Fstatus%2F1902918128876544315&quot; target=&quot;_blank&quot;&gt;分享&lt;/a&gt;&lt;/u&gt;了公司在電動汽車、儲能、智能輔助駕駛、人工智能計算及人形機器人等業務板塊的最新動態。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-39bef0ad1f0e3c05326afa6e48d068ce7c8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;馬斯克稱，特斯拉用於智能輔助駕駛訓練的 Cortex 算力中心目前已有超過 5 萬塊 GPU，且即將突破 10 萬塊大關，躋身全球前五大超級計算中心。&lt;/p&gt; 
&lt;p&gt;此外，Dojo 2 超級計算機即將問世，其將比第一代 Dojo 超級計算機強大 10 倍。目前，Dojo 超級計算機已在紐約超級工廠投入運行，承擔了特斯拉 5% 至 10% 的智能輔助駕駛訓練數據量。&lt;/p&gt; 
&lt;p&gt;馬斯克透露，2024 年特斯拉在人工智能方面的投資約達 100 億美元（現匯率約合 724.51 億元人民幣），其中約一半為內部投入，主要用於特斯拉自研的 AI 推理計算機、所有車輛傳感器以及 Dojo 超級計算機。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-caf53effe89e63245f2c7f3bdf2d0223c1b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;特斯拉全系現款在售車型均已搭載 AI 4 智能輔助駕駛硬件。儘管 AI 4 硬件設計於數年前，但至今仍無同類產品超越其性能。AI 4 不僅性能強大，且能耗極低。&lt;strong&gt;未來幾年，特斯拉將推出 AI 5、AI 6、AI 7 硬件&lt;/strong&gt;，但馬斯克強調，消費者不應因此延遲購買，因為特斯拉的技術進化永無止境，早入手即可早享受，現階段的 AI 4 對於特斯拉智能輔助駕駛硬件來説已經足夠。&lt;/p&gt; 
&lt;p&gt;馬斯克還表示，特斯拉的智能輔助駕駛系統在行駛過程中所需的幹預越來越少，&lt;strong&gt;最終將完全無需人工幹預，且行駛安全水平將超過人類駕駛，達到比人類安全 10 倍的水平&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;目前，在北美地區，特斯拉的智能輔助駕駛系統（北美稱 FSD）已經能夠實現從弗裏蒙特工廠下線的車輛在無人駕駛情況下自行開往目的地停車場，等待裝車長途運輸。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/339990/blackrock-ai-infrastructure-partnership&quot; target=&quot;news&quot;&gt;馬斯克 xAI 和微軟、貝萊德等組成新聯盟，共建 300 億美元 AI 基礎設施項目&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334522/xai-grok3&quot; target=&quot;news&quot;&gt;馬斯克旗下 xAI 發佈 Grok 3 推理模型，聲稱超越 o1、R1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340233</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340233</guid>
            <pubDate>Fri, 21 Mar 2025 08:38:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Minesweeper MCP Server —— 掃雷 MCP 服務器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Minesweeper MCP Server 是一個掃雷 MCP 服務器，讓 Claude 可以玩掃雷遊戲。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0d7a16d356b0beb3c58ab8498176657e2fd.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/minesweeper-mcp-server</link>
            <guid isPermaLink="false">https://www.oschina.net/p/minesweeper-mcp-server</guid>
            <pubDate>Fri, 21 Mar 2025 08:32:00 GMT</pubDate>
        </item>
        <item>
            <title>劉強東：技術算法不應壓榨最底層兄弟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 21 日，據網傳截圖顯示，近日劉強東在朋友圈發文評價京東為快遞員繳納五險一金一事，對此，界面新聞向京東求證，對方回應，截圖內容屬實。劉強東稱，去年是創業 20 年以來最有成就感的時候，因為僅僅快遞小哥就有 1200 多個兄弟退休了。每人可領取數十萬公積金、每月 5350 元退休金，並享受醫保全覆蓋。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;劉強東稱，我們所學的知識、商業模式、技術算法都不應該是用來壓榨社會最底層的兄弟們的，我們的利潤、市值和財富更不應該建立在底層百姓無保障的生活之上的。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;劉強東呼籲所有快遞員和騎手都可以獲得五險一金待遇，因為今天中國幾大平台的利潤和市值完全可以支撐，期待各階層一起幸福生活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;512&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/163026_g23O_4252687.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340231</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340231</guid>
            <pubDate>Fri, 21 Mar 2025 08:30:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>瀏覽器崩潰的第一性原理：內存管理的藝術</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;79&quot; data-source-title=&quot;&quot;&gt; 
  &lt;section class=&quot;js_blockquote_digest&quot;&gt; 
   &lt;section&gt;
     你是否曾經遇到過瀏覽器突然卡頓，甚至崩潰的情況？尤其是在打開多個標籤頁或運行復雜的網頁應用時，瀏覽器似乎變得異常脆弱。這種崩潰的背後，往往與內存管理息息相關。 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/blockquote&gt; 
 &lt;section style=&quot;text-indent: 0em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;瀏覽器的內存管理機制決定了它能否高效地分配和釋放資源，而 JavaScript 引擎 V8 正是這一機制的核心。&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;本文將探討 V8 的內存管理機制，幫助你理解瀏覽器崩潰的根源，並學會如何優化內存使用，避免類似問題的發生。&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;3&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;一、內存管理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;底層語言（如 C 語言）擁有手動的內存管理原語，例如：&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;ree()&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;。相反，JavaScript 是在創建對象時自動分配內存，並在不再使用時自動釋放內存（垃圾回收）。這種自動化機制雖然方便，但也容易讓我們產生誤解，認為不需要關心內存管理，從而忽略潛在的內存問題。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;5&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;二、內存生命週期&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;無論使用何種編程語言，內存的生命週期通常都遵循以下步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ul data-nodeid=&quot;7&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;182&quot;&gt;分配內存&lt;/strong&gt;：根據需求分配所需的內存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;187&quot;&gt;使用內存&lt;/strong&gt;：對分配的內存進行讀寫操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;192&quot;&gt;釋放內存&lt;/strong&gt;：在內存不再需要時將其釋放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;在底層語言中，內存的分配和釋放是顯式的，開發者需要手動管理。而在高級語言如 JavaScript 中，內存的分配和釋放大多是隱式的，由垃圾回收機制自動處理。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;15&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1 內存分配&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_4&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;16&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1.1 值的初始化&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;為了不讓我們費心內存分配，JavaScript 在值初次聲明時自動分配內存。&lt;/span&gt;&lt;/p&gt; 
 &lt;pre data-nodeid=&quot;18&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;28&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為數值分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為字符串分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; o = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為對象及其包含的值分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 為數組及其包含的值分配內存（就像對象一樣）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為函數（可調用的對象）分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 函數表達式也會分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;someElement.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;click&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    someElement.style.backgroundColor = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;19&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2.1 通過函數調用分配內存&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些函數調用的結果是為對象分配內存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;21&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為 Date 對象分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; e = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;div&quot;&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為 DOM 元素分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些方法為新值或新對象分配內存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;23&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;azerty&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s2 = s.substr(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// s2 是一個新的字符串&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 因為字符串是不可變的值，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// JavaScript 可能決定不分配內存，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 只是存儲了 [0-3] 的範圍。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yeah yeah&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a2 = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;generation&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a3 = a.concat(a2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 有四個元素的新數組，由 a 和 a2 其中的元素連接而成。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;24&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2 變量讀取&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用值通常涉及對分配的內存進行讀寫操作。無論是讀取變量值、訪問對象屬性，還是傳遞函數參數，都會使用到內存中的值。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;26&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.3 內存回收（垃圾回收）&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;當內存不再需要時，系統會將其釋放。大多數內存管理問題都出現在這一階段，尤其是如何確定已分配的內存何時不再需要。在底層語言中，開發者需要手動判斷並釋放內存，而 JavaScript 則通過垃圾回收機制自動完成這一任務。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;28&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;三、V8 的垃圾回收&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;垃圾回收的核心任務是識別內存中的「死區」，即不再使用的內存。一旦識別出這些區域，它們可以被重新用於新的內存分配或釋放回操作系統。一個對象如果不再被根對象或活躍對象引用，則被視為「死的」。根對象通常是活躍的，例如局部變量、全局對象或瀏覽器對象（如 DOM 元素）。&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;例如：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;31&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; obj = { &lt;span class=&quot;code-snippet__attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  g(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// might contain an infinite loop.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj.x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於無法精確判斷對象是否會被再次引用（這相當於停機問題），垃圾回收器採用了一種寬鬆的定義：如果對象可以通過某個指針鏈從根對象到達，則該對象是活躍的，否則就是垃圾。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;33&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.1 V8 內存結構&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;V8 的內存分為以下幾個主要部分：&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028741&quot; data-ratio=&quot;0.7166882276843467&quot; src=&quot;https://oscimg.oschina.net/oscnet/ca11da54-bc8b-4a09-9c14-3c4399c0411a.png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;35&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;219&quot;&gt;堆內存（Heap）&lt;/strong&gt;：&lt;br&gt;堆內存是 V8 中用於動態分配內存的區域，存儲 JavaScript 對象、閉包、函數等數據。堆內存進一步分為以下幾個區域：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;38&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;226&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;新生代&lt;/span&gt;&lt;/strong&gt;：用於存儲生命週期較短的對象（如臨時變量、局部變量等）。分為兩個半空間（From Space 和 To Space），採用 Scavenge 算法進行垃圾回收。新生代空間較小，垃圾回收頻率較高。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;233&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;老生代&lt;/span&gt;&lt;/strong&gt;：：用於存儲生命週期較長的對象（如全局變量、閉包等）。採用標記-清除（Mark-Sweep）和標記-整理（Mark-Compact）算法進行垃圾回收。老生代空間較大，垃圾回收頻率較低。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;240&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;代碼空間&lt;/span&gt;&lt;/strong&gt;：專門用於存儲 JIT（Just-In-Time）編譯生成的機器代碼。代碼空間與其他空間分離，因為代碼的生命週期通常較長，且需要高效訪問。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;247&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;大對象空間&lt;/span&gt;&lt;/strong&gt;：用於存儲較大的對象（如大數組、大字符串），避免頻繁複制。採用標記-清除和標記-整理算法進行垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;254&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;單元空間、屬性單元空間和映射空間&lt;/span&gt;&lt;/strong&gt;：些空間分別包含 Cells、PropertyCells 和 Maps。每個空間都包含大小相同的對象，並且對它們指向的對象類型有一定的限制，從而簡化了垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;260&quot;&gt;棧內存（Stack）&lt;/strong&gt;&lt;br&gt;棧內存用於存儲函數調用時的局部變量、參數和返回地址。棧內存的特點是分配和釋放速度快，但空間有限。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;51&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2 V8 垃圾回收機制&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;52&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.1 棧數據的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028742&quot; data-ratio=&quot;0.4969097651421508&quot; src=&quot;https://oscimg.oschina.net/oscnet/dd9587a0-84da-4c35-ab5e-3b2f0a559e6e.png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;棧數據的「垃圾回收」是通過函數調用和返回機制自動完成的。棧幀的內存釋放是隱式的，棧是連續的內存區域，內存分配和釋放通過指針移動實現。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;55&quot; style=&quot;text-align: left;&quot;&gt;&lt;code&gt;
   
   
   &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;38&quot; data-source-title=&quot;&quot;&gt;
 
    
    
    &lt;section class=&quot;js_blockquote_digest&quot;&gt;
  
     
     
     &lt;section&gt;
      
      
      
   為什麼需要區分「堆」和「棧」兩個存儲空間？為什麼不將所有數據直接存放在棧中？
  
     
     
     &lt;/section&gt;
 
    
    
    &lt;/section&gt;

   
   
   &lt;/blockquote&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;JavaScript 引擎需要用棧來維護程序執行期間的上下文狀態。如果棧空間過大，所有數據都存放在棧中，會影響上下文切換的效率，進而影響整個程序的執行效率。例如，當函數執行結束時，JavaScript 引擎只需將指針下移到上一個執行上下文的地址即可，棧幀的內存會自動回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_12&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;57&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.2 堆數據的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;代際假説是垃圾回收領域的一個重要理論，V8 的垃圾回收策略正是基於這一假説。代際假説包含兩個核心觀點：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;59&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;大多數對象的生命週期很短，分配後很快變得不可訪問。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;少數對象會存活較長時間。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;基於此，V8 將堆內存分為新生代和老生代兩個區域。新生代存放生命週期短的對象，老生代存放生命週期長的對象。V8 的垃圾回收器分為主垃圾回收器和副垃圾回收器。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h5_13&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;65&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器主要負責新生代的垃圾回收。由於大多數小對象都分配在新生代，因此該區域的垃圾回收頻率較高。&lt;br&gt;新生代採用 Scavenge 算法，進行垃圾回收。該算法將新生代空間對半劃分為對象區域和空閒區域。&lt;br&gt;&lt;/span&gt;&lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028740&quot; data-ratio=&quot;0.5777063236870311&quot; src=&quot;https://oscimg.oschina.net/oscnet/20a6d122-d24b-4ae0-90ec-ec263472ba5c.png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;新加入的對象存放在對象區域。當對象區域快滿時，副垃圾回收器會執行以下步驟：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;67&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;標記對象區域中的存活對象。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;將存活對象複製到空閒區域，並有序排列，消除內存碎片。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;角色翻轉：對象區域變為空閒區域，空閒區域變為對象區域。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於 &lt;strong data-nodeid=&quot;298&quot;&gt;Scavenge 算法&lt;/strong&gt;需要複製存活對象，如果新生代空間過大，複製操作會耗費較多時間。因此，新生代空間通常較小。為了應對新生代空間不足的問題，V8 採用了對象晉升策略：經過兩次垃圾回收後仍然存活的對象會被移動到老生代。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_14&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;75&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;主垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;老生代的對象通常較大，使用 &lt;strong data-nodeid=&quot;313&quot;&gt;Scavenge 算法&lt;/strong&gt;進行垃圾回收效率較低。因此，主垃圾回收器採用&lt;strong data-nodeid=&quot;314&quot;&gt;標記-清除&lt;/strong&gt;和&lt;strong data-nodeid=&quot;315&quot;&gt;標記-整理&lt;/strong&gt;算法。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;標記-清除：首先是標記過程階段。標記階段就是從一組根元素開始，遞歸遍歷調用棧，在這個遍歷過程中，能到達的元素稱為活動對象，沒有到達的元素就可以判斷為垃圾數據。標記過程和清除過程就是標記 - 清除算法 Mark-Sweep ，不過對一塊內存多次執行標記 - 清除算法後，會產生大量不連續的內存碎片。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028743&quot; data-ratio=&quot;0.4945770065075922&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed116503-4d1e-493b-8d7f-3457262b4501.png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;碎片過多會導致大對象無法分配到足夠的連續內存，於是又產生了另外一種算法—標記-整理（Mark-Compact）&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;這個標記過程仍然與標記 - 清除算法裏的是一樣的，但後續步驟不是直接對可回收對象進行清理，而是讓所有存活的對象都向一端移動，然後直接清理掉端邊界以外的內存。V8 研究團隊 2016 年的一篇博文：在一次完整的垃圾回收之後，V8 的堆增長策略會根據活動對象的數量外加一些餘量來確定何時再進行垃圾回收。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028739&quot; data-ratio=&quot;0.4106029106029106&quot; src=&quot;https://oscimg.oschina.net/oscnet/7d262ac7-2d6e-4dff-9074-41b2a5be869f.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_15&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;80&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;全停頓和增量標記&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於 JavaScript 是運行在主線程之上的，一旦執行垃圾回收算法，都需要將正在執行的 JavaScript 腳本暫停下來，待垃圾回收完畢後再恢復腳本執行。我們把這種行為叫做全停頓（Stop-The-World）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有研究數據表明，如果堆中的數據有 1.5GB，V8 實現一次完整的垃圾回收需要 1 秒以上的時間，這也是由於垃圾回收而引起 JavaScript 線程暫停執行的時間，若是這樣的時間花銷，那麼應用的性能和響應能力都會直線下降。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028745&quot; data-ratio=&quot;0.2915506035283194&quot; src=&quot;https://oscimg.oschina.net/oscnet/e32c7d49-8a28-410a-a60f-f0f1f13ba6dc.png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;83&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section style=&quot;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;
   
   
   &lt;code&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果在執行垃圾回收的過程中，佔用主線程時間過久，就像上面圖片展示的那樣，花費了 200 毫秒，在這 200 毫秒內，主線程是不能做其他事情的。比如頁面正在執行一個 JavaScript 動畫，因為垃圾回收器在工作，就會導致這個動畫在這 200 毫秒內無法執行的，這將會造成頁面的卡頓現象。&lt;br&gt;&lt;/span&gt;&lt;/code&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;為了降低老生代的垃圾回收而造成的卡頓，V8 將標記過程分為一個個的子標記過程，同時讓垃圾回收標記和 JavaScript 應用邏輯交替進行，直到標記階段完成，我們把這個算法稱為增量標記（Incremental Marking）算法，&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028744&quot; data-ratio=&quot;0.3201663201663202&quot; src=&quot;https://oscimg.oschina.net/oscnet/0d30149e-d536-4d77-ac3a-0c1865d98a4b.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用增量標記算法，可以把一個完整的垃圾回收任務拆分為很多小的任務，這些小的任務執行時間比較短，可以穿插在其他的 JavaScript 任務中間執行，這樣當執行上述動畫效果時，就不會讓用户因為垃圾回收任務而感受到頁面的卡頓了。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;86&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;四、內存泄漏與優化&lt;/span&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;內存泄漏（Memory Leak）是指程序中已動態分配的堆內存由於某種原因程序未釋放或無法釋放，造成系統內存的浪費，導致程序運行速度減慢甚至系統崩潰等嚴重後果。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_17&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;88&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1 常見的內存泄漏場景及優化方案&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_18&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;89&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.1 意外的全局變量&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未使用 var、let 或 const 聲明的變量會隱式變為全局變量，直到頁面關閉才會被釋放。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;92&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;leak&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  leakedVar = &lt;span class=&quot;code-snippet__string&quot;&gt;&#39;This is a global variable&#39;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 意外的全局變量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;351&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;始終使用 var、let 或 const 聲明變量。啓用嚴格模式（&quot;use strict&quot;），避免意外創建全局變量。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_19&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;94&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.2 未清理的定時器或回調函數&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未清除的 setInterval 或 setTimeout 會持續持有引用，導致相關對象無法被回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;97&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; data = getData();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;setInterval(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  process(data); &lt;span class=&quot;code-snippet__comment&quot;&gt;// data 一直被引用，無法釋放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;360&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 clearInterval 或 clearTimeout 清除定時器。在組件銷燬或頁面卸載時清理定時器。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;99&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.3 未解綁的事件監聽器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未移除的事件監聽器會持續持有對 DOM 元素或對象的引用，導致內存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;102&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; button = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myButton&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;button.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;Button clicked&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果 button 被移除，但未解綁事件監聽器，會導致內存泄漏&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;369&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 removeEventListener 解綁事件監聽器。在組件銷燬或頁面卸載時解綁事件。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_21&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;104&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.4 閉包中的引用&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;閉包會捕獲外部函數的變量，如果閉包未被釋放，這些變量也會一直存在。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;107&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;createClosure&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; largeData = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1000000&lt;/span&gt;).fill(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(largeData[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;code-snippet__comment&quot;&gt;// largeData 一直被閉包引用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; closure = createClosure();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;378&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;免在閉包中捕獲不必要的變量。在不再需要閉包時，手動解除引用（例如將閉包設置為 null）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;109&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.5 DOM 引用未釋放&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果 JavaScript 中保留了 DOM 元素的引用，即使該元素從頁面中移除，也無法被垃圾回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;112&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; element = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.removeChild(element); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 從 DOM 中移除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// element 仍然被引用，無法釋放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;387&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;在移除 DOM 元素後，將其引用設置為 null：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;114&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;element&lt;/span&gt; = null;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_23&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;115&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.6 緩存未清理&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;緩存對象（如 Map 或 WeakMap）如果未正確清理，會導致內存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;118&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; cache = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCache&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;key, value&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache.set(key, value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果緩存未清理，會持續增長&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;396&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 WeakMap 或 WeakSet，它們不會阻止鍵對象的垃圾回收。定期清理緩存。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_24&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;120&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2 內存泄漏檢查&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_25&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;121&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.1 使用 Chrome 任務管理器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 自帶的任務管理器可以幫助你快速發現內存佔用異常的任務。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;內存&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028747&quot; data-ratio=&quot;0.6096885813148789&quot; src=&quot;https://oscimg.oschina.net/oscnet/4a266a6f-5f33-4576-8745-89dbad18ebff.png&quot; data-type=&quot;png&quot; data-w=&quot;2890&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;124&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打開 Chrome 任務管理器：點擊 Chrome 右上角的三個點（菜單按鈕） &amp;gt; 更多工具 &amp;gt; 任務管理器。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查看內存佔用：關注內存佔用異常高的任務（如標籤頁、擴展程序、輔助框架等）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;檢查內存增長：觀察某個任務的內存佔用是否持續增長（即使頁面沒有操作）。如果某個任務的內存佔用不斷增加，可能是內存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_26&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;131&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.2 使用 Chrome 開發者工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 的開發者工具提供了強大的內存分析功能，可以幫助你定位內存泄漏。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028746&quot; data-ratio=&quot;0.6623970722781336&quot; src=&quot;https://oscimg.oschina.net/oscnet/243ee5e7-4a79-4326-8fd1-68e8488a7f46.png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;br&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;133&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打開開發者工具：右鍵點擊頁面，選擇，檢查，或者使用快捷鍵：Ctrl + Shift + I（Windows/Linux）或 Cmd + Option + I（Mac）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用 Memory 面板：切換到 Memory 標籤。選擇以下工具之一進行分析：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;138&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Heap Snapshot：拍攝堆內存快照，分析內存分配情況。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation instrumentation on timeline：記錄內存分配的時間線，查看內存增長情況。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation sampling：通過採樣分析內存分配。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;分析內存泄漏：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;147&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;拍攝多個堆內存快照，比較快照之間的內存變化。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查找未被釋放的對象（如 DOM 節點、事件監聽器等）。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;檢查 Retainers（持有者），找到導致內存泄漏的代碼。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_27&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;154&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.3 使用第三方工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;除了 Chrome 自帶的工具，還可以使用以下第三方工具進行內存分析：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;156&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Lighthouse：Chrome 的 Lighthouse 工具可以檢測頁面性能問題，包括內存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;MemLab：Facebook 開源的 JavaScript 內存分析工具，專門用於檢測內存泄漏。&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h2_28&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;161&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;五、從崩潰到優化：內存管理的終極目標&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;瀏覽器的崩潰往往源於內存管理的不足，而 V8 引擎的內存管理機制正是解決這一問題的關鍵。通過理解 V8 的內存分配、垃圾回收機制以及常見的內存泄漏場景，我們可以更好地優化代碼，避免內存浪費和性能瓶頸。無論是開發者還是普通用户，瞭解這些原理都能幫助我們更好地應對瀏覽器崩潰問題，提升應用的整體性能和用户體驗。&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_29&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;163&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;六、 總結&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;本文通過從常見的瀏覽器崩潰場景引出本篇文章的分享主題：V8 的內存管理， 文章主要介紹了 V8 垃圾回收的原理、常見的內存泄漏場景及其預防方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;最後，最重要的一點：歡迎評論區互動，一起交流學習，共同成長&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;img alt=&quot;圖片&quot; class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-imgfileid=&quot;100028749&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fc371ec9-2b7f-4b7f-b317-4e6e306662bf.png&quot; data-type=&quot;webp&quot; data-w=&quot;396&quot; style=&quot;pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;掃一掃，加入技術交流羣&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 16px;&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公眾號 - 京東雲開發者（JDT_Developers）。&lt;br&gt;如有侵權，請聯繫 support@oschina.cn 刪除。&lt;br&gt;本文參與「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源創計劃&lt;/a&gt;」，歡迎正在閲讀的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/17955030</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/17955030</guid>
            <pubDate>Fri, 21 Mar 2025 08:29:00 GMT</pubDate>
            <author>京東雲開發者</author>
        </item>
        <item>
            <title>Linux 內核越界寫入漏洞致權限提升</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcybersecuritynews.com%2Flinux-kernel-out-of-bounds-write-vulnerability%2F&quot; target=&quot;_blank&quot;&gt;Linux 內核存在近 20 年的嚴重漏洞&lt;/a&gt;&lt;/u&gt;，允許本地用户獲取 root 權限，影響多版本系統。&lt;/p&gt; 
&lt;p&gt;該漏洞被分配的編號為 CVE-2025-0927，在 Linux 內核 HFS+文件系統驅動程序中存在越界寫入漏洞，影響運行至 6.12.0 版本內核的系統，已確認 Ubuntu 22.04 帶有 Linux 內核 6.5.0-18-generic 版本的系統存在漏洞。&lt;/p&gt; 
&lt;p&gt;根據 SSD 的安全公告，該漏洞存在於 HFS+驅動程序中，該驅動程序支持 Apple 的過時文件系統格式，該格式在 2017 年被 APFS 取代之前一直是 MacOS X 的主要文件系統。&lt;/p&gt; 
&lt;p&gt;該漏洞自初始 git 倉庫構建 1da177 以來一直存在，並且自 Linux 內核 2.6.12-rc2 版本以來一直未被檢測到。&lt;/p&gt; 
&lt;p&gt;該漏洞的核心在於 B 樹節點處理中的緩衝區溢出。易受攻擊的函數 fs/hfsplus/bnode.c 中的 hfs_bnode_read_key 未能正確驗證鍵大小的邊界條件：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2f9a4d0f8d837764ff162322f00ccb86e82.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在該代碼中，函數未實現適當的邊界檢查，允許攻擊者觸發越界寫操作，從而破壞內核內存。&lt;/p&gt; 
&lt;p&gt;Ubuntu 已發佈修復程序，管理員需立即更新。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</guid>
            <pubDate>Fri, 21 Mar 2025 08:28:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>AI 組件 ComfyUI 易被黑產盯上</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;隨着近幾年大模型的迅猛發展，以及安全對抗技術的持續迭代升級，黑產團夥逐漸將攻擊目標從傳統服務轉移到了 AI 相關服務。&lt;/p&gt; 
&lt;p&gt;近日，百度安全團隊捕獲到了一起&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIPzuok7ej_ghTn59R9PRbA&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;針對大模型相關組件 ComfyUI 的攻擊事件&lt;/strong&gt;&lt;/a&gt;&lt;/u&gt;，經過深入分析，該事件背後團夥已實際針對國內不少公網 ComfyUI 進行了入侵。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;關於 ComfyUI&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;‌ComfyUI 是一款基於節點流程的 Stable Diffusion 操作界面，專為圖像生成任務設計。‌它通過將深度學習模型的工作流程簡化為圖形化節點，使用户操作更加直觀和易於理解。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 提供了高度的可視化和擴展性，用户可以通過拖放操作來構建和調整圖像生成流程，無需編寫代碼。‌作為大模型圖像生成領域的最熱門框架之一，其在 GitHub 斬獲了接近 7W Star，備受開發者喜愛，根據網絡空間測繪數據，全網共有近 2700 例 ComfyUI 服務，其中不乏無需密碼直接訪問的案例。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 後台支持加載用户指定的模型文件，同時用户可以方便地管理模型。但給用户帶來便利的同時，也存在一些安全隱患。&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;376&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161939_EGHc_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;百度安全在捕獲的攻擊事件中發現，攻擊者利用 ComfyUI 用户錯誤配置問題，在無需認證的情況下進入到 ComfyUI 後台，同時利用後台模型加載功能安裝攻擊者提前上傳在 Hugging Face 的投毒模型文件，以便利用模型加載時的 pickle 反序列化邏輯，控制受害者機器，進一步滲透目標內網。&lt;/p&gt; 
&lt;p&gt;本次事件攻擊者主要利用了 ComfyUI 控制枱無身份鑑權的配置錯誤問題進入控制後台，並通過 ComfyUI-Manager 插件中的遠程下載功能從 Hugging Face 及其鏡像站等相關模型倉庫拉取投毒模型（.pth 後綴的文件），使得開發者在使用 ComfyUI 加載投毒模型時會因自身的 pickle 反序列化邏輯觸發惡意的 Loader，進而執行惡意 Bash 腳本，腳本會從攻擊者的服務器上拉取 C2 木馬進行遠程控制，C2 域名為 cloudflare.com 提供給普通用户使用的隧道服務（用户可以無需外部域名和 ip 就可以把內網的服務映射到外部），攻擊者濫用該服務，達成隱蔽控制的目的。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;696&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/162047_QvnF_2720166.png&quot; width=&quot;941&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;據 CVE 官方披露，ComfyUI 歷史存在多種漏洞類型，包括：任意文件讀取漏洞、遠程代碼執行漏洞、存儲 XSS 漏洞等。&lt;/p&gt; 
&lt;p&gt;相關漏洞已分配如下 CVE 編號：CVE-2024-10099、CVE-2024-21574、CVE-2024-21575、CVE-2024-21576、CVE-2024-21577。&lt;/p&gt; 
&lt;p&gt;本次事件主要利用的 ComfyUI 默認無身份鑑權機制的&quot;特性&quot;，從而直接訪問 ComfyUI 後台。但該「特性」官方並不認為是安全漏洞，歸因為用户錯誤配置，在使用上官方始終認為使用者應自行注意，不要將 ComfyUI 對公網暴露或應該通過沙箱環境運行，以確保 ComfyUI 安全。&lt;/p&gt; 
&lt;p&gt;參考&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomfyanonymous%2FComfyUI%2Fdiscussions%2F5165&quot; target=&quot;_blank&quot;&gt;https://github.com/comfyanonymous/ComfyUI/discussions/5165&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340226</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340226</guid>
            <pubDate>Fri, 21 Mar 2025 08:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>CleanRL —— 深度強化學習庫</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CleanRL 是一個深度強化學習庫，提供具有研究友好功能的高質量 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;single-file&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;實現。該實現簡潔明瞭，但我們可以使用 AWS Batch 對其進行擴展以運行數千次實驗。CleanRL 的亮點包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;Single-file&amp;nbsp;&lt;/span&gt;實現

&lt;ul&gt;
&lt;li&gt;關於算法變體的每個細節都被放入一個獨立的文件中。&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;ppo_atari.py&lt;/code&gt;只有 340 行代碼，但包含了 PPO 如何與 Atari 遊戲配合使用的所有實現細節，&lt;strong&gt;因此對於不想閲讀整個模塊庫的人來説，它是一個很好的參考實現&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://benchmark.cleanrl.dev/&quot;&gt;基準測試實施（ https://benchmark.cleanrl.dev&lt;/a&gt;上的 7 種以上算法和 34 種以上游戲）&lt;/li&gt;
&lt;li&gt;Tensorboard&amp;nbsp;Logging&lt;/li&gt;
&lt;li&gt;Local Reproducibility via Seeding&lt;/li&gt;
&lt;li&gt;遊戲視頻捕捉&lt;/li&gt;
&lt;li&gt;利用&lt;a href=&quot;https://wandb.ai/site&quot;&gt;權重和偏差進行實驗管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;與 Docker 和 AWS 進行雲集成&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/cleanrl</link>
            <guid isPermaLink="false">https://www.oschina.net/p/cleanrl</guid>
            <pubDate>Fri, 21 Mar 2025 08:20:00 GMT</pubDate>
        </item>
        <item>
            <title>快手搜索已全面接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;快手搜索官方宣佈已全面接入 DeepSeek R1 的大模型能力，優化搜索效果與用户體驗，未來也會持續探索智能搜索場景的商業化變現能力。&lt;/p&gt; 
&lt;p&gt;此前，快手已宣佈&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fir.kuaishou.com%2Fzh-hans%2Fnews-releases%2Fnews-release-details%2Fkuaishou-kling-ai-integrates-deepseek-lowering-entry-barrier-ai%2F&quot; target=&quot;_blank&quot;&gt;可靈 AI 已全面接入 DeepSeek-R1&lt;/a&gt;&lt;/u&gt;，在視頻生成、圖片生成等場景下，用户可通過 DeepSeek 協助生成或者優化提示詞，將靈感轉化為專業提示詞，打造高質量創意視頻。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;3436&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161226_9Zcs_2720166.png&quot; width=&quot;2324&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340224</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340224</guid>
            <pubDate>Fri, 21 Mar 2025 08:12:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>印度人工智能快速發展隱憂猶存</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在美國斯坦福大學 2024 年底發佈的《全球人工智能實力排行榜》上，印度在全球 36 個國家 AI 活躍度綜合評估中排名第四位，僅次於美國、中國和英國。今年 2 月，印度總理莫迪提出了印度的「雙重 AI」願景。第一重「AI」是人工智能（Artificial Intelligence），第二重「AI」是有雄心的印度（Aspirational India）。隨後印度與法國在巴黎聯合主辦了「人工智能行動峯會」，向全世界展示了印度希望通過人工智能推動經濟轉型升級，實現跨越發展的目標。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度政府近年來不斷加大對人工智能領域的投入。2024 年 3 月，印度政府啓動「印度人工智能使命（India AI Mission）」，這是一項國家產業發展規劃，為印度人工智能初創企業提供包括 GPU（圖形處理器）關鍵算力在內的數字基礎設施服務以及政策和資金支持，計劃推動印度人工智能市場在 2024 年至 2027 年之間年均增長率達到 25% 至 35%，並在 2027 年創造 170 億美元的價值。全球統計數據庫（Statista）預計，2025 年，印度人工智能市場規模將超過 80 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度擁有龐大的人口基數和多樣化的市場需求，為人工智能技術應用提供了廣闊空間。在政府大力扶持下，阿達尼、塔塔、信實集團等印度本國大企業近年來不斷加大人工智能和數據中心建設投資，助推印度數字經濟發展。威普羅（Wipro）、菲爾洛普（Verloop）等印度本土私營人工智能企業也加大研發投資和應用推廣，加速拓展本土和周邊國家市場，特別是印度企業憑藉本國語言多樣性優勢，訓練適用廣泛的多語言數據模型，已經成功拿下多個東南亞、南亞國家政府訂單。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但相較而言，印度自主研發人工智能技術面臨較大挑戰。研發偏基礎研究而非應用研究，基礎編程人員多，應用研究人才少，同時大量技術人才流失，大多流向美西方科技企業，研發投入整體仍顯不足，推動研究成果商業化的生態系統有待完善。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;針對本國企業在技術研發能力上的不足，印度政府藉助與世界頂尖人工智能研究機構和企業合作，利用世界現有先進技術實現應用層面的創新，加速自身技術突破。近年來，谷歌、微軟、亞馬遜、AMD 等國際科技企業高層頻頻造訪印度，科技巨頭們也紛紛宣佈大規模投資印度人工智能和大數據項目。今年 2 月初，OpenAI 首席執行官薩姆·奧爾特曼在會見印度鐵道、通信以及電子和信息技術部長阿什維尼·瓦伊什瑙時表示，印度是人工智能領域重要的市場，應當成為人工智能革命的領導者之一。在中國開源人工智能模型深度求索（DeepSeek）推出後，印度政府表示，將在本土服務器上部署 DeepSeek，並計劃再用 6 個月至 10 個月的時間，根據不同文化和語言需求設計開發出印度自己的開源人工智能基礎大模型。印度政府希望，屆時印度將在人工智能領域具備更強的國際競爭力，能夠為世界提供「另一個有希望的替代方案」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;不過，在印度人工智能市場快速發展的背後也存在隱憂。有專家指出，人工智能熱潮可能衝擊印度以服務業為主的產業結構，人工智能的替代效應可能造成規模性失業和消費下滑，抑制人口紅利釋放，加大印度政府通過勞動密集型產業推動工業化的難度。一旦人工智能發展不能與工業製造業發展兼容，印度可能錯過本輪產業升級窗口期。 （經濟日報記者，王寶錕）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340223</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340223</guid>
            <pubDate>Fri, 21 Mar 2025 08:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Midjourney 核心開發者離職，加入 Cursor 負責開發 AI 編程 Agents</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;負責 Midjourney V2 至 V7 模型開發的核心工程師 theseriousadult 在 X 上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fgallabytes%2Fstatus%2F1902864672728158610&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;已從公司離職。&lt;/p&gt; 
&lt;p&gt;theseriousadult 寫道：「&lt;strong&gt;&lt;em&gt;我幾乎從第一天起就一直在使用 Cursor，我真的很高興能開始從事長期以來在我的工作流程中如此重要的事情。語言模型將改變我們構建代碼和與代碼交互的方式，我想將其推向極限。&lt;/em&gt;&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2593&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/154821_Ouez_2720166.png&quot; width=&quot;1304&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這位開發者在 Midjourney 的三年時間裏，主導了多個版本的模型迭代，以其對美學與創意的專注而聞名，其工作成果深受業界讚譽。離職後，theseriousadult 加入 Cursor 負責開發 AI 編程 Agents。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/337993/anysphere-in-talks-for-close-to-10-billion-valuation&quot; target=&quot;news&quot;&gt;AI 編程神器 &quot;Cursor&quot; 估值達百億美元&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/320498/anysphere-acquires-supermaven&quot; target=&quot;news&quot;&gt;Cursor 母公司 Anysphere 收購 AI 編碼助手 Supermaven&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340219</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340219</guid>
            <pubDate>Fri, 21 Mar 2025 07:53:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>騰訊元寶新技能：支持分析複雜 Excel 表格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;騰訊元寶&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FV3c4L5T9jvSMACo2JRtrxw&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;推出一項新功能，能夠幫助用户分析複雜 Excel。「你只需要把表格給到元寶，元寶就能直接算、直接答，還能畫重點。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在過去，處理 Excel 表格往往需要用户記住大量的函數和公式，稍有不慎就可能導致錯誤。現在，用户只需將表格上傳至元寶平台，元寶就能直接進行分析，無需用户手動輸入公式或進行復雜的操作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;394&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7eae121ba5a814f0370a2c7d0fc4f138ce3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在碰到體量很大、需要做複雜計算的表格時，可以切換到 Hunyuan，並關閉深度思考。這樣，快思考模型混元 Turbo S 就可以用代碼的方式進行快速分析。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，騰訊元寶不僅支持本地上傳表格，還支持從微信和騰訊文檔直接導入。無論是電腦版、Web 版還是移動端，用户都可以無縫切換。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338559&quot; target=&quot;news&quot;&gt;騰訊元寶宣佈支持上傳、導出騰訊文檔&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340214</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340214</guid>
            <pubDate>Fri, 21 Mar 2025 07:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>百度：任何人無權觸碰用户數據</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在就 「謝廣軍女兒開盒」 事件發佈聲明後，百度於 3 月 20 日下午召開信息安全溝通會，針對事件的調查過程及結果進行現場説明，並展示經三方公證的「（2025）京精誠內經證字第 1642 號」公證書。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;492&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d450818c480c7db9cb2aaf28a87e1384093.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度安全負責人陳洋表示，&lt;strong&gt;百度任何職級的員工及高管均無權限觸碰用户數據&lt;/strong&gt;。同時披露了事件調查結果：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;事件發生以來，百度對當事員工的「歷史數據申請記錄」、「權限記錄」、「數據查詢」等多項權限和操作日誌進行了調查與審計，確認其沒有百度用户個人身份信息的數據權限，也未登錄任何百度數據庫與服務器。經核實，確認開盒信息並非從百度泄露。該過程，全程經過三方現場公證。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;針對「開盒事件」發生後網上流傳的「當事人承認家長給她數據庫」截圖，經核實發現，該截圖的信息內容不實，事實為博主收到家人紅包後，在平台曬出紅包截圖，博主回覆「我家長給的」，本意是想説明紅包的來源，與「開盒」無關，事件發生後的大量傳播信息均為不實。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;並詳細講解了百度針對數據安全的多項防護措施：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户註冊賬號階段，即實施假名化處理，降低數據泄露風險，提高數據合規性；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;對數據實施加密，對敏感數據進行嚴格隔離，並依託數據安全管理平台，實現數據管理、權限控制及安全審計的統一管控；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;遵循國際公認的風險控制理念，建立「基礎防守」、「制度&amp;amp;能力&amp;amp;風險專項」、「稽查&amp;amp;內部審計」三道安全防線。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度表示，在相關政府部門的指導下，積極響應和倡議推進「反開盒」聯盟的成立，共同加強數據隱私防護，嚴厲打擊非法數據竊取及泄露行為，築牢網絡安全防線，共同維護清朗網絡空間。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/339949&quot; target=&quot;_blank&quot;&gt;百度就 「謝廣軍女兒開盒」 事件發佈聲明&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340213</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340213</guid>
            <pubDate>Fri, 21 Mar 2025 07:22:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>13 年後，AlexNet 源代碼終於公開</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌首席科學家 Jeff Dean 宣佈，他們與計算機歷史博物館（CHM）合作，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcomputerhistory.org%2Fblog%2Fchm-releases-alexnet-source-code%2F&quot; target=&quot;_blank&quot;&gt;共同發佈了 AlexNet 的源代碼&lt;/a&gt;&lt;/u&gt;，並將長期保存這些代碼。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150916_mJ2m_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;開放後的代碼庫如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;520&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/150931_Gm2o_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;GitHub 鏈接：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomputerhistory%2FAlexNet-Source-Code&quot; target=&quot;_blank&quot;&gt;https://github.com/computerhistory/AlexNet-Source-Code&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;AlexNet 是一個人工神經網絡，用於識別照片內容。它由當時的多倫多大學研究生 Alex Krizhevsky 和 Ilya Sutskever 以及他們的導師 Geoffrey Hinton 於 2012 年開發。&lt;/p&gt; 
&lt;p&gt;在計算機歷史上，AlexNet 的出現有着劃時代的意義。在它出現之前，很少有機器學習研究人員使用神經網絡。但在 AlexNet 出現之後，幾乎所有研究人員都會使用神經網絡。從 2012 年到 2022 年，神經網絡不斷取得進步，包括合成可信的人類聲音、擊敗圍棋冠軍選手、模擬人類語言並生成藝術作品…… 最終，OpenAI 於 2022 年發佈 ChatGPT…… 它是這一系列故事的重要起點。&lt;/p&gt; 
&lt;p&gt;「谷歌很高興將具有開創性意義的 AlexNet 項目的源代碼貢獻給計算機歷史博物館」，Jeff Dean 説，「這段代碼是 Alex Krizhevsky、Ilya Sutskever 和 Geoffrey Hinton 撰寫的標誌性論文《ImageNet Classification with Deep Convolutional Neural Networks》的基礎，該論文革新了計算機視覺領域，是有史以來被引用次數最多的論文之一。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/151006_C9sF_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Google Scholar 數據顯示，AlexNet 相關論文被引量已經超過 17 萬。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;除了代碼本身的價值，HuggingFace 聯合創始人 Thomas Wolf 還發現，代碼中的註釋也非常有啓發性。他説，「也許真正的歷史記錄是 AlexNet 代碼中每個實驗配置文件末尾的實驗記錄註釋。一個開創性的神經網絡正在誕生……」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1454&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/151021_yhzH_2720166.png&quot; width=&quot;1204&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</guid>
            <pubDate>Fri, 21 Mar 2025 07:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 上線 OpenAI.fm 網站</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;今天凌晨，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/340143/openai-next-generation-audio-models&quot;&gt;OpenAI 上線了全新語音模型 API&lt;/a&gt;&lt;/u&gt;，具體包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-transcribe (語音轉文本)&lt;/strong&gt;：單詞錯誤率 (WER) 顯著降低，在多個基準測試中優於現有 Whisper 模型&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-mini-transcribe (語音轉文本)&lt;/strong&gt;：gpt-4o-transcribe 的精簡版本，速度更快、效率更高&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;gpt-4o-mini-tts (文本轉語音)&lt;/strong&gt;：首次支持「可引導性」(steerability)，開發者不僅能指定「説什麼」，還能控制「如何説」&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;為了讓用户體驗這些全新的語音模型，OpenAI 上線了一個新網站：&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.openai.fm%2F&quot; target=&quot;_blank&quot;&gt;https://www.openai.fm/&lt;/a&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p&gt;用户可以在 OpenAI.fm 網站上體驗並製作 gpt-4o-mini-tts 的相關音頻，這個演示網站可謂是功能齊全，其中包含了官方的預設模板，提供&lt;strong&gt;人設、語氣、方言、發音&lt;/strong&gt;等設置。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150127_tnfp_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3249e7adafd64b35ea62bad76f0f6934b7d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;值得一提的是，OpenAI 還舉辦了一個廣播比賽。用户可以在 http://OpenAI.fm 製作音頻，接着使用 OpenAI.fm 上的「分享」按鈕生成鏈接，然後在 X 平台分享該鏈接。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3604eb6d4cae2ec616dfdca711e05d376bb.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;最具創意的前三名將各獲一台限量版 Teenage Engineering OB-4。音頻時長建議控制在 30 秒左右，可在語音、表達、發音或劇本語調變化上盡情發揮創意。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340209/openai-fm</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340209/openai-fm</guid>
            <pubDate>Fri, 21 Mar 2025 07:05:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>蘋果因 Apple Intelligence 功能延遲面臨集體訴訟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;蘋果公司在美國加州聖荷西的聯邦法院遭到了一起集體訴訟，原告指控蘋果在多個 「Apple Intelligence」 功能的宣傳中存在虛假廣告行為。訴訟於週三提交，原告尋求對購買了具備 Apple Intelligence 功能的 iPhone 及其他設備的消費者進行賠償。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;244&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7761c132a0cc697735299b460941837b6de.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據原告的投訴，他們認為蘋果的廣告為消費者樹立了一個清晰且合理的期望，即這些革命性的功能將在 iPhone 發佈時可用。然而，原告表示，用户所實際體驗到的蘋果智能功能遠未達到這些宣傳的水平，存在明顯的限制，甚至有些功能完全沒有實現。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;原告的律師在投訴中指出：「蘋果的廣告讓消費者誤以為這些先進的人工智能功能會在產品發佈時全面可用，但實際上，產品所提供的功能卻大大低於消費者的預期，這嚴重誤導了消費者對其實際效用和性能的理解。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此訴訟的提出正值蘋果在推向市場的 Apple Intelligence 功能遭遇困難之際。據彭博社報道，蘋果首席執行官蒂姆・庫克對負責產品開發的人工智能主管約翰・賈安德雷亞的執行能力表示失去信心。這使得蘋果在推進這些備受期待的功能上遭遇了不小的挑戰，也給公司帶來了新的壓力。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340205/apple-suit-false-advertising-ai-intelligence</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340205/apple-suit-false-advertising-ai-intelligence</guid>
            <pubDate>Fri, 21 Mar 2025 06:53:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>哈佛研究：Go 商業價值達 8.03 億美元，開源經濟價值達 8.8 萬億美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;哈佛商學院發佈的一項&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.hbs.edu%2Fris%2FPublication%2520Files%2F24-038_51f8444f-502c-4139-8bf2-56eb4b65c58a.pdf&quot; target=&quot;_blank&quot;&gt;研究報告指出&lt;/a&gt;，開源軟件的經濟價值高達 8.8 萬億美元。如果沒有開源程序，公司在軟件上的花費將增加約 3.5 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;由於開源應用程序大多免費，而且其使用數據只能在有限範圍內測量，價值無法通過價格與銷售額的乘積來確定。因此研究人員計算的是供給價值，即開發新開源程序的成本。另一方面還計算了需求價值；即如果公司必須自己開發每個開源應用程序，他們將承擔的成本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;352&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-51527f4c243c759bfdf8a25bc1280adaaa9.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據研究人員的計算，供給價值為 41.5 億美元；需求價值則高出 2000 倍，為 8.8 萬億美元。相比之下，2020 年全球軟件支出約為 3.4 萬億美元。此外，約 5% 的開發人員佔供給價值的約 93%，佔需求價值的 96%。研究報告的作者認為，這種不均衡的分佈是少數開發者使用眾多資源庫的結果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;研究人員還研究了不同編程語言和標記語言的商業價值。例如，Go 語言的報價價值約為 8.03 億美元。其次是 JavaScript（7.58 億美元）、Java（6.58 億美元）和 C（4.06 億美元）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;儘管 Python 近兩年來廣受歡迎，但其供給價值僅為 5500 萬美元。在需求方面，Go 的價值最高，超過 5 萬億美元，是排在第二位的 JavaScript 的四倍多。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;為了確定公司對開源軟件的使用情況，研究人員使用了兩組不同的數據集。其中一組識別出公司產品中包含的開源代碼。第二組數據集顯示公司網站上可用的代碼。但是，這些數據並不包括所有開源項目。研究人員沒有記錄開源操作系統。為了計算經濟價值，研究作者使用了 GitHub 上用户份額最高的 30 個國家的薪資數據。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，研究人員還警告稱，開源軟件是現代社會的共同利益。不應被過度使用，並敦促企業考慮到開源程序的經濟價值，為其自身的發展做出貢獻；且政治決策者有責任推動開源項目的發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;詳情可&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.hbs.edu%2Fris%2FPublication%2520Files%2F24-038_51f8444f-502c-4139-8bf2-56eb4b65c58a.pdf&quot; target=&quot;_blank&quot;&gt;查看完整報告&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340203/value-open-source-software</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340203/value-open-source-software</guid>
            <pubDate>Fri, 21 Mar 2025 06:44:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>數據思維 = 會寫 SQL 或 Python？</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;OSCHINA 編輯部【OSC 有問必答】欄目，每週一會，聚焦開發者提出的實際問題，邀請行業專家、技術大咖或資深開發者進行深度剖析和解答，人話版呈現開發者們最關心的問題。&lt;/p&gt; 
 &lt;p&gt;歡迎各位開發者説出你最關心的技術難題，也歡迎資深開發 er、行業專家、學者大咖們自薦！&lt;/p&gt; 
 &lt;p&gt;交流可添加微信：JunoHsu1122&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;div&gt; 
 &lt;p&gt;數據驅動的時代，開發者們面臨的挑戰不僅僅是技術實現，更是如何將數據轉化為實際的業務價值。&lt;/p&gt; 
 &lt;p&gt;數據思維，作為連接技術與業務的橋樑，正逐漸成為開發者們的必備能力。&lt;/p&gt; 
 &lt;p&gt;本期【OSC 有問必答】欄目，我們邀請到了擁有十年銀行數據分析項目經驗的資深專家錢興會，他將從實戰角度出發，深入探討數據思維的本質、應用場景以及如何在銀行業務中落地。&lt;/p&gt; 
&lt;/div&gt; 
&lt;blockquote&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;本期嘉賓：&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;錢興會&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;Fintech&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt; Career 社區主理人、北京市人工智能行業協會專家、清華大數據產業聯盟專家委員會專家、廣東大數據產業聯盟專家委員、擁有超過十年銀行&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;數據分析&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;項目經驗的資深專業人士，服務了數十家大型銀行。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;在金融領域的多個數據驅動項目中發揮了關鍵作用，擅長通過&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;數據挖掘&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;與分析提升業務效率與決策質量。專業背景涵蓋了風險管理、客户行為分析以及產品優化等多個領域。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;通過構建高效的數據模型，幫助銀行實現了&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;信貸&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;審批流程的優化和客户關係的精細化管理。除了技術能力，還具備出色的項目管理和團隊協作能力，曾帶領團隊成功完成多個大型&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;數據分析&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;項目。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;數據思維破壁：從&quot;會寫 SQL&quot;到&quot;驅動業務增長&quot;&lt;/h2&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;問：許多開發者認為「數據思維=會寫 SQL 或 Python」，您如何看待這種説法？我們可以從哪些維度重新定義數據能力？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;這其實是個挺常見的誤解。會寫 SQL、Python 只是數據能力的基礎，但遠遠不等於數據思維。很多人能用 SQL 查詢數據，或者用 Python 畫個圖，但如果不懂數據的業務背景、分析方法、甚至數據質量，最終只能停留在「執行任務」的層面，而不是「用數據創造價值」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如果要真正定義數據能力，可以從這幾個維度來思考：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;數據理解：不僅是數據本身，還包括它的業務背景、來源、質量、限制等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據分析：能夠用合適的方法分析數據，而不是簡單的統計彙總。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據應用：能把數據分析結果轉化為實際的業務決策或優化方案。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據溝通：能把複雜的分析結論用清晰、易懂的方式表達給不同角色的人，比如業務人員、管理層。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據策略：能站在全局角度思考，如何用數據驅動業務增長，而不是隻做單次分析。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;所以，數據思維是個更全面的能力，而不僅僅是「會寫代碼」這件事。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：與傳統技術思維相比，數據思維最關鍵的差異點是什麼？開發者如何避免將數據分析僅視為「工具」，而是升級為系統性思維？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最大的區別在於「結果導向」和「閉環思維」。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;傳統技術思維，更關注「我能不能做出一個系統」「代碼能不能跑」「接口能不能通」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據思維，關注的是「這個數據分析能不能帶來實際價值」「業務能不能用數據做更好的決策」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;建立數據反饋閉環：不是做完數據分析就結束，而是要觀察這個數據分析帶來的業務變化，有沒有幫助決策改進？有沒有後續可以優化的地方？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;業務驅動的數據應用：先理解業務痛點，再用數據來解釋和優化，而不是隻為了分析而分析。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據產品化思維：能不能讓數據分析變成一個可複用的工具，而不是每次都臨時做個報表？&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;數據分析不是終點，而是讓業務變好的起點。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：數據可視化常被簡化為「圖表生成」，還有其他方式可以讓數據結果真正驅動業務行動嗎？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;很多人覺得數據可視化就是「做個圖表」，但實際上，數據可視化的目的是讓決策更直觀、更容易落地。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;更好的方式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;異常數據自動報警：不要只是做圖表，而是讓關鍵數據出現異常時自動提醒相關人員。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;決策建議+可視化結合：不僅僅展示「銷售下降了 20%」，而是直接告訴你「下降的原因是哪些產品銷售變差」並給出優化建議。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;場景化數據呈現：讓數據和業務流程結合，比如在銀行審批系統裏，直接可視化企業的信用評分趨勢，而不是讓審批員去查一堆表。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：數據思維為什麼還需要業務翻譯能力，開發者如何快速構建業務知識圖譜，並將數據思維融入其中？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;數據分析做得好不好，70% 靠對業務的理解，但很多開發者的痛點是——「業務方聽不懂技術，技術方搞不懂業務」，所以需要**「業務翻譯能力」**。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;關於為什麼需要業務翻譯能力？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;業務人員可能會提一些模糊的需求，比如「幫我們看看這個產品的活躍度」，但沒有明確數據指標。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技術團隊如果不理解業務，就容易查一堆無關數據，最後的分析報告業務方根本看不懂。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：如何快速構建業務知識圖譜？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;梳理關鍵業務流程：比如在銀行的貸款審批流程中，核心數據是什麼？哪些指標能影響業務決策？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;搭建業務-數據映射關係：比如「貸款審批成功率」=「審批通過人數/申請人數」，讓數據與業務語言對齊。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;知識沉澱：把常見的業務數據問題和分析框架形成數據文檔，方便新團隊成員快速上手。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;數據思維的終極目標是讓數據變成「業務資產」，而不是一堆表、一堆代碼。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;銀行實戰場景：當數據思維遇上模糊需求&lt;/h3&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：銀行開發者常面臨業務部門需求模糊的問題。如何用數據思維反向推動業務方清晰表達需求？能否分享一個成功案例？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;銀行業務方經常丟給開發者一個很模糊的需求，比如：「幫我們分析一下貸款用户的活躍度」&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如果開發者直接去查數據，十有八九會查出一堆沒啥用的表，最後業務方還會説「這不是我們想要的」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;解決方案：&lt;/strong&gt;用數據思維引導業務方明確需求，確保數據分析有價值。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;第一步，追問業務目標：直接問業務方——你們想通過這個數據分析做什麼決策？是想提高貸款轉化率？還是優化營銷策略？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第二步，定義關鍵指標：根據目標，先列出可能的衡量指標，比如「貸款用户 7 天留存率」「申請到審批通過的轉化率」等，讓業務方選出最相關的指標。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;第三步，提供數據示例：先用小樣本數據跑個初步分析，讓業務方看到大概的趨勢，然後再調整具體的數據需求。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;某銀行信用卡審批優化，以前，風控部門總是要求「優化信用卡審批流程」，但從來不給明確的衡量標準。後來，技術團隊用數據思維反向提問：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;你們是想降低壞賬率，還是想提高審批效率？&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;現有審批流程中，哪些步驟最容易導致用户流失？&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最終，大家發現問題其實是**「高信用評分用户的審批流程太長，導致用户流失」**，於是用數據優化了審批規則，審批時長縮短了 40%，但壞賬率基本沒變。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;所以，開發者不是等着業務方給需求，而是主動用數據思維，幫他們找到真正的問題。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：銀行普遍存在數據孤島問題，開發者如何通過數據思維推動跨部門協作？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;銀行的數據孤島問題很嚴重，比如貸款部門的數據和信用卡部門的數據互不相通，導致很多高信用客户的二次轉化機會被浪費。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;開發者可以這樣推動跨部門協作：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;用數據案例説服業務方：拿出一個實際的數據例子，比如「如果信用卡用户的高信用羣體能更快審批貸款，預計能提升 20% 的貸款轉化率」，讓不同部門看到數據共享的直接價值。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;推動數據標準化：不同部門的數據口徑不同，要先建立標準，比如「統一的用户 ID、統一的信用評分模型」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;藉助低代碼或數據中台：有些銀行已經開始用低代碼或數據中台，讓不同部門的數據能夠更方便地交互，減少開發工作量。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;數據孤島不是技術問題，而是組織問題。解決方案是讓業務方看到數據共享的直接好處。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：對公業務數據分析複雜度更高，如何通過數據思維幫助開發者從「流程自動化」進階到「業務洞察自動化」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;對公業務數據涉及多個維度，比如企業的現金流、信用狀況、行業趨勢等，光是做流程自動化（比如審批流程、報表自動生成）是不夠的，還需要做「業務洞察自動化」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如何進階？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;從被動分析轉向主動推薦：比如企業申請貸款時，系統可以自動分析企業財務數據，並給出「最合適的貸款方案」推薦。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;結合外部數據，形成完整視角：不僅僅看企業在銀行的交易數據，還可以結合行業數據、供應鏈數據，讓分析更加準確。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;做可解釋的智能分析：對公業務決策往往需要人工審批，所以數據分析結果需要清晰可解釋，不能是黑箱。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;舉個例子：智能風控，某銀行以前的風控策略是「手動審核企業財務報表」，但後來用數據智能分析，結合歷史交易、行業對比等，自動給出「高風險信號預警」，大大提升了審批效率。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;技術人進階指南：從「數據工具人」到「業務驅動者」&lt;/h3&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：在數據驅動的決策流程中，技術團隊如何平衡「快速響應業務」與「保證數據建模嚴謹性」的矛盾？是否存在「最小可行數據產品」方法論？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;最好的方法是**「最小可行數據產品（MVDP）」**，即：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;先做一個可驗證的小規模數據模型，看數據是否真的有價值&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;快速測試，持續優化，而不是一開始就做一個龐大的數據模型&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;業務和數據團隊協作迭代，數據團隊提供初步模型，業務團隊反饋後再優化&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;關鍵思路：小步快跑，快速驗證，持續優化。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：建議開發者掌握哪些「高性價比」數據分析工具鏈？如何避免陷入技術選型內耗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;其實工具只是手段，核心還是看業務需求和實際場景。如果追求高性價比，建議採用「通用工具+行業專用工具」的思路&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;通用型數據分析工具（適合大多數銀行開發者）&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;SQL（PostgreSQL / MySQL / ClickHouse） → 數據查詢和 ETL 的基礎&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Python（Pandas、NumPy、Scikit-Learn） → 數據清洗、分析、建模的主力工具&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BI 工具（Tableau / Power BI / Metabase） → 數據可視化和業務報表&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;適用於銀行場景的工具&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;金融大數據處理：Spark（大數據計算）、Flink（流式計算）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;智能風控與反欺詐：GraphDB（圖數據庫）、Neo4j（社交關係分析）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;自動化數據治理：DataHub / Apache Atlas（數據目錄管理）&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;關於如何避免技術選型內耗？&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;以業務需求為導向：先搞清楚問題是什麼，再選工具，而不是因為「這個工具火」就去用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;避免重複造輪子：很多銀行內部都有數據中台，儘量複用已有的數據基礎設施。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;先小規模試點，再推廣：比如嘗試用 ClickHouse 替換傳統 OLAP 查詢，如果效果好再推廣，而不是一上來就做大遷移。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：AI 大模型（如生成式 AI、多模態模型）正在顛覆傳統的數據分析範式。您認為這對銀行從業者的「數據思維」提出了哪些新要求？是否需要從「因果分析」轉向「關聯洞察」為主？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;大模型的出現，確實讓傳統數據分析邏輯發生了變化：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;以前的分析是「基於規則和統計」，我們關注因果關係，比如「存款利率提高 → 儲蓄賬户開通數量增加」。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;但現在的 AI 大模型更擅長從複雜數據中發現隱藏的模式和關聯，比如「某種用户行為 → 可能意味着更高的信用風險」，但這個模式未必能直接解釋「因果邏輯」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;新的數據思維要求：從因果分析向「關聯洞察」拓展&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;傳統數據分析=「A→B 的因果關係」&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;AI 數據分析=「A、B、C…有強相關性，可能影響業務」&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;銀行可以利用 AI 提前發現風險信號，而不僅僅依賴已有的規則。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;讓 AI 成為業務分析助手，而不是替代傳統分析&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;生成式 AI 可以自動總結數據趨勢，但分析員仍需驗證 AI 的結論是否合理。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;加強數據治理，確保 AI 洞察的可解釋性&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;AI 大模型讓銀行的「數據思維」從因果邏輯拓展到了「全局模式發現」，但開發者仍然需要結合因果推理，避免過度依賴「黑箱相關性」。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;問：AI 大模型能自動生成分析報告甚至決策建議。這是否會導致開發者過度依賴 AI 工具，反而弱化數據思維的培養？如何設計人機協作的邊界？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&lt;strong&gt;答：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;AI 確實可以幫我們生成分析報告、圖表，甚至自動做決策建議，但完全依賴 AI 是不現實的。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;潛在風險：AI 的分析結果不一定正確；AI 的分析是基於歷史數據訓練的，如果數據有偏差，AI 的結論也可能有誤。比如 AI 可能會誤判「某類貸款用户的風險更高」，但其實只是歷史數據裏這類用户較少。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;AI 缺乏業務上下文：AI 可以總結數據趨勢，但它不知道「這個趨勢是否符合市場變化」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;例如，如果 AI 發現「2023 年房貸違約率下降」，它不會考慮是不是因為政府推出了新的購房政策。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;如何設計「人機協作」的邊界？最佳方案：讓 AI 成為數據分析的「助手」，但最終決策仍然由人來做。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;讓 AI 自動生成初步分析，但讓人類去驗證並最終調整。 v 設定「人機協作的檢查機制」，比如在 AI 給出金融風控建議時，風控團隊要有一套人工審核機制，確保 AI 不會做出錯誤判斷。&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4489239/blog/17963082</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/17963082</guid>
            <pubDate>Fri, 21 Mar 2025 06:40:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>Anthropic 為 Claude 增加聯網搜索功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Anthropic &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.anthropic.com%2Fnews%2Fweb-search&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;為旗下 Claude 聊天機器人增加 Web 搜索功能，啓用該功能後，Claude 會自動聯網搜索信息，並在反饋結果中會提供引用出處，以便用户核實來源。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/143104_Yw2o_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-eedcd8f5f771ae0e8c0be9db894e9397cfc.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;據悉，搜索功能目前已面向美國 Cladue 付費用户推出預覽版，不久將向免費用户和其他國家提供支持。用户可以在 Cladue 的個人檔案設置中開啓 Web 搜索，Cladue 會自動搜索各個網站，為回覆提供信息來源。&lt;/p&gt; 
&lt;p&gt;與 ChatGPT 不同，Claude 並未在輸入框中設置專門的「搜索」按鈕，用户需在個人設置中開啓聯網搜索功能。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/143726_vIPC_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 表示，Web 搜索目前只能在 Claude 的最新模型中使用，即 Claude 3.7 Sonnet。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340196/anthropic-claude-web-search</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340196/anthropic-claude-web-search</guid>
            <pubDate>Fri, 21 Mar 2025 06:29:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>