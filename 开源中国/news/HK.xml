<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Mon, 11 Aug 2025 12:45:52 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>開源前端框架 Tailwind 創始人為 AI 生成的默認紫色 UI 道歉</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源前端框架 Tailwind 創始人 Adam Wathan&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FGZhan57%2Fstatus%2F1953866977539219836%2Fphoto%2F1" target="_blank"&gt;表示&lt;/a&gt;，因為五年前他將 Tailwind UI 中的每個按鈕都設為「bg-indigo-500」，這導致地球上每個 AI 生成的 UI 也都是靛藍色的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0811/191017_Uh4E_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Tailwind CSS 是一個為快速開發而精心設計的原子類開源 CSS 框架，它提供了充滿設計感和應用程序至上的能力來創建組件，開箱即用。&lt;/p&gt; 
&lt;p&gt;Tailwind CSS 在 AI 項目（尤其是涉及生成 UI 的 AI，如 LLM 驅動的代碼助手、AI 設計轉代碼工具等）中廣受歡迎。這源於其設計哲學和特性完美契合了 AI 生成代碼的需求和挑戰。它提供了：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;可預測、低歧義的樣式表達方式（原子類）。&lt;/li&gt; 
 &lt;li&gt;自包含、上下文獨立的代碼結構（內聯樣式）。&lt;/li&gt; 
 &lt;li&gt;有限決策空間、高一致性的設計約束（預設系統）。&lt;/li&gt; 
 &lt;li&gt;高效、快速迭代的開發模式。&lt;/li&gt; 
 &lt;li&gt;基於海量流行數據訓練的開發者友好模式。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;如果要避免 AI 使用藍色、紫色，可以加這句 prompt：&lt;br&gt; avoids using indigo or blue colors unless specified in the user's request.&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365577</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365577</guid>
      <pubDate>Sun, 10 Aug 2025 11:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenAI 在華申請「GPT-5」商標被駁回</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;近日，隨着&amp;nbsp;OpenAI&amp;nbsp;正式推出其新一代人工智能模型&amp;nbsp;GPT-5，該公司在中國申請相關商標的進展也引發了關注。據天眼查數據顯示，OpenAI 公司及其運營子公司曾多次申請註冊「OPENAI GPT-5」和「GPT-5」等商標，但目前這些申請均處於「等待駁回複審」或「駁回複審中」的狀態。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;&lt;img height="345" src="https://oscimg.oschina.net/oscnet/up-1477ae4d4e71cad8ceb2fea3ca19cc1802f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在 OpenAI 之前，國內也曾有公司嘗試註冊「GPT-5」商標。數據顯示，深圳一家科技公司曾申請註冊兩枚「GPT-5」商標，但均已被駁回並處於無效狀態。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 此次在中國申請的商標涵蓋「網站服務」和「科學儀器」等國際分類，但流程顯示，其註冊申請並未順利通過。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;&lt;a href="https://www.oschina.net/news/364960/openai-gpt-5" target="news"&gt;OpenAI 正式發佈 GPT-5&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365571</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365571</guid>
      <pubDate>Sun, 10 Aug 2025 10:39:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源重構汽車：從孤島到協作的生態演進</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;智能汽車的軟件正迅速成為核心價值載體:其代碼規模已達數億行、成本佔比迅速上升，與此同時開源正在成為推動技術品牌、成本控制、效率提升、生態協作的關鍵手段，而全球及中國的車企正在通過分層架構、自主研發與行業協作融合大模型技術，共同推進「軟件定義汽車「時代的到來。&lt;span style="display:none"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:justify"&gt;&lt;span style="font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif"&gt;一輛有智能輔助駕駛功能的汽車需要多少行代碼？&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到今天，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果考慮車上的所有軟件，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;這個答案已趨近於 7 億行。同時，軟件也正在成為整車 BOM 表裏單價最高的「零部件」。德勤報告測算，2030 年軟件成本佔整車 BOM 比重將從目前不到 10% 增長到 50%，包括程序開發、AI 算法、操作系統、控制器和芯片等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「軟件定義汽車」的趨勢愈加明晰。而開源作為現代軟件世界中提升&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;協同&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;效率、降低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基礎技術研發&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成本的大功臣，自然也被引入到汽車軟件的場景中，扮演着至關重要的角色。據相關調研數據顯示，汽車行業中代碼庫的開源代碼佔比近 70%，廣泛應用在基礎軟件、座艙軟件等不同的場景中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;從開源協作的角度看，近期海內外的車企、科技企業等都有引人注目的動作：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;除了我們近兩年看到的普華軟件、國科礎石、睿賽徳、理想汽車&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面向基礎操作系統的開源，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不久前，包括大眾集團、寶馬集團、梅賽德斯-奔馳等在內的 11 家歐洲汽車及科技公司決定結盟，計劃共同開發並共享先進的汽車軟件平台。根據規劃，這些公司將在 2026 年之前交付核心軟件棧，基於該平台的首批車輛預計將於 2030 年開始批量生產。該軟件棧的源代碼將作為開源項目發佈，由 Eclipse 基金會管理，並基於現有的 S - Core 項目進行開發，採用模塊化設計：基礎層（通信中間件、認證模塊）開源共享，而上層信息娛樂、自動駕駛功能允許品牌差異化定製。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;這一系統性、行業級別的協作，被業內視為歐洲應對中美智能化領先的關鍵佈局。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就在這個消息發佈的前幾天，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;OpenSDV 汽車軟件開源聯盟也在積極行動，OpenSDV 汽車軟件開源聯盟技術生態總監滕召智與日本愛信、豐田等企業通話&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，溝通汽車開源生態建設的相關事項。滕召智表示，整體來看，歐洲的協作深度更深，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;架構上更容易統一，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;國內車企&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在市場上衝突比較直接，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技術上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;仍處於各自為戰狀態&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，説明國內的技術認知尚未收斂，也側面反映為了應對「內卷」而進行的創新還在持續。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;這種分化格局，其根源並非僅是表面的合作意願問題，也反映出技術路線、商業邏輯與協作成熟度的差異。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;汽車軟件架構：分層協作與車企的掌控焦慮&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;智能汽車的軟件體系早已超越簡單的代碼堆砌，形成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;供應鏈&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;協作的複雜生態。想要了解汽車軟件的生態發展，首先得清楚一輛車究竟需要哪些軟件，成本或者營收更可能發生在什麼地方？滕召智介紹，汽車軟件通常分為硬件抽象、虛擬化、操作系統、中間件、應用、工具鏈及外延&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;應用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;生態&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;七個層級。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;硬件抽象層（BSP/HAL 層）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;功能定義：作為最底層的軟件，直接管理硬件資源，包括芯片級驅動程序和硬件虛擬化接口。其核心是為上層系統提供統一的硬件操作界面，屏蔽不同硬件的差異。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技術形式：以板級支持包（BSP）或硬件抽象層（HAL）的形式存在，實現硬件資源的標準化調度，如傳感器控制、內存分配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;產業實踐：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在國內&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由地平線、黑芝麻智能等芯片廠商主導開發，確保操作系統和應用能跨硬件平台調用資源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;虛擬化層：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;功能定義：通過 Type 1 虛擬機將單一 SoC 芯片劃分為多個獨立域，支持不同操作系統並行運行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;典型場景：例如在智能座艙中，同時運行 Linux 驅動的儀表盤和 Android 系統的娛樂中控。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代表企業：中科創達、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中瓴智行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、國科礎石&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供商業化解決方案，已應用於理想、小鵬&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、東風等車企的部分車型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;操作系統層：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分類與定位：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;座艙系統：車企主導定製化開發，如鴻蒙 OS、理想 OS，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;小米澎湃，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;側重交互體驗；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;車控系統：依賴實時操作系統，如 Linux/Unix 變體，滿足高可靠性要求，如制動、轉向控制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，當前也激發了零部件廠商像智能零部件交付的進化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;開發模式：車企與操作系統廠商&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、方案商&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;聯合研發，確保功能安全與差異化適配。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中間件層&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;核心功能：實現軟硬件解耦，提供通信、數據管理和服務調度能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技術路線：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;傳統框架：AUTOSAR AP 汽車開放系統架構仍是主流標準；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新興方向：ROS 2/DDS 用於感知融合框架，支持自動駕駛多傳感器協同處理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;行業趨勢：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;結合自身的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SOA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;體系建設，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;成為車企技術投入重點，以降低功能迭代複雜度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;形成具有車企供應鏈管理、軟件迭代特性的工具鏈體系。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;應用層&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用户導向功能：直接面向消費者的交互模塊，包括語音識別、導航、ADAS 自動緊急制動及座艙娛樂系統。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;開發佔比：車企 40% 以上資源投入此層，因其直接決定品牌體驗差異和溢價能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工具鏈層：提供一些關鍵工具，如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SOA 設計工具：實現硬件資源服務化定義，如 Vector Davinci；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;仿真驗證平台：華為雲 KubeEdge 支持數字孿生測試 Sim-to-Real；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;台架測試系統：dSPACE SCALEXIO 硬件在環驗證&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;外延生態層：互聯協議，可以實現將手機應用直接「投影」到車載屏幕上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;國際：Apple CarPlay；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;國內：ICCOA Carlink，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由多家車企、手機廠商聯合創建，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;生態內的所有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;手機&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，目前也有很多合資品牌兼容了該協議。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分層協作的複雜生態中，投入的着力點往往也在決定着生態演進的方向。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;當下，車企往往最願投入用户看得見的部分——智能座艙的應用，應用層功能直接決定品牌溢價。究竟該自研哪些層級才能既保安全可控又贏得差異化？深扎操作系統和中間件的核心層級，投入巨大且週期漫長；完全依賴供應商方案，又恐喪失技術主動權和品牌特色。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此外，比亞迪、小米&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、華為、理想&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等頭部企業重倉操作系統與中間件，以降低供應鏈風險；中小車企則聚焦應用層，通過座艙娛樂功能提升溢價能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;供應鏈與合作：用開源建立信任&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如此清晰的軟件架構之下，業界如何協作共建？答案在中、歐之間呈現出截然不同的圖景。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;今年上半年，國內車企及相關業界機構的開源動作頻頻，但另一方面項目間關聯性不強。理想汽車在中關村論壇宣佈開源「理想星環 OS」，成為全球首家開源整車操作系統的車企。吉利汽車與階躍星辰聯合開源兩款大模型——300 億參數視頻生成模型 Step-Video-T2V 和多場景語音交互模型 Step-Audio。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;img height="972" src="https://oscimg.oschina.net/oscnet/up-7c402c968f8612ec93d43599261106adbf4.png" width="1536" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;項目地址：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://gitee.com/haloos/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;此外，東風汽車發佈行業最大端到端自動駕駛開源數據集，包含 125 萬組數據、6000 多個真實駕駛場景片段，如雨天避障、夜間會車等。除了普華基礎軟件的 EasyAda、小滿 EasyXMen 及天元 OS 等開源平台，企業開源的陣營在不斷擴大：比亞迪等車企已實現相關智能 AI 技術平台的開源，華為鴻蒙座艙開放核心能力後已有多家車企接入。在政府引導協同層面，早在 2024 年年底，國家智能網聯汽車創新中心發佈了車用操作系統基線版本開源計劃。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「車企普遍依賴自研體系，各家企業都認為自己能解決大部分問題，導致技術路線分散」，滕召智指出，這種模式雖能快速響應市場，但難以形成標準化合力。例如 AUTOSEMO 推動的 ASF 標準，因車企&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;不同的技術現實情況不同，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;執行差異大而落地困難。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;另一方面，企業參與開源也面臨着一些阻礙。比如傳統車企決策層對開源接受度低，且「忙於&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;業務生產&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;無暇顧及共性技術」；新勢力雖有技術意願，但需承擔高額成本分攤風險。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而且汽車供應鏈存在較高的准入壁壘，新興軟件廠商進入車規領域，需攻克功能安全認證（ISO 26262）或尋找資質供應商背書，尤其是在車控安全領域。這一點在 Eclipse Foundation 2023 年發佈的《汽車行業中的開源軟件》中也有提到：開源軟件在汽車外部應用中的使用率比汽車內部的高很多。在汽車內的有限使用主要是因為業內有嚴格的功能安全標準要求和嚴格的軟件開發流程，而許多（但不是所有）開源軟件方案往往達不到這樣的要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面對這些挑戰，滕召智以 Linux 發展史類比中國汽車開源生態的破局關鍵：「Debian、RedHat 等發行版讓小白用户能用 Linux，才引爆生態繁榮。我們亟需更多像新環 OS（指理想星環 OS 等）這樣的開源發行版，降低開發者參與門檻。」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;為此，OpenSDV 選擇從工具鏈和標準入手進行突破，試圖為打破孤島創造條件：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代碼安全基礎設施：開發 AI 驅動的代碼自動審查工具，可識別功能安全缺陷並自動修復，已被 Linux 基金會 AGL 項目納入流程，供全球車企使用；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;實時性評測標準：聯合 40 餘家車企制定智駕 OS 實時性團體標準，統一主機廠與供應商的測試閾值，打破交付反覆認證的僵局；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;法務支撐體系：構建開源合規知識庫，解決車企出海時的軟件供應鏈法律風險。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:left"&gt;&lt;img height="732" src="https://oscimg.oschina.net/oscnet/up-5c18bb6f6370e3e7f34fa2d8b2e11747377.png" width="1386" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0.0001pt; margin-right:0px"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#8f959e"&gt;2024 年，OpenSDV 在成員單位中，針對開源在汽車軟件供應鏈的應用、使用、管理等方面，做出了行業調研。樣本企業主要來自整車主機廠、汽車軟硬件 Tire1 供應商、檢測機構、 軟件工具廠商等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「開源讓車企深度參與代碼貢獻，看清系統如何運作，才能建立技術信任」，滕召智認為，開源的關鍵作用之一還在於建立信任，基於透明參與和深度理解的技術信任，或許可以打破當前各自為戰的局面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;技術演進：大模型技術的融合&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;開源生態的成熟，最終也會服務於更高階的智能化應用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前國內車企在人工智能技術應用上，主要還是依賴現有的通用大模型算法，在垂直汽車場景的專用優化方面投入有限。應用場景也多是語音交互等淺層功能，缺乏專用數據集訓練。這導致了大模型要真正契合汽車行業的複雜需求，如融合感知、倉駕決策上還存在明顯短板，無論是行業數據的深度積累，還是底層算法架構的針對性調整，都還需要一個長期的持續投入過程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;談到新興的大模型技術如何融入現有的智能駕駛系統時，滕召智用了人與「提線木偶」的對比來形象説明：未來理想的架構中，像特斯拉 Grok 這樣的高級大模型更像是那個操縱全局的「大腦」或核心決策者，負責整合車內外的感知信息。例如判斷駕駛員狀態是否安全，或者結合外部環境複雜情況，並做出整車級的統籌管理策略，比如決定何時需要系統接管控制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;甚至是一個很好的副駕或者領航員。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而當下成熟的智駕系統依賴傳感器如激光雷達和傳統控制算法，則更像是「提線木偶」本身——是大模型決策指令的執行單元，專注於實時、具體的車輛操控，如轉向、剎車等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;因此，大模型並非要取代或壓縮現有的智駕系統，而是作為一種升級和補充，兩者共同協作實現更高級別的智能駕駛能力，最終目標是達到這種「大腦指揮肢體」的集成狀態。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至於 OpenSDV 聯盟在推進汽車行業大模型技術標準化方面的工作，滕召智坦言目前聯盟的角色更偏向於參與者和引導者，而非主導者或實際研發方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:.0001pt; margin-right:0; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要原因是聯盟內尚未出現足夠強大的引領性企業來牽頭。因此，OpenSDV 的策略是通過其技術監督委員會，專注於在標準化層面推動一些基礎性工作。這具體包括參與到制定通用模型相關標準的討論中去，重點關注諸如 AI-BOM 方面的內容，規範模型組件的來源、兼容性和安全性，以及確保大模型在車載環境下符合功能安全要求的設計規範等領域。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通過協同，提煉共性需求，也形成了很多成果，比如在功能安全代碼的自動化審核，發起車用智能駕駛操作系統的性能評測規範等。其&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;核心思路是通過凝聚成員單位的共識，依託行業影響力，來間接推動相關標準框架在行業中的建立與發展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4489239/blog/18687777</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4489239/blog/18687777</guid>
      <pubDate>Sun, 10 Aug 2025 10:28:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>英偉達在中國銷售 AI 芯片需要向美國政府支付所得收入的 15%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;根據報道，&lt;strong&gt;英偉達和 AMD 預計將向美國政府支付其從向中國銷售人工智能芯片所得收入的 15%&lt;/strong&gt;，這是他們與特朗普政府達成的一項極為不尋常的財務協議的一部分。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/182159_4urE_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據三位瞭解該協議但因未獲授權公開討論而匿名的人士透露，這項協議是在英偉達獲準向中國銷售其人工智能芯片的一個版本後一個月達成的。&lt;/p&gt; 
&lt;p&gt;雖然特朗普政府在一個月前公開表示已批准英偉達向中國銷售 H20，但實際上一直遲遲沒有頒發允許這些銷售的許可證。&lt;/p&gt; 
&lt;p&gt;據知情人士稱，上週三，英偉達首席執行官黃仁勳在白宮與特朗普總統會面，並同意將 15% 的收入交給聯邦政府，實質上使聯邦政府成為英偉達在中國業務中的合作伙伴。&lt;/p&gt; 
&lt;p&gt;這些人士表示，商務部在兩天後開始頒發人工智能芯片銷售的許可證。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365568</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365568</guid>
      <pubDate>Sun, 10 Aug 2025 10:24:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬斯克宣佈 Grok V7 基礎模型完成預訓練，具備原生多模態能力</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;埃隆·馬斯克於 8 月 11 日在 X 平台上宣佈，xAI 的 Grok V7 基礎模型已於上週完成預訓練。該版本&lt;span&gt;最大&lt;/span&gt;的亮點在於其原生多模態能力，能夠直接處理視頻和音頻的比特流，無需進行轉換即可理解內容。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這意味着 Grok V7 不僅能看懂視頻畫面，還能聽懂語音中的細微變化，精準辨識出表達的情緒和語調重點，從而實現更深層次的語義理解。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="254" src="https://oscimg.oschina.net/oscnet/up-422d19d41c58d8b2c53f7d673b21c723220.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;與此同時，馬斯克還宣佈，Grok4 模型現在對所有用户免費開放。免費用户每天可以進行少量查詢，如果需要更多的使用權限，則需要付費訂閲。此舉旨在擴大 Grok 的用户基礎，使其更廣泛地被大眾所接觸和使用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Grok V7 的原生多模態能力，預示着其在視頻和音頻處理方面將帶來顯著提升，為未來的 AI 應用開啓了更多可能性。而 Grok4 的免費開放，也反映了 xAI 正在通過不同的策略來平衡技術創新與市場普及。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365565</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365565</guid>
      <pubDate>Sun, 10 Aug 2025 10:03:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Linus Torvalds 怒噴谷歌 Android 工程師，你的代碼就是垃圾</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Linux 創始人 Linus Torvalds 近日在 Linux 內核郵件列表中公開批評了谷歌 Android 團隊成員 Palmer Dabbelt 提交的 RISC-V 補丁代碼，稱其「質量低劣且嚴重超時」，直言「這是垃圾」，並警告不得再遲交。&lt;/p&gt; 
&lt;p&gt;Palmer Dabbelt 於上週五提交了一份旨在合併到 Linux 6.17 內核的 RISC-V 補丁代碼。然而 Linus Torvalds 認為該代碼不僅質量差，而且提交時間太晚，已接近 Linux 6.17 合併窗口的尾聲。&lt;/p&gt; 
&lt;p&gt;Linus&amp;nbsp;在郵件中毫不留情地指出：「&lt;strong&gt;不，這是垃圾，而且提交得太晚了……這種東西根本不應該發給我，更別提是在合併窗口的後期&lt;/strong&gt;」。他還強調，&lt;strong&gt;這段代碼「讓這個世界變得更糟糕&lt;/strong&gt;」，並警告稱：「&lt;strong&gt;若再提交此類垃圾代碼或延遲提交，將不再接受&lt;/strong&gt;」。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-936d20875ad3eebbff999f8de659ee9d2ec.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;後續建議 Linus 強烈建議 Palmer Dabbelt 儘早為 Linux 內核 6.18 提交代碼，並希望未來提交的代碼中「沒有垃圾」。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365562</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365562</guid>
      <pubDate>Sun, 10 Aug 2025 10:00:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>「沉浸式翻譯」插件試圖限制用户自填 API 引發爭議</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;8 月 9 日，知名翻譯插件「沉浸式翻譯」宣佈，注意到很多用户自行設置使用的大模型 API「並非源自正規渠道」，有許多屬於商家使用盜刷信用卡等非法方式購買，並自行搭建服務器轉售，翻譯體驗差且面臨斷流停用、維權困難的風險。&lt;/p&gt; 
&lt;p&gt;因此，決定之後僅支持在設置中填寫官方渠道、大型雲服務商或已認證第三方的 API（本地和局域網搭建的 API 不受影響）。 &amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-62b02bbacf9a32be29eb28a48071f89fd40.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該消息引發許多批評。當天晚上，沉浸式翻譯刪除了之前的公告並致歉，表示立即撤回所有關於限制第三方服務的計劃，永遠不會限制用户使用任何第三方翻譯服務。&lt;/p&gt; 
&lt;p&gt;&lt;img height="640" src="https://static.oschina.net/uploads/space/2025/0811/174011_EjiN_2720166.png" width="1276" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/174058_O2gg_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此外，將建立更加透明的決策機制，在重大功能調整前充分聽取社區意見。公告還承認，「作為一個成長中的團隊，我們在面對增長壓力時產生了焦慮，做出了偏離初心的決定」，請求用户給予改正的機會。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365558</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365558</guid>
      <pubDate>Sun, 10 Aug 2025 09:41:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>百度搜索 PC 端全面上線 AI 搜索功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;百度搜索 PC 端首頁全面上線一系列 AI 功能，這一升級將傳統的信息入口轉變為任務中樞。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;新上線的 「&lt;span&gt;超級&lt;/span&gt;智能雙行框」 讓用户能夠一鍵進行深度搜索，解答更復雜的問題，提升了用户的搜索體驗。此外，百度還推出了 「工作台」 模塊，其中集成了 AI 閲讀、AI 寫作和 AI PPT 三大工具，方便用户在日常工作和學習中使用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="217" src="https://oscimg.oschina.net/oscnet/up-6d9383c18ef0abf0fcbe406cd632ba34f0f.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在 AI 閲讀功能中，用户可以輕鬆一鍵總結鏈接、圖片及超大文檔，大大節省了閲讀和理解的時間。AI 寫作工具則提供了超過 20 種文風的選擇，同時支持劃線修改，幫助用户更好地進行創作和編輯。AI PPT 功能則能根據&lt;span&gt;全網&lt;/span&gt;內容自動生成演示文稿，極大地方便了用户的演示需求。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;根據 QuestMobile 發佈的《2025 年 AI 應用市場半年報》，百度 AI 搜索的月活躍用户已超過 3.22 億，穩居國內 AI 搜索行業的&lt;span&gt;第一&lt;/span&gt;名。此外，國際數據公司 IDC 也在同期報告中指出，百度 AI 搜索在中國通用型 AI 搜索類產品的綜合評分中位列&lt;span&gt;第一&lt;/span&gt;，其中用户數據和技術能力這兩項關鍵指標均名列前茅。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;用户在使用百度搜索時可以在 「智能模式」 和 「經典模式」 之間自由切換，只有在 「智能模式」 下才能直接使用相關的 AI 功能。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="215" src="https://oscimg.oschina.net/oscnet/up-4bec8aeb07ebade3a470534751c0319421e.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365557</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365557</guid>
      <pubDate>Sun, 10 Aug 2025 09:32:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Notte - 快速構建可靠的 Web 自動化代理</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;Notte 是一個用於構建和部署可靠的 Web AI 代理的平台，這些代理可以在任何網站上執行操作和數據抓取。Notte 提供你所需的一切，只需一個 API 即可實現大規模重複性工作流程的自動化。它能夠隱秘地管理雲瀏覽器會話、代理、安全憑證管理，並與生態系統中的 AI 工具無縫集成。&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#111827"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;主要特點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e4441"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一個用於安全、可擴展和智能 Web 自動化的全棧平台：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol style="margin-left:0; margin-right:0"&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/sessions"&gt;創建即時瀏覽器會話&lt;/a&gt;&lt;/strong&gt;。在雲端即時啓動和管理無頭瀏覽器。與 Playwright CDP 集成，管理 Cookie 和文件，重放會話並繞過驗證碼和機器人檢測。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/agents"&gt;運行自動代理&lt;/a&gt;&lt;/strong&gt;。LLM 驅動的代理可自動化任何 Web 工作流程。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/operations"&gt;掌控全局&lt;/a&gt;&lt;/strong&gt;：在網站上觀察、操作和抓取數據。對於需要比自主代理更精確控制的場景，為 LLM 代理提供了功能齊全的 Web 瀏覽器界面。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/vaults"&gt;保護你的憑證&lt;/a&gt;&lt;/strong&gt;。提供安全的保險庫和憑證管理系統，讓你可以安全地與 AI 代理共享身份驗證詳細信息。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#161c19"&gt;&lt;a href="https://docs.notte.cc/concepts/personas"&gt;為你的代理創建數字身份&lt;/a&gt;&lt;/strong&gt;。為你的代理創建和管理數字身份（姓名、郵箱、電話號碼）。使用它們進行自動入職和賬户創建。&lt;/li&gt;
&lt;/ol&gt;

&lt;p style="text-align:start"&gt;&lt;strong style="color:#1f2328"&gt;Opensource Core&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#using-python-sdk-recommended"&gt;運行網絡代理&lt;/a&gt;&lt;/strong&gt;→讓&amp;nbsp;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;AI agents&amp;nbsp;&lt;/span&gt;在網站上完成自然語言任務&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#structured-output"&gt;結構化輸出&lt;/a&gt;&lt;/strong&gt;→使用 Pydantic 模型獲取精確格式的數據&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#scraping"&gt;網站交互&lt;/a&gt;&lt;/strong&gt;→使用 Playwright 兼容原語和自然語言命令觀察網站狀態、抓取數據並執行操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;strong style="color:#1f2328"&gt;API service&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;（推薦）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#session-features"&gt;隱身瀏覽器會話&lt;/a&gt;&lt;/strong&gt;→具有內置 CAPTCHA 解決、代理和反檢測功能的瀏覽器實例&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#workflows"&gt;混合工作流程&lt;/a&gt;&lt;/strong&gt;→結合腳本和 AI agents 以降低成本並提高可靠性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#agent-vault"&gt;秘密保險庫&lt;/a&gt;&lt;/strong&gt;→企業級憑證管理，用於存儲電子郵件、密碼、MFA 令牌、SSO 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://github.com/nottelabs/notte#agent-persona"&gt;數字角色&lt;/a&gt;&lt;/strong&gt;→ 使用獨特的電子郵件、電話和自動化 2FA 創建數字身份，用於帳户創建工作流程&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/notte</link>
      <guid isPermaLink="false">https://www.oschina.net/p/notte</guid>
      <pubDate>Sun, 10 Aug 2025 09:11:00 GMT</pubDate>
    </item>
    <item>
      <title>Hugging Face 發佈 AI Sheets，使用 AI 模型處理數據集的開源工具</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Hugging Face 近日發佈了一款開源工具&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fblog%2Faisheets"&gt;AI Sheets&lt;/a&gt;，旨在讓用户無需編寫代碼，&lt;strong&gt;就能在類似電子表格的界面中使用 AI 模型構建、豐富和轉換數據集&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;開源地址：https://github.com/huggingface/aisheets&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;簡單來説，AI Sheets 就像是 Excel 和 Google Sheets 的 AI 增強版，但它專為數據科學家和開發者設計，能夠直接調用各種 AI 模型來處理表格數據。無論你是需要對文本進行分類、生成新內容，還是進行數據清洗，AI Sheets 都能幫你輕鬆完成。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4abcb51433832c7c0ffa60b4023092a2363.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AI Sheets&amp;nbsp;允許用户通過&amp;nbsp;Hugging Face&amp;nbsp;的&amp;nbsp;Inference Providers&amp;nbsp;調用數千個開源模型，更重要的是，它支持連接到自定義和本地運行的&amp;nbsp;LLM。&lt;/p&gt; 
&lt;p&gt;用户只需確保其本地&amp;nbsp;LLM&amp;nbsp;支持&amp;nbsp;OpenAI API&amp;nbsp;規範即可，例如通過&amp;nbsp;Ollama&amp;nbsp;等工具部署的模型。該工具現已在&amp;nbsp;GitHub&amp;nbsp;上開源，並提供了一個公開的&amp;nbsp;Hugging Face Space&amp;nbsp;供用户即時體驗。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-29bed047aa33f64f8907fed342f6dc3fcb5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-73e30d3cb9a97c73489b118e9588ef6202b.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365544</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365544</guid>
      <pubDate>Sun, 10 Aug 2025 09:02:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>百川智能開源醫療增強大模型 Baichuan-M2</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;百川智能&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FVL2OWORdVDXkenXJ-Jw9Bg" target="_blank"&gt;宣佈&lt;/a&gt;正式開源醫療增強大模型 Baichuan-M2。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;針對醫療領域用户隱私考慮下的模型私有化部署需求，項目團隊對 Baichuan-M2 進行了極致輕量化，量化後的模型精度接近無損，可以在 RTX4090 上單卡部署，相比 DeepSeek-R1 H20 雙節點部署的方式，成本降低了 57 倍。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="263" src="https://oscimg.oschina.net/oscnet/up-74f868bc87127aa7dcb021b6b00dc67c8f0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;面向急診、門診等對於交互速度要求更高的場景，基於 Eagle-3 架構優化的 Baichuan-M2-Spec 版本在單用户場景下實現了 74.9% 的 token 速度躍升。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="249" src="https://oscimg.oschina.net/oscnet/up-d1adb36553288603ffa34ee4169a2800c92.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此外，M2 模型在數學、指令遵循、寫作等通用核心性能上不降反升，因此這個模型也可應用於醫療以外的其他領域。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="250" src="https://oscimg.oschina.net/oscnet/up-f35b08150804a24bf611bbbecb6487fd7b5.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;測評結果表明，Baichuan-M2 在 HealthBench 上得到 60.1 的高分，以 32B 的較小尺寸不僅反超 OpenAI 最新開源模型 gpt-oss120b（得分 57.6），更是力壓 Qwen3-235B、Deepseek R1、Kimi K2 等當前世界所有開源大模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在 HealthBench Hard 評測中，Baichuan-M2 以 34.7 分成為全球第二款超過 32 分的模型，力壓世界所有其他頂尖閉源大模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img alt="" height="413" src="https://oscimg.oschina.net/oscnet/up-1ce0b342e6ea9e33c918ce1f538296d76ed.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="444" src="https://oscimg.oschina.net/oscnet/up-8aa101f0b49a7b587d21048af4a2a44dd2c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;公告稱，儘管真實醫療場景中還存在大量 HealthBench Hard 評測尚未包含的因素，但至少已經證明在多數醫療場景上的問答質量，GPT-5 和 Baichuan-M2 已經超越資深醫生，特別是在知識更新速度和全面性上，完全可以給人類醫生強大支持。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365539</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365539</guid>
      <pubDate>Sun, 10 Aug 2025 08:41:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通義 Qwen3 開源系列模型支持 100 萬 token 超長上下文</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;阿里通義 Qwen 團隊&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FAlibaba_Qwen%2Fstatus%2F1953760230141309354" target="_blank"&gt;宣佈&lt;/a&gt;，Qwen3-30B-A3B-2507&amp;nbsp;和&amp;nbsp;Qwen3-235B-A22B-2507&amp;nbsp;系列模型現已支持高達 100 萬 token 的超長上下文處理。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0811/163327_evaS_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;此次升級集成了兩項關鍵技術：Dual Chunk Attention (DCA)&amp;nbsp;和&amp;nbsp;MInference。&lt;/p&gt; 
&lt;p&gt;DCA&amp;nbsp;是一種長度外推方法，能將長序列分割成可管理的小塊同時保持全局連貫性；MInference&amp;nbsp;則是一種稀疏注意力機制，通過聚焦關鍵 token 交互來降低計算開銷。這些技術結合，使得模型在處理接近 100 萬 token 的序列時，推理速度相比標準注意力實現可提升高達 3 倍。用户可以通過更新模型倉庫中的&amp;nbsp;config.json&amp;nbsp;文件為&amp;nbsp;config_1m.json&amp;nbsp;來啓用此功能。&lt;/p&gt; 
&lt;p&gt;官方指出，要有效處理 100 萬 token 的上下文，用户將需要大約 1000GB 的總 GPU 顯存。新版本與&amp;nbsp;vLLM&amp;nbsp;和&amp;nbsp;SGLang&amp;nbsp;完全兼容，便於高效部署。在 1M 版本的&amp;nbsp;RULER&amp;nbsp;基準測試中，更新後的模型在不同長度的上下文處理上均表現出優異的性能。&lt;/p&gt; 
&lt;p&gt;&lt;br&gt; https://huggingface.co/Qwen/Qwen3-235B-A22B-Instruct-2507&lt;br&gt; https://huggingface.co/Qwen/Qwen3-30B-A3B-Instruct-2507&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365537</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365537</guid>
      <pubDate>Sun, 10 Aug 2025 08:34:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里通義發佈 Wan2.2-I2V-Flash 圖生視頻模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里通義大模型&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FzsBYkzC3J9-jgEf5YNmUww" target="_blank"&gt;宣佈&lt;/a&gt;推出其最新圖生視頻模型 Wan2.2-12V-Flash。「它不僅將電影級視覺呈現裝進模型，更在生成速度與性價比上實現全面躍升，致力於為用户帶來更快速、更專業、更穩定的圖生視頻體驗。」&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;相比 Wan2.1，Wan2.2-I2V-Flash 推理速度提升 12 倍，創作效率躍升。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;指令遵循能力大幅提升：各種特效提示詞直出，運鏡精準控制，指令落地更精準。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;風格化圖像穩定輸出：對各類風格化圖像均能穩定保持風格，並實現合理自然的動態效果。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="402" src="https://oscimg.oschina.net/oscnet/up-ee043f3ae5d17893e38134bd39a2eee008e.png" width="300" referrerpolicy="no-referrer"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365535</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365535</guid>
      <pubDate>Sun, 10 Aug 2025 08:28:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>北京人形發佈具身世界模型體系</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;北京人形宣佈&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FX_jBihaFuIb5G_CoPD_yEA" target="_blank"&gt;發佈&lt;/a&gt;了四項具身智能核心成果，包括：具身世界模型體系，打通認知與預判能力；跨本體 VLA 模型，實現跨本體、多場景、多技能的通用性；人形機器人全身控制自主導航系統，解決移動與操作協同的執行瓶頸；以及千台機器人真實場景數據採集計劃，為持續進化提供規模化數據燃料。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其中，「具身世界模型體系」旨在為機器人理解現實與預測變化提供核心大腦。這一體系包含具備物理時空理解與推理能力的 72B 具身多模態大模型以及實現神經網絡驅動世界模擬器的具身智能世界基座模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;針對通用大模型具身場景下精細空間/幾何理解不足，物理交互誤差大等問題，北京人形基於千問 72B 多模態大模型，通過自研數據清洗與混合模態訓練框架，實現行業首個長視頻理解 72B 具身多模態大模型 PelicanVLM，在現代多模態系統超長視頻語言理解評測集 Egoschema、李飛飛的視覺空間智能基準評測集 VSI-Bench，多模態大模型物理推理能力大規模基準測試集 PhyX 等 6 項具身相關公開評測集上超越 GPT-4o、Gemini flash 2.0 以及原模型，7 個公開評測基準平均性能超過 SOTA 11%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;基於超過 5000 小時視頻數據訓練的具身世界模型 WU，則為具身智能機器人提供了「看見未來」的眼睛，並以未見場景下的泛化能力，解鎖具身無限數據的可能性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-b1a6e72be028a347ae72f70a87255cc4178.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「跨本體 VLA 模型」成為通用性和擴展性的關鍵支撐。北京人形正式發佈跨本體 VLA 模型 XR-1，讓同一模型實現跨本體運行、多場景適配、多技能調用。在業界充分驗證的 RoboMIND 高質量具身數據基礎上，XR-1 通過積累超百萬量級的自有多本體數據，採用首創的多模態視動統一表徵學習，有效利用各類機器人操作數據和海量互聯網視頻數據。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在此基礎上，XR-1 利用多模態視動統一表徵訓練、跨本體主網絡訓練和特定場景微調三階段訓練範式，實現機器人跨本體的通用操作知識積累和特定場景的多任務快速學習。在多種機器人本體上大量真實環境測試，實證了該方法的多本體、多技能、多任務、穩健泛化能力，以及其在快速掌握新技能上的巨大潛力。以 XR-1 為基礎，「慧思開物」能夠快速構建面向各類場景任務的通用技能庫，實現多本體、多場景、多任務的能力，顯著減少具身智能應用開發的成本與用時。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「人形機器人全身控制自主導航系統」聚焦機器人在實際工作中的核心能力，由「自主導航系統」和「全身控制系統」組成。自主導航系統具備點對點導航、動態障礙感知和自主避障能力，並搭載 OCC 環視感知模塊，實現對環境的實時佔用與語義感知，拓展了自主與語義導航的應用空間。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;全身控制系統支持機器人在移動和站立狀態下靈活進行上身動作控制，涵蓋預設動作、遙操作與自主操作開發。通過穩定的質心控制與精準的末端控制，保障操作任務的穩定高效執行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「千台機器人真實場景數據採集計劃」是業內首個千台級規模的真實場景數據採集計劃，通過搭建遠程遙操作中心，讓千台機器人走出實驗室，深入工廠車間、物流倉儲、酒店商超等真實工業場景，在執行實際作業任務的同時，持續採集多模態交互數據。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365527</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365527</guid>
      <pubDate>Sun, 10 Aug 2025 08:07:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>緩存之美：萬文詳解 Caffeine 實現原理（上）</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;文章將採用「總-分-總」的結構對配置固定大小元素驅逐策略的 Caffeine 緩存進行介紹，首先會講解它的實現原理，在大家對它有一個概念之後再深入具體源碼的細節之中，理解它的設計理念，從中能學習到用於統計元素訪問頻率的 Count-Min Sketch 數據結構、理解內存屏障和如何避免緩存偽共享問題、MPSC 多線程設計模式、高性能緩存的設計思想和多線程間的協調方案等等，文章最後會對全文內容進行總結，希望大家能有所收穫的同時在未來對本地緩存選型時提供完整的理論依據。&lt;/p&gt; 
&lt;p&gt;Caffeine 緩存原理圖如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine-第 5 頁.drawio.png" src="https://oscimg.oschina.net/oscnet//b6ecb4c848ed275752576f246ed15bec.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;它使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 保存數據，並在該數據結構的基礎上創建了窗口區、試用區和保護區，用於管理元素的生命週期，各個區的數據結構是使用了 LRU 算法的雙端隊列，隨着緩存的命中率變化，窗口區和保護區大小會自動調節以適應當前訪問模式。在對元素進行驅逐時，使用了 TinyLFU 算法，會優先將頻率低的元素驅逐，訪問頻率使用 Count-Min Sketch 數據結構記錄，它能在保證較高準確率（93.75%）的情況下佔用較少內存空間。讀、寫操作分別會向 &lt;code&gt;ReadBuffer&lt;/code&gt; 和 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加「讀/寫後任務」，這兩個緩衝區的設計均採用了 MPSC 多生產者單消費者的多線程設計模式。緩衝區中任務的消費由維護方法 &lt;code&gt;maintenance&lt;/code&gt; 中 &lt;code&gt;drainReadBuffer&lt;/code&gt; 和 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 實現，維護方法通過添加同步鎖，保證任務只由單線程執行，這種設計參考了 WAL（Write-Ahead Logging）思想，即：先寫日誌，再執行操作，先把操作記錄在緩衝區，然後在合適的時機異步、批量地執行緩衝區中的任務。維護方法除了這些作用外，還負責元素在各個分區的移動、頻率的更新、元素的驅逐等操作。&lt;/p&gt; 
&lt;p&gt;接下來的源碼分析以如下測試用例為例：先分析構造方法，瞭解緩存初始化過程中創建的重要數據結構和關鍵字段，然後再深入添加元素的方法（put），該方法相對複雜，也是 Caffeine 緩存的核心，理解了這部分內容，文章剩餘的內容理解起來會非常容易，接着分析獲取元素的方法（getIfPresent），最後再回到核心的維護方法 &lt;code&gt;maintenance&lt;/code&gt; 中，這樣便基本理解了 Caffeine 緩存的運行原理，需要注意的是，因為我們並未指定緩存元素的過期時間，所以與此相關的內容如時間過期策略和時間輪等內容不會專門介紹。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestReadSourceCode&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;@Test&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// read constructor&lt;/span&gt;
        &lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;.&lt;/span&gt;&lt;span&gt;maximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;10_000&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;.&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// read put&lt;/span&gt;
        cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"key"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"value"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// read get&lt;/span&gt;
        cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"key"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
&lt;h3&gt;constructor&lt;/h3&gt; 
&lt;p&gt;Caffeine 的實現類區分了 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt; 和 &lt;code&gt;UnboundedLocalManualCache&lt;/code&gt;，見名知意它們分別為「有邊界」的和「無邊界」的緩存。&lt;code&gt;Caffeine#isBounded&lt;/code&gt; 方法詮釋了「邊界」的含義：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1 &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; V1 &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;build&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 校驗參數&lt;/span&gt;
        &lt;span&gt;requireWeightWithWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonLoadingCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;K1&lt;span&gt;,&lt;/span&gt; V1&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;isBounded&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;?&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;span&gt;.&lt;/span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;:&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;UnboundedLocalCache&lt;span&gt;.&lt;/span&gt;UnboundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBounded&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 指定了最大大小；指定了最大權重&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumWeight &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;// 指定了訪問後過期策略；指定了寫後過期策略&lt;/span&gt;
                &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expireAfterAccessNanos &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expireAfterWriteNanos &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;UNSET_INT&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;// 指定了自定義過期策略；指定了 key 或 value 的引用級別&lt;/span&gt;
                &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expiry &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;keyStrength &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;valueStrength &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;也就是説，當為緩存指定了上述的驅逐或過期策略會定義為有邊界的 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt; 緩存，它會限制緩存的大小，防止內存溢出，否則為無邊界的 &lt;code&gt;UnboundedLocalManualCache&lt;/code&gt; 類型，它沒有大小限制，直到內存耗盡。我們以創建配置了固定大小的緩存為例，它對應的類型便是 &lt;code&gt;BoundedLocalManualCache&lt;/code&gt;，在執行構造方法時，有以下邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt;
        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// ...&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalManualCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Serializable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;BoundedLocalManualCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;CacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; loader&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            cache &lt;span&gt;=&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newBoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; loader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* async */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BoundedLocalCache&lt;/code&gt; 為抽象類，緩存對象的實際類型都是它的子類。它在創建時使用了反射並遵循簡單工廠的編碼風格：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;newBoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt;
                                                               &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; async&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; factory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;loadFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; factory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newInstance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; async&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; e&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;getClassName&lt;/code&gt; 方法非常有意思，它會根據緩存配置的屬性動態拼接出實際緩存類名：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StringBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// key 是強引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// value 是強引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'I'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了移除監聽器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;removalListener &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'L'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了統計功能&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isRecordingStats&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 不同的驅逐策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 基於最大值限制，可能是最大權重 W，也可能是最大容量 S&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'M'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 基於權重或非權重&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了訪問過期或可變過期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了寫入過期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了刷新策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'R'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;這也就是為什麼能在 &lt;code&gt;com.github.benmanes.caffeine.cache&lt;/code&gt; 包路徑下能發現很多類似 &lt;code&gt;SSMS&lt;/code&gt; 只有簡稱命名的類的原因（下圖只截取部分，實際上有很多）：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="SSMS.png" src="https://oscimg.oschina.net/oscnet//e90933fffda7963aca2f9e451cff165e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據代碼邏輯，它的命名遵循如下格式 &lt;code&gt;S|W S|I [L] [S] [MW|MS] [A] [W] [R]&lt;/code&gt; 其中 &lt;code&gt;[]&lt;/code&gt; 表示選填，&lt;code&gt;|&lt;/code&gt; 表示某配置不同選擇的分隔符，結合註釋能清楚的瞭解各個位置字母簡稱表達的含義。如此定義實現類使用了 &lt;strong&gt;多級繼承&lt;/strong&gt;，儘可能多地複用代碼。&lt;/p&gt; 
&lt;p&gt;以我們測試用例中創建的緩存類型為例，它對應的實現類為 &lt;code&gt;SSMS&lt;/code&gt;，表示 key 和 value 均為強引用，並配置了非權重的最大緩存大小限制，類圖關係如下：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="SSMS.drawio.png" src="https://oscimg.oschina.net/oscnet//ac900e4f348d7fa8c3f55d1442e17b2e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;雖然在一些軟件設計相關的書籍中強調「多用組合，少用繼承」，但是這裏使用多級繼承我覺得並沒有增加開發者的理解難度，反而瞭解了它的命名規則後，能更清晰的理解各個緩存所表示的含義，更好地實現代碼複用。&lt;/p&gt; 
&lt;p&gt;執行 &lt;code&gt;SSMS&lt;/code&gt; 的構造方法會有以下邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 1&lt;/span&gt;
&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt;
        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;PERCENT_MAIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.99d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;PERCENT_MAIN_PROTECTED&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.80d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;HILL_CLIMBER_STEP_PERCENT&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0.0625d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;RemovalListener&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; evictionListener&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; drainBuffersTask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Consumer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessPolicy&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; readBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodeFactory&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; weigher&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; executor&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isWeighted&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt;
                                &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cacheLoader&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 標記同步或異步&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;isAsync &lt;span&gt;=&lt;/span&gt; isAsync&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 指定 cacheLoader &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;cacheLoader &lt;span&gt;=&lt;/span&gt; cacheLoader&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 指定用於執行驅逐元素、刷新緩存等任務的線程池，不指定默認為 ForkJoinPool.commonPool()&lt;/span&gt;
        executor &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getExecutor&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 標記是否定義了節點計算權重的 Weigher 對象&lt;/span&gt;
        isWeighted &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 同步鎖，在接下來的內容中會看到很多標記了 @GuardedBy("evictionLock") 註解的方法，表示這行這些方法時都會獲取這把同步鎖&lt;/span&gt;
        &lt;span&gt;// 根據該鎖的命名，eviction 表示驅逐的意思，也就是説關注驅逐策略執行的方法都要獲取該鎖，這一點需要在後文中注意&lt;/span&gt;
        evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算元素權重的對象，不指定為 SingletonWeigher.INSTANCE&lt;/span&gt;
        weigher &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 執行緩存 maintenance 方法的任務，在後文中具體介紹&lt;/span&gt;
        drainBuffersTask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 創建節點的工廠&lt;/span&gt;
        nodeFactory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 驅逐監聽器，有元素被驅逐時會回調&lt;/span&gt;
        evictionListener &lt;span&gt;=&lt;/span&gt; builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getEvictionListener&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 用於保存所有數據的 ConcurrentHashMap&lt;/span&gt;
        data &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果指定驅逐策略，或 key 為弱引用，或 value 為弱引用或軟引用，或 訪問後過期則創建 readBuffer，否則它為不可用狀態&lt;/span&gt;
        &lt;span&gt;// readBuffer 用於記錄某些被訪問過的節點&lt;/span&gt;
        readBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;collectKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;collectValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                &lt;span&gt;?&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;BoundedBuffer&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;disabled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果指定了驅逐策略，或 訪問後過期策略則會定義訪問策略，執行 onAccess 方法，後文詳細介紹&lt;/span&gt;
        accessPolicy &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;onAccess&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; e &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 初始化最大值和最小值的雙端隊列作為 writeBuffer，用於記錄一些寫後操作任務 &lt;/span&gt;
        writeBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 執行了驅逐策略則更新最大容量限制&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;setMaximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setMaximumSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireArgument&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"maximum must not be negative"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;==&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 不能超過最大容量&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; max &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum&lt;span&gt;,&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算窗口區大小&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; window &lt;span&gt;=&lt;/span&gt; max &lt;span&gt;-&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PERCENT_MAIN&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算保護區大小&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mainProtected &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;PERCENT_MAIN_PROTECTED&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;max &lt;span&gt;-&lt;/span&gt; window&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 記錄這些值&lt;/span&gt;
        &lt;span&gt;setMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setWindowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;window&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setMainProtectedMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mainProtected&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 標記命中量、非命中量並初始化步長值，這三個值用於後續動態調整保護區和窗口區大小&lt;/span&gt;
        &lt;span&gt;setHitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setMissesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;setStepSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;HILL_CLIMBER_STEP_PERCENT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 直到當前緩存的權重（大小）接近最大值一半時才初始化頻率草圖&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;max &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;max&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 2&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;LocalCacheFactory&lt;/span&gt; &lt;span&gt;FACTORY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;::&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// key value 強引用無需特殊操作&lt;/span&gt;
    &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var1&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;,&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;// 3&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SSMS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SS&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 頻率草圖，後文具體介紹&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; sketch &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderWindowDeque&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderProbationDeque&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; accessOrderProtectedDeque&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;SSMS&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var1&lt;span&gt;,&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;AsyncCacheLoader&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt; &lt;span&gt;super&lt;/span&gt; &lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;,&lt;/span&gt; var2&lt;span&gt;,&lt;/span&gt; var3&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果 Caffeine 初始化了容量則確定頻率草圖的容量&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; var4 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getInitialCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;sketch&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;var4&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化窗口區、試用區和保護區，它們都是雙端隊列（鏈表實現）&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderWindowDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;var1&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderProbationDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;accessOrderProtectedDeque &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;AccessOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;在步驟 1 中定義了三個區的初始化大小為 1%|19%|80%，這樣配置的性能相對較好。此外，我們還需要解釋一下 &lt;code&gt;weightedSize()&lt;/code&gt; 方法，它用於訪問 &lt;code&gt;long weightedSize&lt;/code&gt; 變量。根據其命名有「權重大小」的含義，在默認不指定權重計算對象 &lt;code&gt;Weigher&lt;/code&gt; 的情況下，&lt;code&gt;Weigher&lt;/code&gt; 默認為 &lt;code&gt;SingletonWeigher.INSTANCE&lt;/code&gt; 表示每個元素的權重大小為 1，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;SingletonWeigher&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;INSTANCE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;這樣 &lt;code&gt;weightedSize&lt;/code&gt; 表示的便是當前緩存中元素數量。如果自定義了 &lt;code&gt;Weigher&lt;/code&gt; 那麼 &lt;code&gt;weightedSize&lt;/code&gt; 表示的便是緩存中總權重大小，每個元素的權重則可能會不同。因為在示例中我們並沒有指定 &lt;code&gt;Weigher&lt;/code&gt;，所以在此處可以將 &lt;code&gt;weightedSize&lt;/code&gt; 理解為當前緩存大小。&lt;/p&gt; 
&lt;p&gt;上文中我們提到緩存的定義遵循大寫字母縮寫的命名規則，實際上節點類的定義也採用了這種方式，在創建節點工廠 &lt;code&gt;NodeFactory.newFactory(builder, isAsync)&lt;/code&gt;&lt;br&gt; 的邏輯中，它會執行如下邏輯，根據緩存的類型來確定它的節點類型，命名遵循 &lt;code&gt;P|F S|W|D A|AW|W| [R] [MW|MS]&lt;/code&gt; 的規則，同樣使用了反射機制和簡單工廠的編碼風格，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// ...&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;newFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;interner&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Interned&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;FACTORY&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;,&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;loadFactory&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;className&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;getClassName&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; builder&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAsync&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; className &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StringBuilder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// key 強引用或弱引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongKeys&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'P'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'F'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// value 強引用或弱引用或軟引用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isStrongValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeakValues&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'D'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 過期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 訪問後過期&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 寫入後過期&lt;/span&gt;
                    className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 訪問後過期&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'A'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 寫入後過期&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 寫入後刷新&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;refreshAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'R'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 驅逐策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 默認最大大小限制&lt;/span&gt;
            className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'M'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 加權&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;isAsync &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;builder&lt;span&gt;.&lt;/span&gt;weigher &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;Weigher&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;singletonWeigher&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'W'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 非加權&lt;/span&gt;
                className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'S'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; className&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toString&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;SSMS&lt;/code&gt; 類型緩存對應的節點類型為 &lt;code&gt;PSMS&lt;/code&gt;。&lt;/p&gt; 
&lt;span id="OSC_h4_2"&gt;&lt;/span&gt; 
&lt;h4&gt;FrequencySketch&lt;/h4&gt; 
&lt;p&gt;接下來，我們需要具體介紹下 &lt;code&gt;FrequencySketch&lt;/code&gt;，它在上述構造方法的步驟 3 中被創建。這個類的實現採用了 &lt;strong&gt;Count-Min Sketch&lt;/strong&gt; 數據結構，它維護了一個 &lt;code&gt;long[] table&lt;/code&gt; 一維數組，每個元素有 64 位，每 4 位作為一個計數器（這也就限定了最大頻率為 15），那麼數組中每個槽位便是 16 個計數器。通過哈希函數取 4 個獨立的計數值，將其中的最小值作為元素的訪問頻率。&lt;code&gt;table&lt;/code&gt; 的初始大小為緩存最大容量最接近的 2 的 n 次冪，並在計算哈希值時使用 &lt;code&gt;blockMask&lt;/code&gt; 掩碼來使哈希結果均勻分佈，保證了獲取元素訪問頻率的正確率為 93.75%，達到空間與時間的平衡。它的實現原理和布隆過濾器類似，犧牲了部分準確性，但減少了佔用內存的大小。如下圖所示為計算元素 e 的訪問頻率：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="frequencySketch.drawio.png" src="https://oscimg.oschina.net/oscnet//0d20ca462980453af15f3e687ed9a674.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下為 &lt;code&gt;FrequencySketch&lt;/code&gt; 的源碼，關注註釋即可，並不複雜：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;RESET_MASK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;x7777777777777777L&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;ONE_MASK&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;x1111111111111111L&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 採樣大小，用於控制 reset&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sampleSize&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 掩碼，用於均勻分散哈希結果&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; blockMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; table&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;FrequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@NonNegative&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maximumSize&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireArgument&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 取緩存最大容量和 Integer.MAX_VALUE &amp;gt;&amp;gt;&amp;gt; 1 中的小值 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; maximum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximumSize&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果已經被初始化過並且 table 長度大於等於最大容量，那麼不進行操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;&amp;gt;=&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化 table，長度為最接近 maximum 的 2 的 n 次冪，和 8 中的大值&lt;/span&gt;
        table &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;max&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Caffeine&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算採樣大小&lt;/span&gt;
        sampleSize &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximumSize &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; maximum&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算掩碼&lt;/span&gt;
        blockMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 特殊判斷&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;sampleSize &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            sampleSize &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 計數器總數&lt;/span&gt;
        size &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@NonNegative&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;frequency&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果緩存沒有被初始化則返回頻率為 0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isNotInitialized&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 創建 4 個元素的數組 count 用於保存 4 次 hash 計算出的頻率值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; count &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// hash 擾動，使結果均勻分佈&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; blockHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 重 hash，進一步分散結果&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; counterHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;blockHash&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 根據掩碼計算對應的塊索引&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; block &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;blockHash &lt;span&gt;&amp;amp;&lt;/span&gt; blockMask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 循環 4 次計算 4 個計數器的結果&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 位運算變更 hash 值&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; counterHash &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;h &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 計算計數器的偏移量&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; h &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 定位到 table 中某個槽位後右移並進行位與運算得到最低的 4 位的值（0xfL 為二進制的 1111）&lt;/span&gt;
            count&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;block &lt;span&gt;+&lt;/span&gt; offset &lt;span&gt;+&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;xfL&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 取其中的較小值&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; count&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isNotInitialized&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 長度為 8 的數組記錄該元素對應的位置，每個計數器需要兩個值來定位&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; blockHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;e&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; counterHash &lt;span&gt;=&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;blockHash&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; block &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;blockHash &lt;span&gt;&amp;amp;&lt;/span&gt; blockMask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; h &lt;span&gt;=&lt;/span&gt; counterHash &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// i 記錄定位到 table 中某元素的位偏移量&lt;/span&gt;
            index&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;h &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; h &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// i + 4 記錄元素所在 table 中的索引&lt;/span&gt;
            index&lt;span&gt;[&lt;/span&gt;i &lt;span&gt;+&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; block &lt;span&gt;+&lt;/span&gt; offset &lt;span&gt;+&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;i &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 四個對應的計數器都需要累加&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; added &lt;span&gt;=&lt;/span&gt;
                &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 累加成功且達到採樣大小需要進行重置&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;added &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;size &lt;span&gt;==&lt;/span&gt; sampleSize&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;incrementAt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; j &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;xfL &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;1L&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 重置機制防止計數器溢出&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; count &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; table&lt;span&gt;.&lt;/span&gt;length&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 累加 table 中每個元素的 2 進製表示的 1 的個數，結果為計數器個數的 4 倍&lt;/span&gt;
            count &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;bitCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;ONE_MASK&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 右移一位將計數值減半並將高位清零&lt;/span&gt;
            table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;table&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;RESET_MASK&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// count &amp;gt;&amp;gt;&amp;gt; 2 表示計數器個數，計算重置後的 size&lt;/span&gt;
        size &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;size &lt;span&gt;-&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;count &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0xed5ad4bb&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0xac4c1b51&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; x&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        x &lt;span&gt;*=&lt;/span&gt; &lt;span&gt;0x31848bab&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        x &lt;span&gt;^=&lt;/span&gt; x &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; x&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;到這裏，&lt;code&gt;Caffeine&lt;/code&gt; 緩存的基本數據結構全貌已經展現出來了，如下所示，在後文中我們再具體關注它們之間是如何協同的。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine.drawio.png" src="https://oscimg.oschina.net/oscnet//5408b3b6611371ddb67daf2bd23bed08.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_3"&gt;&lt;/span&gt; 
&lt;h3&gt;put&lt;/h3&gt; 
&lt;p&gt;接下來繼續瞭解向緩存中添加元素的流程，本節內容比較多，理解起來也相對複雜，結合文章內容的同時，也需要多去深入查看 Caffeine 源碼才能有更好的理解，以下為 &lt;code&gt;put&lt;/code&gt; 方法的源碼：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 默認入參 onlyIfAbsent 為 false，表示向緩存中添加相同的 key 會對 value 進行替換 &lt;/span&gt;
    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* onlyIfAbsent */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;它會執行到如下具體邏輯中，關注註釋信息：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;NodeFactory&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodeFactory&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Nullable&lt;/span&gt;
    &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Expiry&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 不允許添加 null&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 獲取當前時間戳&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; now &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 計算緩存權重，如果沒有指定 weigher 的話，默認權重為 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newWeight &lt;span&gt;=&lt;/span&gt; weigher&lt;span&gt;.&lt;/span&gt;&lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 創建用於查找的鍵對象&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; lookupKey &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newLookupKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; attempts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; attempts&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 嘗試獲取節點；prior 譯為先前的；較早的&lt;/span&gt;
            &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 處理不存在的節點&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 如果 node 在循環執行中還未被創建&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// NodeFactory 創建對應類型節點&lt;/span&gt;
                    node &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newNode&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;keyReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;valueReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; newWeight&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 設置節點的過期時間&lt;/span&gt;
                    &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expireAfterCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 嘗試添加新節點到緩存中，如果鍵已存在則返回現有節點&lt;/span&gt;
                prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;putIfAbsent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 返回 null 表示插入成功&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 寫後操作：添加 AddTask 並調度執行任務&lt;/span&gt;
                    &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;AddTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; newWeight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// onlyIfAbsent 形參在默認的 put 方法中為 false，以下邏輯簡單介紹&lt;/span&gt;
                &lt;span&gt;// 如果此時有其他線程添加了相同 key 的元素&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 獲取到當前值，嘗試判斷讀後失效策略，更新訪問時間，並執行讀後操作 afterRead 方法&lt;/span&gt;
                    &lt;span&gt;V&lt;/span&gt; currentValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;currentValue &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                            &lt;span&gt;tryExpireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; currentValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                            &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;}&lt;/span&gt;
                        &lt;span&gt;// 讀後操作，該方法在 getIfPresent 中進行講解&lt;/span&gt;
                        &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; currentValue&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 同樣的邏輯&lt;/span&gt;
                &lt;span&gt;V&lt;/span&gt; currentValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;currentValue &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;tryExpireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; currentValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; currentValue&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意添加節點成功的邏輯，它會執行 &lt;code&gt;afterWrite&lt;/code&gt; 寫後操作方法，添加 &lt;code&gt;AddTask&lt;/code&gt; 任務到 &lt;code&gt;writeBuffer&lt;/code&gt; 中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 寫重試最多 100 次&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;WRITE_BUFFER_MIN&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// 添加寫後 Task 到 writeBuffer 中並在合適的時機調度執行任務&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 最多重試添加 100 次&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 寫後調度&lt;/span&gt;
                &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 向 writeBuffer 中添加任務失敗會調度任務執行&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 自旋等待，讓出 CPU 控制權&lt;/span&gt;
            &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;writeBuffer&lt;/code&gt; 的類型為 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt;，在這裏我們詳細的介紹下它。&lt;/p&gt; 
&lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
&lt;h4&gt;WriteBuffer&lt;/h4&gt; 
&lt;p&gt;根據它的命名 &lt;strong&gt;GrowableArrayQueue&lt;/strong&gt; 可知它是一個容量可以增長的雙端隊列，前綴 &lt;strong&gt;MPSC&lt;/strong&gt; 表達的含義是「多生產者，單消費者」，也就是説可以有多個線程向其中添加元素，但只有一個線程能從其中獲取元素。那麼它是如何實現 &lt;strong&gt;MPSC&lt;/strong&gt; 的呢？接下來我們就根據源碼詳細瞭解一下。首先先來看一下它的類繼承關係圖及簡要説明：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="WriteBuffer.drawio.png" src="https://oscimg.oschina.net/oscnet//9c4c7ac6929306032ede02853ad2e105.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;圖中灰色的表示抽象類，藍色為實現類，&lt;code&gt;java.util.AbstractQueue&lt;/code&gt; 就不再多解釋了。我們先看看其中標記紅框的類，討論到底什麼是「避免內存偽共享問題」？&lt;/p&gt; 
&lt;p&gt;以 &lt;code&gt;BaseMpscLinkedArrayQueuePad1&lt;/code&gt; 為例：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p000&lt;span&gt;,&lt;/span&gt; p001&lt;span&gt;,&lt;/span&gt; p002&lt;span&gt;,&lt;/span&gt; p003&lt;span&gt;,&lt;/span&gt; p004&lt;span&gt;,&lt;/span&gt; p005&lt;span&gt;,&lt;/span&gt; p006&lt;span&gt;,&lt;/span&gt; p007&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p008&lt;span&gt;,&lt;/span&gt; p009&lt;span&gt;,&lt;/span&gt; p010&lt;span&gt;,&lt;/span&gt; p011&lt;span&gt;,&lt;/span&gt; p012&lt;span&gt;,&lt;/span&gt; p013&lt;span&gt;,&lt;/span&gt; p014&lt;span&gt;,&lt;/span&gt; p015&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p016&lt;span&gt;,&lt;/span&gt; p017&lt;span&gt;,&lt;/span&gt; p018&lt;span&gt;,&lt;/span&gt; p019&lt;span&gt;,&lt;/span&gt; p020&lt;span&gt;,&lt;/span&gt; p021&lt;span&gt;,&lt;/span&gt; p022&lt;span&gt;,&lt;/span&gt; p023&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p024&lt;span&gt;,&lt;/span&gt; p025&lt;span&gt;,&lt;/span&gt; p026&lt;span&gt;,&lt;/span&gt; p027&lt;span&gt;,&lt;/span&gt; p028&lt;span&gt;,&lt;/span&gt; p029&lt;span&gt;,&lt;/span&gt; p030&lt;span&gt;,&lt;/span&gt; p031&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p032&lt;span&gt;,&lt;/span&gt; p033&lt;span&gt;,&lt;/span&gt; p034&lt;span&gt;,&lt;/span&gt; p035&lt;span&gt;,&lt;/span&gt; p036&lt;span&gt;,&lt;/span&gt; p037&lt;span&gt;,&lt;/span&gt; p038&lt;span&gt;,&lt;/span&gt; p039&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p040&lt;span&gt;,&lt;/span&gt; p041&lt;span&gt;,&lt;/span&gt; p042&lt;span&gt;,&lt;/span&gt; p043&lt;span&gt;,&lt;/span&gt; p044&lt;span&gt;,&lt;/span&gt; p045&lt;span&gt;,&lt;/span&gt; p046&lt;span&gt;,&lt;/span&gt; p047&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p048&lt;span&gt;,&lt;/span&gt; p049&lt;span&gt;,&lt;/span&gt; p050&lt;span&gt;,&lt;/span&gt; p051&lt;span&gt;,&lt;/span&gt; p052&lt;span&gt;,&lt;/span&gt; p053&lt;span&gt;,&lt;/span&gt; p054&lt;span&gt;,&lt;/span&gt; p055&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p056&lt;span&gt;,&lt;/span&gt; p057&lt;span&gt;,&lt;/span&gt; p058&lt;span&gt;,&lt;/span&gt; p059&lt;span&gt;,&lt;/span&gt; p060&lt;span&gt;,&lt;/span&gt; p061&lt;span&gt;,&lt;/span&gt; p062&lt;span&gt;,&lt;/span&gt; p063&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p064&lt;span&gt;,&lt;/span&gt; p065&lt;span&gt;,&lt;/span&gt; p066&lt;span&gt;,&lt;/span&gt; p067&lt;span&gt;,&lt;/span&gt; p068&lt;span&gt;,&lt;/span&gt; p069&lt;span&gt;,&lt;/span&gt; p070&lt;span&gt;,&lt;/span&gt; p071&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p072&lt;span&gt;,&lt;/span&gt; p073&lt;span&gt;,&lt;/span&gt; p074&lt;span&gt;,&lt;/span&gt; p075&lt;span&gt;,&lt;/span&gt; p076&lt;span&gt;,&lt;/span&gt; p077&lt;span&gt;,&lt;/span&gt; p078&lt;span&gt;,&lt;/span&gt; p079&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p080&lt;span&gt;,&lt;/span&gt; p081&lt;span&gt;,&lt;/span&gt; p082&lt;span&gt;,&lt;/span&gt; p083&lt;span&gt;,&lt;/span&gt; p084&lt;span&gt;,&lt;/span&gt; p085&lt;span&gt;,&lt;/span&gt; p086&lt;span&gt;,&lt;/span&gt; p087&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p088&lt;span&gt;,&lt;/span&gt; p089&lt;span&gt;,&lt;/span&gt; p090&lt;span&gt;,&lt;/span&gt; p091&lt;span&gt;,&lt;/span&gt; p092&lt;span&gt;,&lt;/span&gt; p093&lt;span&gt;,&lt;/span&gt; p094&lt;span&gt;,&lt;/span&gt; p095&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p096&lt;span&gt;,&lt;/span&gt; p097&lt;span&gt;,&lt;/span&gt; p098&lt;span&gt;,&lt;/span&gt; p099&lt;span&gt;,&lt;/span&gt; p100&lt;span&gt;,&lt;/span&gt; p101&lt;span&gt;,&lt;/span&gt; p102&lt;span&gt;,&lt;/span&gt; p103&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p104&lt;span&gt;,&lt;/span&gt; p105&lt;span&gt;,&lt;/span&gt; p106&lt;span&gt;,&lt;/span&gt; p107&lt;span&gt;,&lt;/span&gt; p108&lt;span&gt;,&lt;/span&gt; p109&lt;span&gt;,&lt;/span&gt; p110&lt;span&gt;,&lt;/span&gt; p111&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p112&lt;span&gt;,&lt;/span&gt; p113&lt;span&gt;,&lt;/span&gt; p114&lt;span&gt;,&lt;/span&gt; p115&lt;span&gt;,&lt;/span&gt; p116&lt;span&gt;,&lt;/span&gt; p117&lt;span&gt;,&lt;/span&gt; p118&lt;span&gt;,&lt;/span&gt; p119&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;這個類除了定義了 120 字節的字段外，看上去沒有做其他任何事情，實際上它為 &lt;strong&gt;性能提升&lt;/strong&gt; 默默做出了貢獻，&lt;strong&gt;避免了內存偽共享&lt;/strong&gt;。CPU 中緩存行（Cache Line）的大小通常是 64 字節，在類中定義 120 字節來佔位，這樣便能將上下繼承關係間的字段間隔開，保證被多個線程訪問的關鍵字段距離至少跨越一個緩存行，分佈在不同的緩存行中。這樣在不同的線程訪問 &lt;code&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/code&gt; 和 &lt;code&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/code&gt; 中字段時互不影響，詳細瞭解原理可參考&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cnblogs.com%2Fzhongqifeng%2Fp%2F14765576.html" rel="nofollow" target="_blank"&gt;博客園 - CPU Cache 與緩存行&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;接下來我們看看其他抽象類的作用。&lt;code&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/code&gt; 定義生產者相關字段：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad1&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 生產者操作索引（並不對應緩衝區 producerBuffer 中索引位置）&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerIndex&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/code&gt; 負責定義消費者相關字段：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueConsumerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad2&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 掩碼值，用於計算消費者實際的索引位置&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; consumerMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 消費者訪問這個緩衝區來獲取元素消費&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; consumerBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 消費者操作索引（並不對應緩衝區 consumerBuffer 中索引位置）&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; consumerIndex&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/code&gt; 中定義字段如下，該類的命名包含 &lt;strong&gt;Cold&lt;/strong&gt;，表示其中字段被修改的次數會比較少：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueuePad3&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 生產者可以操作的最大索引上限&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerLimit&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 掩碼值，用於計算生產者在數組中實際的索引&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerMask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 存儲生產者生產的元素&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; producerBuffer&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;現在關鍵字段我們已經介紹完了，接下來看一下創建 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 的邏輯，執行它的構造方法時會為我們剛剛提到的字段進行賦值：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 調用父類的構造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;,&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// 省略字節佔位字段...&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt; p119&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;MpscChunkedArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 調用父類的構造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;,&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxQueueCapacity&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;MpscChunkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 調用父類的構造方法&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maxCapacity &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Max capacity must be 4 or more"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 保證了最大值最少比初始值大 2 倍&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
                    &lt;span&gt;"Initial capacity cannot exceed maximum capacity(both rounded up to a power of 2)"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 最大容量也為 2 的 n 次冪&lt;/span&gt;
        maxQueueCapacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;maxCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; initialCapacity&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;initialCapacity &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalArgumentException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Initial capacity must be 2 or more"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 初始化緩衝區大小為數值最接近的 2 的 n 次冪&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; p2capacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;initialCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 掩碼值，-1L 使其低位均為 1，左移 1 位則最低位為 0，eg: 00000110，注意該值會被生產者和消費者掩碼值共同賦值&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;p2capacity &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1L&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 創建一個大小為 2 的 n 次冪 +1 大小的緩衝區，注意這個 buffer 分別被 producerBuffer 和 consumerBuffer 共同引用&lt;/span&gt;
        &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;allocate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;p2capacity &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// BaseMpscLinkedArrayQueueColdProducerFields 類中相關字段賦值&lt;/span&gt;
        producerBuffer &lt;span&gt;=&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        producerMask &lt;span&gt;=&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 將 producerLimit 值賦為，掩碼值&lt;/span&gt;
        &lt;span&gt;soProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// BaseMpscLinkedArrayQueueConsumerFields 類中相關字段賦值&lt;/span&gt;
        consumerBuffer &lt;span&gt;=&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        consumerMask &lt;span&gt;=&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;現在 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 的構建已經看完了，瞭解了其中關鍵字段的賦值，現在我們就需要看它是如何實現 &lt;strong&gt;MPSC&lt;/strong&gt; 的。「多生產者」也就意味着會有多個線程向其中添加元素，既然是多線程就需要重點關注它是如何在多線程間完成協同的。添加操作對應了 &lt;code&gt;BaseMpscLinkedArrayQueue#offer&lt;/code&gt; 方法，它的實現如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"MissingDefault"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;NullPointerException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 生產者最大索引（生產者掩碼值），獲取 BaseMpscLinkedArrayQueueColdProducerFields 中定義的該字段&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; producerLimit &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 生產者當前索引，初始值為 0，BaseMpscLinkedArrayQueueProducerFields 中字段 &lt;/span&gt;
            pIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// producerIndex 最低位用來表示擴容（索引生產者索引 producerIndex 並不對應緩衝區中實際的索引）&lt;/span&gt;
            &lt;span&gt;// 低位為 1 表示正在擴容，自旋等待直到擴容完成（表示只有一個線程操作擴容）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 掩碼值和 buffer 可能在擴容中被改變，每次循環使用最新值&lt;/span&gt;
            mask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;producerMask&lt;span&gt;;&lt;/span&gt;
            buffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;producerBuffer&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 檢查是否需要擴容&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;producerLimit &lt;span&gt;&amp;lt;=&lt;/span&gt; pIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;offerSlowPath&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; producerLimit&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;result&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                        &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;,&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// CAS 操作更新生產者索引，注意這裏是 +2，更新成功結束循環&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 計算該元素在 buffer 中的實際偏移量，並將其添加到緩衝區中&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 沒有將 resize 邏輯封裝在該方法中，而是由該方法判斷是否需要擴容&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;offerSlowPath&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; producerLimit&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; result&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 獲取消費者索引 BaseMpscLinkedArrayQueueConsumerFields 類中&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; cIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 通過掩碼值計算當前緩衝區容量&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; bufferCapacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getCurrentBufferCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 如果隊列還有空間&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cIndex &lt;span&gt;+&lt;/span&gt; bufferCapacity &lt;span&gt;&amp;gt;&lt;/span&gt; pIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 嘗試更新生產者最大限制，更新失敗則返回 1 重試&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;casProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; producerLimit&lt;span&gt;,&lt;/span&gt; cIndex &lt;span&gt;+&lt;/span&gt; bufferCapacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 如果隊列已滿且無法擴展&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;availableInQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; cIndex&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 更新 producerIndex 最低位為 1，成功則進行擴容，否則重試&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            result &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; result&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; oldMask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; oldBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pIndex&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 計算新緩衝區大小並創建，2 * (buffer.length - 1) + 1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newBufferLength &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getNextBufferSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; newBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;allocate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newBufferLength&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 更新緩衝區引用為新的緩衝區&lt;/span&gt;
        producerBuffer &lt;span&gt;=&lt;/span&gt; newBuffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新新的掩碼&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; newMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;newBufferLength &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        producerMask &lt;span&gt;=&lt;/span&gt; newMask&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 計算元素在新舊緩衝區中的偏移量&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInOld &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; oldMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInNew &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; newMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 將元素放到新緩衝區中&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 將新緩衝區連接到舊緩衝區中&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; newBuffer&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 校驗可用空間&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; cIndex &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; availableInQueue &lt;span&gt;=&lt;/span&gt; &lt;span&gt;availableInQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pIndex&lt;span&gt;,&lt;/span&gt; cIndex&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;availableInQueue &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 更新生產者限制大小和生產者索引&lt;/span&gt;
        &lt;span&gt;soProducerLimit&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;min&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newMask&lt;span&gt;,&lt;/span&gt; availableInQueue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;soProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; pIndex &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 將舊緩衝區中該位置的元素更新為 JUMP 標誌位，這樣在被消費時就知道去新的緩衝區獲取了&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldBuffer&lt;span&gt;,&lt;/span&gt; offsetInOld&lt;span&gt;,&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;// 因為最低位用來表示是否在擴容，所以 producerIndex 和 consumerIndex 並不表示實際的索引&lt;/span&gt;
    &lt;span&gt;// 注意生產者（消費者）操作索引值會隨着元素的增加不斷變大，因為有它們和掩碼值的位與運算才保證了索引值一直在索引值的有效範圍內&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可見，在這個過程中它並沒有限制操作線程數量，也沒有使用加鎖的同步機制。它通過保證 &lt;strong&gt;可見性&lt;/strong&gt;，並使用 &lt;strong&gt;自旋鎖結合 CAS 操作&lt;/strong&gt; 更新生產者索引值，因為該操作是原子的，同時只有一個線程能更新獲取索引值成功，更新失敗的線程會自旋重試，這樣便允許多線程同時添加元素，可見性保證和 CAS 操作源碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;VarHandle&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; pIndexLookup&lt;span&gt;.&lt;/span&gt;&lt;span&gt;findVarHandle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;
            &lt;span&gt;BaseMpscLinkedArrayQueueProducerFields&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"producerIndex"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// volatile 可見性保證&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVolatile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;// CAS 操作&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;casProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; self&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; expect&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; newValue&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;P_INDEX&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;compareAndSet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;self&lt;span&gt;,&lt;/span&gt; expect&lt;span&gt;,&lt;/span&gt; newValue&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;保證可見性（內存操作對其他線程可見）的原理是 &lt;strong&gt;內存屏障&lt;/strong&gt;，除了保證可見性以外，內存屏障還能夠 &lt;strong&gt;防止重排序&lt;/strong&gt;（確保在內存屏障前後的內存操作不會被重排序，從而保證程序的正確性）。到這裏，生產者添加元素的邏輯我們已經分析完了，接下來我們需要繼續看一下消費者獲取元素的邏輯，它對應了 &lt;code&gt;BaseMpscLinkedArrayQueue#poll&lt;/code&gt; 方法，同樣地，在這過程中需要關注「在這個方法中有沒有限制單一線程執行」，以此實現單消費者呢：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseMpscLinkedArrayQueueColdProducerFields&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 讀取消費者相關字段 BaseMpscLinkedArrayQueueConsumerFields 類&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer &lt;span&gt;=&lt;/span&gt; consumerBuffer&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index &lt;span&gt;=&lt;/span&gt; consumerIndex&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask &lt;span&gt;=&lt;/span&gt; consumerMask&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 根據消費索引，計算出元素在消費者緩衝區中實際的位置&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 讀取該元素（volatile 可見性讀取）&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; e &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        
        &lt;span&gt;// 如果為空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 比較生產者索引，如果兩個索引不相等，那麼證明兩索引間存在距離表示還有元素能夠被消費&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;lvProducerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 自旋讀取元素，直到讀到元素&lt;/span&gt;
                &lt;span&gt;do&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    e &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 索引相等證明確實是空隊列&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;e &lt;span&gt;==&lt;/span&gt; &lt;span&gt;JUMP&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 獲取到新緩衝區&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getNextBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 在新緩衝區中獲取到對應元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;newBufferPoll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 清除當前索引的元素，表示該元素已經被消費&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; offset&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新消費者索引，這裏也是 +2，它並不表示實際的在緩衝區的索引&lt;/span&gt;
        &lt;span&gt;soConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; e&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;getNextBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果已經發生擴容，此時 consumerMask 仍然對應的是擴容前的 mask&lt;/span&gt;
        &lt;span&gt;// 此處與生產者操作擴容時拼接新舊緩衝區調用的是一樣的方法，這樣便能夠獲取到新緩衝區的偏移量&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nextArrayOffset &lt;span&gt;=&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 獲取到新緩衝區，因為在擴容操作時已經將新緩衝區鏈接到舊緩衝區上了&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; nextArrayOffset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 將舊緩衝區中新緩衝區位置設置為 null 表示舊緩衝區中已經沒有任何元素需要被消費了，也不再需要被引用了（能被垃圾回收了）&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; nextArrayOffset&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; nextBuffer&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nextArrayOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;mask &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;newBufferPoll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 計算出消費者操作索引在新緩衝區中對應的實際位置&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offsetInNew &lt;span&gt;=&lt;/span&gt; &lt;span&gt;newBufferAndOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在新緩衝區中獲取到對應元素&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; n &lt;span&gt;=&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"new buffer must have at least one element"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 清除當前索引的元素，表示該元素已經被消費&lt;/span&gt;
        &lt;span&gt;soElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;,&lt;/span&gt; offsetInNew&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 更新消費者索引&lt;/span&gt;
        &lt;span&gt;soConsumerIndex&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; index &lt;span&gt;+&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;newBufferAndOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; nextBuffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 將消費者緩衝區引用和掩碼值更新&lt;/span&gt;
        consumerBuffer &lt;span&gt;=&lt;/span&gt; nextBuffer&lt;span&gt;;&lt;/span&gt;
        consumerMask &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;nextBuffer&lt;span&gt;.&lt;/span&gt;length &lt;span&gt;-&lt;/span&gt; &lt;span&gt;2L&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;index&lt;span&gt;,&lt;/span&gt; consumerMask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;modifiedCalcElementOffset&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; index&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;index &lt;span&gt;&amp;amp;&lt;/span&gt; mask&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
    
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;lvElement&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;REF_ARRAY&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVolatile&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;buffer&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; offset&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以發現在該方法中並沒有限制單一線程執行，所以理論上這個方法可能被多個線程調用，那麼它又為什麼被稱為 &lt;strong&gt;MPSC&lt;/strong&gt; 呢？在這個方法中的一段註釋值得細心體會：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;This implementation is correct for single consumer thread use only.&lt;br&gt; 此實現僅適用於單消費者線程使用&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;所以調用該方法時開發者本身需要保證單線程調用而並不是在實現中控制。&lt;/p&gt; 
&lt;p&gt;到這裏 &lt;code&gt;MpscGrowableArrayQueue&lt;/code&gt; 中核心的邏輯已經講解完了，現在我們回過頭來再看一下隊列擴容前後生產者和消費者是如何協同的？在擴容前，&lt;code&gt;consumerBuffer&lt;/code&gt; 和 &lt;code&gt;producerBuffer&lt;/code&gt; 引用的是同一個緩衝區對象。如果發生擴容，那麼生產者會創建一個新的緩衝區，並將 &lt;code&gt;producerBuffer&lt;/code&gt; 引用指向它，此時它做了一個 &lt;strong&gt;非常巧妙&lt;/strong&gt; 的操作，將 &lt;strong&gt;新緩衝區依然鏈接到舊緩衝區&lt;/strong&gt; 上，並將觸發擴容的元素對應的舊緩衝區的索引處標記為 JUMP，表示這及之後的元素已經都在新緩衝區中。此時，消費者依然會在舊緩衝區中慢慢地消費，直到遇到 JUMP 標誌位，消費者就知道需要到新緩衝區中取獲取元素了。因為之前生產者在擴容時對新舊緩衝區進行鏈接，所以消費者能夠通過舊緩衝區獲取到新緩衝區的引用，並變更 &lt;code&gt;consumerBuffer&lt;/code&gt; 的引用和 &lt;code&gt;consumerMask&lt;/code&gt; 掩碼值，接下來的消費過程便和擴容前沒有差別了。&lt;/p&gt; 
&lt;span id="OSC_h4_5"&gt;&lt;/span&gt; 
&lt;h4&gt;scheduleAfterWrite&lt;/h4&gt; 
&lt;p&gt;現在我們再回到 &lt;code&gt;put&lt;/code&gt; 方法的邏輯中，如果向 &lt;code&gt;WriterBuffer&lt;/code&gt; 中添加元素成功，則會調用 &lt;code&gt;scheduleAfterWrite&lt;/code&gt; 方法，調度任務的執行：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 默認為 ForkJoinPool.commonPool()&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; executor&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;// 該任務在創建緩存時已經完成初始化&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; drainBuffersTask&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// 根據狀態的變化來調度執行任務&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 獲取當前 drainStatus，drain 譯為排空，耗盡&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; &lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 這裏的狀態機變更需要關注下&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;drainStatus&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// IDLE 表示當前無任務可做&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// CAS 更新狀態為 REQUIRED&lt;/span&gt;
                    &lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 調度任務執行&lt;/span&gt;
                    &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// REQUIRED 表示當前有任務需要執行&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// 調度任務執行&lt;/span&gt;
                    &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// PROCESSING_TO_IDLE 表示當前任務處理完成後會變成 IDLE 狀態&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;// 又來了新的任務，則 CAS 操作將它更新為 PROCESSING_TO_REQUIRED 狀態&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusAcquire&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// PROCESSING_TO_REQUIRED 表示正在處理任務，處理完任務後還有任務需要處理&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt; &lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;IllegalStateException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"Invalid drain status: "&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; drainStatus&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 調度執行緩衝區中的任務&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果狀態表示正在有任務處理則返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 注意這裏要獲取同步鎖 evictionLock&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 獲取鎖後再次校驗當前處理狀態&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; drainStatus &lt;span&gt;=&lt;/span&gt; &lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;drainStatus &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 更新狀態為 PROCESSING_TO_IDLE&lt;/span&gt;
                &lt;span&gt;setDrainStatusRelease&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 同步機制保證任何時刻只能有一個線程能夠提交任務&lt;/span&gt;
                executor&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;drainBuffersTask&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WARNING&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when submitting maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;/* ignored */&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;寫後調度處理任務（&lt;code&gt;scheduleAfterWrite&lt;/code&gt;）會根據狀態選擇性執行 &lt;code&gt;scheduleDrainBuffers&lt;/code&gt; 方法，執行該方法時通過同步鎖 &lt;code&gt;evictionLock&lt;/code&gt; 保證同時只有一個線程能提交 &lt;code&gt;PerformCleanupTask&lt;/code&gt; 任務。這個任務在創建緩存時已經被初始化完成了，每次提交任務都會被複用，接下來我們看一下這個任務的具體實現：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;// 可重用的任務，用於執行 maintenance 方法，避免了使用 ForkJoinPool 來包裝&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;PerformCleanupTask&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ForkJoinTask&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Void&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1L&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; reference&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;PerformCleanupTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            reference &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;cache&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;exec&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;Throwable&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when performing the maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; t&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// Indicates that the task has not completed to allow subsequent submissions to execute&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 獲取到緩存對象&lt;/span&gt;
            &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cache &lt;span&gt;=&lt;/span&gt; reference&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cache &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                cache&lt;span&gt;.&lt;/span&gt;&lt;span&gt;performCleanUp&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// ...&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;它的實現非常簡單，其中 &lt;code&gt;reference&lt;/code&gt; 字段在調用構造方法時被賦值，引用的是緩存對象本身。當任務被執行時，調用的是 &lt;code&gt;BoundedLocalCache#performCleanUp&lt;/code&gt; 方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;// 執行該任務時，也要獲取同步鎖，表示任務只能由一個線程來執行&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;performCleanUp&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 執行維護任務&lt;/span&gt;
            &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;@Nullable&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 更新狀態為執行中&lt;/span&gt;
        &lt;span&gt;setDrainStatusRelease&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 處理讀緩衝區中的任務&lt;/span&gt;
            &lt;span&gt;drainReadBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 處理寫緩衝區中的任務&lt;/span&gt;
            &lt;span&gt;drainWriteBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;task &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                task&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 處理 key 和 value 的引用&lt;/span&gt;
            &lt;span&gt;drainKeyReferences&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;drainValueReferences&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 過期和驅逐策略&lt;/span&gt;
            &lt;span&gt;expireEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

            &lt;span&gt;// 「增值」 操作，後續重點講&lt;/span&gt;
            &lt;span&gt;climb&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 狀態不是 PROCESSING_TO_IDLE 或者無法 CAS 更新為 IDLE 狀態的話，需要更新狀態為 REQUIRED，該狀態會再次執行維護任務&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;casDrainStatus&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_IDLE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;IDLE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;setDrainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注意在執行 &lt;code&gt;performCleanUp&lt;/code&gt; 方法時，也需要獲取到同步鎖 &lt;code&gt;evictionLock&lt;/code&gt;，那麼任務的提交和任務的執行也是互斥的。這個執行的核心邏輯在 &lt;code&gt;maintenance&lt;/code&gt; 「維護」方法中，注意這個方法被標記了註解 &lt;code&gt;@GuardedBy("evictionLock")&lt;/code&gt;，源碼中還有多個方法也標記了該註解，執行這些方法時都要獲取同步鎖，這也是在提醒我們這些方法同時只有由一條線程被執行。因為目前關注的是 &lt;code&gt;put&lt;/code&gt; 方法，所以重點先看維護方法中 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 方法處理寫緩衝區中任務的邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;NCPU&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Runtime&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getRuntime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;availableProcessors&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;128&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;ceilingPowerOfTwo&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;NCPU&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;MpscGrowableArrayQueue&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; writeBuffer&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;drainWriteBuffer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 最大循環次數為 writeBuffer 最大容量，直至彈出元素為 null&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_MAX&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Runnable&lt;/span&gt; task &lt;span&gt;=&lt;/span&gt; writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;poll&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;task &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            task&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 更新狀態為 PROCESSING_TO_REQUIRED&lt;/span&gt;
        &lt;span&gt;setDrainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PROCESSING_TO_REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;執行邏輯非常簡單，在獲取到同步鎖之後，在 &lt;code&gt;WriteBuffer&lt;/code&gt; 中獲取要被執行的任務並執行。在這裏我們能發現「SC 單消費者」的實現使用 &lt;strong&gt;同步鎖的機制保證同時只能有一個消費者消費緩衝區中的任務&lt;/strong&gt;。在上文中我們已經知道，調用 &lt;code&gt;put&lt;/code&gt; 方法時向緩衝區 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加的任務為 &lt;code&gt;AddTask&lt;/code&gt;，下面我們看一下該任務的實現：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;Long&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MAX_VALUE&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AddTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 節點權重&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;AddTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;weight &lt;span&gt;=&lt;/span&gt; weight&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;node &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"FutureReturnValueIgnored"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 是否指定了驅逐策略&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 更新緩存權重和窗口區權重&lt;/span&gt;
                &lt;span&gt;setWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;setWindowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;windowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新節點的 policyWeight，該字段只有在自定了權重計算規則時才有效&lt;/span&gt;
                &lt;span&gt;// 否則像只定義了固定容量的驅逐策略，使用默認元素權重為 1 是不需要關注該字段的&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                &lt;span&gt;// 檢測當前總權重是否超過一半的最大容量&lt;/span&gt;
                &lt;span&gt;long&lt;/span&gt; maximum &lt;span&gt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;maximum &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 如果超過最大容量&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 執行驅逐操作&lt;/span&gt;
                        &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 延遲加載頻率草圖 frequencySketch 數據結構，用於統計元素訪問頻率&lt;/span&gt;
                        &lt;span&gt;long&lt;/span&gt; capacity &lt;span&gt;=&lt;/span&gt; &lt;span&gt;isWeighted&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;mappingCount&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; maximum&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ensureCapacity&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;capacity&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新頻率統計信息&lt;/span&gt;
                &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 因為頻率草圖數據結構具有延遲加載機制（權重超過半數）&lt;/span&gt;
                    &lt;span&gt;// 所以實際上在元素權重還未過半未完成初始化時，調用 increment 是沒有作用的&lt;/span&gt;
                    &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 增加未命中樣本數&lt;/span&gt;
                &lt;span&gt;setMissesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;missesInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 同步檢測節點是否還有效&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; isAlive&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                isAlive &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;isAlive&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 寫後過期策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 過期策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 驅逐策略&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 如果權重比配置的最大權重大&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;// 執行固定權重（RemovalCause.SIZE）的驅逐策略&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 如果權重超過窗口區最大權重，則將其放在窗口區頭節點&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;windowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerFirst&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 否則放在窗口區尾節點&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 訪問後過期策略&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 處理異步計算&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;isComputingAsync&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;Async&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isReady&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;CompletableFuture&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;long&lt;/span&gt; expirationTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;ASYNC_EXPIRY&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; expirationTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;根據註釋很容易理解該方法的作用，因為我們目前對緩存只定義了固定容量的驅逐策略，所以我們需要在看一下 &lt;code&gt;evictEntry&lt;/code&gt; 方法：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;"GuardedByChecker"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"NullAway"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"PMD.CollapsibleIfStatements"&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt; cause&lt;span&gt;,&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;@SuppressWarnings&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"unchecked"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;V&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; value &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; removed &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; resurrect &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; keyReference &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; actualCause &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;computeIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keyReference&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n &lt;span&gt;!=&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                &lt;span&gt;// key 或 value 為 null，這種情況下可能使用了 Caffeine.weakKeys, Caffeine.weakValues, or Caffeine.softValues&lt;/span&gt;
                &lt;span&gt;// 導致被垃圾回收了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 標記實際失效原因為垃圾回收 &lt;/span&gt;
                    actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果原因為垃圾回收，記錄 resurrect 復活標記為 true&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;cause &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 否則記錄入參中的原因&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; cause&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 過期驅逐策略判斷&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;boolean&lt;/span&gt; expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;expiresAfterAccessNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;expiresAfterWriteNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        expired &lt;span&gt;|=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;n&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 固定容量驅逐策略&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; weight &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weight &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 通知驅逐策略監聽器，調用它的方法&lt;/span&gt;
                &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 將該 key 對應的刷新策略失效&lt;/span&gt;
                &lt;span&gt;discardRefresh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;keyReference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 標記該節點被驅逐&lt;/span&gt;
                removed&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 退休準備被垃圾回收&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;retire&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;// 如果復活標記為 true 那麼不被移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;resurrect&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 節點已經要被驅逐&lt;/span&gt;
        &lt;span&gt;// 如果在窗口區，那麼直接從窗口區移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 如果沒在窗口區&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 在試用區直接在試用區移除&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 在保護區則直接從保護區移除&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 將寫後失效和時間輪中關於該節點的元素移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;deschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 同步機制將 node 置為 dead&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;logIfAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;makeDead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;removed&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 節點被移除監控計數和節點移除通知回調&lt;/span&gt;
            &lt;span&gt;statsCounter&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;recordEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; actualCause&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;該方法比較簡單，是將節點進行驅逐的邏輯，在後文中它會被多次複用，需要留一個印象。回到 &lt;code&gt;AddTask&lt;/code&gt; 任務的邏輯中，當被添加的元素權重超過最大權重限制時會被直接移除。這種特殊情況試用於指定了權重計算策略的緩存，如果只指定了固定容量，元素權重默認為 1，所以不會直接超過最大緩存數量限制。&lt;/p&gt; 
&lt;p&gt;現在我們已經將 &lt;code&gt;put&lt;/code&gt; 方法中向緩存中添加元素的邏輯介紹完了，接下來需要關注 &lt;code&gt;put&lt;/code&gt; 方法中對已存在的相同 key 值元素的處理邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;MAX_PUT_SPIN_WAIT_ATTEMPTS&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1024&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SECONDS&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toNanos&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; data&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;@Nullable&lt;/span&gt;
    &lt;span&gt;V&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;K&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Expiry&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;requireNonNull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node &lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; now &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newWeight &lt;span&gt;=&lt;/span&gt; weigher&lt;span&gt;.&lt;/span&gt;&lt;span&gt;weigh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;Object&lt;/span&gt; lookupKey &lt;span&gt;=&lt;/span&gt; nodeFactory&lt;span&gt;.&lt;/span&gt;&lt;span&gt;newLookupKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; attempts &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;;&lt;/span&gt; attempts&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; prior &lt;span&gt;=&lt;/span&gt; data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// ... &lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 元素被讀到之後可能已經被驅逐了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 自旋嘗試重新從 ConcurrentHashMap 中獲取，再獲取時如果為 null 則執行新增邏輯&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;attempts &lt;span&gt;&amp;amp;&lt;/span&gt; &lt;span&gt;MAX_PUT_SPIN_WAIT_ATTEMPTS&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果自旋嘗試後元素仍未被刪除，校驗元素是否處於存活狀態&lt;/span&gt;
                &lt;span&gt;// 如果處於非存活狀態，那麼可能這個元素已經被破壞，無法被移除，拋出異常&lt;/span&gt;
                data&lt;span&gt;.&lt;/span&gt;&lt;span&gt;computeIfPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;lookupKey&lt;span&gt;,&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;k&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;requireIsAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; n&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;V&lt;/span&gt; oldValue&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 新的過期時間&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; varTime&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; oldWeight&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; mayUpdate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; exceedsTolerance &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 為元素加同步鎖&lt;/span&gt;
            &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 如果此時元素已經失效了，那麼需要重新循環&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAlive&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                oldValue &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                oldWeight &lt;span&gt;=&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// oldValue 為 null 證明它被垃圾回收器回收了&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 記錄元素創建後的過期時間&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 驅逐監聽器回調&lt;/span&gt;
                    &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果元素已經過期了&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;hasExpired&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 標記過期標誌為 true&lt;/span&gt;
                    expired &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 記錄元素創建後的過期時間並回調驅逐監聽器&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAftexpireAfterCreateerCreate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;notifyEviction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// onlyInAbsent 為 true 時不會對已存在 key 的值進行修改&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;onlyIfAbsent&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    mayUpdate &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 記錄元素讀後過期時間&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 記錄元素修改後過期時間&lt;/span&gt;
                    varTime &lt;span&gt;=&lt;/span&gt; &lt;span&gt;expireAfterUpdate&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; key&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;,&lt;/span&gt; expiry&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 需要修改原有 key 的 value 值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    exceedsTolerance &lt;span&gt;=&lt;/span&gt;
                            &lt;span&gt;// 配置了寫後過期策略且已經超過寫後時間的容忍範圍&lt;/span&gt;
                            &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;now &lt;span&gt;-&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
                                    &lt;span&gt;// 或者配置了可變時間過期策略同樣判斷是否超過時間的容忍範圍&lt;/span&gt;
                                    &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;abs&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;varTime &lt;span&gt;-&lt;/span&gt; prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;EXPIRE_WRITE_TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                    &lt;span&gt;// 更新值，更新權重，更新寫時間&lt;/span&gt;
                    prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setValue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;value&lt;span&gt;,&lt;/span&gt; &lt;span&gt;valueReferenceQueue&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newWeight&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

                    &lt;span&gt;// 寫後刷新策略失效&lt;/span&gt;
                    &lt;span&gt;discardRefresh&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKeyReference&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新過期時間&lt;/span&gt;
                &lt;span&gt;setVariableTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; varTime&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新訪問時間&lt;/span&gt;
                &lt;span&gt;setAccessTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 根據不同的情況回調不同的監聽器&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;EXPIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyRemoval&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* oldValue */&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;COLLECTED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;notifyOnReplace&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;,&lt;/span&gt; oldValue&lt;span&gt;,&lt;/span&gt; value&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;// 計算寫後權重變化&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; weightedDifference &lt;span&gt;=&lt;/span&gt; mayUpdate &lt;span&gt;?&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;newWeight &lt;span&gt;-&lt;/span&gt; oldWeight&lt;span&gt;)&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 如果 oldValue 已經被回收，或 權重修改前後發生變更，或 已經過期，添加更新任務&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldValue &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;weightedDifference &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; expired&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; weightedDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 如果超過了時間容忍範圍，添加更新任務&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;onlyIfAbsent &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; exceedsTolerance&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; weightedDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 沒有超過時間容忍範圍，更新寫時間&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;mayUpdate&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;setWriteTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 處理讀後操作&lt;/span&gt;
                &lt;span&gt;afterRead&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;prior&lt;span&gt;,&lt;/span&gt; now&lt;span&gt;,&lt;/span&gt; &lt;span&gt;/* recordHit */&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt; expired &lt;span&gt;?&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; oldValue&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;對於已有元素的變更，會對節點添加同步鎖，更新它的權重等一系列變量，如果超過 1s 的時間容忍範圍，則會添加 &lt;code&gt;UpdateTask&lt;/code&gt; 更新任務，至於處理讀後操作 &lt;code&gt;afterRead&lt;/code&gt; 在讀方法中再去介紹。接下來我們需要重新再看一下 &lt;code&gt;afterWrite&lt;/code&gt; 方法，其中有部分我們在上文中沒有介紹的邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; evictionLock&lt;span&gt;;&lt;/span&gt;
    
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt; task&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 這段邏輯我們在看 AddTask 的邏輯時已經看過了，所以略過&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;WRITE_BUFFER_RETRIES&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;writeBuffer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;scheduleAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onSpinWait&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 以下邏輯用於解決在重試了 100 次後仍然寫入失敗的問題，它會嘗試獲取 evictionLock 同步鎖&lt;/span&gt;
        &lt;span&gt;// 直接同步執行「維護」方法並執行當前任務，但是它並無法解決某個寫入操作執行時間很長的問題&lt;/span&gt;
        &lt;span&gt;// 發生這種情況的原因可能是由於執行器的所有線程都很忙（可能是寫入此緩存），寫入速率大大超過了消耗速率，優先級反轉，或者執行器默默地丟棄了維護任務&lt;/span&gt;
        &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;maintenance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;task&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;RuntimeException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ERROR&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"Exception thrown when performing the maintenance task"&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 重新調度異步維護任務，確保維護操作能及時執行&lt;/span&gt;
        &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; remainingNanos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;WARN_AFTER_LOCK_WAIT_NANOS&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; end &lt;span&gt;=&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; remainingNanos&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; interrupted &lt;span&gt;=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;remainingNanos&lt;span&gt;,&lt;/span&gt; &lt;span&gt;TimeUnit&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;NANOSECONDS&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    logger&lt;span&gt;.&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Level&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;WARNING&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;"The cache is experiencing excessive wait times for acquiring "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"the eviction lock. This may indicate that a long-running computation has halted "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"eviction when trying to remove the victim entry. Consider using AsyncCache to "&lt;/span&gt;
                            &lt;span&gt;+&lt;/span&gt; &lt;span&gt;"decouple the computation from the map operation."&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TimeoutException&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt; &lt;span&gt;catch&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;InterruptedException&lt;/span&gt; e&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    remainingNanos &lt;span&gt;=&lt;/span&gt; end &lt;span&gt;-&lt;/span&gt; &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    interrupted &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;interrupted&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;currentThread&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interrupt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;// 調用同步的維護方法時，可能發生獲取鎖超時，那麼再重新開啓一個異步維護調度&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rescheduleCleanUpIfIncomplete&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 校驗是否有任務需要被執行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        
        &lt;span&gt;// 默認線程池調度任務執行，這個方法我們在上文中已經詳細介紹過&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;executor &lt;span&gt;==&lt;/span&gt; &lt;span&gt;ForkJoinPool&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;commonPool&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;scheduleDrainBuffers&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        
        &lt;span&gt;// 如果自定義了線程池，那麼會使用自定義的線程池進行處理&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; pacer &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pacer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;pacer &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isScheduled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;drainStatusOpaque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;REQUIRED&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isScheduled&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    pacer&lt;span&gt;.&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;executor&lt;span&gt;,&lt;/span&gt; drainBuffersTask&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Pacer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;TOLERANCE&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                evictionLock&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;寫後操作除了在添加任務到緩衝區成功後會執行維護方法，添加失敗（證明寫入操作非常頻繁）依然會嘗試同步執行維護方法和發起異步維護，用於保證緩存中的任務能夠被及時執行，使緩存中元素都處於「預期」狀態中。接下來我們在看一下 &lt;code&gt;UpdateTask&lt;/code&gt; 更新任務的邏輯：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;BoundedLocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BLCHeader&lt;span&gt;.&lt;/span&gt;DrainStatusRef&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LocalCache&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;

    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weightDifference&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;UpdateTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;weightDifference &lt;span&gt;=&lt;/span&gt; weightDifference&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;node &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;@Override&lt;/span&gt;
        &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 寫後過期和自定義過期邏輯&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterWrite&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;writeOrderDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 指定了驅逐策略&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;// 變更節點權重&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; oldWeightedSize &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oldWeightedSize &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 如果是窗口區節點&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 更新窗口區權重&lt;/span&gt;
                    &lt;span&gt;setWindowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;windowWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 節點權重超過最大權重限制，直接驅逐&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 節點權重比窗口區最大值小&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;windowMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 窗口區包含該節點且該節點的權重大於窗口最大權重，則放到頭節點&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;moveToFront&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果是試用區節點&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 節點權重比最大權重限制小&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                    &lt;span&gt;// 否則將該節點驅逐&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;// 如果是保護區節點&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProtected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;// 更新保護區權重&lt;/span&gt;
                    &lt;span&gt;setMainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;// 同樣的邏輯&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;maximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                        &lt;span&gt;evictEntry&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;,&lt;/span&gt; &lt;span&gt;RemovalCause&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SIZE&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expirationTicker&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                    &lt;span&gt;}&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;

                &lt;span&gt;// 更新緩存權重大小&lt;/span&gt;
                &lt;span&gt;setWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; weightDifference&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;// 更新完成後超過最大權重限制執行驅逐操作&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;weightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                    &lt;span&gt;evictEntries&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
                &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 配置了訪問後過期&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;evicts&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;K&lt;/span&gt; key &lt;span&gt;=&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getKey&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;key &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 更新訪問頻率&lt;/span&gt;
            &lt;span&gt;frequencySketch&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;increment&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;key&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;// 如果節點在窗口區，則將其移動到尾節點&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inWindow&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 在試用區的節點執行 reorderProbation 方法，可能會將該節點從試用區晉升到保護區&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;inMainProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorderProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 否則移動到保護區的尾結點&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
                &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;}&lt;/span&gt;
            &lt;span&gt;// 更新命中量&lt;/span&gt;
            &lt;span&gt;setHitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;hitsInSample&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了訪問過期策略&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresAfterAccess&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderWindowDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 配置了自定義時間過期策略&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;expiresVariable&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;timerWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;reschedule&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;LinkedDeque&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; deque&lt;span&gt;,&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 如果節點存在，將其移動到尾結點&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;deque&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            deque&lt;span&gt;.&lt;/span&gt;&lt;span&gt;moveToBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@GuardedBy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;"evictionLock"&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reorderProbation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Node&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// 檢查試用區是否包含該節點，不包含則證明已經被移除，則不處理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;contains&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
        &lt;span&gt;// 檢查節點的權重是否超過保護區最大值&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;mainProtectedMaximum&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            &lt;span&gt;// 如果超過，將該節點移動到，試用區，尾巴節點，保證超重的節點不會被移動到保護區&lt;/span&gt;
            &lt;span&gt;reorder&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;

        &lt;span&gt;// 更新保護區權重大小&lt;/span&gt;
        &lt;span&gt;setMainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mainProtectedWeightedSize&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPolicyWeight&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在試用區中移除該節點&lt;/span&gt;
        &lt;span&gt;accessOrderProbationDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 在保護區尾節點中添加&lt;/span&gt;
        &lt;span&gt;accessOrderProtectedDeque&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;node&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// 將該節點標記為保護區節點&lt;/span&gt;
        node&lt;span&gt;.&lt;/span&gt;&lt;span&gt;makeMainProtected&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;code&gt;UpdateTask&lt;/code&gt; 修改任務負責變更權重值，並更新節點所在隊列的順序和訪問頻率，這裏我們也能發現，這三個區域的隊列採用了 &lt;strong&gt;LRU 算法&lt;/strong&gt;，一般情況下，&lt;strong&gt;最新被訪問的元素會被移動到尾節點&lt;/strong&gt;。到現在，向有固定容量限制的緩存中調用 &lt;code&gt;put&lt;/code&gt; 方法添加元素的邏輯基本已經介紹完了，目前對 Caffeine 緩存的瞭解程度如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img alt="caffeine-第 2 頁.drawio.png" src="https://oscimg.oschina.net/oscnet//6bcc0e2b5adbb349b35e24c5cb7a2763.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;put&lt;/code&gt; 添加元素時會先直接添加到 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 中，並在 &lt;code&gt;WriteBuffer&lt;/code&gt; 中添加 &lt;code&gt;AddTask/UpdateTask&lt;/code&gt; 任務，&lt;code&gt;WriteBuffer&lt;/code&gt; 是一個 &lt;strong&gt;MPSC&lt;/strong&gt; 的緩衝區，添加成功後會有加鎖的同步機制在默認的 &lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt; 線程池中提交 &lt;code&gt;PerformCleanupTask&lt;/code&gt; 任務，&lt;code&gt;PerformCleanupTask&lt;/code&gt; 任務的主要作用是執行 &lt;code&gt;maintenance&lt;/code&gt; 維護方法，該方法執行前需要先獲取同步鎖，單線程消費 &lt;code&gt;WriteBuffer&lt;/code&gt; 中的任務。執行 &lt;code&gt;AddTask&lt;/code&gt; 任務時會將元素先添加到窗口區，如果是 &lt;code&gt;UpdateTask&lt;/code&gt;，它會修改三個不同區域的雙端隊列，這些隊列採用 LRU 算法，最新被訪問的元素會被放在尾節點處，並且試用區的元素被訪問後會被晉升到保護區尾節點，元素對應的訪問頻率也會在頻率草圖中更新，如果被添加的節點權重超過緩存最大權重會直接被驅逐。（目前維護方法中除了 &lt;code&gt;drainWriteBuffer&lt;/code&gt; 方法外，其他步驟還未詳細解釋，之後會在後文中不斷完善）&lt;/p&gt; 
&lt;hr&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18687082</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18687082</guid>
      <pubDate>Sun, 10 Aug 2025 08:01:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>智譜 AI 發佈 GLM-4.5 技術報告</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;上月底，智譜 AI 正式發佈&lt;a href="https://www.oschina.net/news/362861/glm-4-5"&gt;新一代旗艦模型 GLM-4.5&lt;/a&gt;，專為智能體應用打造的基礎模型。官方稱 「GLM-4.5 在包含推理、代碼、智能體的綜合能力達到開源 SOTA 水平，在真實代碼智能體的人工對比評測中，實測國內最佳。」&lt;/p&gt; 
&lt;p&gt;GLM-4.5 不僅首次突破性地在單個模型中實現了推理、編碼和智能體能力的原生融合，還在 12 項全球公認的硬核測試中取得了全球第三的綜合成績。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0729/095958_jsN7_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;今天 GLM-4.5 技術報告正式發佈。報告不僅詳述了 GLM-4.5 的預訓練與後訓練細節，還介紹了為其打造的開源強化學習（RL）框架 slime，它兼具靈活性、效率與可擴展性，可為模型高效 RL 訓練保駕護航。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;em&gt;報告地址：https://arxiv.org/abs/2508.06471&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;智譜 AI 和清華大學研究團隊採用了多階段的訓練策略，包括在 23T tokens 數據上進行預訓練，以及結合領域特定數據的 「中訓練」（Mid-training），最後通過專家模型迭代和強化學習進行 「後訓練」（Post-training） 。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0811/155334_fWNH_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;模型的特點是與外部工具交互的 「智能體」（Agentic）能力、解決多步問題的 「推理」（Reasoning）能力，以及處理真實軟件工程的 「編碼」（Coding）能力，三中能力都很強，填補了沒有能同時精通這三大核心領域的開源模型的空白。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365521</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365521</guid>
      <pubDate>Sun, 10 Aug 2025 07:53:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Stripe 報告：AI 經濟火箭式增長，營收速度超越 SaaS 三倍</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;金融服務平台 Stripe 發佈&lt;span&gt;最新&lt;/span&gt;分析報告，深入剖析其平台上排名前 100 位的 AI 企業的支付數據，揭示了人工智能經濟正以前所未有的速度蓬勃發展，並在營收增長、全球市場拓展和商業模式創新方面呈現出顯著趨勢。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="238" src="https://oscimg.oschina.net/oscnet/up-9f3b8d22b76edac2a6c228349390ab5a922.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;作為 OpenAI、Anthropic、Midjourney 和 Cohere 等知名 AI 企業的金融服務夥伴，Stripe 對這場技術浪潮中 AI 初創公司從「用户需求」到「企業營收」的加速轉化擁有獨特洞察。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;報告指出，AI 經濟的迅猛發展主要由三大關鍵趨勢驅動：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="text-align:left"&gt;AI 初創公司實現營收里程碑的速度超越以往任何一代科技公司，包括 SaaS 企業;&lt;/li&gt; 
 &lt;li style="text-align:left"&gt;AI 公司在起步階段即同步拓展國際市場，具備「天生全球化」的基因;&lt;/li&gt; 
 &lt;li style="text-align:left"&gt;以及層出不窮的創新商業模式和變現策略，加速了營收增長和市場採納率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;營收增長進入「火箭」模式&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 企業達成關鍵營收里程碑的速度遠超預期。Stripe 平台百強 AI 企業實現&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;100 萬美元年化營收&lt;/strong&gt;的中位用時僅為&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;11.5 個月&lt;/strong&gt;，比營收增長最快的 SaaS 企業還快整整&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;4 個月&lt;/strong&gt;。在達到&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;500 萬美元年化營收&lt;/strong&gt;時，AI 企業的中位用時為&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;24 個月&lt;/strong&gt;，而 SaaS 企業則需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;37 個月&lt;/strong&gt;，AI 公司在此項上快了近一年。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="466" src="https://oscimg.oschina.net/oscnet/up-1831765c86365a8eaca4a2e293203766e0c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;尤其值得注意的是，&lt;strong&gt;2020-2023 年間成立的年輕 AI 公司&lt;/strong&gt;，其營收表現更是驚人:實現&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;100 萬美元年化營收&lt;/strong&gt;僅需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;5 個月&lt;/strong&gt;，而&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;500 萬美元年化營收&lt;/strong&gt;則需&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;13 個月&lt;/strong&gt;。這比 2020 年前成立的 AI 公司分別縮短了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;11 個月&lt;/strong&gt;和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;28 個月&lt;/strong&gt;，平均所需時間減少了三分之二以上。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;強勁的市場需求是推動這一加速增長的根本原因：&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;2023 年，全球企業採用 AI 技術的比例為&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;55%&lt;/strong&gt;，而到 2024 年，這一比例已升至&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;72%&lt;/strong&gt;。&lt;/li&gt; 
 &lt;li&gt;生成式 AI 的企業採納率在同期更是翻了一番。&lt;/li&gt; 
 &lt;li&gt;截至 2024 年 8 月，美國個人用户對 AI 的採用率，大致是個人電腦與互聯網在發展同期的&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;兩倍&lt;/strong&gt;。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;報告中不乏高速增長的案例：&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="238" src="https://oscimg.oschina.net/oscnet/up-1d7ef66917eabe1af1c3c171ccb3a21bb92.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;&lt;strong&gt;Bolt&lt;/strong&gt;:一個允許用户通過提示創建、運行、編輯和部署全棧網頁及移動應用的平台，僅用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;2 個月&lt;/strong&gt;就達到了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;2000 萬美元&lt;/strong&gt;的年度經常性收入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Lovable&lt;/strong&gt;:一個無需編寫代碼即可構建高質量軟件的工具，僅用&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;3 個月&lt;/strong&gt;就實現了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;1700 萬美元&lt;/strong&gt;的年度經常性收入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Cursor&lt;/strong&gt;:一個 AI 驅動的代碼助手，在&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;3 年內&lt;/strong&gt;實現了超過&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;1 億美元&lt;/strong&gt;的年度經常性收入。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;天生全球化：AI 市場滲透無邊界&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;與過去初創企業先深耕本地市場再逐步海外擴張的傳統路徑不同，AI 公司正打破常規，從成立之初便具備國際化基因。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;數據顯示，Stripe 平台上的百強 AI 企業在上線&lt;span&gt;第一&lt;/span&gt;年內銷售覆蓋的國家數量是同期 SaaS 企業的近&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;兩倍&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;（AI 企業平均覆蓋&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;55 個國家&lt;/strong&gt;，SaaS 企業為&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;25 個&lt;/strong&gt;）。這一領先優勢在隨後四年中持續保持，例如上線第四年，AI 企業平均覆蓋&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;104 個國家&lt;/strong&gt;，而 SaaS 企業為&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;57 個&lt;/strong&gt;。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;全球各地對 AI 產品的需求呈現爆發式增長，其中一些增長最快的地區出人意料，如冰島、愛沙尼亞、盧森堡、瑞士和新加坡，正迅速成為人均 AI 採購密度&lt;span&gt;最高&lt;/span&gt;的新興熱點國家和地區。例如，&lt;strong&gt;Midjourney&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;截至 2024 年的業務已覆蓋全球&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;200 多個國家和地區&lt;/strong&gt;，超越了所有其他 Stripe 用户。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;商業應用版圖：從通用到垂直，創新變現層出不窮&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前，大多數 AI 公司仍以行業通用工具為主。在 Stripe 平台上的百強 AI 企業中，有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;80 家&lt;/strong&gt;提供內容生成、聊天機器人或 AI 基礎設施等橫向應用，尚未聚焦於特定行業的深度場景。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;然而，報告也觀察到一個明顯的轉變趨勢:AI 企業正逐步轉向面向特定行業、契合具體業務流程與客户需求的定製化解決方案，這與早期 SaaS 模式的發展路徑如出一轍。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這些垂直化產品不再是對大型語言模型（LLM）的簡單包裝，而是深度嵌入行業工作流、數據體系與場景語境的「原生」智能工具。典型案例包括:&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;醫療保健領域：&lt;strong&gt;Abridge、Nabla 和 DeepScribe&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;房地產營銷：&lt;strong&gt;Studeo&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;建築行業：&lt;strong&gt;SketchPro&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;餐廳預訂：&lt;strong&gt;Slang.ai&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;物業管理：&lt;strong&gt;HostAI&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;法律領域：&lt;strong&gt;Harvey 公司&lt;/strong&gt;的 AI 法律助手，僅在 2024 年一年間，營收就實現了&lt;strong&gt;四倍增長&lt;/strong&gt;，並被眾多《財富》500 強企業採用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;隨着 AI 行業的逐漸成熟，企業正在加速探索更加多元化的變現路徑。除了傳統的訂閲模式，&lt;strong&gt;按用量計費&lt;/strong&gt;和&lt;strong&gt;按成果計費&lt;/strong&gt;模式正日益流行。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;按用量計費&lt;/strong&gt;:根據客户使用 AI 服務的時長、數據量或 API 調用次數進行收費。這種模式使價格與服務成本掛鈎，並降低了客户的使用門檻。例如，協作分析平台&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;Hex&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;藉助 Stripe 實施了按用量計費模式，在上線後短短几個月內，累計處理了&lt;strong&gt;超過 5 億次&lt;/strong&gt;使用量計費事件，運營效率顯著提升。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;strong&gt;按成果計費&lt;/strong&gt;:客户僅在 AI 產生實際結果時才付費。這種模式尤其適合&lt;strong&gt;智能體工作流 （Agentic Workflows）&lt;/strong&gt;，大幅減少了客户的前期投入風險，鼓勵了更多企業嘗試使用 AI。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;儘管用量和成果計費模式在收入預測性方面面臨挑戰，但越來越多的 AI 企業開始引入&lt;strong&gt;預付費模式&lt;/strong&gt;，以緩解現金流壓力並提升收入可預測性，這對於初創早期的 AI 企業尤為適用。&lt;/p&gt; 
&lt;h3 style="margin-left:0; margin-right:0; text-align:left"&gt;智能體商務崛起：AI 重塑交易方式&lt;/h3&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;AI 不僅在改變企業銷售內容，更在重塑交易方式。&lt;strong&gt;AI 智能體&lt;/strong&gt;正逐步承擔傳統人工任務，例如產品調研、下單採購、訂閲管理等，並以自主化方式執行。例如，&lt;strong&gt;ElevenLabs&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;通過語音自動化 AI 智能體處理訂閲與退款事務；&lt;strong&gt;Perplexity 和 Payman&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;則實現了 AI 驅動的無縫支付。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;這場轉變將深刻改變企業與客户之間的互動方式、交易流程乃至底層商業邏輯。它不僅需要更新商業與定價模式（如按用量計費、按成果付費或按價值定價），還要求企業配備支持安全自主交易的技術基礎設施，以匹配 AI 智能體在財務決策中日益重要的角色。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;企業普遍將智能體商務視為未來發展方向。Stripe&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;最新&lt;/span&gt;調研顯示，&lt;strong&gt;53%&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的全球企業高管表示正在為智能體商務做準備，而當被問及「未來兩年內智能體商務的重要性」時，更有&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;63%&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;的受訪者給出了 7 分或以上的評價（滿分 10 分）。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;目前已有數以千計的開發者開始集成圍繞 AI 智能體構建的支付工具，Stripe 的智能體開發工具包每週下載量達數千次，僅 2024 年就有數百家智能體初創公司在 Stripe 上啓動運營，預計 2025 年這一數字將進一步攀升。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365520</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365520</guid>
      <pubDate>Sun, 10 Aug 2025 07:50:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>國內首個隧道與地下空間領域垂直大模型發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;由中國中鐵隧道局隧道掘進機及智能運維全國重點實驗室研發，我國首個隧道與地下空間領域垂直大模型已&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FY7GuioIiJFqrDrYiGqNDJA" target="_blank"&gt;發佈&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;據中國中鐵隧道局隧道掘進機及智能運維全國重點實驗室研發團隊負責人介紹，該模型依託盾構/TBM 工程大數據中心 773 條工程線路，1200 億條工程建造數據，構建了通用大模型調度中小模型驅動的垂直領域大模型技術體系，形成了貫穿隧道與地下空間領域全生命週期場景+AI 的數智互饋賦能技術體系新形態；研發了人機交互深度求索的隧道俠 AI 助手，搭建行業科普、專業問答、行業標準、文本翻譯、專項方案和施組輔助編制功能新引擎；突破大模型對齊與微調技術，研發系列知識與數據場景靶向驅動的中小模型，形成隧道設計 BIM 可視化、隧道施工評估、隧道裝備選型、隧道運維感知與解譯等多個應用數智決策新範式。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="333" src="https://oscimg.oschina.net/oscnet/up-b97d315bfa6693ce8e4c4543c0aa433f3b4.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，該模型已在高原鐵路隧道、崇太長江隧道、深江鐵路珠江口隧道等工程完成驗證，實現隧道建造安全、優質、高效、綠色，推動行業數智化轉型升級。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365507</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365507</guid>
      <pubDate>Sun, 10 Aug 2025 07:38:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Debian 14 將改進對中國龍芯 CPU 架構 LoongArch64 的支持</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&amp;nbsp;Debian 13 「trixie」穩定版已發佈，同時 Debian 團隊&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.debian.org%2Fdebian-devel-announce%2F2025%2F08%2Fmsg00002.html" target="_blank"&gt;宣佈&lt;/a&gt;將在計劃於 2027 年發佈的 Debian 14（代號 「Forky」） 中，顯著改進對中國龍芯 CPU 架構 LoongArch64（簡稱 Loong64）的支持。&lt;/p&gt; 
&lt;p&gt;按照規劃，Loong64 的架構資格認證將在 Forky 開發週期後期進行，但相關軟件包將很快可以提交到 Forky 版本中。&lt;/p&gt; 
&lt;p&gt;值得關注的要點：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;官方支持推進&lt;/strong&gt;：LoongArch64 目前作為非官方移植架構已存在兩年，Debian 14 將在此基礎上進一步推動其成為官方支持的架構，類似於 Debian 13 中對 RISC-V 的官方支持。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;開發節奏&lt;/strong&gt;：Debian 14 的 「unstable」 分支即將開放，開發者和維護者可開始提交 LoongArch64 相關軟件包。架構資格認證將在開發週期後期完成。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;生態建設&lt;/strong&gt;：目前已有約 200 個軟件包完成初步移植，重點在於實現 LoongArch64 架構的「自我託管」能力，即在真實龍芯硬件上獨立完成 Debian 軟件包的構建。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="1358" src="https://static.oschina.net/uploads/space/2025/0811/153832_qPqH_2720166.png" width="1312" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;LoongArch 是龍芯中科自主研發的 CPU 指令集架構，已在多款處理器（如 3A5000、3A6000）中應用。Debian 對其支持的加強，標誌着國產 CPU 在國際主流開源操作系統中的適配進程邁出重要一步，對推動自主可控計算生態具有積極意義。&lt;/p&gt; 
&lt;p&gt;相關鏈接&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;https://wiki.debian.org/LoongArch&lt;/li&gt; 
 &lt;li&gt;https://wiki.debian.org/Ports/loong64&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365506/debian-14-loong64-loongarch</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365506/debian-14-loong64-loongarch</guid>
      <pubDate>Sun, 10 Aug 2025 07:37:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>守護力向新 | deepin 25 磐石：權限「新」固，核心防護！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;div&gt; 
  &lt;p style="text-align:left"&gt;&lt;img align="left" src="https://oscimg.oschina.net/oscnet//9aa0dd269d1f1dc956527ec4581b7c84.jpg" width="900" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;在數字化辦公與開發場景中，系統穩定性與安全性已成為用户核心訴求，基於此 deepin 25 推出磐石系統───以 "只讀防護、快照管理、無憂還原" 三大硬核技術為核心，構建從內核層到應用層的全維度穩定性防護體系，致力於為用户帶來 「磐石般」 的系統保障。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;本文，我們將為大家深入剖析操作系統常見的穩定性痛點，並詳細解讀 deepin 25 磐石系統如何依託創新技術，從根源上築牢系統運行的可靠根基。&lt;/span&gt;&lt;/p&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;一、操作系統常見穩定性問題&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;深入理解系統不穩定的根源，是構建有效防護的前提。以下是幾種典型場景：&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;系統核心文件損壞&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表現：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;系統無法啓動、服務異常終止。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;用户誤操作：如通過 sudo rm 命令誤刪 /usr 等關鍵目錄文件（典型場景：開發者執行高危命令、普通用户誤刪系統文件）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;惡意軟件攻擊：病毒、勒索軟件篡改或刪除系統核心文件（如 /lib 下的動態鏈接庫）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;應用越權修改：部分應用因權限配置錯誤，嘗試寫入軟件包安裝目錄（如 /usr/bin），導致文件衝突或覆蓋。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;系統更新失敗&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表現&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：更新後系統卡在啓動界面、功能模塊異常、服務無法啓動。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;部分更新中斷：傳統系統較為脆弱，若中途斷電或其他錯誤，易導致部分文件未更新完成，系統處於「不完全更新」 狀態。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;配置錯誤與軟件兼容性問題&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表現&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：軟件閃退、功能異常、系統資源佔用過高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;非標準安裝包影響：手動安裝 .run/.bundle 等非 deb 格式軟件時，強制寫入系統核心目錄，破壞文件一致性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;公共場景下的系統污染&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;表現&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：共享設備被安裝惡意軟件、用户設置混亂、隱私數據殘留。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;核心原因&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;多用户操作無隔離：公共電腦缺乏有效還原機制，前一用户的操作（如惡意軟件安裝）影響後續使用者。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;二、磐石系統三大核心技術&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;針對上述核心穩定性挑戰，deepin 25 磐石系統提供了一套完整的解決方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;只讀防護：核心目錄物理級鎖定&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;磐石系統將 /usr、/bin、/lib 等關鍵系統目錄設置為只讀掛載，通過內核級文件系統權限控制，從底層杜絕惡意軟件篡改與用户誤操作風險。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;技術實現：採用分層文件系統，系統核心文件的變動處於可控狀態，只有授權的行為才能改變。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;穩定價值：解決因誤刪誤改系統核心文件導致的系統崩潰問題。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快照管理：秒級回溯系統任意狀態&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;基於 OSTree 的秒級快照技術，實現系統狀態的實時備份與快速恢復：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;自動觸發：系統更新前默認創建快照，系統永遠保留當前狀態與上一個系統備份，更新成功後自動覆蓋掉歷史備份，避免磁盤空間被過度佔用；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;精準恢復：若更新失敗，系統重啓後會自動恢復到更新前狀態，且用户數據（/home）不受影響；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;輕量化存儲：多快照之間相同文件複用，磁盤空間佔用少。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;無憂還原：公共場景的「自淨引擎」&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;針對公用電腦、共享終端等場景，無憂還原功能實現「重啓即清零」：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;基於 OverlayFS 技術方案，將用户的修改寫入臨時層，重啓後自動丟棄&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;可配置白名單目錄（如 /etc/ssh），重啓後不丟失數據，從而保留系統必要配置或者部分用户數據；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;性能損失很小，用户使用基本無感知&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;h2&gt;&lt;strong&gt;&lt;strong&gt;三、安裝 deepin，即刻體驗&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;磐石系統為各類用户提供開箱即用的穩定保障與靈活控制。對於普通用户來説，deepin25 默認開啓只讀保護，開機即可享受系統穩定性保護。提供圖形化的備份恢復機制，使用簡單便捷。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;為滿足開發者和社區愛好者深度調試系統的需求，&lt;/span&gt;&lt;span&gt;&lt;span&gt;磐石系統提供了&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快捷開啓/關閉只讀保護&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;的方法，只需簡單一條命令即可關閉只讀保護。&lt;/span&gt;&lt;/span&gt;&lt;s&gt;&lt;s&gt;&lt;s&gt;關閉後也不影響系統正常使用&lt;/s&gt;&lt;/s&gt;&lt;/s&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 這一設計讓您能在系統穩定性和操作自由度之間，根據實際需求靈活把握「黃金平衡」&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;快速上手指南&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span&gt;安裝部署：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;前往 deepin 官網下載 deepin 25 正式版（支持 AMD64/ARM64/LoongArch 架構）。若您是首次安裝 deepin 操作系統推薦採用全盤安裝，系統盤與數據盤獨立分區。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;應用安裝：兼容 apt/dpkg 命令，可通過該命令安裝/管理 deb 應用。&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;關閉/開啓只讀保護：&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;關閉只讀保護：deepin-immutable-writable enable&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;開啓只讀保護：deepin-immutable-writable disable&lt;/span&gt;&lt;/p&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;系統更新：&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;系統更新兼容 apt 命令：apt dist-upgrade&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;以上便是 deepin 25 磐石系統在穩定性與安全性方面的全面解析，從核心文件的只讀防護到系統狀態的秒級快照回溯，再到公共場景下的無憂還原機制，每一項技術都精準直擊操作系統的常見痛點。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style="text-align:left"&gt;&lt;span&gt;無論你是追求零門檻穩定的普通用户，還是需要靈活開發環境的技術愛好者，都能獲得堅實的系統級守護。歡迎前往 deepin 社區論壇分享你的使用感受，你的每一條建議都是我們持續優化的動力！&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/365505</link>
      <guid isPermaLink="false">https://www.oschina.net/news/365505</guid>
      <pubDate>Sun, 10 Aug 2025 07:35:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
  </channel>
</rss>
