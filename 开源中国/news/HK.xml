<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（香港）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-hk</language>
    <lastBuildDate>Thu, 15 May 2025 16:47:33 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Go 語言讀寫 Excel 基礎庫</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;&lt;img src="https://xuri.me/excelize/images/excelize.svg" alt="Excelize" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;Excelize&lt;/a&gt; 是 Go 語言編寫的一個用來操作 Office Excel 文檔類庫，基於 ECMA-376 Office OpenXML 標準。可以使用它來讀取、寫入 XLSX 文件。相比較其他的開源類庫，Excelize 支持寫入原本帶有圖片 (表) 的文檔，還支持向 Excel 中插入圖片，並且在保存後不會丟失圖表樣式。&lt;/p&gt; 
&lt;h3&gt;安裝&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;go get github.com/xuri/excelize/v2
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;創建 XLSX&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f := excelize.NewFile()
    // Create a new sheet.
    index := f.NewSheet("Sheet2")
    // Set value of a cell.
    f.SetCellValue("Sheet2", "A2", "Hello world.")
    f.SetCellValue("Sheet1", "B2", 100)
    // Set active sheet of the workbook.
    f.SetActiveSheet(index)
    // Save xlsx file by the given path.
    err := f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;讀取已有文檔&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Get value from cell by given worksheet name and axis.
    cell, err := f.GetCellValue("Sheet1", "B2")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cell)
    // Get all the rows in the Sheet1.
    rows, err := f.GetRows("Sheet1")
    for _, row := range rows {
        for _, colCell := range row {
            fmt.Print(colCell, "\t")
        }
        fmt.Println()
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入圖表&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/xuri/excelize/master/test/images/chart.png?version=1" alt="chart" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    categories := map[string]string{"A2": "Small", "A3": "Normal", "A4": "Large", "B1": "Apple", "C1": "Orange", "D1": "Pear"}
    values := map[string]int{"B2": 2, "C2": 3, "D2": 3, "B3": 5, "C3": 2, "D3": 4, "B4": 6, "C4": 7, "D4": 8}
    f := excelize.NewFile()
    for k, v := range categories {
        f.SetCellValue("Sheet1", k, v)
    }
    for k, v := range values {
        f.SetCellValue("Sheet1", k, v)
    }
    err := f.AddChart("Sheet1", "E1", `{"type":"col3DClustered","series":[{"name":"Sheet1!$A$2","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$2:$D$2"},{"name":"Sheet1!$A$3","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$3:$D$3"},{"name":"Sheet1!$A$4","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$4:$D$4"}],"title":{"name":"Fruit 3D Clustered Column Chart"}}`)
    if err != nil {
        fmt.Println(err)
        return
    }
    // Save xlsx file by the given path.
    err = f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入圖片&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"
    _ "image/gif"
    _ "image/jpeg"
    _ "image/png"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Insert a picture.
    err = f.AddPicture("Sheet1", "A2", "./image1.png", "")
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture to worksheet with scaling.
    err = f.AddPicture("Sheet1", "D2", "./image2.jpg", `{"x_scale": 0.5, "y_scale": 0.5}`)
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture offset in the cell with printing support.
    err = f.AddPicture("Sheet1", "H2", "./image3.gif", `{"x_offset": 15, "y_offset": 10, "print_obj": true, "lock_aspect_ratio": false, "locked": false}`)
    if err != nil {
        fmt.Println(err)
    }
    // Save the xlsx file with the origin path.
    err = f.Save()
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;還有其他一些功能，在這裏就不一一列舉了，詳細使用文檔以及獲取後期的維護更新可以從項目的主頁獲取&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;github.com/xuri/excelize&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/xuri/blog/3057381</link>
      <guid isPermaLink="false">https://my.oschina.net/xuri/blog/3057381</guid>
      <pubDate>Sat, 10 May 2025 10:24:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>AI 推理大模型或在一年內減緩增長</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 研究機構 Epoch AI 發佈&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fepoch.ai%2Fgradient-updates%2Fhow-far-can-reasoning-models-scale" target="_blank"&gt;《推理模型能擴展多遠（How far can reasoning models scale?）》&lt;/a&gt;報告，其中對推理模型的現狀和未來作出了分析總結。&lt;/p&gt; 
&lt;p&gt;Epoch AI 通過各家開源的技術報告，來分析了目前推理模型的訓練成本，同時也進一步總結，目前前沿的推理模型其推理訓練規模仍未見頂，還能持續擴展（scalable），並且推理模型還有潛力在短期內快速實現能力拓展。&lt;/p&gt; 
&lt;p&gt;Epoch AI 的分析表明，人工智能行業可能無法在更長的時間內從推理人工智能模型中獲得巨大的性能提升。根據該報告的研究結果，推理模型的進展最快可能在一年內放緩。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2b0a64ac6bff63c39819e86da31b4e92548.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;近幾個月來，OpenAI 的 o3 等推理模型在人工智能基準測試中取得了大幅提升，尤其是在衡量數學和編程技能的基準測試中。這些模型可以對問題進行更多計算，從而提高性能，但缺點是它們完成任務的時間比傳統模型更長。&lt;/p&gt; 
&lt;p&gt;Epoch AI 提到，如果推理階段的算力需求見頂，那麼其帶來的增長率將收斂，大概是每年增長 4 倍，不會像 o1 到 o3 那樣擁有「跳躍式增長」——幾個月增長 10 倍的態勢。&lt;/p&gt; 
&lt;p&gt;基於上述情況，Epoch AI 表示，如果推理模型的訓練階段只比前沿推理模型低幾個（比如説不到三個）數量級，這種增長率可能在一年內減緩。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</guid>
      <pubDate>Sat, 10 May 2025 10:16:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>這就是 univer</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;零. 開篇&lt;/h1&gt; 
&lt;div&gt;
  這篇文章旨在幫助新人快速熟悉開源項目 univer 的架構及代碼，也是我過去一段時間參與到 univer 開發中的學習和總結，肯定有不夠準確或者理解偏差，歡迎大家評論指正 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第壹章，會聊聊我對 univer 架構的理解，univer 是如何拆分模塊，以及模塊之間的依賴關係。然後將 univer 放入 MVC 的架構模式中，分別分析下其模型層、視圖層、控制器的邊界和職責 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第貳章，我們先來看看 univer sheet 的模型層數據結構設計，如何區分 workbook、sheet、row、column、style 等，瞭解他們的包含關係，這對後面深入理解代碼是有幫助的 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第叁、肆章，我將從兩條控制鏈路來分析 univer 的代碼，一條鏈路是 univer 啓動和初始化渲染的過程。在這條鏈路中，是從模型層到視圖層的過程。另外一條鏈路是 univer 響應用户事件，並且觸發模型層數據變更，頁面重新渲染，在這條鏈路中，是從視圖層到模型層的過程。在這兩部分，我們會涉及到大量的源碼分析，在保留代碼主邏輯的前提，刪除了邊界 case 的代碼。同時在每個代碼塊第一行，表示該代碼塊所在的 TS 文件，這樣便於直接閲讀源碼 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;壹. 對代碼架構的理解&lt;/h1&gt; 
&lt;blockquote&gt; 
 &lt;div&gt;
   外表的美只能取悦於人的眼睛，而內在的美卻能感染人的靈魂。 ——伏爾泰 
 &lt;/div&gt; 
&lt;/blockquote&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;Univer 中的模塊拆分和依賴關係&lt;/h2&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;無依賴環原則&lt;/h3&gt; 
&lt;div&gt;
  軟件架構的規則其實就是排列組合代碼塊的規則，軟件架構會根據業務域來將組織項目代碼，將項目拆分成不同的模塊，各個模塊做到關注點分離，同時模塊之間有明確的依賴關係，並且依賴關係是一個單向無環圖，也就是 
 &lt;strong&gt;無依賴環原則&lt;/strong&gt;。正如下面圖中所示，系統級、應用級業務邏輯是整個項目最核心的部分，同時也是應用最穩定的部分，應該放在架構的最裏層，其他如用户界面、渲染引擎、前端框架、持久化的數據庫，這些在架構演進的過程中，可能被替換，所以他們都依賴於最中心的業務實體，置於外層 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp;&amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img align="left" alt="" height="327" src="https://oscimg.oschina.net/oscnet/up-3ab4dcd10c5e846f57c70e486ce2f37951d.png" width="340" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;（圖注：core、base-sheet、base-render、base-ui、ui-plugin-sheet 對應倉庫中 packages 下不同文件夾）&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer 在整個架構設計中，儘量保證核心模塊（core）僅包含最核心的業務邏輯，在核心業務邏輯之上所構築的其他功能，都是通過插件化來提供的，這也是 
 &lt;strong&gt;微內核架構&lt;/strong&gt;的思想。在上圖中，base-render、base-ui、base-sheet 等都是插件化的，為 core 提供額外的能力。如 base-sheet 完善 sheet 相關功能，base-render（canvas 渲染引擎） 提供 canvas 渲染能力，公式引擎提供公式相關的計算和解析等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;依賴反轉&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  直觀理解，我們可能會認為，core 模塊依賴於 base-render 模塊來做 canvas 渲染，依賴 base-ui 來做頁面框架渲染及樣式菜單等，base-ui 又依賴於 React 框架來渲染組件。這樣會有一個問題，核心模塊依賴於其他模塊，其他模塊往往是不穩定的，比如樣式菜單，我們可能會經常改變位置或者樣式，這也有可能導致核心模塊易變。在 Univer 中，利用了 
 &lt;strong&gt;依賴反轉（Dependency Inversion）&lt;/strong&gt;解決上面面臨的問題，這也就是上面圖中，所有的外面的環都依賴內部的環，而內部的環不能依賴外部環。在 Univer 中引入了 
 &lt;strong&gt;依賴注入（DI）&lt;/strong&gt;，通過依賴注入的方式，反轉依賴，避免了核心層對外層的依賴，通過下面代碼示例來解釋會更清晰一些 
&lt;/div&gt; 
&lt;div&gt;
  舉個例子，在沒有依賴注入，我們可能會寫這樣的代碼： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    private _commandService = new CommandService(); 
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼中，SheetPlugin 類依賴於 CommandService 類，CommandService 類中方法的變更直接會影響到 SheetPlugin，SheetPlugin 可能也需要修改，導致 SheetPlugin 的不穩定 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="256" src="https://oscimg.oschina.net/oscnet/up-d90622f22bde7a5dae35b7fe4953a7dff37.png" width="812" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  我們通過依賴注入，代碼如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    constructor(
        // ...
        @ICommandService private readonly _commandService: ICommandService,
        // ...
    )

    otherMethod(){
        this._commandService.registerCommand(SomeCommand);
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面的代碼中，聲明瞭 _commandService 屬性擁有 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口，通過相關的依賴綁定，就可以在 SheetPlugin 的方法中調用 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口所定義的方法了。這樣 SheetPlugin 依賴於 ICommandService 接口，同時 CommandService 類實現了這個接口。這樣就解耦了 SheetPlugin 和 CommandService 之間的直接依賴關係，圖示如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="274" src="https://oscimg.oschina.net/oscnet/up-9fb80a8045b6fa4c8ac48c0f51d982460ba.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  如上圖，我們通過 ICommandService 接口實現依賴反轉，在沒有 ICommandService 接口下，SheetPlugin 直接依賴於 CommandService，導致核心業務邏輯（SheetPlugin）的不穩定。通過引入 ICommandService 接口，及依賴注入，如果將虛線框看成一個整體，CommandService 類指向（實現接口）虛線框，最終實現依賴反轉，保證了核心業務邏輯穩定性 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;淺談 Univer 中的 MVC 架構模式&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="293" src="https://oscimg.oschina.net/oscnet/up-bacff8d1ee26d5039c6ff41f3b7489fef0d.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  MVC 在整個 GUI 編程領域已經有了 50 多年的歷史了，但是 MVC 卻一直沒有一個明確的定義。如上圖，就是兩種比較典型的 MVC 變種，在 
 &lt;strong&gt;MVC with ASP.NET&lt;/strong&gt; 中，控制器負責管理視圖和模型，當控制器改變模型層中數據後，通過一些訂閲機制，視圖層直接讀取模型層中數據，更新視圖。在 
 &lt;strong&gt;MVC with Rails &lt;/strong&gt;中，視圖層不直接和模型層交互，通過控制器做了一層代理，視圖層需要通過控制器從模型層取數據進行渲染。這樣有個好處就是視圖層和模型層完全的解耦，控制流會更清晰 
&lt;/div&gt; 
&lt;div&gt;
  打開 univer 工程代碼，我們可以發現大量以 
 &lt;code&gt;controller&lt;/code&gt; 、 
 &lt;code&gt;view&lt;/code&gt; 和 
 &lt;code&gt;model&lt;/code&gt;後綴命名的文件，大致也能看出其採用了傳統的 MVC 架構模式。Univer 中 MVC 架構更類似於 
 &lt;strong&gt;MVC with Rails&lt;/strong&gt;, 因為視圖層不直接讀取 Model 層數據，也不訂閲模型層的改變（下面會提到，是訂閲了 Mutations），而是做了一層數據緩存（類似 ViewModel）， 
 &lt;u&gt;SheetSkeleton &lt;/u&gt;類 
&lt;/div&gt; 
&lt;div&gt;
  在最開始看工程代碼時，一些疑慮一直縈繞在腦海： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 是如何組織和管理模型層的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 中控制器有哪些職責，如何保證控制器代碼架構清晰？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 的視圖層怎麼組織和管理的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  閲讀源碼，談談 Univer 如何從架構層面回答上面的問題 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;模型層（Model）&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  Univer 的整個模型層會比較薄，拿 univer sheet 來舉例，在 core 模塊中，通過 
 &lt;u&gt;Workbook&lt;/u&gt; 和 
 &lt;u&gt;Worksheet&lt;/u&gt; 類來管理和 sheet 相關的模型數據，提供了相關模型數據存儲和管理的工作。如在 
 &lt;u&gt;Worksheet&lt;/u&gt; 類中，有 
 &lt;code&gt;row-manager&lt;/code&gt;、 
 &lt;code&gt;column-manager&lt;/code&gt;、相關的類和方法來管理每個 sheet 模型數據，拿 
 &lt;code&gt;row-manager&lt;/code&gt;來説，我們可以獲取表格行的一些信息和數據： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;getRowData(): ObjectArray&amp;lt;IRowData&amp;gt;;
getRowHeight(rowPos: number): number;
getRowOrCreate(rowPos: number): IRowData;
// ...&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  很容易理解，我們渲染的數據不能夠直接使用底層模型數據，往往需要經過一定的計算，生成一個用於渲染的「模型層」才能用於直接的視圖渲染。比如在渲染視圖的時候，我們需要計算行、列的總高度。通過每行的文檔內容，計算能夠容納數據的最小行高度。通過一系列的計算，最終確定 sheet 頁面的佈局，用於最終的渲染。而這一系列的計算都放在了視圖層 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 類中 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;控制器（Controller）的職責&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img alt="" height="428" src="https://oscimg.oschina.net/oscnet/up-95ce27fa3497387181c703081a693a984be.png" width="600" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在傳統的 MVC 架構中，視圖和模型層往往職責比較明晰，而控制器承擔了主要的業務邏輯，和管理視圖層、模型層的任務，往往會比較臃腫，那麼 univer 是如何避免控制器臃腫的呢？在 Univer 中，控制器（MVC 中的控制器）進一步拆解為 
 &lt;strong&gt;Controllers&lt;/strong&gt;（Univer 中狹義的控制器）、 
 &lt;strong&gt;Commands&lt;/strong&gt; 和 
 &lt;strong&gt;Services&lt;/strong&gt;。同時在控制器中，幾乎包含了 univer 所有的業務邏輯，他們各司其職，保證了 univer 應用的正常運行 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Controllers 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    初始化一些渲染邏輯和事件的監聽，如在 
   &lt;u&gt;SheetRenderController 類&lt;/u&gt;中，在應用 
   &lt;code&gt;Rendered&lt;/code&gt;生命週期執行，會去初始化頁面的數據刷新（_initialRenderRefresh），會去監聽 Commands 的執行，涉及到 Mutation 修改模型層，還會觸發頁面渲染邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和視圖層交互，拿到視圖層的一些數據信息。如在 
   &lt;u&gt;AutoHeightController &lt;/u&gt;類中，會根據 Commands 所需，通過視圖層計算 sheet 自動行高 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    綁定 UI 事件，如在 
   &lt;u&gt;HeaderResizeController &lt;/u&gt;類中，會在應用 
   &lt;code&gt;Rendered&lt;/code&gt;生命週期執行，在初始化中，為 spreadsheetRowHeader、spreadsheetColumnHeader 綁定 hover 事件，顯示和隱藏 resize header（用於調節行列高度和寬度），也為 resize header 綁定 pointer down/move/up 等事件，這樣 resize header 就會響應拖拽移動，處理相關用户操作，最終也會反應到模型層的修改和視圖層的更新 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Commands 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Commands 可以理解為用户的單次交互操作，比如合併單元格、清除選區、插入行列、設置單元格樣式等，並且更改模型層，觸發視圖層渲染。 
 &lt;code&gt;Commands&lt;/code&gt; 有三種類型： 
 &lt;code&gt;COMMAND&lt;/code&gt;、 
 &lt;code&gt;MUTATION&lt;/code&gt;、 
 &lt;code&gt;OPERATION&lt;/code&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;COMMAND&lt;/strong&gt; 就是用户的一次交互操作，有用户行為觸發，可以派生出另外一個 
   &lt;code&gt;COMMAND&lt;/code&gt;，比如用户點擊菜單中 text wrap 菜單項，會觸發 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt;， 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt; 會派生出 
   &lt;code&gt;SetStyleCommand&lt;/code&gt; 統一處理所有樣式的更改。一個 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生另外一個 
   &lt;code&gt;COMMAND&lt;/code&gt;，但是不能分叉，因為我們需要在 
   &lt;code&gt;COMMAND&lt;/code&gt; 中處理 undo/redo 相關操作（後面 undo/redo 可能會移到數據層）。但是一個 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生出多個 
   &lt;code&gt;MUTATION&lt;/code&gt; 和 
   &lt;code&gt;OPERATION&lt;/code&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;MUTATION&lt;/strong&gt; 可以理解為對模型層數據的原子操作，比如 
   &lt;code&gt;SetRangeValuesMutation&lt;/code&gt; 修改選區範圍內的單元格樣式和值， 
   &lt;code&gt;SetWorksheetRowHeightMutation&lt;/code&gt;修改選區範圍內行的高度。MUTATION 的執行，不僅會修改模型數據，同時也會觸發視圖的重新渲染。MUTATION 中修改的數據需要處理協同，和解決協同中的衝突 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;OPERATION&lt;/strong&gt; 是對應用狀態的變更，是應用的某個臨時狀態，如頁面滾動位置、用户光標位置、當前的選區等，不涉及到協同和解決衝突的問題，主要用於之後 live share （類似於飛書的 magic share）等功能 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Services 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Services 為整個 Univer 應用提供各種服務，是關注點分離（Separate of concern）在 Univer 項目架構中的承載者 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    管理應用生命週期，如 
   &lt;u&gt;LifecycleService &lt;/u&gt;類，保存應用生命週期的狀態值，並提供 
   &lt;code&gt;subscribeWithPrevious&lt;/code&gt;方法供其他模塊訂閲應用生命週期狀態值的變更，並做響應任務執行，如依賴的初始化等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理應用的 History 操作和存儲歷史操作，這樣用户可以 undo/redo 之前的操作。在 
   &lt;u&gt;LocalUndoRedoService &lt;/u&gt;類中，通過 
   &lt;code&gt;pushUndoRedo&lt;/code&gt; 方法將 undo/redo 信息推入棧中，通過 
   &lt;code&gt;updateStatus&lt;/code&gt; 方法觸發 undo/redo 操作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理網絡 IO 和 websocket 鏈接 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  總結一下，將上面 Controllers、Commands、Services 統稱為 MVC 中的控制器，他們完成了 univer 中大量業務邏輯，下面列舉了其主要職責（在叁、肆部分，會更加詳細的分析控制器是如何工作的）： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    負責整個應用的生命週期管理 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    綁定和響應 UI 事件，如雙擊、光標移動等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    控制視圖的渲染和觸發渲染的邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和視圖層通信，如拿計算後頁面佈局信息 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通過 Command/Mutation 改變模型層，觸發界面渲染 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理 undo/redo 相關工作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    負責協作、和網絡 IO 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;視圖層（View）&lt;/h3&gt; 
&lt;div&gt;
  在 Univer 中，有兩種渲染方式：一種是 Canvas 渲染引擎，一種是 React 通過 DOM 進行渲染。Canvas 渲染引擎主要渲染 sheet 的主體部分：行表頭、列表頭、sheet 單元格、選區、單元格編輯器等。React 主要用於渲染頂部菜單欄、右鍵菜單欄、浮窗等 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 主體部分選用 Canvas 進行渲染，保證了在大數據量下表格渲染的極致性能體驗，和流暢的動畫效果。而菜單主要需要響應用户事件，DOM 往往比 Canvas 更具優勢 
&lt;/div&gt; 
&lt;div&gt;
  Canvas 渲染所需要的組件、服務都在 
 &lt;code&gt;base-render&lt;/code&gt;文件夾中，如 sheet 渲染相關的： 
 &lt;u&gt;Spreadsheet、SpreadsheetRowHeader、SpreadsheetColumnHeader &lt;/u&gt;等。同時在 Canvas 組件上定義了一套事件響應機制，保證了各個組件能夠獨立響應事件，但是並不會在視圖層處理這些事件。這些事件都需要在 Controllers 中處理 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;code&gt;Base-ui/Components&lt;/code&gt; 文件夾中代碼負責菜單基礎組件的渲染和用户事件的發佈，base-ui 模塊也負責整個應用的框架渲染。如在 
 &lt;u&gt;DesktopUIController &lt;/u&gt;類中，bootstrapWorkbench 啓動了整個應用框架渲染，以及 Canvas 元素的掛載等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_13"&gt;&lt;/span&gt; 
&lt;h1&gt;貳. Univer sheet 數據結構&lt;/h1&gt; 
&lt;div&gt;
  瞭解一個項目，先從其數據結構開始 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 相關的數據類型定義在 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Ftree%2Fdev%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces" rel="nofollow" target="_blank"&gt;Interfaces&lt;/a&gt; 文件夾中，包含關係如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="576" src="https://oscimg.oschina.net/oscnet/up-538aaa85e011f7227788f7d59ab0abe1447.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer sheet 整體的數據類型定義如上圖所示，一個 workbook 包含多個 sheets，sheets 所引用的 styles 字段定義在了頂層 workbook 上，保證了樣式的複用，減少內存開銷，這也是和 Excel 保持一致。在 IWorksheetConfig 中，定義了 cellData 字段，這是一個二維矩陣，用於持久化單元格信息，也就是 ICellData 中定義的類型信息， 
 &lt;strong&gt;p 是指富文本，接口類型 IDocumentData，也就是一篇 univer doc，這也是 univer 設計的獨到之處，univer sheet 的每個單元格都可以轉變成一個 univer doc。&lt;/strong&gt;s 字段大多是一個字符串 id，指向 IWorkbookConfig 中 styles 字段，從中檢索出該單元格的樣式信息 
&lt;/div&gt; 
&lt;div&gt;
  圖中並沒有包含各個接口定義的所有字段，想了解更多，建議直接查看上面的 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2F9a505ec3ba9de96677b9caaa821e287e71ebe0cf%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces%2FIWorkbookData.ts%23L12" rel="nofollow" target="_blank"&gt;類型定義文件&lt;/a&gt;，上面也有相應註釋 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_14"&gt;&lt;/span&gt; 
&lt;h1&gt;叁. 應用啓動到渲染的過程&lt;/h1&gt; 
&lt;div&gt;
  Univer 如何渲染頁面，其實就是 univer 應用啓動的整個過程，也是模型層到視圖層的整個過程。在瞭解頁面渲染前，我們先了解下 univer 的生命週期，其實在上面 Services 部分也有所提及 
&lt;/div&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;應用的生命週期&lt;/h2&gt; 
&lt;pre&gt;&lt;code class="language-javascript"&gt;export const enum LifecycleStages {
    /**
     * Register plugins to Univer.
     */
    Starting,
    /**
     * Univer business instances (UniverDoc / UniverSheet / UniverSlide) are created and services or controllers provided by
     * plugins get initialized. The application is ready to do the first-time rendering.
     */
    Ready,
    /**
     * First-time rendering is completed.
     */
    Rendered,
    /**
     * All lazy tasks are completed. The application is fully ready to provide features to users.
     */
    Steady,
}&lt;/code&gt;&lt;/pre&gt; 
&lt;div&gt;
  Univer 生命週期有四個階段， 
 &lt;code&gt;Starting&lt;/code&gt;、 
 &lt;code&gt;Ready&lt;/code&gt;、 
 &lt;code&gt;Rendered&lt;/code&gt; 和 
 &lt;code&gt;Steady&lt;/code&gt;。如在 Starting 階段去註冊各個插件到 univer 上面，在 Ready 階段實例化 UniverSheet，並且執行各個插件的初始化函數，Rendered 階段完成首次渲染，Steady 階段，應用完成啓動，用户可以使用完整功能 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;各個生命週期狀態在什麼時候觸發呢？&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Starting 狀態&lt;/strong&gt;：在 
 &lt;code&gt;_tryStart&lt;/code&gt;方法中， 
 &lt;u&gt;LifecycleService &lt;/u&gt;類實例化，應用進入 Staring 階段， 
 &lt;strong&gt;在這個階段也會去執行插件的 onStarting 鈎子函數&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Ready 狀態&lt;/strong&gt;：在實例化 
 &lt;u&gt;UniverSheet&lt;/u&gt; 後，在 
 &lt;code&gt;_tryProgressToReady&lt;/code&gt;方法中，設置 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值為 Ready， 
 &lt;strong&gt;在這個階段也會執行各個插件的 onReady 鈎子函數&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Rendered 狀態&lt;/strong&gt;：在 
 &lt;u&gt;DesktopUIController&lt;/u&gt; 中，bootStrap 整個應用後，標記 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值為 Rendered 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Steady 狀態&lt;/strong&gt;：在 Rendered 狀態後，延遲 3000 秒觸發 Steady 狀態 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  通過 @OnLifecycle 註解，我們可以精確控制某個類在什麼生命週期階段實例化，如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {
    //...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼中，SheetRenderController 將在 Rendered 階段實例化 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt; 
&lt;h2&gt;啓動到渲染的整個過程&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-92859da81dc29e5183cf26c4e682302d65b.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第一步：&lt;/strong&gt;創建 
 &lt;u&gt;Univer &lt;/u&gt;實例、註冊 sheet 所需的相關插件和創建 univer sheet 實例 
&lt;/div&gt; 
&lt;div&gt;
  註冊的插件及相關功能如下： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-docs：用於單元格和公式的編輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-render：Canvas 渲染引擎，也包含 sheet、doc、slide 所需的基礎組件，負責 Canvas 渲染整個過程 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-sheets：管理 sheet canvas 相關的渲染，如 row header、column header、單元格等，同時也處理大量 sheet 相關業務邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-ui：管理 React DOM 渲染的基礎組件，如菜單相關的組件。同時也負責整個 univer sheet 頁面框架的渲染，以及和用户交互的操作都會放在這個插件中，如快捷鍵註冊、複製、剪切黏貼等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    ui-plugin-sheets：負責一些基礎 UI 的渲染和業務邏輯，如右鍵菜單、單元格富文本編輯相關的任務 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  插件註冊完成，通過 createUniverSheet 方法，創建 univer sheet 實例 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;/**
 * Create a univer sheet instance with internal dependency injection.
 */
createUniverSheet(config: Partial&amp;lt;IWorkbookConfig&amp;gt;): Workbook {
    let workbook: Workbook;
    const addSheet = () =&amp;gt; {
        workbook = this._univerSheet!.createSheet(config);
        this._currentUniverService.addSheet(workbook);
    };

    if (!this._univerSheet) {
        this._univerSheet = this._rootInjector.createInstance(UniverSheet);

        this._univerPluginRegistry
            .getRegisterPlugins(PluginType.Sheet)
            .forEach((p) =&amp;gt; this._univerSheet!.addPlugin(p.plugin as unknown as PluginCtor&amp;lt;any&amp;gt;, p.options));
        this._tryStart();
        this._univerSheet.init();
        addSheet();

        this._tryProgressToReady();
    } else {
        addSheet();
    }

    return workbook!;
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  通過上面代碼，我們可以看到，univer 將上面註冊的插件中 PluginType.Sheet 類型的插件，重新註冊到了 univerSheet 實例上，然後通過 _tryStart 應用進入 Starting 階段，然後初始化，通過 addSheet 實例化 
 &lt;u&gt;Workbook&lt;/u&gt;，完成了模型層的初始化。到這裏模型數據準備完畢，univer 進入到 Ready 階段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第二步&lt;/strong&gt;：初始化頁面框架，渲染頁面框架 
&lt;/div&gt; 
&lt;div&gt;
  在上面講述 Univer 應用生命週期時，提到過插件會在 univer 不同的生命週期執行，在這一步，我們重點關注 base-ui 插件 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// base-ui-plugin.ts
override onStarting(_injector: Injector): void {
    this._initDependencies(_injector);
}

override onReady(): void {
    his._initUI();
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt;
    如上代碼，base-ui 插件在 onStarting 階段會去聲明和添加依賴，在 onReady 階段，會去初始化渲染整個頁面框架，將 View 界面掛載到 container 上。 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;pre&gt;&lt;code class="language-javascript"&gt;// ui-desktop.controller.tsx
bootstrapWorkbench(options: IWorkbenchOptions): void {
    this.disposeWithMe(
        bootStrap(this._injector, options, (canvasElement, containerElement) =&amp;gt; {
            this._initializeEngine(canvasElement);
            this._lifecycleService.stage = LifecycleStages.Rendered;
            this._focusService.setContainerElement(containerElement);

            setTimeout(() =&amp;gt; (this._lifecycleService.stage = LifecycleStages.Steady), STEADY_TIMEOUT);
        })
    );
}
// ...
function bootStrap(
    injector: Injector,
    options: IWorkbenchOptions,
    callback: (canvasEl: HTMLElement, containerElement: HTMLElement) =&amp;gt; void
): IDisposable {
    let mountContainer: HTMLElement;
    // ...
    const root = createRoot(mountContainer);
    const ConnectedApp = connectInjector(App, injector);
    const desktopUIController = injector.get(IUIController) as IDesktopUIController;
    const onRendered = (canvasElement: HTMLElement) =&amp;gt; callback(canvasElement, mountContainer);

    function render() {
        const headerComponents = desktopUIController.getHeaderComponents();
        const contentComponents = desktopUIController.getContentComponents();
        const footerComponents = desktopUIController.getFooterComponents();
        const sidebarComponents = desktopUIController.getSidebarComponents();
        root.render(
            &amp;lt;ConnectedApp
                {...options}
                headerComponents={headerComponents}
                contentComponents={contentComponents}
                onRendered={onRendered}
                footerComponents={footerComponents}
                sidebarComponents={sidebarComponents}
            /&amp;gt;
        );
    }

    // ...
    render();
    // ...
}&lt;/code&gt;&lt;/pre&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼可以看到，在頁面框架掛載並渲染完成後，會去完成 canvas 渲染引擎容器掛載及調整 canvas 尺寸，整個應用進入 Rendered 階段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：渲染 canvas 界面，完成整個渲染過程 
&lt;/div&gt; 
&lt;div&gt;
  其實這個過程在應用 Ready 階段就已經開始了 sheet canvas 的初始化和組件組裝和添加 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-canvas-view.ts
@OnLifecycle(LifecycleStages.Ready, SheetCanvasView)
export class SheetCanvasView {
    // ...
    constructor(
        // ...
    ) {
        this._currentUniverService.currentSheet$.subscribe((workbook) =&amp;gt; {
            // ...
            const unitId = workbook.getUnitId();
            if (!this._loadedMap.has(unitId)) {
                this._currentWorkbook = workbook;
                this._addNewRender();
                this._loadedMap.add(unitId);
            }
        });
    }

    private _addNewRender() {
        // ...
        if (currentRender != null) {
            this._addComponent(currentRender);
        }
        const should = workbook.getShouldRenderLoopImmediately();
        if (should &amp;amp;&amp;amp; !isAddedToExistedScene) {
            engine.runRenderLoop(() =&amp;gt; {
                scene.render();
            });
        }
        // ...
    }

    private _addComponent(currentRender: IRender) {
        // ...
        currentRender.mainComponent = spreadsheet;
        currentRender.components.set(SHEET_VIEW_KEY.MAIN, spreadsheet);
        currentRender.components.set(SHEET_VIEW_KEY.ROW, spreadsheetRowHeader);
        currentRender.components.set(SHEET_VIEW_KEY.COLUMN, spreadsheetColumnHeader);
        currentRender.components.set(SHEET_VIEW_KEY.LEFT_TOP, SpreadsheetLeftTopPlaceholder);
        // ...
        this._sheetSkeletonManagerService.setCurrent({ sheetId, unitId });
    }

    private _addViewport(worksheet: Worksheet) {
        // ...
        scene
            .addViewport(
                viewMain,
                viewColumnLeft,
                viewColumnRight,
                viewRowTop,
                viewRowBottom,
                viewLeftTop,
                viewMainLeftTop,
                viewMainLeft,
                viewMainTop
            )
            .attachControl();
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代碼，其實就是 sheet canvas 渲染的整個過程，首先會去訂閲 
 &lt;code&gt;currentSheet$&lt;/code&gt;，如果該 sheet 沒有被 render 過，那麼就會調用 
 &lt;code&gt;_addNewRender&lt;/code&gt; 方法，添加 sheet 所需的 canvas 渲染組件，添加 viewport，然後將 scene 的渲染添加到渲染引擎的渲染循環中（runRenderLoop） 
&lt;/div&gt; 
&lt;div&gt;
  在上面過程，完成了 sheet 所需 canvas 組件的組裝以及添加 viewport，那麼 canvas 的首次渲染髮生在什麼地方呢？和什麼生命週期階段呢？sheet canvas 的渲染被 
 &lt;u&gt;SheetRenderController &lt;/u&gt;類所管理，該類管理了 sheet canvas 的初始化渲染以及監聽 Mutations 的變更，然後按需渲染 Canvas 界面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面的代碼可以看到，sheet canvas 的渲染時間點是在整個應用 Rendered 階段，其實也好理解，這個階段，頁面框架才完成掛載到 container 上，同時 sheet canvas 也完成了初始化工作。在 Rendered 階段，會去訂閲 currentSkeleton$ 改變，然後去更新 skeleton，完成頁面首次渲染。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
         his._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                // ...
                if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                         ,
                        true
                    );
                }

                 this._sheetSkeletonManagerService.setCurrent({
                    unitId,
                    sheetId,
                    commandId: command.id,
                });
           }

            this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
        })
    );
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代碼發生在 
 &lt;u&gt;SheetRenderController &lt;/u&gt;類，在 _commandExecutedListener 方法中，會去監聽 Command 執行，如果在 
 &lt;code&gt;COMMAND_LISTENER_SKELETON_CHANGE&lt;/code&gt; 列表內，標記當前 skeleton 為 dirty，mainComponent 為 dirty，這樣 Canvas 渲染引擎就會在下個渲染循環中重新渲染頁面了 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：單元格編輯器初始化 
&lt;/div&gt; 
&lt;div&gt;
  其實在第三步，基本已經完成了整個 sheet 界面的渲染，我們再來關注一下單元格編輯器的初始化過程。在應用 Rendered 階段，univer 會去初始化兩個 Doc 實例，一個用於單元格的編輯，另一個用於公式輸入框的編輯。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// initialize-editor.controller.ts
private _initialize() {
    this._currentUniverService.createDoc({
        id: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
    // create univer doc formula bar editor instance

    this._currentUniverService.createDoc({
        id: DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  同樣在 Rendered 階段， 
 &lt;u&gt;EditorBridgeController &lt;/u&gt;類實例化時，會去初始化相關的事件監聽，如雙擊單元格，單元格進入編輯模式。但是直到 Steady 階段， 
 &lt;u&gt;StartEditController &lt;/u&gt;類才完成實例化，單元格編輯才能完全可交互 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;肆. 界面如何響應用户操作？&lt;/h1&gt; 
&lt;div&gt;
  下面的時序圖描述了當用户點擊 text wrap 菜單項，univer 從響應事件到界面渲染的整個過程 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="819" src="https://oscimg.oschina.net/oscnet/up-5858c5e9fc2871f877345efca1f3aa5a740.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  第一步：用户點擊菜單中 text wrap 菜單項。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // menu.ts
 export function WrapTextMenuItemFactory(accessor: IAccessor): IMenuSelectorItem&amp;lt;WrapStrategy&amp;gt; {
    // ...
    return {
        id: SetTextWrapCommand.id,
        // ...
    };
}
// ToolbarItem.tsx
 &amp;lt;Select
    // ...
    onClick={(value) =&amp;gt; {
        let commandId = id;
        // ...
        commandService.executeCommand(commandId, value);
     }}
     // ...
 /&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面是菜單欄中 text wrap 菜單項的 Select 組件，可以看到在上面綁定了 click 事件處理函數，當點擊後，commandService 將執行 commandId，也就是在 WrapTextMenuItemFactory 中配置的 id 值：SetTextWrapCommand 的 id 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第二步：在 SetTextWrapCommand 中，包裝一下參數，然後執行了統一設置樣式的 Command，SetStyleCommand 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;export const SetTextWrapCommand: ICommand&amp;lt;ISetTextWrapCommandParams&amp;gt; = {
    type: CommandType.COMMAND,
    id: 'sheet.command.set-text-wrap',
    handler: async (accessor, params) =&amp;gt; {
        // ...
        const commandService = accessor.get(ICommandService);
        const setStyleParams: ISetStyleParams&amp;lt;WrapStrategy&amp;gt; = {
            style: {
                type: 'tb',
                value: params.value,
            },
        };
  
        return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    },
};&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：在 SetStyleCommand 中，因為改變了選區內樣式值，所以需要組裝 SetRangeValuesMutation 的參數，比如將選區內所有單元格的 tb 設置為 
 &lt;u&gt;WrapStrategy.WRAP&lt;/u&gt;。由於選區內 text wrap 的改變，同時該行是自動調整行高的，那麼還需要去計算該行的一個 autoHeight，也就是容納該行內容的一個最低高度。計算自動行高之前，需要先執行 SetRangeValuesMutation，因為 autoHeight 計算是依賴於更新後的視圖數據的。 通過 SheetInterceptorService 中註冊的 interceptor 拿到 autoHeight 的值（redos 中） 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // set-style.command.ts
 const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
       id: SetStyleCommand.id,
        params,
 });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：之所以上面能夠拿到 autoHeight 的值，主要還是歸因於 
 &lt;u&gt;AutoHeightController &lt;/u&gt;類，該類在 
 &lt;u&gt;LifecycleStages&lt;/u&gt;.Ready 階段被實例化，並且添加了會影響到行自動行高的所有 Command 的攔截，如對 SetStylecommand 攔截。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
// for intercept set style command.
sheetInterceptorService.interceptCommand({
     getMutations: (command: { id: string; params: ISetStyleParams&amp;lt;number&amp;gt; }) =&amp;gt; {
          if (command.id !== SetStyleCommand.id) {
              return {
                  redos: [],
                  undos: [],
              };
          }
          // ...
          const selections = selectionManagerService.getSelectionRanges();
 
          return this._getUndoRedoParamsOfAutoHeight(selections);
      },
  });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第五步：因為計算行的自動行高需要用到文檔模型以及單元格佈局的相關計算，所相關計算都放在了管理 
 &lt;u&gt;Spreadsheet&lt;/u&gt; 的 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 類中 (視圖層)， 通過該類中 
 &lt;code&gt;calculateAutoHeightInRange&lt;/code&gt; 方法最終計算出行的自動行高 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
private _getUndoRedoParamsOfAutoHeight(ranges: IRange[]) {
    // ...
    const { skeleton } = sheetSkeletonService.getCurrent()!;
    const rowsAutoHeightInfo = skeleton.calculateAutoHeightInRange(ranges);
    // ...     
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第六步：當拿到 autoHeight 的數據後，會觸發 SetWorksheetRowHeightMutation。無論是上面觸發的 SetRangeValuesMutation 還是 SetWorksheetRowHeightMutation，都會更改模型層，並且標記 sheetSkeleton 和 mainComponent 為 dirty，在 sheetSkeletion 重新計算佈局等相關渲染所需信息，然後渲染頁面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
        this._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                 // ...
                 if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                        },
                        true
                    );
                  }
                  // ...
              }
              this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
         })
     );
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  以上就完成了從事件觸發到修改模型層，進而視圖層更新的整個過程 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_18"&gt;&lt;/span&gt; 
&lt;h1&gt;伍. 更多閲讀&lt;/h1&gt; 
&lt;div&gt;
  如果你想對架構有個整體的瞭解，推薦閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fachitecture.md%23architecture-notes-%25E6%259E%25B6%25E6%259E%2584%25E6%25A6%2582%25E8%25A6%2581" rel="nofollow" target="_blank"&gt;Architecture Notes 架構概要&lt;/a&gt;&lt;/strong&gt;，如果你想了解更多 sheet 的架構和各個模塊的設計和職責，推薦閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fsheet-architecture.md%23univer-sheet-architecture---univer-sheet-%25E6%259E%25B6%25E6%259E%2584" rel="nofollow" target="_blank"&gt;Univer Sheet Architecture - Univer Sheet 架構&lt;/a&gt;&lt;/strong&gt;。如果你對 DI 系統比較陌生，建議，閲讀 Univer 項目中所使用的 DI 框架 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredi.wendell.fun%2Fzh-CN%2Fdocs%2Fintroduction" rel="nofollow" target="_blank"&gt;redi&lt;/a&gt;&lt;/strong&gt;。項目使用 Rxjs 作為觀察者模式，閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frxjs.tech%2Fguide%2Foverview" rel="nofollow" target="_blank"&gt;Rxjs 相關文檔&lt;/a&gt;&lt;/strong&gt; 
 &lt;strong&gt; &lt;/strong&gt;是快速熟悉 Rxjs 的方式 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/6977969/blog/10142382</link>
      <guid isPermaLink="false">https://my.oschina.net/u/6977969/blog/10142382</guid>
      <pubDate>Sat, 10 May 2025 10:12:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Stability AI 發佈可在端側運行的全新音頻生成模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Stability AI &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstability.ai%2Fnews%2Fstability-ai-and-arm-release-stable-audio-open-small-enabling-real-world-deployment-for-on-device-audio-control" target="_blank"&gt;發佈&lt;/a&gt;&lt;/u&gt;了一款名為 Stable Audio Open Small 的音頻生成模型，可在手機端上運行。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-aa977d69f583aa125c61d78628c79f29a64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Hugging Face：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fstabilityai%2Fstable-audio-open-small" target="_blank"&gt;https://huggingface.co/stabilityai/stable-audio-open-small&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 是 Stability AI 與 Arm 公司合作的成果。該模型的訓練集完全由免版税音頻庫 Free Music Archive 和 Freesound 中的歌曲組成。模型擁有 3.41 億個參數，經過優化可在 Arm CPU 上運行。&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 專為快速生成簡短的音頻採樣和音效（如鼓聲和樂器旋律）而設計，Stability AI 公司稱，它可以在 8 秒內在智能手機上生成長達 11 秒的音頻。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350074</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350074</guid>
      <pubDate>Sat, 10 May 2025 10:06:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>因流量持續暴跌，Stack Overflow 尋求品牌重塑</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;編程問答社區 Stack Overflow 開發商表示由於 AI 在回答編程相關問題上更快捷更方便，其網站上的帖子數量正在持續急劇下降，為此他們計劃進行「品牌重塑」。&lt;/p&gt; 
&lt;p&gt;根據官方統計數據，2025 年 4 月發佈的問題和答案總數與 2024 年同期下降了超過 64%，與 2020 年 4 月（當時流量接近峯值）相比下降了超過 90%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-01d9e19775d998a0fa483d562a1a6b782e2.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;CEO Prashanth Chandrasekar 表示公司考慮在問答功能外加入社區和職業發展服務。該公司已在試驗多項新服務，包括 AI Answer Assistant 和 Question Assistant，以及與 Indeed 合作的招聘網站等。&lt;/p&gt; 
&lt;p&gt;Stack Overflow 品牌廣為人知，為什麼還要進行品牌重塑？官方帖子提到了 AI 正在「重塑我們構建、學習和解決問題的方式」，並且該公司似乎正在尋找新的方式來提供價值（並推動業務）。&lt;/p&gt; 
&lt;p&gt;在這種情況下，許多用户並不認為品牌重塑是答案。有用户&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reddit.com%2Fr%2Fprogramming%2Fcomments%2F1km8mbc%2Fstack_overflow_seeks_rebrand_as_traffic_continues%2F" target="_blank"&gt;表示&lt;/a&gt;&lt;/u&gt;，「沒有 DevOps、系統管理員、C/C++/Python/Rust/Java 程序員、數據庫管理員或其他頻繁使用 Stack Overflow 的用户關心品牌，現有的網站就很好」，&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</guid>
      <pubDate>Sat, 10 May 2025 09:30:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>從編譯器、遊戲引擎到遊戲掌機，我是這樣做獨立遊戲的</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;h2&gt;引言&lt;/h2&gt; 
&lt;p&gt;  自己開發製作遊戲是一個兒時起就有的夢，特別是長時間接觸魔獸爭霸 3 世界編輯器後，我對遊戲引擎和開發工具也有着特別的興趣。學生時代接觸編程以後，夢的外延開始擴散，不滿足於使用各式編程語言做開發，開始維護一門自己喜歡的寫遊戲業務邏輯的編程語言項目 Yuescript，因為學習圖形學和作為練手項目重寫 Cocos2d-x 有了 Dora SSR 遊戲引擎。工作後因為對遊戲掌機的喜愛，開始與夥伴合作研發自由開放的可編程遊戲掌機設備——吉祥機，實現自己遊戲夢終極的 Digital Freedom。&lt;/p&gt; 
&lt;h2&gt;遊戲腳本語言的樂趣與挑戰&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-715e7bd07ab1f0fb9a982d2c625f69f9fef.png" alt="編程語言遊樂場！" title="編程語言遊樂場！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  各式新的編程語言的學習過程是充滿樂趣的，對不同語言工具的接觸也會感受到不同的編程理念和程序設計思想。為了學習製作遊戲，對於複雜多變遊戲玩法的腳本編程（Scripting），我也形成了自己編程偏好，即使用一門儘可能簡潔和表達力強的編程語言來編寫容易變化的業務邏輯。可以轉譯為 Lua 語言執行的 Yuescript 語言開源項目就是我為了滿足這個需求的產物。後來隨着使用自己的 Dora SSR 遊戲引擎遇到更多的遊戲開發場景，我又為 Dora SSR 開源遊戲引擎引入了 Teal（為 Lua 語言添加靜態類型檢查能力的語言）、Typescript（進一步增強代碼編輯器提示和代碼檢查的語言）、TSX 和 XML（提供描述性代碼進行組件化開發的語言）等等。每一種腳本語言都能在特定的遊戲開發場景發揮優勢，並通過轉譯到最終運行的、同樣的 Lua 語言進行無縫的互通調用。不只是基於 Lua 語言的擴展，Dora SSR 遊戲引擎項目還在嘗試通過 WASM 虛擬機來支持更加多樣的可以用做遊戲腳本編程的語言，如 Rust 和準備支持的 C++ 和 Go 等，兼顧性能與引擎的運行時擴展能力。&lt;/p&gt; 
&lt;h2&gt;遊戲引擎的創新之路&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d13c83fb9e85ab500bfc4a52c25c25488be.png" alt="隨時隨地用任何設備製作遊戲！" title="隨時隨地用任何設備製作遊戲！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  説到遊戲引擎大家總是想到高性能高質量的圖形渲染，搭建複雜的遊戲場景。實際上作為獨立遊戲開發者，或是遊戲製作的愛好者，並不是人人都有條件追求 3A 遊戲的製作能力（可能會缺少鈔能力）。我認為很多 2D 遊戲或是 2D 混合 3D 效果的遊戲也能表達展現十分有創意和獨特的遊戲作品。而且能運行自己製作遊戲的終端最好是不受限制的，再進一步，也許能用於開發遊戲的終端和操作系統也可以是不受限制的。所以就有了 Dora SSR 開源遊戲引擎的項目目標，在儘可能多的設備上為遊戲開發愛好者提供便捷易用的環境甚至是遊戲開發 IDE。&lt;/p&gt; 
&lt;p&gt;  一直以來遊戲開發這件事也成為了我的個人生活的一個日常的部分。哪怕只有碎片化的時間和手邊隨機可用作遊戲開發和運行的設備，我也想有空就利用起來碎片化地寫兩行遊戲代碼，或是調試一個遊戲功能，並把它變成了一種比較隨性和愜意的休閒娛樂活動。&lt;/p&gt; 
&lt;p&gt;  所以我也嘗試了在 Dora SSR 上搭建了通過遊戲引擎運行時內置用於遊戲開發的 Web IDE 服務器，可以通過其它方便做輸入的設備通過 Web 瀏覽器做訪問，並實現直接在任意的終端設備上直接編寫運行和調試遊戲程序代碼的體驗。同時用户能獲得代碼編輯器可視提示服務、以及使用其它遊戲開發和資源管理的可視化工具。目前 Dora SSR 在努力之下已具備了在 Windows、macOS、iOS、Android、多個 Linux 發行版上進行遊戲開發的能力。&lt;/p&gt; 
&lt;h2&gt;向着自由開放的遊戲掌機夢想邁進&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1a4efb08595713fcf90d5b06eecbe82f151.png" alt="開源開放？軟件和硬件全都要！" title="開源開放？軟件和硬件全都要！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  到此我覺得對遊戲開發能力的自由和開放體驗的追求還遠不到盡頭。作為喜好各式掌機的老玩家，在體驗了諸多國產開源掌機的商業產品後，我感覺深深的不滿足。用掌上游戲機玩遊戲目前還是在卷硬件參數和外觀設計來提供體驗的差異化，而我期待的掌機並不只是玩遊戲上的體驗，還應該是一個可以用來自由的開發、運行甚至發行自制遊戲的設備。很多掌機廠商都有自己的商業化模式和獲得盈利的閉環，所以不會允許硬件設備獲得太多可編程定製的能力。於是和同樣對硬件發燒的夥伴一起研究構建了完全自由開放的掌機設備。並儘可能提供包括機器的計算核心、外設和外觀均可進行模塊化的定製和更換的能力（使科技不再以換殼為本）。於是又有了叫做「吉祥機」的項目。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-677fa26ccf81393c62a89ff15e0179e68e1.png" alt="吉祥機 + Dora SSR 遊戲引擎" title="吉祥機 + Dora SSR 遊戲引擎" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-563f088864ac8a58e6b9687daf303f6fcae.png" alt="不只是掌機和移動編程設備，「吉祥機」也是提供 GPIO + SPI + I2C 接口的外設開發板" title="不只是掌機和移動編程設備，「吉祥機」也是提供 GPIO + SPI + I2C 接口的外設開發板" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;回到遊戲創作的初心&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1f5689f94e27f1b3cf208904e76c8041731.jpg" alt="社區在做的開源獨立遊戲項目《靈數奇緣》" title="社區在做的開源獨立遊戲項目《靈數奇緣》" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  所以折騰了半天我們的遊戲到底做出來了沒有呢？答案當然是做了，但沒完全做出來啦。在生成式 AI 大模型進入徹底火爆前夕的 2020 年，我們就想象了這樣一個關於未來的 AI 的遊戲故事，在未來人的物質需求已經得到完全滿足，人生下來的目的只剩下了通過進行遊戲娛樂，並通過採集在遊戲過程體現人創造力和展現智慧的交互數據給 AI 用做訓練材料。人生的價值都是由未來的銀行（數據銀行），通過評估在遊戲活動中人所創造的智能數據的質量和價值，來進行貨幣分配和評定的。最終數據訓練出的 AI，則會幫助人完成一切的物質生產，從人類個體的養育到社會治理。遊戲的劇情會探索在這樣的設定背景下，人類會有什麼樣的故事。最後遊戲輸出的價值觀就是人生來就應該是改造世界的主體，而不是隻會適應一切現狀的被改造的客體。也呼應了我和我的夥伴們一直在現實中追尋的東西，想要不被與生俱來的一切所定義，就靠自己的主動創造去重新定義一切。&lt;/p&gt; 
&lt;p&gt;  如果對我們在做的編程語言、遊戲引擎、遊戲掌機或是開源獨立遊戲項目感興趣，歡迎 Star 我們的倉庫或是進入我們的 Q 羣一起聊聊。目前的項目都還在逐漸完善的階段，但是幾個項目都會互相整合和驗證迭代，關注我們也可以及時看到我們的項目是怎麼做的以及目前的進展。&lt;/p&gt; 
&lt;h3&gt;項目地址&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;遊戲引擎：&lt;br&gt; &lt;a href="https://gitee.com/pig/Dora-SSR"&gt;https://gitee.com/pig/Dora-SSR&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FIppClub%2FDora-SSR" target="_blank"&gt;https://github.com/IppClub/Dora-SSR&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Yuescript 語言：&lt;br&gt; &lt;a href="https://gitee.com/pig/Yuescript"&gt;https://gitee.com/pig/Yuescript&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpigpigyyy%2FYuescript" target="_blank"&gt;https://github.com/pigpigyyy/Yuescript&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;《靈數奇緣》開源遊戲項目：&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fluv-sense-digital.readthedocs.io" target="_blank"&gt;https://luv-sense-digital.readthedocs.io&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;遊戲開發及掌機交流 Q 羣：512620381&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4925410/blog/11049342</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4925410/blog/11049342</guid>
      <pubDate>Sat, 10 May 2025 09:29:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>DeepSeek 新論文公開 V3 大模型降本方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DeepSeek 團隊近日發表了新論文《Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures》，把 DeepSeek-V3 在訓練和推理過程中，如何解決「硬件瓶頸」的方法公佈了出來。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/165038_St64_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;論文主要介紹了 DeepSeek-V3 在硬件架構方面的挑戰和創新，以及如何通過軟硬件協同設計實現高效訓練和推理。&lt;/p&gt; 
&lt;p&gt;關鍵結論&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;內存效率：DeepSeek-V3 通過 MLA 將 KV 緩存大小顯著減少到每個 token 僅需 70 KB，遠低於其他模型（如 Qwen-2.5 72B 的 327 KB 和 LLaMA-3.1 405B 的 516 KB）。這使得模型更適合處理長文本和資源受限的環境。&lt;/li&gt; 
 &lt;li&gt;成本效益：MoE 架構允許在訓練時僅激活部分參數，從而顯著降低計算需求。例如，DeepSeek-V3 在擴展到 671B 參數時，每個 token 的激活參數僅為 37B，相比全參數激活的密集模型（如 72B 的 Qwen 和 405B 的 LLaMA），計算成本大幅降低。&lt;/li&gt; 
 &lt;li&gt;推理速度：通過重疊計算和通信以及多令牌預測模塊，DeepSeek-V3 在推理時能夠顯著提高吞吐量和響應速度。例如，多令牌預測模塊可以將生成速度提高 1.8 倍。&lt;/li&gt; 
 &lt;li&gt;低精度計算：FP8 混合精度訓練在 DeepSeek-V3 中首次應用於大規模模型訓練，通過細粒度量化策略，相對 BF16 的精度損失控制在 0.25% 以內。&lt;/li&gt; 
 &lt;li&gt;網絡優化：採用多平面兩層 Fat-Tree 網絡拓撲，相比傳統的三層 Fat-Tree 拓撲，顯著降低了網絡成本，並提高了網絡的魯棒性和可擴展性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;論文還提出了對未來 AI 硬件的建議和展望。詳情查看：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2505.09343" target="_blank"&gt;https://arxiv.org/pdf/2505.09343&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350049</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350049</guid>
      <pubDate>Sat, 10 May 2025 08:52:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>vivo 開啓頂尖人才招募計劃：涉及芯片、AI 大模型等領域，稱薪酬上不封頂</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;vivo 近日啓動了一項名為「藍極星計劃」的頂尖人才招募項目。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1099" src="https://static.oschina.net/uploads/space/2025/0515/164047_c20b_2720166.png" width="750" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;招募信息顯示，藍極星計劃的定位為 vivo 最核心的人才戰略方案，面向全球高校頂尖技術人才。在待遇方面，vivo 承諾薪酬上不封頂。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164121_udGF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164136_65kU_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164149_53FG_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;不過，藍極星計劃的門檻也很高，僅向博士生開放。此次招募的崗位涉及 XR、AI 大模型、影像、芯片、器件開發等核心技術領域，崗位類型十餘個。總體招募規模在百人左右，其中以影像方向名額最多。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350047</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350047</guid>
      <pubDate>Sat, 10 May 2025 08:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Ruby 已合併新的即時編譯器 ZJIT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;ZJIT 是一個新的即時編譯器（JIT），由與開發 YJIT 的同一編譯器團隊構建到參考 Ruby 實現 YARV 中，該工具目前已合併到 Ruby。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;相關閲讀&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/231919/ruby-rjit" target="news"&gt;Ruby 引入新 JIT 編譯器 RJIT，替代 MJIT&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/192164/rust-jit-for-ruby" target="news"&gt;Ruby 的新 YJIT 編譯器已完成，使用 Rust 重新實現&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;ZJIT 在多個方面與 YJIT 有所不同：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;它不是直接將 YARV 字節碼編譯成低級中間表示（LIR），而是使用基於高級單賦值（SSA）的中間表示（HIR）&lt;/li&gt; 
 &lt;li&gt;它不是一次編譯一個基本塊，而是每次編譯一個完整的方法&lt;/li&gt; 
 &lt;li&gt;它不是使用懶惰基本塊版本化（LBBV）來分析類型，而是從已分析的解釋器中讀取歷史類型信息&lt;/li&gt; 
 &lt;li&gt;與在將 YARV 降低到 LIR 時進行優化不同，它有一個工作在 HIR 上的高級模塊化優化器&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;從高層次來看，ZJIT 接收 YARV 字節碼，構建中間表示（IR），進行一些優化，並生成機器碼。簡化來説，它看起來像這樣：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/162351_2fb3_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下示例為 Ruby 程序通過完整的編譯器管道：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-ruby"&gt;# add.rb
def add(left, right)
  left + right
end

p add(1, 2)
p add(3, 4)&lt;/code&gt;&lt;/pre&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350040/ruby-merge-zjit</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350040/ruby-merge-zjit</guid>
      <pubDate>Sat, 10 May 2025 08:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>騰訊元寶推出 Chrome 瀏覽器插件</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;騰訊元寶上線了瀏覽器插件，可以在 Chrome 應用商店下載。安裝之後，在網頁上就能劃詞提問、總結內容、翻譯外文網頁，看到重要信息還能一鍵收藏，所有收藏的內容都會同步，方便之後接着問、繼續看。&lt;/p&gt; 
&lt;p&gt;開啓元寶插件後，頁面右側會有一個懸浮球，點擊就能用元寶；右側的側邊欄，支持截圖提問、上傳文件、搜索內容等操作，適合在瀏覽網頁時順手處理信息。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-38991e82b9d30a95f1547c862cbb75f202b.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-477743ad0ecf29d37287fdaab5a391134a8.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ed86f3ccf817ebd7d6844d987868865c677.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;下載地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyuanbao.tencent.com%2Fdownload" target="_blank"&gt;https://yuanbao.tencent.com/download&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350035</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350035</guid>
      <pubDate>Sat, 10 May 2025 08:05:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Databricks 官宣收購開源數據庫引擎初創公司 Neon</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美國數據公司 Databricks&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.databricks.com%2Fblog%2Fdatabricks-neon" target="_blank"&gt;宣佈&lt;/a&gt;已達成協議收購 Neon，這是一家以開發者為核心、提供無服務器 Postgres 解決方案的公司。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4671779d822a78c6be19b9199b6bae1e524.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該公司表示，Neon 的聯合創始團隊是全球極少數能夠重構 Postgres 數據庫架構、實現真正存儲與計算分離的團隊，這支由 Postgres 技術專家和數據庫資深人士組成的團隊將加入 Databricks，致力於在 AI 原生時代為開發者提供生產級規模的無服務器 Postgres 服務。&lt;/p&gt; 
&lt;p&gt;Databricks 在公告提到，當 Neon 去年正式發佈時，他們注意到一個有趣的數據：30% 的數據庫是由 AI Agent 創建的，而不是人類。當他們最近再次查看統計數據時，這個數字從 30% 上升到了 80% 以上。也就是説，AI Agent 創建的數據庫數量是人類的四倍。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ec3bf200a942ba01e9a5788c048a3386cd3.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Neon 的約 140 名員工將在交易完成後加入 Databricks。Databricks 表示，在短期內，該初創公司將保持獨立，但從長期來看，將會整合到 Databricks 平台中。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/348379/scoop-databricks-talks-to-acquire-neon" target="_blank"&gt;Databricks 正洽談以約 10 億美元收購開源數據庫初創公司 Neon&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/246894/databricks-strikes-1-3-billion-deal-for-mosaicml" target="news"&gt;大數據巨頭 Databricks 斥資 13 億美元收購 MosaicML&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350031/databricks-acquires-neon</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350031/databricks-acquires-neon</guid>
      <pubDate>Sat, 10 May 2025 07:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬化騰：微信有可能形成獨特 Agent AI 生態</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;昨天，&lt;a href="https://www.oschina.net/news/349982"&gt;騰訊公佈了 2025 年第一季度財報&lt;/a&gt;，總營收 1800 億元，同比增長 13%。毛利為人民幣 1000 億元，同比增長 20%，淨利潤為 497 億元，同比增長 17%。&lt;/p&gt; 
&lt;p&gt;在財報電話會議上，AI 成為了分析師們重點關切的話題。騰訊 CEO 馬化騰、騰訊總裁劉熾平做了詳細解讀和提問。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151017_3gSe_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151007_rkWf_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;馬化騰在回答分析師提問時表示，每個人都可以做通用的智能體，但與此同時，也有一種智能體可以存在於微信內部以及微信獨特的生態系統中。&lt;/p&gt; 
&lt;p&gt;馬化騰強調，「我認為這是兩種不同的產品。」&lt;/p&gt; 
&lt;p&gt;馬化騰表示，對於通用的智能體，騰訊正在公司的一些 AI 原生產品，例如，元寶和 Ima 等，中創建這種能力。在最初階段，這些 AI 產品可能只是非常快速地回答問題，然後隨着時間推移，它們開始包含思維鏈、長鏈路思考、推理模型，可以回答複雜的問題，再往後可以做更復雜的自動化任務。騰訊會繼續發展這類產，但與我們同行提供的其他智能體沒有太大區別。&lt;/p&gt; 
&lt;p&gt;馬化騰認為，在微信生態系統內，騰訊有機會創建一個非常獨特的智能體。它與微信生態系統的獨特組成部分相連接，包括社交圖譜、通信和社區能力、內容生態系統（如公眾號和視頻號），以及微信內數百萬個小程序。&lt;/p&gt; 
&lt;p&gt;這些小程序實際上涉及各種信息以及跨越許多不同垂直應用的交易和操作能力。因此，為與其它更通用的智能體相比，這將是非常獨特的。這對騰訊來説是一個非常差異化的產品&lt;/p&gt; 
&lt;p&gt;對於 AI 的商業模式，馬化騰認為，通過 AI 提升廣告收入存在巨大的機會，雖然 GPU 租賃與雲業務直接相關，但這部分業務主要是轉售 GPU，在騰訊內部優先級較低。馬化騰還認為，在中國，用户都在免費獲取 AI 服務，訂閲模式不會是中國 AI 的主流商業模式。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350025</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350025</guid>
      <pubDate>Sat, 10 May 2025 07:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Eclipse Vert.x 5 發佈！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;我們非常高興地宣佈 Vert.x 5 的發佈。&lt;/p&gt; 
&lt;h2&gt;Vert.x 5 有哪些新功能？&lt;/h2&gt; 
&lt;p&gt;Vert.x 5 是 Vert.x 4.x 系列的進化版本，為 Vert.x 帶來了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fblog%2Fwhats-new-in-vert-x-5%2F" target="_blank"&gt;重要功能&lt;/a&gt;。&lt;/p&gt; 
&lt;h2&gt;從 Vert.x 4 到 Vert.x 5 升級&lt;/h2&gt; 
&lt;p&gt;Vert.x 5 在 Vert.x 4 的基礎上添加了一系列新功能，同時提供了與 Vert.x 4 一致的使用體驗：Vert.x 4 的用户在使用 Vert.x 5 時會感到非常熟悉。&lt;/p&gt; 
&lt;p&gt;你可以瞭解更多關於從 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fblog%2Ffrom-vert-x-4-to-vert-x-5%2F" target="_blank"&gt;Vert.x 4 遷移到 Vert.x 5&lt;/a&gt; 的信息。&lt;/p&gt; 
&lt;h2&gt;沒有社區，我們一無所有&lt;/h2&gt; 
&lt;p&gt;正是&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fcommunity%2F" target="_blank"&gt;社區&lt;/a&gt;的努力，讓 Vert.x 5 成為了現實。&lt;/p&gt; 
&lt;p&gt;特別感謝 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmichelkraemer.com%2F" target="_blank"&gt;Michel Krämer&lt;/a&gt;，他是這個令人驚歎的網站的創建者。&lt;/p&gt; 
&lt;h2&gt;最後&lt;/h2&gt; 
&lt;p&gt;5.0.0 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvert-x3%2Fwiki%2Fwiki%2F5.0.0-Release-Notes" target="_blank"&gt;發行説明&lt;/a&gt;以及&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvert-x3%2Fwiki%2Fwiki%2F5.0.0-Deprecations-and-breaking-changes" target="_blank"&gt;廢棄和重大更改的信息&lt;/a&gt;可以在 wiki 中找到。&lt;/p&gt; 
&lt;p&gt;你可以使用 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstart.vertx.io%2F" target="_blank"&gt;start.vertx.io&lt;/a&gt; 來啓動一個 Vert.x 5 項目。&lt;/p&gt; 
&lt;p&gt;發佈的構件已經部署到了 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsearch.maven.org%2Fsearch%3Fq%3Dg%3Aio.vertx%2520AND%2520v%3A5.0.0" target="_blank"&gt;Maven Central&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40vertx%2Feventbus-bridge-client.js" target="_blank"&gt;Vert.x 4 的事件總線 JavaScript 客户端庫&lt;/a&gt;現在可以在一個單一的位置獲取，並且它現在可以單獨使用，也可以輕鬆集成到任何前端構建工具中。&lt;/p&gt; 
&lt;p&gt;就這些！祝你編碼愉快，並期待在我們的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fchannels" target="_blank"&gt;用户或開發者頻道&lt;/a&gt;中很快見到你。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350023/eclipse-vert-x-5-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350023/eclipse-vert-x-5-released</guid>
      <pubDate>Sat, 10 May 2025 07:06:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>Anthropic 或將發佈新模型，已開始內部安全測試</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.testingcatalog.com%2Fnew-claude-neptune-model-undergoes-red-team-review-at-anthropic%2F" target="_blank"&gt;據 TechingCatalog 報道&lt;/a&gt;&lt;/u&gt;，Anthropic 正在對一個名為「claude-neptune」的新 AI 模型進行安全測試。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-708826a51d39b3ae8c7c5212b0c223fa837.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;本次測試即將持續到 5 月 18 日，主要是測試該模型對於越獄嘗試的防範性。新模型將使依賴 Claude 進行安全、高性能推理的開發人員、研究人員和企業用户受益匪淺，尤其是在代碼生成和技術研究等領域，Claude 在這些領域的評估中一直保持強勢。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-411a072df13c279a6cb41be11b7b27d7637.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 可能會在 5 月底或者 6 月初發布 Neptune 模型，與 OpenAI 以及谷歌展開正面對決。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</guid>
      <pubDate>Sat, 10 May 2025 06:59:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Canonical 今年將向開源開發者提供超過 10 萬美元的捐款</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Canonical 宣佈，將在未來一年向開源開發者捐贈 12 萬美元。該公司計劃從 4 月份發放的第一筆款項開始，每月捐贈 1 萬美元，持續 12 個月。這些資金將通過&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthanks.dev%2F" target="_blank"&gt;thanks.dev 平台&lt;/a&gt;進行分配。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-60dfdea453b94c8e5e86c25d88085ea5029.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;該計劃旨在為 Canonical 所依賴的小型上游開源項目提供資金支持。除了 Canonical 對 Eclipse 基金會、雲原生計算基金會 (CNCF) 和 GNOME 基金會等主要開源基金會的持續支持之外，該計劃也是一種回饋社會的額外方式。&lt;/p&gt; 
&lt;p&gt;Thanks.dev 的工作原理是分析公司 GitHub 代碼庫和依賴關係樹（深度可達三層），並根據依賴關係的使用頻率，通過算法分配捐款。Canonical 表示，它可以在編程語言層面調整資金的權重，以更好地反映資金的使用情況。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoverage.readthedocs.io%2F" target="_blank"&gt;Canonical 使用了一些開發者的項目，例如編寫了 coverage.py 的&lt;/a&gt;nedbat 和&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fadamchainz%2Ftime-machine" target="_blank"&gt;維護 Ubuntu 網站使用的庫 time-machine 的&lt;/a&gt;adamchainz&amp;nbsp;。該公司表示，即使是微小的認可或資金支持，對開源開發者來説也意義非凡。這是對這些項目幕後工作的讚賞。Canonical 的大部分代碼都是開源的，並在 GitHub 和 Launchpad 等平台上公開開發。&lt;/p&gt; 
&lt;p&gt;該公司還指出，thanks.dev 正在努力添加對檢查 Launchpad 上託管的依賴項的支持。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2Fblog%2Fcanonical-thanks-dev-giving-back-to-open-source-developers" target="_blank"&gt;此公告&lt;/a&gt;是在最近發佈的 Ubuntu 25.04「Plucky Puffin」之後發佈的，這是一個臨時版本，包含許多受益於活躍的上游開發的新開源組件，例如 GNOME 4.8 桌面和 Linux 內核 6.14。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350018</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350018</guid>
      <pubDate>Sat, 10 May 2025 06:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>在微軟任職 18 年的資深 TypeScript 工程師被裁員</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微軟近期進行了&lt;a href="https://www.oschina.net/news/349773/microsoft-is-cutting-3percent-of-workers"&gt;全球裁員&lt;/a&gt;，約 6,000 名員工受到影響，佔其全球員工總數的近 3%。其中包括資深 TypeScript 工程師 Ron Buckton。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/114444_6gWh_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Frbuckton%2Fstatus%2F1922364558426911039" target="_blank"&gt;https://x.com/rbuckton/status/1922364558426911039&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Ron Buckton 在微軟工作了 18 年，其中近 10 年致力於 TypeScript 的開發。&lt;/p&gt; 
&lt;p&gt;兩個月前，TypeScript、C#、Delphi 語言之父 Anders Hejlsberg 宣佈了「&lt;a href="https://www.oschina.net/news/338304/typescript-native-port"&gt;10x Faster TypeScript&lt;/a&gt;」項目——將 TypeScript 編譯器以及工具鏈將移植到 Go 語言，性能提升高達 10 倍！&lt;/p&gt; 
&lt;p&gt;該項目由 Anders Hejlsberg 主導，Ron Buckton 則是其中核心開發者。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="2070" src="https://static.oschina.net/uploads/space/2025/0515/115256_8t1n_2720166.png" width="2806" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Ftypescript-go%2Fgraphs%2Fcontributors" target="_blank"&gt;https://github.com/microsoft/typescript-go/graphs/contributors&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;目前，該項目還在進展中，然而其核心成員已經被解僱了。作為 TypeScript 核心開發者，Ron 的離開也讓大家對微軟此次裁員的標準和背後的決策邏輯產生了疑問。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115906_rOTp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;有人諷刺地説：「被裁要麼是你工作太差，要麼是太優秀——如果不是前者，那就只能是後者。」甚至有人調侃道，「10 倍工程師實現了 10 倍性能提升後被裁，HR AI 宣佈：‘價值已提取，執行終止。’」&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115558_zk7j_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;閲讀更多：&lt;a href="https://www.oschina.net/news/338304/typescript-native-port" target="news"&gt;TypeScript 編譯器和工具鏈將移植到 Go：性能提升 10 倍&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</guid>
      <pubDate>Sat, 10 May 2025 03:56:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>KuaiMod —— SVP 內容審核框架</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;KuaiMod，是快手推出的一個具有真實用户/審閲者反饋的 SVP 內容審核基準。&lt;/p&gt;

&lt;p&gt;KuaiMod 審核框架由三個部分組成：訓練數據構建、離線自適應以及在線部署和改進。快手利用&lt;strong style="color:#363636"&gt;大規模視覺語言模型 (VLM) 和思維鏈 (CoT) 推理&lt;/strong&gt;，基於稀疏的用户反饋對視頻惡意程度進行充分建模，並構建了更新速度快、準確率高的動態審核策略。&lt;/p&gt;

&lt;p&gt;基準測試結果表明，KuaiMod 的部署降低了 20% 的用户舉報率，其在視頻推薦中的應用提高了酷我多個場景中的日活躍用户（DAU）和 APP 使用時間（AUT）。&lt;/p&gt;

&lt;p&gt;&lt;img height="309" src="https://static.oschina.net/uploads/space/2025/0509/141639_WJZZ_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;h2 style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Kuaimod 實現細節&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img height="93" src="https://static.oschina.net/uploads/space/2025/0509/141652_v2nX_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img height="153" src="https://static.oschina.net/uploads/space/2025/0509/141710_FayU_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img height="269" src="https://static.oschina.net/uploads/space/2025/0509/141741_hk71_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img height="201" src="https://static.oschina.net/uploads/space/2025/0509/141758_NNw5_4252687.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/kuaimod</link>
      <guid isPermaLink="false">https://www.oschina.net/p/kuaimod</guid>
      <pubDate>Sat, 10 May 2025 03:54:00 GMT</pubDate>
    </item>
    <item>
      <title>微軟 WizardLM 團隊「集體跳槽」騰訊，或已併入混元大模型研發體系</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;外媒 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F05%2F13%2Ftencent-hires-wizardlm-team-a-microsoft-ai-group-with-an-odd-history%2F" target="_blank"&gt;TechCrunch&lt;/a&gt; 消息稱，總部位於北京、曾隸屬於微軟的人工智能研究團隊 WizardLM，近日被爆出已整體加入騰訊 AI 實驗室旗下的「混元」團隊。多位核心研究人員在社交平台 X（原推特）上宣佈了這一動向。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在週二的帖子中，曾領導多個 WizardLM 項目的微軟高級研究員 Can Xu 表示，他和團隊已經離開微軟，並正式加入騰訊混元團隊。該團隊近年來在視頻生成、3D 內容創作等多個方向發佈了具有突破性的模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="270" src="https://oscimg.oschina.net/oscnet/up-5223c0b970012c471e14a6ea16c4736967d.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;更引人關注的是，WizardLM 近期公開發布了名為 Hunyuan-TurboS0416 的模型，首次在產品命名中出現「混元」字樣，顯示其團隊歸屬已與騰訊深度融合。據自稱為 WizardLM 聯合創始人的孫慶峯透露，該模型在多個基準測試中超越了谷歌最新開源大模型 Gemma3 系列，被視為騰訊在開源對抗賽中的關鍵成果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;WizardLM 自成立以來便頗具爭議。2024 年 4 月，該團隊發佈了自研大模型 WizardLM-2，並宣稱其能力接近 GPT-4，但僅一天後便遭到微軟下架處理，原因是「未完成毒性測試」。儘管團隊緊急補測並承諾重新發布，但原始模型已被社區快速傳播和二次上傳，微軟難以控制。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;這一事件也引發了開源圈強烈不滿。Hugging Face CEO Clément Delangue 公開批評微軟的下架行為「破壞了數十個開源項目」，強調 WizardLM 模型每月下載量曾超過十萬次，對生態影響巨大。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;WizardLM 團隊加入之際，騰訊正加緊佈局大模型生態。消息稱，騰訊已重組混元大模型團隊，劃分為兩個獨立部門，並擴大基礎設施投資。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在剛剛公佈的 2025 年第一季度財報中，騰訊明確將營收同比增長的 8% 歸因於 AI 戰略升級，並宣佈全年將投入 900 億元人民幣（約合 124.9 億美元） 用於資本支出，其中大部分將用於 AI 能力建設。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前尚不清楚 WizardLM 團隊是否整體加入騰訊，也不清楚其在微軟的正式離職時間。微軟和騰訊方面尚未就此變動發表公開聲明。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/349995/tencent-hires-wizardlm-team</link>
      <guid isPermaLink="false">https://www.oschina.net/news/349995/tencent-hires-wizardlm-team</guid>
      <pubDate>Sat, 10 May 2025 03:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>vivo 互聯網研發效能關鍵技術與實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;blockquote&gt; 
 &lt;p&gt;作者：&lt;/p&gt; 
 &lt;p&gt;vivo 互聯網研發效能團隊&lt;/p&gt; 
 &lt;p&gt;Yang Peng、Huang Fengjin&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;本文介紹了 vivo 互聯網研發效能平台建設與最佳實踐的話題，將分為 4 個部分與大家分享，分別是研發效能提升的背景與挑戰、關鍵場景技術，以及在項目案例中的實踐與效果，最後也將和大家探討未來在研發效能提升上的一些規劃與思考。&lt;/p&gt; 
&lt;h1&gt;一、互聯網研發挑戰與方案&lt;/h1&gt; 
&lt;p&gt;隨着互聯網業務的快速發展，業務規模和用户體量在不斷擴張，在如此大的規模和體量下，對研發交付效率及質量也提出了新的要求和挑戰。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/9c/9c0a7cbc954e640c7934d6f3a97a9e27.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;（圖中數據統計截止時間為 2024.07）&lt;/p&gt; 
&lt;p&gt;vivo 互聯網業務廣泛，體量巨大。伴隨而來的是互聯網項目快速增長，最近 5 年增長超過了 5 倍。與此同時，項目的服務數量也出現大規模增長，最近 6 年從原先少於 2500，到快速增長超過 8000，服務數量增長超過 3.7 倍；服務器數量也同時期增長了 2.8 倍，研發交付和穩定性保障的複雜度成幾何式增長。可以看到隨着項目、服務、機器的大規模增長，研發團隊規模也發生了較大的變化，前後增長超過 2.7 倍。隨之而來研發協作難度逐步增加，甚至出現效能下滑的傾向。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/e0/e0636a5851af1b78a9420a26451c3b7e.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;（圖中數據統計截止時間為 2024.07）&lt;/p&gt; 
&lt;p&gt;隨着研發複雜度增加，互聯網研發流程也變得規範，與此同時，支撐的工具和平台能力也非常豐富。但是這也帶來了交付複雜度的上升，項目成員往往需要在多個平台來回切換，非常麻煩！正如下圖所示，從需求洞察到需求運營至少需要經歷 10 個階段、10 多個角色的高效協作才能完成，顯然相比以前複雜了許多，也逐步顯示了需求交付效率下降的情況。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/ab/ab4c018635115bcbc14f87c34c01a08a.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;項目流程和平台複雜度增加的同時，在技術層面，研發基礎設施也是幾經變遷，線上線下環境的機器複雜度持續增長，變更與維護難度逐年上升，對變更質量的要求越來越高。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/d4/d4687a785b5a8fa92ddd8369d13cd004.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;從上圖可以看出，在 2017 年以前，研發整體線上交付的機器以物理機為主，所有的線上運維都是交由專門的業務運維及 DBA 角色來執行，開發人員主要參與編碼和測試工作。&lt;/p&gt; 
&lt;p&gt;但隨着研發規模增長，快速交付、低成本的資源也逐步開始引入像 OpenStack 這樣虛擬化技術，此時用户的操作也逐步從原有運維逐步轉向類似 CICD 這樣自助化運維交付平台。&lt;/p&gt; 
&lt;p&gt;並且隨着內外銷業務的發展，越來越多彈性、快速、低成本的雲主機也逐步引入，平台從簡單流程逐步發展成體系化、場景化平台，用户的使用成本也逐步攀升。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/07/07845d5a1789e616f965e516e1a27675.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;回顧上面業務規模、研發體量和流程平台的現狀，以及基礎設施的變遷，vivo 互聯網業務面臨相當大研發效能提升的挑戰。&lt;/p&gt; 
&lt;p&gt;總結來看：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;研發規模攀升，研發交付複雜度持續上升。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;研發交付橫跨多個階段，在多個平台間操作，成本非常高。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;隨着基礎設施的變遷發展，平台需要不斷兼容不同資源、不同雲廠商、不同用户場景的訴求，為平台建設和項目實踐帶來了非常大的挑戰。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/bf/bfc239a0835b62591526e3d53d17df5c.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;回溯過去與當前的困境，結合公司文化行為準則，vivo 研發效能團隊堅持以用户導向深入業務側，從頂層進行設計與規劃，提出「1-2-3」建設框架：通過 1 個雙環模型、2 個標準化、3 條研發管線助力研發效能持續提升。&lt;/p&gt; 
&lt;p&gt;**第 1 層結合「價值探索」與「價值交付」 的持續交付雙環模型。**左環確定方向與目標，強調採用「提問」-「錨定」-「共創」-「精煉」的方式來循環驗證；右環則偏重過程交付，快速實現左環目標，並保持業務結果與價值達成。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 2 層定義了兩個標準化：需求標準化、研發標準化&lt;/strong&gt;。需求標準化更加強調需求從提出到需求實驗全鏈路閉環管理，最終實現需求端到端交付；研發標準化更多強調從分支拉出到交付上線的標準化、自動化過程。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 3 層為了重點支撐業務、數據、以及模型和算法需求的研發交付&lt;/strong&gt;，規劃了 3 條對應的研發管線，將原有煙囱式能力串聯成體系化工具鏈，致力於打造絲滑流暢的開發者體驗。&lt;/p&gt; 
&lt;h1&gt;二、互聯網研發效能關鍵場景技術&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/be/be5cc5cebb5c27eb5c82ef3b2723cb1c.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據上述研發效能現狀來看，我們規劃了研發效能的需求標準化、研發標準化。根據 2 個標準化，我們梳理了 3 個關鍵場景：需求自動化、標準流水線、測試自動化。&lt;/p&gt; 
&lt;p&gt;**需求標準化：**需求自動化作為標準化實現的關鍵，它作為需求整個標準化驅動引擎，推動需求狀態自動流轉。從而實現分支創建和合並、測試環境交付、測試自動化驗證等場景串聯，達到全鏈路需求標準化交付目的。例如：需求拆分任務時按照分支策略自動拉分支，需求轉測時能夠自動合併分支，以及觸發流水線執行測試環境發版，及時更新測試環境版本。&lt;/p&gt; 
&lt;p&gt;**標準流水線：**主要流水線內卡片類型有明確的規範，為了減少流水線配置，推進流水線「一人配置、多人共享」，實現流水線並行執行，不受運行時流水線的限制，使得滿足所有目標項目符合持續集成的要求。&lt;/p&gt; 
&lt;p&gt;**測試自動化：**作為研發效能質量提升的重要措施，在需求狀態發生流轉時，則自動觸發流水線實現測試環境更新，以及觸發測試用例的執行，主要包含流程管控自動化和測試實施自動化兩個方面。&lt;/p&gt; 
&lt;p&gt;上面需求自動化是為瞭解決需求端到端過程中自動化串聯，那原先需求自動化是解決什麼問題呢？我們接下來看下目前互聯網需求流程端到端流程，不同階段的場景之間自動化率較低，大部分靠手工操作。並且根據該頁下半部分來看，支持研發效能實施操作的平台較多，圖上所示的基本只是在平台層面有單一支持，並沒有實現串聯，用户多平台操作成本較高。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/7e/7e6a8637bee04a157c68e21731d169d6.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據圖上流程顯示多平台操作成本高，自動化聯動率較低，面對這樣的用户痛點問題，我們需要根據上述流程示意圖，3 個大的階段 7 個關鍵狀態和 3 個核心平台之間動態自動化聯動。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，在需求階段，需求從納入迭代時就根據分支策略自動化拉取分支，完成需求設計進入開發階段，當需求狀態從待開發狀態變成已完成開發時，則自動化觸發測試環境流水線運行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，觸發流水線運行後則首先將分支進行合併，並且將合併後的分支執行代碼靜態檢查和代碼評審，通過之後藉助全鏈路能力快速拉取多版本測試環境，與此同時也同步觸發測試平台的測試用例執行，涵蓋功能、性能等接口測試用例。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;再次&lt;/strong&gt;，完成測試環境搭建以及測試用例的執行，生成對應的測試報告。此時流水線將結合測試結果動態生成上線工單，也同步反饋更新需求狀態到待上線狀態。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;最後&lt;/strong&gt;，待上線工單完成相關審批，此時將按照預設策略執行線上部署，完成線上交付，則自動反饋需求狀態更新已上線狀態。到目前為止，我們能夠看到整體的狀態流轉絕大部分以上都自動化完成。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/09/093fe558445f1e63bbde1ce7e46e4a2a.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上述我們談到需求自動化的流轉流程，那要實現這樣的自動化流程，我們要如何做到呢？如圖所示我們能夠看到完成整個自動化流轉需要 4 個部分：事件觸發機、規則匹配引擎、規則執行器、日誌記錄器。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，在觸發執行之前，我們需要先配置觸發執行規則，例如：「當 xx 發生時，則執行 xx 事件」等，並且將規則的執行主體、觸發時機、執行動作關聯。此時，一旦規則的觸發時機達到條件時，則產生觸發事件，加入事件隊列，採用先進先出模式執行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，當事件隊列出列某個觸發事件之後，則將事件傳播到規則匹配引擎，此時通過匹配規則進行模版匹配，一旦匹配通過，則將規則對應的執行主體任務取出，並且觸發 action 動作，例如：傳遞 xx 參數並調用指定流水線運行等，最後將執行狀態返回，記錄到日誌。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/5f/5fc97189f0b7e068e91f7d01be050f42.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;剛剛我們看到的是需求自動化的上下游觸發，要是能夠讓研發交付效能進一步提升，我們此時就需要關注通過流水線實現標準化交付。從圖上我們能夠看到要想實現交付成熟度從 1.0 提升到 2.0，需要提升持續交付的規範化，我們知道單純依靠流程規範來實現流水線按照指定的規範配置和執行，只能通過平台標準化流水線配置與運行，才能以實現交付流程的標準化和一致性。&lt;/p&gt; 
&lt;p&gt;為了實現標準化流水線，需要 3 個部分。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，需要定製標準流程，約束所有業務研發團隊統一標準化流程操作；&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，要考慮多場景觸發，則需要保證流水線可並行運行；&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;最後&lt;/strong&gt;，要通過標準檢查來保證流水線能夠按照設定好的規則配置，從而實現標準化交付。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/45/453b07dbef4188421de00fb0f8927cb5.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上述我們也提到要實現標準流水線，需要支持流水線在多場景下並行執行，提升流水線的使用和運行效率。談到並行執行，我們類比類與實例的關係，目標是一套流水線配置，可以並行根據參數動態運行不同實例。&lt;/p&gt; 
&lt;p&gt;那我們來一起看看並行流水線如何實現的，考慮到流水線在運行過程中根據具體配置，固化按照預設分支、環境運行。&lt;/p&gt; 
&lt;p&gt;為此，要想實現並行執行，關鍵如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;去除排隊限制，讓同一條流水線可以支持運行多個實例；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;執行過程中隔離資源（機器、環境、任務等），避免環境污染；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;動態生成不同執行任務，並自動觸發運行；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;保證任務運行過程中資源隔離，避免運行環境污染；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;之後要注意運行結束後隔離資源回收是否全面。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/4b/4b584d406e09c6c1fce10da75e24a9c1.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;上述談到要實現流水線標準化，靠人工檢查效率低下，此處基於標準規則和檢查機制來保證。為此，我們來瞭解下我們是如何實現標準化規則檢查的，此處核心是將所有配置位運算可解析的格式，通過&amp;amp;和^操作來實現。&lt;/p&gt; 
&lt;p&gt;正如上圖所示，我們將規則檢查分為兩個&lt;strong&gt;關鍵步驟&lt;/strong&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;通過&amp;amp;識別是否一致，主要通過二進制位檢查來識別是否有通過檢查；&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果不一致，則通過^和&amp;amp;再次識別具體不一致的位置，從實現快速校驗和識別，將得到的結果到數據庫中比對出不一致的流水線及歸屬服務。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/26/267ad62254bc0a373a978f9588d19277.jpeg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我們從需求自動化到流水線標準化，主要關注效率維度提升，接下來我們看下在質量維度的提升。在測試域我們關注的測試活動實施，主要分為兩塊：流程管控自動化、測試實施自動化。&lt;/p&gt; 
&lt;p&gt;**流程管控自動化，**通過打通了研發域、交付域、測試域，完成測試任務的自動流轉，從而實現覆蓋了 80% 項目的測試活動。&lt;/p&gt; 
&lt;p&gt;對於&lt;strong&gt;測試實施自動化&lt;/strong&gt;而言，測試實施分為客户端和服務端兩個維度。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;對於&lt;strong&gt;服務端測試&lt;/strong&gt;：接口和性能自動化、變更風險可視化是確保服務端高質量測試交付的關鍵，兩者的自動化覆蓋度超過 70% 的核心項目。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;對於&lt;strong&gt;客户端測試&lt;/strong&gt;：通過統一的插件化方案實現各類自動化能力（穩定性、功能、埋點等），並支持實時監控手工測試過程中相關數據，從而保障客户端測試的整體效果。目前覆蓋超過 90% 的 APK 應用。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/6d/6d4a61365365e4bbf84dfb346156d4d1.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我們提到接口測試自動化，那我們來一起看下如何實現？接口自動化實現總體分為 4 個大的步驟，分別是：接口管理、用例轉化、用例執行、輸出報告，其中接口管理考慮場景，又分為接口自動化掃描和流量錄製。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;接口錄製階段&lt;/strong&gt;：接口掃描採用 agent 組件在 java 工程測試環境啓動過程中動態採集工程所有的 java 訪問接口，並且實時將接口數據上報到接口服務平台。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;接口管理階段&lt;/strong&gt;：除了支持工程掃描，也可以藉助自研流量錄製平台進行錄製，並且將線上錄製好的接口鏈接及參數登記到接口服務平台。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;用例執行階段&lt;/strong&gt;：通過將接口參數進行解析，動態生成接口測試用例，並針對生成的接口測試用例進行驗證是否有效。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;報告輸出階段&lt;/strong&gt;：通過接口測試用例動態生成，我們後續可以將單個測試用例進行批量組合成套件，可以根據代碼變更動態識別出需要自動化測試的接口用例，通過手工、流水線、定時進行觸發，並且將測試的接口生成測試報告通知給用户，便於用户實時關注測試結果。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/17/176107951b78413ead358b0d6d4ccad0.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我們瞭解了接口的自動化，通過自動化我們可以有效提升測試的質量。但是我們都知道，接口的穩定性除了功能的完整性測試之外，也需要考慮在目標用户體量下的穩定性和可靠性，我們接下來一起看下關於接口自動化壓測的實現，談到接口性能壓測，那必然離不開接口、性能測試用例，以及壓測需要的環境。我們從整體來看，壓測過程分為兩個部分：線上環境接口錄製、壓測環境流量回放。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;線上環境接口錄製主要是採用我們公司自研的流量錄製回放平台月光寶盒（MoonBox），通過 moonbox-sdk 將線上流量採集並推送到平台，之後將錄製的流量接口數據存放在 ES 數據庫中，待壓測平台 IPT 需要的時候拉取。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;用户在 IPT 壓測平台開啓壓測時，平台根據用户指定的配置動態形成壓測策略推送到壓測服務，並通過壓測服務轉化為一組組壓測任務下發到壓測集羣，考慮到壓測任務體量不同，壓測集羣藉助容器可以動態伸縮，實現目標體量的完全模擬。通過壓測集羣批量、動態非線性實時壓測，與此同時 IPT 壓測平台會動態從監控平台獲取壓測環境監測數據，並且將性能壓測結果進行整合，最終形成目標壓測報告發送給用户。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;h1&gt;三、研發效能項目實踐與效果&lt;/h1&gt; 
&lt;p&gt;我們介紹了在效能平台建設過程中面臨的挑戰和關鍵技術。當然所有能力的建設都會迴歸到助力業務效能提升上面去，在實際的業務中我們是如何實踐這些能力提升研發效能。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/e2/e2a33d9f7153c86512a9c0e9228776de.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在「應用商店」項目中，我們在「需求交付標準化」和「研發過程標準化」的框架下，重點實踐了需求分層管理和自動化驅動，標準流水線和自動化測試，有效地解決了在需求管理和研發流程中的效率問題。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/eb/eb022479a00c8616b60c5e7ba0a05409.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;vivo 應用商店是 vivo 官方團隊傾力打造的應用下載及管理平台，為 vivo 手機用户提供海量的應用和遊戲，是一款工具產品，也是一款商業化產品，既協助開發者獲客的同時促進合規，也要在幫助用户獲取應用時做好風險管控。對於上線的需求有着嚴格的評估流程，會經過需求、開發、測試、上線、實驗等各個階段的各類評審與評估。通過對應用商店研發效能成熟度的評估，發現在需求管理、質量保證和持續集成方面還有很大提升的空間，為此我們的實踐重點也是從這裏展開。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;首先，通過需求的分層管理&lt;/strong&gt;，將需求拆分成可以在線上進行獨立商業驗證的特性。在評審和設計環節，我們的過程涵蓋了產品、需求、策劃以及埋點，通過持續的評審來保證正在做正確的事情。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;其次，在開發層面&lt;/strong&gt;，將業務特性分端拆分成不同的用户故事，並進行開發和測試的閉環。整個需求流程的推進，更多的依賴工具來驅動，避免人工導致的錯誤和流程執行的不到位。&lt;/p&gt; 
&lt;p&gt;比如説：1）在需求的開始，項目管理工具會自動創建需求羣，在策劃評審通過後，流程引擎會通知數據產品和設計進行埋點和 UI 設計，在所有開發準備工作完成後，自動進行分端拆分用户故事，並通知項目管理人員組織進行排期。&lt;/p&gt; 
&lt;p&gt;2）在開發完成後，項目管理工具會協助開發創建驗收單和測試單，並將必要的信息填充在工單中，開發人員所需要做的就是填寫少量的信息，並提交執行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;最後&lt;/strong&gt;，所有的項目活動，通過&lt;strong&gt;項目管理工具流程引擎&lt;/strong&gt;來驅動，讓開發專注於開發，測試專注於測試，流程的事情交給系統，力求一次性把事情做對。讓項目團隊持續、高效、高質量的進行價值交付，可以看到應用商店 2024 年上半年我們將需求研發平均交付時長優化至 17 天。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/90/90c9d756a1654d8991d21e8fe85085cc.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了上面的需求流程自動化，我們在研發過程也進行了很多優化探索。我們在整個研發階段打通各個系統之間的交互，詳細如下：&lt;/p&gt; 
&lt;p&gt;**需求階段：**我們在項目管理工具 VAPD 上對需求進行排期，確定好版本號後，通過「分支管理」 功能配合自定義的分支規範，一鍵創建並拉取各個服務的代碼分支。並將各個服務的分支與流水線、工單、代碼評審平台、發佈等系統關聯，後續所有代碼分支相關的活動都可以自動化的處理。&lt;/p&gt; 
&lt;p&gt;**開發階段：**我們設計了六條不同規格的流水線，涵蓋了我們研發的各個階段，比如「開發流水線」，會監聽所有人的代碼提交。在代碼發生變動時會自動執行我們的預先定義好的各項任務，包括各類安全檢查，靜態代碼分析及代碼規範檢查等等，將發現的問題實時通過 V 消息反饋給開發團隊，將盡可能多的檢查工作都放在開發階段，儘早暴露編碼過程中引入的各種風險和問題，實現驗證左移。&lt;/p&gt; 
&lt;p&gt;**測試階段：**當我們的開發結束，並通過，測試平台測試合格，製品晉級成功後，我們開發的產品就可以進行發佈上線了，當然這個過程仍然伴隨着各種自動化工具的配合，我們的流水線會推進整個發佈過程，自動化點檢平台會對所有的功能進行迴歸、點檢、驗證、灰度，確保發佈功能的完善。&lt;/p&gt; 
&lt;p&gt;**上線階段：**最後配合埋點、告警、監控、雲診斷等手段，將我們的發佈過程可視化。&lt;/p&gt; 
&lt;p&gt;縱觀整個過程來看，參與的角色和平台非常的多，平台很多都是獨立或者自動化能力不可達，需要人工傳遞或者手動編輯，我們將各平台能力打通，真正實現狀態和數據的自動流轉。下方也列出了我們統計到的一系列提效數據，從分支管理到工單自助，從需求建羣到任務催辦等等，最終我們在 2023 年實現開發人力節省超過 270 人天&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/67/67304a2fa5db511f54579aabb7e8bf8a.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我們介紹了更多的我們在開發編碼階段所實踐的內容，接下來看看在測試階段，我們做了哪些&lt;strong&gt;提升&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;**首先，**測試過程中最重要的一環是我們要測試什麼內容？如何圈定測試的範圍？傳統的方式是我們的測試人員根據需求，配合開發人員的意見來分析可能的業務影響範圍、編寫測試用例，整個過程其實相對主觀，靠的是我們常説的經驗主義，依賴於測試、開發人員的經驗，對業務的理解深度，以及對上下游關聯關係的掌握程度。&lt;/p&gt; 
&lt;p&gt;**其次，**這個能力是因人而異的，過程也是偏主觀的，容易造成判斷錯誤或者遺漏。所以我們要做的第一個提升就是通過工具來更客觀地分析業務的影響範圍，依據的就是代碼的差異性分析和上下游調用鏈圖譜，即通過編碼前後代碼的變化來確定哪些服務、接口受到了影響，同時結合調用鏈圖譜檢索可能被這些服務或接口影響到的上下游。這樣在一定程度是彌補了不同測試水平人員在主觀經驗上的差距，以及各個業務上下文帶來的影響。&lt;/p&gt; 
&lt;p&gt;**再次，**通過不同規格的流水線驅動，執行綁定的各類不同任務實現持續測試以及驗證左移，這些任務包括了各類自動化的檢查與驗證，功能的、性能的以及人工介入的。&lt;/p&gt; 
&lt;p&gt;**最後，**通過我們的測試準出門禁，確保製品的輸出質量，並將測試過程中產生的數據資產沉澱到後續的準出報告中。最終，在這些流水線和自動化工具的支撐下，我們整個研發階段的測試活動滲透率提升了 156%，測試執行效率提升了 35%，版本發佈的成功率也提升到了 97.27%。&lt;/p&gt; 
&lt;h1&gt;四、研發效能未來規劃&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/58/58d799ed84d310d92cc79179680e26cf.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;從上述的近幾年在研發效能關鍵場景和項目上落地情況有了一定了解，那未來計劃如何繼續推進研發效能呢？接下來我們就一起聊聊研發效能未來的規劃。&lt;/p&gt; 
&lt;p&gt;談到研發效能每個公司都面臨不一樣的情況，vivo 互聯網研發效能也經歷前前後後 4 個大的階段，從早期的開源工具化時代到場景化業務賦能時代。&lt;/p&gt; 
&lt;p&gt;**工具化時代：**早 2018 年及以前，vivo 互聯網還是主要以解決當時研發管理過程中遇到的問題和痛點展開，不斷提升研發過程白屏化、自動化，儘可能藉助開源和商業化工具 JIRA、SVN、Gitlab、Jenkins、SaltStack 等來提升研發運維效率。&lt;/p&gt; 
&lt;p&gt;**平台化時代：**隨着平台種類規模增加，用户需要基於自己的訴求去「找」平台和工具，然而平台也面臨着「找不到」用户的兩難境遇。&lt;/p&gt; 
&lt;p&gt;**體系化時代：**我們也考慮建立體系化平台，消除用户與平台的「隔離」，讓用户能夠在平台解決自己的訴求。&lt;/p&gt; 
&lt;p&gt;**場景化時代：**與大多數公司的發展一致，平台經歷多年的發展以後，隨着用户體量、業務複雜度增加，平台個性化、定製化訴求逐步導致平台維護和使用成本進一步增加，讓平台研發團隊維護成本非常高，也讓用户的訴求受到了影響。為此，如何從用户場景出發規劃和實現成為關鍵。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/c2/c236faa8ccffcba877e15f52232d107c.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;談到這裏 vivo 互聯網研發效能的未來到底是什麼？vivo 互聯網研發效能團隊結合自身經歷來看，還是要回歸本源。結合行業的先進理論體系，進一步走進業務研發團隊，找到真正的痛點與訴求，幫助業務團隊「做正確的事，把事情做正確」。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/89/89c1a86a5e21ecd2e67b541a8eb3a0e6.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;我們前面聊到對研發效能新的認知和理解，未來我們將進一步走進業務來提效。我們為此也定義三個北極星指標來牽引我們的目標達成，分別為：代碼前置變更時間 1 小時內，需求研發交付時長在 2 周內，需求實現到結果閉環 3 周內。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/0a/0a7c84afa8c12b15198215fab34ceca4.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;根據研發效能新的理解和目標，我們也多次回滾本源，思考我們的最佳路徑，總結來看就 5 個階段，分別為：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 1 階段實現工具全面自動化&lt;/strong&gt;，消除絕大部分黑屏和手工操作。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 2 階段工具實現串聯&lt;/strong&gt;，能夠結合項目研發流程初步具備自動化流轉。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 3 階段實現研發效能信息全面拉通&lt;/strong&gt;，平台之間的研效信息能夠在多個平台間自由的共享，實現多維度、多角度度量識別效能低窪，並且結合研發流程不斷提升項目的研發效能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 4 階段之後&lt;/strong&gt;，平台能夠基於平台度量的能力逐步識別項目內個性化研發場景的短板，並且結合研發效能實踐專家，深入項目內部，真正結合場景自助化、自動化進一步項目研發效能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第 5 階段就不僅僅關注項目本身的研效&lt;/strong&gt;，而是需要回歸需求本身去關注整體價值達成效果。&lt;/p&gt; 
&lt;p&gt;我們期望通過目標來牽引業務，將 OKR、項目、需求等不同層級的要素進行連接。通過可視化看到任務分解、進展、數據效果，以及資源投入和風險，真正意義上做到「一層支撐一層」，層層看得清、管得明。從而實現始終在做正確的事情。除了上面的需求流程自動化，我們在研發過程也進行了很多優化探索。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/vivotech/blog/18395466</link>
      <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18395466</guid>
      <pubDate>Sat, 10 May 2025 03:19:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>DeepSeek 使用率下降 50%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;大模型整合應用平台 Poe 發佈了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpoe.com%2Fzh%2Fblog%2Fspring-2025-ai-model-usage-trends" target="_blank"&gt;《2025 年春季 AI 模型使用趨勢報告》&lt;/a&gt;，具體來看：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;DeepSeek 的「病毒式」傳播有所減弱，其使用率從 2 月的峯值 7% 降至 4 月底的 3%，&lt;strong&gt;整體使用率下降超過 50%&lt;/strong&gt;；&lt;/li&gt; 
 &lt;li&gt;OpenAI 憑藉其在 GPT-4o 中推出新的文生圖生成器後，通過「吉卜力風格」「仿真自拍」等熱點玩法，實現了「病毒式」使用率增長；&lt;/li&gt; 
 &lt;li&gt;快手的視頻生成模型「可靈」在發佈 Kling-2.0-Master 後，用短短三週時間獲得了 21% 的 Poe 視頻生成佔有率。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Poe 還在報告中提到，發送給 Poe 內的推理模型的消息文本份額，從約 2% 增加至約 10%，其中 DeepSeek「病毒式」傳播期間達到了峯值。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-17b88f0bfc5d4ce3a6ac29f795e1d8e6276.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;另外，Poe 訂閲者對 Gemini 2.5 Pro 的使用正在迅速增長，該模型在發佈僅約 6 周內就獲得了約 30% 的推理消息份額。&lt;/p&gt; 
&lt;p&gt;具體報告：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpoe.com%2Fzh%2Fblog%2Fspring-2025-ai-model-usage-trends" target="_blank"&gt;https://poe.com/zh/blog/spring-2025-ai-model-usage-trends&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/349993/poe-spring-2025-ai-model-usage-trends</link>
      <guid isPermaLink="false">https://www.oschina.net/news/349993/poe-spring-2025-ai-model-usage-trends</guid>
      <pubDate>Sat, 10 May 2025 03:19:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
