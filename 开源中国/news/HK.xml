<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://rsshub.app/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Made with love by RSSHub(https://github.com/DIYgod/RSSHub)</description>
        <generator>RSSHub</generator>
        <webMaster>i@diygod.me (DIYgod)</webMaster>
        <language>en</language>
        <lastBuildDate>Tue, 28 May 2024 13:42:29 GMT</lastBuildDate>
        <ttl>180</ttl>
        <item>
            <title>開源日報 | Istio 七週歲；倪光南果然有遠見；AI 搜索的諸神之戰；「龍芯+鴻蒙」桌面 PC；馬斯克激情對線；SaaS 的 PLG 模式</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;歡迎閲讀 OSCHINA 編輯部出品的開源日報，每天更新一期。&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ff9900&quot;&gt;&lt;strong&gt;# 2024.5.28&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日要點&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/news/294636/happy-7th-birthday-istio&quot; target=&quot;_blank&quot;&gt;Istio 七週歲&lt;/a&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-aa0939d5f63acbd3a6b331f3a3a2c4e81a5.jpg&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 是一個由谷歌、IBM 和 Lyft 的團隊於 2016 年開始合作開發的開源項目，在 2017 年正式推出；它是一個大型微服務系統管理工具，旨在提供一種統一化的微服務連接、安全保障、管理與監控方式；基於 Lyft 的 Envoy 項目構建。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8Zx0IAFwWpp&quot; target=&quot;_blank&quot;&gt;國產開源 Sora 上新：全面支持國產 AI 算力，可用 ReVideo 視頻編輯&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;北大-兔展聯合發起的 Sora 開源復現計劃 Open-Sora-Plan，今起可以生成最長約 21 秒的視頻了！該説不説，版本迭代速度還挺快——上個月，Open-Sora-Plan 就在開源社區上新過一波。當時能支持單鏡頭 16 秒的視頻生成，分辨率最高 720p，能滿足的生成需求也比較多樣。&lt;/p&gt; 
&lt;p&gt;這次版本更新，背後主要是兩個方面有了進步：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;採用了更高質量視覺數據與 caption&lt;/li&gt; 
 &lt;li&gt;優化了 CausalVideoVAE 的結構&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;團隊還表示，Open-Sora-Plan 已經支持使用國產 AI 計算系統（華為昇騰，期待更多國產算力芯片）進行完整的訓練和推理。&lt;/p&gt; 
&lt;h3&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F782033819_121400326&quot; target=&quot;_blank&quot;&gt;浪潮信息發佈「源 2.0-M32」開源大模型&lt;/a&gt;&lt;/h3&gt; 
&lt;p&gt;浪潮信息發佈了「源 2.0-M32」 開源大模型。該模型在源 2.0 系列大模型基礎上，採用了「基於注意力機制的門控網絡」技術，構建包含 32 個專家的混合專家模型（MoE），並大幅提升模型算力效率。M32 憑藉特別優化設計的模型架構，在僅激活 37 億參數的情況下，取得了和 700 億參數 LLaMA3 相當的性能水平，所消耗算力僅為 LLaMA3 的 1/19。&lt;/p&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;今日觀察&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;社交觀察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800286621157390695%26wfr%3Dspider%26for%3Dpc&quot; target=&quot;_blank&quot;&gt;比爾蓋茨説得很對！中國芯迎重大突破，倪光南果然有遠見&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;美國修改芯片規則限制華為等中企發展，中國芯片產業需突破尖端光刻機設備。芯片架構作為關鍵，X86 和 ARM 架構主導市場但面臨被美控制風險。中國聚焦 RISC-V 架構研發，取得顯著成果打破技術壟斷，預示中國芯片產業將迎來輝煌未來。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;百家曉科技&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2795277930410887&quot; target=&quot;_blank&quot;&gt;馬斯克 xAI 估值 240 億美元，LeCun 隔空開懟，竟上升到人身攻擊&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;這兩天，AI 圈的瓜全被馬斯克 LeCun 承包了。不論是在 AI 安全監管，還是 xAI 使命上，兩人已經開啓了激烈的隔空罵戰。&lt;/p&gt; 
  &lt;p&gt;昨日，AI 領域兩位重量級人物 Yann LeCun 和 Elon Musk 就人工智能的安全性和監管問題在社交媒體上「隔空交鋒」。&lt;/p&gt; 
  &lt;p&gt;人工智能先驅 LeCun 在 X 上表達了他對正在進行的人工智能監管的看法。LeCun 認為，現在擔心人工智能帶來「生存風險」還為時過早，更別説對其進行監管了。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;新智元&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.sohu.com%2Fa%2F782034856_114819&quot; target=&quot;_blank&quot;&gt;詳解 SaaS 的 PLG 模式&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;這時的基礎設施已經成為可以根據需要進行擴展的彈性實用程序，開發者可以從 API、模塊化的工具中更快捷地編寫軟件，軟件數量爆發式增長，新軟件試用/使用的門檻逐漸走低。&lt;/p&gt; 
  &lt;p&gt;這一時期主要是 PLG，產品主導增長，決策權進一步下放到軟件的真正使用者，他們的採購標準通常是——個人生產力，即該軟件是否真的能幫助到我的日常工作？&lt;/p&gt; 
  &lt;p&gt;與此同時，一個新的線索衡量指標——PQL（Product Qualified Leads，產品合格線索）出現。MQL 通常依賴產品之外的公開課、白皮書、線下會議等方式獲取，而 PQL 是用户真正體驗產品後達到某些數據維度要求後的線索。有數據表明 PQL 的轉化率通常為 15%～30%，遠高於 MQL。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- &lt;strong&gt;人人都是產品經理&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1704750133%2FOgo1F2H4n%3Frefer_flag%3D1001030103_&quot; target=&quot;_blank&quot;&gt;NAS 開源的導航頁&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;Heimdall，模塊化設計，可以根據需要添加或刪除模塊。支持 Plex、Jellyfin、Nextcloud、Emby 等。可自定義主題和佈局，支持多用户登錄。&lt;/p&gt; 
  &lt;p&gt;Dashy，可定製性比較高，界面友好，可以拖拽操作。支持書籤管理、應用快捷方式、服務狀態監控等功能，非常適合 NAS 環境下的資源管理和快速訪問。&lt;/p&gt; 
  &lt;p&gt;Organizr，支持用户權限管理，可以為不同用户分配不同的訪問權限，模塊豐富，比如 Sonarr、Radarr、Plex，插件也很豐富。&lt;/p&gt; 
  &lt;p&gt;SUI，極簡風格，支持 JSON 文件快速配置，佔用資源極少，適合在資源有限的 NAS 設備上運行。&lt;/p&gt; 
  &lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9fe92adf9c6bea2b77c4dede62ac2f4c374.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;- 微博&amp;nbsp;&lt;strong&gt;你的檔案&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒體觀察&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.doit.com.cn%2Fp%2F513146.html&quot; target=&quot;_blank&quot;&gt;《全球軟件供應鏈發展報告》發佈：JFrog 引導軟件供應鏈安全市場&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;在通過開源生態系統引入漏洞方面，並非所有的軟件技術都表現一樣。雖然 Debian 和 RPM 的漏洞最多，但 NPM 和 PyPI 的嚴重 CVE 漏洞佔比最大，其次是 Maven。大多數的 Debian 和 Alpine 代碼庫都是 C/C++代碼和 Linux。由於二者都是 Linux 系統，用户很可能會在這兩種軟件包類型中發現相同的漏洞，Debian 的漏洞更多，因為它的應用更為廣泛，貢獻的軟件包也更多。&lt;/p&gt; 
 &lt;p&gt;但是，存在 CVE 並不一定意味着該軟件包不能使用，更要緊的是監控和防止惡意軟件包進入軟件供應鏈，因為即使只是下載這些軟件包也可能使企業遭受攻擊。攻擊者也意識到，開源軟件包和使用這些軟件包的開發人員是安全漏洞的「黃金通行證」。他們的攻擊方式往往是利用 CVE 帶來的缺陷（通常是使用開源軟件包的開發人員無意中造成），或者引入他們自己的惡意軟件包，偽裝成安全的開源組件。&lt;/p&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- DOIT&lt;/strong&gt;&lt;/p&gt; 
 &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.huxiu.com%2Farticle%2F3075895.html&quot; target=&quot;_blank&quot;&gt;AI 搜索的諸神之戰&lt;/a&gt;&lt;/h4&gt; 
 &lt;p&gt;有人搜索如何讓番茄醬粘在 Pizza 上，答案是用 1/8 杯無毒膠水。後來人們發現這是來自社區 Reddit 上 11 年前有人開玩笑的回答。谷歌自去年開始上線生成式 AI 搜索後，它總結出來的答案不時出錯，這次全面推出的 Overview 功能，立刻翻車了。&lt;/p&gt; 
 &lt;p&gt;是不是推理不夠，就用搜索來湊？這也是大模型幻覺的老問題，只是因為谷歌搜索的量太大了，問題會更加突出。還有一個把 Reddit 上的玩笑當科學的回答：貓舔你的手，是想先嚐下你能否被消費。&lt;/p&gt; 
 &lt;p&gt;人們搜索到的東西越來越豐富，也越來越智能，但也令它們有了浮誇之感。&lt;/p&gt; 
 &lt;p&gt;人們開始懷念十多年前的谷歌，那時第一頁上只出現十個藍色的鏈接，並附有每個結果的頁面標題和簡短的文本片段。這種只有大約 10 個網頁鏈接的簡約設計，在第一頁被稱為「十個藍色鏈接」格式。那時沒有那麼多的 Shit。&lt;/p&gt; 
 &lt;p style=&quot;text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ffffff; color:#2b2b2b&quot;&gt;未盡研究&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcio.zhiding.cn%2Fcio%2F2024%2F0528%2F3158096.shtml&quot; target=&quot;_blank&quot;&gt;CIO 指南：採用開源生成式 AI 需要注意的十件事&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;開源生成式 AI 模型是可以免費下載的、大規模使用而無需增加 API 調用成本的，並且可以在企業防火牆後面安全運行。但你不要放鬆警惕，風險仍然存在，有些風險不僅被放大了，而且針對生成式 AI 的新風險正在出現。&lt;/p&gt; 
  &lt;p&gt;企業應該知道該怎麼做才能確保他們使用的是經過適當許可的代碼，如何檢查漏洞，如何保持所有內容都已經修補並保持最新狀態。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 至頂網&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2794264329137796&quot; target=&quot;_blank&quot;&gt;OpenAI 悄悄招募了 Altman 投資的安全團隊，但與超級對齊無關&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;Indent 成立於 2018 年，從事數據安全相關業務，它所提供的服務也很簡單——自動化處理訪問權限的審批流程。&lt;/p&gt; 
  &lt;p&gt;比如，當工程師需要查看生產服務器日誌或客户支持需要敏感系統的管理員權限時，他們可以使用 Indent 的應用程序請求訪問權限，而無需 IT 部門的幫助。審閲者可以通過 Slack 收到消息並直接從那裏批准，然後一旦時間到期，訪問權限就會自動撤銷。&lt;/p&gt; 
  &lt;p&gt;Indent 為公司中的每個人提供按需訪問控制，讓他們可以在需要時訪問自己需要的內容。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 甲子光年&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2F36kr.com%2Fp%2F2794201924873859&quot; target=&quot;_blank&quot;&gt;馬斯克 xAI 獲 60 億美元融資，要造一個「超級算力工廠」&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;xAI 新獲得的 B 輪融資，在一定程度上幫助其解決了財務負擔。但馬斯克自己也曾承認，如果要在 AI 賽道擁有競爭力，那麼每年至少要花幾十億美元。&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;無論是給人腦植入微芯片的 Neuralink ，做類人機器人的 Optimus， 還是智能的 Grok AI 助手，馬斯克這些積極推進的項目都隱約指向一個終極目標：通用人工智能（AGI）。&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;xAI 還有很長的路要走，並且在努力成為規則改變者。不過，現在看來，英偉達可能才是目前最大的贏家。&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 愛範兒&lt;/strong&gt;&lt;/p&gt; 
  &lt;h4&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fishare.ifeng.com%2Fc%2Fs%2F8Zx0IAFwWpq&quot; target=&quot;_blank&quot;&gt;多模態 CoT 思維鏈架構來了，現已開源｜來自廈大&amp;amp;騰訊優圖&lt;/a&gt;&lt;/h4&gt; 
  &lt;p&gt;廈門大學&amp;amp;騰訊優圖團隊提出一種名為「領唱員（Cantor）」的決策感知多模態思維鏈架構，無需額外訓練，性能大幅提升。&lt;/p&gt; 
  &lt;p&gt;在 ScienceQA 上，基於 GPT-3.5 的 Cantor 準確率達到了 82.39%，相比基於 GPT-3.5 的思維鏈方法提升了 4.08%。&lt;/p&gt; 
  &lt;p&gt;在更具挑戰性的 MathVista 上，基於 Gemini 的 Cantor 準確率比原始 Gemini 提高了 5.9%。&lt;/p&gt; 
  &lt;p style=&quot;text-align:right&quot;&gt;&lt;strong&gt;- 量子位&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;今日推薦&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;開源項目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fskylot%2Fjadx&quot; target=&quot;_blank&quot;&gt;skylot/jadx&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;324&quot; src=&quot;https://static.oschina.net/uploads/space/2022/0620/104307_gSwa_5430600.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fskylot%2Fjadx&quot; target=&quot;_blank&quot;&gt;https://github.com/skylot/jadx&lt;/a&gt;&lt;/u&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;JADX 是一個&amp;nbsp;Dex 到 Java 的反編譯器，&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#24292f&quot;&gt;用於從 Android Dex 和 Apk 文件生成 Java 源代碼。&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;JADX 有命令行和 GUI 兩個版本。&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;每日一博&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://my.oschina.net/u/5783135/blog/11194314&quot; target=&quot;_blank&quot;&gt;Bookie 存儲架構源碼剖析&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;Pulsar 作為新一代 MQ 中間件，在底層架構設計上充分貫徹了存算分離的思想，broker 與 Bookeeper 兩個組件獨立部署，前者負責流量的調度、聚合、計算，後者負責數據的存儲，這也契合了雲原生下 k8s 大行其道的時代背景。Bookeeper 又名 Bookie ，是一個單獨的存儲引擎。在組件關係上，broker 深度依賴 Bookie，內部集成了 Bookie 的 client 端，broker 和 Bookie 之間基於 TCP 通信，使用 protobuf。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;330&quot; src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7ae3724a6738446d9eaa24a3989b2304~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=KN6gea6ImIlHS7pxV%2BTu63QB%2B%2Bs%3D&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;div&gt; 
 &lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;事件點評&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;/div&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FkNMJX3WEghxkOF81o_4ctw&quot; target=&quot;_blank&quot;&gt;龍芯自主龍架構 2024 年已適配 318 款產品、有望推出「龍芯+鴻蒙」桌面 PC&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;龍芯中科每個月都會公佈 LoongArch 龍架構的生態適配進展，2024 年 4 月又新增了 110 款，加上此前 3 月的 101 款、1-2 月的 107 款，今年以來已達 318 款。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這些適配產品面向網絡安全、數據安全、日常辦公、智慧教學、人工智能、醫療健康等諸多領域。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;334&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0f07ad4a6460ea9f69e093282f112f8f5a1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;點評&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;龍芯與鴻蒙操作系統的結合，預示着國產軟硬件強強聯合的新局面。這種結合不僅能夠推動國產操作系統的發展，還能促進國產處理器的市場競爭力。龍芯 3A6000 性能達到英特爾 10 代酷睿 i3 的水平，顯示了國產處理器在性能上的顯著提升。同時，二進制翻譯技術的發展將有助於提高軟件兼容性，進一步拓寬應用場景。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;LoongArch 龍架構在 2024 年已適配 318 款產品，這表明龍芯正在快速擴大其軟件生態，這對於吸引更多開發者和企業使用龍芯平台至關重要。龍芯 3A6000 的成功不僅對處理器市場有積極影響，還將推動上下游產業鏈的發展，包括操作系統開發商、軟件開發商和硬件製造商等。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;在全球半導體產業格局中，龍芯的發展也可能促進國際合作，同時在某些領域形成競爭，這對於全球技術進步和產業生態都是有益的。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;雖然龍芯 3A6000 展現出良好的性能和自主化程度，但面對國際知名品牌的競爭，如何在市場中脱穎而出，仍是一個挑戰。需要通過持續的技術創新、市場推廣和用户體驗優化來實現。&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
&lt;/ol&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294625&quot; target=&quot;_blank&quot;&gt;馬斯克和 「AI 教父」 激情對線&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;起因是馬斯克轉發了一條為自己 xAI 公司招人的&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;推文&lt;/a&gt;。&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;沒成想被有 「AI 教父」 之稱的楊立昆當場拆台，言語間盡是嘲諷。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;342&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-42deaf887656eb50e3b3a7d15076d52d3b4.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;點評&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;馬斯克和 LeCun 之間的爭論不僅是兩位科技領袖之間的觀點碰撞，也反映了 AI 領域當前面臨的一些關鍵問題和挑戰。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;馬斯克和 LeCun 分別代表了業界和學術界對於 AI 技術的不同立場。馬斯克關於 AI 可能帶來的風險和挑戰的言論，引發了公眾對於人工智能安全性和倫理問題的關注。這種擔憂在一定程度上推動了對 AI 監管和倫理準則的討論。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;爭論觸及了技術發展與倫理考量之間的平衡問題。如何在推動技術創新的同時確保倫理和社會責任，是 AI 領域亟待解決的問題。這場公開爭論可能會影響未來的 AI 政策和法規制定。政策制定者可能會更加重視來自不同領域的意見和建議。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;爭論中提出的觀點和問題可能會激發 AI 研究者對現有技術和方法的反思，促進更深入的研究和創新。儘管存在分歧，但這樣的公開討論也可能促進不同背景的專家之間的合作，共同推動 AI 技術的發展和應用。&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294691&quot; target=&quot;_blank&quot;&gt;百度沈抖迴應大模型價格戰：希望大家別再天天拉表格比價格&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;「其實我們決定免費的原因特別樸素，就是希望大家別再天天拉表格比價格了，有這個時間，不如去卷場景、卷應用。現在成本更低了，大家創新的膽子可以更大一些、步子可以更快一些，把相關的場景都試一遍，快速驗證。跑成功了，就快速複製。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;258&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9e74eeb2b39092d87ea08dcc53d2999cd27.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;點評&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度沈抖的發言不僅是對當前 AI 大模型價格戰的迴應，也是對整個行業發展方向的一次重要引導。沈抖的發言體現了百度希望推動行業從價格競爭轉向創新競爭的願景。他鼓勵業界不要過分關注價格比較，而是應該投入更多精力於探索應用場景和加速創新。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖的發言暗示了百度對未來 AI 應用的樂觀態度，預計隨着成本的降低和技術的成熟，AI 將在更多行業中發揮關鍵作用。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#1f2328; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度的這一策略可能會改變 AI 大模型市場的競爭格局，促使其他企業也更加註重技術創新和服務優化，而非單純的價格競爭。也可能對行業標準產生影響，促使業界思考如何制定更加健康、可持續的發展模式。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;hr&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#27ae60&quot;&gt;&lt;strong&gt;開源之聲&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;媒體觀點&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.yoojia.com%2Farticle%2F8982063525401688813.html&quot; target=&quot;_blank&quot;&gt;從降價到免費，大模型的「進」與「退」&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;當前大模型在各行各業的應用落地處於初級階段。除了價格，能否解決客户業務痛點並創造價值，是大模型發展的關鍵。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;- &lt;strong&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;中國證券報&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800209461494388621&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#2980b9&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;AI 出大招，蘋果要出奇制勝&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#000000; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;蘋果在 AI 時代姍姍來遲，固然有等技術成熟的考量，但也付出了銷量下滑的代價，如今面對同行競爭，蘋果在 AI 上能否出奇制勝是市場關注重點，在專家看來，蘋果在 AI 上預計也不會太激進，還是以鞏固自身生態為第一目標。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;- &lt;strong&gt;北京商報&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.21jingji.com%2Farticle%2F20240527%2Fherald%2F5f7b347c2787de4bf776584f95950075.html&quot; target=&quot;_blank&quot;&gt;美國大模型出口限制法案再進一步，「套殼」大模型危？&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
 &lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#292934&quot;&gt;中國大模型市場要警惕「加拉帕戈斯隱憂」——加拉帕戈斯是太平洋上的一個羣島，它比喻的是在一個孤立的環境中，獨自自我進化，逐步放棄對外交換。一旦再次面對外部適應性、生存能力更高的品種，最終會陷入被淘汰的危險。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;-&amp;nbsp;&lt;/span&gt;&lt;strong&gt;21 世紀經濟報道&lt;/strong&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaijiahao.baidu.com%2Fs%3Fid%3D1800247492453152257&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#2980b9&quot;&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;「拼價格」推動大模型產業邁入新階段&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;價格機制是市場機制的核心運行機制，價格競爭是市場競爭的集中體現。因為有價格競爭，企業才能感受到市場壓力，從而努力提高生產效率、提升產品質量、強化產品差異化程度、用心服務客户，以保持性價比優勢。價格競爭是一個產業從小到大、從弱到強的必經階段，不可或缺。正是一輪輪價格競爭篩選出了一批批優質企業，讓產業呈現出螺旋式上升的發展特徵。因此，要做強產業，必然要經過價格競爭的洗禮，大模型產業也不例外。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:right&quot;&gt;- &lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;中國經濟網&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;strong&gt;&lt;span style=&quot;background-color:#ff9900&quot;&gt;用户觀點&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIa-OODj7x8PhkzQ2Sat6wQ&quot; target=&quot;_blank&quot;&gt;最適合寫代碼的等寬字體 Cascadia Code&lt;span&gt;——&lt;/span&gt;三年來首次大版本更新：由微軟開源、新增兩款 Nerd 字體&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 1：英文還是 JetBrain Mono，中文就改成落霞孤鶩了，這樣寫中文註釋就像古文一樣，coding 的時候特別有感覺&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 2：還是 Fira Code 和 JetBrain Mono 用在 IDE 裏舒服一些，Cascadia Code 更適合終端&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 3：中英文全部包含的等寬只有，更紗黑體，github 搜 Sarasa Gothic，如果寫代碼不考慮中文等寬，github 搜 hack font 也不錯&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 4：consolas yyds&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 5：手動嘗試了一百多款字體，只有 mononoki 一款算得上是漂亮的字體&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 6：原汁原味最好了。連字體這種特性，屏蔽了其原始狀態，個人認為不適合學習&lt;/span&gt; 
   &lt;ul&gt; 
    &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 7：那你可能沒有遇到過終端需要顯示圖標的。&lt;/span&gt;&lt;/li&gt; 
   &lt;/ul&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 8：連字體真的是一項很變態的發明…嚴重降低了代碼的可讀性。對於新手，很多情況下，只能靠先把連字符號腦補為非連字的版本。而且經常需要仔細觀察連字的寬度，來判斷它到底是什麼符號。真的是非常變態…即使對於常用者，你也很難熟記每一個符號的含義。冷不丁遇到一個不認識的符號，還得查它到底是什麼。真的很煩。除了裝，我想不到它到底有什麼實用性。&lt;/span&gt; 
   &lt;ul&gt; 
    &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 9：常用的連字符就那麼幾種情況，基本上都是望文生義的，如果這都能對你編程造成影響，那我只能勸你多寫代碼了。而且這個也不是強制使用的，你完全可以不用，但是隨意貶低可不是個好品質&lt;/span&gt;&lt;/li&gt; 
   &lt;/ul&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 10：個人認為最適合寫代碼的字體還得是 Hack。&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 11：Courier New&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 12：ubuntu mono 才是最好的&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 13：啥字體無所謂，我只求：1.g 不是這種花式寫法，看了頭疼；2.小 l 和 1 能區分開。如果不滿足條件 1，我寧可用 Courier New 這種違背條件 2 的&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 14：一直在用這款字體，建議把 font weight 設置成 300，效果更加&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FkNMJX3WEghxkOF81o_4ctw&quot; target=&quot;_blank&quot;&gt;龍芯自主龍架構 2024 年已適配 318 款產品、有望推出「龍芯+鴻蒙」桌面 PC&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 1：龍芯加鴻蒙，那可以整一個來玩玩&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 2：草台班子套餐&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 3：只要有進步就應該支持、誰又不是從啥也不是開始的呢？&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 4：如果便宜點，倒可以整個來玩玩，&lt;img alt=&quot;[微笑]&quot; src=&quot;https://res.wx.qq.com/mpres/zh_CN/htmledition/comm_htmledition/images/pic/common/pic_blank.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;太貴可玩不起，&lt;img alt=&quot;[憨笑]&quot; src=&quot;https://res.wx.qq.com/mpres/zh_CN/htmledition/comm_htmledition/images/pic/common/pic_blank.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;窮鬼一枚&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 5：趕緊多賣點，把售價做下來&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 6：在？搞幾台抽個獎&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_MYBiooOBtC5u7-m-JmC2A&quot; target=&quot;_blank&quot;&gt;原來東子的「兄弟」是用 let 定義的「兄弟」&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點:1：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;很好的文章，令我的前端知識增長&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 2：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;知識以一種奇怪的方式流進了我的腦&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 3：&lt;/span&gt; &lt;pre&gt;&lt;code&gt;let temp=(workingStatus===100%）?&quot;xiong di&quot;:「xiong die」;
doSomething(temp);&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 4：&lt;/span&gt; &lt;pre&gt;&lt;code&gt;if（剝削價值&amp;lt;30000/月）
      is_Bro = false&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 5：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;東哥的兄弟是未被 final 修飾的變量定義，可以隨時在運行中重新賦值&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 6：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;本來就是這樣，來混日子的，你能認他兄弟嗎&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 7：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;所以説員工就是員工，不要拿兄弟這種詞來套近乎&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 8：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;不能給企業帶來利益誰跟你兄弟🤣 「兄弟」就是忽悠騾子幹活的胡蘿蔔🥕，甚至還不如胡蘿蔔，胡蘿蔔還能拿來吃呢，「兄弟」能幹什麼？滿足你跟大企業家「稱兄道弟」的虛榮心嗎？ 不過現在確實越來越難過了，錢越來越難賺，對於沒資本的人而言就只能拼命幹拼命幹，也沒啥別的路子能走。只能卷唄，不然誰給發錢啊？&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 9：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;起碼人家加錢了&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 10：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;有價值才是兄弟&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 11：&lt;/span&gt;&lt;span style=&quot;color:rgba(0, 0, 0, 0.9)&quot;&gt;是 list 對象，隨時可以 clear&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 12：&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:rgba(0, 0, 0, 0.9)&quot;&gt;起碼漲薪之後才説的，而且説的也沒啥問題&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/news/294608/tklog-released&quot; target=&quot;_blank&quot;&gt;Rust 的高效易用日誌庫 — tklog&lt;/a&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點:1：很好，支持自動分割！&lt;/span&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;觀點 2：示例寫的真醜&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;em&gt;&lt;strong&gt;---END---&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;最後，歡迎掃碼下載「開源中國 APP」，閲讀海量技術報告、程序員極客分享！&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d27cc3636c021c266537f4729dc0f84fdc3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294724</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294724</guid>
            <pubDate>Tue, 28 May 2024 12:32:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>大學四年級（1990 年）就會寫的程序，現在的計算機系同學反而寫不出</title>
            <description>同濟大學的一名老師感嘆稱，他在大學四年級（1990 年）就會寫的程序——表達式分析，現在的計算機系同學反而寫不出。而且當時還沒互聯網，所以完全是裸寫。 他還説道：「沒有這個功底，我也不...</description>
            <link>http://osc.cool/9tJSU6sD</link>
            <guid isPermaLink="false">http://osc.cool/9tJSU6sD</guid>
            <pubDate>Tue, 28 May 2024 10:43:00 GMT</pubDate>
        </item>
        <item>
            <title>百度沈抖迴應大模型價格戰：希望大家別再天天拉表格比價格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 2024 智能經濟論壇上，百度集團執行副總裁、百度智能雲事業羣總裁沈抖介紹了文心繫列主力大模型免費背後的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「其實我們決定免費的原因特別樸素，就是希望大家別再天天拉表格比價格了，有這個時間，不如去卷場景、卷應用。現在成本更低了，大家創新的膽子可以更大一些、步子可以更快一些，把相關的場景都試一遍，快速驗證。跑成功了，就快速複製。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;258&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-9e74eeb2b39092d87ea08dcc53d2999cd27.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖表示，模型免費以及降價，主要是依託於技術能力，尤其是 AI 異構算力管理平台和「一雲多芯」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「大家非常關注自主可控。在芯片層，我們有自研的芯片崑崙芯，正在逐步推向市場；當然，如果有其它廠商的芯片，百舸計算平台也能很好地管理起來。在框架層，我們有自研的深度學習框架飛槳，已經成為國內最受歡迎的開源框架。在模型層，我們會保障模型的內容安全可控。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;沈抖表示，目前，百度文心大模型已經擁有中國最大的產業落地規模，超過半數的央企正在使用百度智能雲。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294691</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294691</guid>
            <pubDate>Tue, 28 May 2024 09:18:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>JavaScript、Python 和 Java 為何一直是開發者的首選</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Azul 公司的副首席技術官 Simon Ritter &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.infoworld.com%2Farticle%2F3715288%2Fwhy-enterprises-rely-on-javascript-python-and-java.html&quot; target=&quot;_blank&quot;&gt;撰文探討了&lt;/a&gt; JavaScript、Python 和 Java 三種編程語言經久不衰的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;他在文中指出，儘管雲計算、移動開發和 AI 取得了長足進步，但全球企業的日常業務仍依賴於上世紀 90 年代問世的三種編程語言。在幾乎所有的排名系統中，JavaScript、Python 和 Java 都位居最流行語言的前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;譬如自 2014 年以來，三巨頭在 GitHub 的年度「Octoverse 狀態」報告中每年都佔據了前四名中的三席。「&lt;strong&gt;為什麼這些編程語言巨頭在近 30 年的時間裏一直是開發人員的首選，沒有任何跡象表明它們會被淘汰出局？&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;281&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2282290f1d81552159a064111841b56f170.webp&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;具體分析如下：&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;JavaScript（580 萬用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;正如後端由 Java 驅動，前端則由 JavaScript 驅動。網頁上的所有交互活動都是由 JavaScript 編寫和控制的，十年來，JavaScript 在 GitHub 編程語言排名中一直穩居第一。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;JavaScript 及其服務器端配套語言 Node.js 於 1995 年首次亮相後不久便因其簡潔性和多功能性而大受歡迎。通過與用於構建網頁的 HTML 語言無縫協作，JavaScript 成為了 Web 開發的標準，甚至在移動應用開發興起之時也是如此。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;從谷歌、YouTube 到 Facebook，你都能找到 JavaScript 的身影。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Python（520 萬用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Python 於 1991 年首次亮相，是三大語言中最古老的語言。作為一種腳本語言，Python 的主要優勢在於進行查詢、自動執行任務和分析數據。目前，該編程語言在現代大數據和分析應用程序中越來越受歡迎。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;亞馬遜、Netflix、Spotify 和 Instagram 上的應用程序都是用 Python 編寫的。它在 2019 年的 GitHub 報告中超越 Java，位居第二，甚至在 2022 年的受歡迎程度增長了 22.5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;儘管 Python 在 one-off、general-purpose tasks 方面表現出色，但它最大的缺點在於速度。它在支持實時任務或毫秒級金融交易方面無法與 Java 匹敵。儘管如此，它仍然是軟件開發人員的首選 ，也是僱主最看重的技能之一。&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Java（320 萬用户）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Java 為大多數企業應用程序提供了底層編程架構。Azul 的 Java 現狀調查和報告發現，絕大多數（98%）的企業繼續在其軟件應用程序或基礎架構中使用 Java，其中 57% 的組織表示 Java 是其大多數（60% 或更多）應用程序的支柱。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用 Java 構建應用程序既快速又簡單，同時用 Java 構建的應用程序越多，開發過程也就越簡單、越快。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;應用程序很少是從零開始開發的；大多是使用各種技術組合而成的。而 Java 的真正優勢在於無數的框架、庫和開源材料，使得開發人員可以非常快速地創建應用程序；並且知道這種組合都已經過了實戰檢驗，行之有效。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，Java 之所以能名列前茅，不僅僅是因為它的歷史實力。Java 每六個月就會進行一次重要的功能和性能更新，每季度還會發布一些小的改進、錯誤修復和安全更新。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;它還具有適應新技術的靈活性。Java 22 可能將用於管理大語言模型和生成式 AI 在企業應用中的應用。&lt;/span&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Simon Ritter 還引用了 Gartner 副總裁兼研究總監 Linda Ivy-Rosser 的觀點，即：「企業軟件......歷來被視為一種支持功能，缺乏創新，需要很長時間才能從精心設計的應用戰略中獲益。面對熟練開發人員的短缺和 IT 預算的緊縮，企業規避風險，通常不急於改變任何沒有壞掉的東西，這是可以理解的。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;與此同時，還沒有其他編程語言能以如此強勁的勢頭和實力取代 Java、Python 和 JavaScript，成為軟件開發的基本組成部分。這三種語言已成為當今數字業務運行方式的基本要素，並將在多年後繼續發揮重要作用。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294654/javascript-python-and-java-enterprises</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294654/javascript-python-and-java-enterprises</guid>
            <pubDate>Tue, 28 May 2024 07:15:09 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>武漢 LUG 活動回顧 | 4 大技術分享！乾貨滿滿，熱鬧非凡！</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;text-align:center&quot;&gt;&lt;img height=&quot;383&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-74b0116b6fb4ba3cd6e962be5942d9a776e.jpg&quot; width=&quot;900&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;內容來源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fzh%2F2024-05-whlug%2F&quot; target=&quot;_blank&quot;&gt;deepin（深度）社區&lt;/a&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span&gt;2024 年 5 月 25 日下午，由 deepin（深度）社區與&lt;/span&gt;華中科技大學開放原子開源俱樂部聯合&lt;span&gt;舉辦的武漢 Linux 愛好者線下沙龍活動（WHLUG）在華中科技大學成功舉辦。&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;&lt;span&gt;本次活動聚集了近 40 名來自武漢地區的 Linuxer 線下參與，共同探討技術話題，分享技術經驗和見解，現場氣氛熱烈。讓我們一起回顧本次活動的精彩瞬間吧！&lt;/span&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;752&quot; src=&quot;https://storage.deepin.org/thread/202405280613017359_20240527135900.jpg&quot; width=&quot;1003&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;活動伊始，來自&lt;strong&gt;華中科技大學網絡空間安全學院的宋靜怡&lt;/strong&gt;同學為大家帶來了《自動化生成漏洞復現環境與大規模高精確度的漏洞信息獲取》的主題分享。&lt;/p&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;753&quot; src=&quot;https://storage.deepin.org/thread/202405280620524629_20240527160622.jpg&quot; width=&quot;1005&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;華中科技大學網絡空間安全學院&amp;nbsp; / 宋靜怡&lt;/em&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;據宋靜怡介紹，漏洞復現是緩解漏洞的關鍵步驟，也是確定漏洞存在的最準確方式，然而這一過程不僅要求深厚的專業知識儲備，同時也需要投入大量的人力。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;考慮到 Docker 是目前最便捷的漏洞復現方式，能夠很好地解決環境配置問題，Vulhub 作為一個面向大眾的開源漏洞靶場，是一個基於 Docker 和 Docker-compose 的漏洞環境集合，只需進入對應目錄並執行一條語句，即可啓動一個全新的漏洞環境。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;所以俱樂部系統設計了 S2VulHub 工具，用於自動化生成復現漏洞所需的 Dockerfile。通過 S2VulHub，大家可以方便地復現與調試漏洞，並進一步獲取精確的漏洞軟件版本信息，從而進一步提升開源漏洞數據庫質量。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;S2VulHub：&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhust-open-atom-club%2FS2VulnHub&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;em&gt;https://github.com/hust-open-atom-club/S2VulnHub&lt;/em&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;接下來，&lt;strong&gt;deepin（深度）社區的研發工程師 asterwyx&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;詳細介紹了 dde-shell 項目，深入探討了其基本架構、開發運行依賴關係和分進程插件機制，並與大家分享了 dde-shell 的未來規劃發展。&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;752&quot; src=&quot;https://storage.deepin.org/thread/202405280620264951_20240527140429.jpg&quot; width=&quot;1003&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;deepin（深度）社區的研發工程師 / asterwyx&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;據 asterwyx 介紹，dde-shell 作為 deepin 新一代的桌面環境，會逐漸取代以往 DDE 的各個系統組件，新一代 dde-shell 基於 QML 開發，具有更靈活的開發模式。&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;目前，dde-shell 包含「Applet、Containment、Panel」三個層級、在同一個 dde-shell 進程中，組件加載呈現樹形結構，dde-shell 負責加載所有的 Panel，並會遞歸地加載從屬於對應 Panel 的 Applet。此外，Applet 與 Panel 存在父子關係，可以通過配置文件靜態指定，其中同一個 Applet 可以被不同的 Panel 加載。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;dde-shell：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Fdde-shell&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/linuxdeepin/dde-shell&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  緊着着，
  &lt;strong&gt;deepin（深度）社區的研發工程師 rewine&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;為大家帶來了《為 Treeland 實現平鋪式佈局邏輯》主題分享。
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;749&quot; src=&quot;https://storage.deepin.org/thread/202405280622512710_20240527140120.jpg&quot; width=&quot;999&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;deepin（深度）社區的研發工程師 / rewine&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;rewine 提到，平鋪式窗管是以不重疊畫面的方式組織屏幕畫面，相比堆疊佈局，平鋪式佈局在純鍵盤情景下操作更為高效。而 Treeland 作為 deepin 的下一代 Wayland 窗口管理器，基於 wlroots 開發，目前已實現了 layer-shell 等常用的 Wayland 協議，在設計上可以同時支持堆疊式和平鋪式兩種佈局。&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;Qt 作為跨平台的 C++應用程序開發框架，目前被廣泛用於 GUI 程序開發。QtQuick 的聲明式方法使得用户界面的定義和實現更加簡單直觀，與傳統的命令式 GUI 編程相比更具優勢。於是我們通過 waylib 項目，將 wlroots 和 QtQuick 深度結合，極大簡化了窗管的開發難度，僅需掌握 QML 即可參與其中。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;Treeland：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Flinuxdeepin%2Ftreeland&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/linuxdeepin/treeland&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;waylib：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvioken%2Fwaylib&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/vioken/waylib&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  最後，來自
  &lt;strong&gt;華中科技大學網絡空間安全學院的丁鵬宇&lt;/strong&gt;同學為大家介紹了 pwn.hust.college 平台。據介紹，pwn.hust.college 是由華中科技大學網絡空間安全學院白帽黑客團隊所創建的基於神奇寶貝動畫設計的趣味教育學習平台，堅持「未知攻，焉知防」與「實踐出真知」的設計理念，致力於讓學生或其他感興趣的團體學習和動手實踐核心網絡空間安全的概念。
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;749&quot; src=&quot;https://storage.deepin.org/thread/20240528062415174_20240527140038.jpg&quot; width=&quot;999&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;華中科技大學網絡空間安全學院&amp;nbsp; &amp;nbsp;/ 丁鵬宇&lt;/em&gt;&lt;/p&gt; 
  &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;進入首頁後，同學們即可化身成為神奇寶貝訓練家，在神奇寶貝道館時間理論課堂中探索軟件安全的核心攻防技術。從入門篇、初級篇、中級篇，一直到高級篇的多個關卡，涵蓋了平台食用指南、Pwntools 使用、緩衝區溢出、Shellcode 注入等內容。通過完成這些挑戰，便可以獲得相應的道館徽章，並最終成為技嫺熟的白帽黑客。&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;&lt;em&gt;Dojo：&lt;/em&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fhust-open-atom-club%2Fdojo&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://github.com/hust-open-atom-club/dojo&lt;/em&gt;&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;h1&gt;&lt;span&gt;&lt;strong&gt;關於 WHLUG&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;WHLUG （武漢 Linux 用户組）由 deepin（深度）社區於 1997 年發起創立，創建的初衷是為武漢地區的 Linux 愛好者們提供一個不受外界幹擾的技術討論氛圍，讓每一個技術愛好者回歸技術本質，構建武漢最純粹的 Linux 技術討論圈子，持續推動武漢本地開源社區文化的發展。&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;217&quot; src=&quot;https://storage.deepin.org/thread/202401220823526444_%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17059114451088.png&quot; width=&quot;807&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;em&gt;WHLUG 聚會基本形式&lt;/em&gt;&lt;/p&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;我們誠摯地歡迎武漢地區的&lt;strong&gt;學生/開源愛好者&lt;/strong&gt;加入，共同參與到 WHLUG 活動的策劃和組織中，同時，熱忱歡迎&lt;strong&gt;各高校社團&lt;/strong&gt;與我們攜手，為構建武漢最純粹的 Linux 技術圈和推動本地開源發展貢獻力量。&lt;/p&gt; 
   &lt;p style=&quot;margin-left:0; margin-right:0&quot;&gt;若您對參與活動共建感興趣，請&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwj.qq.com%2Fs2%2F13816139%2F8b53%2F&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;點擊「此處」&lt;/strong&gt;&lt;/a&gt;或&lt;strong&gt;掃碼&lt;/strong&gt;填寫報名錶，我們的工作人員將會與您取得聯繫，期待與您一同開啓這段激動人心的開源之旅！&lt;/p&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:center&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;235&quot; src=&quot;https://storage.deepin.org/thread/202403250931175203_WHLUG%E5%85%B1%E5%BB%BA%E6%8A%A5%E5%90%8D.png&quot; width=&quot;235&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;span&gt;&lt;strong&gt;deepin 鏡像下載地址：&lt;/strong&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.deepin.org%2Fdownload%2F&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;www.deepin.org/download/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&lt;strong&gt;deepin 歷史版本鏡像獲取（V20 前）：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdistrowatch.com%2Findex.php%3Fdistribution%3Ddeepin&quot; target=&quot;_blank&quot;&gt;https://distrowatch.com/index.php?distribution=deepin&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294652</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294652</guid>
            <pubDate>Tue, 28 May 2024 06:50:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>Istio 七週歲</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cncf.io%2Fblog%2F2024%2F05%2F24%2Fhappy-7th-birthday-istio%2F&quot; target=&quot;_blank&quot;&gt;發文&lt;/a&gt;慶祝七歲生日，並總結了自項目誕生以來所取得的一些成果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-aa0939d5f63acbd3a6b331f3a3a2c4e81a5.jpg&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 是一個由谷歌、IBM 和 Lyft 的團隊於 2016 年開始合作開發的開源項目，在 2017 年正式推出；它是一個大型微服務系統管理工具，旨在提供一種統一化的微服務連接、安全保障、管理與監控方式；基於 Lyft 的 Envoy 項目構建。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2022 年 4 月，谷歌和 Istio 指導委員會宣佈將 Istio 項目捐贈給 CNCF；同年 9 月，CNCF 技術監督委員會 (TOC) 投票決定接受 Istio 作為 CNCF 孵化項目。2023 年 7 月，Istio 正式從 CNCF 畢業；同時，微軟 Open Service Mesh 團隊成為 Istio 項目維護者。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，Istio 的控制面板和邊車代理分別是 Docker Hub 上下載量排名第三和第四的鏡像，各自超過 100 億次下載。過去一年裏，社區的貢獻公司數量和貢獻者人數均實現了巨大增長，超過了 1700 名。其中，&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2FSolo.io&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;Solo.io&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;、Google 和 DaoCloud 是貢獻度最高的三家公司。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;205&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-1303068e017b0358fca5ac12f74dfac9189.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「我們堅信多樣性驅動創新。最令我們驚歎的是 Istio 社區持續不斷的創新，從簡化升級過程，到採用 Kubernetes Gateway API，再到新增無需邊車的環境數據平面模式，以及努力使 Istio 易於使用並儘可能透明。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Istio 的環境模式於 2022 年 9 月推出，旨在簡化操作、增強應用程序兼容性，並降低基礎設施成本。隨着 Istio 1.22 版本的發佈，環境模式已進入測試階段，用户可以在採取一定預防措施的情況下，在生產環境中無邊車運行 Istio。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/193192/google-istio-cncf&quot; target=&quot;_blank&quot;&gt;谷歌向 CNCF 捐贈 Istio&lt;/a&gt;&lt;/li&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/212312/istio-sails-into-cncf&quot; target=&quot;_blank&quot;&gt;Istio 成為 CNCF 孵化項目&lt;/a&gt;&lt;/li&gt; 
 &lt;li style=&quot;text-align:start&quot;&gt;&lt;a href=&quot;https://www.oschina.net/news/249167/istio-graduates-cncf&quot; target=&quot;_blank&quot;&gt;Istio 從 CNCF 畢業，微軟加入項目社區&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294636/happy-7th-birthday-istio</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294636/happy-7th-birthday-istio</guid>
            <pubDate>Tue, 28 May 2024 06:00:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>真好用的 ORM 框架 mybatis-mp:1.5.1 發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;h1&gt;官方文檔：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fmybatis-mp.cn&quot; target=&quot;_blank&quot;&gt;http://mybatis-mp.cn&lt;/a&gt;&lt;/h1&gt; 
&lt;h2&gt;1.5.1 更新：&lt;/h2&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:rgba(0, 0, 0, 0.04); color:#000000&quot;&gt;1.修復了多數據源 springboot3 下報錯的問題 &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:rgba(0, 0, 0, 0.04); color:#000000&quot;&gt;2.部分數據庫函數同時兼容各數據庫 &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:rgba(0, 0, 0, 0.04); color:#000000&quot;&gt;3.增加不同數據庫執行不同 sql 功能&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;SysUser sysUser = QueryChain.of(sysUserMapper)
                    .select(SysUser::getId)
                    .onDB(DbType.H2, queryChain -&amp;gt; {
                        queryChain.eq(SysUser::getId, 3);
                    })
                    .onDB(DbType.MYSQL, queryChain -&amp;gt; {
                        queryChain.eq(SysUser::getId, 2);
                    })
                    .elseDB(queryChain -&amp;gt; {
                        queryChain.eq(SysUser::getId, 1);
                    })
                    .get();&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;10 大與眾不同的亮點：&lt;/h2&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;1：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點一：可自定義動態默認值&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;2：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點二：支持不同數據庫 ID 自增配置&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;3：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點三：邏輯刪除，可自動填充刪除時間&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;4：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點四：可自定義 sql（sql 模板）&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;5：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點五：mapWithKey（把查詢轉成一個&amp;nbsp;map）&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;6：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點&amp;nbsp;六：部分字段&amp;nbsp;新增&amp;nbsp;和&amp;nbsp;修改&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;7：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點七：枚舉的良好支持&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;8：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點八：mybatis-xml&amp;nbsp;returnType&amp;nbsp;的&amp;nbsp;ORM&amp;nbsp;映射&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;9：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點九：優雅的&amp;nbsp;XML 和&amp;nbsp;@Select 查詢&amp;nbsp;自動分頁&lt;/span&gt;&lt;br&gt; &lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;10：mybatis-mp&amp;nbsp;-&amp;nbsp;亮點十：支持多層嵌套 VO，自動映射以及自動 select&amp;nbsp;所需列&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:start&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;mybatis-mp 包含豐富的 api：&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;1：基於註解，映射數據庫；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;2：支持多表 join 和返回；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;3：api 採用 lambda 和 stream 流式設計；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;4：select 自動化以及結果 1 對 1,1 對多，超級方便快捷；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;5：內置分頁以及超強的 sql 優化功能；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;6：穩定且性能極優；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;7：輕量級封裝 mybatis，幾乎沒有侵入；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;8：api 豐富，支持數據庫函數、多表、樂觀鎖、多租户、邏輯刪除、默認值（可動態值） 等眾多功能；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;9：零學習成本，和寫 sql 一樣方便。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;10：支持複雜的返回關係映射：例如一對一 ，一對多，多對多；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;11：支持自定義 sql 模板，再也不用擔心框架支持不足；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;12：內置代碼生成器，通過配置，可定製自身規範；&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;13：全新的框架，全新的設計理念，新的就是好！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294633/mybatis-mp-1-5-1-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294633/mybatis-mp-1-5-1-released</guid>
            <pubDate>Tue, 28 May 2024 05:44:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>馬斯克和「AI 教父」激情對線</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;起因是馬斯克轉發了一條為自己 xAI 公司招人的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;推文&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1646&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-acedb0fcdff381e79f9fbda1bf622a701af.png&quot; width=&quot;1284&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;沒成想被有「AI 教父」之稱的楊立昆當場拆台，言語間盡是嘲諷。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;楊立昆（法語：Yann Le Cun）是一名法國計算機科學家。他在機器學習、計算機視覺、移動機器人和計算神經科學等領域都有很多貢獻。他最著名的工作是在光學字符識別和計算機視覺上使用卷積神經網絡，他也被稱為卷積網絡之父。他共同創建了 DjVu 圖像壓縮技術，以及聯合開發 Lush 語言。2019 年，他同約書亞·本希奧、傑弗裏·辛頓共同獲得計算機學界最高獎項——圖靈獎。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;楊立昆解釋了他評論這些內容的原因——「&lt;strong&gt;不喜歡馬斯克的報復性政治手段、陰謀論和炒作&lt;/strong&gt;」。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;880&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-42deaf887656eb50e3b3a7d15076d52d3b4.png&quot; width=&quot;1286&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;下面是大佬的互噴現場：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;2337&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b27ea3061e6803707fc5bce1d91b0e8a472.jpg&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;機翻效果&lt;/p&gt; 
 &lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-47f8e8355e7ca675222a031eef7eed7aff8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;來源：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Felonmusk%2Fstatus%2F1794981927125987683&quot; target=&quot;_blank&quot;&gt;https://x.com/elonmusk/status/1794981927125987683&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294625</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294625</guid>
            <pubDate>Tue, 28 May 2024 04:33:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>wlnmp 一鍵安裝包更新 240528</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;strong&gt;wlnmp 一鍵安裝包 240528 更新內容如下：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;（更新）mariadb10.4.34、mariadb10.5.25、mariadb10.6.18、mariadb10.11.8&lt;/li&gt; 
 &lt;li&gt;（其它）增加 mariadb10.4.34、mariadb10.5.25、mariadb10.6.18、mariadb10.11.8 使用指南，可以在版本支持列表中點擊對應的 mysql 版本查看，也可以訪問以下鏈接。 
  &lt;ul&gt; 
   &lt;li&gt;wlnmp 一鍵安裝包 mariadb10.4 使用指南：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Fpost-2614.html&quot; target=&quot;_blank&quot;&gt;https://www.wlnmp.com/post-2614.html&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;wlnmp 一鍵安裝包 mariadb10.5 使用指南：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Fpost-2618.html&quot; target=&quot;_blank&quot;&gt;https://www.wlnmp.com/post-2618.html&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;wlnmp 一鍵安裝包 mariadb10.6 使用指南：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Fpost-2621.html&quot; target=&quot;_blank&quot;&gt;https://www.wlnmp.com/post-2621.html&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;wlnmp 一鍵安裝包 mariadb10.11 使用指南：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Fpost-2624.html&quot; target=&quot;_blank&quot;&gt;https://www.wlnmp.com/post-2624.html&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;關於 wlnmp&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;從 2019 年初開始維護 wlnmp 一鍵安裝包這個項目，起初只是為了在日常運維過程中，可以快速的部署 lnmp 服務。wlnmp 已支持國產華為歐拉 OpenEuler、龍蜥 AnolisOS、OpenCloudOS 系統等。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;wlnmp 一鍵安裝包基於上游開源軟件二次開發，可以在 x86_64 架構的 Linux 系統上通過 wlnmp 提供的鏡像源，快速部署 Nginx/Mysql/PHP 等常用軟件，支持 php、MySQL 多個版本在同一系統中並存。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#72c490&quot;&gt;&lt;strong&gt;系統支持：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;Alibaba CloudLinux 2.1903/3&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;AlmaLinux 8.x/9.x&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;AnolisOS 8.x&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;CentOS 7.x&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;CentOS 8.x&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;&lt;/span&gt;OpenCloudOS 8.x&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦ OpenEuler 20.03&lt;/span&gt;(SP1~SP4)&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;OpenEuler 22.03&lt;/span&gt;(SP1~SP3)&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;✦&amp;nbsp;RockyLinux 8.x/9.x&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;傳統方式添加 wlnmp 鏡像源，實現 yum 一鍵安裝部署！&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;安裝便捷，穩定更新，模塊集成&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;免費使用，為愛發電&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;安裝使用見：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Finstall&quot; target=&quot;_blank&quot;&gt;install&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;background-color:#ffffff; color:#333333&quot;&gt;更新日誌可查看：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.wlnmp.com%2Fchangelog&quot; target=&quot;_blank&quot;&gt;ChangeLog&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294619/wlnmp-updated</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294619/wlnmp-updated</guid>
            <pubDate>Tue, 28 May 2024 04:11:48 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>龍芯自主龍架構 2024 年已適配 318 款產品、有望推出「龍芯+鴻蒙」桌面 PC</title>
            <description>龍芯中科每個月都會公佈 LoongArch 龍架構的生態適配進展，2024 年 4 月又新增了 110 款，加上此前 3 月的 101 款、1-2 月的 107 款，今年以來已達 318 款。這些適配產品面向網絡安全、數據安全、日常辦公、智...</description>
            <link>http://osc.cool/99Ar188B</link>
            <guid isPermaLink="false">http://osc.cool/99Ar188B</guid>
            <pubDate>Tue, 28 May 2024 03:34:48 GMT</pubDate>
        </item>
        <item>
            <title>Bookie 存儲架構源碼剖析｜得物技術</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                            
                                                                                            &lt;p style=&quot;color:#222222; margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;一、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Pulsar 存儲架構簡析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 作為新一代 MQ 中間件，在底層架構設計上充分貫徹了存算分離的思想，broker 與 Bookeeper 兩個組件獨立部署，前者負責流量的調度、聚合、計算，後者負責數據的存儲，這也契合了雲原生下 k8s 大行其道的時代背景。Bookeeper 又名 Bookie ，是一個單獨的存儲引擎。在組件關係上，broker 深度依賴 Bookie，內部集成了 Bookie 的 client 端，broker 和 Bookie 之間基於 TCP 通信，使用 protobuf。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7ae3724a6738446d9eaa24a3989b2304~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=KN6gea6ImIlHS7pxV%2BTu63QB%2B%2Bs%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 整體架構&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;消息流從 client 端發送到 broker，經過 broker 的計算、轉化、路由後再次被分發到具體的 Bookie 節點，一條消息被存儲幾份是可配置的。數據的高可用由 broker 來保障而非 Bookie，Bookie 只是一個簡單的單機存儲引擎。一般而言數據多副本有兩種主要的分發方式：一種是基於主從模式，主節點在收到數據寫入後，將數據二次分發到從節點，從節點的數據流源頭只有主節點，可以存在多個從節點，這種架構典型實現有 rocketMQ ，MySQL 等；另一種方式是並行多份寫入多份相同的數據，在接收到 SDK 側數據後進行多路分發。兩種方式各有優劣，前者實現簡單，但是延遲較高，在開啓同步複製（異步複製可能丟數據）的情況下延遲為：&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;master 寫入延遲+slave 寫入延遲&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;；後者實現複雜，需要處理單節點分發失敗補償的問題，但是延遲較低，實際的寫入延遲為&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Max(shard1 寫入延遲，shard2 寫入延遲，.....)&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。Pulsar 的數據分發模式為後者。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ac570f7e482d475ba47d23ab53de14ce~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Y3CoV7%2Bloep6waHMMRk36Ritb4M%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 數據流架構&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;一個 topic 在時間序列上被分為多個 Ledger，使用 LedgerId 標識，在一個物理集羣中，LedgerId 不會重複，採用全局分配模式，對於單個 topic（分區 topic）而言同一時刻只會有一個 Ledger 在寫入，關閉的 Ledger 不可以寫入，以 topicA-partition1 的 Ledgers[ledger1, ledger3, ledger7, ...., ledgerN]為例，可寫入的 Ledger 只有 N，小於 N 的 Ledger 均不可寫入，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;單個 Ledger 默認可以存儲 5W 條消息&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，當 broker 以 （3,2,2）模式寫入數據時，具體架構如下圖所示。3,2,2 可以解釋為當前 topic 可以寫入的節點有 3 個，每次數據寫入 2 份，並且收到 2 個數據寫入成功的 ACK 後才會返回響應 client 端。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/74f43b7ff2f141a7aa0c23cc869cde2c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=a5pq528voyeoqg9fUPKGI5M9cVc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 分段機制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;二、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的架構設計&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;對 Pulsar 的架構有了大致的瞭解後，我們重點剖析下 Bookie 這個核心的存儲引擎。消息系統為了追求最大寫入吞吐，一般都採用順序寫的方式來壓榨磁盤的 IO 性能。Bookie 也是一樣，默認情況下 Bookie 的數據會寫入 journal 日誌文件，這個日誌類似於 MySQL 中的 binlog 文件或者 rocketMQ 中的 commitlog 文件，採用亂序追加寫的方式，存在多個 topic 的數據寫入同一個文件的情況。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;為了更好的 IO 隔離，官方建議 journal 單獨掛一塊盤。為了充分發揮磁盤 IO 性能，journal 目錄可以有多個，即同時存在多個並行寫入的 journal 日誌，每個 journal 日誌會綁定一個寫入線程，寫入請求提交後會被歸一化到某個具體線程，實現無鎖化，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;單個消息寫入是按照 LedgerId 對目錄數量取模，決定當前數據落到哪個 journal 目錄&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。journal 日誌落盤策略是可配置的，當配置同步落盤時，數據實時落盤後才會返回寫入成功。journal 日誌數據寫入後會確認返回寫入成功，而 entrylog 的數據是否落盤並不影響請求的立即返回。journal 和 entrylog 均可以配置為異步刷盤，這種情況下落盤的時序上並沒有先後之分。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/21791c6012b74868a0d27ae2d86cf5be~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=M4HQB%2Ffr0RPxXWKRr7kOf9sHhA0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 數據存儲架構&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal 日誌的主要作用是保證數據不丟失，同時提供足夠快的性能，因此採用了混合落盤的模式。實際業務消費時，針對單個 topic 的數據在時間序列上是順序消費，如果實際的數據從 journal 文件中讀取則會出現大量的隨機 IO，性能較差。Bookie 通過將數據進行二次轉寫的方式實現數據的局部有序從而提升讀取性能，默認情況下一份數據在磁盤上會存兩份：一份在 journal 日誌中，一份在 entry 日誌中。entry 日誌中的數據具備局部有序的特性，在一批數據刷盤時，會針對這批數據按照 LedgerId，entryId 進行排序後落盤。這樣消費側在消費數據時能夠實現一定程度上的順序 IO，以提升性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryIndex 的作用是保存（LedgerId+entryId）到 offset 的映射關係，這裏的 offset 是指 entry data 文件中的 offset。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;這樣的一組映射關係很容易想到其在內存中的組織形式，一個 map。實際的存儲&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 選擇 rocksDB 來存儲這樣的 KV 關係&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，但 Bookie 本身也有自己的 KV 存儲實現；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;通過對 Bookie 架構的上分析，我們發現針對讀寫場景 Bookie 做了兩件事來支撐：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;混合 Ledger 順序寫的 journal 日誌支撐高吞吐低延遲的寫入場景；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;局部有序的 entry data 支撐消費場景下的 Ledger 級別的順序讀。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;三、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的數據寫入流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;對於 Bookie 的寫入流程大致如下圖所示。Bookie 收到數據後會同時寫入 journal 日誌和 memtable，memtable 是一個內存 buffer。memtable 再次分發到 entry logger 以及 entry index，數據在 journal 中 append 完後會立即返回寫入成功。entry data 和 entry index 的構建可以理解都是異步操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c79f614980394a84a49a384d5f951992~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=JstCsfZnMznBP%2BppNtSBd%2B4oRCI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 數據寫入流程&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;client 端源碼分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Pulsar 中 broker 組件，使用 low level API 與 Bookie 進行通信。下文結合具體代碼進行分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;ClientConfiguration conf = &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; ClientConfiguration();
conf.setThrottleValue(bkthrottle);
conf.setMetadataServiceUri(&lt;span style=&quot;color:#00753b&quot;&gt;&quot;zk://&quot;&lt;/span&gt; + zkservers + &lt;span style=&quot;color:#00753b&quot;&gt;&quot;/ledgers&quot;&lt;/span&gt;);
BookKeeper bkc = &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; BookKeeper(conf);


&lt;span style=&quot;color:#114ba6&quot;&gt;final&lt;/span&gt; LedgerHandle ledger = bkc.createLedger(&lt;span style=&quot;color:#a82e2e&quot;&gt;3&lt;/span&gt;, &lt;span style=&quot;color:#a82e2e&quot;&gt;2&lt;/span&gt;, &lt;span style=&quot;color:#a82e2e&quot;&gt;2&lt;/span&gt;, DigestType.CRC32, &lt;span style=&quot;color:#114ba6&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;byte&lt;/span&gt;[]{&lt;span style=&quot;color:#00753b&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span style=&quot;color:#00753b&quot;&gt;&#39;b&#39;&lt;/span&gt;});
&lt;span style=&quot;color:#114ba6&quot;&gt;final&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;long&lt;/span&gt; entryId = ledger.addEntry(&lt;span style=&quot;color:#00753b&quot;&gt;&quot;ABC&quot;&lt;/span&gt;.getBytes(UTF_8));&lt;/code&gt;&lt;/pre&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;使用 low level api 時，藉助於 LedgerHandle 添加 entry 對象。在 Pulsar 中 entryId 為一個遞增的序列，在 broker 中 Bookie 的源碼調用順序如下所示，其中 LedgerHandle，OpAddEntry，LedgerHandle class 對象為 Bookeeper 模塊提供。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ManagedLedgerImpl#asyncAddEntry() 方法（參數省略，下同）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ManagedLedgerImpl#internalAsyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#asyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpAddEntry#initiate() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#doAsyncAddEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieClient#addEntry() 方法&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/88388e7af5994decbf99cfd54e384999~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=bu4o%2BHDLkFQZHX2OnvvyuVwPQ4Q%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerHandle#doAsyncAddEntry 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 doAsyncAddEntry 中的 729 行，發現 entryId 其實是由 lastAddPushed 遞增得到，並且這段代碼也被加上了重量級鎖。PendingAddOp 對象構建完成後會進入一個 pendingAddOps 隊列，該隊列與當前 Ledger 綁定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b9a99e6e9a594516b6392abb8b7a969c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=dTaLtkmTrxg3ICa5uVm19p2V0cc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;PendingAddOp#initiate 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;這裏的 PendingAddOp 對象代表着一個寫數據的請求，在 initiate 進一步加鎖，結合寫入節點的數量分別向不同的 Bookie 存儲節點發送寫請求，sendWriteRequest 方法內容比較簡單，直接調用 addEntry 方法即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b475269c59d84386b1f629498bd7a0fd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=orN95MLTacsV4IqPggMkHouN%2FZE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;PendingAddOp#sendWriteRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/932135a1d2484b0995347a57afabaf45~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=UPNm6lwbiAgaH%2BMcgKhxdWCrM4U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieClient#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 方法的實現依然有很多方法包裝的細節，但最終通過網絡調用 server 端的相關接口，這裏篇幅有限，不過度展開。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端源碼分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;請求路由組件：BookieRequestProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;直接跳轉 bookeeper 的 server 端的核心處理方法上，BookieRequestHandler 為 server 端的處理類，其繼承了 Netty 的&lt;br&gt; ChannelInboundHandlerAdapter，是最外層與 netty 組合工作的 handler。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/97e4e19a3fc743f3961e48a80c467cdd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=jukxvEBhULNwRoLB%2BNt1%2Ba9z9L8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestHandler&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 channelRead 方法中觸發了 requestProcessor 的處理邏輯，這裏的 processor 實際為 BookieRequestProcessor，具體的相關代碼在 BookieServer 類的構造函數中，BookieServer 是整個 bookeeper server 端的啓動類。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest 方法為數據流的核心指令分發器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8203741ab2834eb8a9cc60dc6b5dc7c7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=mcTGqjmTIhX5wJdK%2FB3nkF5t%2B8U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;這裏圍繞&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;processAddRequestV3&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;方法展開分析；Bookie 中有個很有意思的設定，將請求處理線程池分為普通線程池和高優線程池；兩者執行邏輯相同。在下圖的 452 行將寫操作請求放入了線程池，需要説明的是這個線程池是經過改良的，多了一個 orderingKey 參數，在內部會將根據該參數進行 hash 運算，映射具體的線程上，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;其內部由多個單線程的線程池組成。這樣做的好處是可以大幅度減少投遞任務時的隊列頭部競爭&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，相比傳統線程池有一定的性能優勢。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d180b1e466854521828ddf3da3adcf03~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=kEtNUv1uTetdiM7WVW981I9wdAk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;processAddRequestV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;核心線程池任務：WriteEntryProcessorV3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;顯然，核心的處理邏輯在 write.run 方法內，繼續開扒。run 方法中核心邏輯封裝在 getAddResponse()。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a76943db2d4e424587ab0bfa9882d989~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=G6pIG01xu52Svzq9wZdgvyNk7XI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;getAddResponse 方法內會對當前請求的標記，判斷後分別調用 recoveryAddEntry 和 addEntry 這兩個方法。前者的使用場景顧名思義是在異常恢復流程中被觸發，一般是節點啓動，宕機後重啓等過程中恢復數據。addEntry 方法位於 Bookie 內，Bookie 是個接口，只有一個實現類 BookieImpl。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c685d087a3064314bac57469a2bfcb61~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=sJh8FeBd9svGGiaQyEiOhCNHZoA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3#getAddResponse&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;存儲引擎接口抽象：Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;繼續來看 BookieImpl#addEntry 方法，在 1067 這一行加上了 synchronized 鎖，鎖的對象為 handle，具體為 LedgerDescriptor 類型，這表示在單個 Ledger 內部的數據在寫入時通過加鎖的方式實現串行化寫入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;1073 行的 addEntryInternal 方法內部是核心的寫入邏輯。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3371b182268d43878ee60f58fc34fea0~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=T7OTWrcllN%2B7PPEne1yYhMHd4TI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 的管理者：LedgerDescriptor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;getLedgerForEntry 方法基於傳入的參數 LedgerId 查找到對應的 LedgerDescriptor，該類是一個抽象類，有兩個實現類，分別是 LedgerDescriptorImpl 和&lt;br&gt; LedgerDescriptorReadOnlyImpl，顧名思義，二者分別提供讀寫功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7912608a28174239a11c372652a4e2de~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Zhw0S0JiGqdHMFlR2HquYMtw0d8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#getLedgerForEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/06009ac4c70c490b89f80908bf9ecd38~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=W4xjO7zokrOJUvOk0bKiEMv1F9U%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptor 的兩個實現類&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;handles 是 HandleFactory 類型接口，從其定義的接口來看主要作用就是實現 LedgerDescriptor 的讀寫分離，且只有一個實現 HandleFactoryImpl，在 HandleFactoryImpl 中保存了 2 個 Map 類型的 MAP。分別服務於兩個接口的調用，getHandle 方法就是從 map 中獲取可以寫入的 LedgerDescriptor。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a3cdaca4e7a346eda7ac8f816cc23a20~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=oYEQ%2BrrDqV8kLizqGmoiYVepisM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;HandleFactory&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;事實上&lt;br&gt; LedgerDescriptorReadOnlyImpl 的實現很簡單，繼承了 LedgerDescriptorImpl 後將該類涉及到寫入的方法全部重寫為拋出異常！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6e5fd10fcf564dd8a8de0f66eb5e9ee7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=z%2F1VahLYeW1DKkF6ei3hQmbU70w%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptorReadOnlyImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;獲取到對應的 LedgerDescriptor 後，就需要進行寫入操作，下面分析 BookieImpl#addEntryInternal 方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;從邏輯上來講，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 先是被寫入 Ledger storage（930 行），其次才被寫入 journal 日誌，同時 journal 日誌的寫入是可選的，默認情況下開啓&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;；journal 關閉後將不存在數據落盤的邏輯，這意味着將無法依靠 journal 日誌進行數據恢復。但考慮到消息寫入時一般是多份，不考慮寫入的多個節點同時宕機的情況，數據某種程度上依然是可靠的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dbd30b41001f4df183460f355bb7a1b7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Ei9JpTtfTltmKU24FEEbe9HUrjg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#addEntryInternal&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Ledger 級的接口抽象：LedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;LedgerDescriptorImpl 中持有一個 ledgerStorage 類型，該組件負責最終的 entry 對象寫入，存在多個實現類，分別是：DbLedgerStorage,&lt;br&gt; SingleDirectoryDbLedgerStorage,InterleavedLedgerStorage,SortedLedgerStorage。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5bae520c5df94113b3099dda57b0a902~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=pClQIg4ztO2TkJtXqpVQE1zCGVE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptorImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a29b426a93cd4fcf90c46843f1074054~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=4lRhalqMykCHg2Qumz0gmTydT4g%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerStorage 實現類&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 默認使用 SortedLedgerStorage，但 Pulsar 中使用 DbLedgerStorage 進行管理。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;實際可配置的實現只有三個選項，下面依次對每個實現類進行分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d00d1ebd4b034ea0bbf67f3d1ba45254~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=3NScdxoCgX46ar07w4oHs6xOePg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage-&amp;gt;SingleDirectoryDbLedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 寫入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage 主要特點是使用了 rocksDB 保存[ledgerId+entryId --&amp;gt; location]的映射關係；內部又存在了一層套娃。addEntry 方法中先獲取到 LedgerId， 再根據 LedgerId 獲取 ledgerStorage，也就是説 LedgerId 和實際的 LedgerStorage 存在映射關係；&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;DbLedgerStorage 內部又繼續封裝了&lt;br&gt; SingleDirectoryDbLedgerStorage 類來支撐數據寫入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;，具體是一個 ListledgerStrageList；字段。經過 hash 後獲得真實的&lt;br&gt; SingleDirectoryDbLedgerStorage 對象進行實際的 addEntry 操作；下文首先對該實現進行分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ec2d1e4c52734a918e9a0f8be39484c6~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=iXY5xBOhQGqk2xDUe9hUNmqI3gk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d468e2b3d69442289f4d3d5ac6b16745~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=a4QY3kYbtpu6zytJv8It0s5HYwc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#getLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a762f3034dd740c888bbd427c0a2ba16~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=MdJkJqkDCUjY6QZceVgQfjMx6cE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage 的成員變量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;在&lt;br&gt; SingleDirectoryDbLedgerStorage 的源碼中，&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;待寫入的 entry 僅僅是被放入 writeCache 中，put 成功後更新 LAC 並通知相關監聽者，同時觸發寫入成功事件，貌似沒有任何寫盤的操作出現！！！&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;進一步分析 497 行，如果 put 失敗會觸發 flush 操作並嘗試再次 addEntry，這裏的 flush 有點眼熟，有必要展開分析一波。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;不難發現這裏的寫入操作和刷盤操作其實是線程隔離的，默認情況下，類比於 RMQ，大部分存儲組件的刷盤操作和實際寫入動作切分為兩個線程在執行，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;刷盤線程會不斷地巡檢是否需要刷盤，主要基於當前未刷盤的數據量以及距離上次刷盤的時間間隔&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，如果開啓同步刷盤，一般寫入線程會被掛起在 req 請求上，當刷盤進度已經 cover 寫入請求的 offset 時，被掛起的請求上的線程會被喚醒繼續執行，這是一種非常典型的存儲引擎設計模式。這裏 writeCache 就是個 buffer，既可以充當寫入緩衝也可以充當讀取緩衝，在 tail read 場景下會有非常好的性能收益。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3587e1b0b3a54909b1d5c47d2fd1a8ff~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=d42iQEouPgouNbzRQZNOo8Ft3y8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 背後的 flush&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;triggerFlushAndAddEntry 的邏輯並不複雜，在超時時間到來之前會不斷的檢查當前的刷盤標記位，如果沒有正在刷盤以及刷盤邏輯沒有被觸發，會嘗試刷盤，同時嘗試繼續向 writeCache 中 put 數據，因為刷盤成功後會在 cache 中清理出一部分空間，用於 put 新的的數據，一旦 put 成功立即返回，跟外層的 addEntry 方法類似，只是多了個刷盤邏輯的處理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/d2c1c8b218db40c28954b9fceb401c7e~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QlfSvym40gR%2B%2Fb3s%2BrMxS8kZXZQ%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#triggerFlushAndAddEntry 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 方法其實是個空殼，核心邏輯在 checkpoint() 方法內，該方法的主要邏輯為：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;交換 writeCache，避免刷盤過程中數據無法寫入，導致寫入抖動；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;對 writeCache 內的數據進行排序，實現局部有序；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;分別調用 entryLog 的 add 方法和 entryIndex 的 add 方法；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;調用 entrylog 的 flush 和 entryIndex 的 flush 進行刷盤。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/8ab1e6f90d694c6596135dd70dc62a9a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=8wlbtIHF0H3Yepkkz5pIclmzL5w%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/36a2951089214868800e9fcc0574b55b~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=zlk0OAltR4DP6u5POMPZMkzEy1Y%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#checkpoint&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;源碼中的 writeCacheBeingFlushed 實際上和 writeCache 一體兩面，上一次刷盤結束後 writeCacheBeingFlushed 會被 clear，再次刷盤時會交換兩者；保證寫入的穩定性；如果實際查詢數據時要利用這部分 cache，需要查詢兩次，先查 writeCache 如果不存在 ，再查 writeCacheBeingFlushed。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/e8d83bc5e6d943fa9c0db5316aa16dc9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=EDFEak82%2BOJcH%2BPy91usveH88J4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCacheBeingFlushed 的註釋&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5941113e1baf446e95b1d9e6aac710d9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=inUzrEgEyf8goulcaU9kCC71ntg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;br&gt; &lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;entryLocationIndex.addLocation(batch, ledgerId, entryId, location);方法底層依賴 rocksDB 建立了[ledgerId, entryId]--&amp;gt;location 的映射關係，Batch 在這裏代表着，一個 RocksDBBatch，location 可以理解為實際磁盤文件上的 offset。rocksDB 引擎超出本文範疇，這裏不做分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryLogger 代表着存儲實際數據的組件抽象，調用 addEntry(ledgerId, entry) 方法完成數據寫入。進一步對 addEntry 方法展開分析，發現 EntryLogger 是一個接口，有 2 個直接實現類，分別是 DefaultEntryLogger 和 DirectEntryLogger，默認使用 DefaultEntryLogger 參見源碼：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/216dfb199cfc4ad69e8ba3182c08e41c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=MCldx0IppN8uCtqLaHrPtu08mW4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#initialize -part1&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5fd3a3d565344ba2aa56f188131ab79a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=V%2F8hYUsNK78oboTOxDnQNv3T3Mk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DbLedgerStorage#initialize -part2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;最終的調用來到了 EntryLogManagerBase#addEntry 方法，首先獲取到待寫入的數據，然後調用 BufferedLogChannel#write 將其寫入，可以看到實際的數據長度為：entry.readableBytes() + 4，4 個字節用於記錄長度，先寫入長度值，再寫入 entry 的二進制數據；addEntry 方法返回值為 location，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;方法的最後一行表明 location 由 2 部分組成，分別是 logId 和 pos，各暫用高位和低位的 4 個字節&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;。很容易想到隨着時間的推移 EntryLogger 中的文件不止一個，因此需要一個 logId 來標識不同文件，具體到文件上又需要一個偏移量來定位具體的一條數據，4 個字節的 pos 也表明了單個 entryLog 文件理論大小值不能超過 4 個 G，實際默認值為 1G。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9b5507e160064b8f8f0f4103b24df52a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=iwh5fXHc%2BARHsJ0N5WYOmdEydNg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogManagerBase#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;進一步分析 BufferedLogChannel#write 方法，發現 BufferedLogChannel 繼承置之 BufferedChannel ，在 BufferedChannel 中有一個 writeBuffer ，write 方法只是將數據寫入到這個 writeBuffer 中，至於是否刷盤則不一定。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;只在滿足下列兩種情況時數據才會刷盤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當前 writeBuffer 已經寫滿，writeBuffer 默認值 64KB；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration 中配置了 FLUSH_ENTRYLOG_INTERVAL_BYTES 參數，且值大於 0，默認值為 0。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/02ad5b5bfdbe41ee9c9805681513b3fa~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=wSW%2FumdRKHAxLmh0QabQOBZrdRI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedLogChannel#write&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 方法內容很簡單，調用底層的 fileChannel 將 writeBuffer 中的數據寫入底層的文件系統，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;但是 flush 並不保證一定落盤&lt;/span&gt;&lt;/strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;，而是最後一行代碼 forceWrite 方法保證。forceWrite 會調用 fileChannel.force(forceMetadata) 將數據同步到磁盤上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/bab28e93323f43a69119a417a3534b10~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=uHaBzjMDBKkVe%2Fr6tfMisW1SXvo%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;為了保證數據的務必落盤，在&lt;br&gt; SingleDirectoryDbLedgerStorage#checkpoint 方法中，addEntry 方法之後，又單獨調用了 entryLogger.flush();和 ledgerIndex.flush();對 entryLogger.flush() 進一步拆分，發現底層調用了 EntryLogManagerBase#flush 方法，二者兩個方法在 base 類中是 abstract 類型，具體實現又落到了&lt;span&gt;&amp;nbsp;&lt;/span&gt;EntryLogManagerForSingleEntryLog 中，最終任務還是落在了 BufferedChannel#flushAndForceWrite 上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6cea0ca2ad7047a282eb4fa9613f2085~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=rTylKLwhNZgJz4%2B9F4SNFIvzXu8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel#flushAndForceWrite&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage-&amp;gt;InterleavedLedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 SortedLedgerStorage 類中，持有了 InterleavedLedgerStorage 類型，大部分的接口實現都委託給了 InterleavedLedgerStorage 的相關方法調用，SortedLedgerStorage 的最大特點是，每次數據寫入時都會進行排序，其內部使用了跳錶。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/834f9975acfa4c4c82ee2aa64827e7ec~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=6tf7mSryYkTcjsm5O32kYhTRVw0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable 寫入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 方法的邏輯非常簡單，將數據 add 到 memtTable 後，更新下 LAC 即結束；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/fc4c7efc1902441e957d7e27f368b855~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QvBttu0pq1qzzehR%2BStyJjgRT3k%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;繼續研究 EntryMemTable 的 addEntry 方法之前先了解下 EntryMemTable 的結構，這個組件是一個純內存的數據保存結構，kvmap 和 snapshot 負責實際數據保存，二者類型皆是 EntrySkipList ，這個類簡單封裝了 ConcurrentSkipListMap，實際使用時 KV 值相同，因為需要保證有序，所以重寫了排序規則，主要比較 LedgerId 和 entryId。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;kvmap 和 snapshot 工作機制是，當寫滿 kvmap 時，會將數據交換給 snapshot，kvmap 重新構建一個新的指定大小的結構，後台線程負責將 snpshot 中的數據刷盤保存，因此只要後台刷盤的速度不是特別垮，可以提供持續不間斷的寫入。單個 kvmap 有大小限制，默認 64M 大小，結合前面的 swap 機制，最多可以兜住 128M 的寫入緩存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/edc551f2d71f40bc81912e0851e69358~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=NserGlryB9Y7eCWS3mxiJs2UGe4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;addEntry 寫入之前先獲取讀鎖，（沒錯，寫入用的是讀鎖！！！）然後將數據 put 進入 kvmap 結構中，internalAdd 方法內容很簡單，就是一個對 kvmap 的 putIfAbsent 調用，看到這裏可以理解為什麼用的是讀鎖了。因為這裏 kvmap 的併發安全控制根本不依賴這個讀寫鎖。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/66a2f015f9374d449f9867fa0152ace1~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=j%2FZDwDsPx%2FwuLjG%2FthrPEnWmHe0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable 刷盤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;讀寫鎖的主要作用是，在 swap kvmap 和 snapshot 瞬間加上寫鎖控制以及讀取數據時加上讀鎖控制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/5d5a1e67ca7d4c64bcdadc4a97337f3f~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=yeCcxPi4xYP5u8ILgPyHsgMh%2FP4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReentrantReadWriteLock 使用場景&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;每次刷盤之前會先創建個一個 snapshot 快照，用以保證此快照之前的數據在此次的刷盤範圍內；創建 snapshot 時，會交換 kvmap 與 snapshot 兩個字段，因為快照的創建是刷盤行為觸發的，而刷盤動作一般都是有個單獨的線程在執行，所以這裏需要控制併發邏輯，保證在 swap 的瞬間，不能有 addEntry 操作，同樣的在刷盤結束後需要清理 snapshot 的數據，也加上了寫鎖來控制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f61bf224fdd341eab87c4c6ae22f7c0c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Y%2F5YBXMfO5oKRWz%2F9K1tdhmk5oc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#snapshot&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;會有一個後台的刷盤線程執行 flush 操作，首先會先將 snapshot 數據 flush，然後嘗試創建新的 snapshot，如果創建成功説明，仍然有可刷數據，再次執行 flushSnapshot 的動作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f0abb2747eb749d09a134f94ee984430~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=CjBVLq3JVqinJCl2vXiUT%2Fu1y%2Bg%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#flush&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 flushSnapshot 方法中，會調用 flusher 的 process 方法，這裏的 flusher 其實就是 SortedLedgerStorage，在 process 方法內的實際調用了 InterleavedLedgerStorage 的 processEntry 方法，這個方法並不能保證數據一定會落到磁盤文件上，&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;因此 EntryMemTable 所謂的 flush 操作只是將其內存數據刷新到 InterleavedLedgerStorage 組件中。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4ab10f21ee634d1bb258701a81a50e88~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=OJBC7IxMh96rV5F4jTzhyQkq6k4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryMemTable#flushSnapshot&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1eae5ca472ea49b1b7c8a77851ba8015~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=TtYa60tW0AhPsOMp8Ye9HVDyqNQ%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SortedLedgerStorage#process&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;繼續來看 InterleavedLedgerStorage 的處理邏輯，添加 Entry 後將對應的 KV 索引寫入 LedgerCache 緩存後返回。查看 InterleavedLedgerStorage 的 entryLogger 字段發現，與上文的&lt;br&gt; SingleDirectoryDbLedgerStorage 相同，寫入 entry 依然用的是 DefaultEntryLogger。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/44cf91ffafd74f32a2651ead373a797c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=aE%2Ft51FwvU2yePle928gF3%2F32yM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#processEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/dc96f3eed91542e78eebfcf38ecf3c18~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=LgYrRg0qXW3sQC%2Fnax34QU2TC8Y%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#entryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryIndex&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上文提到默認情況下 Pulsar 使用 DbLedgerStorage 來存儲數據和索引信息，而索引信息默認情況下使用 rocksDB 來存儲，rocksDB 作為頂級 KV 引擎其性能和穩定性毋庸置疑。但是在實際的使用過程中，某些時候會選擇 LedgerStorage 的另一個實現類：SortedLedgerStorage。SortedLedgerStorage 的主要特點是是在每次寫入數據的時候都會進行內部排序，內部維護一個跳錶，同時其存儲 leggerId+entryId 到 location 的映射關係是使用 Java 的引擎實現。下面對這個 Java 實現的 KV 引擎做詳細分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ad73e6db79e24496b43d7c54c42241d7~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=7q%2FLLBe8Xq8vwsKvhiZgRSeGH5A%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ServerConfiguration 關於 ledgerStorageClass 的配置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;仍然是先從 entryLog 的寫入作為突破口，SortedLedgerStorage 內部套了一個 InterleavedLedgerStorage 對象，前者複用了後者的 addEntry 方法，核心方法在 InterleavedLedgerStorage#processEntry 中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;long pos = entryLogger.addEntry(ledgerId, entry, rollLog);方法添加完 entry 對象後返回對象在文件的 offset，內部的 add 邏輯與上文分析的&lt;br&gt; SingleDirectoryDbLedgerStorage 一致。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/cd18ebe87ae54838b240b8aa9e4bf315~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=0XIhwoiE%2Biah75zqryOjU7TqeEM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#addEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9eb9cec086e54899931f62bb942339cd~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=wFuSzSJDFQPUiS7u7wpBSjb1%2BBo%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage#processEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerCache 是一個接口，具體的實現只有一個 LedgerCacheImpl 類，後者內部有兩個支撐組件，IndexInMemPageMgr 和 IndexPersistenceMgr，從名稱可以看出前者負責數據在內存中的保持，後者負責實際的存儲。按照之前的分析的源碼，很容易聯想到數據大概率先落入 memoryPage 再落盤，pageSize 默認 8K，entriesPerPage 默認為 pageSize/8= 1K。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3b1ca181eea2430ab38d42dafdce9d77~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=5QPxZqx1NwbBXKEoH1hQ3gMWgk4%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerCacheImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;putEntryOffset 方法首先通過 entryId 模以單個 page 頁的 entry 數量得到當前 entryId 在具體的 page 頁中的偏移量，這裏的 page 不是 OS 中的 page 頁，是 Bookeeper 單獨抽象出來的 page 概念，需要區分開。在 getLedgerEntryPage 方法中，首先會嘗試從內存中獲取 LedgerEntryPage 對象，如果沒有則調用 grabLedgerEntryPage 方法從磁盤上加載，內存中緩存的對象結構為 InMemPageCollection，內部是一個 LRU 緩存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;寫入算法分析：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerEntryPage 是對單個頁的抽象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;int offsetInPage = entry % entriesPerPage;計算出當前的 entryId 在單個 LedgerEntryPage 的邏輯偏移量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;long pageEntry = entry - offsetInPage; 計算出當前 LedgerEntryPage 中初始 entryId；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;基於 LedgerId 和初始 entryId 查找定位到 LedgerEntryPage，如果緩存中不存在，則從文件中加載；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;按照 offsetInPage 計算當前的 offset 需要寫入的真實位置，這裏的 offset 即是 entryLogger 中 entry location 值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;由於寫入的數據為 offset 是個 long 類型，需要 8 個二進制為，實際的寫入的位點為邏輯上的 offsetInPage*8。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4526e58486324a869c1028c747552b90~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=hNrBsydTwx83%2BUxi9rH38ge%2BIZY%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;IndexInMemPageMgr#putEntryOffset&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上述的算法自然也是可逆的，讀取的時候同樣基於 LedgerId 和 entryId 定位到具體的 LedgerEntryPage。然後在計算出實際的物理偏移量，在特定位置讀取到 location 參數。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;順序寫入的 WAL 日誌：Journal&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;分析完 writeCache 的寫入及其背後的邏輯，我們繼續分析 journal 日誌的寫入流程；上文提到 journal 為混合寫入模式，可能存在多個 LedgerId 的數據混編。在 addEntryInternal 方法的最後一行中通過 LedgerId 獲取到真實的 journal，獲取的邏輯依然是個 hash 算法，用來保證相同 LedgerId 始終落到一個 journal 上進行處理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;logAddEntry 幹了三件事：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry.retain() 調整 entry 的引用計數值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journalStats 給內部的 queueSize +1；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;memoryLimitController 內存使用限速器，如果超限時，當前線程會被置為等待狀態；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;queue.put(.......), 將待寫入的數據放進隊列。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;結合 logAddEntry 源碼發現又是熟悉的味道，寫入方法只是將請求放入隊列，那麼必然存在從隊列獲取數據並進行刷盤的邏輯。既然有 put 操作，必然有 take 操作，我們發現 takeAll 和 pollAll 方法 ，都位於 journal#run 方法中，run 方法這個名字如此敏感，以至於不跟 Thread 扯上點關係都説不過去。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/3482bc4d63f54742a8eebdeeddfbb8b8~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Z9aO0NuZROmBmKSmpCtOrT9%2BheM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#logAddEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/6c0f62f4b9804d40991c50d269072324~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=%2BHZSzvVFyJhrA1ir%2BwamXRkO0I8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;queue 的調用點&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;&lt;span style=&quot;color:#114ba6&quot;&gt;public&lt;/span&gt; &lt;span&gt;&lt;span style=&quot;color:#114ba6&quot;&gt;class&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;Journal&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;extends&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;BookieCriticalThread&lt;/span&gt; &lt;span style=&quot;color:#114ba6&quot;&gt;implements&lt;/span&gt; &lt;span style=&quot;color:#a82e2e&quot;&gt;CheckpointSource&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;查看 journal 的 class 簽名，發現其不出所料的實現了 Thread 的 run 方法，journal 既是順序寫入日誌邏輯的抽象也是後台的刷盤線程的抽象；&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;run 方法的實現較為複雜，其註釋表明這是一個專門負責持久化的線程方法，同時負責 journal 文件的滾動，當 journal 文件被寫滿時，會使用當前時間戳創建一個新的 journal 文件，老的文件會被定期回收。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在 queue 字段旁邊有一個 forceWriteRequests 字段，這個字段在實際的刷盤邏輯中起到了重要作用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a12fa115e8d247e9b29937ddaca709ab~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=HOkuAdbF4xXsNNfMjGb1S8hFCQM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal 部分成員變量釋義：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;maxGroupWaitInNanos 組提交間隔，一般超過這個時間需要刷盤；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flushWhenQueueEmpty 開關表示當 queue 為空時是否刷盤；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bufferedEntriesThreshold 表示暫存在 toFlush 中的對象數量的閾值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bufferedWritesThreshold 表示待刷盤的字節數閾值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journalPageCacheFlushIntervalMSec 真實刷盤的時間間隔。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 方法成員變量釋義：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntries 是一個複用的定長數組；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntriesIdx 是這個定長數組中當前處理的元素索引編號，從 0 開始；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;localQueueEntriesLen 代表每次從 queue 隊列中獲取的對象數量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;toFlush 隊列是個可複用的 ArrayList，可以認為是個對象池；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;numEntriesToFlush 是個待刷盤對象數量的計數器，與 toFlush 配合使用；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;lastFlushPosition 為上次刷盤位點記錄值；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;lastFlushTimeMs 為上次刷盤時間點（毫秒單位）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;JournalChannel 是單個 journal 文件的抽象，journal 代表單個目錄下的多文件抽象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel 代表一個寫入緩衝區，來自於 JournalChannel；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;qe 為 QueueEntry 類型的臨時變量。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 的主要邏輯如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;啓動 forceWriteThread 線程，這是一個真正意義上的刷盤線程；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 線程只是將 queue 中的 QueueEntry 對象寫入相關的 FileChannel 的 buffer 中，並不保證一定落盤；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;實際的刷盤行為由 forceWriteThread 負責。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;不斷的從 queue 中獲取一組 QueueEntry 對象，並逐一將其寫入 BufferedChannel 緩衝區；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;從 queue 中獲取的 QE 對象放入 localQueueEntries 數組中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 需要符合一定的條件才會被寫入二進制數據流（主要 entryId 和版本的識別）；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;寫入調用的是 BufferedChannel#write 方法，只是將數據寫入內部的 writeBuffer 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;寫入緩衝區後，將 QE 對象添加進入 toFlush 隊列，同時調整 numEntriesToFlush（+1）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;繼續處理 localQueueEntries 中的下一個元素。當 localQueueEntriesIdx == localQueueEntriesLen 時，表示 localQueueEntries 元素全部處理完成，此時臨時變量 qe(QueueEntry) 置為 null。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在處理 qe 對象的過程中，會綜合多方面條件判斷是否需要刷盤，使用臨時變量 shouldFlush 表示；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當 numEntriesToFlush&amp;gt;0 且符合以下條件時會觸發「刷盤」邏輯；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當臨時變量 qe 為空，或者當前的 qe 處理的時間超過 maxGroupWaitInNanos；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當臨時變量 qe 為空並且開啓 flushWhenQueueEmpty 配置時刷盤；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當臨時變量 qe 不為空，符合下面兩個條件時刷盤；&lt;/span&gt;&lt;/span&gt; 
      &lt;ol&gt; 
       &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;且 toFlush 中暫存的對象數量超過 bufferedEntriesThreshold；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
       &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;或距離上次刷盤的位點間隔超過 bufferedWritesThreshold。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
      &lt;/ol&gt; &lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果滿足刷盤條件，調用 BufferedChannel#flush 操作；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 操作會將之前攢批的 writeBuffer 中的數據寫入 OS 的文件系統；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;底層作為 FileChannel#write 方法的入參；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;將 toFlush 相關索引為置空，同時調整 numEntriesToFlush；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;觸發 entry 寫入的相關回調邏輯執行；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;更新 lastFlushPosition。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;flush 操作完成後將進一步判斷是否需要向 forceWriteThread 提交真實的刷盤請求；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;提交時會將 toFlush 列表中全部對象連同其他參數封裝成一個請求對象；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;一旦提交後將更新 lastFlushTimeMs；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;符合提交條件的情況有：&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;開啓 syncData ，journal 級別的開啓同步刷盤的開關；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當前需要滾動創建新的 journal 文件；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;距離上次真實刷盤時間超過閾值 journalPageCacheFlushIntervalMSec。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p6-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/640cbca1dece48129b53f44fc9e98493~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=QZIgme%2FnjT7qc1fnMbNcRmT5Ee8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#run 方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;當真實刷盤請求被提交到 forceWriteThread 線程後，有必要進一步分析該線程的執行邏輯，相比之下 ForceWriteThread#run 方法的邏輯簡單很多，解包收到的請求，然後調用 syncJournal 進行強制刷盤，同時做一些清理回收的動作，以及最後的一些回調方法的觸發和統計操作。這裏的 localRequests 也是一個可複用的臨時數組。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4d236b2798084a4bbe3bef3b5a5c4d93~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=DF0IT5x2H541SqZIbXdPcoTa8Go%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ForceWriteThread#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#syncJournal 方法調用了 request 對象的 flushFileToDisk 方法，該方法內部調用了 logFile.forceWrite(false); 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;logFile 就是之前提到的單個 journal 文件的抽象，即 JournalChannel，其內部封裝了 BufferedChannel，實際的類型為 DefaultEntryLogger，與 EntryLogger 所使用的底層實現如出一轍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/785a9fc0bc63440a9a36c1152bc9fef5~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=gogSeuWPDADx7vpgQZybhrFavQA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Journal#syncJournal&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/a9329b4989e64ace98a13c62afa0cf6f~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=e%2ByW88RzPT0fEbYm0Ya4RhRiBnc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;JournalChannel 類&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;再論 Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;上文提到 BookieImpl 中的 addEntry 邏輯似乎很簡單，數據寫入交由 LedgerHander 和 journal 組件，自身則是簡單的封裝。實則不然，查看 BooikeImpl 的實現，發現其中存在一個 SyncThread 對象，該對象是一個同步線程，其邏輯為轉寫 journal 日誌的數據到 entryLog 和 entryIndex。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/942f531f025742f6b4b24a777c3a2ea0~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=ghQVAaYtdbNnyClref1AzzE1vTM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/75475b9530b3443a85dfaca54221de1d~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=W5pPJh0ICMdvmDJDTdCcaBLKlsY%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;啓動 checkpoint 定期檢查&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;doCheckpoint 在底層最終調用了 LedgerStorage#checkpoint 方法，與上文提到的 writeCache 背後的 flush 殊途同歸。這裏存在另外一個問題：SyncThread 線程是否會與 triggerFlushAndAddEntry 中的 flush 線程併發執行，以及是否存在併發刷盤帶來的數據錯亂問題。答案是不會，具體來看 checkpoint 方法內部存在一個 flushMutex 鎖，同時在進入鎖之前，首先會對當前的 checkpoint 做判斷，如果傳入的 checkpoint 水位線低於當前&lt;br&gt; SingleDirectoryDbLedgerStorage 對象持有的 lastCheckpoint 水位線，則不執行實際的 checkpoint 動作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p26-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/4b4d31c75d7241848b19c00f2efd333c~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=tJmenSrpXdhS%2FwRbyjw%2BCcmjwvs%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SyncThread#doCheckpoint&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端分析總結&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookeeper 的 server 端的架構較為複雜，分為多級寫入的架構，收據流向為：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;數據首先進入 writeCache，有後台線程定期將 cache 數據同步到 entryLog 和 entryIndex；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;writeCache 底層採用 swap 機制，保證寫入延遲的穩定性。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;調用 entryLog 和 entryIndex 分別寫入業務數據和索引數據；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryIndex 使用 rocksDB 作為 KV 索引保存 LedgerId+ entryId 到 offset 的映射關係。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#flush 操作和 EntryLogger#flush 操作不同；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;前者只是將數據同步到 entryLog 和 entryIndex 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;後者真實調用底層的文件系統進行刷盤。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 日誌的寫入時可配置的，默認開啓，journal 日誌同樣存在後台的刷盤線程；&lt;/span&gt;&lt;/span&gt; 
  &lt;ol&gt; 
   &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;journal 線程一直重複在幹兩件事；&lt;/span&gt;&lt;/span&gt; 
    &lt;ol&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;將 QueueEntry 轉化為二進制寫入 bufferChannel 的 writebuffer；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;綜合判斷各種條件，定期向 forceWriteThread 線程，提交真實的刷盤任務。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
    &lt;/ol&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;四、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;Bookie 的數據讀取流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端源碼分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;請求路由&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;回到 BookieRequestProcessor#processRequest 的源碼截圖，讀取流程圍繞 READ_ENTRY 這一 opCode 展開，同樣在最新版本的 Bookie 代碼中，read processor 升級到了 V3 版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/da4e75686f194581bbf94fb8b2b21463~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=LCrKjnO6fkI5%2BkidaSVtNnqMvho%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processRequest&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;和寫入一樣，在讀取的 processReadRequestV3 方法中，依然有高優先級線程池和普通線程池，不同的是還多了一個長輪詢線程池，在投遞任務時又出現了熟悉的操作，跟 LedgerId 選擇線程池中具體的線程執行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/0fc61e4f097147b0a21e3f02ad87f205~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Nzj0BbwF0wmRlpTULiMqUv5vwvk%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieRequestProcessor#processReadRequestV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;直接跳轉 ReadEntryProcessorV3#run 方法。發現是個空殼，邏輯封裝 executeOp 方法中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7466b4971a42470b994d89c48ea6d744~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=gKyaBt7ov3UFD%2B9cB1ydqTZ42SA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3#run&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#readEntry&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;最終的讀取邏輯在 BookieImpl#readEntry 中，該方法只是簡單的封裝，根據 LedgerId 獲取到 LedgerDescriptor 後，讀取邏輯順利委託給了 LedgerDescriptor，在 LedgerDescriptor#readEntry 方法內進一步套娃，又將請求轉移給了 LedgerStorage#getEntry，前文提到 LedgerStorage 是個接口，真正幹活的是&lt;br&gt; SingleDirectoryDbLedgerStorage 中的 doGetEntry 方法，這個類在寫入請求的分析過程中同樣出場過。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/9bc7bcac6a4d45cc951c98251327b4ae~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=eqAtbeQDRooXg74sEdqiRNWAD0k%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;BookieImpl#readEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;doGetEntry 方法的邏輯整體較為簡單，主要分為以下幾步：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果傳入的 entryId 為-1 ，表示讀取 LAC ，先從 Ledger 中獲取實際的 LAC 的 entryId，在進行讀取；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;默認先從 writeCache 中讀取，如果讀取不到則去 writeCacheBeingFlushed 中讀取，命中則直接返回；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果 2 級緩存中均不存在，則去 readCache 中據需讀取；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果 readCache 也不存在，那麼就要觸發磁盤讀，先去 entryLocationIndex 獲取 entryLogger 中的物理偏移量；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;隨後調用 entry = entryLogger.readEntry(ledgerId, entryId, entryLocation); 獲取真實數據；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;數據獲取到後會放入 readCache 中；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在方法結束時，會觸發一次預讀，讀取緊挨着當前 entry 的下一個 entry 並放入 readCache 中。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/10592c6aa7c94ae29fe520eceddab116~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=g%2FW4QtAWEb74plNFKiGh5E595kE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage#doGetEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger 如何讀取 entry&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entry 的讀取在上圖的 640 行，最終調用方法為 DefaultEntryLogger#internalReadEntry 方法。邏輯如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;將 location 參數轉化為 buffer 中的 position 位點；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;獲取到 FileChannel(856 行)；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;從 pos-4 位置開始讀取 20 個字節並解析，sizeBuf 值為 entry 的整體長度（4+8+8）；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;然後分配一個 sizeBuf 大小的 buffer 用於裝載即將要讀取的 entry。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/74790b9260fa433e8d4dc129b2b01ad8~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=H8nBbAidGdUZINxkbdT2nVMg0T8%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#internalReadEntry&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/63ab3d9ab38941398572f7c8f65cf212~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=htCn2q%2FPiIgazf1m5lg4o13eS%2FA%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#readEntrySize&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;在存量數據足夠的情況下 readFromLogChannel 方法會盡可能將入參中的 buffer 填滿，在 BufferedReadChannel 中存在一個 readBuffer，默認大小 512 字節，read 方法仍然有可能命中該緩存。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/587ac986509346858d84935a2dd2b0f5~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=7Js6rbpsWGie%2BDNIVYkDCLnaD7E%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger#readFromLogChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;server 端分析總結&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;數據的查詢內容比較簡單，從大的架構上來看整個讀取過程存在三級緩存，都不命中的話才會讀取磁盤。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;實際上在上層的 broker 組件裏還有一層緩存存在。消息獲取流程如下圖所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/c6212093d3de46b798d79bfad5a9752a~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=OgISxwJXrCICgKNz0DApy60MStE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;五、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;讀寫調用鏈分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;組件模塊分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;BufferedChannel&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;其派生關係如下圖所示，還有一個 SlowBufferedChannel 繼承 BufferedChannel 類，但是該類為測試使用。BufferedReadChannel 是讀場景下的主要支撐類，內部有 512 字節的讀緩衝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/054a5088d16042c0a86ba4c414d4e2e4~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=k8OXmKeAdDsoA5iOtIUoNTLJ3vM%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;EntryLogger&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;默認使用 DefaultEntryLogger，主要用於存儲實際的 entry 對象數據，DefaultEntryLogger 和 DirectEntryLogger 的區別在於一個使用 JDK 的 RandomAccessFile ，另一個直接使用 DIO（單獨依賴特定 C 庫）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/f18b0dccc7a2478590e83816b4e5f7b9~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=0s8B1zDWga5xBnXRdLEDrlKR4k0%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DefaultEntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/b0bc2c0d39d54a9cbf6a20b81e29272d~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=M2jOVDPB7Aj6weSYksweY8RYaFw%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;DirectEntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerStorage&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;span&gt;基於 EntryLogger 的上層抽象，主要實現有 InterleavedLedgerStorage 和&lt;br&gt; SingleDirectoryDbLedgerStorage， 還有一個 SortedLedgerStorage，內部封裝了 InterleavedLedgerStorage，複用了大部分的 InterleavedLedgerStorage 的方法。SortedLedgerStorage 每次寫入時對內部的數據進行排序，使用自帶的 KV 引擎存儲 LedgerId+entryId--&amp;gt;location 映射關係。SingleDirectoryDbLedgerStorage 每次刷盤時才會對緩存的數據進行排序，使用 rocksDB 存儲 KV 關係。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/ba4d06e591ef44daa9d61fd49797a38b~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=Rwnng0zaWSyfAjLsLER%2FHFN5xuI%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;SingleDirectoryDbLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/009d3df275cb4b63894e7d56fb1d28eb~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=jfkJD6uhdy1kASljF9FJZd%2BJHjc%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;InterleavedLedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;LedgerDescriptor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;包裝類，大部分邏輯委託給 ledgerStorage 實現。內部持有 ledgerId，每個 ledgerId 對應一個 LedgerDescriptor 對象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 節點級存儲抽象，內部封裝了多個 journal 抽象組成的 journalList，ledgerStorage，syncThread 線程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;syncThread 線程主要負責將 journal 中的 appendLog 轉寫為 entryLog 和 enrtyIndex，checkpoint 之前的數據在執行 GC（數據清理工作，非 JVM 中的 GC）時可被回收刪除。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3，WriteEntryProcessorV3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;負責讀寫指令的路由和轉化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;寫入流程調用時序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;WriteEntryProcessorV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt; Bookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerDescriptor&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;EntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;BufferedLogChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/1c735733cd674ce3918d9859602f7050~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=63qO9iUg3pIXQ5J1aZeiutQE6uE%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;讀取流程調用時序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;ReadEntryProcessorV3&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt; Bookie&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerDescriptor&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;LedgerStorage&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;EntryLogger&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;--&amp;gt;BufferedReadChannel&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-6w9my0ksvp/7366bcc7df3f4d5ab2bcd2562b260d18~tplv-tt-shrink:640:0.image?lk3s=06827d14&amp;amp;traceid=20240527162338B78E4572A9F45AD6EE06&amp;amp;x-expires=2147483647&amp;amp;x-signature=dZL%2BVkBi5st0Z%2FYaAm3N5aZ3o6M%3D&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;p style=&quot;margin-left:0px; margin-right:0px&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;strong&gt;六、&lt;span style=&quot;color:#ffffff&quot;&gt;&lt;span style=&quot;background-color:#000000&quot;&gt;架構總結&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;Bookie 的存儲架構主要分為三大塊，首先是代表 WAL 日誌的 journal 文件寫入，以順序混寫的方式提升寫入性能，保證低延遲，通常以獨立盤隔離掛載，典型的消息場景下 journal 日誌寫完後即可返回。由於是不同 topic 的混合寫入，journal 日誌無法很好的支撐單個 topic 的消息的順序讀，回溯等場景，會存在讀放大問題。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;由此就衍生出了 entryLog 的二次轉儲，為了儘可能利用順序讀，單個 entryLog 內部的數據在寫入時會根據 ledgerId+entryId 排序，這樣同一個 ledgerId 的數據會緊密的收斂在局部，能夠一定程度上提升讀性能；entryLog 寫入後會獲取到消息實際存儲的位點信息 offset，由於該 offset 不可被自定義，很難表述出這條消息在 topic 寫入序列上為第幾條信息，這一點很重要，因為消費的時候是基於這樣的序列來消費的，同時在消費位點管理時也需要這樣的信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;entryId 的作為一個傳入參數，其作用恰恰如此，是一個面向用户的更易於管理的唯一 Id。當用户基於 ledgerId+entryId 來查找數據時，顯然並不知道這個這條數據實際存儲 offset 信息。這就誕生了一個額外的 KV 結構，用來保存 ledgerId+entryId 到 offset 的映射關係。Bookie 內嵌了 rocksDB 的 KV 引擎，同時也自行實現了一套，Pulsar 默認使用 rocksDB 方式保存 KV 關係。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;bookie 在整個寫入和讀取過程中利用了大量的用户態緩存機制，相比於 mmap 的 pageCache 機制更為靈活可控，同時也很大程度上降低了讀寫的抖動，尤其是在容器環境下不同 POD 互相干擾的情況。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;*&lt;/span&gt;&lt;strong&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;文/&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span style=&quot;color:#000000&quot;&gt;簌語&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;本文屬得物技術原創，更多精彩文章請看：&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftech.dewu.com%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;得物技術&lt;/a&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#222222; margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;span style=&quot;color:#4d4d4d&quot;&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任！&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/5783135/blog/11194314</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/11194314</guid>
            <pubDate>Tue, 28 May 2024 02:08:00 GMT</pubDate>
            <author>得物技術</author>
        </item>
        <item>
            <title>崑崙萬維：天工 AI 每日活躍用户超 100 萬</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;崑崙萬維宣佈，天工 AI 每日活躍用户（DAU）已超過 100 萬。並表示，在初步驗證大模型能力之後，天工 AI 將繼續聚焦產品市場匹配度（PMF, Product Market Fit）。&lt;/p&gt; 
&lt;p&gt;國內商業智能數據服務商 QuestMobile 數據顯示，早在 2024 年 3 月，崑崙萬維天工 AI APP 的月活躍用户已達近千萬，僅次於豆包與文心一言，成為國內 AIGC APP 月活躍用户第三。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;309&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-545cde53bfd86762ad17eee2e934e789562.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此外，天工 AI 智能體平台目前已擁有近百萬個 UGC 智能體。&lt;/p&gt; 
&lt;p&gt;天工 AI 最新上線的 AI PPT 則是近期最受用户歡迎的 AI 智能體之一。用户只需要輸入 PPT 內容需求，天工 AI 即可立即在線生成一份完整、可編輯的 PPT 大綱及各頁內容文本，並實現智能檢索圖片、智能匹配模板，一鍵生成內容完整、邏輯清晰、佈局優美的 PPT 文檔，用户可在線或下載到本地進行編輯與分享。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;328&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-b6a2df6071f19c4eca764da6ceb56111c3c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;崑崙萬維方面表示，下一步將全力推動人工智能技術應用落地，不斷優化天工 AI 的模型技術研發與產品用户體驗，打造用户首選的人工智能內容創作平台，賦能用户生成高質量的文字、聲音、圖像、音樂、視頻等 AI UGC 內容，讓人工智能技術走入千家萬户，為我國人工智能產業發展貢獻積極力量。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294578</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294578</guid>
            <pubDate>Tue, 28 May 2024 02:04:49 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>原來東子的「兄弟」是用 let 定義的「兄弟」</title>
            <description>媒體報道稱，劉強東近日在高管會上直言：「凡是長期業績不好，從來不拼搏的人，不是我的兄弟。」</description>
            <link>https://mp.weixin.qq.com/s/_MYBiooOBtC5u7-m-JmC2A</link>
            <guid isPermaLink="false">https://mp.weixin.qq.com/s/_MYBiooOBtC5u7-m-JmC2A</guid>
            <pubDate>Mon, 27 May 2024 14:10:00 GMT</pubDate>
        </item>
        <item>
            <title>微軟對開源字體 Cascadia Code 進行重大更新</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Cascadia Code 2404.23 版本已&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fcommandline%2Fcascadia-code-2404-23%2F&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;。Cascadia Code 是微軟開源的一套等寬字體，這是該字體自三年前發佈 2111.01 版本以來的第一次重大版本更新。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2404.03 版本中為 Cascadia Code 添加了對象限、六分儀、八分儀、大型字體、更多傳統計算符號和 Nerd 字體的支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;285&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-26f734452da97140646a771c76f8167c980.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;356&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-19736901ec49a109baf16d78ec836d36a29.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;311&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-76c6dc1f24cbbfcf90338aec83762a1a404.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;451&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-657504c9b33faf48aa5491b4121d1529bb5.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;244&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-830dad5725018c339e6d639be1febe23587.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告稱，項目團隊正在將「Cascadia Code NF」和「Cascadia Mono NF」添加到 Cascadia Code 字體系列中。Cascadia Code NF 和 Cascadia Mono NF 是 Cascadia Code 的原生「&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nerdfonts.com%2F&quot; target=&quot;_blank&quot;&gt;Nerd Font&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;」變體，包含截至 2024 年 4 月的最新 Nerd Font 字形。且每個字形都與 Cascadia Code 的其餘部分兼容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;329&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-61dc965e58e3e7d16af123a6e9b737344fc.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用户可以將 Cascadia Code 的 Nerd 字體變體與 Oh My Posh 相結合，進行自定義。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;324&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-dedb91d874502190a5f1c6e59b473f5751d.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;更多詳情可&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdevblogs.microsoft.com%2Fcommandline%2Fcascadia-code-2404-23%2F&quot; target=&quot;_blank&quot;&gt;查看官方公告&lt;/a&gt;&lt;span style=&quot;color:#000000&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294449/cascadia-code-2404-23</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294449/cascadia-code-2404-23</guid>
            <pubDate>Mon, 27 May 2024 06:45:14 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>黑客利用掃雷遊戲 Python 克隆隱藏惡意腳本，攻擊歐洲和美國金融機構</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;近期，烏克蘭的國家計算機緊急響應小組（CSIRT-NBU）和烏克蘭計算機緊急響應小組（CERT-UA）共同&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bleepingcomputer.com%2Fnews%2Fsecurity%2Fhackers-phish-finance-orgs-using-trojanized-minesweeper-clone%2F&quot; target=&quot;_blank&quot;&gt;揭露了一起黑客攻擊事件&lt;/a&gt;。攻擊者利用微軟經典掃雷遊戲的 Python 克隆代碼，隱藏針對歐洲和美國金融機構的惡意腳本。&lt;/p&gt; 
&lt;h3&gt;攻擊背景與執行者&lt;/h3&gt; 
&lt;p&gt;本次攻擊被追蹤到一個代號為「UAC-0188」的威脅行為者。該黑客組織通過使用合法代碼，成功地隱藏並下載安裝了 SuperOps RMM 的 Python 腳本。&lt;/p&gt; 
&lt;p&gt;SuperOps RMM 是一款合法的遠程管理軟件，但被攻擊者用來直接訪問被入侵的系統。CERT-UA 的報告指出，自攻擊被發現以來，已經有至少五起涉及歐洲和美國金融及保險機構的潛在相同文件的違規行為。&lt;/p&gt; 
&lt;h3&gt;攻擊細節&lt;/h3&gt; 
&lt;p&gt;攻擊從一封偽裝成醫療中心的電子郵件開始，發件地址為「support@patient-docs-mail.com」，郵件主題為「個人醫療文檔的網絡檔案」。受害者被誘導從提供的 Dropbox 鏈接下載一個 33MB 的.SCR 文件。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1126&quot; src=&quot;https://static.oschina.net/uploads/space/2024/0527/142132_Kt16_3820517.png&quot; width=&quot;1688&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;該文件包含了一個無害的 Python 克隆掃雷遊戲代碼，但同時也隱藏了從遠程源（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fanotepad.com&quot; target=&quot;_blank&quot;&gt;anotepad.com&lt;/a&gt;）下載額外腳本的惡意 Python 代碼。掃雷代碼中包含一個名為「create_license_ver」的函數，該函數被重新用於解碼和執行隱藏的惡意代碼。黑客利用這種方法試圖讓安全軟件誤認為該文件是無害的。&lt;/p&gt; 
&lt;p&gt;惡意代碼通過 base64 編碼的字符串隱藏在文件中，該字符串解碼後會組裝一個包含 SuperOps RMM 的 MSI 安裝程序的 ZIP 文件。安裝程序最終被提取並使用靜態密碼執行，授予攻擊者對受害者計算機的未授權訪問。&lt;/p&gt; 
&lt;h3&gt;安全建議&lt;/h3&gt; 
&lt;p&gt;CERT-UA 建議不使用 SuperOps RMM 產品的組織，將任何與該產品相關的網絡活動，如對「&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsuperops.com&quot; target=&quot;_blank&quot;&gt;superops.com&lt;/a&gt;」或「&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsuperops.ai&quot; target=&quot;_blank&quot;&gt;superops.ai&lt;/a&gt;」域的調用，視為黑客入侵的跡象。報告底部還分享了與此次攻擊相關的其他入侵指標（IoCs），供安全團隊參考。&lt;/p&gt; 
&lt;p&gt;這起攻擊事件提醒我們，黑客正在不斷尋找創新的方法來繞過安全防護，企業和個人用户都應時刻保持警惕，及時更新安全軟件，避免下載和執行來歷不明的文件。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294442/hackers-phish-finance-orgs-using-trojanized-minesweeper-clone</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294442/hackers-phish-finance-orgs-using-trojanized-minesweeper-clone</guid>
            <pubDate>Mon, 27 May 2024 06:23:14 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>華為發佈 2024 年奧林帕斯難題懸紅——200 萬元、解決 AI 與數據存儲難題</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;近日，華為在 2024 年全球數據存儲教授論壇上，宣佈了&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fe.huawei.com%2Fcn%2Ftopic%2Fstorage%2Folympus-mons-awards&quot; target=&quot;_blank&quot;&gt;2024 年奧林帕斯難題懸紅&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;今年的奧林帕斯難題包括兩個方向：&lt;strong&gt;一是每比特極致性價比的存儲技術，二是面向 AI 時代的新型數據底座&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;奧林帕斯難題百萬懸紅設立兩個奧林帕斯獎，每個難題方向各一個，如果某個難題方向大獎空缺，增設 1-2 個奧林帕斯先鋒獎。&lt;strong&gt;奧林帕斯獎獎金為 100 萬元人民幣/個，奧林帕斯先鋒獎獎金 50 萬元人民幣/個&lt;/strong&gt;，旨在吸引全球頂尖科研人才共同探索數據存儲領域的前沿技術。&lt;/p&gt; 
&lt;p&gt;據瞭解，自 2019 年起，華為每年發佈奧林帕斯難題百萬懸紅，旨在牽引全球數據存儲領域基礎理論研究方向，突破關鍵技術難題，加速科研成果產業化，實現產學研合作共贏。目前，「奧林帕斯懸紅」已發佈四期，共吸引來自全球 49 所高校的 240 多名學者積極參與。&lt;/p&gt; 
&lt;p&gt;去年，蘇黎世聯邦理工學院 Torsten Hoefler 教授團隊以及上海交通大學過敏意教授團隊榮獲 2023 年奧林帕斯獎。來自新加坡國立大學尤洋教授團隊、韓國科學技術院 John Kim 教授團隊、北京大學楊仝老師團隊、中國科學院計算技術研究所王穎老師團隊獲得 2023 年奧林帕斯先鋒獎。&lt;/p&gt; 
&lt;p&gt;華為數據存儲產品線總裁周躍峯表示，具備極致性能、數據韌性、全新數據範式、高擴展性、綠色節能、數據編織能力的數據存儲是 AI 時代存儲演進的必由之路，需要各界的共同參與。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;近日發佈的《全國數據資源調查報告（2023 年）》顯示，2023 年，全國數據生產總量達 32.85ZB（澤字節），同比增長 22.44%。&lt;/p&gt; 
&lt;p&gt;在數據存儲方面，2023 年我國累計數據存儲總量為 1.73ZB（澤字節），存儲空間利用率為 59%，其中政府和行業重點企業存儲空間利用率均為 70% 左右。在上述存儲數據中，數據雲存儲佔比超過 40%。&lt;/p&gt; 
&lt;p&gt;在算力方面，至 2023 年底，全國 2200 多個算力中心的算力規模同比增長約為 30%。大模型訓練算力需求高漲，科學、政務、金融、工業等行業算力需求增加。&lt;/p&gt; 
&lt;p&gt;報告還指出，我國數據資源管理和利用整體處於起步階段，目前還存在數據有效供給不足、算力還需適度超前佈局、數據多元流通模式待完善、數據價值有待進一步釋放等挑戰。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294439/huawei-olympus-mons-awards-2024</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294439/huawei-olympus-mons-awards-2024</guid>
            <pubDate>Mon, 27 May 2024 06:19:14 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>蘋果重新設計其開發者論壇</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;蘋果&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fnews%2F%3Fid%3Dhufhlpow&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;已針對 WWDC24 重新設計其開發者論壇，以便於開發者與 Apple 專家、工程師以及彼此聯繫，尋找答案並獲取建議。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「Apple 開發者關係部和 Apple 工程部門將聯手解答您的問題，並努力解決您的技術問題。您將可以訪問擴展的知識庫並享受快速響應時間 - 這樣您就可以重新開始創建和改進您的應用或遊戲。此外，Apple 開發者計劃成員現在可以優先訪問論壇上的專家建議。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;259&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5c7ab78dc1b4fbff123235c53f00bcd74d4.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;論壇現在按照一些主題劃分了十幾個大分類，以幫助用户精確導航查找。具體包括：Accessibility &amp;amp; Inclusion、App &amp;amp; System Services、App Store&amp;nbsp;分發和營銷、商業與教育、代碼簽名、社區、開發人員工具和服務等等。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;其中，每個大分類還包含了一些更具體的子主題。在特定問題旁邊可能會出現「Apple 推薦」圖標，表示 Apple 工程師已經回答了該問題；或者出現「已解決」圖標，表示該問題有一個社區認可的答案。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;除了按主題瀏覽外，還有一個 &lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fforums%2Flatest&quot; target=&quot;_blank&quot;&gt;Latest &lt;/a&gt;欄目&lt;span style=&quot;color:#000000&quot;&gt;，其中顯示了所有主題的所有最新內容。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;詳情可查看：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.apple.com%2Fforums%2F&quot; target=&quot;_blank&quot;&gt;https://developer.apple.com/forums/&lt;/a&gt;&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294436/apple-redesigns-developer-forums</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294436/apple-redesigns-developer-forums</guid>
            <pubDate>Mon, 27 May 2024 06:08:14 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>行業內首次實現國產 GPU 從 0 到 1 的端到端 AI 大模型實訓</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;摩爾線程、無問芯穹今天聯合宣佈，雙方已經正式完成基於國產全功能 GPU 千卡集羣的 3B 規模大模型「MT-infini-3B」實訓，&lt;strong&gt;該模型基於摩爾線程國產全功能 GPU MTT S4000 組成的千卡集羣&lt;/strong&gt;，以及無問芯穹的 AIStudio PaaS 平台打造。&lt;/p&gt; 
&lt;p&gt;據悉，這次的 MT-infini-3B 模型訓練總共用時 13.2 天，全程穩定無中斷，集羣訓練穩定性達到 100％，千卡訓練和單機相比擴展效率超過 90％，號稱「充分驗證了誇娥千卡智算集羣在大模型訓練場景下的可靠性，同時也在行業內率先開啓了國產大語言模型與國產 GPU 千卡智算集羣深度合作的新範式」。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;本次實訓充分驗證了誇娥千卡智算集羣在大模型訓練場景下的可靠性，同時也在行業內率先開啓了國產大語言模型與國產 GPU 千卡智算集羣深度合作的新範式。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前，實訓出來的 MT-infini-3B 性能在同規模模型中躋身前列，相比在國際主流硬件上訓練而成的其他模型，在 C-Eval，MMLU，CMMLU 等 3 個測試集上均實現性能領先。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-006f2e3d0fd10bdbe8a116c276fc8e377b4.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;MT-infini-3B 性能表現&lt;/em&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;無問芯穹聯合創始人兼 CEO 夏立雪表示：「國內大模型與國產芯片的軟硬件協同發展，最終目標是構建一個成熟的生態系統。無問芯穹正在打造‘M 種模型’和‘N 種芯片’間的‘M×N’中間層產品，實現多種大模型算法在多元芯片上的高效、統一部署。摩爾線程是第一家接入無問芯穹並進行千卡級別大模型訓練的國產 GPU 公司，而‘MT-infini-3B’的訓練是行業內首次實現基於國產 GPU 芯片從 0 到 1 的端到端大模型實訓案例。」&lt;/p&gt; 
&lt;p&gt;摩爾線程創始人兼 CEO 張建中表示：「無問芯穹在誇娥千卡智算集羣上實現的從零開始的大模型訓練，不僅是對摩爾線程技術實力的有力認證，更是實現了國內大模型訓練的國產化閉環。摩爾線程誇娥千卡智算集羣以全功能 GPU 為底座，提供軟硬一體化的全棧解決方案，具備高兼容性、高穩定性、高擴展性等綜合優勢，我們致力於成為 AGI 時代大模型訓練堅實可靠的先進基礎設施。」&lt;/p&gt; 
&lt;p&gt;此前，摩爾線程與無問芯穹已達成深度戰略合作。無問芯穹大模型開發與服務平台「無穹 Infini-AI」和摩爾線程大模型智算千卡集羣誇娥已完成系統級融合適配，該平台可以靈活調用誇娥的集羣能力以完成大模型的訓練、微調與推理任務。未來，雙方還將開展更多適配與測試，推動國產大模型技術的快速發展與應用普及，為中國人工智能產業的蓬勃發展貢獻力量。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;▼&lt;/strong&gt;&amp;nbsp; 關於無問芯穹&lt;/p&gt; 
&lt;p&gt;無問芯穹（Infinigence AI）依託行業領先且經過驗證的 AI 計算優化能力與算力解決方案，追求大模型落地的極致能效。打造「M 種模型」和「N 種芯片」間的「M×N」中間層產品，實現多種大模型算法在多元芯片上的高效、統一部署。鏈接上下游，共建 AGI 時代大模型基礎設施，加速 AGI 落地千行百業。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;▼&lt;/strong&gt;&amp;nbsp; 關於摩爾線程&lt;/p&gt; 
&lt;p&gt;摩爾線程是一家以全功能 GPU 芯片設計為主的集成電路高科技公司，能夠為廣泛的科技生態合作伙伴提供強大的計算加速能力，致力於打造為下一代互聯網提供多元算力的元計算平台。&lt;/p&gt;
                                        &lt;/div&gt;
                                    </description>
            <link>https://www.oschina.net/news/294431</link>
            <guid isPermaLink="false">https://www.oschina.net/news/294431</guid>
            <pubDate>Mon, 27 May 2024 05:52:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>我的 CEO 覺得任何技術經理都是多餘的</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                            
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;原文 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcharity.wtf%2F2024%2F01%2F05%2Fquestionable-advice-my-boss-says-we-dont-need-any-engineering-managers-is-he-right%2F&quot; target=&quot;_blank&quot;&gt;QUESTIONABLE ADVICE: 「MY BOSS SAYS WE DON’T NEED ANY ENGINEERING MANAGERS. IS HE RIGHT?」&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ae1abd6d4c75f3c03c8a571fbf995b47e5c.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;我最近加入了一家初創公司，負責管理一個約 40 名工程師的團隊，擔任技術副總裁。然而，我與 CEO（之前是工程師）在是否需要僱傭專職技術經理的問題上產生了很大的衝突。目前，工程師們被分成了 3-4 人的小團隊，每個團隊有一個工程師頭頭，負責領導團隊，但他們的主要職責仍然是編寫代碼和交付產品。&lt;/p&gt; 
&lt;p&gt;我有 HC 在未來一年僱傭更多的工程師，但沒有經理的 HC。老闆認為我們是初創公司，負擔不起這種奢侈品。在我看來，我們顯然需要技術經理，但在他看來，經理只是多餘的開銷，在我們的階段所有人都應該全力編寫代碼。&lt;/p&gt; 
&lt;p&gt;我不知道該如何論證。在我看來這很顯然，但實際上我很難用言語表達為什麼我們需要技術經理。你能幫幫我嗎？&lt;/p&gt; 
&lt;p&gt;—— 真的是多餘的開銷嗎 (？！)&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;這裏有很多問題需要解答。&lt;/p&gt; 
&lt;p&gt;你的首席執行官不理解為什麼需要經理，這並不奇怪，因為他似乎不明白為什麼需要組織結構。🙈 他為什麼要對你如何組織團隊或你可以僱傭哪些角色進行微管理？他僱用了你來做這份工作，卻不讓你完成。他甚至不能解釋為什麼不讓你做。這不是個好兆頭。&lt;/p&gt; 
&lt;p&gt;但這個問題確實值得思考。我們假設他不是故意要刁難你。😒&lt;/p&gt; 
&lt;p&gt;我能想到兩種論證僱用技術經理的方式：一種是相當複雜的，從第一性原理 (First Principle) 出發，另一種非常簡單，但可能不太令人滿意。&lt;/p&gt; 
&lt;p&gt;我個人對權威有一種強烈的反感；我討厭被告知該做什麼。直到最近，我才通過系統理論的視角，找到了一種對層級制度既健康又實用的理解。&lt;/p&gt; 
&lt;h2&gt;為什麼組織中存在層級制度？&lt;/h2&gt; 
&lt;p&gt;層級制度確實帶有很多負麪包袱。我們許多人都有過在層級制度下與經理或整個組織打交道的不幸經歷。在這些地方，層級制度被用作壓迫的工具，人們通過壟斷信息和玩弄權力遊戲來提升地位，決策則是通過權力壓制來做出。&lt;/p&gt; 
&lt;p&gt;在那種地方工作真的是一種折磨。誰願意將自己的創造力和生命力投入到一個感覺像《呆伯特》漫畫的地方，明知道自己的價值被極少認可或回報，而且這些價值會慢慢地但確實被壓制掉？&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6d2e37d41170abca4035827e64d6dfa12f6.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;但層級制度本質上並非是專制的。層級制度並不是人類為控制和支配彼此而發明的一種政治結構，它實際上是自組織系統的一種屬性，是為了子系統的有效運作而出現的。事實上，層級制度對複雜系統的適應性、彈性和可擴展性至關重要。&lt;/p&gt; 
&lt;p&gt;讓我們從一些關於系統的基本事實開始，為可能不熟悉的人介紹一下。&lt;/p&gt; 
&lt;h2&gt;層級是自組織系統的一種屬性&lt;/h2&gt; 
&lt;p&gt;一個系統是「由相互依賴的組件組成的網絡，這些組件共同工作以實現一個共同目標」（W. Edward Deming）。一堆沙子不是一個系統，但一輛車是一個系統；如果你把油箱取下來，車就無法運作。&lt;/p&gt; 
&lt;p&gt;子系統是一個在更大系統內有較小目標的元素集合。在一個系統中可以有很多層次的子系統，它們相互依存地運行。子系統總是為了支持更大系統的需求而工作；如果子系統只為自己的最佳利益優化，整個系統可能會掛掉（這就是「次優」(suboptimal) 這個術語的由來 😄）。&lt;/p&gt; 
&lt;p&gt;如果一個系統能夠通過多樣化、適應和改進自身使自己變得更加複雜，那麼它就是自組織的。隨着系統自組織並增加其複雜性，它們往往會生成層級 —— 即系統和子系統的排列。在一個穩定、有彈性和高效的系統中，子系統在很大程度上可以自我管理、自我調節，併為更大系統的需求服務，而更大系統則負責協調子系統之間的關係並幫助它們更好地發揮作用。&lt;/p&gt; 
&lt;p&gt;層級最小化了協調成本，減少了系統中任何部分需要跟蹤的信息量，防止信息過載。子系統內部的信息傳遞和關係比子系統之間的信息傳遞或關係要密集得多，延遲也少得多。&lt;/p&gt; 
&lt;p&gt;（對於任何軟件工程師來説，這些應該都很熟悉。模塊化，對吧？😍）&lt;/p&gt; 
&lt;p&gt;按照這個定義，我們可以説，經理的工作就是在團隊之間進行協調並幫助他們的團隊表現得更好。&lt;/p&gt; 
&lt;h2&gt;對社會技術系統的二分是偽命題&lt;/h2&gt; 
&lt;p&gt;你可能聽過這個謬論：「工程師搞技術，經理搞人。」我討厭這種説法。😊 我認為這完全誤解了社會技術系統的本質。社會技術系統中的「社會」和「技術」並不是截然分開的，而是相互交織、相互依存的。事實上，很少有純粹的技術工作或純粹的人際工作；有大量涉及兩種技能的粘合工作。&lt;/p&gt; 
&lt;p&gt;看看任何一個有效運作的工程組織除了編寫代碼之外還要做的一部分任務：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;招聘、建立人脈、面試、培訓面試官、彙總反饋、撰寫職位描述和職業發展路徑&lt;/li&gt; 
 &lt;li&gt;每個項目或承諾的項目管理、優先級排序、管理利益相關者和解決衝突、估算規模和範圍、進行回顧會議&lt;/li&gt; 
 &lt;li&gt;召開團隊會議、進行一對一交流、提供持續的成長反饋、撰寫評審、代表團隊的需求，架構設計、代碼審查、重構；捕獲 DORA 和生產力指標、管理警報量以防止倦怠&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;許多工作可以由工程師完成，而且通常也是如此。每家公司對這些任務的分配方式有所不同。這是一件好事！你不希望這些工作僅由經理來做。你希望個人貢獻者共同創造組織，並參與其運行方式。幾乎所有這些工作由有工程背景的人完成會更有效。&lt;/p&gt; 
&lt;p&gt;所以，你可以理解為什麼有人會猶豫是否要把寶貴的人員編制花在技術經理上。為什麼不希望技術部門的每個人的主要工作都是編寫和交付代碼呢？這不是從定義上説最大化生產力的最佳方式嗎？&lt;/p&gt; 
&lt;p&gt;額……😉&lt;/p&gt; 
&lt;h2&gt;技術經理是一層有用的抽象&lt;/h2&gt; 
&lt;p&gt;理論上，你可以列出所有需要完成的協調任務，並讓不同的人來負責每一項。但實際上，這是不切實際的，因為這樣每個人都需要了解所有事情。記住，層級制度的主要好處之一是減少信息過載。團隊內部的溝通應該是高效和快速的，而團隊之間的溝通則可以少一些。&lt;/p&gt; 
&lt;p&gt;隨着公司的擴展，你不能期望每個人都認識其他所有人；我們需要抽象的概念才能運作。經理是他們團隊的聯絡點和代表，充當重要信息的路由器。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0574899d959a544f15c5ae6ff19d2228584.png&quot; alt=&quot;file&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;有時我把經理想象成公司的神經系統，將信息從一個部門傳遞到另一個部門，以協調行動。將許多或大部分功能集中到一個人身上，可以利用專業化的優勢，因為經理會不斷建立關係和背景知識，並在他們的角色中不斷改進，這大大減少了其他人的上下文切換。&lt;/p&gt; 
&lt;h2&gt;管理者 (Manager) 日程與創造者 (Maker) 日程&lt;/h2&gt; 
&lt;p&gt;技術工作需要集中和專注。上下文切換的成本很高，過多的中斷是挺要命的。而管理工作則是每小時左右進行一次上下文切換，並且一整天都要應對各種打斷。這是兩種完全不同的工作模式、思維方式和日程安排，無法很好地共存。&lt;/p&gt; 
&lt;p&gt;通常，你希望團隊成員能夠把大部分時間花在直接為他們負責的成果做出貢獻的事情上。工程師只能做有限的粘合工作，否則他們的日程安排就會變得支離破碎，從而無法履行他們的承諾。而管理者的日程安排本身已經是支離破碎的，因此讓他們承擔更多的粘合工作通常不會帶來太大幹擾。&lt;/p&gt; 
&lt;p&gt;雖然並不是所有粘合工作都應該由管理者來完成，但管理者的職責是確保所有工作都能完成。管理者的職責是儘量讓每個工程師都能從事有趣且具有挑戰性的工作，但不能讓他們感到過於負擔重，還要確保不愉快的工作能公平分配。管理者還要確保，如果我們要求某人完成一項工作，就必須為其配備成功完成這項工作所需的資源，包括專注的時間。&lt;/p&gt; 
&lt;h2&gt;管理是問責的工具&lt;/h2&gt; 
&lt;p&gt;當你是工程師時，你對自己開發、部署和維護的軟件負責。而作為經理，你則對團隊和整個組織負責。&lt;/p&gt; 
&lt;p&gt;管理是一種讓人們對特定結果（如構建具備正確技能、關係和流程的團隊，以做出正確的決策併為公司創造價值）負責的方式，併為他們提供實現這些結果所需的資源（預算、工具和人員編制）。如果你不把組織建設作為某人的首要任務，那麼這就不會成為任何人的首要任務，這意味着它可能不會得到很好地執行。那麼，這該由誰負責呢，CEO 先生？&lt;/p&gt; 
&lt;p&gt;你對技術負責人、工程師或任何負責交付軟件的人在「業餘時間」能完成的任務有一個合理的上限。如果你試圖讓技術負責人負責構建健康的工程團隊、工具和流程，那麼你就是在要求他們在同一個日曆裏做兩份時間不兼容的工作。最可能的情況是，他們會專注於自己覺得舒適的成果（技術成果），而在後台堆積組織債務。&lt;/p&gt; 
&lt;p&gt;在自然層級中，我們向上看是為了目標，向下看是為了功能。簡而言之，這就是我們需要技術經理的複雜原因。&lt;/p&gt; 
&lt;h2&gt;選擇無趣的技術文化&lt;/h2&gt; 
&lt;p&gt;更簡單的論點是：大多數工程組織都有技術經理。這是默認設置。多年來，許多比你或我更聰明的人花了大量時間思考和調整組織結構，這就是我們得到的結果。&lt;/p&gt; 
&lt;p&gt;正如丹-麥金利（Dan McKinley）的名言，我們應該「選擇無趣的技術」。無趣並不意味着不好，而是意味着它的能力和失敗條件是眾所周知的。你只能獲得少數的創新點數，因此你應該明智地將這些點數用在能夠成就或毀掉你業務的核心差異點上。文化也是如此。你真的想把你的點數用在組織結構上嗎？為什麼？&lt;/p&gt; 
&lt;p&gt;無論好壞，層級組織結構是眾所周知的。市場上有很多人擅長管理或與管理者合作，你可以僱傭他們。你可以接受培訓、指導，或者閲讀大量的自助書籍。有各種各樣的管理哲學可以圍繞它們來凝聚團隊或用來排除其他人。另一方面，我所知道的無經理實驗（例如 Medium 和 GitHub 的全員自治，或 Linden Lab 的「選擇你的工作」）都被悄然放棄或被顛覆了。在我的經驗中，這並不是因為領導者瘋狂追求權力，而是由於混亂、缺乏重點和執行不力。&lt;/p&gt; 
&lt;p&gt;當沒有明確的結構或層級時，結果不是自由和平等，而是「非正式的、不被承認的和不負責任的領導」，正如《無結構的暴政》中詳細描述的那樣。事實上，這些團隊往往是混亂、脆弱和令人沮喪的。我知道！我也很生氣！😭&lt;/p&gt; 
&lt;p&gt;這個論點並不一定能證明你的 CEO 是錯的，但我認為他的證明標準比你的要高得多。「我不想讓我的任何工程師停止寫代碼」並不是一個有效的論點。但我也覺得我還沒有完全解決生產力的核心問題，所以我們再來討論一下這個問題。&lt;/p&gt; 
&lt;h2&gt;更多代碼行數 ≠ 更高生產力&lt;/h2&gt; 
&lt;p&gt;簡要回顧一下：我們在討論一個有約 40 名工程師的組織，分成 10 個小組，每組有 3-4 名工程師，每組都有一個技術負責人。你的 CEO 認為，如果有人停止全職編程，這個減速將是你們無法承受的。&lt;/p&gt; 
&lt;p&gt;也許吧。但根據我的經驗，由經驗豐富的技術經理領導的幾個較大團隊，將遠遠優於這些小團隊。這差距很明顯。而且，他們可以以更高效、可持續和人性化的方式完成工作，而不是這種拼命的死命趕工。&lt;/p&gt; 
&lt;p&gt;系統思維告訴我們原因！更少的團隊，但規模更大，你會有更少的整體管理開銷，且大大減少了團隊內慢且昂貴的協調。你可以在團隊內部實現豐富、密集的知識傳遞，從而實現更大面積的共享。每組有 7-9 名工程師，你可以建立一個真正的值班輪換，這意味着更少的英雄主義和更少的倦怠。你需要進行的協調可以更具戰略性，減少戰術性，更具前瞻性。&lt;/p&gt; 
&lt;p&gt;五個大團隊是否能比十個小團隊編寫更多的代碼行數，即使有五名工程師成為經理並停止編寫代碼？可能會，但誰在乎呢？你的客户根本不關心你寫了多少代碼行數。他們關心的是你是否在構建正確的東西，是否在解決對他們重要的問題。關鍵是推動業務前進，而不是單純地編寫代碼。不要忘記，單純地編寫代碼會產生額外的成本和負面效應。&lt;/p&gt; 
&lt;p&gt;決定你速度的是你是否把時間花在了正確的事情上。學會正確決定構建什麼是每個組織都必須自己解決的問題，而且這是一項持續不斷的工作。技術經理不會做所有的工作或做出所有的決策，但根據我的經驗，他們對於確保工作順利進行並且做得很好，絕對至關重要。正如我在上篇文章中寫到的，技術經理是系統用來學習和改進的反饋循環的載體。&lt;/p&gt; 
&lt;h2&gt;管理人員是否會成為不必要的開銷？&lt;/h2&gt; 
&lt;p&gt;當然有可能。管理的核心是協調團隊之間的工作並提升團隊的運作效率，所以任何減少協調需求的方式也會減少對管理的需求。如果你是一家小公司，或者你的團隊成員都是非常資深且習慣合作的，那麼你就不需要太多的協調。另一個重要因素是變化的速度；如果你的公司在快速增長或者人員流動頻繁，或者面臨很多時間壓力或頻繁的戰略調整，你對管理人員的需求就會增加。但也有許多較小的組織在沒有太多正式管理的情況下運作得很好。&lt;/p&gt; 
&lt;p&gt;我不喜歡「開銷」這個詞，因為 a) 這有點粗魯，b) 稱管理人員為「開銷」的人通常是不尊重或不重視管理這門技藝的人。&lt;/p&gt; 
&lt;p&gt;但管理實際上確實是開銷😅。許多其他的粘合工作也是如此！這些工作很重要，但它們本身並不能推動業務向前發展；我們應該儘量只做那些絕對必要的工作。粘合工作的天然屬性使得它很容易擴散，吞噬所有可用的時間和資源（甚至更多）。&lt;/p&gt; 
&lt;p&gt;限制是好的。感覺資源不足是好的，這應該成為常態。管理很容易變得臃腫，管理人員可能非常不願意承認這一點，因為他們從來沒有感到壓力或緊張減少。（事實上，情況可能恰恰相反；臃腫的管理層可能會為管理人員帶來更多工作，而精簡的組織結構可能會讓他們反而感到壓力更小。官僚主義往往會自我發育。特別是當管理層過於關注晉升和自我時。這也是確保管理不應僅為升職或統治的又一個充分理由）&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;管理也很像運營工作，當它做得好的時候，是看不見的。評估管理人員的工作可能非常困難，尤其是在短期內，而決定何時創建或償還組織債務是一個完全不同的複雜問題，遠遠超出了這篇文章的討論範圍。&lt;/p&gt; 
&lt;p&gt;但是，是的，管理人員絕對可以成為不必要的開銷。&lt;/p&gt; 
&lt;p&gt;然而，如果你有 40 個工程師都向一個副總裁彙報，而沒有其他人專門負責人員、團隊和組織相關的工作，那麼我可以相當肯定地説，這對你來説目前不是一個問題。&lt;/p&gt; 
&lt;p&gt;&amp;lt;3&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;💡 更多資訊，請關注 Bytebase 公號：Bytebase&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                    </description>
            <link>https://my.oschina.net/u/6148470/blog/11192713</link>
            <guid isPermaLink="false">https://my.oschina.net/u/6148470/blog/11192713</guid>
            <pubDate>Mon, 27 May 2024 05:50:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>原來東子的「兄弟」是用 let 定義的「兄弟」</title>
            <description>媒體報道稱，劉強東近日在高管會上直言：「凡是長期業績不好，從來不拼搏的人，不是我的兄弟。」</description>
            <link>http://osc.cool/6SfbGh37</link>
            <guid isPermaLink="false">http://osc.cool/6SfbGh37</guid>
            <pubDate>Sun, 26 May 2024 14:10:00 GMT</pubDate>
        </item>
    </channel>
</rss>