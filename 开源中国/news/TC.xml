<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Thu, 27 Mar 2025 02:44:07 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>OpenAI 預估 2025 年營收將達到 127 億美元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-26%2Fopenai-expects-revenue-will-triple-to-12-7-billion-this-year&quot; target=&quot;_blank&quot;&gt;據彭博社今日報道&lt;/a&gt;&lt;/u&gt;，OpenAI 預估其 2025 年營收將達到 127 億美元（約合 923 億元人民幣），相比 2024 年 37 億美元（約合 269 億元人民幣）的營收翻了超三倍。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/103323_ghkE_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在該預估基礎上，OpenAI 預計其 2026 年營收將達到 294 億美元（約合 2,136.8 億元人民幣），2029 年更將超過 1,250 億美元（約合 9085.2 億元人民幣）。&lt;/p&gt; 
&lt;p&gt;報道指出，OpenAI 此前正與軟銀集團進行談判，軟銀計劃以 2600 億美元估值向 OpenAI 注資 400 億美元，部分資金將用於 OpenAI 與軟銀、甲骨文聯合成立的 Stargate 項目；此外，OpenAI 還一直在與監管機構談判，計劃從非營利組織轉變為更傳統的營利性公益公司。&lt;/p&gt; 
&lt;p&gt;產品迭代方面，&lt;a href=&quot;https://www.oschina.net/news/341240/openai-agents-sdk-mcp&quot;&gt;OpenAI 在今日凌晨對 Agent SDK 進行了重大更新&lt;/a&gt;：支持大模型上下文協議 MCP。&lt;/p&gt; 
&lt;p&gt;目前，OpenAI 已經在開源的 Agent SDK 中支持 MCP，API 和桌面版 ChatGPT 也將很快提供。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341252</guid>
            <pubDate>Thu, 27 Mar 2025 02:34:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>算力，並不是大模型廠商發展的護城河</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div&gt; 
 &lt;p&gt;上個月，OpenAI CEO 山姆·奧爾特曼在社交媒體上表示，號稱 52 萬億參數量的 GPT-5 將在數月內發佈。相較於上一代 GPT-4 的 2 萬億參數，體量上足足增長了 26 倍，雖無公佈具體的訓練成本，但想必也一定是個天文數字，堪稱大模型領域的「力大磚飛」。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//b5d3d49a58e00ea764875a0cd773ce57.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;反觀 LLM 界的「黑天鵝」，DeepSeek-V3 卻僅用了 2048 塊英偉達 H800 ，耗費了 557.6 萬美金就完成了訓練，一度引起硅谷恐慌，力證了：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;並非不可逾越的堡壘。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;一邊是暴力填鴨，一邊是技術深化，2025 年的大模型似乎走出了兩條截然不同的道路，也逐漸撕開了 AI 行業最殘酷的真相：&lt;strong&gt;早期以「&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;」建立護城河的大模型廠商們，在面對新一輪技術衝擊時，高成本的算力反而成為了其靈活發展的累贅。&lt;/strong&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_1&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;算力的必要性和侷限性&lt;/h3&gt; 
 &lt;p&gt;作為數字經濟的「新電力」，算力在大模型的訓練和推理過程中確實起到了不可或缺的作用。&lt;/p&gt; 
 &lt;p&gt;以 OpenAI 為例，早期在 GPT-4 的訓練中，大概就使用了 25000 個 A100 芯片。如果 OpenAI 雲計算的成本是差不多 1 美元/每 A100 小時的話，那麼在這樣的條件下，&lt;strong&gt;僅一次訓練的成本大約是 6300 萬美元&lt;/strong&gt;，同期還不乏實驗、試錯以及其他成本。OpenAI 的技術負責人直言：「每一次模型迭代都需要近乎天文數字的算力支撐。」&lt;/p&gt; 
 &lt;p&gt;而在推理成本方面，截至 2024 年 3 月，OpenAI 就已花費 40 億美元租用微軟的服務器集羣，該集羣相當於 35 萬個英偉達 A100 芯片，算力消耗不可謂不大。&lt;/p&gt; 
 &lt;p&gt;反觀國內，同樣印證了這一規律。2025 年初，南京智算中心聯合寒武紀，基於 7280 塊國產 AI 加速卡構建全國產化算力平台，以運行 DeepSeek 671B 大模型，在供應鏈優化、智能客服等零售場景實現毫秒級響應。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2f8b6f62899001ee832509d86ebb956b.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;南京智算中心機房，來源：南京智算中心&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;這二者的共性在於：&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;始終是&lt;/strong&gt;&lt;strong&gt;大模型&lt;/strong&gt;&lt;strong&gt;研發的「基礎設施入場券」&lt;/strong&gt;，正如 DeepSeek 技術白皮書所言：大模型的競爭，首先是算力基礎設施的競爭。&lt;/p&gt; 
 &lt;p&gt;但其實，「算力」本質上是一種「商品化」資源，自帶經濟週期屬性，隨着硬件成本的下降和雲服務的普及，算力也逐漸脫離賣方市場，一些囤貨居奇的算力廠商更是很難轉型。&lt;/p&gt; 
 &lt;p&gt;比如，2023 年 AI 大模型熱潮期間，算力需求呈爆發式增長，英偉達 H100 8 卡節點年租金峯值達到 20 萬元，而隨着大模型從訓練階段轉向推理階段，算力需求驟減（訓練需千卡級，推理僅需單卡級），2024 年 H100 8 卡節點年租金跌至 6 萬，很多中小型企業也能依靠算力租用跑步入場。&lt;/p&gt; 
 &lt;p&gt;而在算力租賃市場，截至去年，很多算力中心都出現了出租率不高、回款週期長，甚至一些底子不深的廠商直接關停一半機房，以降低日常運營成本。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//5fb3eacaa5d6decdecd8eaf02618394d.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;來源：《&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;算力&lt;/span&gt;&lt;span style=&quot;color:#8f959e&quot;&gt;荒，自主化智算還有必要嗎？》-腦極體&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;可見，大模型廠商早期在硬件性能和算力中心上的建設，雖然能夠在短期內加速模型的訓練和推理，但並不意味着競爭對手無法通過硬件設施的「經濟逆週期」，以及技術優化實現彎道超車，這就是「算力」這一大模型發展的必要資源所刻在骨子裏的侷限性。&lt;/p&gt; 
 &lt;p&gt;直至 DeepSeek 的出現，「卡多模優」的大模型發展格局，徹底失去優勢。&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_2&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;護城河的重構：從「堆料」到「四維壁壘」&lt;/h3&gt; 
 &lt;p&gt;相較於單純的硬件「堆料」，模型創新、數據規模、算法工程及生態構建的四維能力矩陣，正成為越來越多大模型廠商穿越週期的關鍵壁壘。2025 年行業數據顯示，頭部廠商研發投入中，算法優化（ 38% ）與場景化工程（ 27% ）的佔比已超過硬件採購（ 25% ），書寫新競爭法則——&lt;strong&gt;效率優先於規模。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;以 DeepSeek 為例，通過「三維創新體系」重構行業範式：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;模型層，首創「神經元動態剪枝+混合精度訓練」架構，使 1.6 萬億參數模型體積壓縮 80% ，推理速度提升 500%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;數據層，構建金融/政務領域「知識-行為-反饋」三元數據閉環，標註成本降低 65%；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;而在跟算力相關的工程層，其分佈式訓練調度系統，將千卡集羣利用率從 58% 提升至 92%。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//93414f30d7f61d6d5973d26012e11932.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;憑藉這套組合拳下來，DeepSeek 訓練成本降至同期競品的 17% ，這種「技術驅動型」增長，不僅是對思維鏈突破、數據處理、系統優化等技術的最佳詮釋，甚至使得 DeepSeek 利潤猛增。&lt;/p&gt; 
 &lt;p&gt;以行業具體實施來看。在算力的制約下，長足以來，業內很多人都不太看好 MaaS 這樣的商業模式，因為 MaaS 的核心成本是算力租賃，依賴 API 調用按 token 計費，本質上可以看作為「算力批發」——&lt;strong&gt;想要賺錢，你就得投入大量算力儲備，保證高併發和彈性伸縮，碰上 API 價格內卷，很多廠商根本負擔不起高額得硬件投入。&lt;/strong&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1ef35030fdc620a594a6096008472682.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;但隨着 DeepSeek 出現，通過大規模的並行（包括數據並行和專家並行），儘可能為每個 GPU 分配均衡的計算負載、可通信負載，以技術升級，提升算力效率。根據&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27181462601&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;《DeepSeek-V3 / R1 推理系統概括》&lt;/a&gt;一文中闡述：以 24 小時計算，DeepSeek V3 和 R1 推理服務峯值佔用總和 278 個節點，平均佔用 226.75 個節點（每個節點為 8 個 H800 GPU ）。假定 GPU 租賃成本為 2 美金/小時，日成本為 87072 美元/天。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;而對比 24 小時所輸出的 tokens 全部按照 DeepSeek R1 的定價計算，理論上一天的總收入為 562027 美元/天，成本利潤率高達 545%&lt;/strong&gt;。&lt;/p&gt; 
 &lt;p style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//92f0b2c24548560677469843c4826cc8.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;除此之外，&lt;strong&gt;開源生態&lt;/strong&gt;正加速成為模型創新的催化劑。Meta Llama 3 通過開源策略（免費使用、多平台支持）及訓練效率優化（預訓練數據擴展、後訓練技術），使中小企業模型部署成本顯著降低；智譜 GLM-4 依託 10 萬開發者社區的持續優化，在代碼生成等任務上實現同參數模型的性能超越，體現了開源協作對模型迭代的推動作用。&lt;/p&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;如此看來，這場產業革命的深層動因，不僅源於算力資源的成本週期，更源自於技術演進的內在規律：&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;供給的週期調整&lt;/strong&gt;&lt;/span&gt;：2023-2025 年全球總算力複合增長率達 147%，但單位算力成本下降曲線（年降 68%）遠超規模擴張速度，標誌着算力正從「戰略資源」向「基礎建設」加速蛻變。簡言之，算力主導的大模型經濟，難以覆蓋早期硬件設備上的成本投入；&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#e74c3c&quot;&gt;&lt;strong&gt;價值創造的路徑遷移&lt;/strong&gt;&lt;/span&gt;：算法創新對模型效能的貢獻率從 2020 年的 38% 躍升至 2025 年的 67%。例如 DeepSeek 的算法優化、理論利潤，間接證明瞭&lt;strong&gt;算法創新才能撬動&lt;/strong&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;效益，並也能實現很好的商業變現。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;站在 2025 年的時代座標回望，算力作為產業發展的「數字燃料」，已完成了它幫助早期模型廠商爬坡式發展的使命，隨着越來越多大模型應用的加速投產，模型廠商們能依仗的絕不是訓練、推理這些模型的算力規模，而是真正能讓這些算力產生乘積效應的技術創新、能力整合，以及市場洞察。&lt;/p&gt; 
 &lt;p&gt;&lt;strong&gt;算力&lt;/strong&gt;&lt;strong&gt;之爭的終局，是通過技術讓算力不再成為問題。&lt;/strong&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/7819858/blog/18015313</link>
            <guid isPermaLink="false">https://my.oschina.net/u/7819858/blog/18015313</guid>
            <pubDate>Thu, 27 Mar 2025 02:32:25 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>騰訊元寶支持實時預覽 HTML 代碼</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 26 日，首發接入 DeepSeek V3-0324 最新模型後，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FfYn2utj1aiJcuI58JuZ4zw&quot; target=&quot;_blank&quot;&gt;騰訊元寶再次發佈更新&lt;/a&gt;&lt;/u&gt;，&lt;strong&gt;支持實時預覽 HTML 代碼&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/102015_iEXO_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;目前，元寶的混元與 DeepSeek 兩大模型均支持代碼生成，覆蓋前端、腳本、數據處理等多種主流語言，適配多類開發場景，適合開發者和各類用戶快速上手。結合元寶雙模型在代碼方面的表現，也還夠幫助用戶代碼審查相關工作。&lt;/p&gt; 
&lt;p&gt;此外，使用 DeepSeek V3-0324 模型，除了網頁生成，還能完成更多類型的代碼生成任務，如生成 UI 組件、構建網頁、編寫小遊戲，甚至是生成 3D 動畫等。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;810&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/102200_dqsd_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;現在，用戶在元寶選擇 DeepSeek，並關閉「深度思考」，便可使用最新的 V3-0324。該模型在代碼生成穩定性、邏輯控制精準度和響應速度上均有明顯提升，在數學、代碼類相關評測集上取得了超過 GPT-4.5、Claude Sonnet 3.7 的得分成績。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/341137/deepseek-v3-0324-detail&quot; target=&quot;news&quot;&gt;DeepSeek 官方詳解 V3 模型「小版本」升級，各項能力全面進階&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340789/deepseek-v3-0324&quot; target=&quot;news&quot;&gt;DeepSeek V3 模型更新，大幅提升編程能力&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341248</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341248</guid>
            <pubDate>Thu, 27 Mar 2025 02:23:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>萬字長文解讀 MCP 框架，讓你掌握 mark3labs/mcp-go</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、引言&lt;/h1&gt; 
&lt;div&gt;
  在 
 &lt;a href=&quot;https://my.oschina.net/qiangmzsx/blog/17987222&quot;&gt;《萬字長文，帶你讀懂 Anthropic MCP》&lt;/a&gt;中我們介紹了 MCP 的基本框架和組件，並初步説了在 golang 中的框架 metoro-io/mcp-golang 和 mark3labs/mcp-go。本文將通過實踐和源碼的方式先解讀 mark3labs/mcp-go。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;298&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-803fb33e305fbbb839a0166e62ed0c18111.jpg&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、MCP-Server 的簡述&lt;/h1&gt; 
&lt;div&gt;
  MCP Server 一般為輕量的服務端程序，通過一種標準的協議 (MCP) 暴露出特定資源的一些特定的能力。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.1 連接生命週期&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 初始化連接&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img height=&quot;1104&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-71f5896875ced4bfcd504e32c61489dd750.png&quot; width=&quot;1250&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客戶端發送帶有協議版本和功能 initialize 請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    服務器以其協議版本和功能進行響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    客戶端發送 initialized 通知作為確認 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    開始正常信息交換 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 信息交換&lt;/h3&gt; 
&lt;div&gt;
  初始化後，支持以下模式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    請求-響應：客戶端或服務器發送請求，對方響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通知：任何一方發送單向消息 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.3 終止&lt;/h3&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}&lt;/code&gt;&lt;/pre&gt; 任何一方都可以終止連接： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通過 close() 乾淨關閉 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    傳輸斷開 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    錯誤情況 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      請求的錯誤響應 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      傳輸中的錯誤事件 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      協議級錯誤處理程序 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  常見錯誤碼： 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_7&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.2 MCP Server 的業務能力&lt;/h2&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Request Method&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發起方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;響應方&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;initialized&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;初始化會話&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;tools-list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;tools/call&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;調用工具&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的資源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/read&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;獲取資源內容&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;resources/templates&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的參數化資源&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;resources/subscribe&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;訂閲特定資源，監聽其變化事件&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;prompts/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;發現可用的提示詞&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;prompts/get&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;獲取特定提示詞&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;roots/list&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:rgba(0, 0, 0, 0.03); text-align:center; white-space:pre-wrap&quot;&gt;列出服務器有權訪問的客戶端文件系統根節點（暴露目錄和文件）&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;sampling/create&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Server&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;Client&lt;/td&gt; 
    &lt;td style=&quot;background-color:#ffffff; text-align:center; white-space:pre-wrap&quot;&gt;啓用服務器的 AI 生成能力（ sampling creation ）&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_8&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、mark3labs/mcp-go 示例&lt;/h1&gt; 
&lt;div&gt;
  我們就以框架中的官方示例代碼為引子一步步解讀流程和框架代碼。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;package main

import (
    &quot;context&quot;
    &quot;errors&quot;
    &quot;fmt&quot;

    &quot;github.com/mark3labs/mcp-go/mcp&quot;
    &quot;github.com/mark3labs/mcp-go/server&quot;
)

func main() {
    // 創建 MCP 服務器
    s := server.NewMCPServer(
       &quot;Demo 🚀&quot;, // 服務器名稱
       &quot;1.0.0&quot;,  // 服務器版本
    )

    // 添加工具
    tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名稱
       mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
       mcp.WithString(&quot;name&quot;, // 參數名稱
          mcp.Required(), // 參數是必需的
          mcp.Description(&quot;Name of the person to greet&quot;), // 參數描述
       ),
    )

    // 為工具添加處理器
    s.AddTool(tool, helloHandler)

    // 啓動標準輸入輸出服務器
    if err := server.ServeStdio(s); err != nil {
       fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服務器錯誤
    }
}

func helloHandler(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
    // 從請求參數中獲取名字參數，並斷言為字符串類型
    name, ok := request.Params.Arguments[&quot;name&quot;].(string)
    if !ok {
       // 如果斷言失敗，返回錯誤
       return nil, errors.New(&quot;name must be a string&quot;)
    }

    // 返回包含問候語的結果
    return mcp.NewToolResultText(fmt.Sprintf(&quot;Hello, %s!&quot;, name)), nil
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 搭建一個聯調環境&lt;/h2&gt; 
&lt;div&gt;
  就以上面的代碼為例，將上面的代碼編譯為二進制命令： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;$ go build -v -o server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;再啓動 mcp inspetor：&lt;/p&gt; 
 &lt;pre&gt;&lt;code&gt;$ npx -y @modelcontextprotocol/inspector ./server&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&lt;img height=&quot;701&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7c0fba487d16433005ebd394b937e30063b.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  這樣一個簡單的 MCP Client 和 MCP Server 就搭建好了，後續也為我們開發測試構建好了環境。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_10&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;四、源碼解讀&lt;/h1&gt; 
&lt;div&gt;
  在上面的代碼中 main 函數中的第一個代碼就是 server.NewMCPServer，那我們就從 MCPServer 這個結構體入手。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_11&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.1 MCPServer 結構體&lt;/h2&gt; 
&lt;div&gt;
  代碼地址：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/server.go#L135 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type MCPServer struct {
    mu                   sync.RWMutex                       // 用於保護共享資源，確保併發訪問時的數據一致性
    name                 string                             // 服務器的名稱，用於標識服務器
    version              string                             // 服務器的版本，用於跟蹤和管理服務器的不同版本
    instructions         string                             // 服務器的指令，通常在初始化響應中返回給客戶端，提供使用指南或幫助信息
    resources            map[string]resourceEntry           // 存儲服務器支持的資源及其處理函數
    resourceTemplates    map[string]resourceTemplateEntry   // 存儲資源模板及其處理函數，支持 URI 模板匹配多類似資源
    prompts              map[string]mcp.Prompt              // 存儲服務器支持的提示，用於與用戶交互
    promptHandlers       map[string]PromptHandlerFunc       // 存儲處理提示請求的函數，每個提示對應一個處理函數
    tools                map[string]ServerTool              // 存儲服務器支持的工具及其處理函數
    notificationHandlers map[string]NotificationHandlerFunc // 存儲處理傳入通知的函數，接收客戶端通知並處理
    capabilities         serverCapabilities                 // 定義服務器支持的功能特性，包括資源、提示、工具和日誌記錄等
    sessions             sync.Map                           // 存儲當前活躍的客戶端會話，用於跟蹤用戶交互
    initialized          atomic.Bool                        // 使用原子操作標記服務器是否已初始化，確保線程安全
    hooks                *Hooks                             // 存儲服務器鈎子，允許在請求處理前後或返回錯誤前執行自定義邏輯
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCPServer 是 Model Control Protocol (MCP) 服務器的實現，用於處理包括資源、提示和工具在內的各種類型的請求。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; height:30px; width:1111px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
    &lt;td style=&quot;text-align:left; white-space:pre-wrap&quot;&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_12&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style=&quot;color:#333333&quot;&gt;4.2 MCPServer 初始化&lt;/span&gt;&lt;/h2&gt; 
&lt;div&gt;
  看看如何創建一個 MCPServer 對象。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewMCPServer(
    name, version string,
    opts ...ServerOption,
) *MCPServer {
    s := &amp;amp;MCPServer{
       resources:            make(map[string]resourceEntry),
       resourceTemplates:    make(map[string]resourceTemplateEntry),
       prompts:              make(map[string]mcp.Prompt),
       promptHandlers:       make(map[string]PromptHandlerFunc),
       tools:                make(map[string]ServerTool),
       name:                 name,
       version:              version,
       notificationHandlers: make(map[string]NotificationHandlerFunc),
       capabilities: serverCapabilities{
          tools:     nil,
          resources: nil,
          prompts:   nil,
          logging:   false,
       },
    }

    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;在 NewMCPServer() 方法中，我們需要關注的 opts ...ServerOption，進一步看看 ServerOption 有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;選項&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置資源相關的服務器功能，如訂閲和資源列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithResourceCapabilities(subscribe, listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;添加鈎子函數，用於在請求處理前後執行特定邏輯&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHooks(hooks *Hooks)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置提示相關的服務器功能，如提示列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithPromptCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;配置工具相關的服務器功能，如工具列表變化通知&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithToolCapabilities(listChanged bool)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;啓用服務器日誌記錄功能&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithLogging()&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置服務器指令，用於在初始化響應中返回給客戶端&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithInstructions(instructions string)&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  它接受一個 Hooks 類型的指針作為參數。允許在創建 MCPServer 實例時，為服務器添加自定義的鈎子函數，這些鈎子函數可以在請求處理前後或返回錯誤給客戶端之前執行。 
&lt;/div&gt; 
&lt;div&gt;
  hooks 機制對開發和流程是非常有效的。框架中給的 hooks 能力有： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;字段名&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;類型&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;描述&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeAny&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]BeforeAnyHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求被解析後但方法調用前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnSuccess&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnSuccessHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求成功生成結果但結果尚未發送給客戶端之前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnError&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnErrorHookFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在請求解析或方法執行過程中發生錯誤時執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理初始化請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterInitialize&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterInitializeFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理初始化請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforePing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforePingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理 Ping 請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterPing&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterPingFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理 Ping 請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResources&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourcesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源模板請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListResourceTemplates&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListResourceTemplatesFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出資源模板請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理讀取資源請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterReadResource&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterReadResourceFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理讀取資源請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出提示請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListPrompts&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListPromptsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出提示請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理獲取提示請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterGetPrompt&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterGetPromptFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理獲取提示請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出工具請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterListTools&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterListToolsFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理列出工具請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnBeforeCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnBeforeCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理調用工具請求前執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;OnAfterCallTool&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;[]OnAfterCallToolFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;在處理調用工具請求後執行的鈎子函數。&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  現在模擬創建一個完整的 MCPServer： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;hooks := &amp;amp;server.Hooks{}

hooks.AddBeforeAny(func(id any, method mcp.MCPMethod, message any) {
    fmt.Printf(&quot;beforeAny: %s, %v, %v\n&quot;, method, id, message)
})
hooks.AddOnSuccess(func(id any, method mcp.MCPMethod, message any, result any) {
    fmt.Printf(&quot;onSuccess: %s, %v, %v, %v\n&quot;, method, id, message, result)
})
hooks.AddOnError(func(id any, method mcp.MCPMethod, message any, err error) {
    fmt.Printf(&quot;onError: %s, %v, %v, %v\n&quot;, method, id, message, err)
})
hooks.AddBeforeInitialize(func(id any, message *mcp.InitializeRequest) {
    fmt.Printf(&quot;beforeInitialize: %v, %v\n&quot;, id, message)
})
hooks.AddAfterInitialize(func(id any, message *mcp.InitializeRequest, result *mcp.InitializeResult) {
    fmt.Printf(&quot;afterInitialize: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddAfterCallTool(func(id any, message *mcp.CallToolRequest, result *mcp.CallToolResult) {
    fmt.Printf(&quot;afterCallTool: %v, %v, %v\n&quot;, id, message, result)
})
hooks.AddBeforeCallTool(func(id any, message *mcp.CallToolRequest) {
    fmt.Printf(&quot;beforeCallTool: %v, %v\n&quot;, id, message)
})
// 創建 MCP 服務器
s := server.NewMCPServer(
    &quot;Demo 🚀&quot;, // 服務器名稱
    &quot;1.0.0&quot;,  // 服務器版本
    server.WithLogging(),
    server.WithToolCapabilities(true),
    server.WithResourceCapabilities(true, true),
    server.WithPromptCapabilities(true),
    server.WithInstructions(&quot;initialized&quot;),
    server.WithHooks(hooks),
)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_13&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.3 Tools 模塊&lt;/h2&gt; 
&lt;span id=&quot;OSC_h3_14&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.1 創建 Tool&lt;/h3&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架中創建 Tool 有兩個方式： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewTool(name string, opts ...ToolOption) Tool 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    mcp.NewToolWithRawSchema(name, description string, schema json.RawMessage) Tool 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  下面通過一段代碼進行對比： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;方式一：mcp.NewTool()
tool := mcp.NewTool(&quot;hello_world&quot;, // 工具名稱
    mcp.WithDescription(&quot;Say hello to someone&quot;), // 工具描述
    mcp.WithString(&quot;name&quot;, // 參數名稱
       mcp.Required(), // 參數是必需的
       mcp.Description(&quot;Name of the person to greet&quot;), // 參數描述
    ),
)

方式二：mcp.NewToolWithRawSchema()
rawSchema := json.RawMessage(`{
    &quot;type&quot;: &quot;object&quot;,
    &quot;properties&quot;: {
       &quot;name&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Name of the person to greet&quot;}
    },
    &quot;required&quot;: [&quot;name&quot;]
}`)

// Create a tool with raw schema
toolRS := mcp.NewToolWithRawSchema(&quot;hello_world_1&quot;, &quot;Say hello to someone&quot;, rawSchema)&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中 rawSchema 的結構需要符合 ToolInputSchema 結構體：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ToolInputSchema struct {
    Type       string                 `json:&quot;type&quot;`
    Properties map[string]interface{} `json:&quot;properties,omitempty&quot;`
    Required   []string               `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;需要注意的是 Properties 來源於 jsonSchema，所以具備的需要校驗屬性，比如 default、maximum、minimum、maxLength、minLength、enum 等等。其中 key 為請求傳入的參數字段，interface{}為對 key 的各種屬性校驗。&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;更建議使用方式一：mcp.NewTool() 更加符合編碼方式，也更好控制器生成的&lt;/strong&gt; 
 &lt;strong&gt;jsonSchema&lt;/strong&gt; 
 &lt;strong&gt;。&lt;/strong&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_15&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.3.2 存放 Tool&lt;/h3&gt; 
&lt;div&gt;
  創建好 Tool 值之後，調用 server 的方法 AddTool() 將 Tool 添加進入，相當於 web 框架中的添加路由與相關 handle 的關係。相關代碼如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// AddTool registers a new tool and its handler
func (s *MCPServer) AddTool(tool mcp.Tool, handler ToolHandlerFunc) {
    s.AddTools(ServerTool{Tool: tool, Handler: handler})
}

// AddTools registers multiple tools at once
func (s *MCPServer) AddTools(tools ...ServerTool) {
    // 檢查工具
    if s.capabilities.tools == nil {
       s.capabilities.tools = &amp;amp;toolCapabilities{}
    }

    // 加鎖
    s.mu.Lock()
    // 遍歷工具
    for _, entry := range tools {
       s.tools[entry.Tool.Name] = entry
    }
    // 獲取初始化狀態
    initialized := s.initialized.Load()
    s.mu.Unlock()

    // 發送通知
    if initialized {
       s.sendNotificationToAllClients(&quot;notifications/tools/list_changed&quot;, nil)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以看出 Tool 是放入到 MCPServer 的 tools 字段中，使用 name 作為 key，ServerTool 作為 value，其中 ServerTool 結構如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ServerTool struct {
    Tool    mcp.Tool
    Handler ToolHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架還提供了：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    DeleteTools(names... string) 作為刪除 Tool 關聯的方法。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SetTools(tools ...ServerTool) 可以設置當前所有的 Tool 列表。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.4 Resource 模塊&lt;/h2&gt; 
&lt;div&gt;
  老規矩先來一個 demo，再看器源碼實現： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Static resource example - exposing a README file
resource := mcp.NewResource(
    &quot;docs://readme&quot;,
    &quot;Project README&quot;,
    mcp.WithResourceDescription(&quot;The project&#39;s README file&quot;),
    mcp.WithMIMEType(&quot;text/markdown&quot;),
)

// Add resource with its handler
s.AddResource(resource, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    content, err := os.ReadFile(&quot;main.go&quot;)
    if err != nil {
       return nil, err
    }

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      &quot;docs://readme&quot;,
          MIMEType: &quot;text/markdown&quot;,
          Text:     string(content),
       },
    }, nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在 MCP 中 Resource 是指允許 Server 公開可供客戶端讀取並用作交互上下文的數據和內容。有很多類型的 Resource： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    File contents 文件內容 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Database records 數據庫記錄 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    API responses API 響應 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Live system data 實時系統數據 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    images 圖像 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Log files 日誌文件 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    等等... ... 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  框架中 Resource 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
type Resource struct {
    Annotated // 包含可選註解，用於告知客戶端如何使用或顯示對象

    // 資源的 URI
    URI string `json:&quot;uri&quot;` // 資源的唯一標識符，用於定位和訪問資源

    // 資源的可讀名稱
    //
    // 客戶端可以使用此名稱來填充 UI 元素
    Name string `json:&quot;name&quot;` // 資源的顯示名稱，便於用戶理解和界面展示

    // 對此資源所代表內容的描述
    //
    // 客戶端可以使用此描述來幫助大型語言模型（LLM）理解可用資源
    // 這可以看作是對模型的「提示」
    Description string `json:&quot;description,omitempty&quot;` // 資源的詳細描述，為模型提供上下文信息

    // 如果已知，此資源的 MIME 類型
    MIMEType string `json:&quot;mimeType,omitempty&quot;` // 資源的媒體類型，如 text/plain、image/jpeg 等，用於指示資源的內容格式
}

type Annotated struct {
    Annotations *struct {
       // 描述此對象或數據的預期客戶是誰
       //
       // 它可以包含多個條目，以指示對多個受眾有用的內容（例如，`[&quot;user&quot;, &quot;assistant&quot;]`）
       Audience []Role `json:&quot;audience,omitempty&quot;` // 受眾羣體，指示數據對哪些角色或用戶羣體有用

       // 描述此數據對服務器操作的重要性
       //
       // 值為 1 表示「最重要」，並指示數據實際上是必需的，而 0 表示「最不重要」，並指示數據完全是可選的
       Priority float64 `json:&quot;priority,omitempty&quot;` // 優先級，表示數據對服務器操作的重要程度，範圍從 0（最不重要）到 1（最重要）
    } `json:&quot;annotations,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    URI 用於定位一個具體資源的標識，場景的有 http://、file://、postgres://等等還可以去 https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml 看看。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    MIMEType 表示文件的類型，常見的有 text/html、image/png，這裏也可以查看到更多：https://www.iana.org/assignments/media-types/media-types.xhtml。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *MCPServer) AddResource(
    resource mcp.Resource,
    handler ResourceHandlerFunc,
) {
    // 檢查資源
    if s.capabilities.resources == nil {
       s.capabilities.resources = &amp;amp;resourceCapabilities{}
    }

    // 加鎖
    s.mu.Lock()
    // 解鎖（defer）
    defer s.mu.Unlock()

    // 存儲資源
    s.resources[resource.URI] = resourceEntry{
       resource: resource,
       handler:  handler,
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;resource 是放入到 MCPServer 的 resources 字段中，使用 URI 作為 key，resourceEntry 作為 value，其中 resourceEntry 結構如下：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type resourceEntry struct {
    resource mcp.Resource
    handler  ResourceHandlerFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;框架還提供了添加 Resource templates 的功能，主要是針對動態資源，服務器可以公開 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatatracker.ietf.org%2Fdoc%2Fhtml%2Frfc6570&quot; target=&quot;_blank&quot;&gt;URI 模板 &lt;/a&gt;，客戶端可以使用它來構建有效的資源 URI。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Dynamic resource example - user profiles by ID
template := mcp.NewResourceTemplate(
    &quot;users://{id}/profile&quot;,
    &quot;User Profile&quot;,
    mcp.WithTemplateDescription(&quot;Returns user profile information&quot;),
    mcp.WithTemplateMIMEType(&quot;application/json&quot;),
)

// Add template with its handler
s.AddResourceTemplate(template, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
    // Extract ID from the URI using regex matching
    // The server automatically matches URIs to templates
    userID := extractIDFromURI(request.Params.URI)

    profile := fmt.Sprintf(&quot;Hello %s&quot;, userID) // Your DB/API call here

    return []mcp.ResourceContents{
       mcp.TextResourceContents{
          URI:      request.Params.URI,
          MIMEType: &quot;application/json&quot;,
          Text:     profile,
       },
    }, nil
})

// extractIDFromURI 從給定的 URI 中提取用戶 ID。
// 假設 URI 的格式為 &quot;users://{id}/profile&quot;。
func extractIDFromURI(uri string) string {
    // 定義正則表達式來匹配 URI 中的 ID
    re := regexp.MustCompile(`users://([^/]+)/profile`)

    // 使用正則表達式查找匹配項
    matches := re.FindStringSubmatch(uri)

    // 如果找到了匹配項，並且匹配項的數量正確，則返回 ID
    if len(matches) == 2 {
       return matches[1]
    }

    // 如果沒有找到匹配項，或者匹配項的數量不正確，則返回空字符串
    return &quot;&quot;
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.5 Prompts 添加&lt;/h2&gt; 
&lt;div&gt;
  Prompts 創建可重複使用的提示模板和工作流程，提示使服務器能夠定義可重複使用的提示模板和工作流程。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Simple greeting prompt
s.AddPrompt(mcp.NewPrompt(&quot;greeting&quot;,
    mcp.WithPromptDescription(&quot;A friendly greeting prompt&quot;),
    mcp.WithArgument(&quot;name&quot;,
       mcp.ArgumentDescription(&quot;Name of the person to greet&quot;),
    ),
), func(ctx context.Context, request mcp.GetPromptRequest) (*mcp.GetPromptResult, error) {
    name := request.Params.Arguments[&quot;name&quot;]
    if name == &quot;&quot; {
       name = &quot;friend&quot;
    }

    return mcp.NewGetPromptResult(
       &quot;A friendly greeting&quot;,
       []mcp.PromptMessage{
          mcp.NewPromptMessage(
             mcp.RoleAssistant,
             mcp.NewTextContent(fmt.Sprintf(&quot;Hello, %s! How can I help you today?&quot;, name)),
          ),
       },
    ), nil
})&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Prompt 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Prompt 表示服務器提供的提示或提示模板。
// 如果 Arguments 非空且包含元素，則表示該提示是一個模板，
// 在調用 prompts/get 時需要提供參數值。
// 如果 Arguments 為空或為 nil，則這是一個不需要參數的靜態提示。
type Prompt struct {
    // 提示或提示模板的名稱。
    Name string `json:&quot;name&quot;`
    // 提示提供內容的可選描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 用於模板化提示的參數列表。
    // 參數的存在表明這是一個模板提示。
    Arguments []PromptArgument `json:&quot;arguments,omitempty&quot;`
}

// PromptArgument 描述提示模板可以接受的參數。
// 當提示包含參數時，客戶端在發出 prompts/get 請求時
// 必須為所有必需參數提供值。
type PromptArgument struct {
    // 參數的名稱。
    Name string `json:&quot;name&quot;`
    // 參數的可讀描述。
    Description string `json:&quot;description,omitempty&quot;`
    // 此參數是否必須提供。
    // 如果為 true，則客戶端在調用 prompts/get 時必須包含此參數。
    Required bool `json:&quot;required,omitempty&quot;`
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;可以通過 mcp.NewPrompt 方法來生成 Prompt 對象：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func NewPrompt(name string, opts ...PromptOption) Prompt {
    prompt := Prompt{
       Name: name,
    }

    for _, opt := range opts {
       opt(&amp;amp;prompt)
    }

    return prompt
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;又見到了 opts ...PromptOption，看看有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithPromptDescription 用於設置 description； 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    WithArgument 用於設置 arguments； 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id=&quot;OSC_h2_18&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.6 選擇傳輸方式&lt;/h2&gt; 
&lt;div&gt;
  現在代碼已經來到了： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 啓動標準輸入輸出服務器
if err := server.ServeStdio(s); err != nil {
    fmt.Printf(&quot;Server error: %v\n&quot;, err) // 打印服務器錯誤
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;MCP 當前主要提供兩類 Stdio transport 和 HTTP with SSE transport 。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.1 Stdio&lt;/h3&gt; 
&lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;創建 StdioServer&lt;/h4&gt; 
&lt;div&gt;
  StdioServer 的結構體： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type StdioServer struct {
    server      *MCPServer
    errLogger   *log.Logger
    contextFunc StdioContextFunc
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中在，重要的字段有 server 和 contextFunc，給 MCPServer 進來就是為了具備 MCP 的能力，只是使用 stdio 的傳輸方式。contextFunc 是為了讓外部自定義的 context 可以進入到 StdioServer，可以用於結束服務和控制超時.&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;
// 為 MCP Server 啓用 stdio
func ServeStdio(server *MCPServer, opts ...StdioOption) error {
    // 創建 Stdio 服務器
    s := NewStdioServer(server)
    // 設置錯誤日誌
    s.SetErrorLogger(log.New(os.Stderr, &quot;&quot;, log.LstdFlags))

    // 應用選項
    for _, opt := range opts {
       opt(s)
    }

    // 創建上下文
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // 設置信號通道
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

    // 監聽信號
    go func() {
       &amp;lt;-sigChan
       cancel()
    }()

    // 開始監聽
    return s.Listen(ctx, os.Stdin, os.Stdout)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中最關鍵的是 Listen 方法，它是 StdioServer 類型的一個關鍵方法，用於監聽標準輸入輸出的 JSON-RPC 消息。&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// Listen 啓動監聽，從提供的輸入讀取 JSON-RPC 消息，並將響應寫入提供的輸出。
// 它將持續運行，直到上下文被取消或發生錯誤。
// 如果在讀取輸入或寫入輸出時遇到問題，將返回錯誤。
func (s *StdioServer) Listen(
    ctx context.Context, // 監聽過程的上下文，用於控制生命週期和傳遞請求範圍的信息
    stdin io.Reader, // 標準輸入流，用於讀取客戶端發送的 JSON-RPC 消息
    stdout io.Writer, // 標準輸出流，用於將響應寫回客戶端
) error {
    // 由於標準輸入輸出只有一個客戶端，因此設置一個靜態客戶端上下文，SessionId 為 stdio
    if err := s.server.RegisterSession(&amp;amp;stdioSessionInstance); err != nil {
       // 如果會話註冊失敗，返回錯誤
       return fmt.Errorf(&quot;register session: %w&quot;, err)
    }
    // 確保在函數結束時註銷會話
    defer s.server.UnregisterSession(stdioSessionInstance.SessionID())
    // 更新上下文，將會話信息加入
    ctx = s.server.WithContext(ctx, &amp;amp;stdioSessionInstance)

    // 如果存在自定義上下文函數，則應用該函數修改上下文
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx)
    }

    // 創建一個帶緩衝的讀取器，用於從標準輸入流高效讀取數據
    reader := bufio.NewReader(stdin)

    // 啓動一個協程專門處理通知
    go func() {
       for {
          select {
          case notification := &amp;lt;-stdioSessionInstance.notifications:
             // 收到通知時，調用 writeResponse 方法將通知寫入標準輸出
             err := s.writeResponse(notification, stdout)
             if err != nil {
                // 如果寫入通知時出錯，記錄錯誤日誌
                s.errLogger.Printf(&quot;Error writing notification: %v&quot;, err)
             }
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，退出協程
             return
          }
       }
    }()

    // 主循環，用於處理輸入消息
    for {
       select {
       case &amp;lt;-ctx.Done():
          // 如果上下文完成，返回上下文錯誤
          return ctx.Err()
       default:
          // 使用協程使讀取操作可取消
          readChan := make(chan string, 1) // 用於接收讀取到的行
          errChan := make(chan error, 1)   // 用於接收讀取錯誤

          go func() {
             line, err := reader.ReadString(&#39;\n&#39;) // 讀取一行輸入
             if err != nil {
                errChan &amp;lt;- err // 發送讀取錯誤
                return
             }
             readChan &amp;lt;- line // 發送讀取到的行
          }()

          select {
          case &amp;lt;-ctx.Done():
             // 如果上下文完成，返回上下文錯誤
             return ctx.Err()
          case err := &amp;lt;-errChan:
             // 處理讀取錯誤
             if err == io.EOF {
                // 如果是文件結束符，表示輸入結束，返回 nil
                return nil
             }
             // 其他錯誤則記錄日誌並返回
             s.errLogger.Printf(&quot;Error reading input: %v&quot;, err)
             return err
          case line := &amp;lt;-readChan:
             // 處理讀取到的行
             if err := s.processMessage(ctx, line, stdout); err != nil {
                // 如果處理消息時出錯
                if err == io.EOF {
                   // 如果是文件結束符，返回 nil
                   return nil
                }
                // 其他錯誤則記錄日誌並返回
                s.errLogger.Printf(&quot;Error handling message: %v&quot;, err)
                return err
             }
          }
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_21&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.2 SSE&lt;/h3&gt; 
&lt;div&gt;
  SSE 模式憑藉其分佈式能力、實時性和架構靈活性，成為 MCP 在 
 &lt;strong&gt;企業級應用、雲端協作、動態數據流處理&lt;/strong&gt;等場景的首選。所以對 SSE 的支持程度和易用程度，對於一個 MCP 框架而言是非常重要的。 
&lt;/div&gt; 
&lt;div&gt;
  mark3labs/mcp-go 如何支持 SSE 呢？看看如下代碼： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mcpServer := NewMCPServer()
sseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(&quot;http://localhost:8080&quot;))
log.Printf(&quot;SSE server listening on :8080&quot;)
if err := sseServer.Start(&quot;:8080&quot;); err != nil {
    log.Fatalf(&quot;Server error: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;現在已經知道如何在 mark3labs/mcp-go 中啓用 SSE 了，現在來分析一下，它是如何實現的。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
&lt;h4&gt;創建 SSEServer&lt;/h4&gt; 
&lt;div&gt;
  SSEServer 的結構體如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// SSEServer implements a Server-Sent Events (SSE) based MCP server.
// It provides real-time communication capabilities over HTTP using the SSE protocol.
type SSEServer struct {
    server          *MCPServer       // MCPServer 實例，用於處理實際的消息傳遞和通信邏輯
    baseURL         string           // SSE 服務器的基礎 URL，用於構建完整的端點路徑
    basePath        string           // SSE 服務器的基礎路徑，通常用於區分不同的服務或版本
    messageEndpoint string           // 消息端點的路徑，客戶端通過此端點發送 JSON-RPC 消息
    sseEndpoint     string           // SSE 端點的路徑，客戶端通過此端點建立 SSE 連接
    sessions        sync.Map         // 存儲活動 SSE 會話的同步映射，用於跟蹤和管理客戶端連接
    srv             *http.Server     // 內部的 HTTP 服務器實例，用於處理 HTTP 請求和響應
    contextFunc     SSEContextFunc   // 可選的上下文函數，用於根據請求內容自定義上下文
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;與之前的 StdioServer 相比，SSEServer 多了用於 http 中使用的 URI、path，還有 srv 這是一個 httpServer 的類型，用於支持 HTTP 請求和響應。繼續查看如何構建 SSEServer：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// NewSSEServer creates a new SSE server instance with the given MCP server and options.
func NewSSEServer(server *MCPServer, opts ...SSEOption) *SSEServer {
    s := &amp;amp;SSEServer{
       server:          server,
       sseEndpoint:     &quot;/sse&quot;,
       messageEndpoint: &quot;/message&quot;,
    }

    // Apply all options
    for _, opt := range opts {
       opt(s)
    }

    return s
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;還是採用的才是經典 Option 模式，繼續看看 SSEOption 有哪些選項：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;名稱&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;功能&lt;/td&gt; 
    &lt;td style=&quot;text-align:center; white-space:pre-wrap&quot;&gt;使用方式&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 服務器的基礎 URL&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBaseURL(&quot;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fexample.com&quot; target=&quot;_blank&quot;&gt;https://example.com&lt;/a&gt;&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 服務器的基礎路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithBasePath(&quot;/v1&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置消息端點的路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithMessageEndpoint(&quot;/custom-message&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 SSE 端點的路徑&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithSSEEndpoint(&quot;/custom-sse&quot;)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置 HTTP 服務器實例（通常用於測試或自定義服務器配置）&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithHTTPServer(customHttpServer)&lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;設置一個函數，用於根據請求內容自定義上下文&lt;/td&gt; 
    &lt;td style=&quot;white-space:pre-wrap&quot;&gt;WithContextFunc(func(ctx context.Context, r *http.Request) context.Context { ... })&lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;div&gt;
  WithHTTPServer 適用於需要自定義服務器配置的場景，為後續替換更好性能的 http 服務實例打下基礎，也體現了 mark3labs/mcp-go 擴展性。 
&lt;/div&gt; 
&lt;div&gt;
  剩下的 Start() 就是常見的啓動 http 服務實例的功能了。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) Start(addr string) error {
    s.srv = &amp;amp;http.Server{
       Addr:    addr,
       Handler: s,
    }

    return s.srv.ListenAndServe()
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;還可以調用 Shutdown() 實現對服務器的關閉。&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_23&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.6.3 集成到 gin 框架&lt;/h3&gt; 
&lt;div&gt;
  在實際開發中，很多公司內部的業務有自己的框架，集成了許許多多的獨特功能。總不能為了使用 MCP 重寫一套 Web 框架，此時就需要使用到 mark3labs/mcp-go 集成到 Web 框架的能力了。下面以 gin 框架為例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 創建一個新的 Gin 引擎
r := gin.Default()

// 創建一個新的 MCPServer 實例（假設這是 SSEServer 所需的）
mcpServer := server.NewMCPServer(&quot;gin-mcp-server&quot;, &quot;1.0.0&quot;) // 根據你的實際代碼調整
// mcpServer 新加 Tool、Resource、Prompt
// ... ...
// 創建一個新的 SSEServer 實例，並傳入 MCPServer
sseServer := server.NewSSEServer(mcpServer)

// 將 SSEServer 的 SSE 端點和處理函數集成到 Gin 路由中
r.GET(sseServer.CompleteSsePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 將 SSEServer 的消息端點和處理函數集成到 Gin 路由中
r.POST(sseServer.CompleteMessagePath(), func(c *gin.Context) {
    sseServer.ServeHTTP(c.Writer, c.Request)
})

// 啓動 Gin 服務器
if err := r.Run(&quot;localhost:8081&quot;); err != nil {
    log.Fatalf(&quot;Gin server startup failed: %v&quot;, err)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;上述的代碼會生成兩個路由：&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;table cellspacing=&quot;0&quot; style=&quot;border-collapse:collapse; border:none; table-layout:fixed; width:500px&quot;&gt; 
  &lt;tbody&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       路由 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       方法 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       作用 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       實例 
     &lt;/div&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /sse 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       GET 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         獲取 SessionID 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         接受 Server 響應 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;請求：
curl &#39;http://localhost:3000/sse?transportType=sse&amp;amp;url=http%3A%2F%2Flocalhost%3A8081%2Fsse&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; 
  
  響應：
  event: endpoint
data: /message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
   &lt;tr&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       /message 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;div&gt;
       POST 
     &lt;/div&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; 
     &lt;ul&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         使用 SessionID 保持會話 
       &lt;/div&gt; &lt;/li&gt; 
      &lt;li&gt; 
       &lt;div&gt;
         發起功能請求 
       &lt;/div&gt; &lt;/li&gt; 
     &lt;/ul&gt; &lt;/td&gt; 
    &lt;td style=&quot;border-color:#dee0e3; border-style:solid; border-width:1px; height:39px; vertical-align:top&quot;&gt; &lt;pre&gt;&lt;code&gt;請求：
curl &#39;http://localhost:3000/message?sessionId=fee6d6df-d394-4b4d-a748-fddcc73fb766&#39; \
  -H &#39;Accept: */*&#39; \
  -H &#39;Cache-Control: no-cache&#39; \
  -H &#39;Connection: keep-alive&#39; \
  -H &#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#39; \
  -H &#39;content-type: application/json&#39; 
  --data-raw &#39;{&quot;method&quot;:&quot;initialize&quot;,&quot;params&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;sampling&quot;:{},&quot;roots&quot;:{&quot;listChanged&quot;:true}},&quot;clientInfo&quot;:{&quot;name&quot;:&quot;mcp-inspector&quot;,&quot;version&quot;:&quot;0.7.0&quot;}},&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0}&#39;
 
/message 的響應：
{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}

/sse 收到的響應：
event: message
data: {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:{&quot;protocolVersion&quot;:&quot;2024-11-05&quot;,&quot;capabilities&quot;:{&quot;logging&quot;:{},&quot;prompts&quot;:{&quot;listChanged&quot;:true},&quot;resources&quot;:{&quot;subscribe&quot;:true,&quot;listChanged&quot;:true},&quot;tools&quot;:{}},&quot;serverInfo&quot;:{&quot;name&quot;:&quot;example-servers/everything&quot;,&quot;version&quot;:&quot;1.0.0&quot;}}}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;/td&gt; 
   &lt;/tr&gt; 
  &lt;/tbody&gt; 
 &lt;/table&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h2_24&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;4.7 處理請求&lt;/h2&gt; 
&lt;div&gt;
  之前的內容，解析瞭如何構建 MCP Server 的實踐和背後的實現。下面我們還需要了解 mark3labs/mcp-go 如何接受請求並進行響應的。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_25&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.1 路由入口&lt;/h3&gt; 
&lt;div&gt;
  從 SSEServer 結構體中已經知道使用的 http.Server，所以其接受請求的入口為 ServeHTTP 方法，實現了 http.Handler 接口，用於處理 HTTP 請求。根據請求的路徑，它會將請求分發到不同的處理方法（handleSSE 或 handleMessage），或者返回 404 未找到。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func (s *SSEServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 獲取請求的路徑
    path := r.URL.Path

    // 使用精確路徑匹配，而不是模糊包含
    ssePath := s.CompleteSsePath() // 獲取完整的 SSE 路徑
    if ssePath != &quot;&quot; &amp;amp;&amp;amp; path == ssePath {
       // 如果請求路徑與 SSE 路徑匹配，則處理 SSE 請求
       s.handleSSE(w, r)
       return // 處理完成後直接返回，不再繼續後續邏輯
    }

    // 獲取消息處理的完整路徑
    messagePath := s.CompleteMessagePath()
    if messagePath != &quot;&quot; &amp;amp;&amp;amp; path == messagePath {
       // 如果請求路徑與消息處理路徑匹配，則處理消息請求
       s.handleMessage(w, r)
       return // 處理完成後直接返回，不再繼續後續邏輯
    }

    // 如果請求路徑不匹配任何已知路徑，則返回 404 未找到
    http.NotFound(w, r)
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;其中：&lt;/p&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    SSE 路徑為：s.baseURL + s.basePath + s.sseEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    Message 路徑為：s.baseURL + s.basePath + s.messageEndpoint 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  這些信息都是可以在 NewSSEServer() 方法中設置。 
&lt;/div&gt; 
&lt;div&gt;
  需要詳細查看的是 s.handleSSE(w, r) 和 s.handleMessage(w, r) 方法，他們分別處理/see 和/message 的請求。 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h3_26&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;4.7.2 handleSSE&lt;/h3&gt; 
&lt;div&gt;
  handleSSE 實現了一個處理服務器發送事件（SSE）的 HTTP 處理器。SSE 是一種允許服務器向客戶端發送自動更新的技術。主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;請求方法檢查&lt;/strong&gt;：只允許 GET 請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;設置響應頭&lt;/strong&gt;：設置適當的 SSE 響應頭。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;創建會話&lt;/strong&gt;：為每個客戶端創建一個新的 SSE 會話。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;註冊和註銷會話&lt;/strong&gt;：在服務器中註冊會話，並在處理完成後註銷。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;通知處理器&lt;/strong&gt;：啓動一個 goroutine 處理來自通知通道的事件，並將其發送到客戶端。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;主事件循環&lt;/strong&gt;：處理來自事件隊列的事件，並將其發送到客戶端。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 它設置適當的頭信息併為客戶端創建一個新的會話。
func (s *SSEServer) handleSSE(w http.ResponseWriter, r *http.Request) {
    // 1. 檢查請求方法是否為 GET，如果不是，返回 405 Method Not Allowed 錯誤
    if r.Method != http.MethodGet {
       http.Error(w, &quot;Method not allowed&quot;, http.StatusMethodNotAllowed)
       return
    }

    // 2. 設置 SSE 相關的響應頭
    w.Header().Set(&quot;Content-Type&quot;, &quot;text/event-stream&quot;) // 設置內容類型為 text/event-stream
    w.Header().Set(&quot;Cache-Control&quot;, &quot;no-cache&quot;)         // 禁用緩存
    w.Header().Set(&quot;Connection&quot;, &quot;keep-alive&quot;)          // 保持連接活躍
    w.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)  // 允許所有域跨域請求

    // 檢查 ResponseWriter 是否支持 Flush，如果不支持，返回 500 Internal Server Error 錯誤
    flusher, ok := w.(http.Flusher)
    if !ok {
       http.Error(w, &quot;Streaming unsupported&quot;, http.StatusInternalServerError)
       return
    }

    // 3. 創建一個新的會話 ID 和會話對象
    sessionID := uuid.New().String() // 生成唯一的會話 ID
    session := &amp;amp;sseSession{
       writer:              w,                          // 響應寫入器
       flusher:             flusher,                    // 刷新器
       done:                make(chan struct{}),        // 用於通知會話結束的通道
       eventQueue:          make(chan string, 100),     // 事件隊列，緩衝區大小為 100
       sessionID:           sessionID,                  // 會話 ID
       notificationChannel: make(chan mcp.JSONRPCNotification, 100), // 通知通道，緩衝區大小為 100
    }

    // 4. 將會話存儲到會話存儲中，並在處理完成後刪除
    s.sessions.Store(sessionID, session)
    defer s.sessions.Delete(sessionID)

    // 在服務器中註冊會話，如果註冊失敗，返回 500 Internal Server Error 錯誤
    if err := s.server.RegisterSession(session); err != nil {
       http.Error(w, fmt.Sprintf(&quot;Session registration failed: %v&quot;, err), http.StatusInternalServerError)
       return
    }
    // 在處理完成後註銷會話
    defer s.server.UnregisterSession(sessionID)

    // 5. 啓動一個 goroutine 處理通知通道中的事件
    go func() {
       for {
          select {
          case notification := &amp;lt;-session.notificationChannel: // 從通知通道接收通知
             eventData, err := json.Marshal(notification) // 將通知序列化為 JSON
             if err == nil {
                select {
                case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData): // 將事件發送到事件隊列
                   // 事件成功入隊
                case &amp;lt;-session.done: // 如果會話結束，退出 goroutine
                   return
                }
             }
          case &amp;lt;-session.done: // 如果會話結束，退出 goroutine
             return
          case &amp;lt;-r.Context().Done(): // 如果請求上下文被取消，退出 goroutine
             return
          }
       }
    }()

    // 生成消息端點 URL 併發送初始的 endpoint 事件
    messageEndpoint := fmt.Sprintf(&quot;%s?sessionId=%s&quot;, s.CompleteMessageEndpoint(), sessionID)
    fmt.Fprintf(w, &quot;event: endpoint\ndata: %s\r\n\r\n&quot;, messageEndpoint) // 發送 endpoint 事件
    flusher.Flush() // 刷新響應，確保事件立即發送到客戶端

    // 6. 主事件循環，運行在 HTTP 處理器 goroutine 中
    for {
       select {
       case event := &amp;lt;-session.eventQueue: // 從事件隊列接收事件
          fmt.Fprint(w, event) // 將事件寫入響應
          flusher.Flush()      // 刷新響應，確保事件立即發送到客戶端
       case &amp;lt;-r.Context().Done(): // 如果請求上下文被取消，關閉會話並退出
          close(session.done)
          return
       }
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;第三階段又看到 Session 了，與之前的 stdioSession 相比，sseSession 明顯複雜多了，它們都實現接口 ClientSession：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type ClientSession interface {
    // NotificationChannel provides a channel suitable for sending notifications to client.
    NotificationChannel() chan&amp;lt;- mcp.JSONRPCNotification
    // SessionID is a unique identifier used to track user session.
    SessionID() string
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;sseSession 是專門用於表示一個基於服務器發送事件（Server-Sent Events, SSE）協議的活躍連接。sseSession 負責管理客戶端與服務器之間的單向實時數據推送，並保持會話。其結構體如下：&lt;/p&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;type sseSession struct {
    writer              http.ResponseWriter // HTTP 響應寫入器，用於向客戶端發送數據
    flusher             http.Flusher       // HTTP 刷新器，用於刷新響應緩衝區，確保數據立即發送給客戶端
    done                chan struct{}      // 用於通知會話結束的通道
    eventQueue          chan string        // 用於排隊事件的通道，存儲待發送給客戶端的事件
    sessionID           string             // 會話的唯一標識符
    notificationChannel chan mcp.JSONRPCNotification // 用於接收 JSON-RPC 通知的通道
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_27&quot;&gt;&lt;/span&gt; 
 &lt;h3&gt;4.7.3 handleMessage&lt;/h3&gt; 
&lt;/div&gt; 
&lt;div&gt;
  handleMessage 方法是 SSEServer 類型的一個方法，用於處理傳入的 JSON-RPC 消息，並通過 SSE 連接和 HTTP 響應返回結果。其主要流程： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    請求驗證：檢查請求方法 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      檢查請求方法：方法首先檢查請求方法是否為 HTTP POST。如果不是，返回 &quot;Method not allowed&quot; 錯誤，並終止處理。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      驗證 sessionId 參數：從請求的 URL 查詢參數中獲取 sessionId。如果缺失，返回 &quot;Missing sessionId&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      加載會話：使用 sessionId 從會話存儲中加載會話。如果會話不存在，返回 &quot;Invalid session ID&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    設置上下文 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      調用 s.server.WithContext 方法，將請求上下文和會話信息合併，生成新的上下文。如果提供了 contextFunc，則進一步處理上下文。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    解析 JSON-RPC 消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      使用 json.NewDecoder 解析請求體中的原始 JSON 消息。如果解析失敗，返回 &quot;Parse error&quot; 錯誤。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理消息 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將解析後的消息傳遞給 s.server.HandleMessage 方法進行處理，並獲取響應結果。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    發送響應 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 返回了響應（非通知），則： 
  &lt;/div&gt; 
  &lt;div&gt;
    &amp;nbsp;&amp;nbsp;如果 HandleMessage 沒有返回響應（通知），則僅設置 HTTP 響應狀態碼為 202 Accepted，不發送響應體。 
  &lt;/div&gt; 
  &lt;ol&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將響應編碼為 JSON 格式。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      將響應事件加入會話的事件隊列，供 SSE 連接發送。 
    &lt;/div&gt; &lt;/li&gt; 
   &lt;li&gt; 
    &lt;div&gt;
      設置 HTTP 響應頭為 application/json，狀態碼為 202 Accepted，併發送響應體。 
    &lt;/div&gt; &lt;/li&gt; 
  &lt;/ol&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    事件隊列處理 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  嘗試將事件加入會話的事件隊列。如果隊列已滿或會話已關閉，則丟棄事件。 
&lt;/div&gt; 
&lt;div&gt;
  那麼 handleSSE 和 handleMessage 的關係是怎樣的呢？使用一張圖來説明： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img height=&quot;729&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7cab372d06266dac5b06a8959d2df0382ea.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// handleMessage 處理來自客戶端的 JSON-RPC 消息，並通過 SSE 連接和 HTTP 響應返回結果
func (s *SSEServer) handleMessage(w http.ResponseWriter, r *http.Request) {
    // 1. 如果請求方法不是 POST，則返回 JSON-RPC 錯誤響應，表示方法不允許
    if r.Method != http.MethodPost {
       s.writeJSONRPCError(w, nil, mcp.INVALID_REQUEST, &quot;Method not allowed&quot;)
       return
    }

    // 從請求的 URL 查詢參數中獲取 sessionId
    sessionID := r.URL.Query().Get(&quot;sessionId&quot;)
    // 如果 sessionId 為空，則返回 JSON-RPC 錯誤響應，表示缺少 sessionId 參數
    if sessionID == &quot;&quot; {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Missing sessionId&quot;)
       return
    }

    // 從 session 存儲中加載與 sessionId 對應的 session
    sessionI, ok := s.sessions.Load(sessionID)
    // 如果 session 不存在，則返回 JSON-RPC 錯誤響應，表示無效的 session ID
    if !ok {
       s.writeJSONRPCError(w, nil, mcp.INVALID_PARAMS, &quot;Invalid session ID&quot;)
       return
    }
    session := sessionI.(*sseSession)

    // 在處理消息之前設置客戶端上下文
    ctx := s.server.WithContext(r.Context(), session)
    // 如果提供了自定義的上下文函數，則應用它
    if s.contextFunc != nil {
       ctx = s.contextFunc(ctx, r)
    }

    // 將請求體解析為原始 JSON 消息
    var rawMessage json.RawMessage
    if err := json.NewDecoder(r.Body).Decode(&amp;amp;rawMessage); err != nil {
       // 如果解析失敗，則返回 JSON-RPC 錯誤響應，表示解析錯誤
       s.writeJSONRPCError(w, nil, mcp.PARSE_ERROR, &quot;Parse error&quot;)
       return
    }

    // 通過 MCPServer 處理消息
    response := s.server.HandleMessage(ctx, rawMessage)

    // 如果存在響應（非通知），則發送響應
    if response != nil {
       // 將響應編碼為 JSON 格式
       eventData, _ := json.Marshal(response)

       // 將事件排隊以通過 SSE 發送
       select {
       case session.eventQueue &amp;lt;- fmt.Sprintf(&quot;event: message\ndata: %s\n\n&quot;, eventData):
          // 事件成功排隊
       case &amp;lt;-session.done:
          // 會話已關閉，不嘗試排隊
       default:
          // 隊列已滿，可以記錄此情況
       }

       // 發送 HTTP 響應
       w.Header().Set(&quot;Content-Type&quot;, &quot;application/json&quot;)
       w.WriteHeader(http.StatusAccepted)
       json.NewEncoder(w).Encode(response)
    } else {
       // 對於通知，只發送 202 Accepted 狀態碼，無響應體
       w.WriteHeader(http.StatusAccepted)
    }
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div&gt;
  需要注意的是 HandleMessage 方法，這是通過 server/internal/gen/request_handler.go.tmpl 生成的，也根據 MCP 協議實現的模版，其流程如下： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    嘗試將原始消息解析為對應請求類型。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果解析失敗，記錄錯誤信息。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    執行請求前的鈎子函數。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    調用對應的處理函數處理請求。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    如果處理過程中發生錯誤，執行錯誤鈎子函數並返回錯誤響應。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    執行請求後的鈎子函數。 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    返回成功響應。 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  以 initialize 請求為例： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// 根據消息方法進行分情況處理
switch baseMessage.Method {
// 初始化請求處理
case mcp.MethodInitialize:
    var request mcp.InitializeRequest
    var result *mcp.InitializeResult
    // 嘗試將原始消息解析為初始化請求類型
    if unmarshalErr := json.Unmarshal(message, &amp;amp;request); unmarshalErr != nil {
       // 如果解析失敗，記錄錯誤信息
       err = &amp;amp;requestError{
          id:   baseMessage.ID,
          code: mcp.INVALID_REQUEST,
          err:  &amp;amp;UnparseableMessageError{message: message, err: unmarshalErr, method: baseMessage.Method},
       }
    } else {
       // 執行初始化請求前的鈎子函數
       s.hooks.beforeInitialize(baseMessage.ID, &amp;amp;request)
       // 處理初始化請求
       result, err = s.handleInitialize(ctx, baseMessage.ID, request)
    }
    // 如果處理過程中發生錯誤
    if err != nil {
       // 執行錯誤鈎子函數
       s.hooks.onError(baseMessage.ID, baseMessage.Method, &amp;amp;request, err)
       // 返回錯誤響應
       return err.ToJSONRPCError()
    }
    // 執行初始化請求後的鈎子函數
    s.hooks.afterInitialize(baseMessage.ID, &amp;amp;request, result)
    // 返回成功響應
    return createResponse(baseMessage.ID, *result)

// 其他方法處理邏輯類似，省略...

// 如果方法不匹配任何已知方法，返回方法未找到錯誤響應
default:
    return createErrorResponse(
       baseMessage.ID,
       mcp.METHOD_NOT_FOUND,
       fmt.Sprintf(&quot;Method %s not found&quot;, baseMessage.Method),
    )
}&lt;/code&gt;&lt;/pre&gt; 
 &lt;p&gt;代碼比較多，可以自行查看：https://github.com/mark3labs/mcp-go/blob/e183dd17cfec07072a188f6169033bf61f7bf37d/server/request_handler.go#L12&lt;/p&gt; 
&lt;/div&gt; 
&lt;span id=&quot;OSC_h1_28&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;五、總結&lt;/h1&gt; 
&lt;div&gt;
  mark3labs/mcp-go 框架是一個簡單易用的 MCP 框架，基本上實現了 MCP 協議，提供對 MCP 核心規範的完整支持，包括資源（Resources）、工具（Tools）、提示（Prompts）等核心組件，確保與主流 LLM 客戶端（如 Claude、Cline）的兼容性。尤其是 mark3labs/mcp-go 提供的 hooks 機制，可以讓開發者更好的使用類似 gin 空間一樣的中間件能力，比如實現統一鑑權等能力。除此之外，還可以與主流的 Web 框架，如 gin 框架進行集成，進一步擴展了 mark3labs/mcp-go 的適用性。 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/qiangmzsx/blog/18014540</link>
            <guid isPermaLink="false">https://my.oschina.net/qiangmzsx/blog/18014540</guid>
            <pubDate>Thu, 27 Mar 2025 02:15:25 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>阿里通義千問開源端到端多模態模型 Qwen2.5-Omni</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;3 月 27 日，通義千問&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqwenlm.github.io%2Fzh%2Fblog%2Fqwen2.5-omni%2F&quot; target=&quot;_blank&quot;&gt;宣佈推出&lt;/a&gt;&lt;/u&gt;新一代端到端多模態旗艦模型 Qwen2.5-Omni。該模型現已在 Hugging Face、ModelScope、DashScope 和 GitHub 上開源開放。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e620efb7beda14c716812fb6f4a8ed2f17f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Qwen2.5-Omni 是一種端到端多模態模型，旨在感知各種模態，包括文本，圖像，音頻和視頻，同時以流式方式生成文本和自然語音響應。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;關鍵特點&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Omni 和新穎的架構：我們提出 Thinker-Talker 架構，這是一種端到端多模態模型，旨在感知各種模式，包括文本，圖像，音頻和視頻，同時以流式方式生成文本和自然語音響應。 我們提出了一種新的位置嵌入，稱為 TMRoPE (時間對齊多模態 RoPE), 以將視頻輸入的時間戳與音頻同步。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;實時語音和視頻聊天：專為完全實時交互而設計的架構，支持分塊輸入和即時輸出。&lt;/li&gt; 
 &lt;li&gt;自然和強大的語音生成：超越許多現有的流媒體和非流媒體替代方案，在語音生成中表現出卓越的魯棒性和自然性。&lt;/li&gt; 
 &lt;li&gt;跨模式的強大性能：在與類似規模的單模式模型進行基準測試時，在所有模式中表現出卓越的性能。 Qwen2.5-Omni 在音頻功能方面優於類似尺寸的 Qwen2-Audio, 並實現與 Qwen2.5-VL-7B 相當的性能。&lt;/li&gt; 
 &lt;li&gt;優秀的端到端語音指令：Qwen2.5-Omni 在端到端語音指令中表現出性能，這與文本輸入的有效性相媲美，MMLU 和 GSM8K 等基準測試就證明瞭這一點。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;模型架構&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8eac4f9ca743454cd238cfa11a6319f1710.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-ac3ad0960351e7733a1cfb5cabf05690d01.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型下載&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;目前只開源了 7B 尺寸的模型&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2FQwen%2FQwen2.5-Omni-7B&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/Qwen/Qwen2.5-Omni-7B&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341243/qwen2-5-omni-7b</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341243/qwen2-5-omni-7b</guid>
            <pubDate>Thu, 27 Mar 2025 02:12:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI Agents SDK 已支持大模型上下文協議 MCP</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;OpenAI &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAIDevs%2Fstatus%2F1904957755829481737&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;其智能體——OpenAI Agents SDK 已支持大模型上下文協議 MCP，並表示稱&lt;strong&gt;正在為 OpenAI API 和 ChatGPT 桌面應用程序開發 MCP 支持&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height=&quot;1052&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0327/095628_d79a_2720166.png&quot; width=&quot;1278&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0327/100304_ckel_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;OpenAI Agents SDK 支持 MCP 對於開發複雜的智能體具有巨大幫助。例如，在開發一個需要同時進行文件處理、數據查詢和網絡信息收集的智能體時，開發者可以通過 MCP 服務器分別集成文件系統工具、數據庫查詢工具和網絡爬蟲工具，更高效地完成任務。&lt;/p&gt; 
&lt;p&gt;參考文檔&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fopenai.github.io%2Fopenai-agents-python%2Fmcp%2F&quot; target=&quot;_blank&quot;&gt;https://openai.github.io/openai-agents-python/mcp/&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenai%2Fopenai-agents-python&quot; target=&quot;_blank&quot;&gt;https://github.com/openai/openai-agents-python&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341240/openai-agents-sdk-mcp</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341240/openai-agents-sdk-mcp</guid>
            <pubDate>Thu, 27 Mar 2025 02:04:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>張一鳴登頂中國首富</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 27 日，彭博億萬富豪指數及福布斯富豪榜均顯示，字節跳動創始人張一鳴登頂中國富豪榜榜首，成為中國首富。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;福布斯預估張一鳴身家為 655 億美元（約合 4760.67 億元人民幣），在全球富豪榜位列第 23 位，馬化騰與鍾睒睒分別以 535 億美元、531 億美元的身家分列富豪榜第 27 和 28 位。彭博億萬富豪指數預估張一鳴身家為 575 億美元，位居全球富豪榜第 24 位，馬化騰和鍾睒睒分列第 25 和 26 位。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另外根據彭博億萬富豪指數，張一鳴目前是亞洲第三大富豪，僅次於印度的 Mukesh Ambani 和 Gautam Adani。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;309&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-63eb3fc9dc2e64506bf7afcc27af90e9d51.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341239</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341239</guid>
            <pubDate>Thu, 27 Mar 2025 02:00:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>商湯科技：2024 年生成式 AI 收入佔比達 63.7%</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商湯集團&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FPBkhEy84piWtkBHwY8nDYA&quot; target=&quot;_blank&quot;&gt;發佈&lt;/a&gt;截至 2024 年 12 月 31 日經審核全年業績。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年，商湯集團總體收入同比增長 10.8%，達到 37.7 億元人民幣；其中，生成式 AI 業務收入突破 24 億元，同比大幅增長 103.1%，這是生成式 AI 連續兩年保持三位數增速，佔總收入比例進一步提升至 63.7%，已成為集團最大業務。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年集團毛利為 16.2 億元人民幣，毛利率為 42.9%，虧損同比收窄 33.7%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;商湯集團董事會執行主席兼首席執行官徐立博士表示：「大模型算法與基礎設施軟件系統的聯合優化已成為生成式 AI 飛速發展的核心驅動力。商湯秉承的‘大裝置-大模型-應用’三位一體、聯合優化的戰略與此趨勢契合，正在迎來高速發展階段。商湯以‘1+X’組織架構重組推動資源的戰略聚焦，以可持續增長與盈利能力為核心，增強商湯作為行業標杆的競爭力。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;3808&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-60709661fa23c67ebe39f9c529b30ba38ec.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341237</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341237</guid>
            <pubDate>Thu, 27 Mar 2025 01:56:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>英偉達正在洽談收購賈揚清創業公司 Lepton AI</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theinformation.com%2Farticles%2Fnvidia-nears-deal-buy-gpu-reseller-several-hundred-million-dollars&quot; target=&quot;_blank&quot;&gt;根據 The Information 的報道&lt;/a&gt;&lt;/u&gt;，英偉達即將收購成立兩年的 AI 創業公司 Lepton AI。據稱這筆交易的金額達數億美元。&lt;/p&gt; 
&lt;p&gt;Lepton AI 創始人賈揚清是開源深度學習框架 Caffe 創始人、TensorFlow 作者之一、也是 PyTorch 1.0 的共同創始人。他在創立 Lepton AI 之前在阿里巴巴擔任技術副總裁。&lt;/p&gt; 
&lt;p&gt;2023 年 3 月，賈揚清離職創立了 Lepton AI，主做 AI 底層架構方向的事情，希望通過產品的方式來降低 AI 應用開發的門檻，幫助開發者更容易地完成創建、部署和擴展任務。&lt;/p&gt; 
&lt;p&gt;2023 年 5 月，Lepton AI 完成了首輪天使輪融資，由 Fusion Fund 基金和 CRV 風投兩家機構投資。創始團隊成員還包括 ONNX 的聯合創始人以及 etcd 的創始人。&lt;/p&gt; 
&lt;p&gt;成立至今，Lepton AI 主要發佈了兩款產品：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;FastGPU：2024 年 6 月上線的雲 GPU 解決方案，主打經濟高效和可靠。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Lepton Search：2023 年 12 月推出的對話式搜索引擎，基於 Lepton AI 平台實現，代碼量不到 500 行。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Lepton AI 的基本思路是提供大模型訓練、部署和應用時所需的基礎設施，諸如提供 Python SDK 和雲計算平台，支持 HuggingFace 模型集成和從 GitHub 倉庫創建 AI 模型，以降低了 AI 應用開發的門檻。&lt;/p&gt; 
&lt;p&gt;而 NVIDIA 目前也正致力於擴展其 AI 能力和基礎設施，為其客戶更全面的解決方案。這是促成此次收購的核心戰略邏輯。&lt;/p&gt; 
&lt;p&gt;英偉達正感受到來自其最大客戶——主要雲服務提供商，如亞馬遜和谷歌的壓力，這些客戶試圖通過開發和低價租賃替代芯片來削弱英偉達的市場地位，因此英偉達考慮進行多元化發展，直接下場做 Lepton AI 做的事情。&lt;/p&gt; 
&lt;p&gt;Lepton AI 的一個主要競爭對手是 Together AI，這同樣是一家初創公司，儘管僅比 Lepton AI 早成立一年左右，但已籌集了超過 5 億美元的風險投資。另外還有一個競爭對手是 Fireworks，由前 Meta PyTorch 團隊成員創立，去年完成了 B 輪融資，英偉達也有參與跟投。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340005/nvidia-gretel-acquisition-synthetic-training-data&quot; target=&quot;news&quot;&gt;英偉達收購合成數據初創公司 Gretel&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/287935&quot; target=&quot;news&quot;&gt;賈揚清評價李彥宏對大模型行業趨勢的預測：非常對&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/276738/search-with-lepton-opensource&quot; target=&quot;news&quot;&gt;賈揚清最新開源項目 —— 500 行代碼構建的 AI 搜索工具&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341235</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341235</guid>
            <pubDate>Thu, 27 Mar 2025 01:47:25 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>中國 AIGC APP 月活 TOP10 出爐：DeepSeek 第一、豆包第二</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fl4_g0dgHMu0g9E2AEbRLfw&quot; target=&quot;_blank&quot;&gt;QuestMobile 數據顯示&lt;/a&gt;&lt;/u&gt;，截止 2025 年 1 月，全網用戶月人均使用時長提升至 171.4 小時，增速放緩，人均使用次數及 APP 個數分別達到 2487.9 次和 28.7 個，趨於穩定。其中，數量、時長同比均微增，但是次數同比出現了罕見的下降。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;582&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/192553_3GKs_2720166.png&quot; width=&quot;960&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;2025 年 1 月，月活躍用戶增長榜單中，AIGC、智能家居、用車服務等領域同比分別增長了 244.7%、16.7%、20.8%；相比之下，兩年前的 2023 年 1 月，月活躍用戶增長較快的領域分別為綜合電商、手機銀行、效率辦公、益智休閒遊戲等領域，增速分別為 12.1%、18.4%、22.9%、57.5%。&lt;/p&gt; 
&lt;p&gt;QuestMobile 數據顯示，2025 年 1 月，AIGC APP 行業月活躍用戶規模同比增長率高達 244.7%，淨增量超 9200 萬，領跑移動互聯網行業。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/192740_XN38_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;隨着 AI 大模型的不斷升級，深度思考和推理能力顯著提升，AIGC 已成為全網增速最快賽道，&lt;strong&gt;DeepSeek APP 上線次月活躍用戶規模突破 1.8 億，豆包 APP 破億，騰訊元寶、納米 AI 搜索在 DeepSeek 大模型加持下，躋身 TOP5&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/192702_SJHe_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/192719_cAAX_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;QuestMobile 數據顯示，納米 AI 搜索、騰訊元寶 APP 在接入 DeepSeek 大模型後日活躍用戶規模提升顯著，其中，騰訊元寶 APP 在接入大模型 11 天后日活躍用戶規模突破 500 萬，納米 AI 搜索 2 月日活峯值達 384.8 萬。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341168</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341168</guid>
            <pubDate>Sat, 22 Mar 2025 11:28:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>worth-calculator —— 計算「這班上得值不值」的開源項目</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                            &lt;p&gt;worth-calculator 是一個工作性價比計算器，通過一系列計算公式，計算出我們當前工作的性價比分數，看到底 「值不值得」 上這個（B）班。&lt;/p&gt;

&lt;p&gt;具體能算以下幾項信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;nbsp;到手工資: 基於年薪和實際工作天數算出真實日薪。&lt;/li&gt;
&lt;li&gt;時間成本: 上班時長、通勤時間、各種假期都考慮進去了。&lt;/li&gt;
&lt;li&gt;&amp;nbsp;工作環境: 從工位到同事，全方位評估。&lt;/li&gt;
&lt;li&gt;最終結果: 給你一個直觀的參考指標。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;結果評判標準：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;😱 低於 1.0：很慘&lt;/li&gt;
&lt;li&gt;😐 1.0-1.8：一般&lt;/li&gt;
&lt;li&gt;😎 1.8-2.5：很爽&lt;/li&gt;
&lt;li&gt;🤩 高於 2.5：爽到爆炸&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;運行效果&lt;/p&gt;

&lt;p&gt;&lt;img height=&quot;3494&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/185439_kGZz_2720166.png&quot; width=&quot;1862&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/185507_bxX6_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/worth-calculator</link>
            <guid isPermaLink="false">https://www.oschina.net/p/worth-calculator</guid>
            <pubDate>Sat, 22 Mar 2025 11:07:00 GMT</pubDate>
        </item>
        <item>
            <title>讓 AI 評審代碼！Gitee Code MCP 幫你高效完成 PR Review</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;還在為開發寫的「屎山」代碼發愁？&lt;/p&gt; 
&lt;p&gt;還在為每天 Review 不完的代碼苦惱？&lt;/p&gt; 
&lt;p&gt;每次看完代碼卻不知道怎麼評論合適？&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;今天馬建倉繼續帶着 Gitee Code MCP 走來了！&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;馬建倉今天將帶你體驗 Gitee Code MCP + Cursor 的完整實踐流程，並展示 AI 在&lt;code&gt;代碼審核&lt;/code&gt;、&lt;code&gt;優化建議&lt;/code&gt;、&lt;code&gt;自動合併&lt;/code&gt;環節的強大能力。&lt;/p&gt; 
&lt;p&gt;把代碼託管簡單化，把 PR Review 敏捷化，用 Gitee Code MCP 把 PR Review 的煩惱統統搞定！&lt;/p&gt; 
&lt;h1&gt;01 快速上手：配置 Gitee Code MCP&lt;/h1&gt; 
&lt;p&gt;在開始之前，要先擁有屬於自己的 Gitee DevOps 旗艦版賬號，並創建私人令牌（僅需&lt;code&gt;接口操作&lt;/code&gt;和&lt;code&gt;代碼庫&lt;/code&gt;、&lt;code&gt;代碼組&lt;/code&gt;權限）。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182107_e4mQ_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下載並編譯 Gitee Code MCP Server，可選擇&lt;code&gt;Docker&lt;/code&gt;或&amp;nbsp;&lt;code&gt;Node&lt;/code&gt;方式運行。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Docker build 編譯：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;docker build -t gitee-mcp:latest -f Dockerfile .&amp;nbsp;&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;Npm 安裝依賴，使用 node 運行：&lt;/li&gt; 
&lt;/ul&gt; 
&lt;pre&gt;&lt;code&gt;npm install&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;在 Cursor 中安裝使用 MCP&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182139_sUUi_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;配置 MCP Server&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;以 Docker 方式運行 MCP Server：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;&quot;mcpServers&quot;: {
&amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;mcp_server_gitee&quot;: {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;command&quot;:&amp;nbsp;&quot;docker&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;args&quot;: [
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;run&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;--rm&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;-i&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;-e&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_PERSONAL_ACCESS_TOKEN&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;-e&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_API_URL&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;gitee-mcp:latest&quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;env&quot;: {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_PERSONAL_ACCESS_TOKEN&quot;:&amp;nbsp;&quot;個人令牌&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_API_URL&quot;:&amp;nbsp;&quot;http://xxx.gitee.work/api/v8&quot;&amp;nbsp;// V8 接口
&amp;nbsp; &amp;nbsp; &amp;nbsp; },
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;disabled&quot;:&amp;nbsp;false,
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;autoApprove&quot;: []
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;以 Node 方式運行 MCP Server：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;{
&amp;nbsp;&amp;nbsp;&quot;mcpServers&quot;: {
&amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;gitee_mcp&quot;: {
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;command&quot;:&amp;nbsp;&quot;node&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;args&quot;: [
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;mcp 代碼目錄/build/index.js&quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; ],
&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;env&quot;: {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_PERSONAL_ACCESS_TOKEN&quot;:&amp;nbsp;&quot;個人令牌&quot;,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&quot;GITEE_API_URL&quot;:&amp;nbsp;&quot;http://xxx.gitee.work/api/v8&quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;出現彈窗後，無需關閉，查看 MCP Server 顯示為綠色即為成功運行。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182208_c2r1_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;打開新的聊天窗口，設置為 Agent 聊天。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182219_BpD2_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;至此環境配置完成，接下來讓我們看看 Gitee Code MCP 如何，智能化提升 PR Review 體驗。&lt;/p&gt; 
&lt;h1&gt;02 AI 賦能 PR Review：高效應對三大評審場景&lt;/h1&gt; 
&lt;h2&gt;「屎山」代碼？快速駁回！&lt;/h2&gt; 
&lt;p&gt;面對團隊中堆積如山的 PR，逐個手動檢查不僅低效，還可能遺漏關鍵問題。Gitee Code MCP 可以直接獲取代碼倉庫中的所有待審 PR，快速呈現變更內容，並智能分析代碼質量，幫助開發者精準識別可能存在的問題。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;獲取代碼倉庫&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182245_vg10_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這時 Gitee Code MCP 會把想要查的倉庫展示出來。如果想知道這個倉庫裏當前有哪些 PR 沒處理的，同樣可以讓 Gitee Code MCP 列出來：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182259_ahK3_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;分析 PR 很累？不用擔心，Gitee Code MCP 可以幫你一鍵 Review：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182317_cprc_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;讓我們再回到 Gitee Code 上看一看：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182334_8utO_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;神級代碼？照樣鋭評！&lt;/h2&gt; 
&lt;p&gt;即便是經驗豐富的開發者，寫出了看起來十分完美的代碼，也難免在代碼優化上有所疏漏。&lt;/p&gt; 
&lt;p&gt;Gitee Code MCP 不僅能識別問題代碼，還能提供優化建議，幫助團隊提升整體代碼質量：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182349_ch25_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;我們可以在 Gitee Code 的 PR 詳情中看到 AI 具體説了什麼。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182402_676Y_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;無可挑剔，輕鬆合併！&lt;/h2&gt; 
&lt;p&gt;當代碼通過審核後，Gitee Code MCP 還能，自動執行 PR 合併操作，避免繁瑣的人工點擊流程：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182422_7myc_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;再返回 Gitee Code 查看合併結果：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/182435_wt9o_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;至此，我們在 PR Review 時不再需要任何人工的操作，對代碼的評審也完全可以交給 Cursor 和 Gitee MCP Server 去做，從此不再需要為代碼評審苦惱。&lt;/p&gt; 
&lt;p&gt;除了 PR Review，Gitee Code MCP 還支持 Issue 處理、Commit 追蹤、代碼倉庫管理等完整代碼倉庫相關 DevOps 流程。現在就去試試，探索 AI 賦能開發的新方式吧！&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;推薦閲讀&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/340077&quot; target=&quot;news&quot;&gt;寫一行代碼，用 Cursor + Gitee MCP 實現貪吃蛇遊戲&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/339785&quot; target=&quot;news&quot;&gt;Gitee MCP Server：讓 AI 助手接管繁瑣事務，助力 Gitee 專業版研發提效&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338794/gitee-mcp-server&quot; target=&quot;news&quot;&gt;Gitee MCP Server 正式開源：讓 AI 助手直連你的代碼倉庫&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341154</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341154</guid>
            <pubDate>Sat, 22 Mar 2025 10:25:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>DeepSeek 官方詳解 V3 模型「小版本」升級，各項能力全面進階</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;DeepSeek-V3 模型&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/news/340789/deepseek-v3-0324&quot;&gt;近日進行了更新&lt;/a&gt;&lt;/u&gt;，雖然大家都説更新後的 DeepSeek-V3-0324 強到沒邊——哪怕叫 DeepSeek V3.5 也不為過，但官方仍低調地稱其是「小版本升級」。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;486&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/172423_W9Lc_2720166.png&quot; width=&quot;1402&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;下面是官方針對 DeepSeek-V3-0324 &lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FXK6ymJL7y0vo_GQXxmpuBA&quot; target=&quot;_blank&quot;&gt;發佈的更新説明&lt;/a&gt;&lt;/u&gt;。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;DeepSeek V3 模型已完成小版本升級，目前版本號 DeepSeek-V3-0324，用戶登錄官方網頁、APP、小程序進入對話界面後，&lt;strong&gt;關閉深度思考&lt;/strong&gt;即可體驗。API 接口和使用方式保持不變。&lt;/p&gt; 
&lt;p&gt;如非複雜推理任務，建議使用新版本 V3 模型，即刻享受速度更加流暢、效果全面提升的對話體驗。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;模型能力提升一覽&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;推理任務表現提高&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;新版 V3 模型借鑑 DeepSeek-R1 模型訓練過程中所使用的強化學習技術，大幅提高了在推理類任務上的表現水平，在數學、代碼類相關評測集上取得了超過 GPT-4.5 的得分成績。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;799&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/173130_fEuG_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;新版 V3 模型的百科知識（MMLU-Pro, GPQA）、數學（MATH-500, AIME 2024）和代碼任務（LiveCodeBench）表現均有提升&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;前端開發能力增強&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 HTML 等代碼前端任務上，新版 V3 模型生成的代碼可用性更高，視覺效果也更加美觀、富有設計感。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-8c268dc1982a47b1d5c1d3960317fb4b7c2.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;em&gt;動圖展示了一個由模型生成的演示多個小球在指定空間範圍內運動的 p5.js 程序，包含若干可以調整重力、摩擦力等參數的滑動按鈕，並以賽博朋克風格的 HTML 呈現&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;中文寫作升級&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在中文寫作任務方面，新版 V3 模型基於 R1 的寫作水平進行了進一步優化，同時特別提升了中長篇文本創作的內容質量。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1761&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/173210_hnNh_2720166.png&quot; width=&quot;1252&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;中文搜索能力優化&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;新版 V3 模型可以在聯網搜索場景下，對於報告生成類指令輸出內容更為詳實準確、排版更加清晰美觀的結果。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3ceb41b23b1984968d9c56909a7beb38153.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此外，新版 V3 模型在&lt;strong&gt;工具調用、角色扮演、&lt;strong&gt;&lt;strong&gt;問答&lt;/strong&gt;&lt;/strong&gt;閒聊&lt;/strong&gt;等方面也得到了一定幅度的能力提升。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;模型開源&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;DeepSeek-V3-0324 與之前的 DeepSeek-V3 使用同樣的 base 模型，僅改進了後訓練方法。私有化部署時只需要更新 checkpoint 和 tokenizer_config.json（tool calls 相關變動）。模型參數約 660B，開源版本上下文長度為 128K（網頁端、App 和 API 提供 64K 上下文）。&lt;/p&gt; 
&lt;p&gt;V3-0324 模型權重下載請參考：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Model Scope:&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelscope.cn%2Fmodels%2Fdeepseek-ai%2FDeepSeek-V3-0324&quot; target=&quot;_blank&quot;&gt;https://modelscope.cn/models/deepseek-ai/DeepSeek-V3-0324&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Huggingface:&amp;nbsp;&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fdeepseek-ai%2FDeepSeek-V3-0324&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/deepseek-ai/DeepSeek-V3-0324&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;與 DeepSeek-R1 保持一致，此次我們的開源倉庫（包括模型權重）&lt;strong&gt;統一採用 MIT License&lt;/strong&gt;，並允許用戶利用模型輸出、通過模型蒸餾等方式訓練其他模型。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#d35400&quot;&gt;&lt;strong&gt;最後，奉上 DeepSeek V3 最新版的免費體驗地址，由模力方舟提供：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;u&gt;&lt;a href=&quot;https://ai.gitee.com/serverless-api/packages/1917?model=DeepSeek-V3&amp;amp;package=1917&quot; target=&quot;_blank&quot;&gt;https://ai.gitee.com/serverless-api/packages/1917?model=DeepSeek-V3&amp;amp;package=1917&lt;/a&gt;&lt;/u&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0326/103438_ukgv_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;模力方舟的 Serverless API 提供了視頻生成、文本生成、視覺模型、圖像生成與處理、文檔處理 / OCR、自動語音識別、語音合成、特徵抽取、代碼生成、風控識別十大類共 58 款各領域的頂尖開源模型的在線體驗和 API 使用。通過購買模型資源包，即可通過極低的價格即可盡享眾多主流模型。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;683&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0326/103139_wjCp_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341137/deepseek-v3-0324-detail</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341137/deepseek-v3-0324-detail</guid>
            <pubDate>Sat, 22 Mar 2025 09:35:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>高通在全球三大洲指控 ARM 壟斷，芯片架構授權模式面臨重構</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;英國芯片設計公司 Arm&amp;nbsp;自被軟銀收購後，業務模式已經逐漸從基礎架構提供商轉向完整芯片設計商。&lt;/p&gt; 
&lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-03-25%2Fqualcomm-takes-legal-fight-with-arm-to-global-antitrust-agencies&quot; target=&quot;_blank&quot;&gt;彭博社今天援引知情人士的話透露&lt;/a&gt;&lt;/u&gt;，高通已向歐盟委員會、美國聯邦貿易委員會（FTC）及韓國公平交易委員會提交機密文件，指控 Arm&amp;nbsp;涉嫌濫用市場支配地位實施反競爭行為。&lt;/p&gt; 
&lt;p&gt;高通是全球最大手機芯片製造商。該公司認為，Arm 通過開放授權模式使業界對其技術形成高度依賴，同時也促成了芯片產業的蓬勃發展。但是，這一充滿活力的市場如今正受到威脅，因為 Arm 正通過限制技術訪問來推動自身的芯片製造野心，以提高利潤。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-378959a9f2407fecd1acaf54103c1824963.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在與監管機構的私下會議和保密文件中，高通指控 Arm 在運營開放授權模式 20 餘年後，突然限制技術訪問權限，試圖通過自研芯片業務提升利潤。具體表現為：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;拒絕提供協議範圍內的關鍵技術&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;修改授權條款阻礙客戶產品開發&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#e67e22&quot;&gt;&lt;strong&gt;利用指令集架構壟斷地位擠壓下游廠商&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;高通表示，Arm 正「不擇手段」提升財務表現，包括終止與部分客戶的授權協議、要求芯片廠商簽訂捆綁協議、強制收取更高專利費。&lt;/p&gt; 
&lt;p&gt;高通認為，Arm 通過開放的許可模式建立了對其技術的嚴重依賴，這也促進了一個蓬勃發展的芯片產業。高通向全球競爭管理機構表示，由於 Arm 種種限制行為，目前市場正在受到威脅。&lt;/p&gt; 
&lt;p&gt;高通發言人拒絕置評。歐盟委員會、美國 FTC 和韓國公平貿易委員會的發言人也拒絕置評。&lt;/p&gt; 
&lt;p&gt;Arm 方面則表示對勝訴充滿信心：「Arm 仍然專注於加強創新，促進競爭，並尊重合同權利和義務。任何關於反競爭行為的指控都不過是高通為了自身競爭利益，不擇手段地轉移人們對其與我方持續商業糾紛實質的注意力並擴大爭端範圍的絕望嘗試。」&lt;/p&gt; 
&lt;p&gt;閲讀更多：&lt;a href=&quot;https://www.oschina.net/news/318231&quot; target=&quot;news&quot;&gt;英偉達、高通等芯片四巨頭聯手，以新 CPU 架構對抗英特爾、AMD&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341129</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341129</guid>
            <pubDate>Sat, 22 Mar 2025 09:17:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>螞蟻數科發佈能源電力時序大模型 EnergyTS，預測精度超谷歌、亞馬遜</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;螞蟻數科在蘇州舉辦的新能源數字資產社區春季峯會上，宣佈正式推出能源電力時序大模型 EnergyTS。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;EnergyTS 專為新能源行業定製，在光伏場景測評中，其發電量預測準確率顯著超越谷歌（TimesFM-V2.0）和亞馬遜 (Chronos-Large) 等國際主流通用時序模型。在 T+1 天預測中，模型的平均絕對誤差僅為 0.0233，較谷歌模型提升約 22.4%;在 T+3 天預測中，性能提升更是達到 46.8%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;206&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e865e9a90be3dc50aca39f98046b6a90b3a.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;EnergyTS 通過 AI 技術，可精準預測發電量、電力供需情況，有效緩解電價波動、儲能調度收益低等關聯風險，為行業提供更智能的經營決策支持。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;該模型具備多尺度訓練、多模態融合、多任務學習和零樣本冷啓等優勢，可廣泛應用於光伏發電、風力發電、儲能、微電網、電力交易等多個場景，實現&quot;開箱即用&quot;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;螞蟻數科 CEO 趙聞飆表示，公司致力於解決各行業在 AI 時代的智能化轉型問題，未來將在更多領域探索大模型技術與行業實際問題的結合。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341125</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341125</guid>
            <pubDate>Sat, 22 Mar 2025 09:06:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>TensorRT-LLM —— 優化大型語言模型推理的 TensorRT 工具箱</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                            &lt;p&gt;TensorRT-LLM 為用戶提供了易於使用的 Python API，用於定義大型語言模型（LLM）和構建 TensorRT 引擎，這些引擎包含最先進的優化技術，可在英偉達（NVIDIA）圖形處理器上高效執行推理。&lt;/p&gt;

&lt;p&gt;TensorRT-LLM 還包含用於創建執行這些 TensorRT 引擎的 Python 和 C++ 運行時的組件。它還包括一個用於與英偉達 Triton 推理服務器（NVIDIA Triton Inference Server）集成的後端；這是一個為 LLM 提供服務的生產質量系統。使用 TensorRT-LLM 構建的模型可以在多種配置上執行，從單個 GPU 到具有多個 GPU 的多個節點（使用張量並行和/或管道並行）。&lt;/p&gt;

&lt;p&gt;TensorRT-LLM 的 Python API 架構與 PyTorch API 相似。它為用戶提供了包含 einsum、softmax、matmul 或 view 等函數的功能模塊。層模塊捆綁了用於組裝 LLM 的有用構件，如 Attention 塊、MLP 或整個 Transformer 層。GPTAttention 或 BertAttention 等特定模型組件可在模型模塊中找到。&lt;/p&gt;

&lt;p&gt;TensorRT-LLM 預先定義了幾種常用模型。它們可以很容易地修改和擴展，以滿足客戶的需求。可&lt;a href=&quot;https://github.com/NVIDIA/TensorRT-LLM#Models&quot;&gt;參閲支持型號&lt;/a&gt;列表&amp;nbsp;。&lt;/p&gt;

&lt;p&gt;為了最大限度地提高性能並減少內存佔用，TensorRT-LLM 允許使用不同的量化模式來執行模型（具體示例見 &lt;a href=&quot;https://github.com/NVIDIA/TensorRT-LLM/blob/release/0.5.0/examples/gpt&quot;&gt;&lt;code&gt;examples/gpt&lt;/code&gt;&lt;/a&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;）。TensorRT-LLM 支持 INT4 或 INT8 權重（和 FP16 activations，又稱 INT4/INT8 weight-only）以及 SmoothQuant 技術的完整&lt;a href=&quot;https://arxiv.org/abs/2211.10438&quot;&gt;實現&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img height=&quot;284&quot; src=&quot;https://static.oschina.net/uploads/space/2023/1116/164435_jwZL_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/tensorrt-llm</link>
            <guid isPermaLink="false">https://www.oschina.net/p/tensorrt-llm</guid>
            <pubDate>Sat, 22 Mar 2025 08:44:00 GMT</pubDate>
        </item>
        <item>
            <title>蘿蔔快跑在自貢成立科技公司，含 AI 相關業務</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;天眼查資料顯示，近日，蘿蔔運力（自貢）科技有限公司成立，法定代表人為畢然，註冊資本 100 萬人民幣。公司由蘿蔔快跑關聯公司蘿蔔運力（北京）科技有限公司全資持股。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;313&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-a544cf9d0bfa2827963e1b32d87d99f4929.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;經營範圍包括軟件開發、計算機系統服務、互聯網數據服務、數據處理和存儲支持服務、人工智能應用軟件開發、人工智能基礎軟件開發等，由蘿蔔快跑關聯公司蘿蔔運力（北京）科技有限公司全資持股。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341116</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341116</guid>
            <pubDate>Sat, 22 Mar 2025 08:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>華為增資至 409.4 億，近一年已 3 次增資</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;天眼查 App 顯示，華為技術有限公司近日發生工商變更，註冊資本由約 408.4 億人民幣增至約 409.4 億人民幣。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;300&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-f5af3d0d03a8d4183622343df88b625dd7f.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;基本信息顯示，華為技術有限公司 (曾用名：深圳市華為技術有限公司) ，成立於 1987 年，位於廣東省深圳市，由華為投資控股有限公司全資持股。是一家以從事計算機、通信和其他電子設備製造業為主的企業。企業註冊資本 4094113.182 萬人民幣，超過了 100% 的廣東省同行，實繳資本 4054113.18 萬人民幣。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;變更記錄表明，該公司近一年已三次增資，前兩次分別發生於 2024 年 4 月、2024 年 6 月。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341115</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341115</guid>
            <pubDate>Sat, 22 Mar 2025 08:28:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Cloudflare 開源 OpenPubkey SSH（OPKSSH），將單點登錄集成到 SSH</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;Cloudflare 近日&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.cloudflare.com%2Fopen-sourcing-openpubkey-ssh-opkssh-integrating-single-sign-on-with-ssh%2F&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;將 OPKSSH（OpenPubkey SSH）代碼庫捐贈給 Linux 基金會旗下的 OpenPubkey 項目，這意味着開發者現在可通過開源方式實現基於單點登錄（SSO）的 SSH 密鑰管理。&lt;/p&gt; 
&lt;p&gt;OPKSSH 通過將 OpenID Connect（OIDC）協議與 SSH 協議無縫結合，使企業能夠利用現有身份提供商（如 Google、Azure AD）直接管理 SSH 訪問權限，徹底告別手動配置 SSH 密鑰的時代。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-609a9940408bc6b0fe8a976760b572a27f8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;OPKSSH 基於 OpenPubkey 協議，該協議通過在 OIDC 的 ID Token 中嵌入用戶公鑰，生成名為「PK Token」的短期證書。當用戶執行&lt;code&gt;opkssh login&lt;/code&gt;時，流程如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;生成臨時 SSH 密鑰對（默認有效期 24 小時）；&lt;/li&gt; 
 &lt;li&gt;通過瀏覽器跳轉完成 OIDC 認證，獲取包含公鑰的 PK Token；&lt;/li&gt; 
 &lt;li&gt;將 PK Token 寫入本地 SSH 公鑰文件，私鑰僅存於內存。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;服務器端只需在 SSH 配置中添加兩行驗證邏輯（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenpubkey%2Fopenpubkey&quot; target=&quot;_blank&quot;&gt;示例代碼&lt;/a&gt;），即可將傳統 SSH 公鑰驗證替換為 PK Token 驗證。該方案兼容任何 OIDC 提供商，且無需修改 SSH 協議棧。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;OPKSSH&amp;nbsp;三大核心優勢&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;安全性躍升&lt;/strong&gt;：臨時密鑰自動過期，消除長期密鑰泄露風險。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;運維簡化&lt;/strong&gt;：管理員通過郵件地址管理權限（如&lt;code&gt;authorized_emails&lt;/code&gt;文件），無需跟蹤密鑰指紋。用戶可在任意設備通過&lt;code&gt;opkssh login&lt;/code&gt;生成密鑰，徹底解決密鑰分發難題。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;審計透明化&lt;/strong&gt;：所有 SSH 登錄事件均關聯 OIDC 身份信息，天然支持 SIEM 系統集成。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;適用場景與遷移成本&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;OPKSSH 適用於已部署 OIDC 的企業環境，尤其是需嚴格管控雲服務器或 CI/CD 系統訪問權限的場景。遷移僅需：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;在目標服務器運行安裝腳本（&lt;code&gt;curl -sSfL https://install.opkssh.dev | sh&lt;/code&gt;）；&lt;/li&gt; 
 &lt;li&gt;在身份提供商註冊 OPKSSH 客戶端 ID。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;OpenPubkey SSH（OPKSSH）採用 Apache 2.0 許可證，開源地址：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fopenpubkey%2Fopkssh&quot; target=&quot;_blank&quot;&gt;https://github.com/openpubkey/opkssh&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341113/cloudflare-open-sourcing-openpubkey</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341113/cloudflare-open-sourcing-openpubkey</guid>
            <pubDate>Sat, 22 Mar 2025 08:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>崑崙萬維發佈全球首款音樂推理大模型 Mureka O1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                            &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;崑崙萬維宣佈&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1JPYXUwX-1JAVpz3IgygtQ&quot; target=&quot;_blank&quot;&gt;推出&lt;/a&gt; Mureka O1 模型與 Mureka V6 模型。「Mureka O1 作為全球首款音樂推理大模型，性能超越 Suno、模型登頂 SOTA，中國科技創新再次在 AI 音樂領域領跑全球。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2024 年 4 月，崑崙萬維發佈了第一代音樂生成模型：Mureka V1（SkyMusic）。Mureka V6 是當前 Mureka 的基座模型，支持純音樂生成，還支持 10 種語言的 AI 音樂創作，包括英語、中文、日語、韓語、法語、西班牙語、葡萄牙語、德語、意大利語和俄語。在 Mureka V6 中，團隊引入自研 ICL（in-context learning）技術，使得聲場更加開闊，人聲質感和混音設計進一步強化。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;270&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-eb6a0135a337596b6a6a105f75b95b34fb8.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mureka O1 模型是基於 Mureka V6 思維鏈的推理優化版本，也是全球範圍內首個引入 CoT 的音樂模型，在推理過程中加入思考與自我批判，大幅提升音樂品質、音樂創作效率和靈活性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mureka V6 和 O1 模式支持多元化的音樂創作風格及情感表達。曲風涵蓋爵士 (Jazz)、電子 (Electronic)、流行 (Pop)、鄉村 (Country)、節奏布魯斯 (R&amp;amp;B)、靈魂樂 (Soul)、藍調 (Blues)、搖滾 (Rock)、舞曲 (Dance) 等；情感維度包括快樂、放縱、神祕、充滿活力、悲傷等多種情緒表達。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;此外，Mureka 還提供兩個特色音樂生成功能：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;歌曲參考（Reference Fuction）：將音樂本身作為提示，用戶可直接上傳音頻或 Youtube 鏈接作為創作提示，比文本提示更直接更高級的提示方式；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;音色克隆（Vocal Fuction）：Mureka 是全球首個可以指定演唱歌手音色的 AI 音樂生成平台，用戶不僅可以選擇官方提供的多種歌手音色，還可以上傳自己的聲音，讓 AI 學習並復刻，精準模擬歌手音色，一鍵生成個性化專屬作品。自定義歌手音色的功能宣告人人都能成為 AI 歌手的時代正式到來了。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Mureka O1 中包含了 Mureka 團隊最新發布的音樂生成領域的創新研究成果——MusiCoT。根據介紹，MusiCoT 利用了思維鏈 Chain-of-Thought （CoT）方法，不同於傳統自迴歸模型逐步生成音頻，MusiCoT 首次在細粒度音頻 token 預測前預生成整體音樂結構，大幅提升生成音樂的結構連貫性與樂器編排精準度。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;MusiCoT 基於 CLAP 模型，無需人工標註即具備高擴展性，並顯著提高了生成音樂的可解釋性和質量。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;基於首次在音樂生成領域引入 Chain-of-Thought（CoT）技術、算法框架的升級，Mureka O1 不僅保持了低延遲音樂生成，還顯著提升了歌詞旋律契合度、演唱準確性和藝術表現力等，多項指標領先於 Suno V4。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;294&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-503e30956b12803e771c5937b2b29cdd12d.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;305&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-cbf0a6f76c773afe0506002d7f11fe7135c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;336&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-82ca85f7fa60597b44ceaddec62bfe1e73c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;330&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-051e429a4d3e0dc2eb7a98978f95ef96f3c.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/341110</link>
            <guid isPermaLink="false">https://www.oschina.net/news/341110</guid>
            <pubDate>Sat, 22 Mar 2025 08:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>