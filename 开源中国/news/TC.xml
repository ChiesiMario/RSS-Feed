<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Fri, 16 May 2025 02:43:05 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>微軟 Copilot 應用開始支持「Hey Copilot」語音喚醒詞</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微軟於 5 月 14 日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.windows.com%2Fwindows-insider%2F2025%2F05%2F14%2Fcopilot-on-windows-hey-copilot-begins-rolling-out-to-windows-insiders%2F" target="_blank"&gt;發佈博文&lt;/a&gt;，邀請 Windows Insider 項目成員測試新版 Microsoft Copilot 應用程序（版本 1.25051.10.0 及以上）。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5a34382c61b9b7b18278a027534f39f7e0d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;用戶在新版 Copilot 應用中啓用相關選項後，可通過「Hey Copilot」喚醒詞，在 PC 解鎖且功能開啓時、喚醒 Copilot 開啓 AI 聊天，無需點擊或輸入。微軟表示，用戶在工作或思考時無需手動操作，即可獲得幫助。&lt;/p&gt; 
&lt;p&gt;提問時，屏幕會顯示 Copilot 麥克風圖標，並伴隨提示音，表明 Copilot 正在傾聽。結束對話可點擊 X 按鈕，或在幾秒無交互後自動結束，併發出確認音。&lt;/p&gt; 
&lt;p&gt;微軟強調，設備僅在本地識別喚醒詞，採用 10 秒內存音頻緩衝區，不錄音或本地存儲數據。一旦識別到喚醒詞，Copilot Voice 浮動界面將出現，隨後音頻會傳輸至雲端處理用戶請求。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350160/copilot-on-windows-hey-copilot</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350160/copilot-on-windows-hey-copilot</guid>
      <pubDate>Fri, 16 May 2025 02:17:53 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>雷軍：小米自研手機 SoC 芯片「玄戒 O1」將於 5 月下旬發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;小米集團創始人雷軍發佈微博透露，造芯十年，小米自主研發設計的手機 SoC 芯片名字叫「玄戒 O1」，將在 5 月下旬發佈。&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;和大家分享一條消息：&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;小米自主研發設計的手機 SoC 芯片，名字叫，玄戒 O1，即將在 5 月下旬發佈。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="color:#000000"&gt;感謝大家支持！&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="266" src="https://oscimg.oschina.net/oscnet/up-a36d75d9b55368c7956744282be4ebb4cec.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="274" src="https://oscimg.oschina.net/oscnet/up-4d662277ff9587e8953da3929f020383f21.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;對此，人民網也發文點評稱：「最近一年，小米在新能源汽車、國產芯片等領域接連帶來突破創新。這證明瞭，只要堅定實幹，就沒有不可逾越的高山；只要奮起直追，後來者永遠有機會。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="332" src="https://oscimg.oschina.net/oscnet/up-5bd8371176fd6755e7b2635cd8c858f5fce.png" width="500" referrerpolicy="no-referrer"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350157</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350157</guid>
      <pubDate>Fri, 16 May 2025 02:13:53 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 發佈語音模型 MiniMax Speech 02</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;MiniMax 現已&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4pa3KCRLwDlVZHCA_9R0iA"&gt;推出&lt;/a&gt;基於 AR Transformer 模型的高質量 TTS 系統 ——MiniMax Speech 02。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-6f2d41090b2c4d82bff733ccc15046faf46.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;MiniMax Speech 02 具有足夠強的泛化能力，&lt;strong&gt;能夠輕鬆駕馭 32 語種、不同口音、不同情緒的人聲&lt;/strong&gt;。該模型系統的核心創新之處在於其內在的 Zero-Shot 能力，其命為 Intrinsic Zero-Shot Text-to-Speech with a Learnable Speaker Encoder。&lt;/p&gt; 
&lt;p&gt;在提供更優異聽感同時，MiniMax Speech 02 做到了價格更低，分別是 ElevenLabs Flash V2.5 與 Mutilingual V2 的一半與四分之一。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/101019_9RYc_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在國際權威的 Artificial Analysis 上，MiniMax Speech 02 也通過全球用戶測評，位列全球第一。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/100728_YHJY_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0516/100932_INxq_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;體驗 MiniMax Speech&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.minimax.io%2Faudio"&gt;https://www.minimax.io/audio&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.minimaxi.com%2Faudio"&gt;https://www.minimaxi.com/audio&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;更多技術細節、實驗對比數據、以及開源的多語言測試集，閲讀技術報告&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;GitHub：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FMiniMax-AI%2FMiniMax-AI.github.io%2Fblob%2Fmain%2Ftts_tech_report%2FMiniMax_Speech.pdf"&gt;https://github.com/MiniMax-AI/MiniMax-AI.github.io/blob/main/tts_tech_report/MiniMax_Speech.pdf&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Hugging Face：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fspaces%2FMiniMaxAI%2FMiniMax-Speech-Tech-Report"&gt;https://huggingface.co/spaces/MiniMaxAI/MiniMax-Speech-Tech-Report&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350155/minimax-speech-02</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350155/minimax-speech-02</guid>
      <pubDate>Fri, 16 May 2025 02:08:53 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>梁文鋒等發表 DeepSeek V3 回顧性論文</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;DeepSeek 創始人梁文鋒等人近日發表了一篇名為《Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for Al Architectures（深入瞭解 DeepSeek-V3：人工智能架構硬件的擴展挑戰與思考）》的回顧性論文。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;深入分析了 DeepSeek-V3/R1 模型架構及其人工智能基礎架構，重點介紹了一些關鍵創新，如提高內存效率的多頭潛意識（MLA）、優化計算與通信權衡的混合專家（MoE）架構、釋放硬件能力全部潛力的 FP8 混合精度訓練，以及最大限度降低集羣級網絡開銷的多平面網絡拓撲結構。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="308" src="https://oscimg.oschina.net/oscnet/up-7d3d04217f33b8b740ddaf8bd1753b2ce4b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;該研究表明，當前大語言模型（LLM）的迅速擴展暴露了現有硬件架構的許多侷限性，比如內存容量、計算效率和互連帶寬。DeepSeek-V3 在 2048 塊 NVIDIA H800GPU 集羣上訓練，通過有效的硬件感知模型設計，克服了這些限制，實現了經濟高效的大規模訓練和推理。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="348" src="https://oscimg.oschina.net/oscnet/up-1fa090ba2ba63a45ee9c1b284fe2b778ca0.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;具體來説，論文中提出了幾個關鍵點。首先，DeepSeek-V3 採用了先進的 DeepSeekMoE 架構和多頭潛在注意力（MLA）架構，極大地提高了內存效率。MLA 技術通過壓縮鍵值緩存，顯著降低了內存使用，使得每個 token 只需 70KB 的內存，相比其他模型大幅減少。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;其次，DeepSeek 還實現了成本效益的優化。通過其混合專家（MoE）架構，DeepSeek-V3 在激活參數的數量上實現了顯著的降低，訓練成本相比於傳統密集模型降低了一個數量級。此外，該模型在推理速度上也進行了優化，採用雙微批次重疊架構來最大化吞吐量，確保 GPU 資源得到充分利用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;DeepSeek 在未來硬件設計方面提出了創新的思考。他們建議通過聯合優化硬件和模型架構，來應對 LLM 的內存效率、成本效益和推理速度三大挑戰。這為日後的 AI 系統開發提供了寶貴的參考。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;更多詳情可查看具體論文：&lt;/span&gt;&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2505.09343" target="_blank"&gt;https://arxiv.org/pdf/2505.09343&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350152</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350152</guid>
      <pubDate>Fri, 16 May 2025 01:56:53 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Go 語言讀寫 Excel 基礎庫</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p&gt;&lt;img src="https://xuri.me/excelize/images/excelize.svg" alt="Excelize" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;Excelize&lt;/a&gt; 是 Go 語言編寫的一個用來操作 Office Excel 文檔類庫，基於 ECMA-376 Office OpenXML 標準。可以使用它來讀取、寫入 XLSX 文件。相比較其他的開源類庫，Excelize 支持寫入原本帶有圖片 (表) 的文檔，還支持向 Excel 中插入圖片，並且在保存後不會丟失圖表樣式。&lt;/p&gt; 
&lt;h3&gt;安裝&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-bash"&gt;go get github.com/xuri/excelize/v2
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;創建 XLSX&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f := excelize.NewFile()
    // Create a new sheet.
    index := f.NewSheet("Sheet2")
    // Set value of a cell.
    f.SetCellValue("Sheet2", "A2", "Hello world.")
    f.SetCellValue("Sheet1", "B2", 100)
    // Set active sheet of the workbook.
    f.SetActiveSheet(index)
    // Save xlsx file by the given path.
    err := f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;讀取已有文檔&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Get value from cell by given worksheet name and axis.
    cell, err := f.GetCellValue("Sheet1", "B2")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(cell)
    // Get all the rows in the Sheet1.
    rows, err := f.GetRows("Sheet1")
    for _, row := range rows {
        for _, colCell := range row {
            fmt.Print(colCell, "\t")
        }
        fmt.Println()
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入圖表&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/xuri/excelize/master/test/images/chart.png?version=1" alt="chart" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"

    "github.com/xuri/excelize/v2"
)

func main() {
    categories := map[string]string{"A2": "Small", "A3": "Normal", "A4": "Large", "B1": "Apple", "C1": "Orange", "D1": "Pear"}
    values := map[string]int{"B2": 2, "C2": 3, "D2": 3, "B3": 5, "C3": 2, "D3": 4, "B4": 6, "C4": 7, "D4": 8}
    f := excelize.NewFile()
    for k, v := range categories {
        f.SetCellValue("Sheet1", k, v)
    }
    for k, v := range values {
        f.SetCellValue("Sheet1", k, v)
    }
    err := f.AddChart("Sheet1", "E1", `{"type":"col3DClustered","series":[{"name":"Sheet1!$A$2","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$2:$D$2"},{"name":"Sheet1!$A$3","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$3:$D$3"},{"name":"Sheet1!$A$4","categories":"Sheet1!$B$1:$D$1","values":"Sheet1!$B$4:$D$4"}],"title":{"name":"Fruit 3D Clustered Column Chart"}}`)
    if err != nil {
        fmt.Println(err)
        return
    }
    // Save xlsx file by the given path.
    err = f.SaveAs("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;向 Excel 中插入圖片&lt;/h3&gt; 
&lt;pre&gt;&lt;code class="language-go"&gt;package main

import (
    "fmt"
    _ "image/gif"
    _ "image/jpeg"
    _ "image/png"

    "github.com/xuri/excelize/v2"
)

func main() {
    f, err := excelize.OpenFile("./Book1.xlsx")
    if err != nil {
        fmt.Println(err)
        return
    }
    // Insert a picture.
    err = f.AddPicture("Sheet1", "A2", "./image1.png", "")
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture to worksheet with scaling.
    err = f.AddPicture("Sheet1", "D2", "./image2.jpg", `{"x_scale": 0.5, "y_scale": 0.5}`)
    if err != nil {
        fmt.Println(err)
    }
    // Insert a picture offset in the cell with printing support.
    err = f.AddPicture("Sheet1", "H2", "./image3.gif", `{"x_offset": 15, "y_offset": 10, "print_obj": true, "lock_aspect_ratio": false, "locked": false}`)
    if err != nil {
        fmt.Println(err)
    }
    // Save the xlsx file with the origin path.
    err = f.Save()
    if err != nil {
        fmt.Println(err)
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;還有其他一些功能，在這裏就不一一列舉了，詳細使用文檔以及獲取後期的維護更新可以從項目的主頁獲取&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxuri%2Fexcelize" target="_blank"&gt;github.com/xuri/excelize&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/xuri/blog/3057381</link>
      <guid isPermaLink="false">https://my.oschina.net/xuri/blog/3057381</guid>
      <pubDate>Sat, 10 May 2025 10:24:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>AI 推理大模型或在一年內減緩增長</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 研究機構 Epoch AI 發佈&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fepoch.ai%2Fgradient-updates%2Fhow-far-can-reasoning-models-scale" target="_blank"&gt;《推理模型能擴展多遠（How far can reasoning models scale?）》&lt;/a&gt;報告，其中對推理模型的現狀和未來作出了分析總結。&lt;/p&gt; 
&lt;p&gt;Epoch AI 通過各家開源的技術報告，來分析了目前推理模型的訓練成本，同時也進一步總結，目前前沿的推理模型其推理訓練規模仍未見頂，還能持續擴展（scalable），並且推理模型還有潛力在短期內快速實現能力拓展。&lt;/p&gt; 
&lt;p&gt;Epoch AI 的分析表明，人工智能行業可能無法在更長的時間內從推理人工智能模型中獲得巨大的性能提升。根據該報告的研究結果，推理模型的進展最快可能在一年內放緩。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2b0a64ac6bff63c39819e86da31b4e92548.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;近幾個月來，OpenAI 的 o3 等推理模型在人工智能基準測試中取得了大幅提升，尤其是在衡量數學和編程技能的基準測試中。這些模型可以對問題進行更多計算，從而提高性能，但缺點是它們完成任務的時間比傳統模型更長。&lt;/p&gt; 
&lt;p&gt;Epoch AI 提到，如果推理階段的算力需求見頂，那麼其帶來的增長率將收斂，大概是每年增長 4 倍，不會像 o1 到 o3 那樣擁有「跳躍式增長」——幾個月增長 10 倍的態勢。&lt;/p&gt; 
&lt;p&gt;基於上述情況，Epoch AI 表示，如果推理模型的訓練階段只比前沿推理模型低幾個（比如説不到三個）數量級，這種增長率可能在一年內減緩。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350079/how-far-can-reasoning-models-scale</guid>
      <pubDate>Sat, 10 May 2025 10:16:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>這就是 univer</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;零. 開篇&lt;/h1&gt; 
&lt;div&gt;
  這篇文章旨在幫助新人快速熟悉開源項目 univer 的架構及代碼，也是我過去一段時間參與到 univer 開發中的學習和總結，肯定有不夠準確或者理解偏差，歡迎大家評論指正 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第壹章，會聊聊我對 univer 架構的理解，univer 是如何拆分模塊，以及模塊之間的依賴關係。然後將 univer 放入 MVC 的架構模式中，分別分析下其模型層、視圖層、控制器的邊界和職責 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第貳章，我們先來看看 univer sheet 的模型層數據結構設計，如何區分 workbook、sheet、row、column、style 等，瞭解他們的包含關係，這對後面深入理解代碼是有幫助的 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第叄、肆章，我將從兩條控制鏈路來分析 univer 的代碼，一條鏈路是 univer 啓動和初始化渲染的過程。在這條鏈路中，是從模型層到視圖層的過程。另外一條鏈路是 univer 響應用戶事件，並且觸發模型層數據變更，頁面重新渲染，在這條鏈路中，是從視圖層到模型層的過程。在這兩部分，我們會涉及到大量的源碼分析，在保留代碼主邏輯的前提，刪除了邊界 case 的代碼。同時在每個代碼塊第一行，表示該代碼塊所在的 TS 文件，這樣便於直接閲讀源碼 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;壹. 對代碼架構的理解&lt;/h1&gt; 
&lt;blockquote&gt; 
 &lt;div&gt;
   外表的美只能取悅於人的眼睛，而內在的美卻能感染人的靈魂。 ——伏爾泰 
 &lt;/div&gt; 
&lt;/blockquote&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;Univer 中的模塊拆分和依賴關係&lt;/h2&gt; 
&lt;span id="OSC_h3_4"&gt;&lt;/span&gt; 
&lt;h3&gt;無依賴環原則&lt;/h3&gt; 
&lt;div&gt;
  軟件架構的規則其實就是排列組合代碼塊的規則，軟件架構會根據業務域來將組織項目代碼，將項目拆分成不同的模塊，各個模塊做到關注點分離，同時模塊之間有明確的依賴關係，並且依賴關係是一個單向無環圖，也就是 
 &lt;strong&gt;無依賴環原則&lt;/strong&gt;。正如下面圖中所示，系統級、應用級業務邏輯是整個項目最核心的部分，同時也是應用最穩定的部分，應該放在架構的最裏層，其他如用戶界面、渲染引擎、前端框架、持久化的數據庫，這些在架構演進的過程中，可能被替換，所以他們都依賴於最中心的業務實體，置於外層 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp;&amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img align="left" alt="" height="327" src="https://oscimg.oschina.net/oscnet/up-3ab4dcd10c5e846f57c70e486ce2f37951d.png" width="340" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;（圖注：core、base-sheet、base-render、base-ui、ui-plugin-sheet 對應倉庫中 packages 下不同文件夾）&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer 在整個架構設計中，儘量保證核心模塊（core）僅包含最核心的業務邏輯，在覈心業務邏輯之上所構築的其他功能，都是通過插件化來提供的，這也是 
 &lt;strong&gt;微內核架構&lt;/strong&gt;的思想。在上圖中，base-render、base-ui、base-sheet 等都是插件化的，為 core 提供額外的能力。如 base-sheet 完善 sheet 相關功能，base-render（canvas 渲染引擎） 提供 canvas 渲染能力，公式引擎提供公式相關的計算和解析等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;依賴反轉&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  直觀理解，我們可能會認為，core 模塊依賴於 base-render 模塊來做 canvas 渲染，依賴 base-ui 來做頁面框架渲染及樣式菜單等，base-ui 又依賴於 React 框架來渲染組件。這樣會有一個問題，核心模塊依賴於其他模塊，其他模塊往往是不穩定的，比如樣式菜單，我們可能會經常改變位置或者樣式，這也有可能導致核心模塊易變。在 Univer 中，利用了 
 &lt;strong&gt;依賴反轉（Dependency Inversion）&lt;/strong&gt;解決上面面臨的問題，這也就是上面圖中，所有的外面的環都依賴內部的環，而內部的環不能依賴外部環。在 Univer 中引入了 
 &lt;strong&gt;依賴注入（DI）&lt;/strong&gt;，通過依賴注入的方式，反轉依賴，避免了核心層對外層的依賴，通過下面代碼示例來解釋會更清晰一些 
&lt;/div&gt; 
&lt;div&gt;
  舉個例子，在沒有依賴注入，我們可能會寫這樣的代碼： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    private _commandService = new CommandService(); 
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼中，SheetPlugin 類依賴於 CommandService 類，CommandService 類中方法的變更直接會影響到 SheetPlugin，SheetPlugin 可能也需要修改，導致 SheetPlugin 的不穩定 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="256" src="https://oscimg.oschina.net/oscnet/up-d90622f22bde7a5dae35b7fe4953a7dff37.png" width="812" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  我們通過依賴注入，代碼如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;class SheetPlugin {
    constructor(
        // ...
        @ICommandService private readonly _commandService: ICommandService,
        // ...
    )

    otherMethod(){
        this._commandService.registerCommand(SomeCommand);
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面的代碼中，聲明瞭 _commandService 屬性擁有 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口，通過相關的依賴綁定，就可以在 SheetPlugin 的方法中調用 
 &lt;u&gt;ICommandService&lt;/u&gt; 接口所定義的方法了。這樣 SheetPlugin 依賴於 ICommandService 接口，同時 CommandService 類實現了這個接口。這樣就解耦了 SheetPlugin 和 CommandService 之間的直接依賴關係，圖示如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="274" src="https://oscimg.oschina.net/oscnet/up-9fb80a8045b6fa4c8ac48c0f51d982460ba.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  如上圖，我們通過 ICommandService 接口實現依賴反轉，在沒有 ICommandService 接口下，SheetPlugin 直接依賴於 CommandService，導致核心業務邏輯（SheetPlugin）的不穩定。通過引入 ICommandService 接口，及依賴注入，如果將虛線框看成一個整體，CommandService 類指向（實現接口）虛線框，最終實現依賴反轉，保證了核心業務邏輯穩定性 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;淺談 Univer 中的 MVC 架構模式&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="293" src="https://oscimg.oschina.net/oscnet/up-bacff8d1ee26d5039c6ff41f3b7489fef0d.png" width="1000" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  MVC 在整個 GUI 編程領域已經有了 50 多年的歷史了，但是 MVC 卻一直沒有一個明確的定義。如上圖，就是兩種比較典型的 MVC 變種，在 
 &lt;strong&gt;MVC with ASP.NET&lt;/strong&gt; 中，控制器負責管理視圖和模型，當控制器改變模型層中數據後，通過一些訂閲機制，視圖層直接讀取模型層中數據，更新視圖。在 
 &lt;strong&gt;MVC with Rails &lt;/strong&gt;中，視圖層不直接和模型層交互，通過控制器做了一層代理，視圖層需要通過控制器從模型層取數據進行渲染。這樣有個好處就是視圖層和模型層完全的解耦，控制流會更清晰 
&lt;/div&gt; 
&lt;div&gt;
  打開 univer 工程代碼，我們可以發現大量以 
 &lt;code&gt;controller&lt;/code&gt; 、 
 &lt;code&gt;view&lt;/code&gt; 和 
 &lt;code&gt;model&lt;/code&gt;後綴命名的文件，大致也能看出其採用了傳統的 MVC 架構模式。Univer 中 MVC 架構更類似於 
 &lt;strong&gt;MVC with Rails&lt;/strong&gt;, 因為視圖層不直接讀取 Model 層數據，也不訂閲模型層的改變（下面會提到，是訂閲了 Mutations），而是做了一層數據緩存（類似 ViewModel）， 
 &lt;u&gt;SheetSkeleton &lt;/u&gt;類 
&lt;/div&gt; 
&lt;div&gt;
  在最開始看工程代碼時，一些疑慮一直縈繞在腦海： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 是如何組織和管理模型層的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 中控制器有哪些職責，如何保證控制器代碼架構清晰？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;em&gt;Univer 的視圖層怎麼組織和管理的？&lt;/em&gt; 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;div&gt;
  閲讀源碼，談談 Univer 如何從架構層面回答上面的問題 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;模型層（Model）&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt;
  Univer 的整個模型層會比較薄，拿 univer sheet 來舉例，在 core 模塊中，通過 
 &lt;u&gt;Workbook&lt;/u&gt; 和 
 &lt;u&gt;Worksheet&lt;/u&gt; 類來管理和 sheet 相關的模型數據，提供了相關模型數據存儲和管理的工作。如在 
 &lt;u&gt;Worksheet&lt;/u&gt; 類中，有 
 &lt;code&gt;row-manager&lt;/code&gt;、 
 &lt;code&gt;column-manager&lt;/code&gt;、相關的類和方法來管理每個 sheet 模型數據，拿 
 &lt;code&gt;row-manager&lt;/code&gt;來説，我們可以獲取表格行的一些信息和數據： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;getRowData(): ObjectArray&amp;lt;IRowData&amp;gt;;
getRowHeight(rowPos: number): number;
getRowOrCreate(rowPos: number): IRowData;
// ...&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  很容易理解，我們渲染的數據不能夠直接使用底層模型數據，往往需要經過一定的計算，生成一個用於渲染的「模型層」才能用於直接的視圖渲染。比如在渲染視圖的時候，我們需要計算行、列的總高度。通過每行的文檔內容，計算能夠容納數據的最小行高度。通過一系列的計算，最終確定 sheet 頁面的佈局，用於最終的渲染。而這一系列的計算都放在了視圖層 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 類中 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;&lt;strong&gt;控制器（Controller）的職責&lt;/strong&gt;&lt;/h3&gt; 
&lt;div&gt; 
 &lt;img alt="" height="428" src="https://oscimg.oschina.net/oscnet/up-95ce27fa3497387181c703081a693a984be.png" width="600" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在傳統的 MVC 架構中，視圖和模型層往往職責比較明晰，而控制器承擔了主要的業務邏輯，和管理視圖層、模型層的任務，往往會比較臃腫，那麼 univer 是如何避免控制器臃腫的呢？在 Univer 中，控制器（MVC 中的控制器）進一步拆解為 
 &lt;strong&gt;Controllers&lt;/strong&gt;（Univer 中狹義的控制器）、 
 &lt;strong&gt;Commands&lt;/strong&gt; 和 
 &lt;strong&gt;Services&lt;/strong&gt;。同時在控制器中，幾乎包含了 univer 所有的業務邏輯，他們各司其職，保證了 univer 應用的正常運行 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Controllers 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    初始化一些渲染邏輯和事件的監聽，如在 
   &lt;u&gt;SheetRenderController 類&lt;/u&gt;中，在應用 
   &lt;code&gt;Rendered&lt;/code&gt;生命週期執行，會去初始化頁面的數據刷新（_initialRenderRefresh），會去監聽 Commands 的執行，涉及到 Mutation 修改模型層，還會觸發頁面渲染邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和視圖層交互，拿到視圖層的一些數據信息。如在 
   &lt;u&gt;AutoHeightController &lt;/u&gt;類中，會根據 Commands 所需，通過視圖層計算 sheet 自動行高 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    綁定 UI 事件，如在 
   &lt;u&gt;HeaderResizeController &lt;/u&gt;類中，會在應用 
   &lt;code&gt;Rendered&lt;/code&gt;生命週期執行，在初始化中，為 spreadsheetRowHeader、spreadsheetColumnHeader 綁定 hover 事件，顯示和隱藏 resize header（用於調節行列高度和寬度），也為 resize header 綁定 pointer down/move/up 等事件，這樣 resize header 就會響應拖拽移動，處理相關用戶操作，最終也會反應到模型層的修改和視圖層的更新 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Commands 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Commands 可以理解為用戶的單次交互操作，比如合併單元格、清除選區、插入行列、設置單元格樣式等，並且更改模型層，觸發視圖層渲染。 
 &lt;code&gt;Commands&lt;/code&gt; 有三種類型： 
 &lt;code&gt;COMMAND&lt;/code&gt;、 
 &lt;code&gt;MUTATION&lt;/code&gt;、 
 &lt;code&gt;OPERATION&lt;/code&gt; 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;COMMAND&lt;/strong&gt; 就是用戶的一次交互操作，有用戶行為觸發，可以派生出另外一個 
   &lt;code&gt;COMMAND&lt;/code&gt;，比如用戶點擊菜單中 text wrap 菜單項，會觸發 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt;， 
   &lt;code&gt;SetTextWrapCommand&lt;/code&gt; 會派生出 
   &lt;code&gt;SetStyleCommand&lt;/code&gt; 統一處理所有樣式的更改。一個 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生另外一個 
   &lt;code&gt;COMMAND&lt;/code&gt;，但是不能分叉，因為我們需要在 
   &lt;code&gt;COMMAND&lt;/code&gt; 中處理 undo/redo 相關操作（後面 undo/redo 可能會移到數據層）。但是一個 
   &lt;code&gt;COMMAND&lt;/code&gt; 可以派生出多個 
   &lt;code&gt;MUTATION&lt;/code&gt; 和 
   &lt;code&gt;OPERATION&lt;/code&gt; 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;MUTATION&lt;/strong&gt; 可以理解為對模型層數據的原子操作，比如 
   &lt;code&gt;SetRangeValuesMutation&lt;/code&gt; 修改選區範圍內的單元格樣式和值， 
   &lt;code&gt;SetWorksheetRowHeightMutation&lt;/code&gt;修改選區範圍內行的高度。MUTATION 的執行，不僅會修改模型數據，同時也會觸發視圖的重新渲染。MUTATION 中修改的數據需要處理協同，和解決協同中的衝突 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt; 
   &lt;strong&gt;OPERATION&lt;/strong&gt; 是對應用狀態的變更，是應用的某個臨時狀態，如頁面滾動位置、用戶光標位置、當前的選區等，不涉及到協同和解決衝突的問題，主要用於之後 live share （類似於飛書的 magic share）等功能 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h4_11"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;Services 職責&lt;/strong&gt;&lt;/h4&gt; 
&lt;div&gt;
  Services 為整個 Univer 應用提供各種服務，是關注點分離（Separate of concern）在 Univer 項目架構中的承載者 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    管理應用生命週期，如 
   &lt;u&gt;LifecycleService &lt;/u&gt;類，保存應用生命週期的狀態值，並提供 
   &lt;code&gt;subscribeWithPrevious&lt;/code&gt;方法供其他模塊訂閲應用生命週期狀態值的變更，並做響應任務執行，如依賴的初始化等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理應用的 History 操作和存儲歷史操作，這樣用戶可以 undo/redo 之前的操作。在 
   &lt;u&gt;LocalUndoRedoService &lt;/u&gt;類中，通過 
   &lt;code&gt;pushUndoRedo&lt;/code&gt; 方法將 undo/redo 信息推入棧中，通過 
   &lt;code&gt;updateStatus&lt;/code&gt; 方法觸發 undo/redo 操作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理網絡 IO 和 websocket 鏈接 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  總結一下，將上面 Controllers、Commands、Services 統稱為 MVC 中的控制器，他們完成了 univer 中大量業務邏輯，下面列舉了其主要職責（在叄、肆部分，會更加詳細的分析控制器是如何工作的）： 
&lt;/div&gt; 
&lt;ol&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    負責整個應用的生命週期管理 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    綁定和響應 UI 事件，如雙擊、光標移動等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    控制視圖的渲染和觸發渲染的邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    和視圖層通信，如拿計算後頁面佈局信息 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    通過 Command/Mutation 改變模型層，觸發界面渲染 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    處理 undo/redo 相關工作 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    負責協作、和網絡 IO 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h3_12"&gt;&lt;/span&gt; 
&lt;h3&gt;視圖層（View）&lt;/h3&gt; 
&lt;div&gt;
  在 Univer 中，有兩種渲染方式：一種是 Canvas 渲染引擎，一種是 React 通過 DOM 進行渲染。Canvas 渲染引擎主要渲染 sheet 的主體部分：行表頭、列表頭、sheet 單元格、選區、單元格編輯器等。React 主要用於渲染頂部菜單欄、右鍵菜單欄、浮窗等 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 主體部分選用 Canvas 進行渲染，保證了在大數據量下表格渲染的極致性能體驗，和流暢的動畫效果。而菜單主要需要響應用戶事件，DOM 往往比 Canvas 更具優勢 
&lt;/div&gt; 
&lt;div&gt;
  Canvas 渲染所需要的組件、服務都在 
 &lt;code&gt;base-render&lt;/code&gt;文件夾中，如 sheet 渲染相關的： 
 &lt;u&gt;Spreadsheet、SpreadsheetRowHeader、SpreadsheetColumnHeader &lt;/u&gt;等。同時在 Canvas 組件上定義了一套事件響應機制，保證了各個組件能夠獨立響應事件，但是並不會在視圖層處理這些事件。這些事件都需要在 Controllers 中處理 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;code&gt;Base-ui/Components&lt;/code&gt; 文件夾中代碼負責菜單基礎組件的渲染和用戶事件的發佈，base-ui 模塊也負責整個應用的框架渲染。如在 
 &lt;u&gt;DesktopUIController &lt;/u&gt;類中，bootstrapWorkbench 啓動了整個應用框架渲染，以及 Canvas 元素的掛載等 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_13"&gt;&lt;/span&gt; 
&lt;h1&gt;貳. Univer sheet 數據結構&lt;/h1&gt; 
&lt;div&gt;
  瞭解一個項目，先從其數據結構開始 
&lt;/div&gt; 
&lt;div&gt;
  Sheet 相關的數據類型定義在 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Ftree%2Fdev%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces" rel="nofollow" target="_blank"&gt;Interfaces&lt;/a&gt; 文件夾中，包含關係如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="576" src="https://oscimg.oschina.net/oscnet/up-538aaa85e011f7227788f7d59ab0abe1447.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  Univer sheet 整體的數據類型定義如上圖所示，一個 workbook 包含多個 sheets，sheets 所引用的 styles 字段定義在了頂層 workbook 上，保證了樣式的複用，減少內存開銷，這也是和 Excel 保持一致。在 IWorksheetConfig 中，定義了 cellData 字段，這是一個二維矩陣，用於持久化單元格信息，也就是 ICellData 中定義的類型信息， 
 &lt;strong&gt;p 是指富文本，接口類型 IDocumentData，也就是一篇 univer doc，這也是 univer 設計的獨到之處，univer sheet 的每個單元格都可以轉變成一個 univer doc。&lt;/strong&gt;s 字段大多是一個字符串 id，指向 IWorkbookConfig 中 styles 字段，從中檢索出該單元格的樣式信息 
&lt;/div&gt; 
&lt;div&gt;
  圖中並沒有包含各個接口定義的所有字段，想了解更多，建議直接查看上面的 
 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2F9a505ec3ba9de96677b9caaa821e287e71ebe0cf%2Fpackages%2Fcore%2Fsrc%2FTypes%2FInterfaces%2FIWorkbookData.ts%23L12" rel="nofollow" target="_blank"&gt;類型定義文件&lt;/a&gt;，上面也有相應註釋 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_14"&gt;&lt;/span&gt; 
&lt;h1&gt;叄. 應用啓動到渲染的過程&lt;/h1&gt; 
&lt;div&gt;
  Univer 如何渲染頁面，其實就是 univer 應用啓動的整個過程，也是模型層到視圖層的整個過程。在瞭解頁面渲染前，我們先了解下 univer 的生命週期，其實在上面 Services 部分也有所提及 
&lt;/div&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;應用的生命週期&lt;/h2&gt; 
&lt;pre&gt;&lt;code class="language-javascript"&gt;export const enum LifecycleStages {
    /**
     * Register plugins to Univer.
     */
    Starting,
    /**
     * Univer business instances (UniverDoc / UniverSheet / UniverSlide) are created and services or controllers provided by
     * plugins get initialized. The application is ready to do the first-time rendering.
     */
    Ready,
    /**
     * First-time rendering is completed.
     */
    Rendered,
    /**
     * All lazy tasks are completed. The application is fully ready to provide features to users.
     */
    Steady,
}&lt;/code&gt;&lt;/pre&gt; 
&lt;div&gt;
  Univer 生命週期有四個階段， 
 &lt;code&gt;Starting&lt;/code&gt;、 
 &lt;code&gt;Ready&lt;/code&gt;、 
 &lt;code&gt;Rendered&lt;/code&gt; 和 
 &lt;code&gt;Steady&lt;/code&gt;。如在 Starting 階段去註冊各個插件到 univer 上面，在 Ready 階段實例化 UniverSheet，並且執行各個插件的初始化函數，Rendered 階段完成首次渲染，Steady 階段，應用完成啓動，用戶可以使用完整功能 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;em&gt;各個生命週期狀態在什麼時候觸發呢？&lt;/em&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Starting 狀態&lt;/strong&gt;：在 
 &lt;code&gt;_tryStart&lt;/code&gt;方法中， 
 &lt;u&gt;LifecycleService &lt;/u&gt;類實例化，應用進入 Staring 階段， 
 &lt;strong&gt;在這個階段也會去執行插件的 onStarting 鈎子函數&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Ready 狀態&lt;/strong&gt;：在實例化 
 &lt;u&gt;UniverSheet&lt;/u&gt; 後，在 
 &lt;code&gt;_tryProgressToReady&lt;/code&gt;方法中，設置 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值為 Ready， 
 &lt;strong&gt;在這個階段也會執行各個插件的 onReady 鈎子函數&lt;/strong&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Rendered 狀態&lt;/strong&gt;：在 
 &lt;u&gt;DesktopUIController&lt;/u&gt; 中，bootStrap 整個應用後，標記 
 &lt;u&gt;LifecycleService stage &lt;/u&gt;值為 Rendered 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;Steady 狀態&lt;/strong&gt;：在 Rendered 狀態後，延遲 3000 秒觸發 Steady 狀態 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  通過 @OnLifecycle 註解，我們可以精確控制某個類在什麼生命週期階段實例化，如下： 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {
    //...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼中，SheetRenderController 將在 Rendered 階段實例化 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h2_16"&gt;&lt;/span&gt; 
&lt;h2&gt;啓動到渲染的整個過程&lt;/h2&gt; 
&lt;div&gt; 
 &lt;img alt="" height="400" src="https://oscimg.oschina.net/oscnet/up-92859da81dc29e5183cf26c4e682302d65b.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第一步：&lt;/strong&gt;創建 
 &lt;u&gt;Univer &lt;/u&gt;實例、註冊 sheet 所需的相關插件和創建 univer sheet 實例 
&lt;/div&gt; 
&lt;div&gt;
  註冊的插件及相關功能如下： 
&lt;/div&gt; 
&lt;ul&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-docs：用於單元格和公式的編輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-render：Canvas 渲染引擎，也包含 sheet、doc、slide 所需的基礎組件，負責 Canvas 渲染整個過程 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-sheets：管理 sheet canvas 相關的渲染，如 row header、column header、單元格等，同時也處理大量 sheet 相關業務邏輯 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    base-ui：管理 React DOM 渲染的基礎組件，如菜單相關的組件。同時也負責整個 univer sheet 頁面框架的渲染，以及和用戶交互的操作都會放在這個插件中，如快捷鍵註冊、複製、剪切黏貼等 
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div&gt;
    ui-plugin-sheets：負責一些基礎 UI 的渲染和業務邏輯，如右鍵菜單、單元格富文本編輯相關的任務 
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  插件註冊完成，通過 createUniverSheet 方法，創建 univer sheet 實例 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;/**
 * Create a univer sheet instance with internal dependency injection.
 */
createUniverSheet(config: Partial&amp;lt;IWorkbookConfig&amp;gt;): Workbook {
    let workbook: Workbook;
    const addSheet = () =&amp;gt; {
        workbook = this._univerSheet!.createSheet(config);
        this._currentUniverService.addSheet(workbook);
    };

    if (!this._univerSheet) {
        this._univerSheet = this._rootInjector.createInstance(UniverSheet);

        this._univerPluginRegistry
            .getRegisterPlugins(PluginType.Sheet)
            .forEach((p) =&amp;gt; this._univerSheet!.addPlugin(p.plugin as unknown as PluginCtor&amp;lt;any&amp;gt;, p.options));
        this._tryStart();
        this._univerSheet.init();
        addSheet();

        this._tryProgressToReady();
    } else {
        addSheet();
    }

    return workbook!;
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  通過上面代碼，我們可以看到，univer 將上面註冊的插件中 PluginType.Sheet 類型的插件，重新註冊到了 univerSheet 實例上，然後通過 _tryStart 應用進入 Starting 階段，然後初始化，通過 addSheet 實例化 
 &lt;u&gt;Workbook&lt;/u&gt;，完成了模型層的初始化。到這裏模型數據準備完畢，univer 進入到 Ready 階段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;strong&gt;第二步&lt;/strong&gt;：初始化頁面框架，渲染頁面框架 
&lt;/div&gt; 
&lt;div&gt;
  在上面講述 Univer 應用生命週期時，提到過插件會在 univer 不同的生命週期執行，在這一步，我們重點關注 base-ui 插件 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// base-ui-plugin.ts
override onStarting(_injector: Injector): void {
    this._initDependencies(_injector);
}

override onReady(): void {
    his._initUI();
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt;
    如上代碼，base-ui 插件在 onStarting 階段會去聲明和添加依賴，在 onReady 階段，會去初始化渲染整個頁面框架，將 View 界面掛載到 container 上。 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;pre&gt;&lt;code class="language-javascript"&gt;// ui-desktop.controller.tsx
bootstrapWorkbench(options: IWorkbenchOptions): void {
    this.disposeWithMe(
        bootStrap(this._injector, options, (canvasElement, containerElement) =&amp;gt; {
            this._initializeEngine(canvasElement);
            this._lifecycleService.stage = LifecycleStages.Rendered;
            this._focusService.setContainerElement(containerElement);

            setTimeout(() =&amp;gt; (this._lifecycleService.stage = LifecycleStages.Steady), STEADY_TIMEOUT);
        })
    );
}
// ...
function bootStrap(
    injector: Injector,
    options: IWorkbenchOptions,
    callback: (canvasEl: HTMLElement, containerElement: HTMLElement) =&amp;gt; void
): IDisposable {
    let mountContainer: HTMLElement;
    // ...
    const root = createRoot(mountContainer);
    const ConnectedApp = connectInjector(App, injector);
    const desktopUIController = injector.get(IUIController) as IDesktopUIController;
    const onRendered = (canvasElement: HTMLElement) =&amp;gt; callback(canvasElement, mountContainer);

    function render() {
        const headerComponents = desktopUIController.getHeaderComponents();
        const contentComponents = desktopUIController.getContentComponents();
        const footerComponents = desktopUIController.getFooterComponents();
        const sidebarComponents = desktopUIController.getSidebarComponents();
        root.render(
            &amp;lt;ConnectedApp
                {...options}
                headerComponents={headerComponents}
                contentComponents={contentComponents}
                onRendered={onRendered}
                footerComponents={footerComponents}
                sidebarComponents={sidebarComponents}
            /&amp;gt;
        );
    }

    // ...
    render();
    // ...
}&lt;/code&gt;&lt;/pre&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt;
  在上面代碼可以看到，在頁面框架掛載並渲染完成後，會去完成 canvas 渲染引擎容器掛載及調整 canvas 尺寸，整個應用進入 Rendered 階段 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：渲染 canvas 界面，完成整個渲染過程 
&lt;/div&gt; 
&lt;div&gt;
  其實這個過程在應用 Ready 階段就已經開始了 sheet canvas 的初始化和組件組裝和添加 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-canvas-view.ts
@OnLifecycle(LifecycleStages.Ready, SheetCanvasView)
export class SheetCanvasView {
    // ...
    constructor(
        // ...
    ) {
        this._currentUniverService.currentSheet$.subscribe((workbook) =&amp;gt; {
            // ...
            const unitId = workbook.getUnitId();
            if (!this._loadedMap.has(unitId)) {
                this._currentWorkbook = workbook;
                this._addNewRender();
                this._loadedMap.add(unitId);
            }
        });
    }

    private _addNewRender() {
        // ...
        if (currentRender != null) {
            this._addComponent(currentRender);
        }
        const should = workbook.getShouldRenderLoopImmediately();
        if (should &amp;amp;&amp;amp; !isAddedToExistedScene) {
            engine.runRenderLoop(() =&amp;gt; {
                scene.render();
            });
        }
        // ...
    }

    private _addComponent(currentRender: IRender) {
        // ...
        currentRender.mainComponent = spreadsheet;
        currentRender.components.set(SHEET_VIEW_KEY.MAIN, spreadsheet);
        currentRender.components.set(SHEET_VIEW_KEY.ROW, spreadsheetRowHeader);
        currentRender.components.set(SHEET_VIEW_KEY.COLUMN, spreadsheetColumnHeader);
        currentRender.components.set(SHEET_VIEW_KEY.LEFT_TOP, SpreadsheetLeftTopPlaceholder);
        // ...
        this._sheetSkeletonManagerService.setCurrent({ sheetId, unitId });
    }

    private _addViewport(worksheet: Worksheet) {
        // ...
        scene
            .addViewport(
                viewMain,
                viewColumnLeft,
                viewColumnRight,
                viewRowTop,
                viewRowBottom,
                viewLeftTop,
                viewMainLeftTop,
                viewMainLeft,
                viewMainTop
            )
            .attachControl();
    }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代碼，其實就是 sheet canvas 渲染的整個過程，首先會去訂閲 
 &lt;code&gt;currentSheet$&lt;/code&gt;，如果該 sheet 沒有被 render 過，那麼就會調用 
 &lt;code&gt;_addNewRender&lt;/code&gt; 方法，添加 sheet 所需的 canvas 渲染組件，添加 viewport，然後將 scene 的渲染添加到渲染引擎的渲染循環中（runRenderLoop） 
&lt;/div&gt; 
&lt;div&gt;
  在上面過程，完成了 sheet 所需 canvas 組件的組裝以及添加 viewport，那麼 canvas 的首次渲染髮生在什麼地方呢？和什麼生命週期階段呢？sheet canvas 的渲染被 
 &lt;u&gt;SheetRenderController &lt;/u&gt;類所管理，該類管理了 sheet canvas 的初始化渲染以及監聽 Mutations 的變更，然後按需渲染 Canvas 界面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
@OnLifecycle(LifecycleStages.Rendered, SheetRenderController)
export class SheetRenderController extends Disposable {}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面的代碼可以看到，sheet canvas 的渲染時間點是在整個應用 Rendered 階段，其實也好理解，這個階段，頁面框架才完成掛載到 container 上，同時 sheet canvas 也完成了初始化工作。在 Rendered 階段，會去訂閲 currentSkeleton$ 改變，然後去更新 skeleton，完成頁面首次渲染。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
         his._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                // ...
                if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                         ,
                        true
                    );
                }

                 this._sheetSkeletonManagerService.setCurrent({
                    unitId,
                    sheetId,
                    commandId: command.id,
                });
           }

            this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
        })
    );
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面代碼發生在 
 &lt;u&gt;SheetRenderController &lt;/u&gt;類，在 _commandExecutedListener 方法中，會去監聽 Command 執行，如果在 
 &lt;code&gt;COMMAND_LISTENER_SKELETON_CHANGE&lt;/code&gt; 列表內，標記當前 skeleton 為 dirty，mainComponent 為 dirty，這樣 Canvas 渲染引擎就會在下個渲染循環中重新渲染頁面了 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：單元格編輯器初始化 
&lt;/div&gt; 
&lt;div&gt;
  其實在第三步，基本已經完成了整個 sheet 界面的渲染，我們再來關注一下單元格編輯器的初始化過程。在應用 Rendered 階段，univer 會去初始化兩個 Doc 實例，一個用於單元格的編輯，另一個用於公式輸入框的編輯。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// initialize-editor.controller.ts
private _initialize() {
    this._currentUniverService.createDoc({
        id: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
    // create univer doc formula bar editor instance

    this._currentUniverService.createDoc({
        id: DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
        documentStyle: {},
    });
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  同樣在 Rendered 階段， 
 &lt;u&gt;EditorBridgeController &lt;/u&gt;類實例化時，會去初始化相關的事件監聽，如雙擊單元格，單元格進入編輯模式。但是直到 Steady 階段， 
 &lt;u&gt;StartEditController &lt;/u&gt;類才完成實例化，單元格編輯才能完全可交互 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;肆. 界面如何響應用戶操作？&lt;/h1&gt; 
&lt;div&gt;
  下面的時序圖描述了當用戶點擊 text wrap 菜單項，univer 從響應事件到界面渲染的整個過程 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;img alt="" height="819" src="https://oscimg.oschina.net/oscnet/up-5858c5e9fc2871f877345efca1f3aa5a740.png" width="800" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;div&gt;
  第一步：用戶點擊菜單中 text wrap 菜單項。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // menu.ts
 export function WrapTextMenuItemFactory(accessor: IAccessor): IMenuSelectorItem&amp;lt;WrapStrategy&amp;gt; {
    // ...
    return {
        id: SetTextWrapCommand.id,
        // ...
    };
}
// ToolbarItem.tsx
 &amp;lt;Select
    // ...
    onClick={(value) =&amp;gt; {
        let commandId = id;
        // ...
        commandService.executeCommand(commandId, value);
     }}
     // ...
 /&amp;gt;&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  上面是菜單欄中 text wrap 菜單項的 Select 組件，可以看到在上面綁定了 click 事件處理函數，當點擊後，commandService 將執行 commandId，也就是在 WrapTextMenuItemFactory 中配置的 id 值：SetTextWrapCommand 的 id 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第二步：在 SetTextWrapCommand 中，包裝一下參數，然後執行了統一設置樣式的 Command，SetStyleCommand 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;export const SetTextWrapCommand: ICommand&amp;lt;ISetTextWrapCommandParams&amp;gt; = {
    type: CommandType.COMMAND,
    id: 'sheet.command.set-text-wrap',
    handler: async (accessor, params) =&amp;gt; {
        // ...
        const commandService = accessor.get(ICommandService);
        const setStyleParams: ISetStyleParams&amp;lt;WrapStrategy&amp;gt; = {
            style: {
                type: 'tb',
                value: params.value,
            },
        };
  
        return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    },
};&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第三步：在 SetStyleCommand 中，因為改變了選區內樣式值，所以需要組裝 SetRangeValuesMutation 的參數，比如將選區內所有單元格的 tb 設置為 
 &lt;u&gt;WrapStrategy.WRAP&lt;/u&gt;。由於選區內 text wrap 的改變，同時該行是自動調整行高的，那麼還需要去計算該行的一個 autoHeight，也就是容納該行內容的一個最低高度。計算自動行高之前，需要先執行 SetRangeValuesMutation，因為 autoHeight 計算是依賴於更新後的視圖數據的。 通過 SheetInterceptorService 中註冊的 interceptor 拿到 autoHeight 的值（redos 中） 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt; // set-style.command.ts
 const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
       id: SetStyleCommand.id,
        params,
 });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第四步：之所以上面能夠拿到 autoHeight 的值，主要還是歸因於 
 &lt;u&gt;AutoHeightController &lt;/u&gt;類，該類在 
 &lt;u&gt;LifecycleStages&lt;/u&gt;.Ready 階段被實例化，並且添加了會影響到行自動行高的所有 Command 的攔截，如對 SetStylecommand 攔截。 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
// for intercept set style command.
sheetInterceptorService.interceptCommand({
     getMutations: (command: { id: string; params: ISetStyleParams&amp;lt;number&amp;gt; }) =&amp;gt; {
          if (command.id !== SetStyleCommand.id) {
              return {
                  redos: [],
                  undos: [],
              };
          }
          // ...
          const selections = selectionManagerService.getSelectionRanges();
 
          return this._getUndoRedoParamsOfAutoHeight(selections);
      },
  });&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第五步：因為計算行的自動行高需要用到文檔模型以及單元格佈局的相關計算，所相關計算都放在了管理 
 &lt;u&gt;Spreadsheet&lt;/u&gt; 的 
 &lt;u&gt;SheetSkeleton&lt;/u&gt; 類中 (視圖層)， 通過該類中 
 &lt;code&gt;calculateAutoHeightInRange&lt;/code&gt; 方法最終計算出行的自動行高 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// auto-height.controller.ts
private _getUndoRedoParamsOfAutoHeight(ranges: IRange[]) {
    // ...
    const { skeleton } = sheetSkeletonService.getCurrent()!;
    const rowsAutoHeightInfo = skeleton.calculateAutoHeightInRange(ranges);
    // ...     
}&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;div&gt;
  第六步：當拿到 autoHeight 的數據後，會觸發 SetWorksheetRowHeightMutation。無論是上面觸發的 SetRangeValuesMutation 還是 SetWorksheetRowHeightMutation，都會更改模型層，並且標記 sheetSkeleton 和 mainComponent 為 dirty，在 sheetSkeletion 重新計算佈局等相關渲染所需信息，然後渲染頁面 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code class="language-javascript"&gt;// sheet-render.controller.ts
private _commandExecutedListener() {
    this.disposeWithMe(
        this._commandService.onCommandExecuted((command: ICommandInfo) =&amp;gt; {
            // ...
            if (COMMAND_LISTENER_SKELETON_CHANGE.includes(command.id)) {
                 // ...
                 if (command.id !== SetWorksheetActivateMutation.id) {
                    this._sheetSkeletonManagerService.makeDirty(
                        {
                            unitId,
                            sheetId,
                            commandId: command.id,
                        },
                        true
                    );
                  }
                  // ...
              }
              this._renderManagerService.getRenderById(unitId)?.mainComponent?.makeDirty(); // refresh spreadsheet
         })
     );
 }&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt; 
&lt;div&gt;
  以上就完成了從事件觸發到修改模型層，進而視圖層更新的整個過程 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;span id="OSC_h1_18"&gt;&lt;/span&gt; 
&lt;h1&gt;伍. 更多閲讀&lt;/h1&gt; 
&lt;div&gt;
  如果你想對架構有個整體的瞭解，推薦閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fachitecture.md%23architecture-notes-%25E6%259E%25B6%25E6%259E%2584%25E6%25A6%2582%25E8%25A6%2581" rel="nofollow" target="_blank"&gt;Architecture Notes 架構概要&lt;/a&gt;&lt;/strong&gt;，如果你想了解更多 sheet 的架構和各個模塊的設計和職責，推薦閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fdream-num%2Funiver%2Fblob%2Fdev%2Fdocs%2Fzh%2Fsheet-architecture.md%23univer-sheet-architecture---univer-sheet-%25E6%259E%25B6%25E6%259E%2584" rel="nofollow" target="_blank"&gt;Univer Sheet Architecture - Univer Sheet 架構&lt;/a&gt;&lt;/strong&gt;。如果你對 DI 系統比較陌生，建議，閲讀 Univer 項目中所使用的 DI 框架 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fredi.wendell.fun%2Fzh-CN%2Fdocs%2Fintroduction" rel="nofollow" target="_blank"&gt;redi&lt;/a&gt;&lt;/strong&gt;。項目使用 Rxjs 作為觀察者模式，閲讀 
 &lt;strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Frxjs.tech%2Fguide%2Foverview" rel="nofollow" target="_blank"&gt;Rxjs 相關文檔&lt;/a&gt;&lt;/strong&gt; 
 &lt;strong&gt; &lt;/strong&gt;是快速熟悉 Rxjs 的方式 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/6977969/blog/10142382</link>
      <guid isPermaLink="false">https://my.oschina.net/u/6977969/blog/10142382</guid>
      <pubDate>Sat, 10 May 2025 10:12:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Stability AI 發佈可在端側運行的全新音頻生成模型</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Stability AI &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstability.ai%2Fnews%2Fstability-ai-and-arm-release-stable-audio-open-small-enabling-real-world-deployment-for-on-device-audio-control" target="_blank"&gt;發佈&lt;/a&gt;&lt;/u&gt;了一款名為 Stable Audio Open Small 的音頻生成模型，可在手機端上運行。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-aa977d69f583aa125c61d78628c79f29a64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Hugging Face：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fstabilityai%2Fstable-audio-open-small" target="_blank"&gt;https://huggingface.co/stabilityai/stable-audio-open-small&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 是 Stability AI 與 Arm 公司合作的成果。該模型的訓練集完全由免版稅音頻庫 Free Music Archive 和 Freesound 中的歌曲組成。模型擁有 3.41 億個參數，經過優化可在 Arm CPU 上運行。&lt;/p&gt; 
&lt;p&gt;Stable Audio Open Small 專為快速生成簡短的音頻採樣和音效（如鼓聲和樂器旋律）而設計，Stability AI 公司稱，它可以在 8 秒內在智能手機上生成長達 11 秒的音頻。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350074</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350074</guid>
      <pubDate>Sat, 10 May 2025 10:06:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>因流量持續暴跌，Stack Overflow 尋求品牌重塑</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;編程問答社區 Stack Overflow 開發商表示由於 AI 在回答編程相關問題上更快捷更方便，其網站上的帖子數量正在持續急劇下降，為此他們計劃進行「品牌重塑」。&lt;/p&gt; 
&lt;p&gt;根據官方統計數據，2025 年 4 月發佈的問題和答案總數與 2024 年同期下降了超過 64%，與 2020 年 4 月（當時流量接近峯值）相比下降了超過 90%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-01d9e19775d998a0fa483d562a1a6b782e2.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;CEO Prashanth Chandrasekar 表示公司考慮在問答功能外加入社區和職業發展服務。該公司已在試驗多項新服務，包括 AI Answer Assistant 和 Question Assistant，以及與 Indeed 合作的招聘網站等。&lt;/p&gt; 
&lt;p&gt;Stack Overflow 品牌廣為人知，為什麼還要進行品牌重塑？官方帖子提到了 AI 正在「重塑我們構建、學習和解決問題的方式」，並且該公司似乎正在尋找新的方式來提供價值（並推動業務）。&lt;/p&gt; 
&lt;p&gt;在這種情況下，許多用戶並不認為品牌重塑是答案。有用戶&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reddit.com%2Fr%2Fprogramming%2Fcomments%2F1km8mbc%2Fstack_overflow_seeks_rebrand_as_traffic_continues%2F" target="_blank"&gt;表示&lt;/a&gt;&lt;/u&gt;，「沒有 DevOps、系統管理員、C/C++/Python/Rust/Java 程序員、數據庫管理員或其他頻繁使用 Stack Overflow 的用戶關心品牌，現有的網站就很好」，&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350064/stack-overflow-seeks-rebrand-as-traffic-continues-to-plummet</guid>
      <pubDate>Sat, 10 May 2025 09:30:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>從編譯器、遊戲引擎到遊戲掌機，我是這樣做獨立遊戲的</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;h2&gt;引言&lt;/h2&gt; 
&lt;p&gt;  自己開發製作遊戲是一個兒時起就有的夢，特別是長時間接觸魔獸爭霸 3 世界編輯器後，我對遊戲引擎和開發工具也有着特別的興趣。學生時代接觸編程以後，夢的外延開始擴散，不滿足於使用各式編程語言做開發，開始維護一門自己喜歡的寫遊戲業務邏輯的編程語言項目 Yuescript，因為學習圖形學和作為練手項目重寫 Cocos2d-x 有了 Dora SSR 遊戲引擎。工作後因為對遊戲掌機的喜愛，開始與夥伴合作研發自由開放的可編程遊戲掌機設備——吉祥機，實現自己遊戲夢終極的 Digital Freedom。&lt;/p&gt; 
&lt;h2&gt;遊戲腳本語言的樂趣與挑戰&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-715e7bd07ab1f0fb9a982d2c625f69f9fef.png" alt="編程語言遊樂場！" title="編程語言遊樂場！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  各式新的編程語言的學習過程是充滿樂趣的，對不同語言工具的接觸也會感受到不同的編程理念和程序設計思想。為了學習製作遊戲，對於複雜多變遊戲玩法的腳本編程（Scripting），我也形成了自己編程偏好，即使用一門儘可能簡潔和表達力強的編程語言來編寫容易變化的業務邏輯。可以轉譯為 Lua 語言執行的 Yuescript 語言開源項目就是我為了滿足這個需求的產物。後來隨着使用自己的 Dora SSR 遊戲引擎遇到更多的遊戲開發場景，我又為 Dora SSR 開源遊戲引擎引入了 Teal（為 Lua 語言添加靜態類型檢查能力的語言）、Typescript（進一步增強代碼編輯器提示和代碼檢查的語言）、TSX 和 XML（提供描述性代碼進行組件化開發的語言）等等。每一種腳本語言都能在特定的遊戲開發場景發揮優勢，並通過轉譯到最終運行的、同樣的 Lua 語言進行無縫的互通調用。不只是基於 Lua 語言的擴展，Dora SSR 遊戲引擎項目還在嘗試通過 WASM 虛擬機來支持更加多樣的可以用做遊戲腳本編程的語言，如 Rust 和準備支持的 C++ 和 Go 等，兼顧性能與引擎的運行時擴展能力。&lt;/p&gt; 
&lt;h2&gt;遊戲引擎的創新之路&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-d13c83fb9e85ab500bfc4a52c25c25488be.png" alt="隨時隨地用任何設備製作遊戲！" title="隨時隨地用任何設備製作遊戲！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  説到遊戲引擎大家總是想到高性能高質量的圖形渲染，搭建複雜的遊戲場景。實際上作為獨立遊戲開發者，或是遊戲製作的愛好者，並不是人人都有條件追求 3A 遊戲的製作能力（可能會缺少鈔能力）。我認為很多 2D 遊戲或是 2D 混合 3D 效果的遊戲也能表達展現十分有創意和獨特的遊戲作品。而且能運行自己製作遊戲的終端最好是不受限制的，再進一步，也許能用於開發遊戲的終端和操作系統也可以是不受限制的。所以就有了 Dora SSR 開源遊戲引擎的項目目標，在儘可能多的設備上為遊戲開發愛好者提供便捷易用的環境甚至是遊戲開發 IDE。&lt;/p&gt; 
&lt;p&gt;  一直以來遊戲開發這件事也成為了我的個人生活的一個日常的部分。哪怕只有碎片化的時間和手邊隨機可用作遊戲開發和運行的設備，我也想有空就利用起來碎片化地寫兩行遊戲代碼，或是調試一個遊戲功能，並把它變成了一種比較隨性和愜意的休閒娛樂活動。&lt;/p&gt; 
&lt;p&gt;  所以我也嘗試了在 Dora SSR 上搭建了通過遊戲引擎運行時內置用於遊戲開發的 Web IDE 服務器，可以通過其它方便做輸入的設備通過 Web 瀏覽器做訪問，並實現直接在任意的終端設備上直接編寫運行和調試遊戲程序代碼的體驗。同時用戶能獲得代碼編輯器可視提示服務、以及使用其它遊戲開發和資源管理的可視化工具。目前 Dora SSR 在努力之下已具備了在 Windows、macOS、iOS、Android、多個 Linux 發行版上進行遊戲開發的能力。&lt;/p&gt; 
&lt;h2&gt;向着自由開放的遊戲掌機夢想邁進&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1a4efb08595713fcf90d5b06eecbe82f151.png" alt="開源開放？軟件和硬件全都要！" title="開源開放？軟件和硬件全都要！" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  到此我覺得對遊戲開發能力的自由和開放體驗的追求還遠不到盡頭。作為喜好各式掌機的老玩家，在體驗了諸多國產開源掌機的商業產品後，我感覺深深的不滿足。用掌上游戲機玩遊戲目前還是在卷硬件參數和外觀設計來提供體驗的差異化，而我期待的掌機並不只是玩遊戲上的體驗，還應該是一個可以用來自由的開發、運行甚至發行自制遊戲的設備。很多掌機廠商都有自己的商業化模式和獲得盈利的閉環，所以不會允許硬件設備獲得太多可編程定製的能力。於是和同樣對硬件發燒的夥伴一起研究構建了完全自由開放的掌機設備。並儘可能提供包括機器的計算核心、外設和外觀均可進行模塊化的定製和更換的能力（使科技不再以換殼為本）。於是又有了叫做「吉祥機」的項目。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-677fa26ccf81393c62a89ff15e0179e68e1.png" alt="吉祥機 + Dora SSR 遊戲引擎" title="吉祥機 + Dora SSR 遊戲引擎" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-563f088864ac8a58e6b9687daf303f6fcae.png" alt="不只是掌機和移動編程設備，「吉祥機」也是提供 GPIO + SPI + I2C 接口的外設開發板" title="不只是掌機和移動編程設備，「吉祥機」也是提供 GPIO + SPI + I2C 接口的外設開發板" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h2&gt;回到遊戲創作的初心&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1f5689f94e27f1b3cf208904e76c8041731.jpg" alt="社區在做的開源獨立遊戲項目《靈數奇緣》" title="社區在做的開源獨立遊戲項目《靈數奇緣》" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;  所以折騰了半天我們的遊戲到底做出來了沒有呢？答案當然是做了，但沒完全做出來啦。在生成式 AI 大模型進入徹底火爆前夕的 2020 年，我們就想象了這樣一個關於未來的 AI 的遊戲故事，在未來人的物質需求已經得到完全滿足，人生下來的目的只剩下了通過進行遊戲娛樂，並通過採集在遊戲過程體現人創造力和展現智慧的交互數據給 AI 用做訓練材料。人生的價值都是由未來的銀行（數據銀行），通過評估在遊戲活動中人所創造的智能數據的質量和價值，來進行貨幣分配和評定的。最終數據訓練出的 AI，則會幫助人完成一切的物質生產，從人類個體的養育到社會治理。遊戲的劇情會探索在這樣的設定背景下，人類會有什麼樣的故事。最後遊戲輸出的價值觀就是人生來就應該是改造世界的主體，而不是隻會適應一切現狀的被改造的客體。也呼應了我和我的夥伴們一直在現實中追尋的東西，想要不被與生俱來的一切所定義，就靠自己的主動創造去重新定義一切。&lt;/p&gt; 
&lt;p&gt;  如果對我們在做的編程語言、遊戲引擎、遊戲掌機或是開源獨立遊戲項目感興趣，歡迎 Star 我們的倉庫或是進入我們的 Q 羣一起聊聊。目前的項目都還在逐漸完善的階段，但是幾個項目都會互相整合和驗證迭代，關注我們也可以及時看到我們的項目是怎麼做的以及目前的進展。&lt;/p&gt; 
&lt;h3&gt;項目地址&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;遊戲引擎：&lt;br&gt; &lt;a href="https://gitee.com/pig/Dora-SSR"&gt;https://gitee.com/pig/Dora-SSR&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FIppClub%2FDora-SSR" target="_blank"&gt;https://github.com/IppClub/Dora-SSR&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Yuescript 語言：&lt;br&gt; &lt;a href="https://gitee.com/pig/Yuescript"&gt;https://gitee.com/pig/Yuescript&lt;/a&gt;&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpigpigyyy%2FYuescript" target="_blank"&gt;https://github.com/pigpigyyy/Yuescript&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;《靈數奇緣》開源遊戲項目：&lt;br&gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fluv-sense-digital.readthedocs.io" target="_blank"&gt;https://luv-sense-digital.readthedocs.io&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;遊戲開發及掌機交流 Q 羣：512620381&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4925410/blog/11049342</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4925410/blog/11049342</guid>
      <pubDate>Sat, 10 May 2025 09:29:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>DeepSeek 新論文公開 V3 大模型降本方法</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;DeepSeek 團隊近日發表了新論文《Insights into DeepSeek-V3: Scaling Challenges and Reflections on Hardware for AI Architectures》，把 DeepSeek-V3 在訓練和推理過程中，如何解決「硬件瓶頸」的方法公佈了出來。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/165038_St64_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;論文主要介紹了 DeepSeek-V3 在硬件架構方面的挑戰和創新，以及如何通過軟硬件協同設計實現高效訓練和推理。&lt;/p&gt; 
&lt;p&gt;關鍵結論&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;內存效率：DeepSeek-V3 通過 MLA 將 KV 緩存大小顯著減少到每個 token 僅需 70 KB，遠低於其他模型（如 Qwen-2.5 72B 的 327 KB 和 LLaMA-3.1 405B 的 516 KB）。這使得模型更適合處理長文本和資源受限的環境。&lt;/li&gt; 
 &lt;li&gt;成本效益：MoE 架構允許在訓練時僅激活部分參數，從而顯著降低計算需求。例如，DeepSeek-V3 在擴展到 671B 參數時，每個 token 的激活參數僅為 37B，相比全參數激活的密集模型（如 72B 的 Qwen 和 405B 的 LLaMA），計算成本大幅降低。&lt;/li&gt; 
 &lt;li&gt;推理速度：通過重疊計算和通信以及多令牌預測模塊，DeepSeek-V3 在推理時能夠顯著提高吞吐量和響應速度。例如，多令牌預測模塊可以將生成速度提高 1.8 倍。&lt;/li&gt; 
 &lt;li&gt;低精度計算：FP8 混合精度訓練在 DeepSeek-V3 中首次應用於大規模模型訓練，通過細粒度量化策略，相對 BF16 的精度損失控制在 0.25% 以內。&lt;/li&gt; 
 &lt;li&gt;網絡優化：採用多平面兩層 Fat-Tree 網絡拓撲，相比傳統的三層 Fat-Tree 拓撲，顯著降低了網絡成本，並提高了網絡的魯棒性和可擴展性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;論文還提出了對未來 AI 硬件的建議和展望。詳情查看：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fpdf%2F2505.09343" target="_blank"&gt;https://arxiv.org/pdf/2505.09343&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350049</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350049</guid>
      <pubDate>Sat, 10 May 2025 08:52:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>vivo 開啓頂尖人才招募計劃：涉及芯片、AI 大模型等領域，稱薪酬上不封頂</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;vivo 近日啓動了一項名為「藍極星計劃」的頂尖人才招募項目。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1099" src="https://static.oschina.net/uploads/space/2025/0515/164047_c20b_2720166.png" width="750" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;招募信息顯示，藍極星計劃的定位為 vivo 最核心的人才戰略方案，面向全球高校頂尖技術人才。在待遇方面，vivo 承諾薪酬上不封頂。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164121_udGF_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164136_65kU_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/164149_53FG_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;不過，藍極星計劃的門檻也很高，僅向博士生開放。此次招募的崗位涉及 XR、AI 大模型、影像、芯片、器件開發等核心技術領域，崗位類型十餘個。總體招募規模在百人左右，其中以影像方向名額最多。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350047</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350047</guid>
      <pubDate>Sat, 10 May 2025 08:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Ruby 已合併新的即時編譯器 ZJIT</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;ZJIT 是一個新的即時編譯器（JIT），由與開發 YJIT 的同一編譯器團隊構建到參考 Ruby 實現 YARV 中，該工具目前已合併到 Ruby。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;相關閲讀&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/231919/ruby-rjit" target="news"&gt;Ruby 引入新 JIT 編譯器 RJIT，替代 MJIT&lt;/a&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/news/192164/rust-jit-for-ruby" target="news"&gt;Ruby 的新 YJIT 編譯器已完成，使用 Rust 重新實現&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;ZJIT 在多個方面與 YJIT 有所不同：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;它不是直接將 YARV 字節碼編譯成低級中間表示（LIR），而是使用基於高級單賦值（SSA）的中間表示（HIR）&lt;/li&gt; 
 &lt;li&gt;它不是一次編譯一個基本塊，而是每次編譯一個完整的方法&lt;/li&gt; 
 &lt;li&gt;它不是使用懶惰基本塊版本化（LBBV）來分析類型，而是從已分析的解釋器中讀取歷史類型信息&lt;/li&gt; 
 &lt;li&gt;與在將 YARV 降低到 LIR 時進行優化不同，它有一個工作在 HIR 上的高級模塊化優化器&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;從高層次來看，ZJIT 接收 YARV 字節碼，構建中間表示（IR），進行一些優化，並生成機器碼。簡化來説，它看起來像這樣：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/162351_2fb3_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下示例為 Ruby 程序通過完整的編譯器管道：&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-ruby"&gt;# add.rb
def add(left, right)
  left + right
end

p add(1, 2)
p add(3, 4)&lt;/code&gt;&lt;/pre&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350040/ruby-merge-zjit</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350040/ruby-merge-zjit</guid>
      <pubDate>Sat, 10 May 2025 08:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>騰訊元寶推出 Chrome 瀏覽器插件</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;騰訊元寶上線了瀏覽器插件，可以在 Chrome 應用商店下載。安裝之後，在網頁上就能劃詞提問、總結內容、翻譯外文網頁，看到重要信息還能一鍵收藏，所有收藏的內容都會同步，方便之後接着問、繼續看。&lt;/p&gt; 
&lt;p&gt;開啓元寶插件後，頁面右側會有一個懸浮球，點擊就能用元寶；右側的側邊欄，支持截圖提問、上傳文件、搜索內容等操作，適合在瀏覽網頁時順手處理信息。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-38991e82b9d30a95f1547c862cbb75f202b.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-477743ad0ecf29d37287fdaab5a391134a8.png" referrerpolicy="no-referrer"&gt; &lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ed86f3ccf817ebd7d6844d987868865c677.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;下載地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fyuanbao.tencent.com%2Fdownload" target="_blank"&gt;https://yuanbao.tencent.com/download&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350035</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350035</guid>
      <pubDate>Sat, 10 May 2025 08:05:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Databricks 官宣收購開源數據庫引擎初創公司 Neon</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美國數據公司 Databricks&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.databricks.com%2Fblog%2Fdatabricks-neon" target="_blank"&gt;宣佈&lt;/a&gt;已達成協議收購 Neon，這是一家以開發者為核心、提供無服務器 Postgres 解決方案的公司。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-4671779d822a78c6be19b9199b6bae1e524.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該公司表示，Neon 的聯合創始團隊是全球極少數能夠重構 Postgres 數據庫架構、實現真正存儲與計算分離的團隊，這支由 Postgres 技術專家和數據庫資深人士組成的團隊將加入 Databricks，致力於在 AI 原生時代為開發者提供生產級規模的無服務器 Postgres 服務。&lt;/p&gt; 
&lt;p&gt;Databricks 在公告提到，當 Neon 去年正式發佈時，他們注意到一個有趣的數據：30% 的數據庫是由 AI Agent 創建的，而不是人類。當他們最近再次查看統計數據時，這個數字從 30% 上升到了 80% 以上。也就是説，AI Agent 創建的數據庫數量是人類的四倍。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ec3bf200a942ba01e9a5788c048a3386cd3.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Neon 的約 140 名員工將在交易完成後加入 Databricks。Databricks 表示，在短期內，該初創公司將保持獨立，但從長期來看，將會整合到 Databricks 平台中。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/348379/scoop-databricks-talks-to-acquire-neon" target="_blank"&gt;Databricks 正洽談以約 10 億美元收購開源數據庫初創公司 Neon&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/246894/databricks-strikes-1-3-billion-deal-for-mosaicml" target="news"&gt;大數據巨頭 Databricks 斥資 13 億美元收購 MosaicML&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350031/databricks-acquires-neon</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350031/databricks-acquires-neon</guid>
      <pubDate>Sat, 10 May 2025 07:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬化騰：微信有可能形成獨特 Agent AI 生態</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;昨天，&lt;a href="https://www.oschina.net/news/349982"&gt;騰訊公佈了 2025 年第一季度財報&lt;/a&gt;，總營收 1800 億元，同比增長 13%。毛利為人民幣 1000 億元，同比增長 20%，淨利潤為 497 億元，同比增長 17%。&lt;/p&gt; 
&lt;p&gt;在財報電話會議上，AI 成為了分析師們重點關切的話題。騰訊 CEO 馬化騰、騰訊總裁劉熾平做了詳細解讀和提問。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151017_3gSe_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/151007_rkWf_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;馬化騰在回答分析師提問時表示，每個人都可以做通用的智能體，但與此同時，也有一種智能體可以存在於微信內部以及微信獨特的生態系統中。&lt;/p&gt; 
&lt;p&gt;馬化騰強調，「我認為這是兩種不同的產品。」&lt;/p&gt; 
&lt;p&gt;馬化騰表示，對於通用的智能體，騰訊正在公司的一些 AI 原生產品，例如，元寶和 Ima 等，中創建這種能力。在最初階段，這些 AI 產品可能只是非常快速地回答問題，然後隨着時間推移，它們開始包含思維鏈、長鏈路思考、推理模型，可以回答複雜的問題，再往後可以做更復雜的自動化任務。騰訊會繼續發展這類產，但與我們同行提供的其他智能體沒有太大區別。&lt;/p&gt; 
&lt;p&gt;馬化騰認為，在微信生態系統內，騰訊有機會創建一個非常獨特的智能體。它與微信生態系統的獨特組成部分相連接，包括社交圖譜、通信和社區能力、內容生態系統（如公眾號和視頻號），以及微信內數百萬個小程序。&lt;/p&gt; 
&lt;p&gt;這些小程序實際上涉及各種信息以及跨越許多不同垂直應用的交易和操作能力。因此，為與其它更通用的智能體相比，這將是非常獨特的。這對騰訊來説是一個非常差異化的產品&lt;/p&gt; 
&lt;p&gt;對於 AI 的商業模式，馬化騰認為，通過 AI 提升廣告收入存在巨大的機會，雖然 GPU 租賃與雲業務直接相關，但這部分業務主要是轉售 GPU，在騰訊內部優先級較低。馬化騰還認為，在中國，用戶都在免費獲取 AI 服務，訂閲模式不會是中國 AI 的主流商業模式。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350025</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350025</guid>
      <pubDate>Sat, 10 May 2025 07:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Eclipse Vert.x 5 發佈！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;我們非常高興地宣佈 Vert.x 5 的發佈。&lt;/p&gt; 
&lt;h2&gt;Vert.x 5 有哪些新功能？&lt;/h2&gt; 
&lt;p&gt;Vert.x 5 是 Vert.x 4.x 系列的進化版本，為 Vert.x 帶來了&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fblog%2Fwhats-new-in-vert-x-5%2F" target="_blank"&gt;重要功能&lt;/a&gt;。&lt;/p&gt; 
&lt;h2&gt;從 Vert.x 4 到 Vert.x 5 升級&lt;/h2&gt; 
&lt;p&gt;Vert.x 5 在 Vert.x 4 的基礎上添加了一系列新功能，同時提供了與 Vert.x 4 一致的使用體驗：Vert.x 4 的用戶在使用 Vert.x 5 時會感到非常熟悉。&lt;/p&gt; 
&lt;p&gt;你可以瞭解更多關於從 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fblog%2Ffrom-vert-x-4-to-vert-x-5%2F" target="_blank"&gt;Vert.x 4 遷移到 Vert.x 5&lt;/a&gt; 的信息。&lt;/p&gt; 
&lt;h2&gt;沒有社區，我們一無所有&lt;/h2&gt; 
&lt;p&gt;正是&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fcommunity%2F" target="_blank"&gt;社區&lt;/a&gt;的努力，讓 Vert.x 5 成為了現實。&lt;/p&gt; 
&lt;p&gt;特別感謝 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmichelkraemer.com%2F" target="_blank"&gt;Michel Krämer&lt;/a&gt;，他是這個令人驚歎的網站的創建者。&lt;/p&gt; 
&lt;h2&gt;最後&lt;/h2&gt; 
&lt;p&gt;5.0.0 的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvert-x3%2Fwiki%2Fwiki%2F5.0.0-Release-Notes" target="_blank"&gt;發行説明&lt;/a&gt;以及&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvert-x3%2Fwiki%2Fwiki%2F5.0.0-Deprecations-and-breaking-changes" target="_blank"&gt;廢棄和重大更改的信息&lt;/a&gt;可以在 wiki 中找到。&lt;/p&gt; 
&lt;p&gt;你可以使用 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstart.vertx.io%2F" target="_blank"&gt;start.vertx.io&lt;/a&gt; 來啓動一個 Vert.x 5 項目。&lt;/p&gt; 
&lt;p&gt;發佈的構件已經部署到了 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsearch.maven.org%2Fsearch%3Fq%3Dg%3Aio.vertx%2520AND%2520v%3A5.0.0" target="_blank"&gt;Maven Central&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40vertx%2Feventbus-bridge-client.js" target="_blank"&gt;Vert.x 4 的事件總線 JavaScript 客戶端庫&lt;/a&gt;現在可以在一個單一的位置獲取，並且它現在可以單獨使用，也可以輕鬆集成到任何前端構建工具中。&lt;/p&gt; 
&lt;p&gt;就這些！祝你編碼愉快，並期待在我們的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fvertx.io%2Fchannels" target="_blank"&gt;用戶或開發者頻道&lt;/a&gt;中很快見到你。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350023/eclipse-vert-x-5-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350023/eclipse-vert-x-5-released</guid>
      <pubDate>Sat, 10 May 2025 07:06:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>Anthropic 或將發佈新模型，已開始內部安全測試</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.testingcatalog.com%2Fnew-claude-neptune-model-undergoes-red-team-review-at-anthropic%2F" target="_blank"&gt;據 TechingCatalog 報道&lt;/a&gt;&lt;/u&gt;，Anthropic 正在對一個名為「claude-neptune」的新 AI 模型進行安全測試。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-708826a51d39b3ae8c7c5212b0c223fa837.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;本次測試即將持續到 5 月 18 日，主要是測試該模型對於越獄嘗試的防範性。新模型將使依賴 Claude 進行安全、高性能推理的開發人員、研究人員和企業用戶受益匪淺，尤其是在代碼生成和技術研究等領域，Claude 在這些領域的評估中一直保持強勢。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-411a072df13c279a6cb41be11b7b27d7637.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Anthropic 可能會在 5 月底或者 6 月初發布 Neptune 模型，與 OpenAI 以及谷歌展開正面對決。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350021/anthropic-new-claude-neptune-model</guid>
      <pubDate>Sat, 10 May 2025 06:59:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Canonical 今年將向開源開發者提供超過 10 萬美元的捐款</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Canonical 宣佈，將在未來一年向開源開發者捐贈 12 萬美元。該公司計劃從 4 月份發放的第一筆款項開始，每月捐贈 1 萬美元，持續 12 個月。這些資金將通過&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fthanks.dev%2F" target="_blank"&gt;thanks.dev 平台&lt;/a&gt;進行分配。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-60dfdea453b94c8e5e86c25d88085ea5029.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;該計劃旨在為 Canonical 所依賴的小型上游開源項目提供資金支持。除了 Canonical 對 Eclipse 基金會、雲原生計算基金會 (CNCF) 和 GNOME 基金會等主要開源基金會的持續支持之外，該計劃也是一種回饋社會的額外方式。&lt;/p&gt; 
&lt;p&gt;Thanks.dev 的工作原理是分析公司 GitHub 代碼庫和依賴關係樹（深度可達三層），並根據依賴關係的使用頻率，通過算法分配捐款。Canonical 表示，它可以在編程語言層面調整資金的權重，以更好地反映資金的使用情況。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcoverage.readthedocs.io%2F" target="_blank"&gt;Canonical 使用了一些開發者的項目，例如編寫了 coverage.py 的&lt;/a&gt;nedbat 和&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fadamchainz%2Ftime-machine" target="_blank"&gt;維護 Ubuntu 網站使用的庫 time-machine 的&lt;/a&gt;adamchainz&amp;nbsp;。該公司表示，即使是微小的認可或資金支持，對開源開發者來説也意義非凡。這是對這些項目幕後工作的讚賞。Canonical 的大部分代碼都是開源的，並在 GitHub 和 Launchpad 等平台上公開開發。&lt;/p&gt; 
&lt;p&gt;該公司還指出，thanks.dev 正在努力添加對檢查 Launchpad 上託管的依賴項的支持。&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fubuntu.com%2Fblog%2Fcanonical-thanks-dev-giving-back-to-open-source-developers" target="_blank"&gt;此公告&lt;/a&gt;是在最近發佈的 Ubuntu 25.04「Plucky Puffin」之後發佈的，這是一個臨時版本，包含許多受益於活躍的上游開發的新開源組件，例如 GNOME 4.8 桌面和 Linux 內核 6.14。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350018</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350018</guid>
      <pubDate>Sat, 10 May 2025 06:42:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>在微軟任職 18 年的資深 TypeScript 工程師被裁員</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;微軟近期進行了&lt;a href="https://www.oschina.net/news/349773/microsoft-is-cutting-3percent-of-workers"&gt;全球裁員&lt;/a&gt;，約 6,000 名員工受到影響，佔其全球員工總數的近 3%。其中包括資深 TypeScript 工程師 Ron Buckton。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/114444_6gWh_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Frbuckton%2Fstatus%2F1922364558426911039" target="_blank"&gt;https://x.com/rbuckton/status/1922364558426911039&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Ron Buckton 在微軟工作了 18 年，其中近 10 年致力於 TypeScript 的開發。&lt;/p&gt; 
&lt;p&gt;兩個月前，TypeScript、C#、Delphi 語言之父 Anders Hejlsberg 宣佈了「&lt;a href="https://www.oschina.net/news/338304/typescript-native-port"&gt;10x Faster TypeScript&lt;/a&gt;」項目——將 TypeScript 編譯器以及工具鏈將移植到 Go 語言，性能提升高達 10 倍！&lt;/p&gt; 
&lt;p&gt;該項目由 Anders Hejlsberg 主導，Ron Buckton 則是其中核心開發者。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img height="2070" src="https://static.oschina.net/uploads/space/2025/0515/115256_8t1n_2720166.png" width="2806" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmicrosoft%2Ftypescript-go%2Fgraphs%2Fcontributors" target="_blank"&gt;https://github.com/microsoft/typescript-go/graphs/contributors&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;目前，該項目還在進展中，然而其核心成員已經被解僱了。作為 TypeScript 核心開發者，Ron 的離開也讓大家對微軟此次裁員的標準和背後的決策邏輯產生了疑問。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115906_rOTp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;有人諷刺地説：「被裁要麼是你工作太差，要麼是太優秀——如果不是前者，那就只能是後者。」甚至有人調侃道，「10 倍工程師實現了 10 倍性能提升後被裁，HR AI 宣佈：‘價值已提取，執行終止。’」&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0515/115558_zk7j_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;閲讀更多：&lt;a href="https://www.oschina.net/news/338304/typescript-native-port" target="news"&gt;TypeScript 編譯器和工具鏈將移植到 Go：性能提升 10 倍&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</link>
      <guid isPermaLink="false">https://www.oschina.net/news/350003/ms-lays-off-typescript-veteran-in-latest-job-cuts</guid>
      <pubDate>Sat, 10 May 2025 03:56:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
