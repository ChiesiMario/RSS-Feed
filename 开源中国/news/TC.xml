<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Fri, 25 Apr 2025 02:38:08 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>蘋果重組管理層，AI 與機器人項目分離</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;彭博社援引知情人士&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-04-24%2Fapple-to-strip-secret-robotics-unit-from-ai-chief-weeks-after-moving-siri%3Fsref%3D9hGJlFio&quot; target=&quot;_blank&quot;&gt;消息稱&lt;/a&gt;，蘋果計劃本月晚些時候將機器人團隊從約翰・賈南德雷亞（John Giannandrea）的人工智能部門遷至硬件部門，這將使該團隊由負責硬件工程的高級副總裁約翰·特努斯（John Ternus）領導。&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#000000&quot;&gt;這是該公司為應對人工智能困境而做出的最新舉措。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;319&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3a576590969975d61dbf66d43c5fe0e7cc1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;據瞭解，賈南德雷亞之前同時管理多個項目，包括蘋果的人工智能助手 Siri 和機器人團隊。但由於蘋果在 Siri 的功能交付上未能按時實現目標，導致公司決定對管理架構進行調整。現在，負責蘋果首款空間計算設備 Vision Pro 的邁克・羅克韋爾（Mike Rockwell）將接手 Siri 團隊及其未來的發展工作。這一決定旨在讓賈南德雷亞能更集中精力開發新的人工智能功能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;與此同時，蘋果的機器人項目也將從賈南德雷亞的管理範圍中剝離，交由蘋果的高級副總裁約翰・特努斯（John Ternus）負責。特努斯是蘋果公司的高管之一，參與過多款重要產品的硬件開發工作，包括 iPhone 和 iPad 等。他將領導機器人項目的硬件開發工作，以加快蘋果在這一領域的進展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，特努斯還負責一個從事機器人和智能家居技術研發的團隊，這意味着蘋果將兩支機器人團隊合併，進一步加強了在機器人技術方面的研發力度。蘋果希望通過此次管理層的調整，能夠在人工智能領域追趕上谷歌、OpenAI 等競爭對手，確保 Apple Intelligence 的優先發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;據瞭解，蘋果的機器人團隊正在開發多款新產品，其中包括一款能夠移動的桌面機器人，預計將是該團隊的首個成果。此外，蘋果還計劃推出一種更具移動性的機器人，能夠執行簡單任務，打電話和回答問題等。這樣的新產品將進一步擴展蘋果的產品線，滿足消費者的多樣化需求。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346484</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346484</guid>
            <pubDate>Fri, 25 Apr 2025 02:12:47 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>YouTube 誕生二十週年，平台視頻上傳量超過 200 億</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;YouTube 成立於 2005 年 2 月 14 日，4 月 24 日 UTC 時間凌晨 3 點 31 分 52 秒，聯合創始人 Jawed Karim 上傳了該平台的第一個視頻《&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DjNQXAC9IVRw&quot; target=&quot;_blank&quot;&gt;我在動物園（Me at the Zoo）&lt;/a&gt;&lt;/em&gt;》，雖然只有 19 秒鐘，但象徵着視頻新時代的開始。這個由谷歌擁有的平台已經成長為一個視頻內容的超級帝國。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/191531_tDAs_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;20 年後，YouTube &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.youtube%2Fnews-and-events%2Fhappy-birthday-youtube-20%2F&quot; target=&quot;_blank&quot;&gt;公佈了一系列驚人的數據&lt;/a&gt;：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;視頻上傳量超過 &amp;nbsp;200 億&lt;/li&gt; 
 &lt;li&gt;每天上傳的視頻超過 2000 萬（2025 年 3 月數據）&lt;/li&gt; 
 &lt;li&gt;用戶平均每天發表的評論數超過 1 億（2024 年）&lt;/li&gt; 
 &lt;li&gt;創作者每天平均收到 1000 萬觀眾的「點贊」評論&lt;/li&gt; 
 &lt;li&gt;YouTube 視頻每天平均獲得超過 35 億個「點贊」&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-38b09920f8c3903fc0de33d6ad55864333f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;為了慶祝 20 週年，YouTube 宣佈了幾項即將推出的新功能。在未來幾周內，YouTube TV 訂閲用戶將能夠創建自己的多視圖界面，涵蓋部分非體育內容，並計劃在未來幾個月內逐步擴大頻道範圍。&lt;/p&gt; 
&lt;p&gt;此外，YouTube 將在今年晚些時候向更多創作者推出「語音回覆」評論的功能，此前該功能已於 2024 年在小範圍內試用。&lt;/p&gt; 
&lt;p&gt;除了新功能外，YouTube 還為 20 週年設計了一些有趣的彩蛋。例如，平台推出了一個特別的「Yoodle」（YouTube 版的 Google Doodle），用戶點擊該標誌時，會聽到 Rick Astley 的《Never Gonna Give You Up》的混音版，這首歌也是「十億觀看俱樂部」的成員之一。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346420/happy-birthday-youtube-20</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346420/happy-birthday-youtube-20</guid>
            <pubDate>Sun, 13 Apr 2025 11:17:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Harmony 鴻蒙路由框架：TheRouter 開源</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 是一個用於移動端 APP，包括 Android、iOS、Harmony 三端的模塊化、組件化開發的一整套解決方案框架。提供了三端高一致性，對移動端開發者更友好，讓開發人員更適應，使用起來也更順手。在鴻蒙上， TheRouter 基於 HMRouter 做了深度定製，不僅支持平台化應用實現組件化、跨模塊調用、動態化等功能的集成等功能基礎上，還提供了編譯時安全檢查、支持動態路由下發與修改、路由 Path 一對多等高度動態能力。&lt;/p&gt; 
&lt;p&gt;Github: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FHuolalaTech%2Fhll-wp-therouter-harmony%2F&quot; target=&quot;_blank&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-harmony/&lt;/a&gt;&lt;br&gt; 官網：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Ftherouter.cn%2F&quot; target=&quot;_blank&quot;&gt;http://therouter.cn/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;TheRouter Harmony 核心功能具備如下能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;頁面導航跳轉能力 (Navigator)&lt;/li&gt; 
 &lt;li&gt;跨模塊依賴注入能力 (ServiceProvider)&lt;/li&gt; 
 &lt;li&gt;動態化能力 (ActionManager)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;一、為什麼要使用 TheRouter&lt;/h3&gt; 
&lt;p&gt;路由是現如今移動端開發中必不可少的功能，尤其是企業級 APP，可以用於將多模塊頁面跳轉的強依賴關係解耦，同時減少跨團隊開發的互相依賴問題。&lt;/p&gt; 
&lt;p&gt;對於大型 APP 開發，基本都會選用模塊化 (或組件化) 方式開發，對於模塊間解耦要求更高。 &lt;code&gt;TheRouter&lt;/code&gt; 是一整套完全面向模塊化開發的解決方案，不僅能支持常規的模塊依賴解耦、頁面跳轉，同時提供了模塊化過程中常見問題的解決辦法。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;1.1 TheRouter 鴻蒙端的三大能力&lt;/h4&gt; 
&lt;p&gt;Navigator：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持 &lt;code&gt;Path&lt;/code&gt; 與頁面多對一關係或一對一關係，可用於解決多端 path 統一問題&lt;/li&gt; 
 &lt;li&gt;頁面 &lt;code&gt;Path&lt;/code&gt; 支持正則表達式聲明&lt;/li&gt; 
 &lt;li&gt;支持 &lt;code&gt;json&lt;/code&gt; 格式路由表導出&lt;/li&gt; 
 &lt;li&gt;路由表支持為頁面添加註釋説明&lt;/li&gt; 
 &lt;li&gt;支持動態下發 &lt;code&gt;json&lt;/code&gt; 路由表，降級任意頁面為 H5&lt;/li&gt; 
 &lt;li&gt;支持頁面跳轉攔截處理&lt;/li&gt; 
 &lt;li&gt;支持使用路由跳轉到第三方 SDK 中的頁面&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;ServiceProvider：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持跨模塊依賴注入&lt;/li&gt; 
 &lt;li&gt;支持自定義注入項的創建規則，依賴注入可自定義參數&lt;/li&gt; 
 &lt;li&gt;支持注入對象緩存，多次注入，只會 new 一次對象&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;ActionManager：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;支持全局回調配置&lt;/li&gt; 
 &lt;li&gt;支持多對一鏈式響應&lt;/li&gt; 
 &lt;li&gt;支持優先級響應&lt;/li&gt; 
 &lt;li&gt;方法支持返回值與入參&lt;/li&gt; 
 &lt;li&gt;支持記錄調用路徑，解決調試期觀察者模式無法追蹤 &lt;code&gt;Observable&lt;/code&gt; 的問題&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;二、鴻蒙路由方案&lt;/h3&gt; 
&lt;p&gt;根據華為官方文檔建議，從 API 10 開始，推薦使用 &lt;code&gt;NavPathStack&lt;/code&gt; 配合 &lt;code&gt;navDestination&lt;/code&gt; 屬性進行頁面路由。所以 &lt;code&gt;TheRouter&lt;/code&gt; 也是按照這個方案實現的，如果你的項目還是使用 &lt;code&gt;ohos.router&lt;/code&gt; 組件，建議儘早遷移。&lt;br&gt; 詳細內容請查看華為官方文檔：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.huawei.com%2Fconsumer%2Fcn%2Fdoc%2Fharmonyos-references%2Fjs-apis-router&quot; target=&quot;_blank&quot;&gt;https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-router&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;無論哪個平台，路由的本質就是一個 Map，或者説是字典。其中 key 是，頁面的 path，value 是路由項。對於 Action、ServiceProvider，也都是一樣。&lt;br&gt; 所以在鴻蒙上最核心的重點，是實現在編譯期將註解 path 關聯到具體的路由項，使其產生一個一對多或一對一的對應關係。其次就是要考慮如何與系統自帶的路由表兼容，遵循系統方案而不是完全打造一套，否則可能引起將來的不確定性。&lt;br&gt; 在 TheRouter 中，通過編譯期的 &lt;code&gt;hvigor&lt;/code&gt; 插件，解析全部的註解關鍵字，並將獲取到的內容保存下來，在應用編譯完成後，參照系統的路由表格式，生成一份增量的路由表，聚合到系統的路由表內。正是因為這樣，才能做到兼容第三方 SDK，正常跳轉到第三方頁面。既然第三方都能跳轉，那麼其他的二方、或自己的獨立模塊自然也就可以正常跳轉了。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;三、使用 TheRouter 頁面跳轉&lt;/h3&gt; 
&lt;h4&gt;3.1 聲明路由項&lt;/h4&gt; 
&lt;p&gt;如果一個頁面允許被路由打開，則需要使用註解 &lt;code&gt;@Route&lt;/code&gt; 聲明路由項，每個頁面允許聲明多個路由項，也就是一對多的能力，極大降低多端路由統一時的業務影響面。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;參數釋義&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;path&lt;/strong&gt;: 路由 path 【必傳】。&lt;br&gt; 建議是一個 url，並推薦三端 url 統一。path 內支持使用正則表達式，允許多個 path 對應同一個 Page。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;description&lt;/strong&gt;: 頁面描述【可選】。&lt;br&gt; 會被記錄到路由表中，方便後期排查的時候知道每個 path 或 Page 是什麼業務。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;params&lt;/strong&gt;: 頁面參數【可選】。&lt;br&gt; 自動寫入當前頁面參數中，允許寫在路由表中動態下發修改默認值，或通過路由跳轉時代碼傳入。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;launchMode&lt;/strong&gt;: 當前頁的啓動方式【可選】。&lt;br&gt; 啓動模式，可選項：&#39;STANDARD&#39;(默認)、&#39;MOVE_TO_TOP_SINGLETON&#39;、&#39;POP_TO_SINGLETON&#39;、&#39;NEW_INSTANCE&#39;。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Route({ path: BaseConstant.MAIN_PAGE, description: &#39;Demo 首頁&#39;, params: [&quot;hello&quot;, &quot;路由表默認參數&quot;], launchMode:&#39;STANDARD&#39; })
@Component
export struct MainPage {
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;3.2 發起頁面跳轉&lt;/h4&gt; 
&lt;p&gt;傳入的參數可以是 &lt;code&gt;string&lt;/code&gt; 和基本數據類型、也可以是&lt;code&gt;ESObject&lt;/code&gt;對象。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;TheRouter.build(&quot;http://therouter.com/home&quot;)
        .withNumber(&quot;key1&quot;, 12345678)
        .withString(&quot;key2&quot;, &quot;參數&quot;)
        .withBoolean(&quot;key3&quot;, false)
        .with({xxx:xxx}) 
         // navigation、replace、pop 均可以額外傳入 callback 參數，對當前跳轉的個狀態回調
        .navigation();

        // 替換頁面（相當於先 pop 再 push）
        .replace();

        // 關閉當前頁
        .pop();
       
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;3.3 路由表生成規則&lt;/h4&gt; 
&lt;p&gt;如果兩條路由的 &lt;code&gt;path&lt;/code&gt; 完全相同，則認為是同一條路由，&lt;strong&gt;不會考慮參數是否相同&lt;/strong&gt;。&lt;br&gt; 路由表生成規則：編譯期按照如下順序取&lt;strong&gt;並集&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;覆蓋規則&lt;/strong&gt;：&lt;br&gt; 根據如下順序，如果相同，後者可以覆蓋前者的路由表規則。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;編譯期解析註解生成路由表&lt;/li&gt; 
 &lt;li&gt;首先取 &lt;code&gt;業務模塊 (har/hap)&lt;/code&gt; 中的路由表&lt;/li&gt; 
 &lt;li&gt;再取，主&lt;code&gt;hsp module&lt;/code&gt; 代碼中的路由表&lt;/li&gt; 
 &lt;li&gt;最後取 &lt;code&gt;resources/base/profile/RouteMap.json&lt;/code&gt; 文件中聲明的路由表。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;如果編譯期沒有這個文件，會生成一份默認路由表放在這個目錄內（編譯完成後如果沒有配置保留，會自動刪掉）；如果有，會將路由表合併。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;ol start=&quot;5&quot;&gt; 
 &lt;li&gt;運行時線上動態下發的路由表&lt;/li&gt; 
&lt;/ol&gt; 
&lt;ul&gt; 
 &lt;li&gt;路由表允許線上動態下發，將覆蓋本地路由表，詳見 【3.4 動態路由表的設計與使用】&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;如果編譯期沒有這個文件，會生成一份默認路由表放在這個目錄內（編譯完成後如果沒有配置保留，會自動刪掉）；如果有，會將路由表合併，因此，對於沒辦法修改代碼的第三方 SDK 內部，如果希望通過路由打開，只需要手動在 &lt;code&gt;RouteMap.json&lt;/code&gt; 文件中聲明，就能通過路由打開了。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;3.4 動態路由表的設計與使用&lt;/h4&gt; 
&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 的路由表是動態添加的，項目每次編譯後，會在 app 內生成一份當前模塊的全量路由表。這個路由表也可以後續通過遠程下發的方式使用，例如遠端可以針對不同的 APP 版本，下發不同的路由表達到配置目的。這樣如果將來線上某些頁面發生 Crash，可以通過將這個頁面的落地頁替換為 H5 的方式，臨時解決這類問題。&lt;br&gt; &amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;有兩種推薦的遠程下發方式可供使用方選擇：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;將打包系統與配置系統打通，每次新版本打包後自動將所有模塊 (hsp、har、hap) &lt;code&gt;resource/rawfile/&lt;/code&gt; 目錄中的路由表文件上傳到配置系統，聚合成一個 json 後，下發給對應版本 APP 。優點在於全自動不會出錯。&lt;/li&gt; 
 &lt;li&gt;配置系統無法打通，線上手動下發需要修改的路由項，因為 &lt;code&gt;TheRouter&lt;/code&gt; 會自動用最新下發的路由項覆蓋包內的路由項。優點在於精確，且流量資源佔用小。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;動態路由限制&lt;/strong&gt; ：準確的説，應該是鴻蒙系統的限制。在鴻蒙上，路由表必須是靜態的並且在編譯期確定下來。TheRouter Harmony 做了一些黑科技處理，允許動態加載一個或多個路由表，但是動態加載的路由頁面必須是在編譯期就已經存在的，不能憑空新增（類似 &lt;code&gt;Android&lt;/code&gt; 的 &lt;code&gt;Activity&lt;/code&gt;，在編譯後就不能再改或新增註冊清單文件了）。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 與 Android 邏輯不同，此代碼，必須，在頁面打開之前，路由初始化之後調用。 建議緊跟 TheRouter.init() 調用
TheRouter.setRouteMapInitTask(task: (map: Map&amp;lt;string, routeitem&amp;gt;) =&amp;amp;gt; void);

/** 
 * 此處的 map 就是當前應用的路由表全量，
 * 當獲取到遠端路由表以後，把路由表繼續傳入 map 中，有重複項可自動覆蓋
 */
TheRouter.setRouteMapInitTask(() =&amp;amp;gt; {
    // 此處為純業務邏輯，每家公司遠端配置方案可能都不一樣
    const json = Connfig.doHttp(&quot;routeMap&quot;);
    // 只需要將路由 json 返回給框架即可，不建議在任務中做耗時操作
    return json;
});
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;3.5 攔截器用法&lt;/h4&gt; 
&lt;p&gt;框架內置四種自定義處理器可供業務場景定製，用於在路由跳轉過程中，以切面的方式統一修改路由落地頁參數信息。&lt;br&gt; Harmony 路由與 Android 路由的攔截器使用完全一致，可以直接參考【&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftherouter.cn%2Fdocs%2F2022%2F08%2F28%2F01&quot; target=&quot;_blank&quot;&gt;Android 文檔&lt;/a&gt; 第三部分】。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// 所有攔截器方法均在 TheRouter 類下，可以直接如下方式全局調用
TheRouter.addNavigatorPathFixHandle()

/**
  * 應用場景：用於修復客戶端上路由 path 錯誤問題。
  * 例如：相對路徑轉絕對路徑，或由於服務端下發的鏈接無法固定 https 或 http，但客戶端代碼寫死了 https 的 path，就可以用這種方式統一。
  * 注：必須在 TheRouter.build() 方法調用前添加處理器，否則處理器前的所有 path 不會被修改。
  */
static addNavigatorPathFixHandle(handle: NavigatorPathFixHandle);

/**
  * 頁面替換器
  * 應用場景：需要將某些 path 指定為新鏈接的時候使用。 也可以用在修復鏈接的場景，但是與 path 修改器不同的是，修改器通常是為瞭解決通用性的問題，替換器只在頁面跳轉時才會生效，更多是用來解決特性問題。
  *
  * 例如模塊化的時候，首頁殼模板組件中開發了一個 SplashActivity 廣告組件作為應用的 MainActivity，在閃屏廣告結束的時候自動跳轉業務首頁頁面。 但是每個業務不同，首頁頁面的 Path 也不相同，而不希望讓每個業務線自己去改這個首頁殼模板組件，此時就可以組件中先寫佔位符 https://kymjs.com/splash/to/home，讓接入方通過 Path 替換器解決。
  * 注：必須在 TheRouter.build().navigation() 方法調用前添加處理器，否則處理器前的所有跳轉不會被替換。
  */
static addPathReplaceInterceptor(interceptor: PathReplaceInterceptor);


/**
  * 路由替換器
  * 應用場景：常用在未登錄不能使用的頁面上。例如訪問用戶錢包頁面，在錢包頁聲明的時候，可以在路由表上聲明本頁面是需要登錄的，在路由跳轉過程中，如果落地頁是需要登錄的，則先替換路由到登錄頁，同時將原落地頁信息作為參數傳給登錄頁，登錄流程處理完成後可以繼續執行之前的路由操作。
  *
  * 路由替換器的攔截點更靠後，主要用於框架已經從路由表中根據 path 找到路由以後，對找到的路由做操作。
  *
  * 這種邏輯在所有頁面跳轉前寫不太合適，以前的做法通常是在落地頁寫邏輯判斷用戶是否具有權限，但其實在路由層完成更合適。
  * 注：必須在 TheRouter.build().navigation() 方法調用前添加處理器，否則處理器前的所有跳轉不會被替換。
  */
static addRouterReplaceInterceptor(interceptor: RouterReplaceInterceptor);

/**
  * 路由 AOP 攔截器
  * 與前三個處理器不同的點在於，路由的 AOP 攔截器全局只能有一個。用於實現 AOP 的能力，在整個 TheRouter 跳轉的過程中，跳轉前，目標頁是否找到的回調，跳轉時，跳轉後，都可以做一些自定義的邏輯處理。
  *
  * 使用場景：場景很多，最常用的是可以攔截一些跳轉，例如 debug 頁面在生產環境不打開，或定製 startActivity 跳轉方法。
  */
public setRouterInterceptor(interceptor: (route: RouteItem, callback: (route: RouteItem) =&amp;amp;gt; void) =&amp;amp;gt; void);
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;3.6 高級用法&lt;/h4&gt; 
&lt;p&gt;TheRouter 同時支持更多頁面跳轉能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;為第三方庫裏面的頁面添加路由表，達到對某些頁面降級替換的目的；&lt;/li&gt; 
 &lt;li&gt;跳轉過程攔截器（總共四層，可根據實際需求使用）；&lt;/li&gt; 
 &lt;li&gt;跳轉結果回調；&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;四、跨模塊依賴注入 ServiceProvider 的設計&lt;/h3&gt; 
&lt;p&gt;對於模塊化開發中跨模塊的調用，我們推薦採用 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzh.m.wikipedia.org%2Fzh-cn%2F%25E9%259D%25A2%25E5%2590%2591%25E6%259C%258D%25E5%258A%25A1%25E7%259A%2584%25E4%25BD%2593%25E7%25B3%25BB%25E7%25BB%2593%25E6%259E%2584&quot; target=&quot;_blank&quot;&gt;SOA(面向服務架構)&lt;/a&gt; 的設計方式，服務調用方與使用方完全隔離，調用模塊外的能力不需要關注能力的提供者是誰。&lt;br&gt; &lt;code&gt;ServiceProvider&lt;/code&gt; 的核心設計思想也是這樣的，目前服務間的調用協議採用接口的方式。當然，也可以兼容不通過接口下沉而是直接調用的情況。&lt;/p&gt; 
&lt;p&gt;&amp;lt;img src=&quot;https://oscimg.oschina.net/oscnet//2b415a4c5e28eb030692174056fbf876.jpeg&quot; class=&quot;blog-img&quot;&amp;gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;服務提供方負責提供服務，不需要關心調用方是誰會在何時調用自己。&lt;/li&gt; 
 &lt;li&gt;服務的使用方只關注服務本身，不需要關心這個服務是誰提供的，只需要只能服務能提供哪些能力即可。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;例如上面的圖片：拉拉需要使用錄音的服務，小貨則向外提供一個錄音的服務，由&lt;code&gt;TheRouter&lt;/code&gt;的&lt;code&gt;ServiceProvider&lt;/code&gt;負責撮合。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;4.1 服務使用方：拉拉&lt;/h4&gt; 
&lt;p&gt;她無需關心，&lt;code&gt;IRecordService&lt;/code&gt; 這個接口服務是誰提供的，他只需要知道自己需要使用這樣的一個服務就行了。&lt;br&gt; 注：如果沒有提供服務的提供方，&lt;code&gt;TheRouter.get()&lt;/code&gt; 可能返回 &lt;code&gt;    &lt;/code&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;TheRouter.get&amp;lt;irecordservice&amp;gt;(BaseConstant.CLASS_SERVICE)?.doRecord()
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;4.2 服務提供方：小貨&lt;/h4&gt; 
&lt;p&gt;服務提供方需要聲明一個提供服務的方法，用 &lt;code&gt;@ServiceProvider&lt;/code&gt; 註解標記，並需要實現接口 &lt;code&gt;IServiceProvider&lt;/code&gt;。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
// 類名不限定，任意名字都行
// 所有的 ServiceProvider 必須實現 IServiceProvider 接口
// 多次添加重複 serviceName，框架會保證安全，在編譯時報錯
@ServiceProvider({ serviceName: BaseConstant.CLASS_SERVICE, singleton: true })
export class CustomService implements IRecordService, IServiceProvider {

  doRecord(): void {
  }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;@ServiceProvider 參數釋義&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;serviceName&lt;/strong&gt;: 服務名 【必傳】。&lt;br&gt; 服務的唯一標識。如果重複，在編譯期會直接報錯。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;singleton&lt;/strong&gt;: 默認 false【可選】。&lt;br&gt; 服務提供方提供出的服務是否為單例。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;五、動態化能力 Action 的設計&lt;/h3&gt; 
&lt;p&gt;&lt;code&gt;Action&lt;/code&gt; 本質是一個全局的系統回調，主要用於預埋的一系列操作，例如：彈窗、上傳日誌、清理緩存。&lt;br&gt; 與 Android 系統自帶的廣播通知類似，你可以在任何地方聲明動作與處理方式。並且所有 &lt;code&gt;Action&lt;/code&gt; 都是可以被跟蹤的，只要你願意，可以在日誌中將所有的動作調用棧輸出，以方便調試使用，這樣在一定程度上可以解決觀察者模式帶來的通病：&lt;strong&gt;無法追蹤 &lt;code&gt;Observable&lt;/code&gt; 的問題&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;5.1 Action 使用&lt;/h4&gt; 
&lt;p&gt;聲明一個 Action：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// action 建議遵循一定的格式
const readonly ACTION = &quot;therouter://action/xxx&quot;

// action 既可以放在 ServiceProvider 裏面，也可以單獨放在任意類中，但不能是 top-level 函數，這一點與 Android 不同
// action 函數允許有返回值，可以做耗時操作
// 多次添加重複 action，每個 action 的方法都會執行，但最終只會返回優先級最高的方法的返回值
@Action({ action: ACTION })
public test(par: string): string {
    return &quot;返回入參：&quot; + par;
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;執行一個 Action：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// action 建議遵循一定的格式
const val ACTION = &quot;therouter://action/xxx&quot;

// 如果執行了一個沒有被聲明的 Action，則不會有任何動作
// 這裏的&quot;hello&quot;字符串，是根據 action 定義時有一個入參，所以調用時需要傳入這個參數
TheRouter.action&amp;lt;string&amp;gt;(ACTION, &quot;hello&quot;).then((str) =&amp;amp;gt; {
    this.text = str;
})
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://my.oschina.net/u/128551&quot;&gt;@Action&lt;/a&gt; 參數釋義&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;action&lt;/strong&gt;: 事件名 【必傳】。&lt;br&gt; 當前函數需要響應的 action。如果同一個 action 有多個函數訂閲，會在響應時根據優先級決定先後順序。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;priority&lt;/strong&gt;: 優先級 (number 類型)，默認 5【可選】。&lt;br&gt; 數字越大，優先級越高。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;5.2 客戶端動態響應使用場景&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;如果僅客戶端使用&lt;/strong&gt;，常用的場景可能是：當用戶執行某些操作（打開某個頁面、H5 點擊某個按鈕、動態頁面配置的點擊事件）時，將會自動觸發，執行預埋的 Action 邏輯。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;如果與服務端鏈路打通&lt;/strong&gt;，這個能力其實是需要整個公司的配合，比如有一套類似智慧大腦的方案，可以基於客戶端過去的一些埋點數據，智能推斷出用戶下一步要做的事情，然後通過長連接直接向客戶端下發指令做某些事情。那麼通過客戶端預埋的頁面跳轉、彈窗、清緩存、退出登錄等等操作，就可以通過服務端指令進行操作，則就是一套完整的動態化方案。&lt;/p&gt; 
&lt;p&gt;&amp;lt;img src=&quot;https://oscimg.oschina.net/oscnet//79f8e6cef031e34cfa80d4f329003662.png&quot; class=&quot;blog-img&quot;&amp;gt;&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;六、從其他路由遷移至 TheRouter&lt;/h3&gt; 
&lt;h4&gt;6.1 遷移工具一鍵遷移？&lt;/h4&gt; 
&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 在 Android 項目上提供了圖形化界面的遷移工具，可以一鍵從其他路由遷移到&lt;code&gt;TheRouter&lt;/code&gt;。&lt;/p&gt; 
&lt;p&gt;鴻蒙當然也提供了相同的能力，你可以在插件市場搜索，直接安裝。安裝好以後，點擊 IDE 頂部的 Tool 菜單，找到遷移工具。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h4&gt;6.2 與其他路由對比&lt;/h4&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;table&gt; 
 &lt;thead&gt; 
  &lt;tr&gt; 
   &lt;th&gt;功能&lt;/th&gt; 
   &lt;th&gt;TheRouter&lt;/th&gt; 
   &lt;th&gt;HMRouter&lt;/th&gt; 
   &lt;th&gt;Navigation&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/thead&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt;具備三端高一致性&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;註解生成路由表&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;路由 path 支持正則表達式&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;指定攔截器&lt;/td&gt; 
   &lt;td&gt;✔️（四大攔截器可根據業務定製）&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;導出路由表&lt;/td&gt; 
   &lt;td&gt;✔️（路由文檔支持添加註釋描述）&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;支持跨模塊調用&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;動態修改路由信息&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️(未提供功能接口)&lt;/td&gt; 
   &lt;td&gt;✔️(限制高，需提前定義，通過 if/else 修改實現)&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;遠端路由表下發&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;多 Path 對應同一頁面（低成本實現雙端 path 統一）&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt;支持使用路由打開第三方 SDK 頁面&lt;/td&gt; 
   &lt;td&gt;✔️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
   &lt;td&gt;✖️&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;h3&gt;七、總結&lt;/h3&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 並不僅僅是一個小巧靈活的路由庫，而是一整套 &lt;code&gt;Android&lt;/code&gt;、&lt;code&gt;iOS&lt;/code&gt;、&lt;code&gt;Harmony&lt;/code&gt; 三端完整的移動端解決方案，對移動端開發者更友好，上手開發適應性更強。使用 &lt;code&gt;TheRouter&lt;/code&gt; 能夠解決幾乎全部的模塊化過程中會遇到的問題。&lt;br&gt; 對於現有的路由框架，我們也在最大限度支持平滑遷移。你也可以在 &lt;code&gt;Github&lt;/code&gt; &lt;code&gt;issue&lt;/code&gt; 中提出需求，我們評估後會儘快支持，也歡迎任何人提供 &lt;code&gt;Pull Requests&lt;/code&gt;。&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;更多問題請加羣溝通：&lt;br&gt; &amp;lt;br&amp;gt; &amp;lt;img src=&quot;https://oscimg.oschina.net/oscnet//58894fe2e65215c645807394c7428b38.png&quot; class=&quot;blog-img&quot;&amp;gt;&lt;/p&gt; 
&lt;p&gt;&amp;lt;br&amp;gt;&lt;/p&gt; 
&lt;p&gt;&amp;lt;/string&amp;gt;&amp;lt;/irecordservice&amp;gt;&amp;lt;/string,&amp;gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/kymjs/blog/18230924</link>
            <guid isPermaLink="false">https://my.oschina.net/kymjs/blog/18230924</guid>
            <pubDate>Sun, 13 Apr 2025 09:55:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>ai.com 域名跳轉再次變動，已「解綁」 DeepSeek</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;備受關注的全球頂級域名 ai.com&amp;nbsp;跳轉目標近日發生變更。目前訪問 ai.com&amp;nbsp;會跳轉至一個全新的、充滿神祕感的網站。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/173401_GYxd_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;此前該域名曾指向中國 AI 初創公司 DeepSeek 官網，但根據最新觀察，ai.com&amp;nbsp;現已解綁 DeepSeek。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2acc3b56697746a69a6ce511b0478c79dc5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;ai.com 是一個備受追捧的頂級域名，因其簡潔性和與人工智能的直接關聯而備受關注。過去，它曾被 Google、OpenAI 和 Elon Musk 的 xAI 使用，最近的變動顯示它可能已從 DeepSeek 解綁，並重定向到一個新網站。&lt;/p&gt; 
&lt;p&gt;根據 2025 年 4 月的 WHOIS 記錄，ai.com 的註冊機構為 Squarespace Domains II LLC，這表明 Squarespace 可能參與了其管理。Squarespace 最近推出了 AI 驅動的網站構建工具，如 Design Intelligence，可能是新網站的內容。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346402</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346402</guid>
            <pubDate>Sun, 13 Apr 2025 09:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>微軟抄襲獨立開發者開源項目，「改頭換面」後當成新產品</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Spegel 是由獨立開發者 Philip Laine 創建的開源項目，採用 MIT 開源許可協議。這是一個面向 Kubernetes 的 P2P 鏡像分發工具，通過 P2P 分發機制有效降低對中心化鏡像倉庫的依賴，解決鏡像倉庫宕機導致集羣無法擴容的問題。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;858&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/170008_R8IP_2720166.png&quot; width=&quot;1604&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspegel-org%2Fspegel&quot; target=&quot;_blank&quot;&gt;https://github.com/spegel-org/spegel&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;2025 年 4 月，Philip Laine 在巴黎 KubeCon 大會參加一場關於加速鏡像分發策略的演講時，發現微軟推出了一個名為 Peerd 的 Kubernetes 容器內容 P2P 分發工具。&lt;/p&gt; 
&lt;p&gt;他深入研究後發現 Peerd 與 Spegel 在代碼層面存在大量雷同之處，包括函數簽名、註釋乃至多個測試用例都幾乎一樣，且部分測試用例直接來自 Spegel 項目。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/170824_0Lxs_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Peerd 的代碼中未保留 Spegel 原始的 MIT 許可證和版權聲明，僅在 README 文件底部對 Spegel 和 Philip Laine 表示了感謝。&lt;/p&gt; 
&lt;p&gt;Philip Laine 將此事&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fphiliplaine.com%2Fposts%2Fgetting-forked-by-microsoft%2F&quot; target=&quot;_blank&quot;&gt;發表&lt;/a&gt;&lt;/u&gt;在網上後引發開源社區&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnews.ycombinator.com%2Fitem%3Fid%3D43750535&quot; target=&quot;_blank&quot;&gt;熱議&lt;/a&gt;&lt;/u&gt;，許多開發者在 Hacker News 等平台上討論自己類似的經歷，並對微軟的行為表示譴責，認為其違反了開源社區的道德規範，即便在法律上可能因 MIT 協議的寬鬆性而無可指摘，但卻在道義上傷害了開源開發者。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1038&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/170445_lPOa_2720166.png&quot; width=&quot;1938&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;一些開發者指出，MIT 協議的寬鬆性可能導致個人開發者容易被大公司 「利用」，建議對於希望保護自己代碼不被濫用的開發者，可以考慮採用更具限制性的許可證，如 GPL。&lt;/p&gt; 
&lt;p&gt;還有類似經歷的開發者表示，當發現大公司用了自己的開源項目，可以直接跟他們「談錢」——Don’t work for free（不要免費幹活）。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/171421_WuEC_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;事件曝光後，微軟也迅速採取行動，向 Spegel 提交了 pull request，修復 Peerd 開發者忽略的版權聲明，在 Peerd 的 GitHub 倉庫中添加了對 Spegel 的明確致謝和鏈接，並對部分代碼進行了調整，以符合開源協議的要求。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;946&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/171105_gKQY_2720166.png&quot; width=&quot;2728&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346393/getting-forked-by-microsoft</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346393/getting-forked-by-microsoft</guid>
            <pubDate>Sun, 13 Apr 2025 09:15:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Anx Reader —— 電子書閲讀器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                            &lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;Anx Reader，一款為熱愛閲讀的你精心打造的電子書閲讀器。集成多種 AI 能力，支持豐富的電子書格式，讓閲讀更智能、更專注。現代化界面設計，只為提供純粹的閲讀體驗。&lt;/p&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;豐富的格式支持&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持主流電子書格式：EPUB、MOBI、AZW3、FB2、TXT&lt;/li&gt;
&lt;li&gt;完美解析，確保最佳閲讀體驗&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;無縫同步體驗&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通過 WebDAV 跨設備同步閲讀進度、筆記和書籍&lt;/li&gt;
&lt;li&gt;隨時隨地繼續您的閲讀之旅&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;智能 AI 助手&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集成多款頂尖 AI 服務：OpenAI、DeepSeek、Claude、Gemini&lt;/li&gt;
&lt;li&gt;智能總結內容、回憶閲讀位置，讓閲讀更有效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;個性化閲讀體驗&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;精心設計的主題配色，支持自定義&lt;/li&gt;
&lt;li&gt;滾動/分頁模式自由切換&lt;/li&gt;
&lt;li&gt;支持導入自定義字體，打造專屬閲讀空間&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;專業的閲讀追蹤&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;詳盡的閲讀數據統計&lt;/li&gt;
&lt;li&gt;支持周、月、年度閲讀報告&lt;/li&gt;
&lt;li&gt;直觀的閲讀熱力圖，記錄每一刻閲讀時光&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;強大的筆記系統&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;靈活的文本批註功能&lt;/li&gt;
&lt;li&gt;支持導出為 TXT、CSV、Markdown 格式&lt;/li&gt;
&lt;li&gt;輕鬆整理和分享您的讀書心得&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;實用工具集&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TTS 智能朗讀，解放雙眼&lt;/li&gt;
&lt;li&gt;全文搜索，快速定位內容&lt;/li&gt;
&lt;li&gt;即時劃詞翻譯，提升閲讀效率&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;color:#1f2328; text-align:start&quot;&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完美支持 Android 與 Windows 系統&lt;/li&gt;
&lt;li&gt;統一的用戶體驗，無縫切換設備&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; height=&quot;335&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0417/154449_zSOV_4252687.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/anx-reader</link>
            <guid isPermaLink="false">https://www.oschina.net/p/anx-reader</guid>
            <pubDate>Sun, 13 Apr 2025 08:40:00 GMT</pubDate>
        </item>
        <item>
            <title>國家知識產權局：中國成為全球 AI 專利最大擁有國，佔比達 60%</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;4 月 24 日，國務院新聞辦公室就 2024 年中國知識產權強國建設有關情況舉行新聞發佈會。國家知識產權局局長申長雨在會上介紹，目前，我國人工智能領域呈現良好的發展勢頭。世界知識產權組織報告顯示，中國已經成為全球人工智能專利的最大擁有國，在全球的佔比達到 60%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;381&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-268c2801a548428644c866dda9f83ab1bfa.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;近年來，國家知識產權局積極回應人工智能新領域、新業態、新模式發展的需要，深入推進人工智能領域知識產權制度創新，為人工智能技術發展和產業發展提供有力的制度供給。包括及時修改完善《專利審查指南》，發佈《人工智能相關發明專利申請指引》，積極回應和解決了有關人工智能專利申請主體、保護客體、審查標準等熱點問題。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;聚焦人工智能重點領域，為相關專利申請提供快速審查服務，嚴厲打擊搶注「DeepSeek」等相關商標申請行為，持續強化知識產權保護，護航人工智能領域科技創新。「與此同時，我們還在加快人工智能技術在知識產權領域的運用，推動知識產權工作數字化轉型和智能化升級，不斷提升知識產權治理效能。」申長雨説。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;申長雨表示，面向未來，國家知識產權局將積極推動知識產權與人工智能共生演進、雙向賦能、融合發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;一方面，持續推進人工智能相關知識產權制度創新，加快建立人工智能、大數據等新領域新業態知識產權保護規則，為發展人工智能技術提供更加有力的法治保障。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另一方面，提高人工智能知識產權保護和運用水平，健全知識產權支撐關鍵核心技術攻關工作體系，加大人工智能領域專利申請按需審查服務力度。做好相關發明專利分析預警和導航服務，指導建設人工智能領域專利池，深入實施專利轉化運用專項行動，促進更多人工智能領域專利從實驗室走向產業鏈，賦能相關產業發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;同時，積極參與人工智能領域知識產權全球治理，推動完善相關國際規則和標準，促進全球人工智能產業發展，讓人工智能技術更好造福全人類。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346372</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346372</guid>
            <pubDate>Sun, 13 Apr 2025 08:24:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Full GC 頻率優化實戰</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：vivo 互聯網服務器團隊- Li Gang&lt;/p&gt; 
&lt;p&gt;本文介紹了遊戲業務使用 MAT 和 GC 日誌等工具對 Full GC 頻率進行優化的過程。&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//c341f95428b3ab0136fe82b131ed498d.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//93d307a1697bd5e5ed13a82bf4d45ab5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;遊戲業務面對用戶端的某個工程，每天 Full GC 頻率達到 120 次，業務高峯期每 7 分鐘就會有一次 Full GC。為了避免情況持續變差，最大程度減少對系統響應時間的負面影響，需要對該工程的 Full GC 頻率進行優化。&lt;/p&gt; 
&lt;p&gt;該項目 JDK 版本為 1.8，老年代使用 CMS 作為垃圾回收器，優化前的部分啓動參數如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;-Xms4608M -Xmx4608M -Xmn2048M -XX:MetaspaceSize=320M -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;二、工具介紹&lt;/h1&gt; 
&lt;p&gt;在本次優化過程中，我們主要使用了 MAT 和 GC 日誌作為排查工具。MAT 是一個功能強大的內存分析工具，而 GC 日誌則用於記錄 Java 虛擬機中的垃圾回收行為和內存情況。這兩者結合起來，能夠幫助開發人員深入分析程序的內存使用情況，並進行相應的優化。下文將詳細的介紹這兩種工具的使用方法，以及對應的優化案例。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.1 MAT（Memory Analyzer Tool）&lt;/h2&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//54a70be170b0944508c621604a927f93.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Eclipse Memory Analyzer Tool（MAT）是一個開源的 Java 堆轉儲分析工具。它旨在幫助開發人員識別和消除 Java 堆中的內存泄漏和優化內存使用。MAT 允許用戶分析 Java 堆轉儲文件，識別對象的內存佔用情況，查找潛在的內存泄漏和冗餘對象，以便執行一些內存優化。&lt;/p&gt; 
&lt;p&gt;使用 MAT 打開 dump 文件後，首先進入的是上圖頁面，此頁面會顯示 dump 包的縮略概覽信息，包括堆大小，類數量，對象數量等信息。其中的 Biggest Objects By Retained Size 和 Leak Suspects 在問題明顯時會比較有用，但對相對複雜的問題來説幫助不大。筆者比較常用的是下面這幾個功能，下文將依次介紹：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//003bf1d805943c1ca72236688d9943db.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_4&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1 Dominator Tree&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//305da051d1e325a48a6ffe437a162324.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;展示對象的支配關係。對象 A 支配對象 B 代表從 GC Root（也不一定是 GC ROOT，也可以是 unreachable 的起點）達到對象 B 的所有路徑都必須經過對象 A，這也意味着對象 A 被垃圾回收後，對象 B 也會被回收。&lt;/p&gt; 
&lt;p&gt;這個功能相較於下面的 Histogram 更強調對象的引用關係，此外還可以通過 Group By Class/Group By Package/Group By ClassLoader 來進一步的聚合對象。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//57d33fe765c080eaee0982650c74e0a8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;MAT 的各種圖標中會頻繁的出現 Shallow Heap Size 和 Retained Heap Size 這兩個名詞，其含義如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Shallow Heap Size&lt;/strong&gt;：這個對象自身在堆中的大小&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Retained Heap Size&lt;/strong&gt;：這個對象被垃圾回收後會釋放的堆內存大小&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//ab51af06b1b11e22461c2c4df735896c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上圖中，情況 1 裏對象 A 的 Retained Heap Size = A 的 Shallow Heap Size + B 的 Shallow Heap Size +C 的 Shallow Heap Size，情況 2 裏對象 A 的 Retained Heap Size = A 的 Shallow Heap Size + B 的 Shallow Heap Size。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）使用方法&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;①上圖為 Group By Class 的 dominator tree。剛打開 dominator tree 時默認是不進行 group 的，此時可以排查單個大對象，排查完單個大對象後，需要將對象 Group 一下才能進行下一步的排查。&lt;/p&gt; 
&lt;p&gt;② 從上圖可以看出，這個堆內的對象內存佔用比較分散，説明導致問題的原因可能不止一個，這種情況下只能結合自身業務逐個排查內存佔用排在前面的對象。&lt;/p&gt; 
&lt;p&gt;③ 對這些可疑的對象，右鍵類，選擇 List objects → with outgoing references 展開對象列表，查看這類對象具體存了什麼，判斷這些對象的值是否可以再分類。&lt;/p&gt; 
&lt;p&gt;④ 根據對象的值，判斷對象的業務含義，確定是哪段代碼創建的對象。&lt;/p&gt; 
&lt;p&gt;⑤ 結合代碼，思考這類對象是在新生代還是老年代，如果能確定都在新生代，那這些對象一般不會導致老年代快速增長。&lt;/p&gt; 
&lt;p&gt;⑥如果在老年代，需要確定其是怎麼從新生代晉升的，內存佔用是否有上限，上限是多少，一般多長時間能達到上限，再確定有沒有問題。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_5&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.2 Histogram&lt;/h3&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//0aa288e4d9f5bd726b7241f51f1c2093.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;histogram 可以顯示出各類對象的 Shallow Heap Size 和 Retained Heap Size，Retained Heap Size 默認不展示，需要點擊菜單欄的 Calculate Retained Size 進行計算，堆較大時計算耗時較長。&lt;/p&gt; 
&lt;p&gt;這張表一般和 Dominator Tree 結合使用，我們能看到 char[]佔用了較大的內存，但由於 Dominator Tree 裏聚合好的 char[]都是頂層支配者，上層不會再有引用，有時無法直接確定這些對象曾經被誰持有過，這時可以通過 Histogram 查看同類對象，找到相似的並且 reachable 的對象來確定這類對象是誰創建的。但是這一步其實可以通過 oql 解決，所以這張表在排查過程中的使用率其實沒有 Histogram 高。&lt;/p&gt; 
&lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.3 OQL&lt;/h3&gt; 
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;MAT 提供的一種類似 SQL 的查詢語句，可以對對象進行過濾。這篇官方文章裏給了很多查詢語句樣例：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwiki.eclipse.org%2FMemoryAnalyzer%2FOQL&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://wiki.eclipse.org/MemoryAnalyzer/OQL&lt;/a&gt;，這裏就簡單列一些筆者排查過程中用過的語句，不再贅述：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// 字符串模糊匹配
SELECT * FROM char[] b where toString(b) LIKE &quot;.*traceId.*&quot;
// 查找地址&amp;gt;0x700000000 的對象
SELECT * FROM java.lang.Object t WHERE  toHex(t.@objectAddress) &amp;gt;= &quot;0x700000000&quot;
// 查找長度等於 73 並且 retained heap size&amp;gt;1000B 的對象
SELECT * FROM java.lang.Object[] a where a.@length=73 and a.@retainedHeapSize&amp;gt;1000
// 查找長度等於 65536 並且上層有引用的對象
SELECT * FROM char[] a where a.@length=65536 and (inbounds(a).size()&amp;gt;0)
&lt;/code&gt;&lt;/pre&gt; 
&lt;span id=&quot;OSC_h2_7&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;2.2 GC 日誌&lt;/h2&gt; 
&lt;p&gt;GC 日誌是記錄 Java 虛擬機中垃圾回收活動的日誌文件。在 GC 日誌中，可以看到包括垃圾回收的時間、類型（如新生代 GC、老年代 GC 等）、回收週期、回收停頓時間、回收前後堆的使用情況等信息。GC 日誌打印的信息可以通過以下啓動項控制：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//685da0f1c5cfed7523dec9f23a230009.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;span id=&quot;OSC_h1_8&quot;&gt;&lt;/span&gt; 
&lt;h1&gt;三、 案例介紹&lt;/h1&gt; 
&lt;p&gt;在這篇文章中，我們將聚焦於一些具體的案例，涉及到大量被 Dubbo 的 FutureAdapter 引用的對象、Jackson 的 BufferRecycler 導致的大量 char[65536]以及對象晉升年齡閾值過小等問題。通過這些案例，我們將探討這些具體問題的引起原因以及解決方案。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_9&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.1 大量被 Dubbo 的 FutureAdapter 引用的對象&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）分析過程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//b48a8f39c0e7a54137b99320491667e1.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;從上圖中，我們可以看到 dubbo FutureAdapter 佔用了 230M 左右的內存，前面的 PSWMS 對象雖然也佔用了 230M 左右的內存，但這是業務使用的本地緩存相關對象，其內存佔用是在預期範圍內的，因此優先分析 FutureAdapter。先右鍵 List objects→with outgoing references 展開對象列表。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//2ed8971570359b6d3d10934510d23c5b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;發現其中有大量大小几乎一致的 FutureAdapter，一個佔用內存 328KB 左右，大小和內容幾乎一致的對象約有 550 多個，總共佔用內存 200M 左右。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//071edf8accd8f32df486ee3b9abdc1fe.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;FutureAdapter 被用來執行 Dubbo 的異步調用，項目使用的 dubbo 版本為 2.7.18。dubbo 的同步調用本質上是一個異步轉同步的過程，發起異步調用將 CompletableFuture 對象放到 ThreadLocal 的 FutureContext 裏，然後立刻調用 CompletableFuture.get 方法阻塞獲取返回值，獲取到返回值後，dubbo 不會主動清理 FutureContext，因此該線程的 ThreadLocal 裏會有一條 FutureContext→ FutureAdapter→Result 的引用，如下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//de0f093c22f3ec69a7f34d73d135eeb3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;然而，那 550 多個 FutureAdapter 均為不可達對象，意味着其不被 ThreadLocal 引用，在下次 GC 時會被回收，不過我們無法直接確定這些對象是在老年代還是新生代，有可能這些對象都在新生代，下次 young gc 時就會被回收，不會晉升到老年代，更不會導致老年代增長。&lt;/p&gt; 
&lt;p&gt;但由於這個列表裏的數據有明確的業務含義，可以找到對應的業務接口，此接口單機峯值 qps 約為 2，響應時間約 100ms，每被調用一次，就會創建一個該對象列表，此時該機器的 young gc 頻率約為 10s 一次。假設這些對象都在新生代沒有晉升老年代，那麼這些對象在新生代最大的存活數量約為 ((接口響應時間 + 兩次 young gc 間隔) * 對象創建速度) = (0.1s + 10s) * 2 ≈ 20，而堆裏有 550 多個，如果這些對象沒有晉升到老年代的話數量上對不上，所以可以推測出這些對象在老年代裏，需要等下次 Full GC 時才會被回收。&lt;/p&gt; 
&lt;p&gt;那麼這些不可達的 FutureAdapter 為什麼會在老年代？每次執行 dubbo 調用，dubbo 都會用這次調用的 FutureAdapter 替換掉上次調用時存在 FutureContext 裏的 FutureAdapter，上次調用的 FutureAdapter 不再被 GC Root 引用，在下次 GC 時被回收。當一個線程相對頻繁的執行 dubbo 調用時，FutureAdapter 會被 young gc 回收，不會晉升到老年代。但在本例中，該 dubbo 調用被放到了 corePoolSize=150，maxPoolSize=500 的業務通用線程池中執行，該線程池會執行其他不需要調用 dubbo 服務的任務，並且該線程池的使用率並不高，這就意味着一個線程調用完 dubbo 服務後可能要過一段時間才能執行下一次 dubbo 調用。&lt;/p&gt; 
&lt;p&gt;由於這個原因導致 FutureAdapter 被放入 ThreadLocal 後，在新生代停留過長時間，最終晉升到老年代，這個&quot;過長時間&quot;對於此項目來説是 6 次 young gc 的間隔時長，這個時長的獲取方法會在後續説明。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）解決方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;對於此業務來説，這個 dubbo 調用可以改為查詢本地緩存，直接解決了問題。除此之外還有其他解決方案，需要結合自身業務選擇合適的方案。&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;直接使用 dubbo 的異步調用，而不是在上層再創建一個線程池來進行調用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;合理設置線程池的大小，提高線程的利用率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;寫一個 Dubbo Filter，每次同步調用完後清理 FutureContext（影響面可能較大，需自行評估風險）。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id=&quot;OSC_h2_10&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.2. Jackson 的 BufferRecycler 導致的大量 char[65536]&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）分析過程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;從 dominator tree 中我們能看到 char[]也佔用了相當大的一部分內存，展開 char[]，發現其中包含大量的 char[65536]，使用 oql 統計得知不被 gc root 引用的有 1600 個，佔用內存 200M 左右，被 gc root 引用的有 500 個，這種 char[65536]裏存儲的數據均為 http 接口返回值反序列化後的字符。其被 gc root 引用時的鏈路如下，均被 ThreadLocal 裏的 BufferRecycler 引用：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//c7c0700fe985adc40f2087ce8cd6a49e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在 Jackson 庫中，BufferRecycler 的主要作用是管理緩衝區的重用，可以減少頻繁的內存分配和釋放，從而降低垃圾回收的負擔，提高性能。但從堆上看，這些 char 數組裏不可達的數量遠大於可達的數量（1600:500），説明其複用率並不高，與其設計的目標不符，需要查看源碼才能搞清原因。&lt;/p&gt; 
&lt;p&gt;項目使用 jackson 的 ObjectMapper.&lt;/p&gt; 
&lt;p&gt;writeValueAsString() 方法對 http 接口返回值進行了反序列化，使用的 Jackson 版本為 2.10，該方法完整的執行流程如下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//62746e30c7bca82d5152bb3866beba57.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;簡單來説，jackson 在反序列化時，會將反序列化的結果存儲在多段 char[]裏，每當最後一個 char[]空間不夠存放結果時，就新建一個 char[]，大小為最後使用的 char[]的 1.5 倍，但不超過 65536，反序列化結束後將 char[]列表拼接起來就得到了結果，然後線程會將最後使用的那個 char[]存放到 ThreadLocal。此線程下次反序列化時，會從 ThreadLocal 取出這個 char[]進行復用。這樣的一個複用邏輯會有一個問題，參考下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//eb96347e6b14c8ab36c19ee341feb2b2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;圖中，_segements 是當前反序列化使用過的 char[]列表，currentSegement 是當前正在使用的 char[]。一個 char[]的大小最大為 65536。在第二次反序列化大對象時至少會創建一個新的大小為 65536 的 char[]（上一次的 char[]是 65536，再創建一個新 char[]其大小仍不能超過 65536）。可以看到在第一次反序列化結束後和第二次反序列化結束後，雖然 ThreadLocal 裏存放的 char[]大小都是 65536，但其實它們已經不是同一個對象了。這樣的一個替換是沒有必要的，完全可以一直複用同一個 char[]。&lt;/p&gt; 
&lt;p&gt;當業務所有 http 接口的返回值都大且流量也大時，每次保存在 ThreadLocal 裏的 char[65536]雖然會在下次反序列化結束時被替換導致其失去引用，但由於其在新生代只存活了一次接口請求的時間，所以不會晉升到老年代，可以被 young gc 回收。但是我們項目用來處理 http 請求的線程池都是同一個，這些接口的返回值只有一部分超過了 65536，在小於的時候 ThreadLocal 裏的 char[]不會被替換，當這個 char[]在 ThreadLocal 裏停留一段時間後，就會晉升到老年代，從而導致老年代內存增長。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）解決方案&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;關閉 Jackson 的 USE_THREAD_LOCAL_&lt;/p&gt; &lt;p&gt;FOR_BUFFER_RECYCLING，關閉該開關會在每次反序列化時創建一個 BufferRecycler，而不是複用 ThreadLocal 裏的 BufferRecycler，這樣可能導致 young gc 頻率提高。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;升級 Jackson 版本，請參考此&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FFasterXML%2Fjackson-core%2Fissues%2F1186&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;issue&lt;/a&gt;，2.17 版本的 jackson 在調用 releaseByteBuffer 時會避免較小或者相同大小的 char 數組替換原有數組。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;由於項目使用的 jackson 版本是 2.10，直接升級到 2.17 的版本跨度較大，可能帶來不必要的風險，因此採用了方案 1，上線後，young gc 頻率沒有明顯增加。方案 2 的 issue 裏有提到使用 2.16 版本引入的 RecyclerPool 代替基於 ThreadLocal 的實現，這也是解決方案之一。&lt;/p&gt; 
&lt;span id=&quot;OSC_h2_11&quot;&gt;&lt;/span&gt; 
&lt;h2&gt;3.3 對象晉升年齡閾值過小&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;（1）背景知識&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;java 對象從新生代晉升到老年代有多種原因，在本項目中，對象的主要晉升原因是在新生代長期存活，這個長期具體是多久有以下兩個判斷條件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;對象晉升年齡閾值&lt;/strong&gt;：&lt;/p&gt; &lt;p&gt;可通過-XX:MaxTenuringThreshold 啓動項進行配置，對於 CMS，默認值是 6。此參數定義了對象在年輕代存活的最大年齡，如果一個對象在年輕代經過 N 次 GC 後依然存活，它將會被晉升到老年代。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;動態年齡判定&lt;/strong&gt;：&lt;/p&gt; &lt;p&gt;在 survivor 區中小於或等於某年齡的的所有對象大小的總和大於 survivor 空間的一定比例時，大於或等於該年齡的對象就直接進入老年代，這個比例可以通過-XX:TargetSurvivorRatio 啓動項控制，默認值為 50，代表 50%。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;一個對象的年齡滿足上述兩個條件之一時，就會晉升到老年代，具體的晉升年齡可以通過在啓動項裏添加-XX:+PrintTenuringDistribution 獲取，添加該參數後的 gc 日誌如下圖：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//95469f548179176146627eff82e243f8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其中區域 2 的 (max 6) 代表-XX:MaxTenuringThreshold 啓動項配置的值，也就是説對象到達這個年齡一定會晉升，而 new threshold 6 代表對象實際晉升的年齡，上圖代表這次 young gc 因對象到達年齡閾值會導致 9946864 bytes 的對象晉升。&lt;/p&gt; 
&lt;p&gt;區域 1 代表動態年齡判定所需的空間大小，也就是 (survivor 空間大小 x targetSurvivotRatio)。此項目堆的單個 survivor 空間為 200M，所以只要在 survivor 區中小於或等於某年齡的所有對象大小的總和大於 200Mx50%，大於或等於該年齡的對象就會晉升，。&lt;/p&gt; 
&lt;p&gt;而下圖的對象是因為動態年齡判定才晉升的，這次 young gc 因動態年齡判定會導致 38660424 bytes 的對象晉升：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//870184931e6dce04cd75cc983f8e6b50.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）分析過程&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;優化前+調參前：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在進行 dubbo 和 jackson 以及其他業務代碼上的優化前，我們保存了當時的 gc 日誌，可以看到大部分對象都是因為年齡到達 6 晉升的，每次 young gc 約有 10M~16M 左右的對象晉升，顯然對象的晉升年齡閾值太小，需要調大。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//f3a1011e66fe04d2d69d6c1b3668989b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;優化後+調參前：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在調整 JVM 參數之前，我們決定先着手進行業務上的優化。因為直接進行參數調整可能會治標不治本，無法消除潛在的隱患。在完成業務代碼上的優化後，可以看到此時由於年齡達到 6 這一閾值晉升的對象大小從最開始的 10M~16M 降為了 4M 以下，意味着在新生代長期存活的對象數量明顯減少了，但仍然有優化空間。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//437d430248171225f9fc734e950ddba2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（3）解決方案&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在完成業務代碼上的優化後，我們對 JVM 參數進行了調整。將-XX:MaxTenuringThreshold 參數改為 15，-XX:TargetSurvivorRatio 改為 75%（實際上，通過調參後的 gc 日誌我們能確定對於這個項目來説，50% 也已經夠用，因為年齡 1 到 15 的對象佔用的總內存只有 38M 左右，遠遠小於單個 survivor 空間的 50%），以延長對象在新生代的存活時間。我們可以觀察到，儘管會有一些對象存活到年齡 15 的閾值才晉升，但是這部分對象的總大小變小了，大部分情況下都是小於 2M。這部分對象通過添加監控的方式判斷大概率是被移除（大小不足被淘汰，過期等原因）的 caffeine 本地緩存。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//af093a3fbad11a7dcb722a15773c467c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在經過上述一系列優化措施以及一些其他問題的修復後，該工程的 Full GC 頻率從最初的每天 120 次，總耗時 1 分鐘到 1.5 分鐘，成功降低到每天約 30 次左右，總耗時控制在 15 秒到 25 秒之間。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;① GC 次數優化曲線&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//f4b9de14ba7bd218936f4d33e324bf12.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//62c975b43a026c51f7287973bb1cf2aa.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;② GC 總耗時優化曲線&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//a82564cdfade061afcdd2b06695054fe.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;圖片&quot; src=&quot;https://oscimg.oschina.net/oscnet//05c620fbd4f4026dc4446999c7f92b83.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;總的來説，進行 GC 優化時，可以使用以下工具分析當前內存/GC 情況：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;先用 jamp 生成 dump 文件，再使用 MAT 進行分析，找到可能引發問題的對象。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用內存分配火焰圖找到哪些代碼在頻繁的分配內存。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用 GC 日誌分析 GC 情況，瞭解 GC 頻率/觸發 GC 的原因等信息。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;使用這些工具找到問題後，可以修改對應的業務代碼或者調整 JVM 相關參數，以優化 Full GC 頻率。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/vivotech/blog/18231016</link>
            <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18231016</guid>
            <pubDate>Sun, 13 Apr 2025 07:21:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>35 歲腦幹出血程序員發聲</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;近日，浙江杭州「35 歲程序員長期熬夜腦幹出血」引發關注。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/151248_PWGU_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;根據這名當事人的社交平台賬號資料進行彙總，大致信息如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;1、這位程序員姓吳，入行 8 年了。他去年 33 歲，35 歲應是虛歲。本來是想着趁年輕多掙點錢，讓老婆和孩子的生活更好一點。&lt;br&gt; 2、吳哥上一份工作月薪 3 萬，出事之前經常凌晨一兩點睡，然後早上 7 點起。那段時間壓力很大，睡得也很晚，很累。&lt;br&gt; 3、2024 年 7 月底出現腦幹出血，多次出血量達到 5 ml，採用保守治療，ICU 搶救 28 天，15 天昏迷，2 次病危。&lt;br&gt; 4、康復期間：從癱到走用了 1 個月，從走到能走好再用了 1 個月。&lt;br&gt; 5、女兒 5 歲，幼兒園小班，現在壓力都給到老婆了。&lt;br&gt; 6、吳哥説會考慮去擺攤，儘可能把生命活厚一點。&lt;br&gt; 7、根據他最近發的視頻，他自稱：身體情況基本上能像生病前的狀態。每天堅持做運動，自己也變得比以前更自信了。&amp;nbsp;&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;1145&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/151917_dpNh_2720166.png&quot; width=&quot;828&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;4 月 23 日晚，當事人&lt;em&gt;&lt;strong&gt;@腦幹出血的程序員&lt;/strong&gt;&lt;/em&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6210742110%2FPoIRp8i8j%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;髮長文&lt;/a&gt;&lt;/u&gt;講述發病經過以及現狀。他表示，自己在 ICU 一共待了 28 天，後來又去康復醫院待了 70 多天，回家之後也一直在康復和鍛鍊，現在已經恢復了大約 70%，但可能沒有辦法完全康復了。之前在一家創業型公司工作，當面臨裁員時，精神壓力比較大。生病之後，基本上沒了收入，家庭經濟壓力也比較大，女兒現在還小，自己也在想方設法考慮如何迴歸社會去掙錢，現在選擇做自媒體也是一個嘗試。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;「現在的我看待生活，覺得讓自己開心很重要，活得自由一點。之前想着我要掙錢，會在很多方面壓制自己，現在的話我覺得更多的可能要去好好體驗生活，讓自己過得快樂。也希望大家如果覺得累了，就歇一歇，我是前車之鑑。&lt;/p&gt; 
 &lt;p&gt;如果能見到以前的自己，我想對他説：「好好愛自己。」&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;原文如下：&lt;/p&gt; 
&lt;p&gt;我是新聞中腦幹出血的程序員。&lt;/p&gt; 
&lt;p&gt;我是去年 7 月底手麻腳麻已經有幾天了，當時以為是頸椎病，所以沒在意。等到 8 月 1 號的時候，晚上我下班回家，去打掃了一下衞生，突然就要嘔吐，趴在牀上緩解不了，就一直想吐，然後我就開車去了醫院，是的，那時候我還能開車。到了醫院拍了個 CT，診斷出腦幹出血。6 天之後我就出院了，那時候情況還挺好的，只有手麻腳麻，沒有其他症狀。結果去了康復醫院之後發現再次出血了，沒辦法就去了上海的大醫院。&lt;/p&gt; 
&lt;p&gt;當時我就一直在發燒，而且咳嗽，24 小時地咳，根本沒法睡覺，説話已經大舌頭了，手腳都不利索。醫生説我這個情況做不了康復，專家會診完就把我送進了 ICU。我最後只記得抽血檢查，然後就昏過去了。後來才知道，我腦幹部位長了一個血管瘤，可能是因為我壓力太大、過度勞累，那個血管瘤破了。&lt;/p&gt; 
&lt;p&gt;昏迷了大概 15 天吧，等再醒過來的時候，我發現自己手和腳都動不了，連聲音都發不出來，非常難受，就像被鬼壓牀一樣，被封印在牀上，既沒辦法克服，也沒辦法求助，這種狀況持續了大約一兩週。家人進來探視，我也只能瞪着眼睛盯着他們看，什麼也説不了也做不了。當時我只知道自己體溫和心率都很高，夢裏都在想怎麼把體溫和心率降下來。&lt;/p&gt; 
&lt;p&gt;我前後在 ICU 一共待了 28 天，後來又去康復醫院待了 70 多天，回家之後也一直在康復和鍛鍊。因為我在牀上躺了將近兩個月了，肌肉已經萎縮，一開始我連坐都坐不起來，得兩個人一起才能把我從牀上拖到輪椅上。最艱難的就是「接受我自己」，接受自己的現狀，接受現在的我與過去健康的我之間的差別。後來我的康復進展很快，一天比一天好。後來我才知道，不管是康復治療師還是我的主治醫生，都沒想到我能恢復成現在這個樣子，在他們看來我的病情挺嚴重，大概率是會癱瘓的。&lt;/p&gt; 
&lt;p&gt;現在我已經恢復了大約 70%，全身還會覺得麻木，尤其是左側的肢體麻木比較嚴重，左手的部分觸覺其實是丟失的，比如説我去摸被子，我是摸不出來那個被子和一張紙巾有什麼區別的，所以我左手基本上拿不住東西。舌頭還是歪的，説話有點大舌頭，脊椎也不太行。其實我也知道，我可能沒有辦法完全康復了，而且這輩子就得一直做康復。&lt;/p&gt; 
&lt;p&gt;我之前在一家創業型公司工作，人少活兒多，給我分配的工作也確實很多。後來公司內部出了一些問題，我倒是稍微閒了一點，但處於被邊緣化的狀態，面臨裁員壓力，那時候精神壓力就特別大。前前後後大約一年半的時間吧，我幾乎就是晚上 12 點以後睡，早上 6、7 點就得醒。我生病之後，公司也算是按規章來的，也來看望過，工資也是按我們當地最低標準給我發了。至於工傷，我也去諮詢過，因為腦幹出血不屬於特殊疾病，也不能算職業病，所以沒法認定工傷。&lt;/p&gt; 
&lt;p&gt;我生病的時候，5 歲女兒剛開始上幼兒園小班，所以我老婆在家帶小孩，我在 ICU 那邊一直是我爸媽和我舅舅照顧。從一開始 ICU 治療到後來去做康復，我前前後後已經花了 40 多萬了，錢的方面壓力很大。家裏現在還有多少積蓄，我一直不好意思問，只知道家人之前借了一些債。&lt;/p&gt; 
&lt;p&gt;以前家裏主要靠我掙錢，月薪有 3 萬，現在我已經斷收了，更多的壓力給我妻子，她一邊要賺錢，一邊還要照顧小孩。我現在這個身體狀況是掙不到錢的，所以也在想辦法去破這個局，怎麼才能迴歸社會去掙錢，減少家裏的開支，其實這也是很多腦出血的病人面臨的一個困局。&lt;/p&gt; 
&lt;p&gt;其實我們羣體很多人從患病之後心裏會變得很悲觀，甚至會抑鬱，所以我就想去開導鼓勵他們，讓他們更積極一點。我也聯繫了一些康復的病友，希望大家一起努力，讓社會上更多人看到我們知道我們。得了這種病之後，尤其是年輕人，後來的日子很難過的，我希望社會能夠幫助我們。&lt;/p&gt; 
&lt;p&gt;所以我做自媒體，拍視頻，有的時候還開直播，其實也在一個嘗試，如果我能做好了，那我的很多病友們也能看到他們自己成功的希望。但是做自媒體挑戰確實很大，我以前是做技術的程序員，每天更多是面對電腦，話也很少，是很內向的一個人，現在不得不去試着變得外向。直播帶貨的話，現在還説不好，以後看情況應該會，我覺得這個沒有什麼好拒絕的。&lt;/p&gt; 
&lt;p&gt;可能大家看到了我的短視頻賬號，上面有很多我康復訓練的過程。其實一開始我也沒打算做短視頻，是家裏人很關心我的情況，我媽才錄下來發給他們看。而我的心態也因為這次生病有了變化，我也不知道自己能活多久，發現我的手機相冊里根本就沒有我的照片或者視頻。女兒還小，我不知道他長大之後我還在不在，萬一哪天女兒想知道爸爸是什麼樣子，我可以有個地方記錄一下，可以讓她看到爸爸的樣子。後來就有一些病友開始私信我，説我的狀態讓他們看到了康復的希望，希望我繼續做下去，而且聯繫我的病友和家屬越來越多，這個時候我就覺得這個賬號我要一直做下去。&lt;/p&gt; 
&lt;p&gt;現在的我看待生活，覺得讓自己開心很重要，活得自由一點。之前想着我要掙錢，會在很多方面壓制自己，現在的話我覺得更多的可能要去好好體驗生活，讓自己過得快樂。也希望大家如果覺得累了，就歇一歇，我是前車之鑑。&lt;/p&gt; 
&lt;p&gt;如果能見到以前的自己，我想對他説：「好好愛自己。」&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;最後推薦兩份指南：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/p/howtolivelonger&quot; target=&quot;_blank&quot;&gt;程序員延壽指南&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/p/humansystemoptimization&quot; target=&quot;_blank&quot;&gt;人體系統調優指南&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346354</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346354</guid>
            <pubDate>Sun, 13 Apr 2025 07:16:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Perplexity 為 iOS 版應用添加 AI 語音助手功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Perplexity 今天對 iOS 應用進行&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fperplexity_ai%2Fstatus%2F1915064472391336071&quot; target=&quot;_blank&quot;&gt;更新&lt;/a&gt;，為其添加了 &lt;strong&gt;AI 語音助手功能 (Perplexity iOS Voice Assistant)&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/150420_FsMt_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;現在，蘋果用戶可以在應用中激活該助手，並讓它執行諸如撰寫電子郵件、設置提醒和預訂晚餐等任務 —— 某種程度上實現近似蘋果第一方 Siri 助手的使用體驗。&lt;/p&gt; 
&lt;p&gt;您甚至可以離開該應用並繼續與 Perplexity 對話，儘管它目前還不支持像 Android 那樣的屏幕共享。與此同時，蘋果承諾為 Apple Intelligence 驅動的 Siri 提供的一些對話式 AI 功能可能還需要一年多的時間才能實現。與 Apple Intelligence 不同的是，Perplexity 的助手可以在舊設備（例如我的 iPhone 13 mini）上執行這些操作。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1090&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/150645_H3Rh_2720166.png&quot; width=&quot;824&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;當 Android 版本於 1 月份推出時，Perplexity 的發言人表示，一旦「蘋果給予我們足夠的權限」，該版本就會登陸 iPhone 和 iPad，顯然這個目標已經實現。&lt;/p&gt; 
&lt;p&gt;Perplexity 的語音助手在 iOS 上還有其他限制，它並不能像 ChatGPT 和 Grok 等其他 AI 助手那樣讓它訪問設備相機並「查看」你所看到的內容以瞭解具體情況。但仍然可以使用標準的基於文本的聊天機器人來詢問有關圖片的問題，也不能讓它為你設置 iPhone 的定時鬧鐘——這些看似基本的功能仍然需要 Siri 來實現。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346353/perplexity-ios-voice-assistant</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346353/perplexity-ios-voice-assistant</guid>
            <pubDate>Sun, 13 Apr 2025 07:07:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>一季度末廣東人工智能核心產業規模超 2200 億元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;4 月 24 日，廣東省工業和信息化廳舉行一季度新聞發佈會。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;會上透露，一季度，全省先進製造業、高技術製造業增加值分別同比增長 5.9%、5.3%，均高於全省規上工業增加值增速，佔全省規上工業比重分別達到 55.3%、32.4%，產業結構和質量持續優化。其中，高技術產品產量快速增長，新能源汽車、儲能用鋰離子電池、民用無人機產量分別增長 29.9%、83.5%、48.2%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在人工智能產業發展方面，截至今年一季度末，全省人工智能核心產業規模超 2200 億元，穩居全國第一方陣。人工智能核心企業超 1500 家，其中：獨角獸企業 24 家，上市企業達 92 家，國家專精特新「小巨人」企業達到 147 家，數量位居全國第一；全省已發佈 63 個大模型，位居全國前列。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;291&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-60272d80dd5a346ed3cc39fabd06440e891.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;機器人產業發展方面，廣東已成為國內機器人產業的主要集聚區之一，形成以廣州、深圳、佛山、東莞為核心，珠三角協同發展的機器人產業格局。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;2019—2024 年，全省工業機器人產量從 4.47 萬台（套）增長到 24.68 萬台（套），2024 年工業機器人產量佔全國 44%，連續五年全國第一。今年一季度，廣東工業機器人累計產量 6.32 萬套、服務機器人 194 萬套，累計增長 31.1% 和 10.8%，延續了良好的增長態勢。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346351</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346351</guid>
            <pubDate>Sun, 13 Apr 2025 06:48:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Google I/O 2025 聚焦四大領域：Android、AI、Web 和雲</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;谷歌一年一度的開發者大會 Google I/O 2025 將於 5 月 20 日至 21 日舉行，目前谷歌已經提前公佈了部分會議議程。&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/143335_Y1X9_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:start&quot;&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fio.google%2F2025%2Fexplore&quot; target=&quot;_blank&quot;&gt;https://io.google/2025/explore&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;在本次大會中，Android 系統依舊是重頭戲之一。谷歌表示將舉辦一場關於安卓「進階版」用戶體驗設計 Material 3 Expressive 的展示活動。谷歌解釋稱，&lt;strong&gt;此次會議將重點介紹其「全新情感設計」&lt;/strong&gt;。同時，谷歌還將為開發者提供相關的設計文件和 alpha 代碼，以便他們能夠提前為適配這一新的設計理念做準備。&lt;/p&gt; 
&lt;p&gt;此外，&lt;strong&gt;谷歌還將重點討論 Android 系統的「桌面窗口化」和「手寫筆支持」功能&lt;/strong&gt;。桌面窗口化功能旨在幫助用戶更高效地管理多任務操作，提升生產力；而 Ink API 的引入則將進一步優化 Android 設備對手寫筆的支持，為用戶在繪畫、筆記記錄等場景中提供更出色的體驗。&lt;/p&gt; 
&lt;p&gt;在擴展現實（XR）領域，谷歌也準備了重大消息。大會期間，谷歌將詳細介紹 Android XR 的最新進展，包括其 SDK 開發者預覽版即將升級為 Beta 版本的消息。此外，谷歌似乎計劃在今年晚些時候正式發佈 Android XR。此前谷歌在 TED 2025 上展示了支持 Android XR 的智能眼鏡，內置了 Gemini AI 的「記憶」功能。&lt;/p&gt; 
&lt;p&gt;除了 Android 和 XR，谷歌的 AI 技術也將在 I/O 2025 上大放異彩。谷歌將展示其最新的 Gemini 模型進展，並探討未來 AI 軟件的發展方向。此外，谷歌還將介紹即將集成到 Chrome 瀏覽器中的新 AI API，這些 API 將能夠幫助用戶更高效地進行內容總結和創作。&lt;/p&gt; 
&lt;p&gt;本次大會的議程還包括對谷歌雲服務、Web 技術等領域的深入探討，旨在為開發者和用戶提供更多前沿技術和解決方案。&lt;/p&gt; 
&lt;p&gt;Google I/O 2025 將通過主題演講、會議、演示、社交活動和工作坊等多種形式，為參與者帶來豐富的內容和交流機會。&lt;/p&gt; 
&lt;p&gt;值得一提的是，谷歌在 2025 年世界移動通信大會（MWC）上已經確認，Android 16 將在今年第二季度&lt;a href=&quot;https://www.oschina.net/news/337398/android-16-is-on-track-for-june&quot;&gt;提前發佈&lt;/a&gt;。目前谷歌正在積極開發測試版，以確保該系統在 6 月正式推出時能夠滿足用戶的需求。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;閲讀更多：&lt;a href=&quot;https://www.oschina.net/news/333679/google-io-2025-kicks-off-on-may-20&quot; target=&quot;_blank&quot;&gt;Google I/O 2025 已定檔，議程涵蓋 Android 系統優化、Gemini AI 模型&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346347/google-io-2025-explore</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346347/google-io-2025-explore</guid>
            <pubDate>Sun, 13 Apr 2025 06:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>360 旗下納米 AI 發佈「MCP 萬能工具箱」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;360 旗下納米 AI 已正式發佈「MCP 萬能工具箱」，並於 4 月 23 日下午開始內測。首批受邀用戶為部分 AI 博主、媒體和普通用戶，目前，只有拿到邀請碼，才能開始體驗。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;360 集團創始人周鴻禕介紹，萬能工具箱基於 MCP 而生，已接入超過 110 款工具，覆蓋辦公協作、學術、生活服務、搜索引擎、金融、媒體娛樂、數據抓取等多種場景，且工具免費、可一鍵安裝、安全可信。目前，用戶可在納米 AI 客戶端直接調用各類工具，還能用工具創建屬於自己的智能體，提升工作效率，方便自身生活。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;306&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-fff7e9da989b5de475223200a722e6cbf27.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;納米 AI 產品負責人梁志輝介紹，MCP 讓大模型可調用工具，大家熟悉的 Deepseek 大模型過去只能做文本理解、內容生成的事情，但現在在納米 AI 客戶端裏給 DeepSeek 加上 MCP 工具，DeepSeek 能幫你作圖、編輯視頻，或者調用其他工具來幫你辦到過去大模型辦不到事，最終解決「AI 可用」的問題。當工具調用變得像呼吸一樣自然，AI 才能突破今天「只是個聊天機器人」的尷尬，才能進化成真正的「數字員工」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;梁志輝透露，納米 AI 這次上線的 MCP 萬能工具箱，是本着打造「AI 應用基礎設施」的目標在反覆打磨。360 的考量是，工具對 AI 應用意義重大，在人類歷史中，人類的腦容量水平並未發生根本改變，但人類世界在發生天翻地覆的變化，原因在於，人類創造工具利用工具的能力在無限加強，是工具改變了世界。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據介紹，除了「開箱即用」等特點納米 AI 在其萬能工具箱的開發過程中專門為所有工具做了安全檢測，能夠解決行業普遍面臨的 MCP 服務安全和信任等問題，確保用戶能在安心、安全的環境下使用。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「對比市場同類產品，納米 AI 本身集成了國內 16 家大模型廠商的 50 多款大模型，Deep Seek- R1 和阿里通義千問都在其中，用戶能選擇不同的大模型基座驅動工具乃至智能體。」梁志輝稱，納米 AI 還精心打磨了知識庫產品，可以讓 AI 更懂企業和個人，「納米 AI 萬能工具箱、知識庫、多模型，這些功能的組合，可以讓納米 AI 為用戶提供更好更實用的體驗。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346344</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346344</guid>
            <pubDate>Sun, 13 Apr 2025 06:23:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>特朗普簽署行政令，推動 AI 進入課堂</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;美國總統特朗普近日簽署了一項行政命令，旨在將人工智能納入&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;（AI）&lt;/span&gt;美國的課堂。&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;雖然該行政令的具體文本尚未公佈，但《華盛頓郵報》獲得的草案副本顯示，該行政令要求開展學生 AI 應用能力培訓，並推動學校與企業合作實施相關教學計劃。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;334&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bbbdec57534b4d20825a088011eae4027b1.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;該命令將指示教育部長琳達·麥克馬洪優先使用聯邦資金，培訓教師和管理人員如何應用 AI，並將其納入所有學科教學。&lt;/span&gt;此外，&lt;span style=&quot;background-color:#ffffff; color:#222222&quot;&gt;美國政府還計劃成立一個人工智能教育工作組，鼓勵聯邦機構與私營部門合作，目標是教授學生「基本的人工智能素養和批判性思維技能」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346341</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346341</guid>
            <pubDate>Sun, 13 Apr 2025 06:13:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 預測 2029 年收入激增至 1250 億美元，2030 年達 30 億月活用戶</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 近期發佈了一項關於未來收入的預測，預計到 2029 年，其總收入將達到 1250 億美元。其中，AI 代理業務和渠道收入將成為主要驅動力。根據預測，AI 代理業務將佔總收入的近四分之一，預計收入將達到 290 億美元，而渠道收入則預計達到 250 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;img height=&quot;222&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-bad840387250fc1bdbfdc3a7d49fba94372.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;隨着 ChatGPT 的成功，OpenAI 的收入在 2023 年達到了 37 億美元，較前一年增長近四倍。當前，該公司的周活躍用戶已超過 5 億，相比去年底的 3 億，顯著增長。值得注意的是，OpenAI 預計到 2029 年，其 AI 代理的銷售額將超越 ChatGPT 的收入，這表明 AI 代理市場的快速擴張。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 的 AI 代理產品價格不一，面向高收入知識工作者的每月訂閲費用為 2000 美元，而針對博士級研究的產品則可高達每月 20000 美元。這使得 OpenAI 的銷售額與行業巨頭英偉達和 Meta 相媲美。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;除了 AI 代理，OpenAI 還在探索多元化的收入來源。雖然 CEO Sam Altman 對傳統廣告持謹慎態度，但他提到可能會通過用戶在 ChatGPT 或 AI 代理上發起的銷售收取推廣費。此外，OpenAI 預計到 2029 年，通過免費用戶和其他產品的收入將達到 250 億美元，約佔總收入的五分之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;在控制成本方面，OpenAI 預計未來四年將消耗約 460 億美元的現金用於模型訓練和運營成本。然而，預計到 2029 年，公司將實現現金流轉正，並在該年度產生近 120 億美元的現金。推理成本的增長將在未來五年逐漸放緩，這將有助於提升公司的利潤率，毛利潤比例預計將從去年的 40% 提升至接近 70%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#242424; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;OpenAI 預計用戶數量將大幅增長，到 2030 年將達到 30 億月活用戶、20 億周活用戶和 9 億日活用戶。這些預測使得軟銀等投資者願意以 2600 億美元的估值向 OpenAI 注入 400 億美元的新資本。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346316</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346316</guid>
            <pubDate>Sun, 13 Apr 2025 03:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>OpenAI 正在打造「最強」開源模型，計劃今年初夏發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;今年 3 月下旬，OpenAI 宣佈將在年內推出自 GPT-2 以來的首個&quot;開源&quot;語言模型。隨着該公司與 AI 開發者社區的交流持續推進，關於這款模型的更多細節也逐步浮出水面。&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechcrunch.com%2F2025%2F04%2F23%2Fopenai-seeks-to-make-its-upcoming-open-ai-model-best-in-class%2F&quot; target=&quot;_blank&quot;&gt;據 TechCrunch 報道&lt;/a&gt;，知情人士透露，OpenAI 研究副總裁艾丹·克拉克（Aidan Clark）正主導這項開發工作，目前仍處於初期階段。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/111938_NBnV_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;OpenAI 計劃在今年初夏發佈該模型，目標是打造一個在開源推理模型中達到頂尖水平的產品。這款模型定位為推理能力模型，類似於 OpenAI 現有的 o 系列產品。&lt;/p&gt; 
&lt;p&gt;知情人士稱，OpenAI 正考慮為該模型採用一種高度寬鬆的開源許可協議，幾乎不設使用或商業限制。這與 Meta 的 Llama、谷歌的 Gemma 等開源模型形成對比，後者因使用條款過於繁瑣而受到批評。OpenAI 顯然希望避免步其後塵。&lt;/p&gt; 
&lt;p&gt;目前，OpenAI 面臨來自包括中國 AI 實驗室 DeepSeek 在內的開源策略競爭者的挑戰。這些&quot;開源&quot;競爭者將模型提供給 AI 社區用於實驗，在某些情況下還允許商業化使用，與 OpenAI 此前更為封閉的做法形成鮮明對照。&lt;/p&gt; 
&lt;p&gt;這種開放策略已被證明對部分企業極其成功。Meta 在 3 月初宣佈，Llama 系列模型的累計下載量已突破 10 億次。而 DeepSeek 也迅速積累了大量用戶，並獲得本土投資者的關注。&lt;/p&gt; 
&lt;p&gt;據悉，OpenAI 此次推出的開源模型將支持純文本輸入輸出，可在高端消費級硬件上運行。開發者還可能可以選擇是否啓用「推理模式」——推理功能雖能提升準確性，但會以增加延遲為代價，這與 Anthropic 等公司近期發佈的推理模型相似。&lt;/p&gt; 
&lt;p&gt;如果此次發佈反響積極，OpenAI 還計劃後續推出更多開源模型，可能包括更小規模的模型版本。&lt;/p&gt; 
&lt;p&gt;OpenAI 首席執行官山姆·奧特曼（Sam Altman）此前曾公開表示，公司在技術開源方面「站在了歷史的錯誤面」，並呼籲重新審視開源戰略。&lt;/p&gt; 
&lt;p&gt;奧特曼在今年 1 月參加問答活動時指出：「我個人認為，我們需要制定一種新的開源策略。儘管並非所有 OpenAI 員工都認同這一觀點，目前這也不是我們的首要任務，但今後我們會推出更好的模型，不過領先優勢可能不像以往那樣顯著。」&lt;/p&gt; 
&lt;p&gt;他還表示，這款即將發佈的模型將經歷嚴格的「紅隊測試」和安全評估流程。知情人士透露，OpenAI 將為該模型發佈「模型卡片」（Model Card），即一份全面的技術文檔，詳盡展示模型在內部與外部基準測試、安全性評估等方面的結果。&lt;/p&gt; 
&lt;p&gt;奧特曼上月發文稱：「我們會在發佈前，依據‘模型準備度框架’對其進行全面評估，並在已知該模型發佈後可能被修改的前提下，做更多的安全準備工作。」&lt;/p&gt; 
&lt;p&gt;儘管如此，OpenAI 近年來也因對部分新模型倉促推進安全測試、未及時發佈模型卡等問題，受到人工智能倫理學者的批評。奧特曼本人也曾在 2023 年 11 月被短暫罷免前，在模型安全審查方面誤導高管。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/342166/openai-open-model&quot; target=&quot;news&quot;&gt;OpenAI 宣佈將開源推理模型&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/340236&quot; target=&quot;news&quot;&gt;OpenAI CEO 奧特曼 ：DeepSeek 教訓了我們，GPT-5 將免費開放&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334567&quot; target=&quot;news&quot;&gt;OpenAI 即將開源新模型，CEO 發起投票公開徵求意見&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346315/open-ai-model-best-opensource-coming-soon</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346315/open-ai-model-best-opensource-coming-soon</guid>
            <pubDate>Sun, 13 Apr 2025 03:20:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌 AI 聊天機器人 Gemini 全球每月活躍用戶 3.5 億</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;根據谷歌正在進行的反壟斷訴訟中披露的內部數據，截至 3 月份，谷歌 AI 聊天機器人 Gemini 在全球每月擁有 3.5 億活躍用戶。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-61ea9a0e05eb37744a7bdaa96a39bff52f5.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;《The Information》首先報道了這一統計數據，稱谷歌人工智能產品的使用量在去年呈爆炸式增長。&lt;/p&gt; 
&lt;p&gt;根據谷歌的數據，Gemini 在 2024 年 10 月的日活躍用戶僅為 900 萬，但上個月，該公司的日活躍用戶已達 3500 萬。然而，Gemini 仍然落後於業界最受歡迎的人工智能工具。&lt;/p&gt; 
&lt;p&gt;谷歌在法庭上展示的數據顯示，該公司估計 ChatGPT 在 3 月份的月活躍用戶約為 6 億。這使得 ChatGPT 的用戶羣與 Meta AI 相當。Meta AI 首席執行官馬克·扎克伯格在 9 月份表示，其月活躍用戶已接近 5 億。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346312/google-gemini-has-350m-monthly-users-reveals-court-hearing</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346312/google-gemini-has-350m-monthly-users-reveals-court-hearing</guid>
            <pubDate>Sun, 13 Apr 2025 03:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>循序漸進搭建複雜 B 端系統整潔架構</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;作者：京東零售，趙嘉鐸&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;：信息時代技術更迭和傳播速度不斷加快，技術變得泛娛樂化，大數據、雲計算、區塊鏈、元宇宙、大模型，一代代技術熱點在社會輿論的裹挾之下不斷地吸引着資本的眼球，技術人員為了不被時代所淘汰也不得不時刻追趕潮流。在這樣一個時代背景下，軟件工程作為一門不起眼到有些枯燥的古老學科，似乎早已被開發者們遺忘在角落。作為一名技術人員我們自然應該時刻保持對前沿技術的追蹤，然而，當發生線上問題我們卻面對着成片的屎山代碼毫無頭緒時；當業務方提出個性化需求我們卻因為不敢對系統做出修改而強迫對方做出妥協時；當一次請求處理流程中出現多達數萬次重複地數據庫操作而影響到整個系統的穩定性時，大家都應該沉下心來思考一下，我們是不是忘記了作為一名程序員的初心和對代碼的極致追求。 還記的當年我抱着朝聖的心態從傳統行業踏入京東職場時的興奮與期待，然而這份期待很快就被四處可見的屎山代碼給澆滅了，後來從朋友口中瞭解到其他頭部互聯網廠商的業務系統其實也是半斤八兩。這似乎是軟件行業中的一個電車難題，一邊是無盡的業務需求和倒排的工期，一邊是補丁摞補丁的糟糕代碼，是繼續泡在醬缸中縫縫補補還是向屎山代碼説不，開發人員被困在中間不知該如何抉擇。然而事實上，追求整潔架構與提升研發效率之間從來就不是一個悖論。正如 Robert C.Martin 在其著作《Clean Architecture》中所説：「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不管你多敬業、加多少班，（在面對爛系統時）你仍然會寸步難行，因為你大部分的精力是在應對混亂（而不是在開發需求）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。」造成我們整日加班趕需求和疲於應對線上問題的根本原因，恰是那些不被我們重視的糟糕代碼。業務天然就是複雜的，這決定了軟件系統的本質複雜度（Essential Complexity），這種複雜度是無法通過軟件架構去消除的。那麼解決上述問題的關鍵就是找到某種架構去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引導開發者對複雜業務進行問題拆解，分而治之，在這個基礎上再通過標準規約和工具約束及輔助開發者寫出可理解、易拓展、好維護的代碼，以此來對抗軟件系統本身的偶然複雜度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;（Accidental Complexity，Frederick P.Brooks,Jr, 《The Mythical Man-Month》）。 為了找到這樣的一種架構，我們從 19 年就開始對各類架構思想和實踐案例進行了深入地學習和探索，並在接下來的 3 年時間裏通過局部架構演進的方式進行了大量的實踐驗證，在這個過程中我們對這些架構思想的理解也從早期的懵懂教條式執行逐漸做到了如今的融匯貫通，並最終在 22 年底形成了一套成體系的框架及方法論，並在京東廣告投放平台重構工作中進行了實戰應用。本文也將以廣告投放平台架構升級作為背景案例，從設計思想到落地框架，循序漸進地為您介紹這套新架構的誕生始末，而這套架構思想的演進歷程則在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxingyun.jd.com%2Fshendeng%2Farticle%2Fdetail%2F25548%3FforumId%3D43%26jdme_router%3Djdme%253A%252F%252Fweb%252F202206081297%253Furl%253Dhttp%253A%252F%252Fsd.jd.com%252Farticle%252F25548&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《改進我們的架構》&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;一文中有詳細的闡述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_1&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一、架構升級背景&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;與高併發請求給 C 端系統帶來的系統高性能、高可用能力挑戰相比，B 端系統所面臨的挑戰則是如何在海量多維度、多模塊、多場景融合的複雜業務需求中保持系統健康、穩定、快速地迭代。京東廣告投放平台就是一個典型的複雜 B 端業務系統，它承擔着集成廣告業務體系中各個垂直業務模塊，構建、維護和分發廣告物料的重要職責。經過多年迭代，京東廣告投放系統目前已集成 40 餘個垂直業務系統，支撐 7 條核心產品線，先後賦能 10 餘個獨立投放平台，維護着一個擁有 200 餘個業務實體的龐大數據模型，每天都需要處理海量長事務、多系統交互的複雜業務請求。同時作為整個廣告業務鏈路上的首發環節和功能門面，廣告投放系統每年都要承接 400 餘個來自不同業務方的差異化需求、執行 1000 餘次代碼合併及 600 餘次功能發佈。在極高的需求密度之下，作為撬動廣告主預算的重要戰場，投放系統在為廣告主提供優秀投放體驗的同時，還需要每天向廣告業務鏈路穩定輸送 PB 級的物料數據，這對系統的性能、穩定性以及團隊的研發效能提出了極高的要求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//410eb3a6f0c1a4c961386a9242184754.jpg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;廣告投放平台是一個典型的多平台、多模塊集成的複雜 B 端系統&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_2&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;二、傳統架構的研發痛點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;近年來隨着技術和業務的飛速發展，新的廣告業務形態和投放組件層出不窮，廣告物料結構愈發複雜。與此同時，為了提高廣告主留存和撬動預算，業界各大平台都在向着極簡版、智能化和集成化的方向發展。這些新的業態發展方向一方面給廣告主帶來了更加便捷和流暢的投放體驗，另一方面也讓投放系統內部業務流程愈發複雜，如何用有限的研發人力快速支撐越來越多的多場景複雜業務需求成為各大廣告投放平台必須要解決的關鍵問題。然而傳統的「三層架構+面向數據庫編程」的研發模式由於過於簡單的封裝及粗暴的設計思想在面對這些高複雜度業務需求時變得愈發吃力，逐漸成為阻塞研發效能提升的罪魁禍首。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_3&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;客觀：傳統架構面對高複雜度的業務時毫無應對之法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作為一個典型的 Web 應用，廣告投放系統長期以來採用的都是傳統的三層架構，這種沒有架構的架構極其簡單、易上手，因此一直以來都是業界的主流。但是由於它缺少統一明確的邏輯拆分與封裝工具，業務的複雜度會等比滲透到代碼實現中，進而導致系統的代碼複雜度飆升，模塊之間隨意耦合，邏輯糾結纏繞，經過幾輪迭代之後就成了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;看不懂、動不了、不敢動&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的醬缸代碼。這些看似基礎的編碼問題實際上卻是阻礙我們研發效能提升的罪魁禍首：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需求交付提速困難&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：不同平台、產品線及業務場景邏輯交織，晦澀難懂，導致系統功能迭代時梳理及設計耗時漫長，同時在測試階段需投入大量精力進行聯動功能迴歸；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;對新業態的接受度低、響應能力差&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：系統拓展性差，且模塊間深度耦合，在面對新業態時我們卻為了控制影響範圍而不得讓業務選擇讓步，結果錯失商機。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;問題評估和排查效率低下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;缺少明確統一的邏輯歸屬與封裝準則，邏輯四處複寫與逃逸，導致問題定位時間長，難以快速評估影響範圍和修復方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;4.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接口性能與穩定性下降：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;混亂的封裝與複用導致一次接口請求就會產生導致大量重複的 IO 操作，嚴重影響接口性能，每臨大促都需要花費大量人力進行性能優化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;span id=&quot;OSC_h2_4&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;主觀：「面向數據庫編程」的設計思維讓系統加速腐化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我們的業務本質就是獲取、處理、存儲及傳輸數據，在傳統架構中業務邏輯通常以事務腳本（Transaction Script）的形式實現：業務規則直接在開發者的大腦中轉化為數據庫的增刪改查操作（這也是很多程序員調侃自己是 CRUD 工程師的原因），然後被寫到代碼裏。這種模式在場景單一、需求簡單的業務發展早期階段可以快速實現功能，但是隨着業務複雜度的提升，這種過於粗糙的設計思維所帶來的問題就會逐漸顯現出來：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;難以建立對整個數據模型的全景認知&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：完整的數據模型信息被拆分到不同的業務接口實現中，往往需要對整個工程代碼進行逐行 review 才能梳理出完整的數據模型，當工程代碼量和數據模型膨脹到一定程度後，模型梳理成本急劇飆升。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模型野蠻膨脹、存在大量相似或重複的實體，增加系統運維成本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：數據模型全景認知的缺失導致開發者難以進行統一的頂層設計，數據模型泛化表達能力弱，在多需求並行開發過程中極易形成信息孤島，無法實現模型合併與共享，系統中存在大量相似的業務實體與庫表結構。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代碼對業務語義表達能力弱、業務知識傳承效率低下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：代碼經過開發者的轉譯失去了對業務語義的直接表達，導致系統中存在大量只有開發者本人才能理解的魔法邏輯，系統維護與人員更迭成本過高。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要想解決上述問題，就亟需一種面向未來的架構思想來指導我們對系統進行全面地升級。在此背景下，業界眾多平台紛紛進行了領域驅動設計思想的探索和嘗試，經典的案例有阿里的星環與 COLA、快手的 Baldr 等，京東也推出了藏經閣平台與 Matrix 框架。這些實踐案例和架構迭代路線給了我們很多啓發，本着腳踏實地、事實就是的基本原則，在經過充分調研和長期驗證之後，我們立足於京東廣告業務的本質特徵推出了一套可複用的複雜 B 端業務支撐框架，其核心內容可以分為&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PICASO 能力編排框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;與&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合及資源庫機制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;兩部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;網絡上能夠找到很多介紹領域驅動設計思想的文章，但是大多都聚焦在對領域驅動設計中眾多術語和概念的介紹上，對領域驅動設計思想的落地實踐卻淺嘗輒止。再加上中英文語境的差異和國內外軟件開發生態的不同，都在很大程度上將領域驅動設計思想「妖魔化」了，讓很多同學望而卻步或者不得其要義。然而我們在摸索實踐的過程中逐漸意識到，領域驅動設計作為一種軟件架構設計的指導思想其實並沒有創造什麼新的東西，而是對基本的軟件設計思想進行的系統化總結和昇華。但正是這種系統性的歸納將各類技巧、準則和思想凝練成體系化的方法論，並且在行業內形成了被所有開發者所公認的行為準則，這才是領域驅動設計思想強大生產力的源泉和魅力所在。 與傳統的三層架構相比領域驅動設計思想其實並沒有複雜多少，其要義就在於保持業務、模型與代碼三者的統一，只要掌握了這一點，領域驅動設計思想中的各種理念都將是水到渠成的事情。初讀《領域驅動設計》時書中眾多晦澀的術語也曾讓我十分困惑，但其中的很多內容其實已經是很多優秀架構師的工作日常了。隨着對領域驅動設計思想理解的逐漸深入，我不時會產生「咳，這説的不就是 xxx 麼」的感慨。這也是沒有辦法事，誰讓國外那些提前入局的大佬們牢牢掌握着專業領域的命名權呢。也正因為如此，在本文中我們不會去介紹、甚至會盡量避免引用領域驅動設計理論中的術語，避免大家一開始就陷入到那些晦澀難懂的概念裏而無法自拔。希望大家能將更多的精力放在框架內各個模塊的設計動機與運行機制上，這才是我們最應該思考和關注的內容。至於領域驅動設計思想在新架構演進過程中的指導作用我們將會在《領域驅動設計與 PICASO 框架》一文中進行詳細地介紹。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_5&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三、升級措施&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;span id=&quot;OSC_h2_6&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（一）PICASO 框架：從混亂到有序，構建圖書館式的代碼架構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;圖靈獎得主 Frederick 在其著作《The Mythical Man-Month》中將軟件系統的複雜度劃分為本質複雜度（Essential Complexity）和偶然複雜度（Accidental Complexity），其中本質複雜度是問題本身所具有的複雜度，與求解方法無關，而偶然複雜度是求解方法引入的複雜度。本質複雜度無法避免，但是我們可以通過優化求解方法來儘可能降低系統的偶然複雜度。這給了我們很大的啓發，業務天然就是複雜的，這是一個客觀事實，架構設計的目標&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不是消除業務上的本質複雜度，而是應該引導和輔助開發者更好的拆解和分析業務帶來的複雜度（是 handle 而不是 eliminate）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;同時，軟件架構應該提供足夠靈活的標準規約與框架工具，讓所有開發者都能夠按照統一的思想寫出可理解、易拓展和好維護的代碼，減少甚至是消除由於沒有封裝或封裝不統一帶來的偶然複雜度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。在這一思想的指導之下，經過兩年多的打磨，我們推出了 PICASO 框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 概述&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 是一套以領域驅動設計（Domain-Driven Design, DDD）作為思想內核，專門為集成式複雜業務系統設計的通用基礎框架。它的命名來自「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;P&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ICASO &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;s a &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;C&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ontextual &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;A&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;bility &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;S&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;eparate and &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;O&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;rchestrate Framework（PICASO 是一種基於上下文的能力分解與編排框架）」的首字母縮寫。有趣的是這個縮略詞的發音恰好與西班牙現代派繪畫大師畢加索（Picasso）的姓名讀音相同，畢加索在畫作中經常對人體部位進行解構和重組，在接下來的介紹中我們將發現這一點與 PICASO 框架所強調的能力拆分與編排思想有異曲同工之妙，而這也是我們最終採納這個命名的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的命名啓發自筆者比較喜愛的一個開源項目——WINE，其功能是通過內核適配器在 Linux 環境中運行 Windows 應用程序，其命名也是這種藏頭詩的風格：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;W&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;INE &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;s &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;N&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;ot &lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;E&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;umlator（WINE 不是模擬器）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架的職責是引導開發者將複雜業務流程正交分解為多個簡單子問題，然後將這些簡單子問題的處理邏輯封裝為邊界明確的標準可執行實體，在 PICASO 框架中這些可執行實體被稱為&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。完成能力拆解之後，開發者可以通過 PICASO 提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力編排框架&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;將不同的領域能力的組合成一個完整的請求處理流程，這個處理流程所在的可執行實體就是一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域服務&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。領域服務會為每次請求生成一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;對象，通過這個上下文對象可以在不同領域能力以及領域能力與領域服務之間進行數據傳遞與共享，進而避免重複及碎片化的 IO 操作。PICASO 框架還提供了開箱即用的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通用可執行實體發現與路由組件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，開發者可以通過該組件按功能域對領域能力及領域服務進行分組和聚合，每個分組對外暴露統一的請求路由門面，從而向上層調用實體屏蔽分組內部的場景複雜度，進而實現複雜度降維。如果在領域能力或領域服務的路由維度之外還存在其他維度的細微邏輯差異，開發者可以通過 PICASO 提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拓展點&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;機制進一步實現差異點分離。同樣的，拓展點依然可以接入通用可執行實體發現及路由組件，向上層實體屏蔽拓展點所在功能域內的場景複雜度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上文對 PICASO 框架的整體架構進行了整體地介紹，接下來我們將從軟件系統複雜度根源分析開始，循序漸進地詳細闡述 PICASO 各個模塊的設計動機及運行機制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//4b633e93ce342520a42a00636c7d38fd.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;PICASO 框架整體架構&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_8&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;複雜度的根源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;軟件設計的本質就是持續對抗軟件本身產生的複雜度，早在最開始進行新架構探索的時候我們就意識到，構建整潔架構的前提是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#ff4d4f&quot;&gt;釐清系統複雜度的根源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_9&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本質複雜度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通過對複雜業務系統發展歷程的分析，我們發現&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;業務複雜度一般來自水平方向上的多維度拓展和垂直方向上的多模塊集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;業務發展的早期往往都是單一場景，隨着業務的發展，產品形態開始變得豐富多樣，服務的用戶及業務方也越來越多，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;業務架構從原來的單點結構逐漸演變為複雜的樹狀結構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，樹的每一層都代表一個業務維度，業務的發展讓系統在水平方向上呈現出多維度增長的特徵。以廣告投放系統為例，最初的投放系統只有合約展示包段一種業務形態，隨着程序化廣告和智能廣告的興起，廣告投放及播放形式層出不窮，業務樹中開始出現「產品線」的維度；而為了服務不同業務方，我們在系統中增加了「投放平台」的維度；對不同投放標的物的支持又在系統中引入了「計劃類型」的維度......就這樣廣告投放系統的業務架構也逐漸演變成了如下圖所示的複雜樹狀結構。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6b86ee6915b53b63cf4d611d4d061243.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;多維度、多模塊、多場景的廣告投放業務&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;而在垂直方向上，早期的業務流程一般比較簡短，只有少數幾個業務環節。隨着業務的發展，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;系統功能越來越豐富，業務流程也變得愈發冗長，開始呈現出鮮明的模塊化特徵&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。同樣以廣告投放系統為例，早期的廣告物料只有時段、預算、出價、創意幾個基礎模塊，隨着業務的發展陸續新增了智能出價、人羣定向、地域定向、商品定向、智能創意、智能選品等業務模塊，物料創編流程也越來越冗長。除此之外，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;單個模塊內部也開始出現多場景分化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如廣告投放系統中的智能出價模塊內部就存在 tCPA、tROI、eCPC、MC 等不同的智能出價模型，其數據模型及業務規則也不盡相同，這進一步增加了業務的複雜度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本小節從業務架構演進歷程的視角分析了業務複雜度的來源，這構成了系統的本質複雜度。而對這些複雜業務規則的實現方案（好的、或者是壞的）就成了系統偶然複雜度的來源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_10&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;偶然複雜度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;業務在多個維度上向着熵增的方向不斷發展，但是我們的代碼始終只有一套，不同維度的業務場景可能對同一個業務環節提出不同的個性化需求，造成不同維度的業務邏輯互相耦合，代碼中開始出現大量層層嵌套的 if-else 分支，圈複雜度不斷飆升，系統開始出現腐化跡象。此時一些工程師可能會意識到這個問題並開始着手優化，但是由於缺少統一的邏輯封裝與拓展工具，再加上開發者的水平與技法也不盡相同，導致優化方案五花八門，這種方案上的不一致反而進一步增加了代碼的複雜度。除此之外，隨着系統集成的業務模塊越來越多，業務流程愈發冗長，與外部子系統的交互邏輯越來越複雜，開發者不得不去處理超時、重試、冪等、長事務、分佈式事務及跨系統的數據一致性等問題，這些技術方案的引入對系統來説也是複雜度的來源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;對架構設計的啓發&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;從上面的論述中可以看出，系統偶然複雜度的高低在很大程度上取決於開發者能否分析處理好業務的本質複雜度，另外在多人協作開發場景中，軟件架構的標準性和解決方案的一致性也是決定系統偶然複雜度的重要因素，這就是我們推出 PICASO 框架的根本原因。我們希望 PICASO 能夠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引導開發者對複雜業務流程進行模塊化拆解，採用分治思想逐一擊破，並通過標準的邏輯封裝規約與框架來實現多維度邏輯拓展&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，讓團隊中每一位開發者都能夠以統一的思想寫出清晰、簡潔、有序、可檢索的代碼。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;到這裏相信有些讀者可能會產生一些疑問，既然軟件系統的偶然複雜度是技術方案本身的複雜度，那麼引入 PICASO 框架是否也在增加系統的偶然複雜度呢？答案是肯定的，新框架的引入的確會增加系統的偶然複雜度。PICASO 框架由於採用了全新的設計思想，在推行早期曾經歷過痛苦的磨合期，也出現過不少由於開發者不理解新架構的運行機制而導致的設計缺陷或線上問題。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;任何架構迭代之路都是螺旋上升的，新技術帶來的系統複雜度畢竟是靜態的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，隨着開發人員對新架構運行機制及使用技巧的逐漸掌握，系統便開始趨於穩定，新技術帶來的優化收益也會逐漸顯現出來。但是如果我們不對現有的架構做出升級，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;那麼系統將隨着源源不斷的業務需求向着不可控熵增的方向不斷發展，由此帶來的系統複雜度將是動態且持續增加的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h3_12&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的複雜度應對之道&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分析完系統的複雜度來源之後，接下來我們將詳細介紹 PICASO 如何協助開發者對抗軟件系統的複雜度。IEEE 對軟件架構的定義為：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;架構是由系統之間的組織、組件及組件之間的關係、以及對設計與演進的指導原則組成的，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其中前兩者是具體的實體框架，後者是指導思想。而軟件架構的指導思想往往決定着前兩者的實現，對指導思想的理解與掌握程度也直接決定了開發者能否在實際業務中用好架構。以 Spring 框架為例，Spring 的指導思想為：控制反轉（IoC）、依賴注入（DI）及面向切面編程（AOP），這三大核心思想一方面直接決定了 Spring 框架核心模塊的實現，另一方面也是開發者要想用好 Spring 則必須掌握的內容。而對 PICASO 來説，其指導思想可以概括為：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力拆分、拓展點抽象及能力編排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//967fe48ec6941c59ba38e12ebbeb95a3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;軟件架構的構成&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_13&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域能力拆分與路由助力多模塊集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;神經認知學家喬治·米勒在他的論文《神奇的數字 7》中指出人腦能夠同時處理的信息容量是有限的，人腦的短時記憶容量為 7（7 個數字、6 個字母或 5 個單詞），後來的研究更是將這個數字降到了 4 個左右。所以當冗長的業務流程疊加上多維度的個性化訴求，系統的業務複雜度將飆升為&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;，這顯然超出了我們大腦的瞬時處理容量，此時就需要利用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;關注點分離&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分類&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分層&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;思想對複雜問題進行求解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分離&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;關注點分離&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;（Separation of concerns，SOC）就是把複雜問題正交分解為多個互不相關的最小子問題，聚焦整體問題的局部複雜性，逐步進行求解&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我們在《複雜度的根源》章節中指出，複雜的業務系統往往會呈現出鮮明的模塊化特徵，因此我們可以自然而然地根據業務模塊的功能邊界對冗長的業務流程進行拆分，然後聚焦單個模塊進行設計與抽象，避免陷入多模塊、多場景互相耦合的思維泥沼。PICASO 框架為此引入了領域能力及領域服務的概念，其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;用來承接單個業務模塊內部的邏輯細節，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域服務&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;則負責通過組合不同的領域能力實現一個完整的業務流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如下圖所示，以單元新建流程為例，我們可以把單元新建流程劃分為：單元基礎信息構造、優化目標設置、出價設置、人羣設置、地域定向設置和商品定向設置多個子模塊，我們可以將這些模塊內部邏輯封裝成領域能力，然後通過這些能力的組合構建一個完整的單元信息領域服務。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//0da69c0b57d00ace6c80601fdbe11a3e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;一個完整的業務流程可以拆分為多個原子業務模塊，每個原子業務模塊還可以按照其內部的業務模式進行進一步細分&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架中的領域服務與 DDD 思想中的領域服務是同一個概念，其職責和定位都是承接無法在單個實體與值對象內部直接實現的業務邏輯（事實上，B 端系統對外提供的大部分服務都無法在單個聚合內直接實現）。而領域能力的概念則經常出現在一些企業級中台化框架中，如阿里的星環、京東的 Matrix 等。儘管當年如火如荼的中台化戰略如今已經偃旗息鼓，但是我們還是將這個命名引入到了 PICASO 中，因為我們確實沒有找到一個比它更合適的命名，可以如此形象地描述一個足夠內聚、自治且能夠被複用和拓展的原子實體。當然 PICASO 中的領域能力與那些企業級中台化框架中的領域能力相比要輕量和易用的多，不需要繁瑣的身份申請，也不存在跨工程熱加載的問題，畢竟中台化的重心在管理域平台及前中台團隊的協作上，而 PICASO 則始終聚焦在代碼本身的複雜度控制上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;其實中台化也好，組件化也罷，系統的複雜度就擺在那裏，不管用什麼由頭，要想提升團隊整體的研發效能，它都是我們必須要去解決的一個問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt; 在本小節的論述中，領域能力似乎就是根據業務模塊的邊界簡單劃分出來的。但是在實際開發中的能力劃分要複雜的多，需要綜合考慮能力的應用場景、會被哪些領域服務使用、以及能力之間的依賴關係等諸多因素進行反覆地推導和調整。本文對能力劃分方法論只是簡單地做了問題引入，更加具體的內容我們將在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳實踐——能力識別與劃分&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中進行詳細介紹。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域能力的拆解除了能夠降低業務流程分析的複雜度之外，也提高了代碼複用和拓展的靈活性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;領域能力就像積木一樣，可以被組裝到不同的領域服務中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如人羣設置能力可以同時被單元新建服務、單元編輯服務、人羣快捷修改等領域服務複用。而能力拆解帶來的拓展靈活性性是相對於樸素模版設計模式而言的。在傳統架構中模板類可能是我們使用最多的設計模式，它的確能夠簡單有效地實現複用共性流程、分離差異的目標。但是由於複雜業務流程中不同業務節點的差異化維度往往是不同的，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;直接將業務主流程抽象成一個模板類，將各個節點作為模板中的抽象方法，那麼該模板類子類的繼承關係複雜度將是各個業務節點內部場景複雜度的叉乘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。再加上傳統架構並沒有積極引導開發者落實面向對象編程的思想，導致我們基本上還在以面向過程的方式開發我們的系統，通常會將同一個產品線中不同的業務方法實現到同一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Service&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Manager&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;類中，這將進一步加重模板抽象及子類繼承關係的複雜度。而 PICASO 框架通過領域能力拆解將不同的業務環節拆分到了單獨的原子業務實體中，將模板中的抽象方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算子化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;由於不同的原子業務模塊之間互相正交、互不幹擾，因此能夠讓這些業務算子獨立迭代，在各自的業務維度上靈活地進行繼承和拓展&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分類&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;只是把業務流程按照功能邊界拆分成不同的模塊通常是不夠的，因為單個模塊內部往往還存在細分的業務模式，如上圖中的出價設置模塊，其內部還存在手動、MC、tCPA、eCPC 等不同的出價模型，這個時候就需要根據分類思想進行進一步拆解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;分類思想&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;是關注點分離思想進一步的延伸，它在分離的同時還注重元素之間的共性特徵&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。當模塊內部出現場景分化時，PICASO 框架建議開發者對模塊進行進一步細分，將模塊內不同場景的業務規則封裝為不同的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力實例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這些能力實例之間儘管存在邏輯差異，但是畢竟屬於同一個原子業務模塊，在數據模型、接口協議乃至業務流程上都存在很大的相似度。因此 PICASO 會將同模塊下不同業務場景對應的領域能力實例聚合到一起，這樣的一組能力被稱為一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力節點&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。同一個能力節點下的各個能力實例使用相同的接口參數及上下文定義，每個能力節點下會額外定義一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力門面&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能力門面通常不承載具體的業務規則，它僅負責定義當前能力節點對外的接口協議以及從請求參數中提取業務場景標識的邏輯，它是能力節點下所有能力實例對外提供服務的統一入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。上層的領域服務組合領域能力時，引用的不是具體的領域能力實例，而是各個能力節點下的能力門面。PICASO 框架內置的可執行實體發現與路由機制會在應用啓動時掃描出系統中所有的能力門面，並建立好能力門面與各個能力實例的路由表。當請求到來時，領域服務不必關注本次請求應該使用哪個具體的能力實例，而是直接調用能力門面的統一入口，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;PICASO 框架會通過內置的可執行實體發現與路由機制提取請求中的場景標識，然後將請求路由到對應的領域能力實例上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，從而實現模塊內部的場景複雜度與領域服務模塊集成複雜度之間的解耦。以出價模塊為例，出價模塊內部會根據不同的出價類型細分為 tCPA、MC、eCPC 等智能出價能力實例，但是單元新建領域服務並不會直接操作這些具體的能力實例，它引用是出價設置能力門面。當請求到來時，PICASO 框架會根據請求中的出價類型自動將請求路由到相應的能力實例上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可執行實體發現與路由機制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是 PICASO 框架內置的一個底層通用組件，是能力編排、拓展點機制等頂層功能的基礎。其本質上就是一個增強型的門面+策略模式，我們通過一些實現技巧將其做成了一個可以適配任意可執行實體的通用組件。如下圖所示，單元新建業務流程涉及標的物設置、出價設置及人羣設置等業務環節，這些業務環節內部都有各自的細分場景。在代碼實現中，這些業務環節被抽象為 3 個能力節點，節點內部的細分場景被隔離到不同的能力實例中，在構建領域服務時就不需要考慮當前各個能力節點下的細分邏輯，只需要專注於業務流程本身，實現各個能力門面的組裝邏輯即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6fc68de875eec1a26e3e8417cabcd5dc.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;能力門面與能力實例的抽象實現了能力編排複雜度的降維&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分層&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;分層&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;則是分類思想在領域服務、拓展點等其他實體粒度上的延伸&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如快車、互動、推薦三條產品線的單元新建服務會被劃分到同一個服務分組下，對外暴露一個單元新建服務門面。這樣做目的是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;下層實體對上層實體暴露統一的門面接口，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自下而上&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;地逐層屏蔽下層實體的內部複雜度，實現維度間複雜度解耦，進而將代碼的整體複雜度由&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;降維到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;div&gt;
    &amp;nbsp; 
  &lt;/div&gt; 
  &lt;span&gt;&lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;。下圖展示了 PICASO 框架中各個業務實體的層級結構，最下層是各個領域能力實例執行器，它們承載了具體的業務規則；相同功能子域的領域能力實例會對上層的領域服務實例暴露一個統一的領域能力門面執行器，領域服務實例執行器會通過組合領域能力門面定義具體的業務流程；而相同的功能子域的領域服務實例又會對領域服務統一入口（Domain Service Faced）暴露一個領域服務門面執行器，屏蔽模塊內領域服務實例之間的細分規則；領域服務統一入口將不同的領域服務門面集成到一起，對上層不同的流量來源暴露統一的請求入口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;這種分層結構讓開發者逐層解構業務複雜度的同時，實際上也構造了一個索引結構，為實現可檢索的代碼架構打下基礎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//f13cba0ebb1ba5e6a7309d9ef247b2db.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;自下而上逐層屏蔽層級內部的業務場景複雜度&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在分層架構中，除了可以通過通用可執行實體路由機制自下而上地屏蔽下層實體的內部場景複雜度之外，有時我們還要反過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;來自上而下地進行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;複雜度合併&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我們用一個例子來説明這種設計技巧：在廣告投放業務中有一個經典的出價計算器模塊，它會根據廣告物料上的基礎出價、人羣溢價、關鍵詞出價、流量包溢價、時段溢價等信息預估廣告物料最終的出價值範圍。計算邏輯只有一個，但是由於計算邏輯關聯了眾多底層模塊，物料新建、修改以及關聯模塊的快捷修改、還有對物料進行修改過程中實時出價預估回顯（此時最新的修改並未落庫）等接口都會調用出價計算器模塊，但是這些使用場景對出價預估參數的填充程度是不同的，需要模塊針對不同的使用場景執行不同的參數補充查詢邏輯。這是一個典型的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;上層模塊的調用場景複雜度滲透到底層模塊實現複雜度中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的例子。在分層架構中，越是底層的模塊在設計上需要考慮的場景應該越少，而且要避免與上層模塊的使用場景耦合。因為上層模塊的使用場景是動態增加的，不知道什麼時候就會有新的使用場景出現，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;底層模塊的真正需要處理的內部場景應該比頂層使用該模塊的場景要少且穩定的多。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以解決這個問題的措施就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;底層模塊面向自己內部的業務模式在參數中定義一個隱式的標識屬性，讓調用方根據自己的使用場景和業務訴求隱式地設置該參數，底層模塊則直接根據參數中的這個標識屬性執行相應的分支邏輯&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。回到出價計算器的案例中，該模塊的使用場景有：單元新建後事件觸發、單元整體修改後事件觸發、單元新增關鍵詞後事件觸發、單元新建中臨時觸發、單元修改中臨時觸發、單元添加關鍵詞中臨時觸發等多種使用場景，未來也不確定會出現什麼新的使用場景。但是對出價計算器模塊的內部計算邏輯來説，其實只有需要補充查詢單元下關鍵詞信息和不補充查詢這兩種場景。為此我們在出價計算器能力參數中增加一個布爾類型的參數，能力內部直接根據該參數判斷是否需要執行關鍵詞的查詢操作，出價計算器模塊的調用方則分別根據自己的使用場景判斷該如何設置這個參數，從而起到自上而下的合併上層調用場景複雜度、保持底層模塊穩定的作用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;有些讀者或許會覺得這種機制與上文介紹的能力路由機制是互相矛盾的，然而他們實際上並不衝突。因為對那些能夠自下而上屏蔽內部場景複雜度的模塊而言，它們通常顯式地定義了內部不同業務模式的標識屬性，如出價模塊的出價類型、人羣定向模塊的人羣類型等，用戶在請求參數中也會顯式地設置請本次請求對應的業務標識，因此框架能夠直接對這些模塊應用通用可執行實體路由機制。但是實際業務中也存在一些模塊，它們內部沒有定義明確的業務模式標識，而是根據請求來源、調用場景等動態條件執行不同的業務邏輯。此時我們可以先暫時忘掉這些模塊的調用場景，而是聚焦模塊內部的業務分支提煉出隱藏其中的業務模式，然後讓上層模塊將動態調用場景轉化為底層模塊定義的隱式業務模式標識參數，接下來就能繼續應用通用可執行實體路由機制了。因此，分層思想中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;自下而上屏蔽的是模塊內部的固有場景複雜度，而自上而下合併的則是模塊外部的使用場景複雜度，二者其實是互補的關係。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_14&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展點機制協助走出多維度泥潭&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務與領域能力的路由機制能夠較好的應對系統多模塊集成帶來的複雜度，但是領域能力及領域服務必須嚴格遵守框架規約，繼承標準業務執行器模版（後續章節會有詳細講解），定義出明確的數據交換協議及上下文對象，這些都是相對較重的操作。因此能力或服務路由的維度必須抓住最核心的業務差異，而不是把所有存在業務差異的維度都納入到路由規則中，否則就會造成沙粒化拆分，反而增加系統的維護成本。因此我們還需要一種機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能夠以更加輕量的方式承載除了領域服務或能力路由維度之外其他業務維度上的細微差異&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;拓展點機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要解決的問題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;拓展點機制&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;是通用可執行實體發現與路由機制在更細粒度上的延伸應用，本質上就是將存在差異化邏輯的環節抽象為一個接口從主流程中分離出去，然後將不同場景的差異化邏輯隔離在不同的拓展點接口實現中，這其實就是依賴倒轉原則（Dependence Inversion Principle, DIP）的應用&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。與領域服務和領域能力相比，拓展點的定義和實現成本都要低很多，框架對拓展點接口內的方法及方法參數都不會做過多的約束，定義一個拓展點僅需要繼承框架提供的標準接口並指定路由標識的提取邏輯，而實現一個拓展點接口時也僅需要在實現拓展邏輯之外額外指定當前拓展點實例能適配哪些路由標識。拓展點可以嵌入到領域服務、領域能力以及資源庫（Repository，下文中會詳細闡述）中任何一處存在差異化邏輯的流程中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展點機製作為能力與服務拆分路由機制的補充，支持任意維度上的差異化邏輯隔離。以下圖為例，在廣告投放系統中，底層的人羣設置能力節點已經按照其核心屬性人羣類型進行了能力實例的劃分。由於系統還賦能了多個投放平台，不同的投放平台對可綁定的人羣上限有着不同的限制，此時就可以將各個能力實例中人羣綁定數量校驗環節抽象為一個拓展點接口，以投放平台類型作為路由 KEY 為各個投放平台提供不同的接口實現，從而自上而下地解決多維度拓展的難題。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;這裏説的「自上而下」是一種形象的描述，可以理解為父層級業務維度內不同的業務場景在子層級模塊上產生的差異化邏輯。但實際上拓展點機制並不限制邏輯的維度拓展方向，如下圖的例子中，右側觸點新建服務領域服務實例所屬的服務門面定義的服務路由維度是產品線，但是不同的計劃類型的單元新建流程之間依然存在細微的邏輯差異，此時儘管計劃類型是產品線的子維度，但是依然可以通過拓展點來承載這些細微的邏輯差異。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//701162304b0dcc5acf2dcd3734071b08.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;拓展點機制的核心作用是作為能力及服務路由維度的補充，進一步實現差異點的分離&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h4_15&quot;&gt;&lt;/span&gt; 
  &lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排框架確保架構思想切實落地&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前面幾個小節一直在論述如何對複雜邏輯進行拆解和分離，但是系統要想對外提供可用的功能，就必須再次把這些分離出來的能力及拓展點組合起來，構成一個完整的領域服務。最簡單的組合方式就是直接硬編碼依次調用各個能力門面的功能入口，手動實現前置方法調用結果與後置方法入參的屬性映射和轉換，但是這種組合方式會在業務主流程中插入大量的膠水代碼，稀釋代碼的信息密度，將流程關鍵節點掩蓋在大量繁瑣無趣的`setter`、`gettter`方法調用中。為瞭解決這個問題，同時確保新架構設計思想能夠精準落地，讓規範和標準框架化，PICASO 自建了能力編排框架，它為前文所述的各類思想落地提供了框架基礎，將前文提到的各種實體、組件與設計思想有機結合到一起，自動實現模塊串聯，讓開發者專注於業務邏輯本身，實現填空式開發，最終構建出一個完整的工程應用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前業界有很多流程編排引擎，有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;老牌廠商的 Netflix Conductor、AWS Step Function 等，也有開源的 Apache Activiti、Zeebe&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;等。我們在早期架構探索階段對這些解決方案也進行了調研和試用，但是發現它們都無法滿足我們的訴求：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以輕量級的方式實現模塊組合，提高模塊與組件的複用性，同時凸出呈現核心業務流程，輔助開發者快速抓住業務主線並建立對業務的全景認知&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這很大程度上是由於上述開源組件的定位大都是接口級別的服務編排或者是審批流之類的流程引擎，因此其實現方案或執行成本往往較重，很多流程編排框架過分強調通過 UI 框架拖拽式實構建業務流程，導致開發者需要先在代碼工程中實現業務組件，再到 UI 界面中構建串聯流程，適用的場景有限且造成強烈的割裂感不説，開發者依然需要手動配置組件之間的參數映射與數據傳遞邏輯，而脫離了開發工具的代碼提示與補全功能，這些邏輯的實現成本反而增大了。與這些問題相比，拖拽式的 UI 界面雖然炫酷，但並不是我們的核心訴求。還有一些編排框架採用了中心化的部署方式，流程串聯與組件服務分離部部署，通過 RPC 實現組件調用，這種方式會付出巨大的網絡開銷及中間結果存儲成本。這種設計讓它們在批處理任務場景中有較好的應用，但是在交互式服務應用場景中則會造成嚴重的性能問題並付出巨大的運行成本。因此，在經過一次次嘗試之後我們最終決定舉起自研大旗，開發一套與 PICASO 架構基本思想相適配的能力編排框架。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//14e6e125dc26e81dd70da55f5962aa61.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;要想滿足我們在上文中提出的能力編排相關的訴求，能力編排框架需要提供兩個基本功能：分別是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在編碼階段通過簡潔、直觀、易用的 API 輔助開發者定義業務流程，以及在請求處理階段根據開發者制定的執行圖串聯各個業務組件完成請求處理流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。為了實現這兩個基本功能，PICASO 框架採取了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;制定標準化業務執行模版&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;內嵌標準上下文機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;自建能力編排框架三項舉措&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;標準業務執行器模版&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;標準業務執行器模版&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;立足於軟件系統的內在本質定義了適用任何業務場景的基本處理流程&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，就像&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;對象在 JDK 中的作用一樣，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;標準業務執行器模版並不複雜，但它卻是 PICASO 框架中所有組件功能得以實現的基礎&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。從本質上看，所有的軟件系統都在做三件事：數據的獲取、處理與存儲（或傳輸）；從業務視角看，數據的處理又可細分為輸入數據的合法性校驗以及數據的計算與轉換，而數據的合法性校驗又可細分為對輸入數據直接進行的校驗以及需要結合系統內外部詳情數據進行的校驗。基於上述論述，PICASO 框架定義的業務處理的基本流程為：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;1.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;參數預校驗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：直接對請求入參進行的校驗，這些校驗邏輯通常都是簡單的內存計算，不依賴任何外部數據，如參數完整性校驗、參數值範圍校驗、數據長度校驗等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;2.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上下文初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基於校驗後的入參查詢數據詳情並填充到上下文中，如根據入參中的單元 ID 查詢單元詳情、根據 userId 獲取賬戶詳情等，這些數據將會在後續流程中使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;3.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基於上下文的業務校驗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：執行需要結合上下文中詳情數據才能進行的業務校驗，如根據單元狀態判斷是否可以執行物料的修改操作、判斷標的物類型與物料計劃類型是否匹配等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;4.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;業務邏輯處理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基於參數及上下文中的詳情數據執行領域模型（下一章節介紹）的構造和修改，注意對於一些查詢類的服務，這個步驟可能不是必須的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;5.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;數據持久化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：將新建或修改後的領域模型保存到數據庫中或者調用外部服務 API 完成數據傳遞，這同樣是一個可選的標準步驟，另外有些服務在業務邏輯處理環節就已經完成了數據傳遞。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;6.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;發佈領域事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：一些修改類的領域服務在完成請求處理之後可能需要通知其他領域內的業務實體做一些相關的後置操作，PICASO 框架是通過領域事件機制來實現這個功能的（後續章節中進行詳細介紹）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;7.&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;構造處理結果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：業務流程執行完成後構建返回給調用方的響應數據。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;標準業務執行器模版本質上就是一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Executor&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;模板類，上述基本業務流程也就是該模板類中主要的模板方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在 PICASO 框架中，領域服務和領域能力都要繼承標準業務執行器模板類&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這樣做的目的是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;引導和約束開發者對領域服務和領域能力的具體實現邏輯按照標準業務執行流程進行二次拆分，從而可以讓框架對代碼進行精細化地調用控制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。標準業務執行模版是對所有業務處理流程進行的最頂層抽象，模版類中各個標準業務執行步驟 API 的制定讓把不同業務模塊的串聯執行職責從開發者手中轉義到框架手中成為可能，開發者不必手動實現不同模塊和方法的串聯調用，而是專注於業務邏輯，實現填空式開發，從而減少系統中的膠水代碼，提高信息密度，這本質上就是依賴倒轉原則（Dependency Inversion Principle, DI）的應用。下面的代碼片段給出了標準業務執行器模版的定義，出於突出呈現 PICASO 框架設計思想的目的，示例代碼去除了框架功能的具體實現邏輯，僅保留了核心要素及模版方法的定義。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/**
 * 標準業務執行器模板基類，定義了基本的業務處理流程，所有領域服務和領域能力執行器都必須繼承該類。 
 *
 * @param &amp;lt;C&amp;gt;   業務執行器對應的參數類型，所有的執行器參數都應該繼承自標準參數基類 Command 對象
 * @param &amp;lt;T&amp;gt;   業務執行器最終返回的執行結果類型
 * @param &amp;lt;CTX&amp;gt; 業務執行器使用的上下文對象類型，所有執行器的上下文對象都應該繼承標準上下文基類，
 *              請求的入參和產生的中間結果都會保存在上下文對象中
 */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CommandExecutor&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;C extends Command, T, CTX extends ExecutorContext&amp;lt;C, T&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 參數預校驗，該步驟應該只進行純內存計算操作
     * @param context 上下文，此時的上下文中只有參數對象
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPreValidate&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 執行上下文初始化，根據參數執底層情數據的拓展查詢，並將查詢結果填充到 context 對象中
     * @param context 上下文，調用該方法時的上下文中只有參數對象，調用完成後上下文將被填充
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doInitContext&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 結合上下文中的底層數據執行業務校驗
     * @param context 上下文，此時的上下文中已經完成了依賴的業務詳情數據的填充
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doContextualValidate&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 結合上下文中的底層數據執行業務邏輯的處理，對已有實體的變更及生成的新業務實體都會填充回上下文對象中
     * @param context 上下文，業務邏輯執行過程中的中間結果也可以暫存到到該上下文中
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doProcessBizLogic&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 保存業務流程執行過程中新建或者被修改過的業務實體，調用該方法時，這些數據已經被寫入到了上下文對象中
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPersistAggregates&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 構造本次業務請求流程中需要對外發布的領域事件
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;Collection&amp;lt;RetryableEvent&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doPublishAppEvent&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;/**
     * 構造請求的返回值
     * @param context 上下文
     */&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;doAssembleResponse&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;CTX&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; context&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到這裏有些讀者可能還沒有意識到「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;把不同業務模塊的串聯調用職責從開發者手中轉移到框架手中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」的價值，這項措施其實並沒有直接解決我們在本文第二章提出任何一個痛點問題，要想理解這一措施我們必須用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;辯證法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;重新審視前文介紹的各項複雜度應對措施。根據前面幾個小節的論述，我們為了應對業務複雜度而對請求處理流程進行了各種粒度和場景的拆分，拆分出來的各類實體再疊加上實體內部標準執行步驟的二次拆解，必然會增加後續邏輯串聯和組裝的複雜度。如果此時還要求開發者手動硬編碼實現邏輯組裝，那麼勢必會帶來極高的開發負擔和出錯概率，而且硬編碼組裝帶來的大量膠水代碼還會稀釋和掩蓋代碼中的關鍵信息，後續再進行迭代時就容易產生改動點遺漏和影響評估不全等問題。PICASO 框架解決這些問題的措施就是由框架代替開發者實現合個模塊的串聯組裝，這也我們要定義標準業務執行器模版的根本原因：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;統一標準的調用入口是讓框架實現流程串聯的前提，進而才可能實現將膠水代碼隱藏在框架內部、提高業務層代碼信息密度、降低開發者編碼負擔的設計目標&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。PICASO 框架內模塊串聯的詳細邏輯我們將在本章後三個小節中進行闡述，在那之前我們先繼續介紹標準業務模版中的其他核心要素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上下文機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;從標準業務執行模版的示例代碼中我們可以看到，除了各個標準步驟的方法聲明之外，標準業務執行模版還通過泛型變量定義了執行器接收的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;請求參數類型、返回值類型以及上下文對象類型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，其中「上下文」是標準業務執行器模版中的核心要素，業務數據就是通過它在各個標準步驟之間流轉的。所謂的上下文本質上就是一個 POJO（Plain Old Java Object），其內部定義了業務流程執行所需要的各種詳情數據。在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fxingyun.jd.com%2Fshendeng%2Farticle%2Fdetail%2F25548%3FforumId%3D43%26jdme_router%3Djdme%253A%252F%252Fweb%252F202206081297%253Furl%253Dhttp%253A%252F%252Fsd.jd.com%252Farticle%252F25548&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;改進我們的架構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中我們已經對上下文機制進行了詳細的闡述，在這裏我們簡單回顧一下它的作用。如下圖所示，在傳統架構中開發者往往直接面向數據庫編程，業務邏輯與數據庫操作互相交織，容易造成重複或碎片化的數據庫讀寫操作。而採用上下文機制之後，業務流程中的各個子模塊都不再封裝數據的讀寫操作，而是在請求一開始先將後續流程所需要的數據集中初始化到上下文對象中，後續各個業務模塊統一從上下文中獲取所需的詳情數據，並把產生的中間結果寫入到上下文對象中，最後在所有子模塊業務邏輯執行完成之後，集中將上下文中新增或發生變化的業務實體持久化到存儲介質中。這種設計&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;一方面能夠避免子模塊劃分導致的重複及碎片化的數據讀寫操作，另一方面，集中的數據操作可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;啓發&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;開發者採用批量、異步和並行等措施進行極致地性能優化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//246d9ed0041739f4881c0a5099b7db03.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;上下文機制與傳統架構業務處理流程對比&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 框架對上下文機製做了進一步升級和深度集成，上下文作為核心要素被直接定義到標準業務執行器模版中，領域服務和領域能力執行器都要通過泛型參數來聲明自己所需的上下文對象類型。需要説明的是，儘管領域能力執行器中也定義了「上下文初始化」標準步驟，但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架依然建議開發者儘量在領域服務執行器的上下文初始化步驟中就將各個領域能力所依賴的業務實體或外部數據集中批量查詢好，然後填充到領域服務上下文中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。後續各個領域能力會優先從領域服務上下文中獲取所需的詳情數據，領域能力的上下文初始化步驟僅做依賴數據的非空校驗或者做為從領域服務上下文中獲取不到所需數據時的託底補充查詢措施，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;這是由於領域服務作為整個業務流程的全局把控者，擁有最全的數據視角，可以對代價昂貴的 IO 操作進行極致地調優，而領域能力則聚焦於業務流程的局部細節，在能力內部封裝的數據讀寫操作很容易隨着能力的組合或循環複用而被碎片化或重複地執行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;需要注意的是上文中「領域能力優先使用領域服務上下文中的數據」並不意味着領域能力會直接訪問外層領域服務的上下文對象，這是由於同一個領域能力可能會被不同的領域服務所複用，因此領域能力不可能與其中任何一個領域服務的上下文耦合到一起。為瞭解決這個問題，PICASO 框架要求每個領域能力都要定義自己專有的上下文對象。在調用領域能力之前先將領域服務上下文中的數據傳遞到領域能力的上下文中，領域能力中的業務邏輯直接訪問的依然是領域能力自己的上下文對象，在能力執行過程中構建的新實體或者對已有實體的修改也會直接保存到領域能力上下文中。而在完成能力調用之後，PICASO 會將領域能力上下文中新生成或者發生變更的屬性傳遞迴領域服務上下文中，從而在保持領域能力與領域服務解耦的前提下實現領域服務與領域能力上下文數據的共享。因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在 PICASO 框架中上下文機制除了起到避免碎片化及重複讀寫數據的作用之外，還負責在不同領域能力以及領域服務與領域能力之間進行數據的傳遞和共享。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我們可以用一個例子來詳細描述上述機制，如下圖所示，領域服務內編排了三個領域能力：A、B、C，其中能力 A 和 C 分別依賴業務實體 1 和實體 4，能力 B 依賴能力 A 生成的數據實體 2，完成業務邏輯處理後框架需要把能力 B 和 C 構建的業務實體 3 和 5 以及能力 C 對實體 4 的修改保存到數據庫中。當請求到來時 PICASO 框架會首先調用領域服務的上下文初始化標準步驟（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;initContext&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）完成實體 1 與實體 4 的查詢，在調用能力 A 之前會將實體 1 從領域服務上下文拷貝到能力 A 上下文中，完成能力 A 的調用後會將其構建的實體 2 從能力 A 的上下文中拷貝回領域服務上下文，然後將領域服務的上下文作為兩個能力之間數據共享和交換的通道，在調用能力 B 之前將實體 2 拷貝到能力 B 的上下文中......以此類推用相同的方式完成能力 B 和能力 C 的調用，最後 PICASO 框架會調用領域服務的聚合根持久化標準步驟（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;persistAggregate&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;），集中將新生成的實體 3 和 5 以及由能力 C 修改後的實體 4 持久化到數據庫中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//de54d7e00f38a8de83b31dbd2d9221d2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;領域服務與領域能力上下文之間的數據傳遞關係&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上下文機製作為 PICASO 框架的基礎組件，其內部除了用戶自定義的業務屬性之外還承載着大量框架內部運行所需的狀態數據以及大量為開發者提供的工具 API。在本文中我們僅對其基本運行機制進行了介紹，關於上下文的使用技巧及其基類中各種工具 API 的使用方法，我們將在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳實踐——上下文機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》一文中進行詳細的闡述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;標準業務模版執行引擎&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在上一小節的最後我們通過一個架空的例子論述了 PICASO 框架內部的數據傳遞流程，這些數據傳遞規則並不需要開發者手動實現，而是通過 PICASO 框架內置的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;標準業務模版執行引擎&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;自動觸發的。接下來我們就將詳細闡述標準業務模版執行引擎是如何將領域服務及領域能力各個標準步驟串聯到一起的。但是在此之前，我們有必要必再次明確領域服務和領域能力執行器的職責，這對理解標準業務模版執行引擎的設計動機十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在 PICASO 框架中，系統對外提供的服務都是由領域服務執行器承載的，作為整個業務流程的全局把控者，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;領域服務執行器的基本職責就是定義業務流程（編排組裝領域能力）以及管理業務數據（上下文的初始化及持久化），而領域能力執行器則聚焦在完整業務流程中的某個特定模塊，負責實現該模塊內部具體的業務規則&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。如前文所述，領域服務是通過領域能力組合編排而成的，並且它們都繼承了標準業務執行器模版，因此不難推導出領域服步驟其實就是通過各個領域能力的相應標準步驟組合而成的。但是這並不意味着業務流程中所有的業務邏輯都會下沉到領域能力中，比如領域服務上下文初始化操作就必須在領域服務執行器中直接定義。此外，考慮到領域能力聚焦於局部業務細節，無法獨立對外提供服務，為了明確組件職責，避免給開發者帶來困惑，領域能力執行器對標準業務執行器模版進行了二次拓展，隱藏了完整請求流程處理維度才需要的聚合根持久化（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;persisteAggregates&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、構建併發布領域事件（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;publishAppEvent&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）以及組裝請求響應數據（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;assembleResponse&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）標準步驟，因此這三個模版方法對應的業務邏輯也需要直接在領域服務執行器中定義。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務及領域能力執行器的職責劃分決定了二者之間的數據傳遞時機及其標準步驟之間的組合關係，標準業務模版執行引擎的模塊串聯規則就是基於此制定的。其核心設計就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;對業務流程中各個領域能力標準步驟的重組執行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。在 PICASO 框架的早期摸索階段，我們曾傾向於將同一個業務模塊的參數校驗與業務處理邏輯劃分到兩個不同的領域能力中。這種能力劃分方式固然也能實現業務功能，甚至也能起到複雜度分離的作用，但是這種劃分方式會造成業務邏輯的沙粒化分解，產生大量瑣碎的小能力，這反而會增加系統的開發及維護成本。另外，由於同一個模塊的參數校驗及業務處理邏輯往往會依賴相同的底層數據，沙礫化的能力劃分會急劇增加能力間數據傳遞和共享的負擔，稍有不慎就會造成數據的碎片化讀寫，進而對系統性能產生影響。因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;我們最終選擇迴歸業務本質，以最小原子業務邊界作為能力劃分的準則，將同一模塊內關聯緊密的參數校驗、上下文初始化、上下文校驗及業務處理邏輯封裝到同一個領域能力執行器中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是這種封裝規則卻帶來了新的問題：領域服務由領域能力組合而成，如果我們直接依次串行調用每個領域能力內的各個標準步驟，將無法實現領域能力與領域服務標準步驟之間的協調執行，另外由於調用後置能力時前置能力所有標準步驟都已執行完畢，如果後置能力的參數校驗失敗而前置能力在業務邏輯處理步驟已經與外部系統產生了數據交互，此時就會產生髒數據等問題。然而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;標準業務執行模版的抽象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;則為我們帶來了該問題的解決方案：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;將領域能力執行器中的各個標準步驟拆散到領域服務執行器相應的標準步驟中重組執行，而不是依次觸發每個領域能力的全部標準步驟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如下圖所示，在領域服務的參數預校驗標準步驟中會按照能力執行圖依次觸發各個領域能力的參數預校驗步驟，而在領域服務的上下文初始化步驟中則會依次觸發各個領域能力執行器中的上下文初始化步驟。這種重組執行機制確保了服務請求流程能夠整體按照參數預校驗、上下文初始化、上下文校驗、業務邏輯處理、聚合根持久化、發佈領域事件、構造返回值的標準流程執行下去，實現&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;fail-fast&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;特性，避免由於後置操作校驗失敗而前置操作已執行導致的 IO 資源浪費及髒數據問題，另外這種運行機制帶來的額外收益是讓我們能夠利用現有服務快速實現請求預校驗接口，這一點我們在本文第四章的 PICASO 框架開發流程示例中將有專門的呈現。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上述過程也是辯證法的生動詮釋，事物之間存在普遍聯繫，在對立統一中不斷發展。PICASO 框架中也是在一次次提出方案、引發新問題、解決新問題的過程逐漸成型的，框架中各個組件互相支撐，互為因果，共同實現整潔架構的最終目標。我們也希望各位讀者在閲讀本文時能夠始終將本文介紹的各項組件聯繫到一起來理解框架的指導思想和設計動機，這對未來我們能否在實際業務用好 PICASO 框架來説十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//9b99cf23fdfa6085f3b31e200044c394.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;標準業務模版執行引擎的重組執行流程&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面我們將結合着上圖所示的能力標準步驟重組執行流程圖逐步解析標準業務流程模版執行引擎的運行機制：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 參數預校驗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;當請求到來時，PICASO 框架會首先通過領域服務門面定位到具體的領域服務執行器實例，然後調用其參數預校驗標準步驟（preValidate），在該方法中會首先執行領域服務執行器直接定義的參數預校驗邏輯（當然也可以根據開發者的設計意圖調整為先觸發各個領域能力的參數預校驗邏輯），然後再觸發領域能力執行圖中各個領域能力的參數預校驗邏輯，需要注意的是由於領域能力執行器有自己專屬的參數及上下文對象，因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在調用各個能力參數預校驗方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之前&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，PICASO 會自動將領域服務入參對象中的屬性拷貝到領域能力入參對象中同名同類型的屬性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（與 Spring 框架中 BeanUtils.copyProperties 的邏輯相同）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 上下文初始化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;完成參數預校驗邏輯之後，PICASO 會開始執行領域服務的上下文初始化邏輯。我們鼓勵開發者將各個領域能力所依賴的底層數據集中到領域服務的上下文初始化邏輯中批量查詢好，因為領域服務作為整個業務流程的全局把控者，擁有最全面的數據視角，可以進行最徹底的性能優化。完成領域服務直接定義的上下文初始化邏輯之後，PICASO 將調用能力執行圖中各個領域能力的上下文初始化步驟，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;但是在此之前&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，與領域服務與領域能力之間的參數傳遞邏輯類似，PICASO 框架會先將領域服務上下文對象中的屬性拷貝到領域能力上下文對象中同名同類型的屬性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有些讀者可能會對本小節的論述有些疑惑，封裝領域能力的目的之一是為了邏輯複用，然而我們卻要將其依賴數據的初始化邏輯代理到領域服務中，那麼當一個領域能力被不同的領域服務引用時，是否會造成重複編碼呢？這個問題的答案是肯定的，但是絕大多數場景下領域能力依賴的底層實體通常不多，一方面我們可以通過接下來將要介紹的「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合與資源庫&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;」機制簡化這些底層實體的查詢邏輯，與由此收穫的性能提升收益相比，重複編碼所付出的輕微代價是完全值得的。另一方面我們其實並不建議在領域能力內部實現依賴數據的初始化查詢操作，因為能夠被編排到同一個領域服務中的領域能力通常都會依賴相同的業務實體，如果要在每一個領域能力內都實現一遍實體查詢邏輯同樣會造成重複編碼。因此我們建議還是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;統一由領域服務完成上下文的初始化，然後通過上下文傳遞機制拷貝到領域能力上下文中，領域能力僅在上下文校驗標準步驟中做好上下文參數的非空校驗，確保領域服務傳遞過來了正確的數據&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。更多關於領域服務及能力上下文數據傳遞方案設計的技巧請參考《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳實踐——上下文機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 上下文校驗&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;完成領域服務及各個領域能力的上下文初始化邏輯之後，PICASO 會繼續執行領域服務及各個領域能力的上下文校驗邏輯。該標準步驟內執行的是需要結合上下文中的底層數據才能進行的校驗邏輯，如調整預算時要求新預算與歷史預算差值必須大於 5% 且必須大於當前消耗，該邏輯依賴歷史預算及物料當前消耗詳情，就可以在上下文初始化步驟完成這兩部分底層數據的查詢，然後在上下文校驗步驟中直接從上下文中取出詳情數據執行相關的校驗規則。默認情況下領域服務與領域能力在上下文校驗步驟不需要執行任何的參數或上下文傳遞操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. 業務邏輯處理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;基於上下文的業務校驗通過之後，PICASO 框架會繼續觸發領域服務及能力執行圖中各個領域能力的業務處理邏輯。需要注意的是由於領域能力的業務邏輯處理過程中可能會對上下文中已有的實體進行了修改，也可能會構建出新的業務實體對象，這些變更最終都需要被持久化到存儲介質或者外部系統中。因此在默認情況下，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 會在能每一個領域能力的業務邏輯處理標準步驟執行完成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;之後&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;執行一次領域能力上下文到領域服務上下文的數據回傳操作，將領域能力上下文中的屬性拷貝到領域服務上下文中同名同類型的屬性上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這些數據將在領域服務的後續步驟中被持久化到存儲介質中，或者被用於構造領域事件及請求響應結果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 聚合根持久化、發佈領域事件、構造響應結果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由於標準業務執行器中的剩餘的幾個標準步驟承載的都是請求維度的邏輯，領域能力執行器標準模版中對這幾個方法也做了屏蔽，因此在這幾個標準步驟的執行流程中就不需要再調用領域能力執行圖了。需要特別説明的是，當執行到聚合根持久化標準步驟時，定義在領域服務及領域能力中的業務規則對實體的變更以及構建出的新業務實體都已經寫入到了上下文中，開發者可以充分利用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;領域服務對數據操作全局把控&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的職責定位，積極採用批量、異步、並行等手段進行極致地性能優化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 定製化執行流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;前五步內容介紹了領域服務及領域能力標準執行模版默認的串聯執行邏輯，PICASO 框架也遵循&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;約定大於配置（convention over configuration）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基本原&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#232930&quot;&gt;則，如果默認的執行邏輯能夠滿足開發者的訴求，開發者不需要實現過多的流程控制，但是要更&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;靈活地適配各類業務場景，PICASO 框架也支持開發者對上述標準串聯執行邏輯進行定製化的修改：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;span&gt;•&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 允許開發者指定僅執行領域服務的部分標準步驟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如前台業務方期望能夠在實際調用系統的單元創建接口之前先對其構造出來的請求參數進行校驗提前發現問題，因此希望系統為其提供一個預校驗接口（注意這裏的「預校驗」不是標準執行模版中的參數預校驗步驟），該場景就可以直接複用物單元新建領域服務執行器，並且在觸發領域服務執行器時指定間僅執行該領域服務的參數預校驗、上下文初始化及上下文校驗邏輯，領域服務完成前三個標準步驟的執行之後就會立即返回前三步的執行結果，從而快速實現業務方訴求，這其實也是標準業務執行模版抽象帶來的額外收益。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;div&gt; 
   &lt;span&gt;•&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其次，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架支持開發者對領域能力執行圖內的參數及上下文傳遞的時機與具體映射邏輯、能力調用的失敗與異常處理以及各個領域能力的觸發時機等行為進行定製化的修改&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，如出價設置能力與預算設置能力都依賴物料當前的消耗數據，除了在領域服務的上下文初始化步驟完成查詢的常規設計之外，也可以讓出價設置能力完成消耗數據查詢，然後以領域服務上下文作為媒介，將物料消耗數據從出價設置能力傳遞到預算設置能力中。這個時候就可以指定 PICASO 框架在完成出價設置能力的上下文初始化步驟調用之後立即執行一次從能力到領域服務上下文的數據回傳操作，而不必等到默認的業務邏輯處理步驟完成之後。而這些定製化的串聯執行配置都可以通過接下來將要介紹的能力編排領域特定語言來實現。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/div&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排執行圖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在前一小節中我們介紹了 PICASO 框架內部各個原子模塊與標準步驟的串聯執行流程，PICASO 框架通過內置的標準業務模版執行引擎將各個模塊的串聯執行職責從開發者手中轉移到了框架內部，從而讓開發者專注於業務規則設計，實現填空式開發。這裏説的「業務規則」一方面是指領域服務與領域能力各個標準步驟內具體的業務邏輯，另一方面是要明確當前業務流程需要按照什麼樣的順序執行哪些領域能力、能力執行的前置條件、對默認串聯規則的定製化配置（包括參數傳遞規則、上下文傳遞規則、錯誤及異常處理邏輯等），這些信息將以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力執行圖&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的形式提供給 PICASO 框架，之後框架就可以按照開發者的意圖完成對各個領域能力的串聯調用，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;能力編排&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;指的就是構建領域能力執行圖的過程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 能力編排框架的核心職責有兩個，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;首先是在編碼階段讓開發者能夠以易用、簡潔、直白的方式快速定義出業務流程對應的領域能力執行圖，其次是在請求處理階段將能力執行圖解析為可以被標準模版執行引擎理解的執行計劃，讓其能夠根據開發者意圖完成業務邏輯的處理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。我們可以通過下圖所示的框架內部實體關係圖對上述兩項職責進行詳細闡述，圖中藍色線條標記的是領域能力執行圖的構建過程，紅色線條標記的是請求到來時領域能力執行圖的執行流程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//df47910cd08020dd4cd4f42e6e3f5069.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;PICASO 能力編排框架內部實體關係圖&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;上圖其實不算是標準的實體關係圖，它更像是實體關係圖與流程圖的結合，其中不同顏色的線表示不同執行流程。事實上我們認為這種呈現方式更加符合現實，實體之間的關係本就是複雜的，在不同的場景和流程下實體之間的關係和相互作用往往也是不同的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;從圖中我們可以看到，每一個領域服務執行器內部都集成了一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力編排器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，在編碼階段，開發者可以通過它提供的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域特定語言（Domain Specific Language, DSL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以直白的方式構建領域能力執行圖。能力執行圖由多個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力編排節點&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;構成，每一個領域能力編排節點內部都封裝着一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力門面執行器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。當請求到來時，業務模版執行引擎會首先對能力編排執行圖進行解析，根據本次請求的參數及上下文信息將執行圖中各個能力編排節點解析為零到多個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力執行要素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，所謂的領域能力執行要素就是一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;[領域能力執行器、參數對象、上下文對象]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;三元組，它是一個有狀態的、會話級生命週期的實體，除了核心的能力執行三要素之外，其內部還維護着在請求處理過程中執行引擎產生的一些控制中間狀態，如當前已執行到哪個標準步驟、調用過程中是否發生了異常、本次調用是否已經提前終止等。執行圖中解析出來的所有領域能力執行要素將被構造成一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域能力執行要素鏈調用器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，它用來控制各個領域能力執行要素的觸發行為，包括能力執行器各個標準步驟的逐步調用、能力編排節點的延遲解析、不同執行要素之間的並行調用、能力執行要器的提前終止等。在領域能力執行要素鏈調用器的控制之下，能力執行圖中的各個能力門面執行器被依次觸發，通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;標準可執行實體發現與路由機制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;定位到當前請求應該使用的能力實例，調用其各個標準步驟完成業務邏輯處理。由於本文旨在介紹 PICASO 框架中各項組件的基本原理和運行機制，並沒有對能力編排框架的實現細節做過多探討，有關能力編排框架各項特性的詳細介紹請參考《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳實踐——能力編排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排領域特定語言&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在 PICASO 框架設計之初，我們也曾想直接引入一些開源的流程編排框架來實現領域能力之間的串聯調用。但是正如本章節最開始論述的那樣，現有的開源解決方案並沒有滿足我們的核心關切：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以直白、簡潔、輕量、易用的方式實現能力組裝，解決為了應對業務本質複雜度而採取的各項實體拆分與路由機制帶來的編碼繁瑣、模塊組裝邏輯複雜等副作用，減少膠水代碼和開發者的編碼負擔，提高關鍵業務信息密度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。圖形化、配置化的流程編排框架雖然能夠直觀的呈現業務處理流程，但是也造成靈活度差、普適性低、開發流程割裂、業務知識分散、模塊串聯配置繁瑣等問題，無法達成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;整體熵減&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的設計目標，而 PICASO 框架解決這些問題的方案則是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;自定義能力編排領域特定語言。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域特定語言（Domain Specific Language, DSL）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#202122&quot;&gt;專門針對特定應用領域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的計算機語言，與 C++、Java 等通用計算機語言（General Purpose Language，GPL）相比，領域特定語言的功能及普適性十分有限，但是在特定領域之內它卻具有強大的表達能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;領域特定語言的核心吸引力在於它提供了一種更清晰地傳達系統各部分意圖的方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，提高代碼的可讀性（雖然我們總是有意或者無意地低估了代碼可讀性對生產力的影響），降低開發者與領域專家（產品、測試甚至是用戶）的溝通難度。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;它能夠讓使用者輕鬆實現&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聲明式編程（Declarative Program）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;，對業務層開發者來説，這意味着他們可以直接告訴框架他們想做什麼，而不必編寫要想達成目的而需要執行的具體操作步驟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（Martin Fowler, Domain Specific Language, 2013），也正是這一點讓 PICASO 框架能夠將前文所述的各項業務複雜度應對措施帶來的系統偶然複雜度屏蔽在框架內部，將 PICASO 框架內部的各個功能模塊有機結合到一起，共同實現整體熵減的設計目標。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;軟件工程領域的大師 Martin Fowler 將領域特定語言分為外部 DSL（External DSL）和內部 DSL（Internal DSL）兩大類。外部 DSL 往往擁有自定義語法、需要宿主應用的代碼執行文本解析，基於該類 DSL 編寫的業務規則通常以腳本或配置的形式存在於系統代碼之外，典型的案例是正則表達式。而內部 DSL 是通用編程語言的子集，它對外提供一組特定的 API，利用內部 DSL 編寫的業務規則往往是一段合法的代碼，典型的例子就是 JDK8 之後提供的 Java Stream API。與外部 DSL 相比，內部 DSL 不需要專門的語法解析器和開發平台，可以直接與宿主應用代碼無縫銜接，也能直接複用普通 IDE 的代碼提示與自動補全功能，也正因為此，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;為了向業務開發者提供集中、連貫的開發體驗，我們最終選擇為 PICASO 能力編排框架開發一套內部領域特定語言&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;為了儘可能靈活地適配所有的業務流程構建場景，我們在 PICASO 框架的能力編排 DSL 中定義了順序、條件和循環三套能力編排邏輯，分別對應順序執行、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;if...else&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;判斷、循環三種流程控制方式。其中每一類能力編排節點的配置都遵循約定大於配置的原則，按照標準業務模版執行引擎的默認執行邏輯提供了全部缺省配置，同時開發者也可以通過能力編排 API 定製自定義的執行邏輯，如循環規則、分支判斷條件、觸發能力時的參數及上下文傳遞邏輯、失敗及異常處理邏輯、能力節點解析步驟等。由於本文旨在介紹 PICASO 框架的設計思想和各模塊的底層運行機制，因此我們不會對能力編排框架所有 DSL API 進行詳細論述，這部分內容將在《&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;PICASO 框架最佳實踐——能力編排&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;》一文進行詳細論述。本文僅通過一個實際的能力執行圖構建案例讓大家對能力編排 DSL 有一個具象的感知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下圖給出的是一個站外字節廣告計劃創建請求處理流程對應的領域能力執行圖構建邏輯，可以看出&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力編排 DSL 僅用數十行代碼以一種近乎白話文形式描述出了完整的計劃構建過程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：首先對用戶已創建計劃數量進行上限檢查（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignUpperLimitCheckAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；上限校驗通過後會構造出一個空的計劃對象併為其填充用戶 ID、計劃類型等基礎信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignBaseInfoAssembleAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；然後判斷本次計劃創建請求是否在參數中設置了聯合活動 ID，如果聯合活動 ID 不為空則需要執行聯合活動信息設置相關的業務邏輯（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignJointActivityAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）；完成聯合活動信息設置之後就要依次設置計劃的投放週期（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignScheduleConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、計劃名稱（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CampaignNameConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、營銷目標（CampaignMarketTypeConfigAbility）、應用集（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;TrafficStrategyConfigAbiliy&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）等模塊的相關屬性，需要注意的是在上述幾個能力的編排邏輯中，由於領域能力的參數或上下文對象中的屬性名稱與領域服務的參數及上下文中相應屬性並不匹配，默認的參數及上下文數據傳遞機制將無法為這幾個屬性設值，因此開發者對營銷目標設置能力的參數傳遞（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;cmdTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、上下文傳遞（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ctxTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、應用集設置能力的上下文傳遞（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ctxTransfer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）邏輯進行了自定義拓展，手動實現了參數及上下文中特殊屬性的數據映射邏輯；在完成這些業務模塊的屬性設置之後，如果請求參數中設置的標的物類型為「商品庫」，那麼接下來就要執行與站外 DPA 廣告業務相關的特殊業務環節：推廣 SKU 的校驗（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;SkuValidateAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）以及 SKU 跟單信息的配置（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;TraceOrderSkuConfigAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）邏輯......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//6bdf37fcc66e00c800d58232f8b207c7.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;順序及條件能力編排 DSL 示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上圖計劃新建流程的能力編排邏輯中只用到了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;順序和條件編&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;排這兩種最常用的編排模式，但是在一些批量操作請求處理流程中通常還會用到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;循環編排模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，它允許標準業務模版執行引擎重複調用同一個能力門面實現批量請求的處理。下圖通過批量創意綁定接口給出了循環能力編排模式的使用示例，在該流程的最後一個環節通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;registerFlatMapped&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排 API 註冊了一個創意綁定能力（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CreativeBindAbility&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）。該能力被設計為處理單個創意的綁定操作，而批量創意綁定領域服務卻需要在一次請求中完成多個創意的綁定操作，因此我們通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;cmdFlatMap&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排 API 定義了將領域服務參數中的待綁定創意列表展開成多個單創意綁定能力參數的規則，標準業務模版執行引擎將據此遍歷每一個單創意綁定參數並調用單創意綁定能力進而實現批量創意綁定。從示例中我們還可以看到，開發者在編排創意綁定能力時還通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;transferCtxBeforeStep&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排 API 指定在調用領域能力的上下文初始化和業務邏輯處理兩個標準步驟前都執行一次領域服務到領域能力的上下文傳遞操作，而標準業務模版執行引擎的默認行為是僅在領域能力上下文初始化標準步驟調用前執行該操作。除此之外，開發者還通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;onFailure&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;onException&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力編排 API 定製了失敗及異常處理措施，確保在循環過程中單個創意綁定失敗或異常不會中斷整個業務處理流程，而是在處理完所有待綁定創意之後，將綁定失敗的創意信息及失敗原因返回給調用方。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//e9af39f00bc0a3480f86264aa9f8c4c1.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;循環能力編排 DSL 示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有些讀者可能會疑惑為什麼不把創意綁定能力設計為直接在能力粒度上就支持批量綁定邏輯，這是因為當前的設計是綜合考慮能力劃分原則、創意綁定業務實際與拆分規則收益等因素之後決定的。我們曾在前文中提到，領域能力封裝的是最小原子業務模塊，而批量處理實際上屬於流程控制邏輯，因此從職責劃分的角度考慮，領域能力沉澱單個創意綁定的具體業務規則、領域服務負責循環流程控制的設計更符合 PICASO 框架的底層設計邏輯；另外從業務實際來分析，由於不同創意類型對應的創意綁定邏輯也有差異，因此創意綁定能力會按照創意類型拆分為不同的能力實例，而且廣告主有可能通過批量綁定接口一次性綁定類型不同的多個創意。在這樣的業務背景下，單創意綁定的能力拆分邏輯可以讓領域服務直接遍歷每一個待綁定創意，然後通過能力門面將單個創意綁定請求路由到與待綁定創意類型相適配的能力實例上進行處理，而不需要執行按創意類型分組等預處理邏輯；最後從拆分收益上看，單個創意綁定的拆分邏輯能夠給我們提供更多的編排靈活性，通過定製化的失敗及異常處理邏輯，不同的領域服務可以靈活地支持快速失敗或允許部分失敗等異常處理規則。綜上考慮我們最終採用了單創意綁定的能力拆分規則，而這個決策過程其實也是我們進行能力拆分的一般流程。從這個例子中我們可以發現，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能力拆分其實是一個主觀性很強的行為&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，儘管我們為其制定了一系列的指導準則，但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;在實際需求中開發者依然需要充分發揮主觀能動性，在充分理解新架構設計思想的前提下，緊貼業務實際，在系統性能、架構整潔程度以及實現成本之間找到最佳的平衡點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;截止到目前，PICASO 領域能力編排框架已經經歷了兩輪功能迭代，前文所述的順序、條件及循環編排是第一代能力編排框架提供的特性，這一代能力編排框架僅支持領域能力之間編排串聯，而領域服務各個標準步驟內的業務邏輯和能力執行圖之間的串聯依然需要手動硬編碼實現。下圖給出了一個使用第一代能力編排框架的領域服務案例，這個案例也清晰地呈現了領域能力執行圖與領域服務各個標準步驟之間的關係。可以看到領域服務執行器提供了一個標準的領域能力編排入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;registerDomainAbilities&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，該模板方法通過參數提供了一個領域能力編排器（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainAbilityOrchestrator&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;），開發者可以通過該模板方法完成領域能力執行圖的構建。然而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;當請求到來時，標準業務模版執行引擎並不會直接觸發領域能力執行圖的調用，它僅會按照標準業務執行流程依次調用領域服務執行器的各個標準步驟，而領域能力執行圖的調用則必須由開發者硬編碼到領域服務執行器的各個標準步驟中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。當然框架已經將領域能力執行圖的觸發邏輯封裝成了相對易用的 API（詳見下面截圖中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;doPreValidate&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方法中被標註的代碼片段），因此這種設計的實現成本不算太高。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;隨着系統中領域服務執行器數量的增長，它也的確在系統中引入了大量重複的膠水代碼，並且造成了領域服務中業務邏輯與領域能力值執行圖之間的割裂，無法提供徹底的連貫開發體驗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//e5bb9d6bedaf7b16f2edd288ae4af1ff.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;第一代能力編排框架依然存在一些問題&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;近年來，為了給廣告主提供簡潔易用的投放體驗，系統正越來越多地向着智能化和集成化的方向發展，讓廣告主少操作、少輸入成為 UI 交互設計重要原則。在這樣的業務背景下，我們收到了越來越多的跨層級接口合併需求，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;這讓我們的業務在模塊化的基礎上又呈現出集成化特徵&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，而且很多情況下，這種集成是「跨層級」的。如過去我們的廣告物料一直遵循經典的計劃、單元、創意三層結構，計劃下可創建多個單元、單元下可綁定多個創，創建物料時需要依次調用三個接口。然而在近期全站推廣、一頁投放等需求都有一鍵創建全層級物料的訴求。但是由於子層級物料的創編流程都依賴父層級的物料對象創建完成，這與第一代能力編排框架中的重組執行機制底層邏輯相悖；另外，由於父層級物料對象與子層級物料對象之間都是一對多的關係，在一鍵創建全套物料的場景中，我們需要循環調用子層級物料的構建流程，然而第一代能力編排框架中循環能力編排特性僅支持循環調用單個領域能力，而不支持對多個領域能力執行鏈的重複觸發。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;為了更好地適配業務發展趨勢，同時解決上文提到的第一代能力編排框架中由於領域服務與領域能力執行圖之間邏輯分離定義、需要手動硬編碼完成串聯造成的業務邏輯割裂、會引入大量重複的膠水代碼等問題&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，我們在第一代能力編排框架的基礎上進行了升級，引入了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;子流程編排機制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。子流程編排最重要的升級是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;增加了分階段集成的特性&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這也與當下多接口集成的業務發展趨勢相符，一個完整的請求處理流程可以被拆分為不同的執行階段，後置階段的執行邏輯可能依賴於前置階段的執行結果。PICASO 框架允許開發者通過子流程編排 DSL 將一個完整的業務流程拆分定義為多個業務處理階段，其中每一個業務處理階段被稱為一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;子流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;每一個子流程可以看做是一個小的領域服務，有各自專屬的標準處理步驟及領域能力執行圖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。除了可以像第一代能力編排框架那樣為每一個子流程定義專屬的領域能力執行圖之外，第二代子流程編排框架還讓開發者不需要再去重寫領域服務執行器標準模板中的各個標準步驟，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;而是通過子流程編排 DSL 將每個子流程專屬的參數預校驗、上下文初始化、上下文校驗及業務邏輯處理四個標準步驟與領域能力執行圖一起直接定義到子流程執行圖中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，從而徹底解決了第一代能力編排框架中領域服務維度的業務邏輯與能力執行圖開發割裂的問題。也正因為如此我們在第二代子流程編排 DSL 中將第一代編排框架中的領域能力編排器（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainAbilityOrchestrator&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）升級成了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;領域服務構造器（&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainServiceBuilder&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下圖給出了一個使用子流程編排 DSL 構建領域服務執行圖的例子，可以看到，與第一代能力編排框架類似，第二代子流程編排 DSL 為開發者提供了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;順序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;條件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;循環&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;捆綁&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;及&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;包裝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;五種子流程編排節點。其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;循環子流編排節點支持子流程維度的循環調用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，解決了第一代能力編排框架中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;FlatMap&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;編排節點僅支持對單個能力進行循環調用的問題，因此在一對多的子層級物料創編場景中有廣泛的應用，如下面例子中的在單元下綁定關鍵詞列表的場景：一個單元下可以綁定多個關鍵詞，而單個關鍵詞的綁定操作需要串聯執行多個領域能力，此時我們可以將單個關鍵詞的構建過程定義為一個基礎順序子流程，然後再通過循環子流程編排節點將這個基礎子流程循環集成到單元創建領域服務執行圖中，這樣就可以實現在單元下批量綁定關鍵詞的功能；而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;捆綁子流程的作用類似於通用編程語言中的‘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;’，它能夠將多個子流程包裝成一個邏輯子流程節點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這一特性讓子流程編排能夠支持任意不同子流程之間的組合及嵌套，進一步提升了編排框架對各類業務場景的普適性；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;包裝子流程節點則是專門為已有領域服務執行器的組合複用而設計的，它可以將一個現有的領域服務執行器包裝成一個子流程編排節點添加到子流程編排執行圖中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這一特性在複用現有接口進行集成化改造或實現批量操作等需求中會為開發者提供極大的便利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//00576a00f7b24b4d8ed784904b7af260.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;第二代子流程及能力編排框架示例&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通過上面的幾個例子我們能感受到，領域能力編排 DSL 能夠以極高的信息密度描述業務流程的關鍵信息，通過構建領域能力/子流程執行圖的方式定義業務流程的措施不僅能夠減少膠水代碼、降低開發負擔，還可以&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;協助開發者快速建立起對業務的全景認知，同時，領域能力/子流程執行圖也能作為詳細業務規則的目錄或索引，在進行業務梳理或問題排查時讓開發者可以按圖索驥快速定位目標代碼的大致位置，提升業務知識傳承及問題定位的效率&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;儘管我們在 PICASO 框架中捨棄了圖形化流程編排框架的設計，但是我們並沒有否定它存在的意義，這種編排方式在低代碼編程領域佔有重要的地位。但是它更適合在一些節點類型有限或者流程相對穩定的業務場景下使用，比如審批流程，雖然審批流可能有很多，但是每個審批流程中的節點種類往往不多，可以用相對固定的模式進行串聯；或者廣告播放流程，儘管其業務流程同樣節點眾多、冗長複雜，但是流程數量相對固定，基本上可以分為展示、搜索、推薦、站外、合約這五大核心流程，很多變更是對流程的微調或節點內部的邏輯升級。與這些業務相比，廣告投放系統則維護了近 300 個能力節點、400 多條請求處理流程，每次需求迭代都會涉及數十條業務流程的變更。在這樣的業務特點下，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;簡潔、靈活、集中、連貫的開發體驗要比一個炫酷的 UI 交互界面重要的多&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;。當然，我們依然十分認可圖形化界面強大的呈現能力，事實上我們也在規劃為 PICASO 框架開發內置的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代碼元數據管理平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;，其中一項重要的功能就是把代碼中基於能力編排 DSL 構建出來的領域能力執行圖解析為業務流程圖回顯到交互界面中，讓開發者可以直觀地查看所有領域服務的處理流程。但是該平台只做能力編排邏輯的圖形化展示，領域能力執行圖的構造依然是通過代碼中的能力編排 API 實現的（當然該平台也可以提供各個能力編排節點配置屬性的動態修改功能，但是這僅作為緊急情況下的應急處理措施）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h3_16&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PICASO 的願景：構建圖書館式代碼架構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至此我們已經完成了對 PICASO 框架全部核心模塊的介紹，此刻讓我們再次回首 PICASO 框架的設次初衷——竭盡所能地提升團隊的研發效率，這也是一線業務開發團隊的核心價值所在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提到研發效率，有很多同學認為少寫代碼就是研發效率高，也有同學認為支持了配置化、使用了拓展點就能實現研發效率的提升。然而事實上代碼行數從來就是不是制約研發效率提升的核心要素，對業務問題的抽象和封裝有時的確會導致我們多寫一些代碼，但是與多寫幾行代碼花費的幾十分鐘相比，在實際工作中我們會把更多的時間和精力消耗在確定分工時與合作團隊的扯皮上、需求設計時各團隊方案對齊及歷史業務邏輯的確認上、出現問題時原因的定位與影響範圍的評估上、由於自己或者上下游系統的技術或架構限制而不得不進行的妥協方案開發上......解決這些問題所花費的時間才是阻礙研發效率提升和耗盡業務方對研發團隊信任的根源。至於配置化和拓展點，不可否認的是它們的確是包括 PICASO 框架在內的很多效率提升解決方案中經常採用的措施，但是如果上述問題得不到解決，這些措施也只能是治標不治本。正如「鮑勃大叔」Robert C.Martin 在其著作《架構整潔之道》中所説：「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;不管你多敬業、加多少班，在面對爛系統時你仍然會寸步難行，因為你大部分的精力是在應對混亂。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」而我們之所以要為分工扯皮、之所以不敢升級系統以適配新的業態、之所以無法快速梳理出業務規則，都是因為過去大泥團式的代碼架構讓我們&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;看不懂、不敢動、動不了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;為瞭解決上述問題，PICASO 框架在設計之初就確立了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;框架即規範、代碼即文檔&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基本原則，從設計階段就開始引導開發者以統一的思想和方法論對業務進行拆解分析，然後將業務規則澱到&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;標準業務執行模版或拓展點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接口中，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;確保每一處業務規則都有可檢索、可引用的實體邊界&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;；接着通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;能力編排框架&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以近乎白話文的方式將這些原子業務實體組裝起來，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;以極高的信息密度清晰地描述完整的業務流程&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;；最後通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;通用可執行實體發現及路由機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;對各層實體進行分類及分組，對上層實體暴露統一的調用門面，除了起到逐層向上屏蔽分組內部場景複雜度的作用之外，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;PICASO 框架維護的可執行實體路由表也可以作為業務細節邏輯的速查索引&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。有了這些措施，開發者進行業務邏輯梳理時就可以先通過領域服務維度的路由表定位到目標場景對應的領域服務實例，然後通過其領域能力執行圖快速建立起對務流程的全景認知，接着選擇執行圖中感興趣的業務節點，通過領域能力維度的路由錶快速定位到具體的能力實例，最後到相應的的標準步驟中定位具體的實現細節。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;這種由粗及細、逐層按索引查找的過程類似於&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;圖書館的管理模式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：借閲圖書時，我們需要大體推斷目標書籍所屬的類目，然後通過類目確定書籍所在的書架，在書架上找到目標書籍後再通過其目錄快速概覽全書，最後通過目錄定位到感興趣的內容，這就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;圖書館式代碼架構&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的由來。我們希望這種代碼架構能夠讓業務知識通過系統代碼清晰、準確、完整地表達出來並能流暢地傳承下去，進而讓團隊在面對業態更迭時能夠更加從容地承接業務方提出的各項訴求；在進行多團隊協作時能夠擁有足夠的底氣承擔更多的責任；在遇到線上問題時能夠更加快速地定位問題並制定解決方案；在接手新系統時也能夠快速梳理出業務主線並上手開發，最終實現團隊整體研發效率的提升。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_17&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（二）聚合與資源庫：拒絕魔法邏輯，讓代碼直接表達業務規則&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果説前文介紹的 PICASO 框架讓新架構擁有了領域驅動設計之形，那麼接下來將要介紹的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;聚合與資源庫機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;將讓新架構真正具備領域驅動設計的靈魂。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;長期以來，我們的開發行為中業務設計與代碼設計是分離的。接到需求後研發人員會和產品及業務方進行大量的溝通，確認業務流程及各項細節規則，這是業務設計的過程。但是在編碼階段，開發人員又會對業務設計結果重新進行抽象，轉化為代碼實現方案。而此時傳統的三層架構過於簡單的層次劃分很容易將開發者的大部分注意力引導到數據庫設計上，代碼設計就變成了對數據庫增刪改查操作的設計。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;在這個過程中前期業務設計沉澱的大量領域知識往往會被丟棄，實現出來的代碼也失去了對業務規則的直接表達。而缺乏基礎模型設計的軟件充其量也只是一種機械化的產品，雖能實現功能卻無法解釋這樣操作的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;更嚴重的是，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;如果底層數據庫存在表或字段的複用，那麼業務規則被直接翻譯成庫表增刪改查操作邏輯之後，代碼甚至會表達出與業務規則完全不相符的含義出來&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這些代碼就成了只有開發者自己才能看懂的魔法邏輯，甚至經過一段時間之後開發者本人也會忘記這些代碼背後真正的業務含義......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;如果整個程序設計或者其核心部分沒有與領域模型相對應，那麼該模型就是沒有價值的，軟件的正確性也值得懷疑。（Eric Evans, Domain-Driven Design: Trackling Complexity in the Heart of Software, 2003）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;面向數據庫編程的設計思維還容易引導我們最終以事務腳本（Transaction Script）的形式實現業務流程的處理，將業務規則與數據庫表操作邏輯糅合到一起，業務實體之間的關係也因此分散和隱藏到了整個工程中不同的接口實現裏，這會給數據模型全景認知的建立帶來極大的障礙。領域驅動設計思想的祖師爺及佈道者 Eric Evans 曾提到自己項目組的成員曾花費數月時間才梳理出一個完整的數據模型，而在我們自己的記憶裏，似乎也沒有哪位同學有底氣敢宣稱自己掌握了完整的數據模型（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;我們可能清楚數據庫中有哪些庫表，但是由於底層庫表存在不同業務場景複用的情況，導致表中數據對應的業務含義並不統一。這種複用表結構的設計無可厚非，在很多情況下我們甚至都鼓勵這種縱向拓展方式，但這也的確是造成我們對數據模型認識模糊和不完整的主要原因&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）。數據模型全景認知的缺失讓開發者很難進行統一的模型頂層設計，在多需求並行推進的開發模式下很容易在不同項目組之間形成信息孤島，無法實現模型複用與合併，導致數據模型野蠻膨脹，這反過來又進一步加劇了數據模型全景認知的構建難度，從而陷入到惡性循環中無法自拔。除此之外，業務流程中不同的業務環節可能會依賴相同的底層數據，事務腳本式的業務處理邏輯會將這些底層數據的讀寫操作分散到不同的接口或業務模塊的實現中，除了會造成重複編碼之外，還有可能在運行時造成重複和碎片化的數據讀寫操作，進而影響系統性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;聚合與資源庫機制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是專門為解決上述問題而生的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_18&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;聚合與資源庫機制實現數據模型與業務邏輯分離&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合（Aggregate）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是領域驅動設計思想中重要概念，它是一組相關對象的集合，這些對象之間關聯密切，彼此之間已經按照對象之間的關係以父子屬性的方式組裝好。每個聚合都有明確的邊界（boundary）和一個聚合根（root），其中邊界定義了這個聚合中都有哪些對象，而聚合根則是這些對象中的一個特定實體。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;聚合根&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是聚合內唯一個允許被外部對象引用的實體，也是聚合中的所有實體的最頂層父級對象，因此&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;通過聚合根可以訪問到聚合內所有對象，這會給上層業務規則的實現帶來了極大的便利&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是實際業務中聚合內的實體關係通常都十分複雜，常常存在多級嵌套關係。比如廣告投放業務中計劃聚合內就存在着「計劃-&amp;gt;單元-&amp;gt;創意-&amp;gt;子創意-&amp;gt;子創意審核記錄」這種多達 5 層的嵌套實體結構。如果每次使用聚合時都需要開發者手動實現聚合內實體的組裝邏輯顯然會帶來大量的重複代碼及編碼負擔，對系統未來的維護來説也將是一場災難，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;資源庫&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是為瞭解決這個問題而設計的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;資源庫（Repository）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;是系統中所有聚合根對象的邏輯集合，當然這並不意味着資源庫對象會直接加載和維護系統中所有的聚合根實例，它只是邏輯上的集合。事實上在實現層面業務數據始終保存在數據庫等存儲介質中，資源庫只是定義了針對聚合根或聚合根集合的增刪改查操接口，並且維護了底層存儲介質中的數據記錄與聚合實體對象之間的映射關係以及聚合中各個實體之間的關聯組合邏輯。因此開發者可以通過資源庫定義的標準接口一鍵獲取到一個組裝好的聚合根對象，就好像是從一個集合中取出一個元素那樣容易。如下圖所示，與傳統架構業務層代碼在不同業務環節中直接訪問數據庫的實現方式相比，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;新架構在上層業務（領域服務）與底層數據庫訪問層中間插入了一層資源庫，上層業務需要獲取聚合數據時，不需要自己實現聚合中各個業務實體的查詢、映射和組裝邏輯，而是通過資源庫提供的標準接口直接獲取已經組裝好的聚合根對象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這種設計將聚合內各個實體的查詢、映射及組裝邏輯收口屏蔽在資源庫內部，讓上層業務聚焦在業務規則上，從而實現了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;數據模型與業務邏輯的分離&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。這樣不僅能夠避免在業務邏輯中頻繁穿插繁瑣的數據查詢和組裝邏輯，防止在運行時出現重複及碎片化的數據讀寫操作，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;資源庫集中維護的各個聚合實體的查詢、映射和關聯邏輯也是一份重要的業務知識，能夠輔助開發者快速建立對完整數據模型的全景認知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//a38798e9cd68c415a9649b696bc8eb76.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;聚合與資源庫的引入實現了數據模型與上層業務模型的分離&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_19&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六邊形架構讓代碼從業務中來到業務中去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在上一個小節我們介紹了聚合和資源庫的定義及實現準則，這其實有些本末倒置，因為聚合和資源庫機制的關鍵不是如何實現聚合實體的查詢或者持久化，而是如何設計一套有價值的聚合（當然，先了解聚合的實現準則對理解聚合的設計準則是有幫助的），而聚合的設計原則正是領域驅動設計思想核心理念的直接體現。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;網絡上很多介紹 DDD 思想的文章都是從統一語言、領域、界限上下文等術語和概念開始的，但是由於中英文語境的差異和國內外軟件開發生態的不同，這些文章很容易讓初學者陷入到各種概念的泥沼中無法自拔。然而那些概念只是領域驅動設計思想的外在表現形式，其背後的思想內核才是我們應該優先掌握的內容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;領域驅動設計思想的核心理念就是保持業務、領域模型和代碼三者之間的統一&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;六邊形架構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;就是為了保障系統能夠達成這一目標而設計的，它的核心邏輯在於保護領域模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六邊形架構實際上是在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分層架構&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的基礎上升級而來。領域驅動設計思想作為一種設計的指導思想其實並不會限制使用某種特定的架構，在傳統的分層架構上也可以實現領域驅動設計思想的落地。下圖中最左側給出了應用了領域驅動設計思想之後的分層架構，它看上去就是將傳統三層架構中的業務層拆分為應用層與領域層。其中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;領域層負責維護領域模型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，所謂的領域模型就是由當前領域內的全部聚合、資源庫以及運行在這些聚合實體上領域能力和領域服務構成的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;應用層則從業務視角定義了系統應該對外提供多少服務&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（也就是所謂用例（use case）和用戶故事（user story），如果你特別執着於那些術語的話），這些服務接口最終都會調用領域層中的領域服務執行器來實現接口功能；應用層關注的是在系統應該對外提供哪些服務，但是並不關心這些服務的請求來源是 RPC 調用還是 MQ 通知，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;這是用戶接口層的職責，它負責根據與調用方達成的約定將應用層接口暴露給不同的接口協議&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：Http、RPC、MQ、事件通知等等；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;基礎設施層則負責維護系統中使用的眾多中間件、工具以及底層存儲介質的訪問邏輯&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//abe8b83e92d82c7cb82be66d2b1457a6.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;多層架構向六邊形架構的演進歷程&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通過領域層和應用層的抽象，我們讓分層架構具備了實施領域驅動設計思想的可能。但是分層架構天然會引導開發者自上而下地以數據流的視角審視系統。而人腦的天性使我們更容易關注流程的始末，而容易輕視流程的中間環節。因此分層架構容易讓開發者更多的關注底層數據的存儲邏輯，進而再次陷入面向數據庫編程的思維，設計出與實際業務脫節的領域模型。當然，我們自然可以通過不斷的宣貫和世界觀輸出來呼籲開發者緊貼業務實際設計代碼實體，避免在需求伊始就陷入到底層庫表結構中無法自拔，但我們還是希望找到一種&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;能夠在架構模式上就凸顯領域模型的重要性，引導開發者從業務實際出發設計領域模型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;的架構，這就是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六邊形架構&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;誕生的背景。在對六邊形架構進行詳細介紹之前，我們先回過頭來再次審視分層架構中用戶接口層和基礎設施層的職責差異，這對理解六邊形架構的本質十分重要：用戶接口層將系統服務暴露成不同的協議接口，因此其內部的代碼主要在執行接口參數轉換和應用層接口調用的邏輯；在領域服務返回處理結果之後，用戶接口層還需要將領域服務返回的響應結果包裝成符合對外接口協議的響應對象。而基礎設施層主要維護的是底層數據的訪問邏輯，似乎與用戶接口層的職責千差萬別。但是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;如果我們把數據庫看做是一個特殊的外部服務，基礎設施層的代碼執行邏輯就與用戶接口層幾乎一致了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：基礎設施層負責的就是聚合實體與底層存儲 PO 對象之間的轉換及存儲介質數據傳輸協議的調用。我們不難發現用戶接口層與基礎設施層都在針對領域模型做防腐處理，從這個視角看，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;用戶接口層與基礎設施層在架構中的地位是相同的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。因此，如上圖中間位置的架構圖所示，在架構模式上我們嘗試將用戶接口層與基礎設施層&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「掰」&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;到一個同一個層級中合為一體，於是我們就能得到一個&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六邊形的對稱架構&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（從上圖的呈現方式上看，將用戶接口層與基礎設施層合併後可能還需要再旋轉 45°才能呈現出與上圖右側一致的六邊形架構）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;六邊形架構本質上還是一個分層架構，只是在呈現方式上（注意不是實現方式）將用戶接口層與基礎設施層合二為一，讓他們共同作為防腐層保護位於架構中心的領域模型不被調用方的請求協議以及底層數據庫的特殊設計所污染。而人腦天然具備的找中心的特性能夠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;讓開發者將更多的注意力放到位於架構中心的領域模型上，暫時忘記底層數據庫的存儲規則，進而能夠緊貼業務實際設計聚合中的各個實體及值對象，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;讓代碼直接表達業務規則&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，最後通過資源庫實現聚合實體與底層存儲介質 PO 對象之間的轉化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下圖給出了一個廣告投放業務中聚合實體與底層庫表結構設計的例子，投放系統作為一個業務集成平台需要不斷地對接各種垂直業務系統，在廣告物料中也需要不斷集成各類業務實體，這些數據也需要保存到底層的廣告物料數據中。在設計單元聚合時，我們會緊貼業務實際為各類外部關聯對象定義含義明確的聚合實體：商品庫（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;ProductCategory&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、抖音賬號信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AweneAccount&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、展示錨點信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AnchorInfo&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）、直播信息（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;LiveInfo&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;）等，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;從而確保領域模型與實際業務的統一&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。但是在設計底層庫表結構時為了避免庫表結構膨脹以及表字段稀疏化，我們採用了通用化的存儲結構：綁定到廣告物料上的不同外部業務對象都保存到同一張外部關聯對象表中，該表中的字段採用泛化設計，不與任何一種特定的外部業務對象相綁定，而是通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;字段確定本條記錄對應的外部對象類型以及表中其他字段的實際業務含義，業務層對這些外部業務對象讀寫操作都要通過資源庫集中維護的底層數據記錄與領域層聚合實體之間的映射邏輯做轉換。需要特別説明的是，在新架構中我們將 PICASO 框架中的拓展點機制延伸到了基礎設施層，引入了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模型管理拓展點（Model Manage Extension, MME）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;來實現聚合組裝主流程與底層數據對象轉換邏輯的解耦。在本例中，我們將外部關聯對象表對應的 PO 對象與領域層聚合實體之間的映射邏輯抽離成了一個模型管理拓展點，以外部關聯對象類型作為路由鍵，通過 PICASO 框架的通用可執行實體發現與路由機制實現具體拓展點實現的自動定位。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;可以看出資源庫的存在不僅讓開發者可以聚焦業務實際設計領域模型，讓代碼直接反映業務實際，同時還讓通用化的底層數據存儲結構得到更加廣泛的應&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：庫表結構的通用化設計雖然能夠解決數據庫模型膨脹的問題，但是也的確降低了數據模型對業務的表達能力，而且如果讓上層業務直接操作這些庫表，勢必會造成代碼邏輯不明、編碼繁瑣的問題。然而資源庫卻通過收口底層數據對象與上層業務實體之間的轉化邏輯很好地解決了這些問題，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;讓我們在採納這種通用化的數據存儲結構設計時少了很多顧慮&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//1d854f02de342eead602dfb8d6fdd3d0.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;底層通用化存儲結構（K-V 模式）在資源庫中通過模型管理拓展點被映射為領域模型中業務含義明確的實體對象&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在框架實現層面六邊形架構與分層架構其實並沒有太多的差異，頂多就是在六邊形中領域模型僅負責定義資源庫接口，而將資源庫的實現放到了基礎設施層中。在使用了 Spring 等控制反轉容器的項目中，一些宣稱採用了分層架構的系統可能已經在無意間實現了六邊形架構了。那麼六邊形架構的意義又是什麼呢？我們在前文中曾引用了 IEEE 對「架構」的定義：組織、組件以及指導思想，然而很多時候我們都忽略了指導思想對軟件開發行為的重要影響。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一個好的架構一定是包涵人性的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，架構思想直接決定了開發者分析業務的世界觀和方法論。框架只是輔助工具，基於框架思想對業務進行抽象和設計而產出的代碼才是一個軟件系統的主要構成部分。即使採用相同的框架，在不同架構思想的引導之下，系統中的業務代碼也可能會走向全然不同的迭代路線。而六邊形架構與分層架構的差異正體現在二者對開發行為的指導思想上，六邊形架構以領域模型為中心，引導開發者始終緊貼業務實際進行模型設計。它與 PICASO 框架相輔相成，讓系統在應對高複雜度業務時依然能保持對業務規則的清晰表達。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_20&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;聲明式數據操作既要規範又要靈活&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如前文所述，一個聚合會包含業務子域內的全部實體與值對象，資源庫會維護這些業務實體的查詢、映射及組裝邏輯。但是並不是每一個領域服務都會用到聚合中的全部實體，如果每次獲取聚合根時都將聚合內所有實體都查詢出來，勢必會造成極大性能損耗。然而資源庫作為基礎設施層中的底層組件，也不可能為每一個領域服務提供專用的聚合查詢或者數據持久化接口。為了調和這兩者之間的矛盾，我們在資源庫實現上採用了聲明式數據操作設計。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在《能力編排領域特定語言》章節中我們已經對聲明式編程有了比較具象的體會，但聲明式編程並不限定於領域特定語言這一種實現形式，在資源庫的接口設計上我們採用了一種更加樸素的聲明式編程實現方法。如下圖所示，我們計劃聚合的查詢以及創意聚合的更新接口為例來闡述聲明式數據操作的設計細節。當需要從資源庫中獲取聚合根對象時，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;默認情況下資源庫庫會自動查詢聚合下所有子實體並完成組裝，但是開發者可以再提供一個額外的輔助查詢參數&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DomainQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;，並通過該對象的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;addSubEntityQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;方法聲明希望獲取哪些特定的子實體&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。默認情況下資源庫會根據聚合根對應的主表記錄 ID 做子實體查詢，如果開發者希望在子實體查詢時使用額外的匹配條件，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;則可以通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;addSubEntityQuery&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#4c7cff&quot;&gt;方法同時聲明希望獲取的子實體類型以及執行該類型子實體查詢時使用的額外匹配參數&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，這一特性在與聚合根存在一對多的子實體查詢場景中會發揮重要作用。上述聲明式接口在資源庫實現中並不複雜，只需要在執行每個子實體的查詢或修改操作之前，判斷一下上層調用方是否限定了僅對部分子實體進行操作，如果設置了則進一步判斷當前子實體是否在上層調用方指定的子實體範圍之內，如果當前子實體業務上允許調用方指定自定義的匹配邏輯，還需要嘗試從輔助查詢/修改參數中提取調用方為該子實體指定的自定義匹配邏輯。需要特別説明的是，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;我們不推薦在新架構內部各個模塊之間採用任何形式的黑盒調用模式，不管是能力編排還是資源庫調用，上層調用方都有責任和義務理清底層模塊的內部執行邏輯，確保編排配置或調用參數設置正確&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//324f9467ff6988a231a7e8f8fc6ad173.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;基於資源庫進行聲明式聚合數據查詢&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_21&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、新架構下的業務開發流程速覽&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;span id=&quot;OSC_h2_22&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;業務建模&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新架構作為領域驅動設計思想的戰術落地框架，能夠讓其發揮出最大價值的前提是對業務進行良好的領域建模，下圖給出了廣告投放平台中競價及合約廣告投放服務的業務架構。由於本文的主題聚焦在如何腳踏實地地實現一個基於領域驅動設計思想而設計的系統，因此關於 DDD 思想戰略設計相關的內容本文將不做過多闡述，相關內容我們將在後續《領域驅動設計與 PICASO 框架》一文中進行詳細闡述。需要説明的是，圖中的聚合服務層、領域能力層及數據模型層共同構成了廣告投放平台和核心領域模型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//cdce0355a70e153d6d7759b82aa4f84b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;競價及合約廣告投放服務分層業務架構&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_23&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工程結構&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下圖給出了新架構思想落地時工程結構的最佳實踐案例，工程中各 module 的職責以及與上文中業務分層架構圖中各層的對應關係依次為：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-framework&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：框架包，承載架構標準規約及分層架構圖中基礎設施層中的各項基礎組件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-module/rtbad-support-module&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：模型包，對應的是分層架構圖中的模型層，承載領域模型中各個聚合及聚合實體對象的定義，另外用於實現底層存儲介質中持久化數據與領域模型中實體對象映射邏輯的資源庫也定義在此類 module 中。其中 support-module 定義的是支撐域中的實體對象，該 module 下會按照業務子域進一步進行子 module 劃分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-event&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：事件包，屬於特殊的數據模型層，承載這領域事件對象的定義，新架構底層融合了事件驅動架構（篇幅的關係我們會在其他文章中進行專門地介紹），因此事件體系建設也被納入到統一建模的工作中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-composite/rtbad-support-compoaite&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：聚合服務包，對應分層架構中的領域能力及聚合服務層，承載領域能力及領域服務執行器的實現，其中 support-Composite 用於承載支撐域領域能力及領域服務執行器的實現，該 module 下會按照業務子域進一步進行子 module 劃分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-app&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：部署層，內部分為不同的子 module，每一個子 module 對應一個部署應用，其實現邏輯就是根據應用職責組裝底層各個子 module，進而實現不同應用下能力及模型共享。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rtbad-api&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：對外接口 SDK 包，承載了對外提供的 API 接口定義。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//293b49d270375f491db2ec28c2c6d461.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h2_24&quot;&gt;&lt;/span&gt; 
  &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代碼開發流程示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;以下內容以一次計劃新建請求為例，通過從流量入口到數據落庫的完整請求流程展示使用新架構實現業務需求的全部過程，我們希望通過這個例子讓大家建立對新架構的直觀感受。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_25&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務統一入口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務統一入口（Domain Service Faced）的作用是為 HTTP、RPC、MQ 等上層不同的請求流量暴露統一的服務入口。他將同一個業務子域內領域服務執行器集中到一起，便於流量介入層調用，同時也可以集中進行方法性能監控、調用量統計、請求日誌記錄等通用功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//d852396737c66f3b46df116a9366019e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_26&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務門面執行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務統一入口引用的是各個領域服務門面執行器，它負責從參數中提取業務標識並定位到具體的領域服務實例。如下圖所示，所有具體的領域服務實例都繼承自領域服務門面執行器，請求到來時領域服務門面先通過&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;generateRouteKey&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方法從當前參數中提取出本次請求的業務標識，然後與各個領域服務實例能夠支持的業務標識做匹配，從而定位到應該處理本次請求的服務實例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//b72d14450dcf7d42a186a525c21b277c.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_27&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域服務實例執行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力執行圖的作用是定義業務執行流程，框架提供了豐富的 API 及大量的語法糖和默認規則，配合鏈式調用的風格，在支持靈活編排的同時減少了開發者的負擔。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//48540f6a1eee1e5380df3a95b3861702.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_28&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域能力門面執行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;負責從參數中提取場景標識並定位具體的領域能力實例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//054a30e3192e2663263ac9768fe9572f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_29&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;領域能力實例執行器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;能力內主要負責實現具體的業務規則，並對聚合根中相關屬性進行設置/修改，一個領域服務編排的所有領域能力執行完成之後，就能獲取一個完整的、全新的聚合根對象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//135f836f9c6053353870b009efc3ba95.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_30&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;拓展點的作用是作為任意維度的差異點&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;補充分離&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;工具。需要注意的是在新架構中拓展點不是唯一的差異分離工具，在通用對象發現及路由機制下，領域服務、領域能力和拓展點都在不同維度上起着差異點分離的作用。相對與前兩者拓展點更加靈活，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;通常用來承接領域服務及能力自身路由維度之外的邏輯差異&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。比如出價設置能力已經按照出價方式做了能力維度的差異分離，但是在相同的出價方式下，京準通與流量貨幣化還存在一些細微的邏輯差異，那麼這個時候就可以在該能力實例中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#f5222d&quot;&gt;通過拓展點來補充實現平台維度的差異邏輯分離&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//da97e273087f8f10d775f90292607209.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面的例子是在計劃名稱設置能力中獲取不同產品線計劃名稱長度上下限配置的拓展點，計劃名稱設置能力自身按照產品線類型進行業務模式路由，但是站內計劃名稱設置主要業務邏輯基本一致，僅在部分校驗邏輯上不同產品線有各自的要求，此時就可以使用一個名稱設置能力實例服務所有的站內產品線，定義名稱設置主體業務規則，而把不同產品線的細微差異抽象成一個拓展點接口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h3_31&quot;&gt;&lt;/span&gt; 
  &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;資源庫&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上層業務通過聲明式接口實現聚合實體讀寫操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//556b6d0d3fe119766a462ed65c36464e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;div&gt; 
   &lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet//5c2f500826e1efb5546e9f51267fd22e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;/div&gt; 
  &lt;span style=&quot;color:transparent&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;p&gt;&amp;nbsp;&lt;/p&gt; 
  &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;span id=&quot;OSC_h1_32&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;五、結語&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt; 
  &lt;p style=&quot;text-align:justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;很多同學對業務開發一直存在一種偏見，認為業務開發很簡單，甚至有業務開發同學自己也時常調侃自己是 CRUD 工程師，認為自己的工作沒什麼技術含量。但其實業務開發一點都不簡單，只是過去我們一直把它做簡單了。如今業務形態複雜多變，商機轉瞬即逝，如何在快速變化着的複雜業務需求中維持系統健康、穩定、持續迭代，要做到這一點的難度其實一點都不比底層技術差。程序員應該是一門充滿學術性與創造性的職業，我們唯有堅守初心，不斷夯實自己的技術功底，沉澱提升抽象與建模能力，培養自己的系統化思維，不斷學習精進，追求極致編碼，這才是我們無法被 AI 替代的核心競爭力與價值所在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
  &lt;blockquote&gt; 
   &lt;span&gt;&lt;span&gt;&lt;span&gt;有同學可能會關注本文介紹 PICASO 框架未來是否可以對外共享，關於這個問題我們的答案是肯定的。在 PICASO 框架開發之初我們的野心就沒有侷限在京東廣告投放平台這一個業務場景上，而是希望它可以走出廣告部，甚至走出京東，接受全社會開發者的檢驗，成為一個被業界認可的複雜 B 端業務通用解決方案。然而作為一個一線業務團隊，快速支持業務方需求是我們的首要職責。儘管我們在進行 PICASO 底層框架開發時盡力維持與具體業務分離的開發原則，但是在需求排期比較緊張的時候，為了快速支持業務需求的開發，還是存在將與廣告投放業務相關的邏輯耦合到了 PICASO 框架底層源碼中的情況。如果大家有興趣閲讀或者試玩 PICASO 的源碼，請聯繫筆者為您開放一個示例版本的框架源碼權限，該版本框架的功能與筆者負責的線上系統使用的框架功能完全相同，只是去除了廣告投放業務相關的邏輯。您可以在該版本源碼上執行任意的功能及性能測試，但是在我們對外發布正式的共享版本之前，我們並不建議您直接將該示例版本的源碼應用到線上系統。目前框架功能已趨於穩定，我們也將 PICASO 框架的開源化改造提上日程，也歡迎感興趣或者有開源社區維護經驗的同學一起交流共建。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 
  &lt;/blockquote&gt; 
  &lt;span id=&quot;OSC_h1_33&quot;&gt;&lt;/span&gt; 
  &lt;h1&gt;&amp;nbsp;&lt;/h1&gt; 
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/18211828</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18211828</guid>
            <pubDate>Sun, 13 Apr 2025 03:05:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>JuiceFS v1.3-beta1：全面優化 SQL 數據庫支持，十億級元數據管理新選項</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                                                                                        &lt;p&gt;JuiceFS v1.3-beta 今天正式發佈。在這個版本中，除了進行了大量使用體驗優化和 bug 修復外，新增如下特性：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;&lt;strong&gt;新增 Python SDK&lt;/strong&gt;：這是一個從企業版移植過來的特性，旨在支持 FUSE 受限的場景，並優化某些高性能環境中的 I/O 性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Windows 客戶端可用性大幅優化&lt;/strong&gt; ： 
  &lt;ul&gt; 
   &lt;li&gt;修復了 Windows 客戶端在 Windows API 調用和用戶身份管理等方面存在的多個兼容性問題。&lt;/li&gt; 
   &lt;li&gt;完善了工具支持，目前 debug、stat、info 等子命令已可在 Windows 平台下正常使用。&lt;/li&gt; 
   &lt;li&gt;新增了對 -d 參數的支持，使 JuiceFS 可以直接作為系統服務進行掛載，無需再借助第三方工具。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增二進制備份功能&lt;/strong&gt;：可在多種元數據引擎中實現高效的備份和導入。性能提升的同時，還顯著降低了內存佔用。在 TiKV 上備份億級別的元數據時，所需時間僅為原 JSON 格式的十分之一。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;全面優化 SQL 支持&lt;/strong&gt;：涵蓋事務處理、併發控制、連接管理和緩存優化等多個方面，顯著提升 SQL 元數據的處理效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Apache Ranger&lt;/strong&gt;：引入了與 Apache Ranger 的集成，在大數據場景給用戶提供更加靈活和細粒度的權限控制方案。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;除此之外，JuiceFS Gateway、sync 、元數據也有多項優化。本次版本更新，共有 xx 名貢獻者參與，合入 xxx 次代碼。感謝每位貢獻者的付出！&lt;/p&gt; 
&lt;p&gt;在近期的博客中，我們將逐一為大家介紹這些特性的原理及應用。&lt;/p&gt; 
&lt;h2&gt;01 JuiceFS 元數據引擎簡介&lt;/h2&gt; 
&lt;p&gt;元數據管理直接關係到文件系統的性能與穩定性，JuiceFS 提供對多種具備事務支持的引擎的兼容能力。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;文件型（如 SQLite） 適用於單機掛載的文件系統，適合百萬級文件和以讀取為主的場景。&lt;/li&gt; 
 &lt;li&gt;內存 KV 類型（如 Redis） 支持多點掛載，適合文件數在一億以內的場景。&lt;/li&gt; 
 &lt;li&gt;SQL 數據庫（如 MySQL、PostgreSQL） 支持多點掛載，適合文件總數在十億以內的場景。&lt;/li&gt; 
 &lt;li&gt;分佈式 KV（如 TiKV） 支持多點掛載，適合百億級文件的場景。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其中，SQL 類數據庫相較於其他類型的數據庫，具備更強大的事務處理能力和一致性保障，且在企業核心應用中廣泛使用，是 JuiceFS 的元數據存儲的理想搭檔。然而，由於 SQL 數據庫的配置與調優相對複雜，使用者需具備一定的專業背景，這在一定程度上限制了其在社區中的普及。&lt;/p&gt; 
&lt;p&gt;JuiceFS 1.3 版本對 SQL 數據庫的支持進行了全面的優化，涵蓋事務處理、併發控制、連接管理和緩存優化等多個方面，顯著提升 SQL 元數據的處理效率、系統穩定性和併發處理能力，使社區版在應對十億級文件規模時表現更穩定高效。&lt;/p&gt; 
&lt;p&gt;接下來將圍繞這些優化展開介紹，解析優化背後的設計思路與技術細節，並通過對比測試數據展示 JuiceFS 在 SQL 元數據模式下性能與穩定性的顯著提升。&lt;/p&gt; 
&lt;h2&gt;02 簡化事務請求，性能提升 20%+&lt;/h2&gt; 
&lt;h3&gt;事務處理機制優化 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5377&quot; target=&quot;_blank&quot;&gt;PR：#5377&lt;/a&gt; ）&lt;/h3&gt; 
&lt;p&gt;為了提升 SQL 元數據在高併發下的處理效率，我們首先對事務執行流程進行了詳細梳理。JuiceFS 使用 ORM（Object-Relational Mapping）來操作數據庫，以支持多種不同 SQL 元數據類型。在執行讀寫事務時，JuiceFS 要確保在同一事務內，重複執行同一個 SQL 查詢時得到一致的結果，即數據庫的事務隔離級別（簡稱 Isolation Level，要求 Repeatable Read），因此 JuiceFS 使用了事務模板來統一執行所有的 SQL 語句。一個事務模板通常會包含以下幾個步驟（每一步都是一次命令交互，即一個網絡來回）：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;從連接池取得數據連接或創建一個新連接&lt;/li&gt; 
 &lt;li&gt;設置事務隔離級別（通常是 set transaction_isolation 命令）&lt;/li&gt; 
 &lt;li&gt;開始事務（通常是 begin 或 start transaction 命令）&lt;/li&gt; 
 &lt;li&gt;執行第一個 SQL，並取得結果，進行相關處理&lt;/li&gt; 
 &lt;li&gt;執行第二個 SQL，並取得結果，進行相關處理&lt;/li&gt; 
 &lt;li&gt;事務提交（commit 命令）或事務回滾（rollback 命令）&lt;/li&gt; 
 &lt;li&gt;歸還數據庫連接到連接池&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;strong&gt;仔細梳理後，發現有較多的事務中包含單個 SQL 查詢語句，這時其實不需要去設置事務隔離級別，也不需要執行開始事務命令、事務提交或回滾命令，以省去這些交互和網絡來回&lt;/strong&gt;。基於此，我們為單個 SQL 增加了專門的處理模板，有效減少與 SQL 元數據的命令交互次數，減少網絡來回，有利於提升文件系統訪問性能，並有效減輕 SQL 元數據的壓力。&lt;/p&gt; 
&lt;h3&gt;MySQL 事務機制優化（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5432&quot; target=&quot;_blank&quot;&gt;#5432&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;完成上一個優化後，我們發現不同的數據庫對事務設置的實現存在差異。例如，要保證事務內同樣的 SQL 查詢返回同樣的結果，將事務隔離級別設置為 Repeatable Read，PostgreSQL 中可以在開啓事務的命令 (START TRANSACTION ISOLATION LEVEL REPEATABLE READ) 中指定當前事務隔離級別，無需額外的交互。&lt;/p&gt; 
&lt;p&gt;而 MySQL 則不能在開啓事務的命令中指定，需要單獨發送命令 (SET TRANSACTION_ISOLATION ...) ，進一步分析後，我們發現不需要在每個事務開始之前就指定事務隔離級別，只需要在連接建立後執行一次即可，從而避免了每次事務開始前重複設置隔離級別。此優化僅作用於 MySQL 元數據，進一步優化了事務處理機制的效率。&lt;/p&gt; 
&lt;p&gt;下面我們來簡單驗證一下效果，以 MySQL 元數據為例，我們通過查看名為 Questions 的全局統計指標（表示客戶端收到網絡交互請求次數）來評估性能。可以通過 show global status 命令來查詢該指標，測試過程為：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;首次查詢 MySQL 中當前的 Questions 統計值&lt;/li&gt; 
 &lt;li&gt;創建 10000 個文件，然後刪除 10000 個文件&lt;/li&gt; 
 &lt;li&gt;再次查詢 MySQL 中當前的 Questions 統計值，計算增量&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;測試腳本如下（僅供參考）：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

/usr/local/mysql/bin/mysql -u jfs -pjfs \
  -e &quot;show global status like &#39;question%&#39;&quot;

for f in {1..10000};
do
    touch testfile_${f}
done
rm -fr testfile_*

/usr/local/mysql/bin/mysql -u jfs -pjfs \
  -e &quot;show global status like &#39;question%&#39;&quot;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;我們通過比較 JuiceFS 1.23 和 1.3 版本下 Questions 指標增量值的差異，同樣的業務邏輯及業務量的壓測下，指標值下降表示有效地減少了網絡交互。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-6950168e2b95f9efc5154ca03a79628b1ea.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;從測試結果可以看出，Questions 指標減少了超過 50%，整體執行時間也縮短了約 30%。由於測試環境中 MySQL 與客戶端部署在同一台機器，採用本地連接，網絡交互優化的效果相對有限。&lt;strong&gt;如果在實際的網絡環境中（即 MySQL 和客戶端分別部署在不同主機），這一優化在執行時間上的提升將更加顯著&lt;/strong&gt;。&lt;/p&gt; 
&lt;h2&gt;03 優化鎖，10 倍提升單目錄多併發性能&lt;/h2&gt; 
&lt;h3&gt;併發處理機制優化（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5460&quot; target=&quot;_blank&quot;&gt;#5460&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;在文件系統中，當創建或刪除一個文件時，需要同時更新其所在目錄的相關重要信息 (比如 NLINK 值)，並保證文件和目錄操作的事務性。由於不同類型的元數據具有不同的事務併發能力，一些 Key-Value 類型的元數據的併發機制並不健壯，因此在 1.3 版本之前，系統統一在客戶端進行目錄級的併發控制，即操作一個文件時，同步鎖定其所在目錄，保證同一時間內同一目錄只能有一個會話進行文件的創建或刪除操作，這導致了大目錄的併發能力比較弱。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;然而以 MySQL/PostgreSQL 為代表的 SQL 元數據有非常強的後端一致性保障能力，可以通過其原生的併發處理機制來提升大目錄的併發性能&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;仍以目錄的 NLINK 屬性為例，在 Key-Value 中進行更新時，由於沒有足夠的後端保障，因此需要掛載點鎖定目錄，查詢取得當前的 NLINK 值，然後加一或減一後再寫回去。但當後端是 MySQL 或 PostgreSQL 時，可以使用 &quot;update ... set NLINK = NLINK + 1 where ...&quot; 這樣的原子操作去維護 NLINK 屬性，就不再需要提前鎖定目錄，從而可以極大地提升大目錄的併發處理能力。&lt;/p&gt; 
&lt;p&gt;經過此優化後，1.3 版本的單目錄併發能力可達之前版本的 10 倍以上。此優化僅對 MySQL 和 PostgreSQL 有效，其他非 SQL 類型的元數據依舊需要現有的客戶端目錄鎖定保護機制。&lt;/p&gt; 
&lt;h3&gt;QUOTA 相關死鎖優化 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5706&quot; target=&quot;_blank&quot;&gt;#5706&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;該問題由社區用戶反饋，開啓 QUOTA 限額功能時，系統會異步逐層向上統計各級目錄的空間使用量，原先的邏輯未考慮到多個目錄的更新順序問題，在 1.3 版本中已經優化和完善邏輯，並且得到該用戶的確認回覆。&lt;/p&gt; 
&lt;p&gt;為了驗證目錄併發度的提升，下面我們使用 JuiceFS 客戶端程序自帶的 mdtest 工具來進行壓測。測試中設置較小的目錄深度，使用較高的併發和較大的單目錄文件數。需要注意的是，此測試對 MySQL 的資源要求會比較高。壓測命令如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./juicefs mdtest META_URL testdir1 --depth=1 --dirs=2 --files=5000 --threads 50 --write 8192
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;不同版本的測試結果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c6feb627003af889573b4d96e474e08c946.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到，1.3 相較於 1.23 版本有一倍以上的提升。由於是本地壓測，並且使用了 50 個併發來測試三個目錄，單目錄的併發壓力不算大，提升效果不算明顯。如果是在網絡環境中，並且使用更高的併發壓測更少的目錄，可以看到更明顯的提升效果。&lt;/p&gt; 
&lt;p&gt;下面我們來測試 100 併發壓測單個目錄的情況，測試命令變更為：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./juicefs mdtest META_URL testdir1 --depth=0 --dirs=1 --files=1000 --threads 100 --write 8192
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-64ad094e470429805c826c08d647755b16d.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到提高併發減少目錄後，1.3 相較於 1.23 的提升效果更明顯。&lt;/p&gt; 
&lt;p&gt;接下來我們來測試元數據跨網絡場景下的效果，測試結果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-b687f93f5fa85427590f038845412ef0067.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;可以看到，在跨網絡的場景下，1.3 版本中單目錄高併發的吞吐是 1.23 版本的 5 倍左右，這時元數據所在機器的 8v CPU 被打滿，如果提升資源規格，可以繼續提升到 10 倍左右。歡迎廣大社區用戶在各自環境中多做壓測並反饋測試結果。&lt;/p&gt; 
&lt;h2&gt;04 連接處理機制優化，靈活配置連接參數提升穩定性&lt;/h2&gt; 
&lt;h3&gt;數據庫連接數控制 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5512&quot; target=&quot;_blank&quot;&gt;#5512&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;由於元數據需要事務支持，一個事務通常包含多個 SQL 請求，只有當所有 SQL 都處理完成後，數據庫連接才能被歸還到連接池。當客戶端的文件操作併發比較高時，可能會創建非常多的數據庫連接。&lt;strong&gt;大量連接和併發請求發送到數據庫後端，可能對元數據服務的穩定性造成壓力。考慮到一個文件系統可能有成百上千個客戶端掛載點，數據庫的連接總數可能會超出可以承受的極限&lt;/strong&gt;。因此，需要限制每個客戶端的數據庫連接數，並根據客戶端數量合理配置數據庫後端。為了應對這個挑戰，JuiceFS 1.3 新增了 4 個 SQL Meta URL 選項，用來控制掛載點到數據庫的連接行為：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;max-open-conns：限制到數據庫的最大連接數&lt;/li&gt; 
 &lt;li&gt;max-idle-conns：最大的空閒連接數，超過將會主動斷開一些連接&lt;/li&gt; 
 &lt;li&gt;max-idle-time：最長的連接空閒等待時間，如果一直和數據庫無交互會主動斷開連接&lt;/li&gt; 
 &lt;li&gt;max-life-time：連接生命週期，同一連接使用過久可能會有資源泄露，銷燬可清理&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Go 語言的數據庫交互 (database/sql) 模塊提供了相關的 API 接口來設置這些特性，允許通過配置而不改動代碼來控制數據庫的連接行為。以 MySQL 元數據為例，我們在 Meta URL 中增加上述參數來控制掛載點到 MySQL 的最大連接數，這個示例中為 10：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;mysql://jfs:jfs@(localhost:3306)/juicefs?max_open_conns=10
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;這裏的 Meta URL 格式就是數據庫連接的 URL，更多的連接參數可以參考各數據庫的 Go 驅動的實現文檔，不同的數據庫選項名稱各不相同，Redis 和 TiKV 也有其特定的選項（可以查閲相關驅動的文檔），可以用同樣的方法來指定。&lt;/p&gt; 
&lt;h3&gt;優化 Dump 連接消耗（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5930&quot; target=&quot;_blank&quot;&gt;#5930&lt;/a&gt;）&lt;/h3&gt; 
&lt;p&gt;Dump 功能可用於在不同元數據引擎之間遷移數據，也是不同的文件系統之間遷移數據的重要手段。為了加快遷移效率，可以設定一個較大的併發線程數。此前，每個線程都會獨佔一個或多個數據庫連接，容易導致線程數超出限制。1.3 版本對此進行了優化，使得在較少的數據庫連接的情況下也能支持較大的併發操作。&lt;/p&gt; 
&lt;p&gt;下面我們使用前面的 mdtest 併發壓測命令來測試連接數控制的效果。我們通過在 META_URL 中加入 max_open_conns 參數，驗證連接數限制的實際效果。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-007c93a79eaf782a701c3058559208c5dfe.png&quot; alt=&quot;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;從上圖可以看到，隨着最大連接數從 5 提升到 20，系統吞吐能力穩步提升，文件創建性能也隨之提高，説明合理配置數據庫連接數有助於釋放後端性能瓶頸，提升整體併發處理能力。&lt;/p&gt; 
&lt;h2&gt;05 緩存處理機制優化：減少元數據查詢操作，提升整體性能 （&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Fpull%2F5540&quot; target=&quot;_blank&quot;&gt;#5540&lt;/a&gt;）&lt;/h2&gt; 
&lt;p&gt;JuiceFS 支持客戶端元數據緩存，可有效地減少對後端元數據的請求，特別是文件屬性相關的緩存，簡稱 Attr Cache，當文件系統中文件數量非常多時，相關的請求量會激增，若緩存缺失或失效，都會給後端帶來瞬間性能衝擊。&lt;/p&gt; 
&lt;p&gt;在 1.3 版本中，我們優化了查找（ Lookup）和更新操作（SetAttr）流程，在進行這兩項操作時，系統會主動用元數據中的最新版本去更新掛載點本地的 Attr Cache，使得後續 GetAttr 請求可以直接從 Attr Cache 命中，既有利於提升文件訪問性能，又可減少數據庫的查詢請求次數，降低元數據的壓力。此優化適用於所有元數據類型，不僅限於 SQL 數據庫。&lt;/p&gt; 
&lt;p&gt;此外，1.3 版本還包含諸如錯誤重試等其他方面的優化，本文不再逐一展開。歡迎大家在實際場景中嘗試使用 SQL 數據庫作為 JuiceFS 的元數據引擎，體驗這些優化帶來的性能提升。&lt;/p&gt; 
&lt;p&gt;歡迎大家下載試用：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fjuicedata%2Fjuicefs%2Freleases%2Ftag%2Fv1.3.0-beta1&quot; target=&quot;_blank&quot;&gt;https://github.com/juicedata/juicefs/releases/tag/v1.3.0-beta1&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;如果過程中有任何問題或建議，歡迎隨時反饋。我們會持續改進！&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/5389802/blog/18225885</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5389802/blog/18225885</guid>
            <pubDate>Sun, 13 Apr 2025 03:04:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>Qt 6.9 正式發佈：Emoji 處理能力升級、性能優化</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Qt 6.9 現已全面推出，為應用開發者和設備製造商帶來諸多新特性與改進！&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;作為亮點之一，升級至 Qt 6.9 可將現有應用的 Emoji 渲染提升至最新標準，支持 Qt Quick 3D 的無序透明渲染（Order Independent Transparency），大幅增強對現代 OAuth2 需求的適配能力，並在全平台設備上新增多項性能優化功能。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;此外，新增的 API 和新功能也全面提高了開發靈活性和工作效率。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心亮點速覽：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1. Qt Graphs: 更強大的可視化效果&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;3D 圖表渲染能力顯著增強，新增對 Surface3D 透明度的支持，引入 QSpline3DSeries 以渲染 3D 樣條數據，並提供更多圖表、座標軸與標籤的自定義選項。現在，將圖表嵌入 Qt Quick 3D 的 View3D 中變得輕而易舉，從而在 3D 場景中實現極具表現力的數據可視化。&lt;/p&gt; 
&lt;p&gt;2D 圖表的輸入處理現已支持靈活自定義，QGraphsView 可配置 plotArea 以精細控制圖表渲染的矩形區域，細化圖形渲染矩形的定位。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;406&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0424/105213_oQWt_2720166.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;請閲讀博客《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fwhats-new-in-qtgraphs-6.9&quot; target=&quot;_blank&quot;&gt;Qt Graphs 6.9 新功能詳解&lt;/a&gt;》，深入瞭解 Qt Graphs 的改進。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2. Emoji 處理能力升級&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Emoji 是全球最流行的書寫系統之一，且其規範持續演進。自 Qt 5.2 添加彩色字體支持以來，Emoji 領域已發生諸多變化，Qt 6.9 正迎頭趕上。&lt;/p&gt; 
&lt;p&gt;Qt 現能自動檢測文本中的 Emoji 序列，並根據 Unicode 規範按需選用正確的彩色字體。開發者可對此過程進行控制：禁用解析、在源碼編譯時完全排除 Emoji 分割器，或通過 QFontDatabase 的新 API 為 Emoji 指定特定的字體系列。目前 Emoji 支持的字體格式包括 CBDT 和 COLRv1，可實現跨平台高質量縮放渲染。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105316_nY0n_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;左：COLRv0，右：COLRv1&lt;/p&gt; 
&lt;p&gt;請閲讀博客，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Femoji-in-qt-6.9&quot; target=&quot;_blank&quot;&gt;縱覽 Emoji 發展史及 Qt 6.9 的支持詳情&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3. 擴展的客戶端區域和安全區域&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;現代桌面和移動設備上應用設計的核心理念是內容至上——應用與系統 UI 元素以非侵入方式無縫融入內容。Qt 6.9 通過 Qt.ExpandedClientAreaHint 窗口標誌及 Qt Quick 的 SafeArea 附加屬性引入新 API，支持此類設計需求。結合使用這些 API，應用內容可充滿整個窗口或屏幕邊緣，同時避開關鍵系統 UI 元素。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105331_FYYq_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;請閲讀博客，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fexpanded-client-areas-and-safe-areas-in-qt-6.9&quot; target=&quot;_blank&quot;&gt;獲取此新功能的更多細節&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4. SVG CSS 動畫&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Qt 的 SVG 模塊現已在 SVG 光柵化為像素圖序列時，支持對顏色、填充、描邊和形變的 CSS 動畫的初步實現。同時，Qt 6.8 中引入了 VectorImage ，藉助 VectorImage，動畫 SVG 現在可以直接渲染到 Qt Quick 場景圖中。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105356_mySo_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;由瀏覽器渲染&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105407_4QH6_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;由 Qt 渲染&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5. 性能優化特性&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;每個 Qt 版本均致力於簡化跨平台設備的性能優化應用開發。除代碼改進外，Qt 6.9 新增對平台或圖形子系統新特性的支持。&lt;/p&gt; 
&lt;p&gt;現代 CPU 架構普遍包含性能核與能效核，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc-snapshots.qt.io%2Fqt6-6.9%2Fqthread.html%23QualityOfService-enum&quot; target=&quot;_blank&quot;&gt;QThread&lt;/a&gt;現在可以設置執行任務時偏好的 CPU 核心類型。&lt;/p&gt; 
&lt;p&gt;在支持 OpenGL 平台上使用&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc-snapshots.qt.io%2Fqt6-6.9%2Fqquickpainteditem.html%23RenderTarget-enum&quot; target=&quot;_blank&quot;&gt;QQuickPaintedItem&lt;/a&gt;的用戶可以再次使用 FramebufferObject 作為渲染模式，從而在硬件加速和命令式繪製階段受益。&lt;/p&gt; 
&lt;p&gt;OpenGL ES RHI 後端在可用時會利用多重採樣渲染擴展，提升現代 GPU 架構上 Qt Quick 與 Qt Quick 3D HMI 的渲染性能。&lt;/p&gt; 
&lt;p&gt;在 Windows 平台上，Direct 3D RHI 後端通過專用的垂直同步監視線程（vblank）驅動刷新，降低 CPU 負載與延遲。顯著改善拖拽等 UI 交互操作的響應速度。&lt;/p&gt; 
&lt;p&gt;除 OpenGL 外，其他 RHI 後端現支持可變速率着色（Variable Rate Shading），為 visionOS 上的 Qt Quick 3D XR 提供動態注視點渲染支持。&lt;/p&gt; 
&lt;p&gt;Qt Quick 新增的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Frectangularshadow-fast-rectangle-shadows-in-qt-6.9&quot; target=&quot;_blank&quot;&gt;RectangularShadow&lt;/a&gt;元素以及 Qt Quick 3D 中陰影貼圖邊界控制的改進，使 UI 開發人員能夠優化陰影和光暈效果的使用，避免高昂計算開銷。&lt;/p&gt; 
&lt;p&gt;使用 Qt 項視圖（Item Views）開發的 Widget 應用程序可以在處理數據頻繁批量變更的模型時進行&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc-snapshots.qt.io%2Fqt6-6.9%2Fqabstractitemview.html%23updateThreshold-prop&quot; target=&quot;_blank&quot;&gt;調優性能&lt;/a&gt;；而且只要禁用段的大小調整（resizeSection）和重新排序，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc-snapshots.qt.io%2Fqt6-6.9%2Fqheaderview.html%23special-consideration-for-huge-models&quot; target=&quot;_blank&quot;&gt;QHeaderView&lt;/a&gt;的內存佔用就會得到顯著優化。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;6. 無序透明渲染（Order Independent Transparency）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Qt Quick 3D 現在支持 &quot;無序透明渲染&quot;（Order Independent Transparency），無需手動按深度排序透明物體即可渲染。雖然這需要一定的計算和內存成本，但可消除因排序不當（尤其是物體交疊時）而導致的視覺錯誤。我們已經在 Qt Graphs 中使用這種技術來渲染半透明表面圖，但其同樣適用於任何模型（包括實例化）。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105427_5shY_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0424/105439_Obju_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Qt 6.9 支持加權混合（Weighted Blended）技術，在成本、性能與精度間實現良好平衡。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;7. 連接功能煥新&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 Qt 6.8 以及 Qt 6.9 中，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.qt.io%2Fqt-6%2Fzh%2Fqtnetworkauth-index.html&quot; target=&quot;_blank&quot;&gt;Qt 網絡授權（Qt Network Authorization）&lt;/a&gt;模塊顯著增強以滿足現代 OAuth2 需求。值得注意的是，它增加了對 &quot;設備授權許可&quot;（Device Authorization Grant）的支持，便於輸入能力受限設備（如電視與 IoT 設備）的用戶認證。引入 OpenID Connect 中獲取 ID 令牌的基礎功能，使應用能訪問用戶身份信息。現在，該模塊允許使用其他瀏覽器用戶代理（包括使用 Qt WebEngine）進行身份驗證，提供更高靈活性。為優化令牌管理，新增訪問令牌臨近過期的信號提醒，並支持自動刷新令牌。此外，該模塊還能區分請求域和授權域，確保應用能基於用戶授權權限精準調整行為。&lt;/p&gt; 
&lt;p&gt;請閲讀&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Frevitalizing-qtnetworkauth-for-modern-oauth2-needs&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，&amp;nbsp;瞭解 Qt Network Authorization 新功能的完整細節。&lt;/p&gt; 
&lt;p&gt;儘管 Qt HTTP Server 設計用於可信環境，我們仍額外強化其安全性。現在可以通過 QHttpServerConfiguration 類型配置傳入請求的最大數量，從而防止 DoS (Denial-of-Service) 攻擊，暴力破解攻擊或爬蟲攻擊。HTTP/2 客戶端可通過 QHttp2Configuration 控制併發流的最大數量。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;8. Qt Quick 開發者體驗&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Qt Quick 開發者將受益於更佳工具支持與新功能。QML 語言服務器現提供大綱視圖，助力 IDE 與編輯器展示 QML 文檔結構的層次化呈現（包括對象、屬性與方法）。&lt;/p&gt; 
&lt;p&gt;新增 ContextMenu 組件，開發者可輕鬆地將上下文菜單附加到項目上（響應右鍵點擊等平台特定事件）。此外，TextField 與 TextArea 現提供默認上下文菜單（除非指定自定義菜單）。&lt;/p&gt; 
&lt;p&gt;最後，OpenXR 新增了 Metal 後端支持，允許應用在 macOS 上的 Meta XR 模擬器中運行。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;9. 升級到 Qt 6.9&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Qt 6.9 在現有 Qt 6.8 LTS 版本基礎上新增諸多改進與特性，保持與所有 Qt 6 版本的二進制與源碼兼容性。經過 Beta 包廣泛測試與大量用戶反饋，我們確信升級至 Qt 6.9 以利用這些改進將順暢無阻。有關新的 API 的完整列表，請參閲我們的&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc-snapshots.qt.io%2Fqt6-dev%2Fwhatsnew69.html&quot; target=&quot;_blank&quot;&gt;文檔&lt;/a&gt;。衷心感謝所有貢獻者！您可以在發佈説明 (&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcode.qt.io%2Fcgit%2Fqt%2Fqtreleasenotes.git%2Fabout%2Fqt%2F6.9.0%2Frelease-note.md&quot; target=&quot;_blank&quot;&gt;https://code.qt.io/cgit/qt/qtreleasenotes.git/about/qt/6.9.0/release-note.md&lt;/a&gt;) 的末尾查看為 Qt 源代碼提供補丁的所有社區成員的完整名單。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;10. 仍在使用 Qt 5？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Qt 5.15 的標準商業支持將於 2025 年 5 月 26 日結束。支持期結束後，該版本將進入 EoS（支持終止）狀態，僅通過 Qt 5.15 擴展安全維護（ESM）等附加服務提供支持。&lt;/p&gt; 
&lt;p&gt;瞭解有關&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI5MzA3NzU3OA%3D%3D%26mid%3D2649668904%26idx%3D2%26sn%3De4fbff40e137197f1929a13eaa88c704%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Qt 5.15 標準支持終止和 ESM&lt;/a&gt;的更多信息。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;11. 在線試用 Qt 6&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;現可通過瀏覽器直接體驗 Qt 6，無需安裝。只需瀏覽&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftry.qt.io%2F&quot; target=&quot;_blank&quot;&gt;try.qt.io&lt;/a&gt;即刻探索！&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;12. 針對 Python 的 Qt 6.9&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;期待 Qt for Python 更新？&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-for-python-release-6.9&quot; target=&quot;_blank&quot;&gt;Qt for Python 6.9 也已發佈&lt;/a&gt;！&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;原文：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FTWVjq768sQukRl6evbFRdQ&quot; target=&quot;_blank&quot;&gt;https://mp.weixin.qq.com/s/TWVjq768sQukRl6evbFRdQ&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/346306/qt-6-9-ga</link>
            <guid isPermaLink="false">https://www.oschina.net/news/346306/qt-6-9-ga</guid>
            <pubDate>Sun, 13 Apr 2025 02:55:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>