<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 19 Jun 2025 12:48:24 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>Roo Code 3.21 發佈，官方 Roo Code Marketplace 上線</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Roo Code 3.21&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdocs.roocode.com%2Fupdate-notes%2Fv3.21.0" target="_blank"&gt;已發佈&lt;/a&gt;&lt;/u&gt;，帶來了官方 Roo Code Marketplace 和 20 多項改進，其中包括對 Gemini 2.5 新模型的支持。&lt;/p&gt; 
&lt;h3&gt;新功能上線&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Roo Marketplace 正式推出&lt;/strong&gt; ：用戶無需實驗特性即可在 Roo Code 內瀏覽、安裝社區創建的模型上下文協議（MCP）服務器和自定義模式，幾下點擊就能輕鬆獲取所需工具。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持最新 Gemini 2.5 模型&lt;/strong&gt; ：增加對 Gemini 2.5 Pro（複雜編程任務增強型）、Gemini 2.5 Flash（性能提升的快速模型）、Gemini 2.5 Flash Lite（適用於快速任務的輕量級模型）的支持，提升各類編程任務的推理能力和性能。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持 Excel 文件處理&lt;/strong&gt; ：允許在工具中讀取 Excel（.xlsx）文件，直接分析和處理 Excel 電子表格，提取單元格值、公式和工作表信息，並且能與現有 Roo Code 工具和功能無縫集成。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;質量改進&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;OpenAI 最大令牌數選項&lt;/strong&gt; ：在 OpenAI 兼容提供程序設置中添加最大令牌數的複選框選項。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;供應商更新&lt;/strong&gt; ：更新 Groq 和 Mistral 的模型列表及價格信息。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;終端細節改進&lt;/strong&gt; ：終端詳情新增當前工作目錄，增強上下文感知能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;多文件差異&lt;/strong&gt; ：鼓勵使用 start_line 參數以匹配舊版差異行為。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;界面與用戶體驗優化&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;市場品牌更新&lt;/strong&gt; ：更新市場品牌標識，使其顯示為 「Roo Marketplace」，保持品牌一致性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;歷史界面重構&lt;/strong&gt; ：重構歷史界面，使其更加一致和現代化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;上下文菜單調整&lt;/strong&gt; ：調整上下文菜單位置，使其靠近 GitHub Copilot，方便訪問。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;面板焦點優化&lt;/strong&gt; ：點擊面板時始終聚焦面板，確保菜單按鈕可見。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;Bug 修復&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;API 會話歷史修復&lt;/strong&gt; ：為會話歷史問題添加適當的錯誤處理機制。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;模型 ID 錯誤消息修復&lt;/strong&gt; ：修正模糊的模型 ID 錯誤消息。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;提示設置保存流程修復&lt;/strong&gt; ：修復提示設置的保存/丟棄/還原流程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;代碼庫索引修復&lt;/strong&gt; ：修正代碼庫索引與列表文件的隱藏目錄過濾對齊問題。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;子任務完成修復&lt;/strong&gt; ：解決子任務與整體任務完成之間的不匹配問題。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Windows MCP 配置修復&lt;/strong&gt; ：修復 Windows 上 MCP 變量注入的路徑標準化問題。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;其他改進&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;測試模式更新&lt;/strong&gt; ：更新測試模式以支持 Vitest 測試框架。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;工作目錄警告移除&lt;/strong&gt; ：移除關於工作目錄更改的不必要警告。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;遙測添加&lt;/strong&gt; ：添加市場標籤視圖和安裝點擊跟蹤的遙測功能。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Windows Docker 更新&lt;/strong&gt; ：更新評估 Docker 設置，使其在 Windows 上可以正常運行。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳情查看 https://docs.roocode.com/update-notes/v3.21.0&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356236/roocode-3-21</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356236/roocode-3-21</guid>
      <pubDate>Sun, 11 May 2025 10:38:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>馬斯克駁斥 xAI 鉅額虧損傳聞：每月燒錢 10 億美元純屬無稽之談</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;有媒體報道稱，科技巨頭埃隆・馬斯克創辦的人工智能初創公司 xAI 每月燒錢高達 10 億美元，這一説法引發了廣泛關注。消息稱，xAI 在構建先進的 AI 模型方面的成本遠遠超過其收入增長，公司的資金需求愈加迫切。對此，馬斯克進行了強烈反駁，稱這些報道 「純屬胡説八道」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="330" src="https://oscimg.oschina.net/oscnet/up-34a4735e7445256b266cb4625e29a62693a.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;xAI 自 2023 年成立以來，正積極尋求通過債務和股權融資來填補資金缺口，目標是融資 93 億美元。儘管如此，馬斯克合併了 xAI 與社交媒體平台 X，令合併後的新公司的估值達 1130 億美元，其中 xAI 的估值為 800 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;根據相關人士透露，xAI 的支出速度在整個 AI 行業中顯得尤為顯著。公司預計在未來三個月內將花費超過一半的融資金額，而全年虧損預計達到 130 億美元。相比之下，競爭對手 OpenAI 預計在 2025 年的收入將達到 127 億美元，而 xAI 在同年僅預計收入 5 億美元，明年才有可能突破 20 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;馬斯克的巨大個人魅力和資源，使得 xAI 有理由保持樂觀。他曾在特斯拉和 SpaceX 的早期階段也經歷了類似的鉅額虧損，然而這些項目最終都取得了成功。馬斯克相信，xAI 將在 2027 年實現盈利，儘管當前仍需與時間賽跑，以應對鉅額支出。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;xAI 計劃利用與 X 平台的整合，利用其龐大的數據檔案來訓練 AI 模型，從而降低昂貴的數據費用。雖然目前 xAI 正在進行大規模的資金籌集，但公司對於未來的發展前景充滿信心。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356227</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356227</guid>
      <pubDate>Sun, 11 May 2025 10:07:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>MoonBit 編程語言 Beta 版正式發佈！</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;div&gt; 
 &lt;p&gt;MoonBit 編程語言已於今日正式發佈 Beta 版本。作為一門專注於工具鏈構建（特別是 AI 場景）與開發者體驗的新一代編程語言，MoonBit 由 IDEA 研究院主導開發，自設計之初便強調結構化、類型安全與高性能可視化調試。&lt;/p&gt; 
 &lt;div&gt;
  目前，MoonBit 已支持 WebAssembly、JavaScript 與原生後端（native)。功能上，它接近 Rust，但內置垃圾回收（GC），並配套高效、健壯的工具鏈，顯著提升開發效率。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  對於希望體驗語言特性的用戶，MoonBit 官方推出了交互式入門平台 
  &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftour.moonbitlang.com%2F" target="_blank"&gt;MoonBit Tour&lt;/a&gt;，提供內嵌值追蹤、即時運行和語法提示等功能，幫助開發者快速上手。
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;Beta 階段的含義&lt;/h2&gt; 
 &lt;div&gt;
  據 MoonBit 團隊介紹，過去兩年中，MoonBit 經歷了快速迭代與大量實驗，語言特性在實踐與反饋中逐步沉澱，現已進入穩定階段。此次 Beta 發佈意味着：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    語言已覆蓋日常開發所需的關鍵能力
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    語法層面已趨穩定，後續改動將遵循公開的 RFC 提案流程
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  雖然語言本身已趨穩定，標準庫與工具鏈仍將持續演進。目前，MoonBit 團隊正對包命名、模塊結構進行整理與優化，以提升語言一致性與可維護性。接下來，團隊將重點投入在官方文檔完善、包生態擴展與社區協作機制上。
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;異步與錯誤處理：Beta 中的重要特性&lt;/h2&gt; 
 &lt;div&gt;
  MoonBit 在 Beta 階段即提供內建的異步機制與靜態檢查的錯誤處理模型，這一設計區別於多數語言在正式版之後才補充異步語義的做法。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  該模型具有以下特性：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;安全性&lt;/strong&gt;：所有錯誤傳遞均由編譯器靜態檢查
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;簡潔性&lt;/strong&gt;：異步函數與常規函數寫法一致，無需 
    &lt;code&gt;await&lt;/code&gt; 或其他語法糖
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    &lt;strong&gt;可讀性&lt;/strong&gt;：IDE 對異步與可能出錯的操作進行可視化標註，開發者無需顯式聲明（例如，錯誤操作帶下劃線，異步操作為斜體）
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  官方示例中展示了一個用 MoonBit 編寫的簡化版 
  &lt;code&gt;cat&lt;/code&gt; 命令，結合了多個異步數據源與錯誤路徑，代碼依然保持清晰簡潔，體現了語言在可維護性與表現力上的優勢。
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt;
  &lt;img src="https://oscimg.oschina.net/oscnet//80457b66b57b131122f2c0fa278ca618.jpg" referrerpolicy="no-referrer"&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;hr&gt;
 &lt;/div&gt; 
 &lt;h2&gt;發展路線與社區協作&lt;/h2&gt; 
 &lt;div&gt;
  MoonBit 項目當前正朝着 1.0 穩步推進，預計將在 2026 年發佈正式版本。團隊承諾，自 Beta 起，所有語言層級的重要變更都將通過公開的 RFC（Request for Comments）流程，確保透明度與社區參與。
 &lt;/div&gt; 
 &lt;div&gt;
  社區開發者可通過以下方式參與語言建設：
 &lt;/div&gt; 
 &lt;ul&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    🐛 
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2Fcore%2Fissues" target="_blank"&gt;提交 bug 報告或改進建議&lt;/a&gt;
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    💬 加入 Discord 社區參與討論
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    📄 關注並參與
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fmoonbitlang%2Fmoonbit-RFCs" target="_blank"&gt; RFC &lt;/a&gt;提案流程
   &lt;/div&gt; &lt;/li&gt; 
  &lt;li&gt; 
   &lt;div&gt;
    📦 為官方包註冊平台 
    &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmooncakes.io" target="_blank"&gt;mooncakes.io&lt;/a&gt; 貢獻組件或庫
   &lt;/div&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;div&gt;
  MoonBit 的成長離不開每一位社區成員的參與與反饋。團隊表示，期待更多開發者加入 GitHub 與 Discord，共同探索麪向未來的編程語言新範式。
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356224/moonbitlang-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356224/moonbitlang-beta</guid>
      <pubDate>Sun, 11 May 2025 09:51:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>Spring Boot 啓動優化實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互聯網服務器團隊- Liu Di&lt;/p&gt; 
 &lt;p&gt;本文系統性分析並優化了一個 Spring Boot 項目啓動耗時高達 280 秒的問題。通過識別瓶頸、優化分庫分表加載邏輯、異步初始化耗時任務等手段，最終將啓動耗時縮短至 159 秒，提升近 50%。文章涵蓋啓動流程分析、性能熱點識別、異步初始化設計等關鍵技術細節，適用於大型 Spring Boot 項目的性能優化參考。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;文章太長？1 分鐘看圖抓住核心觀點👇&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//de4a19ad8ae5ee03f930e1ffa71b9716.gif" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h1&gt;一、前言&lt;/h1&gt; 
&lt;p&gt;隨着業務的發展，筆者項目對應的 Spring Boot 工程的依賴越來越多。隨着依賴數量的增長，Spring 容器需要加載更多組件、解析複雜依賴並執行自動裝配，導致項目啓動時間顯著增長。在日常開發或測試過程中，一旦因為配置變更或者其他熱部署不生效的變更時，項目重啓就需要等待很長的時間影響代碼的交付。加快 Spring 項目的啓動可以更好的投入項目中，提升開發效率。&lt;/p&gt; 
&lt;p&gt;整體環境介紹：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;Spring 版本：4.3.22&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Spring Boot 版本：1.5.19&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;CPU：i5-9500&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;內存：24GB&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;優化前啓動耗時：280 秒&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;二、Spring Boot 項目啓動流程介紹&lt;/h1&gt; 
&lt;p&gt;Spring Boot 項目主要啓動流程都在 org.spring-&lt;/p&gt; 
&lt;p&gt;framework.boot.SpringApplication#run(java.lang.String...) 方法中：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public ConfigurableApplicationContext run(String... args) {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    // Spring 上下文
    ConfigurableApplicationContext context = null;
    FailureAnalyzers analyzers = null;
    configureHeadlessProperty();
    // 初始化 SpringApplicationRunListener 監聽器
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();
    try {
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(
                args);
        // 環境準備
        ConfigurableEnvironment environment = prepareEnvironment(listeners,
                applicationArguments);
         // 打印 banner
        Banner printedBanner = printBanner(environment);
        // 創建上下文
        context = createApplicationContext();
        analyzers = new FailureAnalyzers(context);
        // 容器初始化
        prepareContext(context, environment, listeners, applicationArguments,
                printedBanner);
        // 刷新容器內容
        refreshContext(context);
        afterRefresh(context, applicationArguments);
        // 結束監聽廣播
        listeners.finished(context, null);
        stopWatch.stop();
        if (this.logStartupInfo) {
            new StartupInfoLogger(this.mainApplicationClass)
                    .logStarted(getApplicationLog(), stopWatch);
        }
        return context;
    } catch (Throwable ex) {
        handleRunFailure(context, listeners, analyzers, ex);
        throw new IllegalStateException(ex);
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到在啓動流程中，監聽器應用在了應用的多個生命週期中。並且 Spring Boot 中也預留了針對 listener 的擴展點。我們可以藉此實現一個自己的擴展點去監聽 Spring Boot 的每個階段的啓動耗時，實現如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Slf4j
public class MySpringApplicationRunListener implements SpringApplicationRunListener{
    private Long startTime;
    public MySpringApplicationRunListener(SpringApplication application, String[] args){
    }
    @Override
    public void starting(){
        startTime = System.currentTimeMillis();
        log.info("MySpringListener 啓動開始 {}", LocalTime.now());
    }
    @Override
    public void environmentPrepared(ConfigurableEnvironment environment){
        log.info("MySpringListener 環境準備，準備耗時：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
    @Override
    public void contextPrepared(ConfigurableApplicationContext context){
        log.info("MySpringListener 上下文準備，耗時：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
    @Override
    public void contextLoaded(ConfigurableApplicationContext context){
        log.info("MySpringListener 上下文載入，耗時：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
   @Override
   public void finished(ConfigurableApplicationContext context, Throwable exception){
        log.info("MySpringListener 結束，耗時：{}毫秒", (System.currentTimeMillis() - startTime));
        startTime = System.currentTimeMillis();
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;接着還需要在 classpath/META-INF 目錄下新建 spring.factories 文件，並添加如下文件內容：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;org.springframework.boot.SpringApplicationRunListener=com.vivo.internet.gameactivity.api.web.MySpringApplicationRunListener
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;至此，藉助 Listener 機制，我們能夠追蹤 Spring Boot 啓動各階段的耗時分佈，為後續性能優化提供數據支撐。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//e19075cd485d32e7d5029945fd7ba604.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;contextLoaded 事件是在 run 方法中的 prepareContext() 結束時調用的，因此 contextLoaded 事件和 finished 事件之間僅存在兩個語句：refreshContext(context) 和 afterRefresh&lt;/p&gt; 
&lt;p&gt;(context,applicationArguements) 消耗了 285 秒的時間，調試一下就能發現主要耗時在 refreshContext() 中。&lt;/p&gt; 
&lt;h1&gt;三、AbstractApplicationContext#refresh&lt;/h1&gt; 
&lt;p&gt;refreshContext() 最終調用到 org.spring-framework.context.support.AbstractApplicationContext#refresh 方法中，這個方法主要是 beanFactory 的預準備、對 beanFactory 完成創建並進行後置處理、向容器添加 bean 並且給 bean 添加屬性、實例化所有 bean。通過調試發現，finishBeanFactoryInitialization(beanFactory) 方法耗時最久。該方法負責實例化容器中所有的單例 Bean，是啓動性能的關鍵影響點。&lt;/p&gt; 
&lt;h1&gt;四、找出實例化耗時的 Bean&lt;/h1&gt; 
&lt;p&gt;Spring Boot 也是利用的 Spring 的加載流程。在 Spring 中可以實現 InstantiationAwareBeanPost-&lt;/p&gt; 
&lt;p&gt;Processor 接口去在 Bean 的實例化和初始化的過程中加入擴展點。因此我們可以實現該接口並添加自己的擴展點找到處理耗時的 Bean。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Service
public class TimeCostCalBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
    private Map&amp;lt;String, Long&amp;gt; costMap = Maps.newConcurrentMap();

    @Override
    public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        if (!costMap.containsKey(beanName)) {
            costMap.put(beanName, System.currentTimeMillis());
        }
        return null;
    }
    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        return true;
    }
    @Override
    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
        return pvs;
    }
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
         if (costMap.containsKey(beanName)) {
            Long start = costMap.get(beanName);
            long cost = System.currentTimeMillis() - start;
            // 只打印耗時長的 bean
             if (cost &amp;gt; 5000) {
                System.out.println("bean: " + beanName + "\ttime: " + cost + "ms");
            }
        }
         return bean;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具體原理就是在 Bean 開始實例化之前記錄時間，在 Bean 初始化完成後記錄結束時間，打印實例化到初始化的時間差獲得 Bean 的加載總體耗時。結果如圖：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//28a73a7adfed28c5eff40855c8260121.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;可以看到有許多耗時在 10 秒以上的類，接下來可以針對性的做優化。值得注意的是，統計方式為單點耗時計算，未考慮依賴鏈上下文對整體加載順序的影響，實際優化還需結合依賴關係分析。&lt;/p&gt; 
&lt;h1&gt;五、singletonDataSource&lt;/h1&gt; 
&lt;pre&gt;&lt;code&gt;@Bean(name = "singletonDataSource")
public DataSource singletonDataSource(DefaultDataSourceWrapper dataSourceWrapper) throws SQLException {
    //先初始化連接
    dataSourceWrapper.getMaster().init();
    //構建分庫分表數據源
    String dataSource0 = "ds0";
    Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;();
    dataSourceMap.put(dataSource0, dataSourceWrapper.getMaster());
    //分庫分表數據源
    DataSource shardingDataSource = ShardingDataSourceFactory.createDataSource
    (dataSourceMap,shardingRuleConfiguration, prop);
    return shardingDataSource;    
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;singletonDataSource 是一個分庫分表的數據源，連接池採用的是 Druid，分庫分表組件採用的是公司內部優化後的中間件。通過簡單調試代碼發現，整個 Bean 耗時的過程發生在 createDataSource 方法，該方法中會調用 createMetaData 方法去獲取數據表的元數據，最終運行到 loadDefaultTables 方法。該方法如下圖，會遍歷數據庫中所有的表。因此數據庫中表越多，整體就越耗時。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//05283b802a6c9c0a6c8653f9a7f080cd.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;筆者的測試環境數據庫中有很多的分表，這些分表為了和線上保持一致，分表的數量都和線上是一樣的。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//eee1a3f0f0dd73861b2894776a40850b.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;因此在測試環境啓動時，為了加載這些分表會更加的耗時。可通過將分表數量配置化，使測試環境在不影響功能驗證的前提下減少分表數量，從而加快啓動速度。&lt;/p&gt; 
&lt;h1&gt;六、初始化異步&lt;/h1&gt; 
&lt;p&gt;activityServiceImpl 啓動中，主要會進行活動信息的查詢初始化，這是一個耗時的操作。類似同樣的操作在工程的其他類中也存在。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;@Service
public class ActivityServiceImpl implements ActivityService, InitializingBean{
     // 省略無關代碼
     @Override
     public void afterPropertiesSet() throws Exception {
        initActivity();
    }
     // 省略無關代碼
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以通過將 afterPropertiesSet() 異步化的方式加速項目的啓動。&lt;/p&gt; 
&lt;p&gt;觀察 Spring 源碼可以注意到 afterPropertiesSet 方法是在 AbstractAutowireCapableBeanFactory#&lt;/p&gt; 
&lt;p&gt;invokeInitMethods 中調用的。在這個方法中，不光處理了 afterPropertiesSet 方法，也處理了 init-method。&lt;/p&gt; 
&lt;p&gt;因此我們可以寫一個自己的 BeanFactory 繼承 AbstractAutowireCapableBeanFactory，將 invokeInitMethods 方法進行異步化重寫。考慮到 AbstractAutowireCapableBeanFactory 是個抽象類，有額外的抽象方法需要實現，因此繼承該抽象類的子類 DefaultListableBeanFactory。具體實現代碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncInitListableBeanFactory extends DefaultListableBeanFactory{
     public AsyncInitBeanFactory(ConfigurableListableBeanFactory beanFactory){
         super(beanFactory);
    }
     @Override
     protected void invokeInitMethods(String beanName, Object bean, RootBeanDefinition mbd)throws Throwable {
        if (beanName.equals("activityServiceImpl")) {
            AsyncTaskExecutor.submitTask(() -&amp;gt; {
                try {
                      super.invokeInitMethods(beanName, bean, mbd);
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }
            });
        } else {
              super.invokeInitMethods(beanName, bean, mbd);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;又因為 Spring 在 refreshContext() 方法之前的 prepareContext() 發放中針對 initialize 方法提供了接口擴展 (applyInitializers())。因此我們可以通過實現該接口並將我們的新的 BeanFactory 通過反射的方式更新到 Spring 的初始化流程之前。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public interface ApplicationContextInitializer&amp;lt;C extends ConfigurableApplicationContext&amp;gt; {
     /**
     * Initialize the given application context.
     * @param applicationContext the application to configure
     */
    void initialize(C applicationContext);

}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;改造後的代碼如下，新增 AsyncAccelerate-&lt;/p&gt; 
&lt;p&gt;Initializer 類實現 ApplicationContextInitializer 接口：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncBeanFactoryInitializer implements ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt; {
    @SneakyThrows
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext){
        if (applicationContext instanceof GenericApplicationContext) {
            AsyncInitListableBeanFactory beanFactory = new AsyncInitListableBeanFactory(applicationContext.getBeanFactory());
            Field field = GenericApplicationContext.class.getDeclaredField("beanFactory");
            field.setAccessible(true);
            field.set(applicationContext, beanFactory);
        }
    }
}
public class AsyncBeanInitExecutor{
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final AtomicReference&amp;lt;ThreadPoolExecutor&amp;gt; THREAD_POOL_REF = new AtomicReference&amp;lt;&amp;gt;();
    private static final List&amp;lt;Future&amp;lt;?&amp;gt;&amp;gt; FUTURES = new ArrayList&amp;lt;&amp;gt;();
     /**
      * 創建線程池實例
      */
     private static ThreadPoolExecutor createThreadPoolExecutor(){
         int poolSize = CPU_COUNT + 1;
         return new ThreadPoolExecutor(poolSize, poolSize, 50L, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;&amp;gt;(), new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
    /**
     * 確保線程池已初始化（線程安全）
     */
     private static void ensureThreadPoolExists(){
         if (THREAD_POOL_REF.get() != null) {
              return;
        }
        ThreadPoolExecutor executor = createThreadPoolExecutor();
         if (!THREAD_POOL_REF.compareAndSet(null, executor)) {
            executor.shutdown(); // 另一線程已初始化成功
        }
    }
    /**
     * 提交異步初始化任務
     *
     * @param task 初始化任務
     * @return 提交後的 Future 對象
     */
    public static Future&amp;lt;?&amp;gt; submitInitTask(Runnable task) {
        ensureThreadPoolExists();
        Future&amp;lt;?&amp;gt; future = THREAD_POOL_REF.get().submit(task);
        FUTURES.add(future);
        return future;
    }
    /**
     * 等待所有初始化任務完成並釋放資源
     */
    public static void waitForInitTasks(){
        try {
            for (Future&amp;lt;?&amp;gt; future : FUTURES) {
                future.get();
            }
        } catch (Exception ex) {
            throw new RuntimeException("Async init task failed", ex);
        } finally {
            FUTURES.clear();
            shutdownThreadPool();
        }
    }
     /**
     * 關閉線程池並重置引用
     */
     private static void shutdownThreadPool(){
        ThreadPoolExecutor executor = THREAD_POOL_REF.getAndSet(null);
         if (executor != null) {
            executor.shutdown();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;實現類後，還需要在 META-INF/spring.factories 下新增説明 org.springframework.context.&lt;/p&gt; 
&lt;p&gt;ApplicationContextInitializer=com.xxx.AsyncAccelerateInitializer，這樣這個類才能真正生效。&lt;/p&gt; 
&lt;p&gt;這樣異步化以後還有一個點需要注意，如果該初始化方法執行耗時很長，那麼會存在 Spring 容器已經啓動完成，但是異步初始化任務沒執行完的情況，可能會導致空指針等異常。為了避免這種問題的發生，還要藉助於 Spring 容器啓動中 finishRefresh() 方法，監聽對應事件，確保異步任務執行完成之後，再啓動容器。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public class AsyncInitCompletionListener implements ApplicationListener&amp;lt;ContextRefreshedEvent&amp;gt;, ApplicationContextAware, PriorityOrdered{
    private ApplicationContext currentContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext)throws BeansException {
         this.currentContext = applicationContext;
    }
    @Override
    public void onApplicationEvent(ContextRefreshedEvent event){
        if (event.getApplicationContext() == currentContext) {
            AsyncBeanInitExecutor.waitForInitTasks();
        }
    }
    @Override
    public int getOrder(){
         return Ordered.HIGHEST_PRECEDENCE;
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h1&gt;七、總結&lt;/h1&gt; 
&lt;p&gt;啓動優化後的項目實際測試結果如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet//2f535724d8b21204e9e881711c6acf6f.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;通過異步化初始化和分庫分表加載優化，項目啓動時間從 280 秒縮短至 159 秒，提升約 50%。這對於提升日常開發效率、加快測試與聯調流程具有重要意義。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/vivotech/blog/18627678</link>
      <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18627678</guid>
      <pubDate>Sun, 11 May 2025 09:43:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Workout.cool —— 現代開源健身教練平台</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;一個全面的健身指導平台，可以為你制定鍛鍊計劃、跟蹤進度並訪問包含詳細説明和視頻演示的龐大鍛鍊數據庫。&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;項目包含一個全面的練習數據庫。要導入練習樣本，請執行以下操作：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;導入的先決條件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;準備 CSV 文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;你的 CSV 應該包含以下列：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;id,name,name_en,description,description_en,full_video_url,full_video_image_url,introduction,introduction_en,slug,slug_en,attribute_name,attribute_value
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可以使用提供的示例。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;導入命令&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;#&lt;/span&gt;&lt;/span&gt; Import exercises from a CSV file&lt;/span&gt;&lt;/span&gt;
pnpm run import:exercises-full /path/to/your/exercises.csv

&lt;span&gt;&lt;span style="color:#59636e"&gt;&lt;span&gt;&lt;span style="color:#59636e"&gt;#&lt;/span&gt;&lt;/span&gt; Example with the provided sample data&lt;/span&gt;&lt;/span&gt;
pnpm run import:exercises-full ./data/sample-exercises.csv&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CSV 格式示例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span style="background-color:#f6f8fa"&gt;&lt;code&gt;id,name,name_en,description,description_en,full_video_url,full_video_image_url,introduction,introduction_en,slug,slug_en,attribute_name,attribute_value
157,"Fentes arrières à la barre","Barbell Reverse Lunges","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;",https://youtube.com/...,https://img.youtube.com/...,slug-fr,slug-en,TYPE,STRENGTH
157,"Fentes arrières à la barre","Barbell Reverse Lunges","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;","&amp;lt;p&amp;gt;Stand upright...&amp;lt;/p&amp;gt;",https://youtube.com/...,https://img.youtube.com/...,slug-fr,slug-en,PRIMARY_MUSCLE,QUADRICEPS&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div style="text-align:start"&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;可用的屬性類型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TYPE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;STRENGTH&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;CARDIO&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;PLYOMETRICS&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;STRETCHING&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRIMARY_MUSCLE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;QUADRICEPS&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;CHEST&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BACK&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;SHOULDERS&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SECONDARY_MUSCLE&lt;/strong&gt;: Secondary muscle groups targeted&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EQUIPMENT&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BARBELL&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;DUMBBELL&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;BODYWEIGHT&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;MACHINE&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MECHANICS_TYPE&lt;/strong&gt;:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;COMPOUND&lt;/code&gt;,&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;ISOLATION&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/workout-cool</link>
      <guid isPermaLink="false">https://www.oschina.net/p/workout-cool</guid>
      <pubDate>Sun, 11 May 2025 08:20:00 GMT</pubDate>
    </item>
    <item>
      <title>MoonBit 正式進入 Beta 版本，邁入語言穩定階段</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;IDEA 研究院編程語言 MoonBit &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fblog%2Fbeta-release" target="_blank"&gt;宣佈推出 Beta 版本&lt;/a&gt;，正式邁入可落地應用的新階段，並逐步演進為&lt;strong&gt;可被實際部署的基礎設施技術。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-fb44018fd10f40a81f0db905688512c73fa.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;進入 Beta 版本的 MoonBit，具備以下優勢特性：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;語言特性進入穩定期&lt;/strong&gt;：目前 MoonBit 已覆蓋工業級開發所需的語言特性與工具鏈支持。現有語法和語義將保持向後兼容，未來的更新將盡量避免破壞性修改。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;改進流程更標準化&lt;/strong&gt;：語言層面的進一步優化將通過公開、透明的 RFC 流程與社區共同討論，確保演進方向清晰、穩定、可協作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;異步支持三大優勢&lt;/strong&gt;：MoonBit 在語言層面提供了錯誤處理與異步編程的支持。MoonBit 對錯誤處理和異步編程的支持有三大優勢。 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;大部分編程語言在靜態分析中，徹底放棄錯誤處理的支持，這意味着任何函數都可以拋出異常，很難寫出高可靠性的代碼，MoonBit 通過準確的控制流分析，可以完全在編譯時期跟蹤函數的錯誤，用戶只需要在頂層標記用作文檔的簽名。這一過程幾乎完全由編譯器自行推導，而又不像 Java checked exception 那樣過於繁瑣，對用戶帶來較高的心智負擔；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;編寫便捷性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;在 MoonBit 中，帶有錯誤和異步操作的函數使用起來就像普通函數一樣便利，無需任何特殊標記，也無需修改程序結構；&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;&lt;strong&gt;可讀性&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;MoonBit IDE 會給帶錯誤的函數標註「下劃線」、並將異步函數標記為「&lt;em&gt;斜體&lt;/em&gt;」。用戶在編寫代碼時無需寫任何特殊標註，但依然能在閲讀代碼時快速定位到帶有錯誤/異步的關鍵操作。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Beta 版：工具鏈打磨與語言層面深度融合&lt;/strong&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fblog%2Fbeta-release%23beta-%25E7%2589%2588%25E5%25B7%25A5%25E5%2585%25B7%25E9%2593%25BE%25E6%2589%2593%25E7%25A3%25A8%25E4%25B8%258E%25E8%25AF%25AD%25E8%25A8%2580%25E5%25B1%2582%25E9%259D%25A2%25E6%25B7%25B1%25E5%25BA%25A6%25E8%259E%258D%25E5%2590%2588" target="_blank"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;作為最早支持 WebAssembly 的編程語言之一，MoonBit 天然契合&lt;strong&gt;高性能、低延遲、跨平台&lt;/strong&gt;的分佈式系統開發需求。在瀏覽器、邊緣節點和輕量微服務等場景中，MoonBit 可通過 Wasm 實現快速部署與高度可移植性，同時保持極低運行時開銷，為「&lt;strong&gt;一次編寫，任意運行&lt;/strong&gt;」的開發模式提供了切實可行的路徑。&lt;/p&gt; 
&lt;p&gt;更重要的是，MoonBit 還帶來了具備「&lt;strong&gt;修改即響應&lt;/strong&gt;」特性的即時反饋開發體驗。開發者可直接在 Web 環境中編寫、運行與調試代碼，極大提升開發效率。這種體驗目前在主流語言體系中仍屬稀缺，也正是 MoonBit 在工具鏈打磨與語言層面深度融合下取得的重要成果。&lt;/p&gt; 
&lt;p&gt;下面是一個著名命令行程序&lt;code&gt;cat&lt;/code&gt;的簡單版的 MoonBit 實現。這段程序包含了對多個不同來源操作的錯誤處理、異步操作等，實際控制流非常複雜。但在 MoonBit 中，這段程序編寫起來非常自然簡潔，沒有任何語法噪音。同時，得益於語法着色，閲讀代碼時很容易捕捉到幾處異步/帶錯誤的關鍵操作。&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;async fn cat(files : ArrayView[String]) -&amp;gt; Unit raise {
  if files is [] {
    @async.stdin.read_streaming() // read from stdin only once
  } else {
    for file in files {
      if file is "-" {
        @async.stdin.read_streaming() // read from stdin
        continue
      } else {
        @async.path(file).read_all()
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;下載地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.moonbitlang.cn%2Fdownload%2F" target="_blank"&gt;https://www.moonbitlang.cn/download/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;在線使用：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftry.moonbitlang.cn%2F" target="_blank"&gt;https://try.moonbitlang.cn/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356201/moonbit-language-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356201/moonbit-language-beta</guid>
      <pubDate>Sun, 11 May 2025 07:53:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenBMB 開源輕量級 CUDA 推理框架 CPM.cu</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;OpenBMB 推出了 CPM.cu，這是一個輕量級且高效的開源 CUDA 推理框架，專為端側大型語言模型（LLMs）的部署而設計，併為&lt;a href="https://www.oschina.net/news/354328"&gt;MiniCPM4&lt;/a&gt;提供優化，核心支持&lt;strong&gt;稀疏架構&lt;/strong&gt;、&lt;strong&gt;投機採樣&lt;/strong&gt;和&lt;strong&gt;低位寬量化&lt;/strong&gt;等前沿技術創新。&lt;/p&gt; 
&lt;p&gt;CPM.cu 亮點包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;集成了 InfLLM v2 可訓練稀疏注意力內核，可加速長上下文預填充和解碼；&lt;/li&gt; 
 &lt;li&gt;FR-Spec（頻率排序推測採樣）通過壓縮詞彙空間提高草稿效率，顯著降低計算開銷；&lt;/li&gt; 
 &lt;li&gt;結合了 EAGLE-2 推測採樣、4 位量化和基於滑動窗口注意力的長上下文支持，從而在資源受限設備上實現高效部署。&lt;/li&gt; 
 &lt;li&gt;性能方面，在 128K-token 序列上，預填充速度比 Qwen3-8B 快 2-4 倍，解碼速度快 4-6 倍。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;CPM.cu&amp;nbsp; 框架結構：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;CPM.cu/
├── src/
│   ├── flash_attn/ # 修改後的 Flash-Attention, 支持稀疏和投機採樣
│   ├── model/
│   │   ├── minicpm4/ # minicpm4 模型
│   │   │   ├── minicpm4_model.cuh # 模型的核心實現
│   │   │   └── minicpm4_eagle.cuh # 投機採樣實現
│   │   ├── model.cuh # 其他代表性模型
│   │   ├── w4a16_gptq_marlin/ # GPTQ 量化計算 kernel
│   │   ├── memory.cuh # 顯存分配
│   │   └── layer.cuh # 通用層
│   ├── entry.cu # pybind: 連接 C/CUDA 和 Python
│   └── ...
├── cpmcu/ # python interface
└── ...&lt;/code&gt;&lt;/pre&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;cpmcu/ 代碼提供了一個 python 的調用接口，裏面涉及在 Python 側 tokenize，調用 C 代碼得到模型的輸出 logits，在 Python 側根據 logits 採樣並 detokenize 這些過程。我們使用了 pybind 將 C 代碼與 Python 代碼進行綁定。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/memory.cuh 這裏實現了整個推理框架的內存管理，這裏我們採用了先分配模型權重，再分配模型中間計算結果所需的空間，最後把所有剩餘顯存分配給 kv-cache 的內存管理策略。這一點設計上是和 vLLM, SGLang 類似的。分配中間計算結果的空間時可以考慮一下中間計算結果的生命週期，做一點顯存複用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/w4a16_gptq_marlin/ 量化的計算 kernel。這裏直接使用了 vLLM 的 Marlin 代碼。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/model/minicpm4/ 這裏是模型的架構實現。src/model/下也有其他代表性模型實現。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;src/flash_attn/ 我們基於 flash_attn 2.6.3 版本，在上面增加了對 InfLLM v2、投機採樣的適配支持。下面我們主要介紹這一部分，也是整個框架實現的難點。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;開源地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FOpenBMB%2FCPM.cu" target="_blank"&gt;https://github.com/OpenBMB/CPM.cu&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356197</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356197</guid>
      <pubDate>Sun, 11 May 2025 07:41:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源模型上下文協議 MCP 更新規範文檔，添加對結構化工具輸出的支持</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源模型上下文協議 MCP 昨天更新了規範文檔，主要變更如下：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;移除對 JSON-RPC 批處理的支持（PR #416）&lt;/li&gt; 
 &lt;li&gt;添加對結構化工具輸出的支持（PR #371）&lt;/li&gt; 
 &lt;li&gt;將 MCP 服務器歸類為 OAuth 資源服務器，添加受保護資源元數據以發現相應的授權服務器。（PR #338）&lt;/li&gt; 
 &lt;li&gt;要求 MCP 客戶端按照 RFC 8707 中描述的方式實現資源指示器，以防止惡意服務器獲取訪問令牌。（PR #734）&lt;/li&gt; 
 &lt;li&gt;在授權規範中闡明安全注意事項和最佳實踐，並在新的安全最佳實踐頁面中説明。&lt;/li&gt; 
 &lt;li&gt;增加引導支持，使服務器能夠在交互過程中向用戶請求更多信息。（PR #382）&lt;/li&gt; 
 &lt;li&gt;在工具調用結果中增加資源鏈接支持。（PR #603）&lt;/li&gt; 
 &lt;li&gt;在使用 HTTP 時，後續請求中需通過&amp;nbsp;&lt;code&gt;MCP-Protocol-Version&lt;/code&gt;&amp;nbsp;頭指定協商的協議版本。（PR #548）&lt;/li&gt; 
 &lt;li&gt;將生命週期操作中的 SHOULD 改為 MUST&lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;詳情查看&amp;nbsp;&lt;em&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmodelcontextprotocol.io%2Fspecification%2F2025-06-18%2Fchangelog" target="_blank"&gt;https://modelcontextprotocol.io/specification/2025-06-18/changelog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356195</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356195</guid>
      <pubDate>Sun, 11 May 2025 07:33:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源代碼編輯器 Zed 上線「調試器」功能</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源代碼編輯器 Zed &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fdebugger" target="_blank"&gt;宣佈&lt;/a&gt;&lt;/u&gt;推出「調試器（Debugger）」功能，稱這是向 Zed 1.0 邁出的重要一步。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;調試器特性&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;快速&lt;/strong&gt; ：減少上下文切換時間，讓用戶能更專注於調試。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;熟悉&lt;/strong&gt; ：與 Zed 的設計語言保持一致，支持典型的調試流程，方便用戶快速上手。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;可配置&lt;/strong&gt; ：用戶可自定義 UI、鍵綁定、調試配置等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-43c899b5d73c5470109aecf601bbff05ba7.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，Zed 開箱即支持調試多種流行編程語言，包括 Rust、C/C++、JavaScript、Go 和 Python。通過擴展系統，Zed 可以支持任何實現調試適配器協議（DAP）的調試適配器。&lt;/p&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;技術架構&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   採用兩層架構，數據層與調試適配器直接通信，UI 層從數據層獲取數據進行界面渲染。
  &lt;/div&gt; &lt;/li&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   數據層負責維護會話狀態、緩存響應、使失效數據，UI 層按需請求數據，避免不必要的請求，便於後續實現協作調試。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;調試適配器集成&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   擴展了 Zed 的擴展 API 以支持調試器集成，通過定義自定義架構等方式，讓擴展作者能輕鬆將調試適配器集成到 Zed 中。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0px; margin-right:0px; text-align:start"&gt;&lt;strong&gt;內聯變量值實現&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; 
  &lt;div style="margin-left:0; margin-right:0"&gt;
   利用 Tree-sitter 查詢準確識別當前執行範圍內的變量，無需依賴 LSP 服務器與調試適配器的緊密集成，目前支持 Python、Rust、Go 等語言。
  &lt;/div&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳情查看文檔：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fdocs%2Fdebugger" target="_blank"&gt;https://zed.dev/docs/debugger&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356190/zed-debugger</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356190/zed-debugger</guid>
      <pubDate>Sun, 11 May 2025 06:59:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源 Rust 瀏覽器引擎 Servo 支持 GIF</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Servo 是一款開源的瀏覽器引擎，最初由 Mozilla 開發。它使用 Rust 語言編寫，旨在提供高效、安全的網頁渲染能力，並且採用並行渲染技術，以提高網頁加載速度和性能。&lt;/p&gt; 
&lt;p&gt;近日，Servo 團隊介紹了最近的更新內容，其中一項重要新功能是&lt;strong&gt;支持顯示動態 GIF&lt;/strong&gt;，並且還可以通過 HTML "img"標籤加載 SVG 圖像。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0619/142856_yG2V_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Servo 還在推進其 Trusted Types API、輸入類型 &amp;lt;input type=color&amp;gt; 支持、更好的佈局和 CSS 支持，以及支持各種其他 API 和功能。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-958f8cd0cc574887e5f2e0cc055fb9586cf.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Servo 還在繼續努力提升圍繞 Servo 嵌入支持的開發者體驗，以 Servo 作為 Chromium 的 CEF 替代方案在應用程序中利用 Servo。&lt;/p&gt; 
&lt;p&gt;詳情查看&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fservo.org%2Fblog%2F2025%2F06%2F18%2Fthis-month-in-servo%2F" target="_blank"&gt;https://servo.org/blog/2025/06/18/this-month-in-servo/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356185/servo-may-2025-animated-gifs</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356185/servo-may-2025-animated-gifs</guid>
      <pubDate>Sun, 11 May 2025 06:30:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Qt Creator 17 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Qt Creator 17 現已發佈，&lt;span style="color:#000000"&gt;一些亮點更新內容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;h4&gt;General&lt;/h4&gt; 
&lt;p&gt;在 Qt Creator 15 中引入並在 Qt Creator 16 中更新的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-15-released%3FhsLang%3Den" target="_blank"&gt;「2024」淺色和深色主題&lt;/a&gt;現已成為默認主題。用戶仍然可以使用 Preferences &amp;gt; Environment &amp;gt; Interface &amp;gt; Theme 來選擇其他主題。已審核並更新了 Qt Creator 中的圖標，以與新的視覺風格保持一致，並實現更一致的用戶界面。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" height="382" src="https://oscimg.oschina.net/oscnet/up-806935a7e5b640cd078f2e4a9533addd625.webp" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;已將擴展的默認註冊表移至&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fqt-creator%2Fextension-registry" target="_blank"&gt;GitHub&lt;/a&gt;。用戶現在可以在 Preferences &amp;gt; Extensions &amp;gt; Browser 中設置擴展的多個來源，但使用風險需自負。同時，項目團隊還擴展了尚未安裝的擴展的顯示信息，用戶可以直接將擴展的存檔拖放到「擴展」模式進行安裝。&lt;/p&gt; 
&lt;h4&gt;Projects&lt;/h4&gt; 
&lt;p&gt;Qt Creator 17 中一個比較大的變化是，將運行配置設為構建配置的一部分。在此之前，構建配置和運行配置完全獨立。現在，每個運行配置都屬於一個特定的構建配置，切換活動的構建配置也會切換可用的運行配置集。這涵蓋了經常需要使用不同運行參數的用例，例如不同的命令行參數或針對不同構建配置（例如 Debug 或 Release）所需的不同環境。&lt;/p&gt; 
&lt;p&gt;此外，現在可以使用新的「&lt;span style="color:#09102b"&gt;Clone into This&lt;/span&gt;」按鈕將值從一個運行配置複製到另一個運行配置，而不管它們屬於哪個構建配置。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;CMake&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;添加了一個選項，當 CMake 配置因缺少 Qt 軟件包而失敗時，可以使用 Qt 在線安裝程序（如果 Qt Creator 已鏈接到該安裝程序）安裝缺失的 Qt 組件。此功能依賴於 Qt Creator 中的 Preferences &amp;gt; CMake &amp;gt; General &amp;gt; Package manager auto setup 功能，該功能要求使用 Qt Creator 中的 CMake 配置項目。有關此功能以及 Qt Creator 中 CMake 支持的其他改進的更多信息，可查看&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-17-cmake-update%3FhsLang%3Den" target="_blank"&gt;單獨的博客文章&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Python&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;添加了在 Qt Creator 中打開基於&lt;code&gt;pyproject.toml&lt;/code&gt;項目的支持。現在，通過 Qt Creator 的項目嚮導創建的新 PySide 項目也默認打開 pyproject.toml。同時也支持打開基於&lt;code&gt;.pyproject&lt;/code&gt;的 PySide 項目。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Editing&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;將預構建的二進制文件切換至 LLVM 20.1.3，以獲得更新的 C++ 支持。新增了一些快速修復，用於將&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdoc.qt.io%2Fqt-6%2Fqt-literals-stringliterals.html" target="_blank"&gt;Qt 的字符串字面量運算符&lt;/a&gt;（例如「_ba」或「_L1」）添加到字符串字面量中。還修復了一些與&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugreports.qt.io%2Fbrowse%2FQTCREATORBUG-32667" target="_blank"&gt;function-like built-ins&lt;/a&gt;&amp;nbsp;和&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugreports.qt.io%2Fbrowse%2FQTCREATORBUG-32598" target="_blank"&gt;function-like macros&lt;/a&gt;&lt;span style="color:#09102b"&gt;&amp;nbsp;的&lt;/span&gt;問題。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;QML&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;現在，Preferences &amp;gt; Qt Quick &amp;gt; Code Style 中的代碼樣式選項允許使用集成到 QML 語言服務器的 qmlformat 進行代碼格式化，以及內置格式化程序和自定義的、兼容 qmlformat 的格式化程序。現在還可以通過上下文菜單和 Tools &amp;gt; QML/JS 菜單重新格式化文檔。&lt;/p&gt; 
&lt;p&gt;QML 代碼編輯器的工具欄上有一個新的&lt;code&gt;.ui.qml&lt;/code&gt;文件按鈕，可以在 Qt Design Studio 中打開文件。&lt;/p&gt; 
&lt;h4&gt;&lt;strong&gt;Version Control&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;對於 Git 版本控制，添加了各種「diff」操作的變體，這些操作適用於已暫存的更改，而非未暫存的更改。「Instant Blame」的工具提示現在新增了用於還原更改的操作，Add Tag 對話框現在也可以創建帶註釋的標籤。&lt;/p&gt; 
&lt;p&gt;更多詳情可&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.qt.io%2Fblog%2Fqt-creator-17-released" target="_blank"&gt;查看官方公告&lt;/a&gt;。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356182/qt-creator-17-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356182/qt-creator-17-released</guid>
      <pubDate>Sun, 11 May 2025 06:24:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源遊戲引擎 Godot 4.5 beta 1 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源遊戲引擎 Godot 4.5 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Farticle%2Fdev-snapshot-godot-4-5-beta-1%2F" target="_blank"&gt;發佈了首個 Beta 更新&lt;/a&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1a2f0c1591c9660839ac2bc0e69402a7647.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2c8b42310278dcb1ea2ce6d7e8611e46f25.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下是 Godot 4.5 beta 版本的更新亮點&lt;/p&gt; 
&lt;h3&gt;新功能&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;支持導出變量為 Variant 類型&lt;/strong&gt; ：此前數組和字典雖技術上支持 Variant 值，但無法直接導出 Variant 類型變量，現在可通過修改導出變量類型實現，為用戶提供了更大的靈活性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;標籤的堆疊輪廓效果&lt;/strong&gt; ：以往添加文本的輪廓或陰影效果時選擇有限，現在支持在 Label 上添加多層堆疊的輪廓效果，無需再通過堆疊多個文本對象來實現，操作更簡便。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;基於環境光的鏡面遮擋&lt;/strong&gt; ：渲染器新增了基於環境光的鏡面遮擋功能，可使某些金屬或反射材質在該遮擋生效時不再出現不自然的反射，且該功能可通過項目設置中的切換按鈕進行開關。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;內聯顏色選擇器&lt;/strong&gt; ：在腳本編輯器中為導出色彩變量添加了內聯顏色選擇器，用戶無需在檢查器中查看，即可直觀地看到變量所代表的顏色，使代碼編寫更加直觀。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;動畫改進&lt;/strong&gt; ：如動畫播放器添加字母排序功能、動畫編輯器添加動畫過濾功能等，提升了動畫製作的便利性和效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;對 Apple Vision Pro 的原生支持&lt;/strong&gt; ：Godot 4.5 Beta 版本中，visionOS 成為近十年來首個被 Godot 引擎正式納入支持的平台，為開發者打開了 XR 遊戲開發的新大門。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;改進&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;編輯器改進&lt;/strong&gt; ：增加了將主菜單摺疊到菜單按鈕的編輯器設置；默認啓用了外部更改時的自動重載腳本功能；添加了在編輯器資源選擇器中快速加載的按鈕等，提升了編輯器的易用性和工作效率。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;圖形用戶界面改進&lt;/strong&gt; ：如添加了文件對話框中的文件排序功能；添加了控制在焦點事件上顯示虛擬鍵盤的屬性；添加了使用 Ctrl+中鍵進行拖動縮放的功能等，優化了用戶在圖形界面操作時的體驗。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;導入改進&lt;/strong&gt; ：使用 libjpeg-turbo 替代原有的 jpeg 編解碼器，提高了兼容性和速度；為紋理資源導入添加了通道重映射設置，為資源導入提供了更多的靈活性和控制。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;網絡改進&lt;/strong&gt; ：修復了 mbedTLS 中與 TLS 相關的併發問題，提高了網絡功能的穩定性和可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;粒子系統改進&lt;/strong&gt; ：對光照、貼花和粒子碰撞器的剔除掩碼內部機制進行了大修，優化了粒子系統的性能和效果。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;渲染改進&lt;/strong&gt; ：添加了將網格添加到顯存佔用分析器中；允許在沒有運動矢量的情況下移動網格；在正向 + 渲染路徑中，用 DFG LUT 替換了當前的 BRDF 近似，並添加了多散射能量補償等，提升了渲染的質量和性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;着色器改進&lt;/strong&gt; ：公開了內置的區域信息，使着色器編程更加靈活和強大，為開發者提供了更多的創作空間。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;修復&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;修復了調試時對類型化字典的調試問題。&lt;/li&gt; 
 &lt;li&gt;修復了崩潰處理程序中打印腳本回溯的問題。&lt;/li&gt; 
 &lt;li&gt;修復了資源複製的問題。&lt;/li&gt; 
 &lt;li&gt;修復了字符串序列化問題。&lt;/li&gt; 
 &lt;li&gt;修復了多通道音頻重採樣問題。&lt;/li&gt; 
 &lt;li&gt;修復了 Android 平台相關問題，如更新 NDK 版本、移除某些導出選項等。&lt;/li&gt; 
 &lt;li&gt;修復了在非監控區域使用 Jolt 物理時的性能問題。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下載地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgodotengine.org%2Fdownload%2Farchive%2F4.5-beta1%2F" target="_blank"&gt;https://godotengine.org/download/archive/4.5-beta1/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356177/godot-4-5-beta-1-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356177/godot-4-5-beta-1-released</guid>
      <pubDate>Sun, 11 May 2025 06:11:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>美國科技巨頭推動聯邦立法，禁止各州單獨監管 AI</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;《金融時報》報道稱，近日美國多家大型科技公司正積極推動一項聯邦禁令，旨在禁止各州自行制定人工智能（AI）監管法規。此次立法倡議得到了亞馬遜、谷歌、微軟和 Meta 等公司的支持，目的是避免各州在 AI 監管方面各自為政，影響行業的整體發展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;知情人士透露，這項禁令提案已經被納入眾議院版本的 「大而美」 預算法案中。參議院也計劃在近期推出自己的版本，並希望能夠在 7 月 4 日之前完成相關立法工作。前聯邦眾議員、現任 INCOMPAS 首席執行官 Chip Pickering 是這項提案的重要推動者，他表示，保持美國在技術領域的領導地位是確保國家競爭力的關鍵。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;INCOMPAS 組織於 2024 年成立了 「人工智能競爭中心」（AICC），專注於遊説國會與監管機構，以適應快速發展的 AI 行業。隨着 AI 監管討論的加劇，尤其是在歐盟出台新規後，亞馬遜和 Meta 也加入了該組織，試圖通過統一監管來增強競爭力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;然而，此提案引發了廣泛的爭議。反對者認為，大型科技公司推動禁令的真正目的是為了鞏固自身在 AGI（通用人工智能）競爭中的壟斷地位。範德比爾特大學的政策加速中心 AI 與科技政策主任 Asad Ramzanali 表示，負責任的創新不應該懼怕法律的約束。同時，麻省理工學院的教授 Max Tegmark 也批評稱，這種行為是科技巨頭為了進一步集中財富和權力的擴張。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;另一方面，支持禁令的人士認為，聯邦層面的統一監管將有助於避免各州的分歧，保持行業的創新能力，從而在全球 AI 競爭中處於有利地位。AI 安全倡導者如 Anthropic 聯合創始人 Dario Amodei 則警告稱，如果完全依賴企業自我監管，可能會帶來嚴重的社會風險。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356176</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356176</guid>
      <pubDate>Sun, 11 May 2025 06:08:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>百度垂搜數據管理系統彈性調度優化實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;百度垂直搜索系統將搜索核心能力賦能阿拉丁（百度搜索特型結果）、垂直領域搜索、應用內搜索等場景，支撐了數百個檢索場景、百億級內容數據的檢索。隨着接入業務數量和數據量不斷增長，系統在海量數據管理與調度上遭遇新的挑戰，通過垂搜數據管理系統彈性調度優化實踐來滿足業務增長需求。&lt;/p&gt; 
&lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;01 背景&lt;/h1&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;1.1 簡介&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;百度垂搜架構的召回引擎經過歷史架構演進確定了&lt;strong&gt;&lt;strong&gt;異構&lt;/strong&gt;&lt;/strong&gt;部署的架構模型，相較於同構部署在容量自動調整、數據按需存儲等方面更具效率與成本的優勢，同時在海量數據和海量檢索方面也實現了高可用和高性能。目前系統已承接 80+業務，全機房部署了數百個檢索服務，數千個索引庫，共計數百億文檔收錄。隨着接入新業務數量的增加，以及存量業務的深入迭代，我們遇到了更加複雜多樣的場景，進而對系統提出更高的要求。本文主要介紹我們的系統在海量數據管理與調度上面臨的問題， 以及各項優化工作落地後在系統擴展性、穩定性等方面取得的效果。&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;1.2&amp;nbsp;當前數據管理架構存在的問題&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;此前我們的系統設計了彈性伸縮機制應對流量和數據量的上漲，冷熱分離機制實現了資源按需部署。隨着接入業務的增加，系統逐漸暴露出一些新的問題，主要體現在以下幾點:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;元信息管理瓶頸。系統使用 ETCD 進行服務發現和心跳管理， 然而所有業務實例&lt;strong&gt;&lt;strong&gt;直連 ETCD&lt;/strong&gt;&lt;/strong&gt;存在嚴重讀寫放大問題， 導致 ETCD 負載超發出現&lt;strong&gt;&lt;strong&gt;單點瓶頸&lt;/strong&gt;&lt;/strong&gt;, 限制集羣規模進一步增長。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;依靠人工評估資源。新業務的接入或者一些大事件運營保障依賴人工估算所需資源，&lt;strong&gt;&lt;strong&gt;不僅耗費人力，而且不夠準確&lt;/strong&gt;&lt;/strong&gt;，估算過高，服務長期處於低負載會造成資源浪費，估算過低，服務容易過載，進而導致穩定性問題。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;數據量增長瓶頸。 當前的架構可以在無需重新建庫的情況下原地擴分片，但是分片數只能倍數擴展，並且&lt;strong&gt;&lt;strong&gt;分片數量有限制&lt;/strong&gt;&lt;/strong&gt;，大庫場景容易觸發上限，進而導致數據量無法繼續增長。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;02 檢索系統與數據管理系統架構&lt;/h1&gt; 
&lt;span id="OSC_h2_5"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.1&amp;nbsp;檢索系統架構概覽&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;首先簡單介紹下垂搜檢索系統的各模塊，如下圖所示:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-c6fa6c464ffb4e6ea05cb47989be85fcbaf.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;RANK。檢索精排模塊，負責 query 理解、請求構造、多隊列拆分、正排數據獲取、策略因子計算、算分排序、返回結果組裝等流程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS。檢索召回引擎，負責基礎召回/粗排，根據基礎相關性等權重因子進行數據的粗篩，支持基於 term 倒排拉鍊和 ANN 向量基礎召回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BUILD。數據建庫模塊，負責數據處理、切詞、生成正排/倒排/向量/摘要等功能。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;每個垂類 (業務) 擁有一套獨立的上述檢索系統服務，數據管理系統為每個業務的檢索系統提供&lt;strong&gt;&lt;strong&gt;實例調度、容量管理、服務發現、心跳管理、路由控制&lt;/strong&gt;&lt;/strong&gt;等能力，數據管理系統面向的核心管理對象是召回引擎 (BS)。&lt;/p&gt; 
&lt;span id="OSC_h3_6"&gt;&lt;/span&gt; 
&lt;h3&gt;2.1.1&amp;nbsp;垂搜召回引擎&lt;/h3&gt; 
&lt;p&gt;如下圖所示，百度垂搜的召回引擎是一個&lt;strong&gt;&lt;strong&gt;流式、多分片、異構、有狀態的倒排+向量&lt;/strong&gt;&lt;/strong&gt;索引引擎:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6a59f451eae4330c4d002228c9ca5d20b51.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;流式。業務經過離線建庫環節產出建庫包並生效到 Kafka 中，召回引擎再從 Kafka 消費，數據從建庫到檢索可實現&lt;strong&gt;&lt;strong&gt;秒級生效&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;多分片。業務數據量超過單機存儲上限，會被拆分成多個分片 (slice)，每個分片由 PaaS 層面實例承載，並對應 Kafka 的一段 partition 區間。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;異構。單個業務的若干個資源號 (resource) 之間支持獨佔或者混部，一般根據服務負載設置不同副本數，根據數據量設置不同分片數。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;有狀態。每個實例承載一個或多個分片數據，週期性彙報心跳，消費分片由中控服務統一調度。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;名詞解釋:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;resource(資源號): 一類或者一個場景的數據集合，即一個&lt;strong&gt;&lt;strong&gt;索引庫&lt;/strong&gt;&lt;/strong&gt;，一個業務通常包含多個資源號 (如圖中 mobile_game，pc_game， game_video 等)。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;slice(分片):數據調度基本單位，一個 resource 根據數據量可能會拆分成多個 slice(mobile_game 有三個 slice, pc_game 和 game_video1 個)。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;slot:數據劃分的基本單位，一個 slice 下有若干個 slot， 與 Kafka 的 partition 一一對應，在業務接入時根據數據量級確定。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;pod:PaaS 層面實際的物理存儲容器，一個 pod 會承載一個或多個 slice，由中控服務統一調度。&lt;/p&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;2.2&amp;nbsp;動態化數據管理系統&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;動態化數據管理系統負責召回引擎的每個實例從建庫到檢索，從部署到下線的全生命週期管理。經過&lt;strong&gt;&lt;strong&gt;服務重構、架構升級、新功能建設&lt;/strong&gt;&lt;/strong&gt;等方面的優化工作，形成了包括中控服務，心跳服務 (HeartbeatService), 名字服務 (NamingService), 存儲 ETCD 等模塊的現有系統架構:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-da1b5525954986be5194f44d536e0d8d45b.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.1&amp;nbsp;中控服務&lt;/h3&gt; 
&lt;p&gt;整個動態化數據管理系統的核心模塊，負責各類調度任務的發起、控制等:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;資源號接入/下線。新增資源號 (索引庫)，為每個資源號根據副本數、資源號之間部署關係等調度實例；下線資源號， 對應資源號的數據發起清理以及實例回收。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;副本保活。每個資源號實際副本數可能由於擴縮副本或 PaaS 層面遷移，導致與目標副本數不一致，中控服務負責定期輪訓所有資源號 (分片)，維持副本數與目標一致。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;容量管理。自動擴縮容服務/人工基於負載調整資源號的副本數，並通過副本保活生效，基於數據量調整資源號分片數，通過任務控制器生效。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;可用度控制。上線重啓需要保證分片維度的可用度，變更由 PaaS 發起，每個實例重啓前需要請求中控服務的探針，中控服務根據當前分片可用度決定實例是否可以重啓。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_9"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.2&amp;nbsp;名字服務 NamingService&lt;/h3&gt; 
&lt;p&gt;提供服務發現，實例屏蔽，建庫路由控制等能力：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;服務發現。週期性加載並更新全量業務的資源號檢索路由拓撲信息，對每個分片過濾心跳丟失、未消費完成、重啓中等暫不可用實例。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實例屏蔽。支持異常實例的分片維度/App 維度屏蔽，線上快速止損，並保留現場便於後續問題追查。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;建庫路由控制。提供離線建庫側全量業務資源號與 Kafka partition 映射關係查詢，資源號倒排索引雙寫控制。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_10"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.3&amp;nbsp;心跳服務 HeartbeatService&lt;/h3&gt; 
&lt;p&gt;負責召回引擎 (BS) 實例、分片心跳信息收集並持久化，實例消費區間信息傳遞等:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;心跳管理。收集召回引擎實例上報的心跳信息，包括實例自身心跳以及消費分片信息， 並將心跳信息聚合後寫入 ETCD。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;實例調度信息傳遞。獲取由中控調度下發的最新消費分片信息，寫入心跳請求 response，實例感知到消費分片發生變化後，清理舊分片數據，並重新消費新分片數據。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_11"&gt;&lt;/span&gt; 
&lt;h3&gt;2.2.4&amp;nbsp;存儲 ETCD&lt;/h3&gt; 
&lt;p&gt;動態化數據管理系統各類元信息持久化存儲:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;實例心跳信息。包括版本號，實例唯一標識，上報時間戳，消費分片等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;分片路由拓撲信息。分片下全量副本狀態信息，包括 endpoint，snapshot 版本，上報時間戳，消費狀態等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;業務資源號拓撲信息、建庫路由信息。單業務視角下全量資源號信息，包括版本號，分片數，副本數，對應 Kafka partition 區間，rpc 參數配置等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_12"&gt;&lt;/span&gt; 
&lt;h1&gt;03 彈性調度機制優化實踐&lt;/h1&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.1&amp;nbsp;服務發現、心跳管理模塊重構&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_14"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.1&amp;nbsp;原有架構&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-6f12910e29c40a1a821609e09c774e7296d.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;可以看到在原有架構，業務 RANK 和 BS 實例都是直連 ETCD，隨着業務接入數量的增加逐漸暴露出一些問題:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;讀流量放大。同業務的不同 RANK 實例會各自訪問 ETCD 獲取相同的路由拓撲，導致讀流量放大，對於 RANK 實例數多的業務放大現象愈發明顯。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;寫流量放大。每個分片含有多個副本，在進行更新時，一輪週期內同一個分片會被寫入多次，導致寫流量放大，對於副本數多的分片寫競爭愈發激烈。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;升級改造困難。路由篩選策略、心跳上報策略均內嵌在 sched-lib 中, 進行升級需要給每個業務 RANK/BS 上線，人力成本巨大。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;為瞭解決上述問題，我們對心跳管理和服務發現模塊進行了微服務拆分，新增心跳服務 (以下簡稱 HS) 和名字服務 (以下簡稱 NS) 避免了業務實例直連 ETCD，同時引入了 Prometheus，對心跳上報狀態和路由獲取狀態等信息進行監控和可視化展示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-bb9efb9826cf2b2ebe1bae522ce0df14546.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_15"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.2&amp;nbsp;NS(NamingService) 設計&lt;/h3&gt; 
&lt;p&gt;我們對 NS 的定位是作為 ETCD 的 cache，採用 Read-Through 的模式，對全量業務的 RANK 提供拓撲信息查詢，RANK 不再直接訪問 ETCD:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;NS 本身設計為一個&lt;strong&gt;&lt;strong&gt;無狀態服務&lt;/strong&gt;&lt;/strong&gt;， RANK 可以訪問任意一台 NS 獲取拓撲，NS 實例之間拓撲路由&lt;strong&gt;&lt;strong&gt;保證最終一致性&lt;/strong&gt;&lt;/strong&gt;，NS 在拓撲變更時返回拓撲信息+MD5(拓撲)+更新時間戳，未變更時僅返回 MD5 和時間戳， RANK 基於 MD5 和時間戳自行判斷是否需要更新。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;拓撲更新策略下沉到 NS 中，RANK 獲取到的拓撲即為直接可用拓撲，針對不同業務提供不同的控制策略並且後續升級改造只需上線 NS，成本大幅降低。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;單機房 3 台 NS 實例即可支撐全部業務拓撲查詢，重構前後 ETCD 讀流量比例為 M:3，M 為平均每個業務 RANK 實例數，假設 N 取 30，則讀流量下降 90%。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-93ea29c3774379e1a2cabf37f1ed095a248.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_16"&gt;&lt;/span&gt; 
&lt;h3&gt;3.1.3&amp;nbsp;HS(HeartbeatService) 設計&lt;/h3&gt; 
&lt;p&gt;HS 負責收集 BS 實例本身的心跳以及實例消費的分片的心跳，週期性&lt;strong&gt;&lt;strong&gt;聚合寫入&lt;/strong&gt;&lt;/strong&gt;ETCD，並且向 BS 實例返回其最新的消費分片信息:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;HS 採用無主節點設計，也支持任意水平擴展。同一個業務的不同 BS 實例通過&lt;strong&gt;&lt;strong&gt;一致性 hash&lt;/strong&gt;&lt;/strong&gt;方式請求同一台 HS 實例, 便於 HS 進行分片維度的信息聚合，這樣在大部分時間，每個分片無論有多少個副本一個週期內只會被寫入一次，實例本身的心跳採用批量更新形式，寫競爭大幅降低。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS 在上報心跳的同時會從 HS 的 response 中獲取自身消費的最新分片信息，如果分片信息變化，則清理老分片數據，消費新分片數據，後續只上報新分片狀態信息。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;單機房 3 台 NS 實例即可支撐全部業務心跳更新，重構前後 ETCD 寫流量比例為 N:1，N 為平均每個分片副本數，假設 N 取 5，則寫流量下降 80%。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-f141ad59566f2bbe45c04a1a0dac2046805.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_17"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;strong&gt;3.2&amp;nbsp;自動擴縮容&lt;/strong&gt;&lt;/h2&gt; 
&lt;span id="OSC_h3_18"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.1&amp;nbsp;當前現狀&lt;/h3&gt; 
&lt;p&gt;BS 是一個&lt;strong&gt;&lt;strong&gt;多分片、異構&lt;/strong&gt;&lt;/strong&gt;服務，即每個 App 內通常部署了多個資源號，各業務 App 在 PasS 層面隔離部署，在資源利用率、擴縮容管理等方面我們遇到以下問題：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;整體資源利用率低。全機房擁有上百個 BS 業務 App、上千個資源號，PaaS 層面的整體平均峯值 CPU 利用率低於平均水平，峯值 CPU 超過 70% 的資源號佔比不足 20%。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;依賴人工進行資源號副本數調整。一般上線前通過人工壓測評估放量後所需的資源然後進行申請，有時候通過壓測難以估算真實的資源，並且後續業務迭代或者流量變化也會引起資源使用的變化，如果負載超發，服務穩定性難以保障，如果負載太過空閒，也會造成資源浪費。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;無法直接接入 PaaS 層面自動擴縮容能力。一方面 PaaS 無法感知每個 App 內資源號維度負載信息，另一方面每個實例承載分片信息只能由中控服務調度，因此無法直接服用 PaaS 層面自動擴縮容能力。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-05f53f5b84434e08c78529d148cd54a6dcb.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_19"&gt;&lt;/span&gt; 
&lt;h3&gt;3.2.2&amp;nbsp;自動擴縮容實現&lt;/h3&gt; 
&lt;p&gt;為了實現容量自適應調整，我們開發了一個自動擴縮容服務，對全量資源號進行容量管理。自動擴縮容服務週期性計算資源號維度負載，根據負載情況，觸發中控服務進行資源號副本數調整，或者 PaaS 層面實例數調整。對於擴容，優先調度存量資源池中實例，如果存量實例不足則觸發 PaaS 擴容；對於縮容，先將空閒副本數回收至空閒資源池，再觸發 PaaS 縮容。對於自動擴縮容服務的設計我們主要考慮了以下幾點:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-53d9ad28a3b34ec0ecb4706a0bc8f9316eb.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_20"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;負載指標選取&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;垂搜系統大部分業務 BS 為純內存版本，且幾乎沒有下游網絡請求，屬於典型的計算密集型業務， 因此我們選擇 CPU 作為負載計算參考指標，另外資源號混部場景進一步結合 QPS 和 Latency 進行判斷。此前我們已經實現了基於 Prometheus 採集實分片維度 CPU、MEM、QPS、Latency、建庫數據量等指標全量業務覆蓋，因此可以低成本的獲取到全量&lt;strong&gt;&lt;strong&gt;資源號維度&lt;/strong&gt;&lt;/strong&gt;的負載數據。&lt;/p&gt; 
&lt;span id="OSC_h4_21"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;負載狀態流轉&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;每個資源號從擴容到縮容，共定義如下 7 種狀態：&lt;/p&gt; 
&lt;p&gt;&lt;code&gt;enum LoadStatus { LOAD_STATUS_LOAD_OK = 0; //正常負載 LOAD_STATUS_OVERLOAD = 1; //超負載 LOAD_STATUS_IDLELOAD = 2; //低負載 LOAD_STATUS_BS_ADD_REPLICA = 3; //bs 擴副本中 LOAD_STATUS_BS_REMOVE_REPLICA = 4; // bs 縮副本中 LOAD_STATUS_TRIGGER_PAAS_EXPENSION = 5; // PaaS 擴容中 LOAD_STATUS_TRIGGER_PAAS_SHRINK = 6; // PaaS 縮容中 }&lt;/code&gt;&lt;/p&gt; 
&lt;p&gt;每個資源號根據負載情況在上述狀態之間流轉:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8fa2f7581ed63466a8f24640ad7258bba52.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_22"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;擴縮容執行流程&lt;/strong&gt;&lt;/h4&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;擴副本&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;優先調度 App 內空閒實例，不足則觸發 PaaS 層面實例數擴容，循環執行直到負載恢復正常。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-edfbd8b326a5709833d414a5fb013f357ed.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;縮容&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;先將資源號多餘副本釋放為空閒實例，再觸發 PaaS 層面縮容，循環執行直到資源號負載以及空閒實例數回到正常水平。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-504ce96574f2dc384b323509ab32bd78022.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_23"&gt;&lt;/span&gt; 
&lt;h2&gt;3.3&amp;nbsp;&lt;strong&gt;資源號擴分片進階&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;每個資源號隨着數據量級不斷增長，分片數也需要動態擴展，否則會出現分片內存超發的情況。&lt;/p&gt; 
&lt;span id="OSC_h3_24"&gt;&lt;/span&gt; 
&lt;h3&gt;3.3.1&amp;nbsp;&lt;strong&gt;當前擴分片方案&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;每個資源號按 resource-&amp;gt;slice-&amp;gt;slot 的層級劃分，slot 是數據劃分最小單位與 kafka partion 一一對應，在業務接入時每個資源號 slot(partion) 的數量已經確定。擴層時，資源號的 slot 數量不變，&lt;strong&gt;&lt;strong&gt;分片數變成原來 2 倍， 每個分片的 slot 數則為原來的 1/2&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8db852d84d0b6a8d63c9bac9fed576d9490.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;原有的擴分片方案可以在無需重新建庫的情況下實現業務無感的原地分片擴縮操作，然而依舊存在兩個問題:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;分片數按指數增長，當分片數超過一定數值，將帶來不容忽視的資源成本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果初始分配 slot 數太少，當 slice:slot=1:1 時，無法再擴層，數據增長出現瓶頸。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h3_25"&gt;&lt;/span&gt; 
&lt;h3&gt;3.3.2&amp;nbsp;&lt;strong&gt;進階擴展方案&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;對於分片無法繼續擴展但是依舊需要繼續建庫的情況，先前的方案只能是重建一個新的資源號，需要業務、架構共同介入，歷史上我們使用原方案遷移一個資源號，前後&lt;strong&gt;&lt;strong&gt;投入近 3 周時間&lt;/strong&gt;&lt;/strong&gt;，耗費成本巨大，因此我們需要一個成本更低的方案。通過分析，當前分片的擴展瓶頸主要有以下三個限制條件：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;每個資源號的 slots 是一段連續的區間。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;BS 的 slot 與 Kafka 的 partition 一一對應。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;初始分配 slot 數太少，且後續不支持調整。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;只需要打破其中任意一個條件，則可以消除瓶頸。綜合考慮改造成本、擴展靈活性、實現難度等因素，我們選擇從條件三入手，在新的 partition 區間重建分片，分片數和 slot 數根據數據量設置，將舊分片的數據全量複製到新的分片上，再將新分片替換舊分片，如下圖所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-1534a9d4b6b75072160e0a0470563a1c8c8.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h4_26"&gt;&lt;/span&gt; 
&lt;h4&gt;&lt;strong&gt;整體實現&lt;/strong&gt;&lt;/h4&gt; 
&lt;p&gt;對於一個流式建庫系統，業務可能時刻都在進行數據建庫，我們希望做到遷移過程中業務依舊可以持續建庫，並且保證數據不丟失、時序不錯亂。我們的方案是將數據分為存量數據 (老分片中的全量數據) 和增量數據 (實時寫入的新數據)，對於增量數據可以通過雙寫機制，同時寫入新舊分片，存量數據則通過構建 snapshot 的方法遷移至新分片，新分片數據 ready 後，再由服務發現層將檢索流量切換至新分片，整體流程如下:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;離線側開啓雙寫，保證增量倒排索引數據同時寫入新舊分片，正排和摘要部分數據無需變化。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基於舊分片構建新分片 snapshot, 並記錄構建時間點。將該時間點前舊分片所有數據進行 resharding 構建新分片 snapshot。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;新分片的 BS 實例加載構建好的 snapshot，然後每個 partition 的消費 offset&lt;strong&gt;&lt;strong&gt;回退到 snapshot 構建時間點開始重新消費&lt;/strong&gt;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;服務發現層將資源號到 slot 區間映射切換到新分片上，檢索流量從老分片遷移至新分片。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;將舊分片 BS 實例回收，並關閉雙寫。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-2cc22fbbf1492e639ef2bf5cbd76b4f8c3a.jpg" alt="" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_27"&gt;&lt;/span&gt; 
&lt;h1&gt;04 總結與展望&lt;/h1&gt; 
&lt;span id="OSC_h2_28"&gt;&lt;/span&gt; 
&lt;h2&gt;4.1&amp;nbsp;&lt;strong&gt;總結&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;本文介紹了百度垂搜檢索數據管理架構在彈性機制建設上的一系列優化工作，並且在擴展性、穩定性、以及成本效率等方面均取得了預期成果:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;擴展性&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;ETCD 負載下降一個量級，單機房 BS、RANK 集羣規模提升兩個量級， 單分片副本數上限提升至 5000+。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;分片擴展數量不再受限，解決了部分存量業務無法擴展分片導致的內存超發問題，並支持搜索創新業務數據量從百萬級逐步增加至數十億量級。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;穩定性&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;存量調度問題被修復，新增多種路由調度策略以應對不同場景，分片可用度不足幹預時間從小時級縮短至分鐘級。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;ETCD 負載不再超發，慢查詢基本消失，穩定性風險基本消除，心跳上報、拓撲獲取狀態建立監控，異常情況及時感知。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;成本效率&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt; &lt;p&gt;全機房 BS 接入自動擴縮容，實現容量自適應調整，整體峯值 CPU 利用率提升了 15%+，同時相比之前減少了 80% 人工介入容量調整的情況出現。&lt;/p&gt; &lt;/li&gt; 
   &lt;li&gt; &lt;p&gt;部分業務通過分片合併，最終使用存儲資源為下降至原來的 20%，並且檢索 97 分位耗時降低了 20ms，業務側效果與先前打平。&lt;/p&gt; &lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_29"&gt;&lt;/span&gt; 
&lt;h2&gt;4.2&amp;nbsp;&lt;strong&gt;展望&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;目前索引庫的自動擴縮容機制實現了副本數隨負載 (CPU) 的自動調整，後續將實現分片數隨數據量的自動調整。另外，在大庫場景將持續建設流批一體機制，以追求用更低的存儲成本實現更高的檢索性能。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4939618/blog/18627327</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/18627327</guid>
      <pubDate>Sun, 11 May 2025 03:11:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Sam Altman 透露將在今年夏季發佈 GPT-5</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;今天凌晨，OpenAI 發佈了其聯合創始人兼首席執行官 Sam Altman 的 40 分鐘深度專訪。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0619/105636_pUBl_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;OpenAI CEO Sam Altman &lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1935357512011890815" target="_blank"&gt;透露&lt;/a&gt;&lt;/u&gt;，備受矚目的 GPT-5 預計將於今年夏天推出，不過具體發佈日期尚未確定。&lt;/p&gt; 
&lt;p&gt;據報道，GPT-5 性能將遠超 GPT-4，測試者表示其在多方面有顯著進步。據悉，這款新模型將整合 OpenAI 的核心技術，融合 GPT-4o 自然語言處理的靈活性與 o3 在代碼及科學推理方面的優勢，打造更強大的統一系統。&lt;/p&gt; 
&lt;p&gt;Altman 暗示，GPT-5 或許不僅是性能上的升級，更可能是 OpenAI 邁向統一、類似代理模型的重要一步，使其向人工通用智能（AGI）目標更進一步。&lt;/p&gt; 
&lt;p&gt;此外，據 AI 工程師 Tibor Blaho 和投資者「Chris（chatgpt21）」消息透露，OpenAI 或將在 7 月發佈一個大規模模型，而該模型有望為 GPT-5。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;相關閲讀：&lt;a href="https://www.oschina.net/news/354761" target="news"&gt;OpenAI 推遲開源模型的發佈時間&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356142</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356142</guid>
      <pubDate>Sun, 11 May 2025 02:56:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Warm-Flow 發佈 1.7.4，設計器和流程圖優化</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;主要內容&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;[feat] 新增下載流程圖功能&lt;/li&gt; 
 &lt;li&gt;[feat] start 和 skip 或者其衍生的方法，新增指定下個任務辦理人 flowParams.nextHandler&lt;/li&gt; 
 &lt;li&gt;[feat] 新增流程圖明暗主題&lt;/li&gt; 
 &lt;li&gt;[feat] 流程圖新增通過訪問路徑設置網格顯隱&lt;/li&gt; 
 &lt;li&gt;[feat] 流程圖新增懸浮提示, 支持自定義內容和樣式&lt;/li&gt; 
 &lt;li&gt;[update] 設計器打開自動居中&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;新版流程圖&lt;/strong&gt;&lt;/p&gt; 
&lt;div&gt;
 &lt;img src="https://oscimg.oschina.net/oscnet//89db2b2722c309d9471d214941e3197b.png" referrerpolicy="no-referrer"&gt;
&lt;/div&gt; 
&lt;h2&gt;項目介紹&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;Dromara Warm-Flow 國產工作流引擎，其特點簡潔輕量，五臟俱全，靈活擴展性強，是一個可通過 jar 引入設計器的工作流。&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;支持常見審批功能、監聽器與流程變量、條件表達式、辦理人表達式&lt;/li&gt; 
 &lt;li&gt;自帶流程圖、流程設計器、節點擴展屬性&lt;/li&gt; 
 &lt;li&gt;支持常見的 orm 框架&lt;/li&gt; 
 &lt;li&gt;支持不同的數據庫&lt;/li&gt; 
 &lt;li&gt;生態豐富可擴展，文檔全面&lt;/li&gt; 
&lt;/ol&gt; 
&lt;h2&gt;功能思維導圖&lt;/h2&gt; 
&lt;div&gt;
 &lt;img src="https://oscimg.oschina.net/oscnet//7c9b29e09f2b3ced6b7ee3f1f9a5977a.png" referrerpolicy="no-referrer"&gt;
&lt;/div&gt; 
&lt;h2&gt;演示地址&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.hhzai.top" target="_blank"&gt;http://www.hhzai.top&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;賬號密碼：admin/admin123&lt;/p&gt; 
&lt;h2&gt;官網&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwarm-flow.dromara.org" target="_blank"&gt;https://warm-flow.dromara.org&lt;/a&gt;&lt;/p&gt; 
&lt;h2&gt;Warm-Flow 視頻&lt;/h2&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1AWRGYEEVr%2F%3Fspm_id_from%3D333.1387.0.0%26vd_source%3D1be886ace16159801f6ed0106df215d9" target="_blank"&gt;從零精通: 全流程開發與源碼解讀&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356140/warm-flow-1-7-4</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356140/warm-flow-1-7-4</guid>
      <pubDate>Sun, 11 May 2025 02:46:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>國產數據庫管理工具 CloudDM 個人版六月版本發佈合集</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;CloudDM 個人版&lt;/span&gt;&lt;span style="color:#333333"&gt;是&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ClouGence&lt;/span&gt;&lt;span style="color:#333333"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;公司推出的一款&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一站式多數據源開發管理工具&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#333333"&gt;，使用它可以方便地訪問和管理&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;MySQL、Oracle、PostgreSQL、阿里雲 RDS、Greenplum、TiDB、Redis、StarRocks、Doris、SelectDB、SQL Server、ClickHouse、OceanBase 、PolarDB-X 、IBM Db2 等多種不同類型的數據庫。通過 CloudDM 豐富的數據源支持可以避免在多個專業工具之間切換，從而提高工作效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;它是本地化的應用程序，沒有後台進程。和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;DataGrip&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Navicat&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;一樣在安裝完成後，只需要雙擊應用程序圖標，便可以方便地管理位於本地計算機或遠程計算機上的數據庫。已支持&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;Windows&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;MacOS、Linux&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;三個操作系統。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:center"&gt;&lt;img src="https://oscimg.oschina.net/oscnet/up-8a94365af948142b7db590d03c3dc5e8d5d.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#030303; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;六月 CloudDM 個人版共迭代發佈了 2 個版本。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.0.7&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;問題修復&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，切換數據庫模式時，數據庫模式沒有變化的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，切換數據庫模式後，SQL 可能仍在上一個模式執行的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.0.6&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;優化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;優化，查詢控制枱日誌面板右側區，新增兩個按鈕可以跳轉到控制枱日誌的最頂部和最底部。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;問題修復&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，達夢數據庫設計表時，無法將字段默認值設置為 Empty String 的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，達夢數據庫設計表時，無法將字段默認值設置為 NULL 的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，達夢數據庫設計表時，字段默認值為自定義時，無法回顯的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span&gt;修復，查詢控制枱日誌面板在執行 SQL 後無法定位到最後的問題。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;下載與反饋&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;產品官網：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.clougence.com%2Fclouddm-personal" target="_blank"&gt;&lt;span&gt;https://www.clougence.com/clouddm-personal&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;問題反饋：&lt;a href="https://gitee.com/clougence/clouddm-issue/issues"&gt;&lt;span&gt;https://gitee.com/clougence/clouddm-issue/issues&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;微信交流羣：訪問產品官網，掃描右側二維碼即可加入。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356139</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356139</guid>
      <pubDate>Sun, 11 May 2025 02:44:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>​OpenAI 終止與 Scale AI 合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 發言人當地時間週三向&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bloomberg.com%2Fnews%2Farticles%2F2025-06-18%2Fopenai-is-phasing-out-its-work-with-scale-ai-after-meta-deal" target="_blank"&gt;彭博社&lt;/a&gt;透露，在 Meta 與 Scale AI 達成交易後，OpenAI 將逐步停止與 Scale AI 的合作，並切斷與該數據供應商的聯繫。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 表示，早在 Meta 上週宣佈向這家初創公司投資數十億美元並任命 Alexandr Wang 擔任首席執行官之前，該公司就已開始逐步結束與 Scale AI 的合作。OpenAI 一直在尋找其他供應商來獲取更專業的數據，以開發日益先進的 AI 模型。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="336" src="https://oscimg.oschina.net/oscnet/up-77faf9c892257b37289b5ccb5a6d4304d54.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;OpenAI 斷絕關係的決定引發了人們對 Scale AI 核心數據標籤業務的質疑。上週，路透社報道稱，谷歌也在討論放棄 Scale AI 作為數據提供商的計劃。隨着 Meta 與 Scale AI 達成合作，Scale AI 的一些競爭對手錶示，他們收到了大量尋求「中立」合作伙伴的 AI 模型供應商的興趣。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在週三發佈的一篇博客文章中，Scale AI 的總法律顧問試圖駁斥 Meta 將在此次交易後獲得優待的説法。Scale AI 的高管表示，公司不會與 Meta 分享其他客戶的機密信息，並且新任首席執行官 Wang 不會直接參與公司的日常運營。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;在週三發佈的另一篇博客文章中，Scale AI 的臨時首席執行官 Jason Droege 則表示，公司將「加倍投入」其應用程序業務，其中包括為政府和企業構建定製的 AI 應用程序。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356119/openai-drops-scale-ai-meta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356119/openai-drops-scale-ai-meta</guid>
      <pubDate>Sun, 11 May 2025 02:29:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Midjourney 發佈首個 AI 視頻生成模型 V1</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;AI 初創公司 Midjourney &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fmidjourney%2Fstatus%2F1935377193733079452" target="_blank"&gt;宣佈&lt;/a&gt;推出其備受期待的首款 AI 視頻生成模型 V1，支持圖像到視頻的生成，並可實現從文本直接生成視頻。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1216" src="https://static.oschina.net/uploads/space/2025/0619/102551_SwUy_2720166.png" width="1286" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;V1 目前僅通過 Discord 平台的網頁端提供服務，基礎訂閲費為每月 10 美元。&lt;/p&gt; 
&lt;p&gt;根據 Midjourney 的官方介紹，V1 基於此前的圖像模型生態進行打造。&lt;/p&gt; 
&lt;p&gt;Midjourney V1 操作分為自動和手動兩種模式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;自動模式下，平台會根據用戶生成的圖片，自動創建「動作提示詞」並讓畫面運動起來；&lt;/li&gt; 
 &lt;li&gt;手動模式則是由用戶提供提示詞。同時，Midjourney V1 也分為「低動態」和「高動態」兩種運動模式。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;V1 的發佈讓 Midjourney 加入與 OpenAI 的 Sora、Runway 的 Gen 4 等 AI 視頻模型的競爭。其目標不止於為好萊塢或廣告業生成素材，公司 CEO David Holz 稱這是邁向 「實時開放世界模擬」 AI 模型的一步，後續還計劃開發 3D 渲染和實時 AI 模型。 &amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356115/midjourney-launches-its-first-ai-video-generation-model-v1</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356115/midjourney-launches-its-first-ai-video-generation-model-v1</guid>
      <pubDate>Sun, 11 May 2025 02:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>MiniMax 考慮赴港 IPO？知情人士：屬實，仍處於初步籌備階段</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;有消息稱，AI 獨角獸稀宇科技 (MiniMax) 正考慮在香港進行首次公開募股（IPO）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;對此，有接近 MiniMax 的知情人士向澎湃新聞記者表示，MiniMax 內部確實有類似想法，但目前仍處於初步籌備階段。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="275" src="https://oscimg.oschina.net/oscnet/up-1c8fdc630a51d77c2dbbdb3ff2131f20e68.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;官網介紹顯示，MiniMax 是全球領先的通用人工智能科技公司。自 2022 年初成立以來，以「與所有人共創智能」為使命，致力於推動人工智能科技前沿發展，實現通用人工智能 (AGI）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，MiniMax 已自主研發了一系列多模態通用大模型，包括 MiniMax M1、Hailuo-02、Speech-02 和 Music-01，具備超長上下文處理能力，能夠理解、生成並整合包括文本、音頻、圖像、視頻和音樂在內的多種模態。並基於這些自研模型推出一系列 AI 原生產品，包括 MiniMax、海螺 AI、MiniMax Audio、星野等，以及面向企業和開發者的開放平台。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;2024 年 3 月，MiniMax 獲 6 億美元 A 輪融資，投後估值 25 億美元，由阿里巴巴領投，此前融資的投資方也包括騰訊等。據媒體報道稱，MiniMax 的實際估值目前已經超過 2024 年所報道過的「25 億美元」。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/356108</link>
      <guid isPermaLink="false">https://www.oschina.net/news/356108</guid>
      <pubDate>Sun, 11 May 2025 02:10:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
