<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 28 Aug 2025 07:42:49 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>IDC 全球 ICT 市場預測：AI 算力驅動未來五年 7.6 萬億美元市場</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;國際數據公司（IDC）發佈了&lt;span&gt;最新&lt;/span&gt;的《全球 ICT 支出指南:行業與企業規模》。根據 IDC 的預測，到 2025 年，全球信息和通信技術 (ICT) 市場總投資規模將接近 5.9 萬億美元，並預計在 2029 年增至 7.6 萬億美元，五年複合增長率 (CAGR) 為 7.0%。特別是在中國，預計到 2029 年，市場規模將接近 8894.3 億美元，同樣保持 7.0% 的複合增長率。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="380" src="https://oscimg.oschina.net/oscnet/up-ec3411c02528d7031bf6d5f495b813246aa.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;報告指出，中國的企業級 ICT 市場將在 2025 年達到 3147 億美元，較 2024 年增長 14.3%，這個增長速度將持續高於 GDP 增速。從 2025 年開始，中國企業級 ICT 市場的年均增長率將達到 12.2%。在這一過程中，人工智能及算力的部署成為了市場增長的重要驅動力。生成式人工智能對算力的需求顯著增加，推動了服務器市場的迅速發展。IDC 預測，2024 至 2029 年期間，中國企業級服務器和存儲投資的年均複合增長率將達到 21.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，隨着國產芯片的不斷進步，未來算力的發展將會獲得更多市場機遇。同時，人工智能技術正在逐步滲透至各個行業，推動了公有云基礎設施即服務（IaaS）市場的快速增長。根據 IDC 的數據，中國 IaaS 支出的年均複合增長率將達到 14.7%。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在國際市場方面，國內雲服務廠商正在積極拓展海外市場，尤其是在雲與人工智能結合的產品及服務領域。越來越多的雲服務企業開始加快佈局，積極輸出在國內市場積累的經驗和技術。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;從技術維度來看，IDC 對市場進行了詳細的細分，涵蓋了五大技術領域和 120 個細分技術。這些技術的廣泛應用為中國企業級 ICT 市場的發展提供了廣闊的前景。報告指出，硬件市場支出仍然&lt;span&gt;最大&lt;/span&gt;，預計到 2029 年將超過 2495.5 億美元。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在軟件和信息服務領域，隨着企業數字化轉型的加速，相關需求不斷增長，預計到 2029 年，企業級軟件市場將達到 1506.5 億美元。教育行業也在積極探索 AI 應用，促進了市場的快速發展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368974</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368974</guid>
      <pubDate>Thu, 28 Aug 2025 07:39:39 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>可擴展系統設計的黃金法則與 Go 語言實踐</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、&amp;nbsp;引言：為什麼需要可擴展的系統？&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;在軟件開發領域，需求變更如同家常便飯。一個缺乏擴展性的系統，往往在面對新功能需求或業務調整時，陷入「改一行代碼，崩整個系統」的困境。可擴展性設計的核心目標是：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;讓系統能夠以最小的修改成本，適應未來的變化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。對於 Go 語言開發者而言，利用其接口、併發、組合等特性，可以高效構建出適應業務演進的系統。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;本文將從架構設計原則、編碼實踐、架構實現模式、驗證指標到演進路線，系統講解如何設計一個「生長型」系統。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、可擴展系統的核心設計原則&lt;/h1&gt; 
&lt;p style="text-align:center"&gt;&lt;strong&gt;2.1&amp;nbsp; 開閉原則：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;對擴展開放，對修改關閉&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;開閉原則是面向對象設計的基石之一。它要求系統中的模塊、類或函數，應該對擴展新功能保持開放，而對修改現有代碼保持關閉。這意味着，當需求變更時，我們應通過添加新代碼（如新增實現類）來滿足需求，而不是修改已有的代碼邏輯。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過接口（Interface）和組合（Composition）特性，天然支持開閉原則。接口定義了穩定的契約，具體實現可以獨立變化；組合則允許通過「搭積木」的方式擴展功能，而無需修改原有結構。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：數據源擴展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設我們需要支持從不同數據源（如 MySQL、S3）讀取數據，核心邏輯是「讀取數據」，而具體數據源的實現可能頻繁變化。此時，我們可以通過接口定義穩定的讀取契約：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// DataSource 定義數據讀取的穩定接口（契約）
type&amp;nbsp;DataSource&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Read(p []byte) (n&amp;nbsp;int, err&amp;nbsp;error) &amp;nbsp;// 讀取數據到緩衝區
&amp;nbsp; &amp;nbsp; Close()&amp;nbsp;error&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 關閉數據源
}


// MySQLDataSource 具體實現：MySQL 數據源
type&amp;nbsp;MySQLDataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; db *sql.DB &amp;nbsp;// 依賴 MySQL 連接
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 實現 MySQL 數據讀取邏輯（如執行查詢、填充緩衝區）
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.QueryRow("SELECT data FROM table").Scan(&amp;amp;p)
}


func&amp;nbsp;(m *MySQLDataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.db.Close() &amp;nbsp;// 關閉數據庫連接
}


// S3DataSource 新增實現：S3 數據源（無需修改原有代碼）
type&amp;nbsp;S3DataSource&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *s3.Client &amp;nbsp;// 依賴 AWS S3 客戶端
&amp;nbsp; &amp;nbsp; bucket&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 存儲桶名
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Read(p []byte) (int,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 實現 S3 數據讀取邏輯（如下載對象到緩衝區）
&amp;nbsp; &amp;nbsp; obj, err := s.client.GetObject(context.Background(), &amp;amp;s3.GetObjectInput{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Bucket: aws.String(s.bucket),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp;aws.String("data.txt"),
&amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;obj.Body.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;obj.Body.Read(p) &amp;nbsp;// 讀取數據到緩衝區
}


func&amp;nbsp;(s *S3DataSource)&amp;nbsp;Close()&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// S3 客戶端通常無需顯式關閉，可根據需要實現
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;接口定義了所有數據源必須實現的方法（&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Read&lt;/span&gt;&lt;/span&gt;和&amp;nbsp;&lt;span style="background-color:#e5e5e5"&gt;Close&lt;/span&gt;），這是系統的「穩定契約」。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;當需要新增數據源（如 S3）時，只需實現該接口，無需修改現有的 MySQL 數據源或其他依賴&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;DataSource&lt;/span&gt;的代碼。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;這一設計符合開閉原則：系統對擴展（新增 S3 數據源）開放，對修改（無需改動現有代碼）關閉。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;2.2 模塊化設計：低耦合、高內聚&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模塊化設計的核心是將系統拆分為獨立的功能模塊，模塊之間通過明確的接口交互。衡量模塊化質量的關鍵指標是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;耦合度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模塊之間的依賴程度（越低越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;內聚度&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模塊內部功能的相關性（越高越好）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理想情況下，模塊應滿足「高內聚、低耦合」：模塊內部功能高度相關（如訂單處理模塊僅處理訂單相關邏輯），模塊之間通過接口通信（如訂單模塊通過接口調用支付模塊，而非直接依賴支付模塊的實現）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過包（Package）管理模塊邊界，通過接口隔離依賴。開發者可以通過以下方式提升模塊化質量：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;單一職責原則&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：每個模塊/包僅負責單一功能（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包處理訂單邏輯，&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包處理支付邏輯）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;接口隔離&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：模塊間通過小而精的接口交互，避免暴露內部實現細節。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：訂單模塊的模塊化設計&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// order/order.go：訂單核心邏輯（高內聚）
package&amp;nbsp;order


// Order 表示一個訂單（核心數據結構）
type&amp;nbsp;Order&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ID &amp;nbsp; &amp;nbsp;&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Items &amp;nbsp;[]Item
&amp;nbsp; &amp;nbsp; Status OrderStatus
}


// Item 表示訂單中的商品項
type&amp;nbsp;Item&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; ProductID&amp;nbsp;string
&amp;nbsp; &amp;nbsp; Quantity &amp;nbsp;int
&amp;nbsp; &amp;nbsp; Price &amp;nbsp; &amp;nbsp;&amp;nbsp;float64
}


// OrderStatus 訂單狀態枚舉
type&amp;nbsp;OrderStatus&amp;nbsp;string


const&amp;nbsp;(
&amp;nbsp; &amp;nbsp; OrderStatusCreated &amp;nbsp;OrderStatus =&amp;nbsp;"created"
&amp;nbsp; &amp;nbsp; OrderStatusPaid &amp;nbsp; &amp;nbsp; OrderStatus =&amp;nbsp;"paid"
&amp;nbsp; &amp;nbsp; OrderStatusShipped &amp;nbsp;OrderStatus =&amp;nbsp;"shipped"
)


// CalculateTotal 計算訂單總金額（核心業務邏輯，無外部依賴）
func&amp;nbsp;(o *Order)&amp;nbsp;CalculateTotal()&amp;nbsp;float64&amp;nbsp;{
&amp;nbsp; &amp;nbsp; total :=&amp;nbsp;0.0
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, item :=&amp;nbsp;range&amp;nbsp;o.Items {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; total += item.Price *&amp;nbsp;float64(item.Quantity)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;total
}


// payment/payment.go：支付模塊（獨立模塊）
package&amp;nbsp;payment


// PaymentService 定義支付接口（與訂單模塊解耦）
type&amp;nbsp;PaymentService&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 支付操作
}


// AlipayService 支付寶支付實現
type&amp;nbsp;AlipayService&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *alipay.Client &amp;nbsp;// 支付寶 SDK 客戶端
}


func&amp;nbsp;(a *AlipayService)&amp;nbsp;Charge(orderID&amp;nbsp;string, amount&amp;nbsp;float64)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 調用支付寶 API 完成支付
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;a.client.TradeAppPay(orderID, amount)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;order&lt;/span&gt;包專注於訂單的核心邏輯（如計算總金額），不依賴任何外部支付實現。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;payment&lt;/span&gt;包定義支付接口，具體實現（如支付寶、微信支付）獨立存在。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;訂單模塊通過&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;PaymentService&lt;/span&gt;接口調用支付功能，與具體支付實現解耦。當需要更換支付方式時，只需新增支付實現（如&lt;span style="background-color:#e5e5e5"&gt;WechatPayService&lt;/span&gt;），無需修改訂單模塊。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_3"&gt;&lt;/span&gt; 
&lt;h1&gt;三、Go 語言的擴展性編碼實踐&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.1 策略模式：動態切換算法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;策略模式（Strategy Pattern）屬於行為型設計模式，用於定義一系列算法（策略），並將每個算法封裝起來，使它們可以相互替換。策略模式讓算法的變化獨立於使用它的客戶端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過接口實現策略的抽象，通過上下文（Context）管理策略的切換。這種模式適用於需要動態選擇不同算法的場景（如緩存策略、路由策略）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：緩存策略的動態切換&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設系統需要支持多種緩存（Redis、Memcached），且可以根據業務場景動態切換。通過策略模式，可以將緩存的&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;和&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;操作抽象為接口，具體實現由不同緩存提供。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// cache/cache.go：緩存策略接口
package&amp;nbsp;cache


// CacheStrategy 定義緩存操作的接口
type&amp;nbsp;CacheStrategy&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 從緩存獲取數據
&amp;nbsp; &amp;nbsp; Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;&amp;nbsp;// 向緩存寫入數據
}
// redis_cache.go：Redis 緩存實現


type&amp;nbsp;RedisCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *redis.Client &amp;nbsp;// Redis 客戶端
&amp;nbsp; &amp;nbsp; ttl &amp;nbsp; &amp;nbsp;time.Duration &amp;nbsp;// 默認過期時間
}


func&amp;nbsp;NewRedisCache(client *redis.Client, ttl time.Duration)&amp;nbsp;*RedisCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;RedisCache{client: client, ttl: ttl}
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Get(context.Background(), key).Result()
}


func&amp;nbsp;(r *RedisCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;r.client.Set(context.Background(), key, value, ttl).Err()
}


// memcached_cache.go：Memcached 緩存實現
type&amp;nbsp;MemcachedCache&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; client *memcache.Client &amp;nbsp;// Memcached 客戶端
}


func&amp;nbsp;NewMemcachedCache(client *memcache.Client)&amp;nbsp;*MemcachedCache {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;MemcachedCache{client: client}
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; item, err := m.client.Get(key)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;value&amp;nbsp;interface{}
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := json.Unmarshal(item.Value, &amp;amp;value); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;value,&amp;nbsp;nil
}


func&amp;nbsp;(m *MemcachedCache)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; data, err := json.Marshal(value)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;m.client.Set(&amp;amp;memcache.Item{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Key: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;key,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Value: &amp;nbsp; &amp;nbsp; &amp;nbsp;data,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Expiration:&amp;nbsp;int32(ttl.Seconds()),
&amp;nbsp; &amp;nbsp; }).Err()
}


// cache_context.go：緩存上下文（管理策略切換）
type&amp;nbsp;CacheContext&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; strategy CacheStrategy &amp;nbsp;// 當前使用的緩存策略
}


func&amp;nbsp;NewCacheContext(strategy CacheStrategy)&amp;nbsp;*CacheContext {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;CacheContext{strategy: strategy}
}


// SwitchStrategy 動態切換緩存策略
func&amp;nbsp;(c *CacheContext)&amp;nbsp;SwitchStrategy(strategy CacheStrategy) {
&amp;nbsp; &amp;nbsp; c.strategy = strategy
}


// Get 使用當前策略獲取緩存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Get(key&amp;nbsp;string) (interface{},&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Get(key)
}


// Set 使用當前策略寫入緩存
func&amp;nbsp;(c *CacheContext)&amp;nbsp;Set(key&amp;nbsp;string, value&amp;nbsp;interface{}, ttl time.Duration)&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;c.strategy.Set(key, value, ttl)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;接口定義了緩存的核心操作（&lt;span style="background-color:#e5e5e5"&gt;Get&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;Set&lt;/span&gt;），所有具體緩存實現必須實現該接口。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;RedisCache&lt;/span&gt;和&lt;span style="background-color:#e5e5e5"&gt;MemcachedCache&lt;/span&gt;是具體的策略實現，分別封裝了 Redis 和 Memcached 的底層邏輯。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;作為上下文，持有當前使用的緩存策略，並提供&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;方法動態切換策略。客戶端只需與&lt;span style="background-color:#e5e5e5"&gt;CacheContext&lt;/span&gt;交互，無需關心具體使用的是哪種緩存。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;優勢：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;當需要新增緩存類型（如本地內存緩存）時，只需實現&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;CacheStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口，無需修改現有代碼；切換緩存策略時，只需調用&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;SwitchStrategy&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;方法，客戶端無感知。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;3.2 中間件鏈：可插拔的請求處理流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;中間件（Middleware）是位於請求處理鏈中的組件，用於實現橫切關注點（如日誌記錄、限流、鑑權）。中間件鏈模式允許將多箇中間件按順序組合，形成處理流水線，每個中間件可以處理請求、傳遞請求或終止請求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過函數類型（&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;func(http.HandlerFunc) http.HandlerFunc&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）定義中間件，通過組合多箇中間件形成處理鏈。這種模式靈活且易於擴展，適用於 HTTP 服務的請求處理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：HTTP 中間件鏈的實現&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設需要為 Web 服務添加日誌記錄、限流和鑑權功能，通過中間件鏈可以將這些功能解耦，按需組合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// middleware/middleware.go：中間件定義
package&amp;nbsp;middleware


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


// Middleware 定義中間件類型：接收 http.HandlerFunc，返回新的 http.HandlerFunc
type&amp;nbsp;Middleware&amp;nbsp;func(http.HandlerFunc)&amp;nbsp;http.HandlerFunc


// LoggingMiddleware 日誌中間件：記錄請求信息
func&amp;nbsp;LoggingMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; start := time.Now()
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 記錄請求方法和路徑
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request received:", r.Method, r.URL.Path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 調用下一個中間件或處理函數
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 記錄請求耗時
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("Request completed in:", time.Since(start))
&amp;nbsp; &amp;nbsp; }
}


// RateLimitMiddleware 限流中間件：限制請求頻率
func&amp;nbsp;RateLimitMiddleware(next http.HandlerFunc, limiter *rate.Limiter)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!limiter.Allow() {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Too Many Requests", http.StatusTooManyRequests)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// AuthMiddleware 鑑權中間件：驗證請求令牌
func&amp;nbsp;AuthMiddleware(next http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; token := r.Header.Get("Authorization")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;token !=&amp;nbsp;"valid-token"&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; http.Error(w,&amp;nbsp;"Unauthorized", http.StatusUnauthorized)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; next(w, r)
&amp;nbsp; &amp;nbsp; }
}


// chain.go：中間件鏈組合
func&amp;nbsp;Chain(middlewares ...Middleware)&amp;nbsp;Middleware {
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;func(final http.HandlerFunc)&amp;nbsp;http.HandlerFunc {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 反向組閤中間件（確保執行順序正確）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i :=&amp;nbsp;len(middlewares) -&amp;nbsp;1; i &amp;gt;=&amp;nbsp;0; i-- {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; final = middlewares[i](final)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;final
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;使用示例：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：Web 服務入口
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"net/http"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"middleware"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"golang.org/x/time/rate"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 創建限流器：每秒允許 100 個請求，突發 10 個
&amp;nbsp; &amp;nbsp; limiter := rate.NewLimiter(100,&amp;nbsp;10)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 定義業務處理函數
&amp;nbsp; &amp;nbsp; handleRequest :=&amp;nbsp;func(w http.ResponseWriter, r *http.Request)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; w.Write([]byte("Hello, World"))
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 組閤中間件鏈：日誌 → 限流 → 鑑權
&amp;nbsp; &amp;nbsp; middlewareChain := middleware.Chain(
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.LoggingMiddleware,
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.RateLimitMiddlewareWithLimiter(limiter),
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; middleware.AuthMiddleware,
&amp;nbsp; &amp;nbsp; )
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 應用中間件鏈到處理函數
&amp;nbsp; &amp;nbsp; http.HandleFunc("/", middlewareChain(handleRequest))
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 啓動服務
&amp;nbsp; &amp;nbsp; http.ListenAndServe(":8080",&amp;nbsp;nil)
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;每個中間件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;LoggingMiddleware&lt;/span&gt;、&lt;span style="background-color:#e5e5e5"&gt;RateLimitMiddleware&lt;/span&gt;）專注於單一功能，通過&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;類型定義，確保接口統一。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函數將多箇中間件按順序組合，形成一個處理鏈。請求會依次經過日誌記錄、限流、鑑權，最後到達業務處理函數。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;新增中間件（如&lt;/span&gt;&lt;span style="background-color:#e5e5e5"&gt;CORS&lt;/span&gt;跨域中間件）時，只需實現&lt;span style="background-color:#e5e5e5"&gt;Middleware&lt;/span&gt;類型，即可通過&lt;span style="background-color:#e5e5e5"&gt;Chain&lt;/span&gt;函數輕鬆加入處理鏈，無需修改現有中間件或業務邏輯。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_4"&gt;&lt;/span&gt; 
&lt;h1&gt;四、可擴展架構的實現模式&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.1 插件化架構：熱插拔的功能擴展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件化架構允許系統在運行時動態加載、卸載插件，從而實現功能的靈活擴展。這種架構適用於需要支持第三方擴展或多租戶定製的場景（如 IDE 插件、電商平台應用市場）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;包支持動態庫加載，結合接口定義插件契約，可以實現安全的插件化架構。插件需實現統一的接口，主程序通過接口調用插件功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：插件化系統的實現&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設需要開發一個支持插件的數據處理系統，主程序可以動態加載處理數據的插件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;json_parser&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// plugin/interface.go：插件接口定義（主程序與插件共享）
package&amp;nbsp;plugin


// DataProcessor 定義數據處理插件的接口
type&amp;nbsp;DataProcessor&amp;nbsp;interface&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Name()&amp;nbsp;string&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件名稱（如"csv_parser"）
&amp;nbsp; &amp;nbsp; Process(input []byte) (output []byte, err&amp;nbsp;error) &amp;nbsp;// 處理數據
}


// plugin/csv_parser/csv_processor.go：CSV 處理插件（動態庫）
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/csv"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"io"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
)


// CSVProcessor 實現 DataProcessor 接口
type&amp;nbsp;CSVProcessor&amp;nbsp;struct{}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Name()&amp;nbsp;string&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;"csv_parser"
}


func&amp;nbsp;(c *CSVProcessor)&amp;nbsp;Process(input []byte) ([]byte,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 解析 CSV 數據
&amp;nbsp; &amp;nbsp; r := csv.NewReader(bytes.NewReader(input))
&amp;nbsp; &amp;nbsp; records, err := r.ReadAll()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 轉換為 JSON 格式輸出
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;result []map[string]string
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;_, record :=&amp;nbsp;range&amp;nbsp;records {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row :=&amp;nbsp;make(map[string]string)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;i, field :=&amp;nbsp;range&amp;nbsp;record {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row[fmt.Sprintf("col_%d", i)] = field
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result =&amp;nbsp;append(result, row)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; jsonData, err := json.Marshal(result)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;jsonData,&amp;nbsp;nil
}


// 插件的入口函數（必須命名為"Plugin"，主程序通過此函數獲取插件實例）
var&amp;nbsp;Plugin plugin.DataProcessor = &amp;amp;CSVProcessor{}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：主程序（加載插件並調用）
package main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"plugin"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
)


func&amp;nbsp;main() {
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 插件路徑（假設編譯為 so 文件）
&amp;nbsp; &amp;nbsp; pluginPath :=&amp;nbsp;filepath.Join("plugins",&amp;nbsp;"csv_parser.so")
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加載插件
&amp;nbsp; &amp;nbsp; p, err :=&amp;nbsp;plugin.Open(pluginPath)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 獲取插件實例（通過接口類型斷言）
&amp;nbsp; &amp;nbsp; sym, err :=&amp;nbsp;p.Lookup("Plugin")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; processor, ok :=&amp;nbsp;sym.(plugin.DataProcessor)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic("插件未實現 DataProcessor 接口")
&amp;nbsp; &amp;nbsp; }


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 使用插件處理數據
&amp;nbsp; &amp;nbsp; inputData :=&amp;nbsp;[]byte("name,age
張三,20
李四,25")
&amp;nbsp; &amp;nbsp; output, err :=&amp;nbsp;processor.Process(inputData)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err&amp;nbsp;!=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; fmt.Println(string(output)) &amp;nbsp;// 輸出 JSON 格式數據
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;接口定義&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序定義&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，規定插件必須實現的方法（&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Name&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Process&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;插件實現&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：插件（如&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;csv_parser&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）實現&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接口，並導出名為&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Plugin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;的全局變量（主程序通過此變量獲取插件實例）。&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="background-color:#ffffff"&gt;動態加載&lt;/span&gt;&lt;/strong&gt;&lt;span style="background-color:#ffffff"&gt;：主程序通過&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;plugin.Open&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;加載插件，通過&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;Lookup&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;獲取插件實例，並轉換為&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DataProcessor&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;接口調用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;優勢：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;主程序與插件解耦，插件的添加、刪除或升級不影響主程序運行。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;支持熱插拔：插件可以在運行時動態加載（需注意 Go 插件的侷限性，如版本兼容性）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;4.2 配置驅動架構：外部化的靈活配置&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;理論補充：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置驅動架構（Configuration-Driven Architecture）通過將系統行為參數化，使系統可以通過修改配置（而非代碼）來適應不同的運行環境或業務需求。這種架構適用於需要支持多環境（開發、測試、生產）、多租戶定製或多場景適配的系統。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言的實現方式：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;Go 語言通過&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;encoding/yaml&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等包支持配置文件的解析，結合&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;viper&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等第三方庫可以實現更復雜的配置管理（如環境變量覆蓋、熱更新）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;示例：配置驅動的數據庫連接&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;假設系統需要支持不同環境（開發、生產）的數據庫配置，通過配置文件動態加載數據庫連接參數。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;// config/config.go：配置結構體定義
package&amp;nbsp;config


// DBConfig 數據庫配置
type&amp;nbsp;DBConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; DSN &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;string&amp;nbsp;`json:"dsn"`&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 數據庫連接字符串
&amp;nbsp; &amp;nbsp; MaxOpenConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_open_conn"`&amp;nbsp;// 最大打開連接數
&amp;nbsp; &amp;nbsp; MaxIdleConn&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"max_idle_conn"`&amp;nbsp;// 最大空閒連接數
&amp;nbsp; &amp;nbsp; ConnTimeout&amp;nbsp;int&amp;nbsp; &amp;nbsp;&amp;nbsp;`json:"conn_timeout"`&amp;nbsp;&amp;nbsp;// 連接超時時間（秒）
}


// AppConfig 應用全局配置
type&amp;nbsp;AppConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Env &amp;nbsp;string&amp;nbsp; &amp;nbsp;`json:"env"`&amp;nbsp; &amp;nbsp;// 環境（dev/test/prod）
&amp;nbsp; &amp;nbsp; DB &amp;nbsp; DBConfig&amp;nbsp;`json:"db"`&amp;nbsp; &amp;nbsp;&amp;nbsp;// 數據庫配置
&amp;nbsp; &amp;nbsp; Log &amp;nbsp;LogConfig&amp;nbsp;`json:"log"`&amp;nbsp; &amp;nbsp;// 日誌配置
}


// LogConfig 日誌配置
type&amp;nbsp;LogConfig&amp;nbsp;struct&amp;nbsp;{
&amp;nbsp; &amp;nbsp; Level&amp;nbsp;string&amp;nbsp;`json:"level"`&amp;nbsp;// 日誌級別（debug/info/warn/error）
&amp;nbsp; &amp;nbsp; Path &amp;nbsp;string&amp;nbsp;`json:"path"`&amp;nbsp;&amp;nbsp;// 日誌文件路徑
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// config/loader.go：配置加載器（支持熱更新）
package&amp;nbsp;config


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"encoding/json"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"os"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"path/filepath"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"time"


&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;"github.com/fsnotify/fsnotify"
)


// LoadConfig 加載配置文件
func&amp;nbsp;LoadConfig(path&amp;nbsp;string)&amp;nbsp;(*AppConfig,&amp;nbsp;error) {
&amp;nbsp; &amp;nbsp; file, err := os.Open(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;file.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;var&amp;nbsp;cfg AppConfig
&amp;nbsp; &amp;nbsp; decoder := json.NewDecoder(file)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := decoder.Decode(&amp;amp;cfg); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;nil, err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;&amp;amp;cfg,&amp;nbsp;nil
}


// WatchConfig 監聽配置文件變化（熱更新）
func&amp;nbsp;WatchConfig(path&amp;nbsp;string, callback&amp;nbsp;func(*AppConfig))&amp;nbsp;error&amp;nbsp;{
&amp;nbsp; &amp;nbsp; watcher, err := fsnotify.NewWatcher()
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;watcher.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 監聽配置文件所在目錄
&amp;nbsp; &amp;nbsp; dir := filepath.Dir(path)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err := watcher.Add(dir); err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;err
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;event, ok := &amp;lt;-watcher.Events:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 僅處理寫事件
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;event.Op&amp;amp;fsnotify.Write == fsnotify.Write {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 重新加載配置
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; newCfg, err := LoadConfig(path)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("加載配置失敗:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 觸發回調（通知其他模塊配置已更新）
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; callback(newCfg)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;case&amp;nbsp;err, ok := &amp;lt;-watcher.Errors:
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;!ok {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;println("配置監聽錯誤:", err.Error())
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 保持程序運行
&amp;nbsp; &amp;nbsp;&amp;nbsp;select&amp;nbsp;{}
}&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;// main.go：使用配置驅動的數據庫連接
package&amp;nbsp;main


import&amp;nbsp;(
&amp;nbsp; &amp;nbsp;&amp;nbsp;"database/sql"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"fmt"
&amp;nbsp; &amp;nbsp;&amp;nbsp;"config"
&amp;nbsp; &amp;nbsp; _&amp;nbsp;"github.com/go-sql-driver/mysql"
)


func&amp;nbsp;main()&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 加載初始配置
&amp;nbsp; &amp;nbsp; cfg, err := config.LoadConfig("config.json")
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 初始化數據庫連接
&amp;nbsp; &amp;nbsp; db, err := sql.Open("mysql", cfg.DB.DSN)
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;defer&amp;nbsp;db.Close()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 設置連接池參數（從配置中讀取）
&amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(cfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(cfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(cfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 啓動配置監聽（熱更新）
&amp;nbsp; &amp;nbsp;&amp;nbsp;go&amp;nbsp;func()&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; err := config.WatchConfig("config.json",&amp;nbsp;func(newCfg *config.AppConfig)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;// 配置更新時，重新設置數據庫連接池參數
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxOpenConns(newCfg.DB.MaxOpenConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetMaxIdleConns(newCfg.DB.MaxIdleConn)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; db.SetConnMaxLifetime(time.Duration(newCfg.DB.ConnTimeout) * time.Second)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; fmt.Println("配置已更新，數據庫連接池參數調整")
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; })
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;err !=&amp;nbsp;nil&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;panic(err)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }()
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;// 業務邏輯...
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;設計説明：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置結構化&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通過&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;AppConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;DBConfig&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;等結構體定義配置的層次結構，確保配置的清晰性和可維護性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;熱更新支持&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通過&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;fsnotify&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;監聽配置文件變化，觸發回調函數重新加載配置，並更新系統狀態（如數據庫連接池參數）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;多環境適配&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通過不同的配置文件（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-dev.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;、&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;config-prod.json&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;）或環境變量覆蓋，實現不同環境的配置隔離。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;優勢：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系統行為的調整無需修改代碼，只需修改配置文件，降低了維護成本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;支持動態調整關鍵參數（如數據庫連接池大小、日誌級別），提升了系統的靈活性和可觀測性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;五、可擴展性的驗證與演進&lt;/h1&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.1 擴展性驗證指標&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;為了確保系統具備良好的擴展性，需要從多個維度進行驗證。以下是關鍵指標及測量方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;table&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;指標&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;測量方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;目標值&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;新功能開發週期&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;統計新增一箇中等複雜度功能所需的時間（包括設計、編碼、測試）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 2 人日&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;修改影響範圍&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;統計修改一個功能時，需要修改的模塊數量和代碼行數&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 5 個模塊，&amp;lt; 500 行代碼&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;配置生效延遲&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;測量配置變更到系統完全應用新配置的時間&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 100ms&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;併發擴展能力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;測量系統在增加 CPU 核數時，吞吐量的增長比例（理想為線性增長）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;吞吐量增長 ≥ 核數增長 × 80%&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;插件加載時間&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;測量動態加載一個插件的時間&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;&amp;lt; 1 秒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#000000"&gt;&lt;span style="background-color:#ffffff"&gt;5.2 擴展性演進路線&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;系統的擴展性不是一蹴而就的，需要隨着業務的發展逐步演進。以下是一個典型的演進路線：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;graph TD
&amp;nbsp; &amp;nbsp; A[單體架構]&amp;nbsp;--&amp;gt;|垂直拆分| B[核心服務+支撐服務]
&amp;nbsp; &amp;nbsp; B&amp;nbsp;--&amp;gt;|接口抽象| C[模塊化架構]
&amp;nbsp; &amp;nbsp; C&amp;nbsp;--&amp;gt;|策略模式/中間件| D[可擴展的分佈式架構]
&amp;nbsp; &amp;nbsp; D&amp;nbsp;--&amp;gt;|插件化/配置驅動| E[雲原生可擴展架構]&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;階段 1&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;單體架構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：初期業務簡單，系統以單體形式存在。此時應注重代碼的可讀性和可維護性，為後續擴展打下基礎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;階段 2&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;核心服務+支撐服務&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：隨着業務增長，將核心功能（如訂單、用戶）與非核心功能（如日誌、監控）拆分，降低耦合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;階段 3&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;模塊化架構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：通過接口抽象和依賴倒置，將系統拆分為高內聚、低耦合的模塊，支持獨立開發和部署。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;階段 4&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可擴展的分佈式架構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：引入策略模式、中間件鏈等模式，支持動態切換算法和處理流程，適應多樣化的業務需求。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;階段 5&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;雲原生可擴展架構&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;：結合容器化（Docker）、編排（Kubernetes）和 Serverless 技術，實現資源的彈性擴展和自動伸縮。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&amp;nbsp;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_6"&gt;&lt;/span&gt; 
&lt;h1&gt;六、結，語&lt;/h1&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;可擴展性設計是軟件系統的「生命力」所在。通過遵循開閉原則、模塊化設計等核心原則，結合策略模式、中間件鏈、插件化架構等 Go 語言友好的編碼模式，開發者可以構建出適應業務變化的「生長型」系統。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;需要注意的是，擴展性設計並非追求「過度設計」，而是在當前需求和未來變化之間找到平衡。建議定期進行架構評審，通過壓力測試和代碼分析（如&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#e5e5e5"&gt;go mod graph&lt;/span&gt;&lt;/span&gt;&lt;span style="color:#3e3e3e"&gt;查看模塊依賴）評估系統的擴展性健康度，及時調整設計策略。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;最後，記住：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;優秀的系統不是完美的，而是能夠持續進化的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;。保持開放的心態，擁抱變化，才能在快速發展的技術領域中立於不敗之地。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:24px; margin-right:24px; text-align:center"&gt;&lt;span&gt;&lt;strong&gt;&lt;span style="color:#ffffff"&gt;&lt;span style="background-color:#5caae9"&gt;往期回顧&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;1.&amp;nbsp;得物新商品審核鏈路建設分享&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;2.&amp;nbsp;營銷會場預覽直通車實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;3.&amp;nbsp;基於 TinyMce 富文本編輯器的客服自研知識庫的技術探索和實踐｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;4.&amp;nbsp;AI 質量專項報告自動分析生成｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:16px; margin-right:16px"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#6a6a6a"&gt;&lt;span style="background-color:#e9faff"&gt;5.&amp;nbsp;Rust 性能提升「最後一公里」：詳解 Profiling 瓶頸定位與優化｜得物技術&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;文 / 悟&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:center"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#3e3e3e"&gt;&lt;span style="background-color:#ffffff"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18689869</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18689869</guid>
      <pubDate>Thu, 28 Aug 2025 07:29:39 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>騰訊混元開源端到端視頻音效生成模型 HunyuanVideo-Foley</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;騰訊混元宣佈開源端到端視頻音效生成模型 HunyuanVideo-Foley，&lt;strong&gt;只需輸入視頻和文字，就能&lt;strong&gt;&lt;strong&gt;為&lt;/strong&gt;&lt;/strong&gt;視頻&lt;strong&gt;&lt;strong&gt;匹配&lt;/strong&gt;&lt;/strong&gt;電影級音效&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;比如，輸入文本描述"With a faint sound as their hands parted, the two embraced, a soft 'mm' escaping between them.」&lt;/p&gt; 
&lt;p&gt;就會得到一個聲色俱佳的視頻：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/151052_IFKo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;技術亮點&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;泛化能力強&lt;/strong&gt;：適配人物、動物、自然景觀、卡通動畫等各類視頻，生成精準匹配畫面的音頻。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;多模態語義均衡響應&lt;/strong&gt;：創新雙流多模態擴散變換器（MMDIT）架構，平衡文本與視頻語義，避免「顧文失畫」問題。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;專業級音頻保真度&lt;/strong&gt;：引入表徵對齊（REPA）損失函數，抑制底噪，確保音頻質量達到專業製作水準。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-8072afd58fae2af02917f8e2c87f453b039.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;官方介紹稱，HunyuanVideo-Foley 不僅打破了 AI&amp;nbsp;生成的視頻只能 「看」 不能 「聽」 的侷限，讓無聲 AI 視頻成為歷史，更是真正做到了 「看懂畫面、讀懂文字、配準聲音」 ，帶來沉浸式視聽體驗。這款音效生成工具可廣泛應用於短視頻創作、電影製作、廣告創意和遊戲開發等場景。&lt;/p&gt; 
&lt;p&gt;即日起，用戶可在 Github,HuggingFace 下載模型，也可以在混元官網直接體驗。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;體驗入口：https://hunyuan.tencent.com/video/zh?tabIndex=0&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;項目官網：https://szczesnys.github.io/hunyuanvideo-foley/&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;代碼：https://github.com/Tencent-Hunyuan/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;技術報告：https://arxiv.org/abs/2508.16930&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Hugging Face：https://huggingface.co/tencent/HunyuanVideo-Foley&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368967</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368967</guid>
      <pubDate>Thu, 28 Aug 2025 07:12:39 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源 IDE 項目 Zed 完成 3200 萬美元 B 輪融資</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源 IDE 項目 Zed &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fsequoia-backs-zed" target="_blank"&gt;宣佈&lt;/a&gt;完成 3200 萬美元 B 輪融資，由紅杉資本領投，使其累計融資總額突破 4200 萬美元。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-08cd4e91d1394290d041152f5dcb7ef153e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zed 最初因「極致性能的代碼編輯器」受到關注，而此次融資背後的核心目標，是推動其向協作平台轉型。團隊提出的重點創新是 DeltaDB ——一種基於操作級別（edit-level）的全新版本控制系統，能夠記錄每一次字符修改，並與討論、AI 建議深度綁定。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/150503_ItlB_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;與傳統依賴 Git 快照的開發方式不同，DeltaDB 採用 CRDT 技術實現實時同步，並提供「字符級永久鏈接」，讓代碼討論和歷史演化可以直接嵌入到 IDE 中。Zed 希望藉此打造出一個既能支撐團隊協作，也能與 AI 高效共創的開發環境。&lt;/p&gt; 
&lt;p&gt;未來，Zed 與 DeltaDB 都將繼續保持開源，並探索付費服務模式。同時，團隊也在積極擴招，涵蓋字體渲染、GPU Shader、編輯預測模型等方向。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368962/sequoia-backs-zed-32m</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368962/sequoia-backs-zed-32m</guid>
      <pubDate>Thu, 28 Aug 2025 07:06:39 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源代碼編輯器 Zed 推出智能體集成協議：Agent Client Protocol (ACP)</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;開源編輯器 &lt;strong&gt;Zed&lt;/strong&gt; 宣佈推出全新的 &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fbring-your-own-agent-to-zed" target="_blank"&gt;&lt;strong&gt;Agent Client Protocol (ACP)&lt;/strong&gt;&lt;/a&gt;，這一協議讓開發者可以在編輯器中自由接入任意第三方智能體（Agent），無需依賴官方內置工具。其理念類似於 &lt;strong&gt;語言服務器協議（LSP）&lt;/strong&gt;，通過解耦編輯器與智能體的交互方式，提供更靈活的擴展能力。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-2f621ad18024ec580d997b820ea9139346e.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/zed-industries/agent-client-protocol&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;首個落地案例是與 &lt;strong&gt;Google Gemini CLI&lt;/strong&gt; 的合作。Zed 已在終端中集成該工具，並通過 &lt;strong&gt;JSON-RPC&lt;/strong&gt; 替代傳統的 ANSI 轉義碼，實現更精準的交互。這讓開發者在 Zed 內獲得了更流暢的 AI 編程體驗：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;實時可視化的智能編輯體驗&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持多緩衝區（multi-buffer）查看和審閲&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在代碼與智能體交互之間實現流暢導航&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-de6cc0bed05ae096d65f7a6d98e326feab1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，ACP 協議已經以 Apache 開源許可證發佈，任何開發者都可基於它集成自己的 AI Agent。目前不僅 Zed 內置的智能體已遷移到這一統一框架，社區中也有人正探索將 ACP 帶到 Neovim 等其他編輯器。這意味着所有為內置 Agent 開發的用戶界面組件，也會開箱即用支持外部智能體。這種內核與 UI 的清晰分離顯著加快了 Zed 的迭代速度。&lt;/p&gt; 
&lt;p&gt;Zed 團隊表示，他們希望 ACP 能像 LSP 一樣成為行業標準，推動形成一個開放、健康的智能體生態系統。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368957/bring-your-own-agent-to-zed</guid>
      <pubDate>Thu, 28 Aug 2025 06:51:39 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>​騰訊開源智能體框架 Youtu-agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;騰訊近日發佈了 Youtu-agent，這是一個靈活且高性能的框架，旨在構建、運行和評估自主智能體。該框架不僅在基準測試中表現出色，還提供了強大的智能體能力，如數據分析、文件處理和深入研究，所有這些功能都基於開源模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 的主要特點之一是其經過驗證的性能。在 WebWalkerQA 基準測試中，該框架使用 DeepSeek-V3 系列模型達到了 71.47% 的準確率，而在 GAIA 基準測試中，達到了 72.8% 的準確率，顯示出開源模型的強大潛力。通過優化框架，Youtu-agent 實現了低成本、便捷的部署，無需依賴封閉模型。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="398" src="https://oscimg.oschina.net/oscnet/up-df9ff0c7515f666fdb5c9d2c521ef538464.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;此外，Youtu-agent 還支持多種實際應用場景，包括 CSV 分析、文獻綜述、個人文件整理，以及即將推出的播客和視頻生成。它採用了靈活的架構，支持多樣的模型 API，從 DeepSeek 到 gpt-oss 都可兼容，方便用戶進行擴展和集成。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="299" src="https://oscimg.oschina.net/oscnet/up-30ecda52cd4aeefc59ae83bccbe4a385e80.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;在自動化和簡化操作方面，Youtu-agent 引入了基於 YAML 的配置，用戶可以通過簡單的配置文件快速生成智能體。其內置的 「元智能體」 能夠與用戶交互，自動捕捉需求並生成配置。這種方法大大減少了手動設置的工作量，讓用戶能迅速上手。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Youtu-agent 還擁有全異步執行的特性，極大地提高了性能效率，特別是在評估基準時的表現尤為突出。該框架不僅支持用戶進行深入研究和數據收集，還能幫助開發者快速構建現實世界中的智能體應用。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;為了幫助用戶更快上手，Youtu-agent 提供了詳細的文檔和示例，用戶只需簡單的腳本便能運行多種智能體，極大地降低了學習曲線。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368953</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368953</guid>
      <pubDate>Thu, 28 Aug 2025 06:41:39 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>互聯網標準組織發佈新草案，提議網頁標註 AI 使用情況</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;互聯網工程任務組（IETF）近日發佈《AI 內容披露頭字段》（AI Content Disclosure Header）草案，提議在網頁 HTTP 響應中新增可機讀的 AI 使用標記，以説明 AI 在內容生成中的參與情況。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143226_iWtj_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;em&gt;https://www.ietf.org/archive/id/draft-abaris-aicdh-00.html&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;該草案擬為網頁服務器響應添加一個新的 HTTP 頭字段，用於標記人工智能在網頁內容生成中的參與情況，目標是在保持低資源消耗的前提下，讓搜索引擎、歸檔系統及瀏覽器等能夠快速識別 AI 相關內容。&lt;/p&gt; 
&lt;p&gt;此頭字段將包含五個主要信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;mode（AI 使用模式）&lt;/li&gt; 
 &lt;li&gt;model（使用的 AI 模型名稱）&lt;/li&gt; 
 &lt;li&gt;provider（模型提供方）&lt;/li&gt; 
 &lt;li&gt;reviewed-by（內容審查人）&lt;/li&gt; 
 &lt;li&gt;date（生成或修改日期時間）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其中，mode 有四種取值：none（未使用 AI 生成或修改內容）、ai-modified（原有人類創作，經 AI 修改）、ai-originated（內容由 AI 生成，經人工編輯修改並審核）、machine-generated（幾乎完全由 AI 生成，幾乎無人為幹預）。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0828/143133_J3wR_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;與現有的 AI 生成內容提示（如文字聲明或圖片/視頻水印）不同，這一 HTTP 頭字段無需依賴人工判斷或解析複雜元數據文件，是完全機器可讀的，可幫助搜索引擎進行更精準的索引，提升合規審查和數據歸檔的效率。&lt;/p&gt; 
&lt;p&gt;IETF 指出，這種標準化的標記方式可為網絡爬蟲、內容分析工具和歸檔系統提供低延遲的 AI 檢測途徑，減少不必要的計算和資源浪費。目前，該草案尚未成為正式標準，未來可能根據業界反饋進一步調整和擴展。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368947</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368947</guid>
      <pubDate>Tue, 19 Aug 2025 06:32:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>研發提效新選擇：Oinone 企業級產品化引擎正式開源 ，邀你體驗</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;不少軟件企業長期陷於「交付優先」，重複開發、規範難落地、資產難沉澱，既要應對高強度的個性化需求，又要維護統一標品，效率與質量常陷拉扯。解決的關鍵是將產品迭代與項目交付分離，在統一架構下沉澱可複用的模塊與擴展包，讓項目逐步轉化為可升級、可規模化的標品&lt;/p&gt; 
&lt;p&gt;Oinone 產品化架構&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span style="color:#035dff"&gt;&lt;strong&gt;上層承接客戶差異化與行業特性，中層直面市場的標準業務產品，底層沉澱通用能力與標準，確保迭代穩定&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。通過將需求拆解為模塊與擴展包，實現標準化與個性化在同一框架內協同；依託低&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;無代碼一體化、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;「&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;被集成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span style="color:rgba(0, 0, 0, 0.9)"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;原則及國產化全棧支持，保障生態適配與持續演進。現場演示中，標準產品與個性化需求都能快速落地，開發到上線全程在統一規範下完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;Oinone demo 體驗&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-spacing:0px; box-sizing:border-box; color:#40485b; display:block; font-family:-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Segoe UI&amp;quot;,Helvetica,Arial,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Liberation Sans&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Wenquanyi Micro Hei&amp;quot;,&amp;quot;WenQuanYi Zen Hei&amp;quot;,&amp;quot;ST Heiti&amp;quot;,SimHei,SimSun,&amp;quot;WenQuanYi Zen Hei Sharp&amp;quot;,sans-serif; font-size:16px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:normal; margin-bottom:16px; margin-top:0px; orphans:2; overflow:auto; text-align:left; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:856px; word-break:initial; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;演示環境&lt;/th&gt; 
   &lt;th&gt;相關視頻&lt;/th&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fdemo.oinone.top" target="_blank"&gt;⚡ 直達演示環境&lt;/a&gt;&lt;br&gt; ☕ 賬號：admin&lt;br&gt; ☕ 密碼：admin&lt;/td&gt; 
   &lt;td style="border-color:#dfe2e5; border-style:solid; border-width:1px; vertical-align:revert !important"&gt; &lt;p&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEts%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 1. [數式 Oinone] #產品化演示# 後端研發與無代碼輔助&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1DoMizbECt%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 2. [數式 Oinone] #產品化演示# 前端開發&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1RDMizYELg%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 3. [數式 Oinone] #個性化二開# 後端邏輯&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYED1%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 4. [數式 Oinone] #個性化二開# 前端交互&lt;/a&gt;&lt;br&gt; &lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eDMizYEdF%2F%3Fvd_source%3Dee004011d0afa992f50d15c8738450b3" target="_blank"&gt;🎬 5. [數式 Oinone] #個性化二開# 無代碼模式&lt;/a&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h1&gt;6.2.0 版本正式開源&lt;/h1&gt; 
&lt;ul&gt; 
 &lt;li&gt;Gitee: 
  &lt;ul&gt; 
   &lt;li&gt;後端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250822 升級內容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;鏡像版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;後端版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;修復集成設計器新建或複製 API 時未正確記錄日誌的問題&lt;/li&gt; 
 &lt;li&gt;修復發佈為開放接口時出入參轉換異常的問題&lt;/li&gt; 
 &lt;li&gt;修復開放接口調用集成接口時日誌保存異常的問題&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250818 升級內容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;鏡像版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;後端版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;前端版本升級&lt;/li&gt; 
 &lt;li&gt;集成應用-集成接口新增測試功能&lt;/li&gt; 
 &lt;li&gt;集成設計器集成接口詳情頁面新增測試功能&lt;/li&gt; 
 &lt;li&gt;集成設計器 body 參數支持保留空值功能&lt;/li&gt; 
 &lt;li&gt;集成設計器的集成接口發佈為開放接口後，刪除時進行二次確認提示&lt;/li&gt; 
 &lt;li&gt;集成設計器數據庫連接支持斷開連接和重新連接功能（支持分佈式啓停）&lt;/li&gt; 
 &lt;li&gt;集成設計器 WebService API 支持 xml 解析功能&lt;/li&gt; 
 &lt;li&gt;修復元數據繼承計算未正確處理由界面設計器創建的提交動作的問題&lt;/li&gt; 
 &lt;li&gt;修復界面設計器複製視圖到子模型時無法複製提交動作的問題&lt;/li&gt; 
 &lt;li&gt;修復界面設計器複製時切換模型時驗證不通過的問題&lt;/li&gt; 
 &lt;li&gt;修復從上游生成的菜單無法正確導出的問題&lt;/li&gt; 
 &lt;li&gt;修復集成設計器導出時出現 getDriver 序列化異常的問題&lt;/li&gt; 
 &lt;li&gt;修復數據可視化快捷日期選擇錯誤的問題&lt;/li&gt; 
 &lt;li&gt;開放 dataflow-api 和 eip-designer-api 包&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;doc 教程文檔：https://guide.oinone.top/zh-cn/DevManual/Tutorials/#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0%E5%90%8E%E7%AB%AF%E5%92%8C%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368943</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368943</guid>
      <pubDate>Tue, 19 Aug 2025 06:26:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>阿里雲百鍊部分模型將從限時免費改為限時額度</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;阿里雲百鍊&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.aliyun.com%2Fnotice%2F117503" target="_blank"&gt;宣佈&lt;/a&gt;，部分模型調用計費將於北京時間 2025 年 8 月 29 日 03:00 起從限時免費變更為發放限時免費額度。用戶將享受 100 萬的免費 token 額度，免費額度用盡後平台將自動停止服務。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;本次影響模型範圍如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;img height="168" src="https://oscimg.oschina.net/oscnet/up-d9dd38cf3830efd579ab292f1f353d732f6.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368942</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368942</guid>
      <pubDate>Tue, 19 Aug 2025 06:23:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>理想汽車可以寫遊戲代碼，還能直接在車機上玩</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;理想汽車產品線負責人@老湯哥 Tango 在微博發佈」理想同學「寫遊戲代碼的視頻，從響應需求到遊戲生成持續了約 3 分鐘時間。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-581559e21893b110ff447556e3176c9d526.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-004e5ec1d909771531577171d2f8b3a2f8a.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-ff70aabed01e3e77bca5848c5bc95395622.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-786b0c2666f658ebc6f9a070a9111477fa8.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-eda646532086b95eb00c99dde042c4f0d64.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據理想官方介紹，理想同學手機、網頁端已正式接入 DeepSeek R1-0528 最新版，切換「DeepSeek 模型」並開啓「深度思考」模式即可體驗最新的 AI 問答、創作能力。&lt;/p&gt; 
&lt;p&gt;據悉，更新後的 R1 模型在數學、編程與通用邏輯等多個基準測評中取得了當前國內所有模型中首屈一指的優異成績，並且在整體表現上已接近其他國際頂尖模型，如 o3 與 Gemini-2.5-Pro。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368941</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368941</guid>
      <pubDate>Tue, 19 Aug 2025 06:22:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>a16z 最新 AI 報告：移動端 Top50 的應用中 22 款由中國開發</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;根據風險投資公司 Andreessen Horowitz 最新發布的一份專注於消費者 AI 領域的新&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fa16z.com%2F100-gen-ai-apps-5%2F" target="_blank"&gt;報告&lt;/a&gt;， ChatGPT 的競爭對手，如谷歌的 Gemini、xAI 的 Grok 以及 Meta AI，正在縮小與 ChatGPT 的差距。&lt;/p&gt; 
&lt;p&gt;該報告已是第五次發佈。14 家公司第五次出現在頂級 AI 產品榜單上：ChatGPT、Perplexity、Poe、Character AI、Midjourney、Leonardo、Veed、Cutout、ElevenLabs、Photoroom、Gamma、QuillBot、Civitai 和 Hugging Face。&lt;/p&gt; 
&lt;p&gt;&lt;img height="288" src="https://oscimg.oschina.net/oscnet/up-504e271a3f148910434873e07a715ea1259.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該公司指出，除第一份報告外，其他五家公司都出現在了報告中，包括 Claude、DeepAI、Janitor AI、Pixelcut 和 Suno，分別代表通用人工智能應用、陪伴、圖像編輯和音樂生成。&lt;/p&gt; 
&lt;p&gt;&lt;img height="305" src="https://oscimg.oschina.net/oscnet/up-2e8fb44cb4232566939732e5f0076528ea9.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在本系列報告中，谷歌首次在頂級生成式 AI 消費網絡產品榜單上增加了四個席位，分別是 Gemini、AI Studio、NotebookLM 和 Google Labs。這些產品現在擁有各自獨立的域名，因此可以分別跟蹤它們的增長情況。&lt;/p&gt; 
&lt;p&gt;&lt;img height="378" src="https://oscimg.oschina.net/oscnet/up-752ac9ec98d43bf0cfd8c70cd9bc8752cbd.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;值得注意的是，在移動設備上，排名第二的應用 Gemini 正在縮小與排名第一的應用 ChatGPT 的差距，但月活躍用戶數幾乎只有後者的一半。Gemini 的 AI 技術在 Android 平台上的應用更為廣泛，佔據了近 90% 的月活躍用戶羣。在網頁端，Gemini 也僅次於 ChatGPT，排名第二，約佔 ChatGPT 訪問量的 12%。&lt;/p&gt; 
&lt;p&gt;&lt;img height="323" src="https://oscimg.oschina.net/oscnet/up-e433ed7d554499571d95f76fdf1bb182f1c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;該公司的 AI Studio 是一款面向開發人員的 &lt;span style="color:#212623"&gt;sandbox&lt;/span&gt;，用於使用 Gemini 模型進行構建，進入了十大 AI 網絡產品榜單，位居第十位；NotebookLM 排名第十三。&lt;/p&gt; 
&lt;p&gt;&lt;img height="335" src="https://oscimg.oschina.net/oscnet/up-1d046af086fb1c731602a315ddfd7f282c1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Grok 在網頁端排名第四，移動端排名第 23。考慮到 Grok 從 2024 年底還沒有獨立應用（在 X 上首次推出）到現在擁有多達 2000 萬月活躍用戶，這是一個快速的增長。2025 年 7 月， Grok 4 發佈後，Grok 的用戶增長了近 40% 。&lt;/p&gt; 
&lt;p&gt;&lt;img height="326" src="https://oscimg.oschina.net/oscnet/up-7276f5b0dc0753d758a96bbb20c8d2c2bba.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Meta 的通用助手在網絡上排名第 46 位，與 3 月份相同，但它並未進入頂級移動 AI 應用榜單。部分原因是，有消息稱 Meta AI 在未經用戶知情同意的情況下，公開分享了部分用戶的帖子。&lt;/p&gt; 
&lt;p&gt;&lt;img height="306" src="https://oscimg.oschina.net/oscnet/up-490ce7eaf61c586775a809535a4137b600c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;DeepSeek 和 Claude 在移動端的增長也趨於平緩，前者從峯值下降了 22%。在網頁端，DeepSeek 的下降幅度更大，較 2025 年 2 月的峯值下降了 40% 以上。然而，Perplexity 和 Claude 仍在繼續增長。&lt;/p&gt; 
&lt;p&gt;其他中國 AI 開發者也進入了網絡榜單前 20 名，包括排名第 9 的阿里巴巴 AI 助手夸克（移動榜單第 47 位）；排名第 12 的豆寶（移動榜單第 4 位）；以及排名第 17 的 Kimi。這些公司都擁有中文網站，75% 的流量來自中國。&lt;/p&gt; 
&lt;p&gt;Web 榜單上還有七家公司在中國發展，但將其 AI 技術出口到全球：DeepSeek、Hailuo、Kling、SeaArt、Cutout Pro、Manus 和 Monica。&lt;/p&gt; 
&lt;p&gt;在移動端，排名前 50 的應用中有 22 款由中國開發，但主要在中國使用的只有 3 款。其中，排名靠前的包括美圖（Photo &amp;amp; Video Editor, BeautyPlus, BeautyCam, Wink 和 Airbrush）、字節跳動（豆寶和 Cici）、Gauth 和 Hypic。&lt;/p&gt; 
&lt;p&gt;氛圍編碼初創公司 Lovable 和 Replit 此次首次亮相主榜單，而它們在 a16z 今年 3 月發佈的榜單中均未入選。&lt;/p&gt; 
&lt;p&gt;&lt;img height="189" src="https://oscimg.oschina.net/oscnet/up-05006cf5ea2bdd595a0a2b22c96ea9aa400.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Andreessen Horowitz 還花時間列舉了即將躋身頂級 AI 應用程序榜單的 AI 應用程序，包括網絡上的 PixAI、Bolt、Blackbox AI、Clipchamp 和 Getliner，以及移動設備上的 Talkie、Seekee、Photo AI、AI Mirror 和 Arvin。&lt;/p&gt; 
&lt;p&gt;該公司指出，本月報告中的移動榜單中新上榜的應用（14 個）已經比以前更多，因為兩個應用商店早已嚴厲打擊 ChatGPT 的模仿者和克隆產品，從而讓更多原創應用找到了立足之地。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368938</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368938</guid>
      <pubDate>Tue, 19 Aug 2025 06:13:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Meta 計劃推出超級政治行動委員會，力挺 AI 監管輕鬆化</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 公司計劃成立一個新的超級政治行動委員會（PAC），旨在支持那些倡導輕鬆化人工智能 (AI) 監管的加州候選人。這一消息的發佈恰逢其他硅谷巨頭，如安德森・霍洛維茨和 OpenAI 的格雷格・布羅克曼，共同承諾為一個新的支持 AI 的超級&amp;nbsp;PAC 提供 1 億美元的資金。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="242" src="https://oscimg.oschina.net/oscnet/up-e60c86bbcc18a7651619abeab3ca5d668e1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;據悉，Meta 將在其新成立的 PAC 「加州經濟轉型動員」（Mobilizing Economic Transformation Across California）中投入數千萬美元。Meta 公共政策副總裁兼新 PAC 負責人布賴恩・瑞斯 (Brian Rice) 表示，薩克拉門託的監管環境可能會抑制創新，阻礙 AI 進步，並危及加州在科技領域的領導地位。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;今年早些時候，Meta 的遊説力量曾針對加州州參議員斯科特・維納（Scott Wiener）的 SB-53 法案進行幹預，該法案要求 AI 公司公佈安全和安保協議，並在發生安全事件時發佈報告。去年，Meta 還幫助阻止了廣受期待的《兒童在線安全法案》。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;Meta 已經向各黨派的下級候選人捐款，而這個新 PAC 的成立則表明了其希望在包括 2026 年下任州長選舉在內的州級選舉中產生影響的意圖。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368931</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368931</guid>
      <pubDate>Tue, 19 Aug 2025 05:39:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>正式版發佈：Oinone 6.2.0 版本 Oinone 正式開源，邀您體驗</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;6.2.0 版本&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Gitee: 
  &lt;ul&gt; 
   &lt;li&gt;後端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250822 升級內容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;鏡像版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;後端版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.12&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;修復集成設計器新建或複製 API 時未正確記錄日誌的問題&lt;/li&gt; 
 &lt;li&gt;修復發佈為開放接口時出入參轉換異常的問題&lt;/li&gt; 
 &lt;li&gt;修復開放接口調用集成接口時日誌保存異常的問題&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;20250818 升級內容&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;鏡像版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;後端版本升級:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.10&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;--&amp;gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;6.2.11&lt;/code&gt;&lt;/li&gt; 
 &lt;li&gt;前端版本升級&lt;/li&gt; 
 &lt;li&gt;集成應用-集成接口新增測試功能&lt;/li&gt; 
 &lt;li&gt;集成設計器集成接口詳情頁面新增測試功能&lt;/li&gt; 
 &lt;li&gt;集成設計器 body 參數支持保留空值功能&lt;/li&gt; 
 &lt;li&gt;集成設計器的集成接口發佈為開放接口後，刪除時進行二次確認提示&lt;/li&gt; 
 &lt;li&gt;集成設計器數據庫連接支持斷開連接和重新連接功能（支持分佈式啓停）&lt;/li&gt; 
 &lt;li&gt;集成設計器 WebService API 支持 xml 解析功能&lt;/li&gt; 
 &lt;li&gt;修復元數據繼承計算未正確處理由界面設計器創建的提交動作的問題&lt;/li&gt; 
 &lt;li&gt;修復界面設計器複製視圖到子模型時無法複製提交動作的問題&lt;/li&gt; 
 &lt;li&gt;修復界面設計器複製時切換模型時驗證不通過的問題&lt;/li&gt; 
 &lt;li&gt;修復從上游生成的菜單無法正確導出的問題&lt;/li&gt; 
 &lt;li&gt;修復集成設計器導出時出現 getDriver 序列化異常的問題&lt;/li&gt; 
 &lt;li&gt;修復數據可視化快捷日期選擇錯誤的問題&lt;/li&gt; 
 &lt;li&gt;開放 dataflow-api 和 eip-designer-api 包&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368921</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368921</guid>
      <pubDate>Tue, 19 Aug 2025 04:21:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>英偉達單季營收 467 億美元暴漲 56%</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;英偉達（&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnvidianews.nvidia.com%2Fnews%2Fnvidia-announces-financial-results-for-second-quarter-fiscal-2026" target="_blank"&gt;公佈&lt;/a&gt;截至 2025 年 7 月 27 日的第二季度營收為 467 億美元，環比增長 6%，同比增長 56%。NVIDIA Blackwell 數據中心營收環比增長 17%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第二季度，中國客戶未售出 H20 芯片。NVIDIA 受益於此前釋放的 1.8 億美元 H20 庫存，這得益於此前向中國境外客戶無限制銷售約 6.5 億美元的 H20 芯片。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 毛利率分別為 72.4% 和 72.7%。若不計入 1.8 億美元釋放，本季度非 GAAP 毛利率應為 72.3%。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;本季度，GAAP 和非 GAAP 稀釋每股收益分別為 1.08 美元和 1.05 美元。若不計 1.8 億美元釋放及相關稅費影響，本季度非 GAAP 稀釋每股收益為 1.04 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 創始人兼首席執行官黃仁勳表示：「Blackwell 是全世界翹首以盼的 AI 平台，它實現了非凡的跨越式發展——Blackwell Ultra 的產量正在全速提升，市場需求也異常旺盛。NVIDIA NVLink 機架級計算技術具有革命性，它的到來恰逢推理 AI 模型推動訓練和推理性能數量級提升的時代。AI 競賽已拉開帷幕，而 Blackwell 正是這場競賽的核心平台。」&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2026 財年上半年，NVIDIA 以股票回購和現金股息的形式向股東返還了 243 億美元。截至第二季度末，公司剩餘的股票回購授權金額為 147 億美元。2025 年 8 月 26 日，董事會批准公司額外增加 600 億美元的股票回購授權，且該授權金額無有效期。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 將於 2025 年 10 月 2 日向 2025 年 9 月 11 日登記在冊的所有股東支付下一季度現金股息，每股 0.01 美元。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="175" src="https://oscimg.oschina.net/oscnet/up-0884edd1756e5c3e624f756bf9373b7e007.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0"&gt;&lt;img height="233" src="https://oscimg.oschina.net/oscnet/up-bf88c6496d006ca5fa7f48b7ede76abe46b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1a1a1a"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;NVIDIA 對 2026 財年第三季度的展望如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc"&gt; 
 &lt;li&gt;預計營收為 540 億美元，上下浮動 2%。該公司在展望中未考慮任何 H20 對華出口。&lt;/li&gt; 
 &lt;li&gt;預計 GAAP 和非 GAAP 毛利率分別為 73.3% 和 73.5%，上下浮動 50 個基點。公司預計今年年底的非 GAAP 毛利率將保持在 70% 左右。&lt;/li&gt; 
 &lt;li&gt;預計 GAAP 和非 GAAP 運營費用分別約為 59 億美元和 42 億美元。預計 2026 財年全年運營費用增長率將達到 30% 以上。&lt;/li&gt; 
 &lt;li&gt;預計 GAAP 和非 GAAP 其他收入和支出約為 5 億美元的收入，不包括非流通股本證券和公開持有的股權證券的損益。&lt;/li&gt; 
 &lt;li&gt;預計 GAAP 和非 GAAP 稅率為 16.5%，上下浮動 1%，不包括任何單項項目。&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368915</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368915</guid>
      <pubDate>Tue, 19 Aug 2025 03:44:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>智譜開源項目閲讀工具 Zread 發佈更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;a href="https://www.oschina.net/news/361635" target="_blank"&gt;Zread&lt;/a&gt; 是智譜為幫助用戶閲讀和理解複雜開源項目打造的 AI 工具，其功能類似於 Cognition 推出的 DeepWiki，優點是支持中文，目前已經索引了大部分熱門開源項目，冷門代碼倉庫可以申請發起索引。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-47cb47c2059cdf185a53799496a0fbd8091.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Zread 近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FZread_ai%2Fstatus%2F1960734929639145494" target="_blank"&gt;發佈更新&lt;/a&gt;增加了三大功能：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;根據用戶設定的主題，提供個性化的代碼倉庫推薦&lt;/li&gt; 
 &lt;li&gt;支持查看 AI 回答背後的搜索來源，增加透明度&lt;/li&gt; 
 &lt;li&gt;支持一鍵刷新倉庫，以方便用戶獲取最新的代碼更新&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;體驗：&lt;em&gt;https://zread.ai/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368914</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368914</guid>
      <pubDate>Tue, 19 Aug 2025 03:43:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>OpenSearch Software Foundation 一週年慶</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;作為 OpenSearch 項目的中立平台，&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#000000"&gt;OpenSearch&amp;nbsp;&lt;/span&gt;&lt;span&gt;Software Foundation 慶祝其在 Linux 基金會下成立一週年。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;公告稱，成立首年，基金會致力於發展和壯大 OpenSearch 開源平台，推動 AI 驅動的搜索、可觀測性和分析技術。通過持續的功能開發、社區參與擴大和行業融合，OpenSearch 已成為現代數據驅動應用的基礎技術。隨着行業向 Agentic AI 轉型，OpenSearch Software Foundation 將繼續打造高性能、完全開源的信息檢索平台，支持更快、更高效的 AI 開發與實時洞察。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;img height="264" src="https://oscimg.oschina.net/oscnet/up-e3edcc23f4749032fea4ca2f17aba64a082.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;Linux 基金會法律與戰略項目高級副總裁 Mike Dolan 表示：「OpenSearch 在 Linux 基金會下的首年進展，展現了開放協作在應對現代數據挑戰中的力量。項目增長和社區活躍證明瞭開源在現代搜索和分析基礎設施中的關鍵作用。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;自 2024 年 9 月基金會成立以來，OpenSearch 項目下載量同比增長 78%，累計下載超過 10 億次。首年成果包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;社區活躍度提升，超 400 家活躍貢獻組織，貢獻超過 8800 次&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;全球協作增強，美國、德國、英國、澳大利亞和印度貢獻最多&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;會員擴展至 16 家新組織，新增 ByteDance、DataStax、DTEX 和 Seacom Srl&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;組建由 15 名成員組成的技術指導委員會，涵蓋 Aryn、AWS、ByteDance、IBM、Paessler、Salesforce、SAP 和 Uber 等企業與獨立機構&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;3.0、3.1 和 3.2 版本亮點：&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量引擎和 Agentic AI 能力增強，推動生成式 AI 創新&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;向量數據庫功能增強&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通過 Model Context Protocol (MCP) 和 GPU 加速，支持原生 Agentic AI，簡化開發部署&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;支持新型 FP16、Byte 和二進制向量類型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提高資源利用效率，構建更廣泛的 GPU 加速應用&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本引入的實驗性查詢類型，支持自然語言交互，觸發基於 Agent 的查詢理解、規劃與執行&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Agentic 記憶&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 實驗功能，支持 AI 代理利用語義搜索調用歷史上下文，提升後續會話質量&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;混合搜索速度和效率提升，實現實時洞察&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;搜索性能增強&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：OpenSearch 3.2 查詢速度較 1.3 版本快 11 倍，混合搜索算法提升查詢速度達 65%，吞吐量提升 3.5 倍&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;gRPC 支持正式發佈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：加快數據傳輸與處理效率&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;近似查詢框架升級&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 版本提升分頁搜索、實時儀表盤和分析工作負載響應速度，擴展所有數值字段類型的近似查詢能力&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;流式聚合功能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：3.2 實驗功能，基於流式傳輸，優化資源分配，實現協調器單點擴展&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;高級可觀測性功能提升準確性與效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;跨集羣 Trace 搜索&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：支持企業跨集羣無縫追蹤分析&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Piped Processing Language (PPL) 升級&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升複雜查詢性能和準確性，簡化複雜日誌分析流程&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;平台現代化，助力未來社區協作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul style="list-style-type:disc; margin-left:0; margin-right:0"&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;升級 Lucene 10&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提升性能和可維護性，支持日益壯大的開源開發者社區貢獻&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;OpenSearch Software Foundation 治理委員會主席、AWS 產品管理總監 Carl Meadows 表示：「進入第二年，我們將繼續發力，打造 AI 時代最強大的開源搜索、分析和可觀測性平台。社區和會員的堅實基礎讓我們能應對行業挑戰，持續交付開發者和企業信賴的技術。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#000000; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;行業領導者貢獻亮點：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;ByteDance&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：為 OpenSearch k-NN 貢獻派生源功能，並優化分段複製協議性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;IBM DataStax&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：貢獻 JVector 引擎，為向量搜索提供純 Java 實現並支持 AstraDB 集成&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Intel&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：貢獻 SIMD 支持，提升 k-NN 在支持硬件上的性能&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;SAP&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：推動 FIPS 合規支持，滿足特定安全規範需求&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="color:#000000"&gt;&lt;span&gt;Uber&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：貢獻基於拉取的採集方式，簡化客戶端配置，支持 OpenSearch 直接集成現有系統&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368909</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368909</guid>
      <pubDate>Tue, 19 Aug 2025 03:35:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Linux 內核貢獻者藉助 AI 判斷是否回退補丁到穩定版本</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Linux 長期支持（LTS）分支的維護工作正在嘗試引入生成式 AI 技術，以幫助判斷哪些補丁需要回退到穩定版本。&lt;/p&gt; 
&lt;p&gt;目前，開發者通常會在補丁中添加 「CC: stable」 標籤，提醒維護者將其回退。但不少補丁並未明確標註，導致 LTS 維護負擔較重。為此，Linux LTS 聯合維護者、現任 NVIDIA 工程師 Sasha Levin &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flore.kernel.org%2Fstable%2F20250825121505.2983941-5-sashal%40kernel.org%2F" target="_blank"&gt;嘗試&lt;/a&gt;了基於大語言模型（LLM）的新流程，讓 AI 自動分析補丁的重要性，並生成回退建議與説明。&lt;/p&gt; 
&lt;p&gt;在近期提交的部分補丁中，已經可以看到 AI 生成的提示，例如 「Backport Status: YES」，並附帶理由説明，儘管 Levin 也坦言這些解釋可能並不完全可靠。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-45e58d6544cd83524a2549342d46ca5c1fc.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;業內認為，這種做法有望顯著減輕維護者壓力，加快企業用戶獲取穩定更新的速度。但也有人擔心 AI 可能出現「幻覺」，錯誤推薦不適合回退的補丁，從而將風險引入 LTS 版本。因此，社區正在討論如何在流程中明確標註 AI 的參與，並制定相關規範，確保透明與安全。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368907/ai-help-backporting-linux-patch</guid>
      <pubDate>Tue, 19 Aug 2025 03:31:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>微語 0.9.3 發佈，智能客服 AI Agent</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;h1&gt;微語 - 重複工作自動化&lt;/h1&gt; 
&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;企業級多租戶團隊協作工具，免費開源 N 件套：企業 IM、在線客服、企業知識庫/幫助文檔、客戶之聲、工單系統、AI 對話、工作流、呼叫中心、視頻客服、開放平台。&lt;/p&gt; 
&lt;h2&gt;介紹&lt;/h2&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/team/readme.zh.md"&gt;企業 IM&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;局域網即時通訊&lt;/li&gt; 
 &lt;li&gt;企業成員管理&lt;/li&gt; 
 &lt;li&gt;聊天記錄監控&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/service/readme.zh.md"&gt;全渠道客服&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;多渠道接入&lt;/li&gt; 
 &lt;li&gt;人工客服&lt;/li&gt; 
 &lt;li&gt;客服 Agent 智能體，對接自有數據，自動執行操作&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/kbase/readme.zh.md"&gt;知識庫&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;對接大模型&lt;/li&gt; 
 &lt;li&gt;自定義知識庫&lt;/li&gt; 
 &lt;li&gt;Function Calling&lt;/li&gt; 
 &lt;li&gt;Mcp&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/ticket/readme.zh.md"&gt;工單系統&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;工單管理&lt;/li&gt; 
 &lt;li&gt;工單 SLA 管理&lt;/li&gt; 
 &lt;li&gt;工單統計和報表&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/ai/readme.zh.md"&gt;AI Agent&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;Ollama/DeepSeek/ZhipuAI/...&lt;/li&gt; 
 &lt;li&gt;智能體&lt;/li&gt; 
 &lt;li&gt;工作流&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/core/readme.workflow.md"&gt;工作流&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;自定義表單&lt;/li&gt; 
 &lt;li&gt;自定義流程&lt;/li&gt; 
 &lt;li&gt;工單流程可視化&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/modules/voc/readme.zh.md"&gt;客戶之聲&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;意見反饋&lt;/li&gt; 
 &lt;li&gt;服務投訴&lt;/li&gt; 
 &lt;li&gt;問卷調查&lt;/li&gt; 
 &lt;li&gt;...&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/freeswitch/readme.zh.md"&gt;呼叫中心&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;基於 FreeSwitch 的專業呼叫平台&lt;/li&gt; 
 &lt;li&gt;支持來電彈屏、自動分配、通話錄音&lt;/li&gt; 
 &lt;li&gt;數據統計，語音與文字服務無縫集成&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/webrtc/readme.zh.md"&gt;視頻客服&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;基於 WebRTC 技術的高清視頻通話&lt;/li&gt; 
 &lt;li&gt;支持一鍵視頻對話與屏幕共享&lt;/li&gt; 
 &lt;li&gt;適用於需要直觀展示的服務場景&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;&lt;a href="https://gitee.com/270580156/weiyu/blob/main/plugins/readme.md"&gt;開放平台&lt;/a&gt;&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;提供完整的 RESTful API 接口和 SDK 工具包&lt;/li&gt; 
 &lt;li&gt;支持與第三方系統無縫集成，實現數據互通&lt;/li&gt; 
 &lt;li&gt;多語言 SDK 支持，簡化開發集成流程&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;快速開始&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fdocker" target="_blank"&gt;Docker 部署&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fbaota" target="_blank"&gt;寶塔面板部署&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://gitee.com/link?target=https%3A%2F%2Fwww.weiyuai.cn%2Fdocs%2Fzh-CN%2Fdocs%2Fdeploy%2Fsource" target="_blank"&gt;源碼啓動&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;演示&lt;/h2&gt; 
&lt;p style="color:#40485b; margin-left:0; margin-right:0; text-align:left"&gt;本地預覽&lt;/p&gt; 
&lt;div&gt; 
 &lt;pre&gt;&lt;code&gt;&lt;em&gt;# 請將 127.0.0.1 替換為你的服務器 ip&lt;/em&gt;
http://127.0.0.1:9003/
&lt;em&gt;# 開放端口：9003, 9885&lt;/em&gt;
默認用戶名: admin@email.com
默認密碼: admin&lt;/code&gt;&lt;/pre&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368903</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368903</guid>
      <pubDate>Tue, 19 Aug 2025 03:23:00 GMT</pubDate>
      <author>來源: 資訊</author>
    </item>
    <item>
      <title>構建 AI 智能體的實用開源技術棧</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;編者按：&lt;/strong&gt; 面對市面上琳琅滿目的開源工具，我們往往迷失在選擇的焦慮中 —— 哪些工具真正經得起生產環境的考驗？哪些只是看起來很酷的演示項目？更重要的是，如何避免把寶貴的開發時間浪費在那些半成品工具上？&lt;/p&gt; 
 &lt;p&gt;我們今天為大家帶來的文章，作者的觀點是：構建可靠的 AI 智能體需要的不是最新最炫的工具，而是經過實戰檢驗、務實可靠的開源技術棧。&lt;/p&gt; 
 &lt;p&gt;本文作者系統梳理出一套經過實戰檢驗的開源技術棧，涵蓋智能體開發的九個核心領域：從用於構建和編排智能體的框架 ，到計算機與瀏覽器操控、語音交互、文檔理解、記憶機制等功能模塊；從測試評估到監控部署的全流程工具鏈；最後還包括仿真環境和垂直領域的專用智能體。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;作者 | Paolo Perrone&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;編譯 | 嶽揚&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;還記得在某個週末，我坐下來，堅信自己終於能構建一個像樣的研究助手智能體原型了。不需要多麼高大上 —— 只要它能讀取 PDF、提取關鍵信息、也許還能回答幾個後續問題就行。本該很簡單對吧？&lt;/p&gt; 
&lt;p&gt;結果，我花了整整兩天時間，在文檔不全的代碼倉庫、沉寂的 GitHub issues 和模糊不清的博客文章間反覆折騰。有個工具看起來很靠譜，直到我發現它已經八個月沒更新了。另一個工具需要啓動四個不同的服務，僅僅是為瞭解析一份文檔。最終，我的「智能體」連文件名都幾乎讀不出來，更別提內容了。&lt;/p&gt; 
&lt;p&gt;但支撐我做下去的不是挫敗感 —— 而是好奇。我想知道：真正的智能體開發者究竟在用哪些工具？不是那些創投圈熱捧的明星項目，而是那些你會默默安裝、保留在你的技術棧中、並真心信賴的工具。那些不需要三頁 Notion 文檔來解釋的工具。&lt;/p&gt; 
&lt;p&gt;這次探索讓我發現了一套出乎意料紮實的開源庫 —— 這些工具輕量、可靠，且專為開發者而打造。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;所以，如果你還在為智能體跑不通而焦頭爛額，本文就是為你準備的。&lt;/strong&gt;&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;01 那麼，你準備好構建 AI 智能體了嗎？&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;你可能會問：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;人們用什麼來構建語音智能體？&lt;/li&gt; 
 &lt;li&gt;解析文檔的最佳開源工具是什麼？&lt;/li&gt; 
 &lt;li&gt;如何在不把向量數據庫（vector DB）像萬能膠一樣到處粘貼的情況下給我的智能體添加記憶功能？&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;本指南並未試圖覆蓋市面上所有工具 —— 這是我有意為之。這是一份經過篩選的工具清單，是我真正使用過、保留在我的技術棧中、並在構建智能體原型時會反覆使用的工具。不是那些在演示中看起來很酷或在每個炒作帖子裏出現的工具，而是那些能幫助我從「想法（idea）」推進到「能工作的東西（working thing）」、而不會讓人迷失方向的工具。&lt;/p&gt; 
&lt;p&gt;以下是按類別劃分的技術棧：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;1）用於構建和編排智能體的框架（Frameworks for Building and Orchestrating Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你是從零開始構建智能體，可以從這裏開始。這些工具能夠幫助你結構化智能體的邏輯 —— 做什麼、何時做以及如何處理工具。可以將其視為將原始語言模型轉變為更自主的智能體的核心大腦。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;2）計算機與瀏覽器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一旦你的智能體能制定計劃，它就需要執行操作。這一類工具能讓你的智能體點擊按鈕、在數據字段中鍵入內容、抓取數據、以及像人類一樣操作應用程序或網站。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;3）語音功能（Voice）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;如果你的智能體需要説話或聆聽，這些工具負責處理音頻部分 —— 將語音轉為文本（speech to text），再將文本轉回語音（text to speech）。適用於免提場景或語音優先型智能體（voice-first agents）。有些工具甚至能很好地處理實時對話。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;4）文檔理解（Document Understanding）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;大量現實世界的數據存在於 PDF、掃描文件或其他雜亂格式中。這些工具能夠幫助你的智能體讀取和理解這些內容 —— 無論是發票、合同還是基於圖像的文件。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;5）記憶（Memory）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;要實現持續學習的能力，你的智能體就需要記憶功能。這些工具庫能幫助智能體記住剛剛發生了什麼、你之前告訴過它什麼，甚至能隨時間的推移構建長期用戶畫像。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;6）測試與評估（Testing and Evaluation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;系統總會出故障。這些工具可以幫助你在系統上線前發現問題 —— 通過預設用戶操作路徑、模擬交互，並檢查智能體的行為是否符合預期。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;7）監控與可觀測性（Monitoring and Observability）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;當智能體正式上線後，你需要知道它在做什麼以及表現如何。這些工具能夠幫助你跟蹤使用情況、調試出現的問題並分析成本或延遲影響。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;8）仿真環境（Simulation）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在將智能體投入真實場景前，需要先在安全的沙箱世界中測試它。仿真環境讓你能在受控條件中進行實驗、優化決策邏輯並發現邊界案例。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;9）垂直領域智能體（Vertical Agents）&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;並非所有東西都需要從零構建。這些是為特定工作（如編程、研究或客戶支持）打造的預置智能體。你可以直接使用它們，或根據你的工作流進行定製。&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;02 用於構建和編排智能體的框架&lt;/strong&gt; &lt;strong&gt;(Frameworks for Building and Orchestrating Agents)&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要打造真正能解決問題的智能體，你需要一個紮實的底層架構 —— 它必須能駕馭工作流、記憶機制和工具協同，而不是淪為一堆東拼西湊的腳本代碼。這些框架為你的智能體提供了所需的結構，使其能夠準確理解目標、制定可行方案並執行到底。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;CrewAI&lt;/strong&gt;&amp;nbsp;— 協調多個協同工作的智能體。非常適合需要協調和基於角色行為的任務。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agno&lt;/strong&gt;&amp;nbsp;— 專注於記憶機制、工具使用和長期交互。對於需要記憶能力和適應能力的 AI 助手來説非常理想。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Camel&lt;/strong&gt;&amp;nbsp;— 專為多智能體協同、仿真推演和任務分工場景打造。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGPT&lt;/strong&gt;&amp;nbsp;— 通過「規劃-執行」閉環實現複雜工作流的自動化運行。最適合需要獨立運行的智能體。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AutoGen&lt;/strong&gt;&amp;nbsp;— 讓智能體之間進行協作，共同解決複雜問題。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;SuperAGI&lt;/strong&gt; — 簡化的設置，用於快速構建和部署自主智能體（autonomous agents）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Superagent&lt;/strong&gt;&amp;nbsp;— 一個靈活的開源工具包，用於創建自定義 AI 助手。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain &amp;amp; LlamaIndex&lt;/strong&gt;&amp;nbsp;— 用於智能記憶管理、高效檢索和工具鏈整合的首選工具。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;03 計算機與瀏覽器操控（Computer and Browser Use）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;當你的智能體能推理、思考後，下一步就是讓它能採取行動。這意味着智能體要像人類一樣與計算機或網絡進行交互 —— 點擊按鈕、填寫表單、瀏覽頁面並執行命令。這些工具在推理（reasoning）與行動（action）之間架起了一座橋樑，讓智能體能在現實場景中運作。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Open Interpreter&lt;/strong&gt;&amp;nbsp;— 將自然語言翻譯成能在你機器上執行的代碼。想移動文件或運行腳本？描述需求即可。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Self-Operating Computer&lt;/strong&gt;&amp;nbsp;— 讓智能體完全控制你的桌面環境，使其能像真人一樣與操作系統（OS）進行交互。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Agent-S&lt;/strong&gt;&amp;nbsp;— 這是一個靈活的框架，允許 AI 智能體像真實用戶那樣操作各類應用程序（apps）、工具（tools）和交互界面（interfaces）。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LaVague&lt;/strong&gt;&amp;nbsp;— 使網頁智能體（web agents）能夠實時瀏覽網站、填寫表單並做出決策，是實現瀏覽器任務自動化的理想選擇。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Playwright&lt;/strong&gt;&amp;nbsp;— 跨瀏覽器自動化網頁操作。適合測試或模擬用戶流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Puppeteer&lt;/strong&gt;&amp;nbsp;— 控制 Chrome 或 Firefox 的可靠工具。非常適用於數據抓取和前端行為自動化。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;04 語音功能（Voice）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;語音是人類與 AI 智能體交互最直觀的方式之一。這些工具處理語音識別（speech recognition）、語音合成（voice synthesis）及實時交互（real-time interactions） —— 讓你的智能體更具「人性化」。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;4.1 語音對話（Speech2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Ultravox&lt;/strong&gt;&amp;nbsp;— 頂級的語音對話模型，可流暢處理實時語音對話。響應迅速靈敏。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Moshi&lt;/strong&gt;&amp;nbsp;— 語音對話任務的另一個強勁選擇。在實時語音交互方面表現可靠，但 Ultravox 在性能上更勝一籌。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Pipecat&lt;/strong&gt;&amp;nbsp;— 用於構建語音交互智能體的全棧框架。支持語音轉文本、文本轉語音，甚至基於視頻的交互（video-based interactions）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.2 語音識別（Speech2text）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Whisper&lt;/strong&gt;&amp;nbsp;— OpenAI 的語音轉文本模型 —— 適用於跨多語言的轉錄和語音識別。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Stable-ts&lt;/strong&gt;&amp;nbsp;— 針對 Whisper 的、對開發者更友好的封裝工具。添加了時間戳和實時支持，非常適合對話型智能體。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Speaker Diarization 3.1&lt;/strong&gt;&amp;nbsp;— Pyannote 的説話人分離模型。對多人對話及會議類音頻等場景至關重要。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.3 語音合成（Text2speech）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;ChatTTS&lt;/strong&gt;&amp;nbsp;— 目前我發現的最佳模型。速度快、穩定，滿足大多數生產需求。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ElevenLabs（商業版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 當音質要求高於開源產品時，這是首選方案。提供高度自然的擬真語音，並支持多種風格。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Cartesia（商業版 / Commercial）&lt;/strong&gt; &amp;nbsp;— 如果你追求超越開源模型表現的高清語音合成，這是另一個強有力的商業選項。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;4.4 實用工具（Miscellaneous Tools）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vocode&lt;/strong&gt;&amp;nbsp;— 用於構建語音驅動的大語言模型智能體的工具包。輕鬆連接語音輸入/輸出與語言模型。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 用於測試和評估語音智能體的框架。可調試優化提示詞、語音角色（voice persona）或模型配置（model setup）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;05 文檔理解（Document Understanding）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;大部分有價值的業務數據仍以非結構化格式存在 —— PDF 文件、掃描文件、基於圖像的報表。這些工具能夠幫助你的智能體讀取、提取並理解這些複雜內容，而無需依賴脆弱的 OCR 處理流程。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Qwen2-VL&lt;/strong&gt;&amp;nbsp;— 阿里巴巴推出的強大視覺語言模型。在處理混合圖像與文本的文檔任務時，表現優於 GPT-4 和 Claude 3.5 Sonnet，非常適合處理複雜的實際業務格式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;DocOwl2&lt;/strong&gt;&amp;nbsp;— 為文檔理解場景打造的輕量級多模態模型，無需依賴 OCR。快速高效，且在從雜亂的輸入中提取內容結構和語義時準確度驚人。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;06 記憶（Memory）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;沒有記憶機制的智能體會陷入一種將每次交互都視為初次接觸的循環。這些工具賦予它們回憶過往對話、追蹤用戶偏好和建立持續交互記憶的能力。正是這種能力，讓一次性的助手逐步進化為持續增值的智能夥伴。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Mem0&lt;/strong&gt;&amp;nbsp;— 可自我迭代的記憶層，讓智能體能夠適配先前的交互。非常適合構建更個性化、持久化的 AI 體驗。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Letta（前身為 MemGPT）&lt;/strong&gt; &amp;nbsp;— 為 LLM 智能體增加長期記憶和工具使用能力。可視為智能體的核心支架，使其具備記憶、推理和進化的能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;LangChain&lt;/strong&gt;&amp;nbsp;— 包含即插即用的記憶組件，用於追蹤對話歷史和用戶上下文 —— 在構建需跨多輪對話保持連續性的智能體時非常實用。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;07 測試與評估（Testing and Evaluation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;當你的智能體不再僅限於聊天，而是開始瀏覽網頁、做出決策、發出語音時，你需要預判它在邊界情況中的表現。這些工具可幫助你測試智能體在不同場景下的行為、及早發現 bug，並定位系統故障點。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Voice Lab&lt;/strong&gt;&amp;nbsp;— 測試語音智能體的綜合框架，確保語音識別和響應準確且自然。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 用於追蹤和通過基準測試測試 AI 智能體的工具集，幫助你在問題影響用戶之前發現隱患並優化性能。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentBench&lt;/strong&gt;&amp;nbsp;— 評估 LLM 智能體的基準測試工具，覆蓋從網頁瀏覽到遊戲等多種任務場景，確保通用性與有效性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;08 監控與可觀測性（Monitoring and Observability）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;要確保 AI 智能體大規模地部署運行時能夠流暢高效地工作，你需要對它們的性能與資源消耗進行監控。這些工具提供的關鍵可觀測性數據，能夠助你監控智能體行為、優化資源，並在問題波及用戶前及時攔截。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;openllmetry&lt;/strong&gt;&amp;nbsp;— 基於 OpenTelemetry 為 LLM 應用提供端到端的可觀測性，清晰展示性能表現，並幫助你快速排查故障和優化系統。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AgentOps&lt;/strong&gt;&amp;nbsp;— 一款全面的監控工具，能夠追蹤智能體性能、成本開支及基準測試數據，確保其高效運行且成本可控。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;09 仿真環境（Simulation）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;在部署前模擬真實環境具有突破性意義。這些工具讓你能創建受控的虛擬空間，使智能體在其中互動、學習並做出決策，而無需承擔在實際環境中可能產生的意外後果。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;AgentVerse&lt;/strong&gt;&amp;nbsp;— 支持在多種應用程序和模擬環境中部署基於 LLM 的多智能體，確保其在各種環境下都能有效運作。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Tau-Bench&lt;/strong&gt;&amp;nbsp;— 評估智能體在特定行業（如零售業/航空業）中用戶交互表現的基準測試工具，確保專業領域任務的流暢執行。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;ChatArena&lt;/strong&gt;&amp;nbsp;— 一個多智能體語言遊戲環境，智能體在其中交互協作，適合在安全受控空間內研究智能體的行為模式並優化溝通模式。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;AI Town&lt;/strong&gt;&amp;nbsp;— AI 角色進行社交互動、決策測試和現實場景模擬的虛擬環境，幫助精細化調優智能體行為。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;Generative Agents&lt;/strong&gt;&amp;nbsp;— 斯坦福的智能體項目，專注於模擬人類複雜行為，非常適合在社交語境中測試記憶與決策能力。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;10 垂直領域智能體（Vertical Agents）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;垂直領域智能體是解決特定行業問題或優化專業任務的專用工具。儘管這類工具的生態系統正在不斷發展，但還是分享我個人使用過並認為特別有用的幾款工具：&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;10.1 編程開發（Coding）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;OpenHands&lt;/strong&gt;&amp;nbsp;— 基於 AI 的軟件開發平台，可自動化編程任務並加速開發流程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;aider&lt;/strong&gt;&amp;nbsp;— 可直接集成到終端的結對編程工具（pair programming tool），提供直接嵌入編程環境的 AI 協作編程。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Engineer&lt;/strong&gt;&amp;nbsp;— 用自然語言構建應用程序；用戶只需描述需求，AI 將解析用戶意圖並生成代碼。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;screenshot-to-code&lt;/strong&gt;&amp;nbsp;— 將設計圖轉換為採用 HTML/Tailwind/React/Vue 的完整網站，快速實現設計稿轉代碼。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.2 學術研究（Research）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;GPT Researcher&lt;/strong&gt;&amp;nbsp;— 一款能夠進行全面研究、分析數據並撰寫報告的自主智能體（autonomous agent），能夠簡化研究流程。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;10.3 數據庫交互（SQL）&lt;/strong&gt;&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;Vanna&lt;/strong&gt;&amp;nbsp;— 使用自然語言查詢與 SQL 數據庫交互。無需編寫複雜的 SQL 命令，提問即可獲取數據。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h1&gt;&lt;strong&gt;11 總結（Conclusion）&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;回顧我早期構建研究助手時的嘗試，我意識到自己當初把問題複雜化了。那個項目最終是一團糟 —— 充斥着過時的代碼、半成品的工具，以及連 PDF 這種簡單文件都處理得力不從心的系統。&lt;/p&gt; 
&lt;p&gt;但正是在這次失敗中我收穫最多。&lt;/p&gt; 
&lt;p&gt;關鍵不在於尋找最完美的工具，而在於堅持有效的方案並保持簡單。那次教訓讓我明白：&lt;strong&gt;構建最可靠的智能體，憑的是務實、直接的技術棧，而非追逐每一款花哨的新工具。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;成功的智能體開發無需重複造輪子。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;核心在於選擇適合目標任務的工具、有條不紊地整合它們，並持續不斷地優化智能體原型。&lt;/strong&gt; 無論你是要自動化工作流程、構建語音智能體，還是解析文檔，一套精心挑選的技術棧都能讓流程更流暢高效。&lt;/p&gt; 
&lt;p&gt;因此，立即行動，大膽嘗試，讓好奇心引領你前行。技術生態系統正在不斷演進，可能性是無窮無盡的。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;應原作者要求，在此放置 Substack 訂閲鏈接和宣傳語：&lt;/p&gt; 
&lt;p&gt;&amp;gt; 作為科技內容從業者，還在為粉絲增長髮愁？ &amp;gt; &amp;gt; 《The Tech Audience Accelerator》正是為你量身打造的必備指南 —— 專為認真擴大受眾羣體的科技創作者而生。 &amp;gt; &amp;gt; 這裏濃縮了我實現 3000 萬+ 曝光量（且持續攀升）的實戰方法論、即用模板與高效策略， &amp;gt; &amp;gt; 所有乾貨，皆經市場驗證。 &amp;gt; &amp;gt; &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftechaudienceaccelerator.substack.com%2F" target="_blank"&gt;https://techaudienceaccelerator.substack.com/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本期互動內容 🍻&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;❓分享一次你構建 AI 智能體時最讓你血壓飆升的工具使用踩坑經歷！🫠 是文檔失蹤？還是兼容性噩夢？&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;本文經原作者授權，由 Baihai IDP 編譯。如需轉載譯文，請聯繫獲取授權。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;原文鏈接：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdecodingml.substack.com%2Fp%2Fthe-open-source-stack-for-ai-agents" target="_blank"&gt;https://decodingml.substack.com/p/the-open-source-stack-for-ai-agents&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/IDP/blog/18689820</link>
      <guid isPermaLink="false">https://my.oschina.net/IDP/blog/18689820</guid>
      <pubDate>Tue, 19 Aug 2025 03:19:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Devv 推出 Coding Agent，專注構建 AI 驅動的產品</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Devv Search 團隊發佈了全新的 Devv Coding Agent，一個專為構建 AI 驅動產品而設計的集成開發平台。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1734" src="https://static.oschina.net/uploads/space/2025/0828/110715_u41G_2720166.png" width="1268" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Ftisoga%2Fstatus%2F1960599099025301756" target="_blank"&gt;官方介紹稱&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;與 Lovable 或 Bolt 不同，Devv 不適用於構建精美的登錄頁面或漂亮的演示。 &amp;nbsp;我們專注於一件事：為您構建真正的 AI 產品 —— 內置 LLM、圖像/音頻生成、後台作業、身份驗證、數據庫、電子郵件等功能。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Devv&amp;nbsp; 被定位為「首個幫助交付 AI 驅動產品的 Coding Agent」，其功能類似於 n8n 與 Lovable 的結合。它原生集成了 Auth、Database、Email、LLMs、OpenRouter、Replicate、Stripe 等常用服務，為開發者提供了一站式解決方案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-1bceba73f6f0bc01bd9f788fa97e1256947.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;體驗：&lt;em&gt;https://devv.ai/&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/368901</link>
      <guid isPermaLink="false">https://www.oschina.net/news/368901</guid>
      <pubDate>Tue, 19 Aug 2025 03:12:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
