<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Mon, 17 Mar 2025 07:39:40 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>Git 2.49 正式發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Git 2.49 已正式發佈，帶來了多項新功能和改進，主要涉及性能優化、部分克隆的歷史數據填充、壓縮庫的更新以及 Rust 代碼的初步引入。&lt;/p&gt; 
&lt;p&gt;主要變化&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;新版本通過改進的 name-hash v2 算法顯著提升了打包性能，減少了存儲空間佔用。&lt;/li&gt; 
 &lt;li&gt;新增的 git backfill 命令可以更高效地填充部分克隆中缺失的歷史數據，提升了操作效率。&lt;/li&gt; 
 &lt;li&gt;支持使用 zlib-ng 壓縮庫，進一步提升了壓縮性能。&lt;/li&gt; 
 &lt;li&gt;更新 gitk&lt;/li&gt; 
 &lt;li&gt;為 zsh 提供了完成腳本更新&lt;/li&gt; 
 &lt;li&gt;向 Meson 構建系統集成中添加了一個「unsafe-sha1」構建旋鈕&lt;/li&gt; 
 &lt;li&gt;新增 Rust 外部語言接口，它是 libgit.a 的包裝器&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif&quot;&gt;詳情查看&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.blog%2Fopen-source%2Fgit%2Fhighlights-from-git-2-49%2F&quot; style=&quot;font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Apple Color Emoji&amp;quot;, &amp;quot;Segoe UI Emoji&amp;quot;, &amp;quot;Segoe UI Symbol&amp;quot;, &amp;quot;Segoe UI&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, Arial, sans-serif;&quot; target=&quot;_blank&quot;&gt;發佈公告&lt;/a&gt;&lt;span style=&quot;font-family:-apple-system,BlinkMacSystemFont,&amp;quot;Apple Color Emoji&amp;quot;,&amp;quot;Segoe UI Emoji&amp;quot;,&amp;quot;Segoe UI Symbol&amp;quot;,&amp;quot;Segoe UI&amp;quot;,&amp;quot;PingFang SC&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,Helvetica,Arial,sans-serif&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339385/git-2-49-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339385/git-2-49-released</guid>
            <pubDate>Mon, 17 Mar 2025 07:10:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>谷歌 Gemini 2.0 Flash 模型增加去水印功能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌旗下最新模型 &lt;a href=&quot;https://www.oschina.net/news/338720/gemini-2-0-flash-native-image-generation&quot;&gt;Gemini 2.0 Flash &lt;/a&gt;被&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fabdiisan%2Fstatus%2F1900147597571977631&quot; target=&quot;_blank&quot;&gt;發現&lt;/a&gt;可以用來去除圖片中的水印，包括 Getty Images 等知名圖庫的水印。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-64731f3f85efa2187a99f37056db1a379b3.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-23233ba4643e6ec781bc9bffdc6668351a2.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e55cf346cfad2540b6702a110098d654c58.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;根據網友的反饋，Gemini 2.0 Flash 可以輕鬆生成描繪名人和受版權保護人物的圖片，不僅如此，它還可以去除現有照片上的水印，同時還能填補因刪除水印而產生的空白。有網友表示，其他大模型其實也能做到這一點，但 Gemini 2.0 Flash 在這方面特別嫺熟，而且免費使用。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3f59dcdf9ca70258e7afc58feab3154a3b1.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;需要説明的是，Gemini 2.0 Flash 的圖像生成功能目前被標註為 「試驗性 」和 「非生產性使用」，並且只在谷歌面向開發者的工具（如 AI Studio）中可用。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339380/gemini-2-0-flash-remove-watermarks</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339380/gemini-2-0-flash-remove-watermarks</guid>
            <pubDate>Mon, 17 Mar 2025 06:54:09 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>基於 Flink 的配置化實時反作弊系統</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;h1&gt;導讀&lt;/h1&gt; 
&lt;p&gt;本文詳細闡述了基於 Flink 構建的實時反作弊流式過濾系統，針對大流量場景下的複雜特徵計算、高頻策略熱更新、模擬過濾驗證及多場景數倉對接等核心挑戰，提出來多項解決方案，實現了秒級特徵計算的實時過濾功能，有效支撐高併發場景下的精準風控判定，並通過 ClickHouse 與圖靈雙鏈路數據輸出，滿足實時監控與離線分析的多樣化需求，為互聯網業務提供了高吞吐、低延遲、強穩定的實時反作弊解決方案。&lt;/p&gt; 
&lt;h1&gt;01 簡介&lt;/h1&gt; 
&lt;p&gt;在互聯網業務高速發展的今天，反作弊已成為 APP 廠商生態穩定運行的重要保障。作弊行為層出不窮，包括惡意點擊、刷單、羊毛黨等，這些行為不僅會破壞平台公平性，還可能造成巨大的經濟損失。因此，構建一個高效、靈活、可擴展的實時反作弊系統變得尤為重要。&lt;/p&gt; 
&lt;p&gt;反作弊系統根據業務屬性和時效性可分為三類：在線反作弊、實時反作弊與離線反作弊。其中，在線反作弊具備最高的時效性，能夠即時響應風險；離線反作弊依託最全面的信息，支持深度分析與建模；而實時反作弊則兼具二者優勢，提供平衡的時效性與信息豐富度。&lt;/p&gt; 
&lt;p&gt;在線反作弊系統通過快速處理簡單指標進行判斷，例如分析當前請求攜帶的字段信息，並結合基於 Redis 的簡單累計值（如訪問頻率或特定行為計數）來制定策略。這種系統以低延遲為核心，能夠在毫秒級別響應反作弊判定結果，適用於攔截時效要求高的風控需求。&lt;/p&gt; 
&lt;p&gt;離線反作弊系統通過對完整的離線數據進行大規模、長週期的數據挖掘和樣本分析，為優化線上策略、構建特徵黑產庫和訓練高精度模型提供支持。然而，由於依賴離線數據的批量處理，其時效性相對較低，通常難以滿足實時風控的需求，更適合用於長期策略優化和深度分析場景。&lt;/p&gt; 
&lt;p&gt;實時反作弊系統能夠在秒級別和分鐘級別對用戶的異常行為做出反饋，及時識別作弊用戶並對業務進行止損。雖然其時效性略低於在線反作弊，但得益於對豐富維度和行為序列特徵的分析，實時反作弊可以實現更加精準的策略判定，在精準性與時效性之間達到良好的平衡。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c8daaeef5688e23daf976cf98290b5df2eb.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;本篇文章我們將重點分析實時反作弊流式系統的相關實現。&lt;/p&gt; 
&lt;h1&gt;02 流式系統面臨的核心問題&lt;/h1&gt; 
&lt;p&gt;在實際建設過程中，我們需要解決以下關鍵挑戰。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;2.1&lt;/strong&gt; &lt;strong&gt;複雜的特徵計算&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;在實時反作弊場景中，用戶行為數據規模龐大且動態變化（如電商大促、搜索點擊等），系統需要處理海量的用戶行為數據，並需基於時間窗口快速計算多維特徵（如用戶點擊頻率、IP 集中度、設備關聯賬戶數）。這些特徵需覆蓋不同窗口粒度（秒級、分鐘級、天級）和窗口類型（滑動、滾動、會話窗口），以捕捉異常行為模式。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;窗口特徵計算的挑戰（多維度多窗口多指標聚合）&lt;/strong&gt;：反作弊策略通常需要基於不同時間窗口（如分鐘級、小時級、天級），不同維度（用戶、設備、IP 等）進行特徵累積計算。例如，計算某個用戶在過去 1 小時內的點擊次數，或者某個 IP 在過去 24 小時內的訪問頻率。這些計算涉及滑動窗口、滾動窗口等多種窗口類型，計算量大且複雜。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;數據亂序問題&lt;/strong&gt;：網絡延遲或分區消費不均可能導致事件亂序到達，若未正確處理，會導致特徵計算不準確，進而影響反作弊策略的判定。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;高併發下的狀態存儲優化&lt;/strong&gt;：在高併發場景下，特徵累積計算需要頻繁訪問狀態後端（如 RocksDB），導致性能瓶頸。例如，當 QPS 達到數十萬甚至上百萬時，狀態後端的訪問壓力會顯著增加，影響系統的吞吐量和延遲。長週期窗口（如月級）到期時，大量 Key 需同時清理狀態，引發瞬時資源爭搶，導致作業卡頓。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳見 3.2 大規模窗口特徵計算，通過，內存緩存+微批處理減少狀態訪問、事件時間排序緩解亂序影響、keyBy 和 trigger 優化降低狀態後端壓力，最終支撐高吞吐場景下的精準計算。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;2.2&lt;/strong&gt; &lt;strong&gt;高頻的策略更新迭代&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;反作弊策略需要快速響應新型作弊行為。例如，當出現新的刷單手段或惡意點擊行為時，風控團隊需要迅速調整策略，以應對新的威脅。此外，不同業務場景（如廣告點擊、電商交易、社交互動）的反作弊策略差異較大，策略的複雜性和多樣性增加了系統維護的難度。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;高頻迭代需求：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;反作弊策略需要根據業務需求和作弊手段的變化進行高頻更新，傳統開發模式（修改代碼→測試→發佈）無法滿足時效性。部分策略需「熱生效」，避免作業重啓導致數據丟失或計算中斷。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;策略複雜性升級：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;多規則嵌套：單一策略可能需組合字段匹配（如 IP 黑名單）、模型評分（如行為異常概率＞90%）、時間窗口特徵（如近 5 分鐘同一設備註冊賬號數＞3）等多層條件，這些策略的複雜性增加了開發和維護的成本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;配置管理風險&lt;/strong&gt;：&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;人工修改配置文件易出錯 (如語法錯誤、字段誤配),導致作業崩潰或策略漏判。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳見 3.3 配置化，通過全流程的配置化升級和配置文件託管，將策略規則、特徵計算、字段抽取等邏輯抽象為配置文件，支持快速策略調整和上線，減少對底層代碼的依賴，提升策略迭代效率。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;2.3&lt;/strong&gt; &lt;strong&gt;模擬過濾的支持&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;在反作弊策略上線前，風控團隊需要對策略進行測試和驗證，以確保其有效性和穩定性，這一過程稱為模擬過濾。在實時反作弊系統中，模擬過濾是策略上線前的核心驗證環節，其必要性體現在以下三個關鍵維度：&lt;/p&gt; 
&lt;p&gt;提前規避線上風險，防止「誤殺」與「漏殺」：直接在生產環境上線新策略存在風險，可能導致誤判或漏判，影響業務正常運行。因此，需要在測試環境中對策略進行模擬過濾，確保其準確性和穩定性。&lt;/p&gt; 
&lt;p&gt;驗證策略性能，避免作業過載：模擬過濾歷史峯值流量（如大促期間數據），驗證作業在極限負載下的穩定性。&lt;/p&gt; 
&lt;p&gt;歷史回溯與極端場景覆蓋：從 HDFS 讀取數月前的全量數據（如黑產攻擊事件日誌），驗證策略對歷史攻擊的檢測能力和進行數據回溯。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-bd404e46079b8882bd219e2e8e2afdac799.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;詳見 3.4 模擬過濾的實現，通過配置化、線上流與測試流隔離、數據 Source 改造等方式，加速策略效果驗證環節。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;2.4&amp;nbsp;多場景數倉對接與平台整合&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;我們的系統產出的數據需要支持業務方的複雜分析需求。例如，基於反作弊結果進行策略優化，實時監控作弊行為的影響，對歷史數據進行深度挖掘。&lt;/p&gt; 
&lt;p&gt;目前我們支持多種數倉形式（如實時 ClickHouse 與離線 Hive）的數據產出，滿足不同業務場景下的需求，包括實時數據看板、策略評估、歷史回溯等應用。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;數據產出的便利性：反作弊系統需要將計算結果輸出到多種存儲系統（如 ClickHouse、Hive、Redis 等），以滿足不同業務場景的需求。例如，實時數據需要寫入 ClickHouse 用於實時監控，離線數據需要寫入 Hive 用於歷史分析。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;自助分析能力：業務方需要對反作弊結果進行多維度的分析，例如按時間、地域、用戶羣體等維度進行統計分析。傳統的固定報表無法滿足這種靈活的分析需求。所以支持業務方進行自助分析，能夠根據需求靈活查詢和分析數據，而不依賴開發團隊的支持。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詳見 3.5 便捷的數據分析，通過將反作弊結果輸出到 ClickHouse 和 Hive，支持實時和離線分析。同時，接入 TDA（Turing Data Analysis 自助分析平台），業務方可以通過簡單的 SQL 查詢或可視化工具，靈活分析反作弊數據，滿足複雜的分析需求。&lt;/p&gt; 
&lt;h1&gt;03 反作弊流式框架介紹&lt;/h1&gt; 
&lt;h2&gt;&lt;strong&gt;3.1 反作弊系統整體框架&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;整個實時反作弊的生效流程圖如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-c6b95b7fffe05b73f639c2b18a36ea422dd.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上圖展示了 Flink 反作弊流式實時過濾系統，的整體架構，包括，風控平台、實時作業、外部存儲，三大核心模塊，整體流程如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;風控平台（配置分發）&lt;/strong&gt;：反作弊工程師在平台上編輯策略規則、配置特徵計算邏輯，並一鍵生成配置文件和啓動模擬過濾驗證策略效果。測試通過後，策略配置通過平台分發至實時作業。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;實時作業（配置解析與執行）&lt;/strong&gt;：Flink 作業解析平台下發的配置文件後，構建作業各個模塊，包括數據接入、ETL 處理、特徵計算、規則匹配等，最後提交併執行流式任務。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;作業結果存儲（結果輸出）&lt;/strong&gt;：ClickHouse，存儲實時計算結果，支持快速查詢與監控。Hive：存儲離線數據，用於歷史回溯與深度分析。Redis：提供低延遲查詢，支持在線服務實時訪問反作弊結果。消息隊列：將判定結果傳輸至下游業務系統，供下游實時決策。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Flink 作業內部，實時流運行各個模塊拆解如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-17b1acbc8844964c1987f9ca0d0cd7976d9.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;流式作業的主要模塊可以分為：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;數據接入 Source&lt;/strong&gt;：業務事件日誌數據（用戶行為、支付、點擊、搜索等）接入。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;數據 ETL 處理&lt;/strong&gt;：數據清洗、轉換、標準化；簡單維度拼接（ip 映射城市等）；第三方字段請求（風險評分、黑設備、用戶畫像等）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;多重窗口特徵計算&lt;/strong&gt;：時間窗口（分鐘級、小時級、天級、周級、月級）、滑動、滾動窗口等，多種維度多種聚合函數進行特徵累積聚合。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Join 階段&lt;/strong&gt;：負責將特徵和原始日誌進行 join。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;規則策略匹配與判定&lt;/strong&gt;：機器學習模型打分，配置化規則引擎基於之前的所有信息進行最終判定。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;下游輸出&lt;/strong&gt;：實時反饋給線上服務、下發給業務方、入數倉表等方式將判定結果進行輸出落盤。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;strong&gt;3.2&amp;nbsp;大規模窗口特徵計算&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;對於整個作業而言，主要計算資源就是用於累積基於窗口的特徵。對於業務需求而言，不同窗口下的特徵聚合結果是提升判定的準確率和召回率最重要的信息。&lt;/p&gt; 
&lt;p&gt;我們的窗口累積邏輯主要基於 Flink 窗口功能實現，包括 TumblingWindows、SlidingWindows 和 SessionWindows，Session 窗口使用較少。我們未使用其原生 Aggregate 函數，而是採用了更底層的 WindowProcessFunction 實現窗口聚合邏輯。這種方式的優勢在於為後續優化提供了更大的靈活性和定製空間。&lt;/p&gt; 
&lt;p&gt;為了滿足業務訴求，我們也對原生的窗口機制進行了多項優化，主要升級點有以下幾個：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;提前觸發&lt;/strong&gt;：無需等待窗口結束即可實時下發累積結果，滿足業務對於數據時效性的要求。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;批量更新和抗亂序&lt;/strong&gt;：採用批量狀態更新方式，減少頻繁讀取與寫入，同時在微批更新時進行局部重排序，以降低亂序影響。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;鍵縮減-粗粒度 KeyBy&lt;/strong&gt;：優化 keyBy 和窗口觸發器設計，減少狀態訪問頻次，提高緩存命中率，降低計算開銷。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;下邊將分別進行介紹。&lt;/p&gt; 
&lt;h3&gt;3.2.1 時效性優化-提前觸發&lt;/h3&gt; 
&lt;p&gt;默認情況下，Flink 的每個窗口自帶一個觸發器（Trigger），在窗口結束時觸發計算並生成聚合結果。然而，在實時性要求較高的反作弊場景中，如果窗口長度長達一天，等待窗口結束再下發結果顯然不符合要求的。因此，我們需要在窗口尚未結束時，通過特定條件提前觸發窗口計算，這種機制稱為「&lt;strong&gt;提前觸發&lt;/strong&gt;」。&lt;/p&gt; 
&lt;p&gt;Flink 提供了多種現成的窗口觸發方式，包括按 ProcessTime 定時觸發、按 EventTime 定時觸發、按固定條數觸發等，同時也支持自定義觸發方式。針對我們的業務需求，目前採用的是按事件時間的間隔提前觸發方式。具體觸發間隔依據不同業務場景設定，能夠在秒級或分鐘級就能得到窗口的聚合結果。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-80c3ba5492f6c98f0b38c449c67a83bef8f.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;上圖:&lt;/strong&gt; 展示了 Flink 原生窗口的觸發機制及其聚合過程。每個綠色矩形表示一個窗口，窗口範圍內累積了多個事件，編號為 1、2、3 、4、5。紅色圓圈表示觸發時下發的特徵數據，從上圖可以看到，窗口觸發是在窗口結束時統一執行的，下發了 2、5、3、1 四條特徵。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;下圖&lt;/strong&gt;：改造後 - 提前觸發機制**，**展示了優化後的窗口觸發機制，通過提前觸發減少延遲。每個綠色矩形依舊錶示一個窗口，但觸發時間提前，避免了窗口結束時的集中計算，紅色圓圈同樣表示輸出結果。提前觸發機制在窗口中按事件到達順序多次輸出，窗口中的事件可以更早地被處理，提升了時效性。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;3.2.2&amp;nbsp;亂序和性能優化-批量更新和亂序糾正&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;在大流量場景下的測試表明，當前吞吐瓶頸主要受限於窗口聚合時 RocksDB 狀態後端讀寫。由於一條數據會抽取多條特徵，所以特徵窗口累積算子會對 Source 輸入數據進行爆炸式擴展，例如當輸入數據 QPS 達到 10 萬時，特徵累積算子的 QPS 可能攀升至數十萬甚至上百萬，導致大量狀態讀寫請求集中在 RocksDB，使其難以支撐高吞吐需求。&lt;/p&gt; 
&lt;p&gt;Flink 默認的窗口機制會在每條數據到達時更新累積值，並與狀態後端交互，進一步加劇了 RocksDB 的負擔。為優化性能，我們將窗口觸發和累積調整為&lt;strong&gt;微批模式&lt;/strong&gt;，每次批量更新數據，並引入&lt;strong&gt;內存緩存層&lt;/strong&gt;，微批內優先訪問內存緩存，有效減少狀態的訪問次數。&lt;/p&gt; 
&lt;p&gt;在百度搜索和點擊流量場景下的測試結果顯示，該優化方案使&lt;strong&gt;內存緩存命中率提升至 90% 以上&lt;/strong&gt;，意味着特徵累積階段減少了約 90% 的狀態後端訪問。&lt;/p&gt; 
&lt;p&gt;同時，在微批數據內部，我們會進行排序，還能有效緩解數據亂序問題，提高計算準確性。如下圖所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7ca0739f1ae258fe5b426d4fb3bb292d867.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上圖：Flink 默認窗口累積機制，**綠色矩形代表窗口的時間範圍，窗口中的每一條數據（標記為 1、2 等）都會觸發累積操作。圖示中展示了 5 條 pv 的狀態後端訪問，每條 pv 都需要與，狀態後端（圖中黃色區域）進行交互，包括查詢、更新、寫入等操作。紅色圓圈是輸出的累積結果，紅色邊框標記的條目表示亂序數據。上圖存在兩個問題，第一，對狀態後端的頻繁隨機訪問會導致性能瓶頸，尤其是在高併發和大流量場景下。第二，輸入數據是亂序的情況下，輸出數據也是亂序的。&lt;/p&gt; 
&lt;p&gt;下圖：優化後的窗口累積機制，**優化引入了內存緩存和微批模式。數據小批量更新（如標記為 2、1、4 為一批、3、5 為一批）。每次窗口觸發時，首先會對本次微批內的數據進行排序 (2,1,4 被糾正為 1,2,4)，然後再累積。累積時，窗口內的累積查詢會先訪問內存緩存，如果內存 miss，再訪問狀態後端。最終圖示中僅有 4 次狀態後端交互，較優化前的 15 次減少 11 次。數據亂序也得到了緩解。&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;3.2.3 大流量場景優化-鍵縮減 (粗粒度 KeyBy)&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;窗口聚合過程中累積器需要頻繁讀寫狀態後端。此前，我們通過引入緩存層和微批模式大幅減少窗口累積器對狀態的訪問頻次，優化效果顯著。然而，在實際應用中，我們發現窗口觸發器（Trigger） 也會頻繁訪問狀態後端，帶來額外的性能開銷。&lt;/p&gt; 
&lt;p&gt;在實際業務場景中，特徵累積的窗口劃分通常較細粒度，例如基於 ip、query、uid 進行 keyBy，且隨着業務接入的線索和特徵增多，key 的數量變多，計算壓力進一步加大。這導致兩個主要問題：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Key 數量激增，觸發頻繁訪問狀態&lt;/strong&gt;：keyBy 後的 Key 量級極大，每個 Key 維護獨立的 Trigger，這些 Trigger 需要不斷訪問狀態後端進行觸發註冊，造成高頻狀態交互，影響吞吐。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;窗口清理（clear）導致計算壓力驟增&lt;/strong&gt;：當水位（watermark）推進到窗口末端時，大量 Key 需要同時觸發 Clear 操作，瞬時狀態訪問量暴增，可能導致作業卡頓甚至崩潰，特別是在窗口長度較長、窗口內 Key 數量龐大的情況下。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;針對上述問題，我們探索了更高效的 Trigger 機制，以降低狀態訪問開銷，提高作業穩定性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第一，減少 Trigger 數量：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;舉個例子，我們基於 UID 進行特徵聚合，如果我們在對特徵數據執行 keyBy 操作時，直接按照最細粒度的 UID 維度進行分區處理。那麼每個唯一的 key 都會綁定一個觸發器（trigger），而觸發器的數量直接影響狀態訪問的頻次和資源佔用。&lt;/p&gt; 
&lt;p&gt;為瞭解決這個問題，我們採用了按 UID 進行取模分區的方式（例如按 uid%100 進行 keyBy 分區）。這種方式顯著減少了觸發器的數量，從而降低了狀態存儲和訪問的開銷。同時我們定製了聚合函數，保證每個分區內進行聚合計算的時候還是會按照原本的 UID 作為 key 進行特徵累積，保證特徵累積的準確性。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;第二，狀態放入內存：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;進一步優化時，我們發現，當按照固定數量（如 100 個分區）取模後，key 的數量和值是確定且有限的。基於此特性，我們將觸發器的狀態從 Flink 的狀態後端遷移到內存中管理，這樣能夠進一步提升性能，避免頻繁訪問狀態存儲帶來的開銷。&lt;/p&gt; 
&lt;p&gt;有人可能擔心：觸發器狀態遷移到內存後，作業一旦發生重啓，內存中的數據會丟失，這可能導致窗口數據無法正常觸發。例如，若按 UID 進行 keyBy 計算，某個 UID 僅有一條數據，且此時作業重啓導致其觸發器狀態丟失，那麼作業恢復後這條數據永遠可能無法下發。&lt;/p&gt; 
&lt;p&gt;但通過固定分區取模（如按 %100 分區）後，我們有效解決了這個問題：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;取模分區的 key 數量是有限的（如 100 個），並且這樣能保證每個分區會持續接收到新的數據。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;當作業重啓時，新數據的到來會自動重新註冊觸發時間，即便原有內存狀態丟失，後續的數據流動能夠重新觸發正常的處理邏輯。因此，即使觸發器狀態短暫丟失，取模後的分區會很快自愈，確保數據下發的正確性和完整性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-db078d3b573516691731e8c08cf5c321a52.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上圖最左邊-原始設計，數據流按照 uid 進行 keyBy 分組，每個 uid 都對應一個獨立的 trigger。每個 trigger 需要與狀態後端 (StateBackend) 頻繁交互，包括保存和更新狀態。存在問題是：狀態後端需要頻繁訪問，尤其在高併發場景下，性能瓶頸明顯。每個 uid 都維持一個獨立的窗口觸發器，資源消耗較高。&lt;/p&gt; 
&lt;p&gt;上圖中間-第一版優化，將原始 uid 進行取模操作 (uid % 100)，將原本細粒度的分組合併為粗粒度的分組。即多個 uid 合併到同一個分組中，減少了窗口觸發器的數量。狀態後端的訪問頻率有所減少，降低資源消耗，提升了整體吞吐量。&lt;/p&gt; 
&lt;p&gt;上圖右邊-第二版優化，內存的引入，每個 trigger 相關的信息存儲於內存中，而不是直接與狀態後端交互。大幅減少狀態後端的訪問次數。提升了系統性能，確保作業穩定運行。&lt;/p&gt; 
&lt;p&gt;綜上，在 Flink 反作弊系統的窗口特徵累積優化中，我們針對高吞吐、低延遲、抗亂序等業務需求，進行了多項改進。&lt;/p&gt; 
&lt;p&gt;1.&lt;strong&gt;提升時效性&lt;/strong&gt;：反作弊策略依賴實時特徵，默認窗口觸發方式無法滿足業務需求。因此，我們採用提前觸發機制，基於事件時間間隔觸發計算，使特徵聚合結果能夠秒級或分鐘級輸出，避免長窗口帶來的數據滯後問題。&lt;/p&gt; 
&lt;p&gt;2.&lt;strong&gt;優化性能瓶頸&lt;/strong&gt;：在高併發場景下，特徵計算涉及海量狀態存儲訪問，容易導致 RocksDB 負載過高，影響作業穩定性。我們引入批量更新、內存緩存 、trigger 優化、分區縮減等方式，大幅提升吞吐量。&lt;/p&gt; 
&lt;p&gt;綜合優化後，該方案使 Flink 反作弊系統具備更快的特徵計算能力、更高的吞吐性&lt;strong&gt;能&lt;/strong&gt;，有效支撐高併發業務場景下的實時風控需求。&lt;/p&gt; 
&lt;h1&gt;&lt;strong&gt;3.3&amp;nbsp;配置化&lt;/strong&gt;&lt;/h1&gt; 
&lt;p&gt;為了滿足反作弊策略的高頻上線和模擬過濾等需求，我們的實時系統實現了高度配置化。並且配置文件全部託管到風控平台。通過配置化驅&lt;strong&gt;動&lt;/strong&gt;的架構，無論是字段抽取、特徵加工、策略規則定義和數倉產出，均可以通過簡單的配置操作快速完成，極大地縮短了開發週期，同時降低了對底層框架代碼開發的依賴。只需要在風控平台上編輯好策略，就可以一鍵分發並啓動對應的測試或線上作業。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-33c428c7da855a9dd66a4834ea9ebbe4184.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;如上圖所示，相關配置文件可以分為兩類分別是工程配置（綠色）和策略配置（黃色），策略配置主要用於定義業務過濾規則和邏輯，工程配置側重於系統的底層運行，比如輸入輸出、並行度等配置。並且部分配置文件為非必需項，這意味着如果某個計算模塊不需要使用，則相應的配置文件可以省略。&lt;/p&gt; 
&lt;h2&gt;3.3.1 工程配置&lt;/h2&gt; 
&lt;p&gt;工程配置是管理流式作業運行的系統層面參數。針對反作弊場景的實時流式任務，與 Flink CDC YAML 的設計思路類似，也是通過 YAML 文件對通用工程配置進行抽象和統一管理，確保流式作業能夠靈活適配多種業務場景。&lt;/p&gt; 
&lt;p&gt;為了保證一個 Flink 流式作業的正常運行，完整的工程配置需要包含以下幾個關鍵部分：輸入配置、輸出配置、併發配置。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;輸入配置：決定了 Flink 作業如何接收和解析源數據，定義數據源類型（如 Kafka、HDFS）、連接參數、消費策略等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;輸出配置：定義了 Flink 作業的計算結果如何存儲或傳輸到下游系統，指定結果存儲方式（如 ClickHouse 表、Redis 集羣、Kafka Topic）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;併發配置：直接影響 Flink 作業的性能、吞吐量以及資源使用情況，設置算子並行度、檢查點間隔等，優化作業性能。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;3.3.2&amp;nbsp;策略配置&lt;/h3&gt; 
&lt;p&gt;策略配置是指將反作弊攔截策略的核心邏輯規範化，以配置文件的形式靈活定義和管理。通過策略配置化設計，能夠快速調整或部署反作弊策略，無需修改底層代碼。&lt;/p&gt; 
&lt;p&gt;策略的配置主要由字段抽取配置、特徵配置、詞表配置、模型配置和規則配置等組成。&lt;/p&gt; 
&lt;p&gt;字段抽取配置：字段是反作弊策略和數倉的最基礎的信息，根據抽取方式不同分為：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;基礎字段：直接從原始數據流中提取的字段，例如設備 ID、用戶 ID 等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;二次計算字段：通過基礎字段計算生成的派生字段，設備 ID 是否合法，UID 是否為歷史黑用戶等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;外部服務字段：通過調用外部服務接口動態獲取的字段，例如 IP 地址歸屬地、安全風控標籤等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;維表字段：通過查詢詞表映射關係獲得的字段，例如黑名單匹配結果、分類標籤等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;我們將字段抽取邏輯進行了配置化抽象，策略開發人員使用類似於寫 sql 的方式即可完成簡單字段的 etl 邏輯的開發，如常見的 json 字段抽取，字符串處理，反作弊內部的常用 UDF 等，配置能覆蓋大部分字段抽取，對於複雜的字段抽取邏輯仍舊使用 Flink 的 Datastream API 開發實現。&lt;/p&gt; 
&lt;p&gt;特徵配置：特徵是策略的重要判定依據，特徵配置包括以下幾個關鍵方面：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;特徵類型：數據的聚合方式，如 sum、count、distinct 等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;窗口信息：設置聚合特徵的時間窗口範圍和窗口形式，時間範圍如：1 分鐘、1 小時等，窗口形式如：滑動窗口、滾動窗口等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;特徵維度：特徵的聚合維度，如用戶、設備、IP 地址等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;詞表配置：詞表通常是離線挖掘得到的黑名單、字段映射（如 ip 映射城市）等固定維表信息，配置內容需包括以下幾個方面：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;詞表路徑：指定詞表的存儲位置，支持文件路徑或分佈式存儲地址。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;詞表類型：支持多種形式的詞表，包括集合（set）、鍵值對映射（kv）、正則表達式（regex）等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;模型配置：通過模型實現複雜的行為預測和風險判定，關鍵配置內容包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;模型路徑：指定模型的存儲位置，支持本地或遠程加載。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;模型類型：支持多種模型形式，例如線性迴歸、GBDT 等，目前模型的加載是通過 PMML 框架實現的。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;模型輸入輸出：明確模型所需的輸入字段和輸出字段等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;規則配置&lt;/strong&gt;：規則配置決定了作弊行為的最終判定規則和處置方式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;策略判定閾值：定義觸發策略的條件，例如基礎字段匹配、詞表匹配、風險評分的閾值、特徵累積閾值、模型打分閾值等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;策略判黑等級：設定風險等級，區分低、中、高風險及對應的處置措施。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;如下圖所示，規則配置能夠獲取所有字段信息，並基於這些信息進行最後的策略判定。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-3e2b45a57ad48af62f1e82de4627311d047.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這張圖展示了反作弊規則的判定流程：&lt;/p&gt; 
&lt;p&gt;1.&lt;strong&gt;輸入數據&lt;/strong&gt;：每條 PV 包含多個字段**，**包括基礎字段（如 IP、手機號、UID 等）、外部抽取字段（如 IP 歸屬地、是否異常等）、計算得到的特徵（如統計特徵 fea1、fea2 等）以及模型得分（多個模型計算的分值）。&lt;/p&gt; 
&lt;p&gt;2.&lt;strong&gt;策略判定&lt;/strong&gt;：系統基於預設的反作弊規則，對各字段、特徵、模型分數進行綜合評估。例如，規則 1 要求【fea1 &amp;gt; 100 &amp;amp;&amp;amp; model2 &amp;gt; 0.95】，規則 2 要求 【IP like &#39;192.%&#39; &amp;amp;&amp;amp; fea2 &amp;gt; 100 &amp;amp;&amp;amp; model1 &amp;gt; 0.65】。多個規則都會執行判定邏輯，判斷是否命中。&lt;/p&gt; 
&lt;p&gt;3.&lt;strong&gt;結果輸出&lt;/strong&gt;：最終的 PV 數據會帶上反作弊命中結果。例如，在示例中，該 PV 數據命中了規則 2，表明該行為可能存在風險。&lt;/p&gt; 
&lt;p&gt;以上就是策略配置的所有介紹，通過配置化管理字段、特徵、詞表、模型和規則，反作弊系統能夠快速響應業務需求，靈活調整檢測邏輯。同時，配置化設計大幅降低了開發部署成本，提高了策略迭代效率。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;3.4&amp;nbsp;模擬過濾的實現&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;通過配置化的支持，可以方便地切換數據輸入和輸出，所以僅需調整測試配置文件，即可啓動模擬過濾作業，提升測試效率。同樣的模擬過濾功能也接入了風控平台，開發者可以直接一鍵調啓模擬過濾任務。&lt;/p&gt; 
&lt;p&gt;對於直接接入實時消息隊列進行模擬過濾，基本無需修改輸入配置，然而，基於實時消息隊列的模擬過濾存在一定侷限性，首先運行耗時較長，需要 1:1 的時間來進行測試。如過濾 24 小時數據需 24 小時，難以快速驗證策略長期效果，其次消息隊列僅保存最近幾天的數據，歷史數據回溯能力有限。一般僅適用於簡單工程測試和策略模擬過濾。&lt;/p&gt; 
&lt;p&gt;為此，我們擴展了 Flink 的 HDFS Source 組件，支持直接讀取 HDFS 上的 Parquet 文件進行模擬過濾。在讀取 Parquet 文件時，因為是流式計算，主要挑戰在於數據順序問題，為確保數據時序一致性，我們採取了以下優化策略：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;文件級別排序&lt;/strong&gt;：在讀取數據時，按照文件路徑和名稱進行排序，確保數據按時間順序加載。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;順序讀取文件&lt;/strong&gt;：嚴格按照排序後的順序依次讀取 Parquet 文件，避免亂序問題，保證數據的時序性。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;通過這一優化方案，我們在策略模擬過濾中與線上對比測試，準確率達到 99% 左右，大幅提升了模擬過濾的可靠性和一致性。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-cbc609f6de7bc91ac2b4a0563226cd94838.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;除了 Source 組件適配了讀取離線數據外，其他組件跟線上完全一致，這樣就保證了模擬過濾的準確性。極端場景下（如線上作業出錯需重新回溯數據），可通過此方式對離線數據再次模擬流式過濾，實現數據修正。&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;3.5&amp;nbsp;便捷的數據分析&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;在實時反作弊系統中，數據分析不僅是風控團隊優化策略的核心工具，也是業務方監控風險、評估影響的重要支撐。為了滿足不同角色的分析需求，系統提供了離線和實時的數倉產出，幫助進行便捷的數據分析。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a414bc27b82636814d788831804ca209d97.jpg&quot; alt=&quot;圖片&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;上圖展示了我們的數倉方案，其中 Flink 負責實時數據流的計算和處理，最終將數據分別存儲到 HDFS（Parquet 格式） 和 ClickHouse。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;離線 Hive 表&lt;/strong&gt;：Flink 將數據以 Parquet 格式，存儲到 HDFS，支持按刻鐘或小時級別分區產出數據，並掛載到圖靈表中，便於後續使用 Hive、Spark 進行批量計算和查詢。也可以作為後續回溯和測試模擬過濾的直接輸入。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;實時 ClickHouse 表&lt;/strong&gt;：支持實時數據產出，用於高性能的 OLAP 分析，可用於快速分析策略上線效果、構建實時看板以及告警監控等場景。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;這種架構能夠同時滿足，實時查詢，和 離線存儲分析，需求，實現高效的數據流式處理與存儲。&lt;/p&gt; 
&lt;p&gt;高效便捷的數據分析主要滿足瞭如下需求：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;實時監控與告警&lt;/strong&gt;：業務方需實時瞭解反作弊策略的執行效果（如攔截量趨勢、高風險用戶分佈）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;基於 ClickHouse 的秒級查詢能力，支持實時生成監控看板（如「近 1 小時攔截量 TOP 10 IP」）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;配置告警規則（如「攔截量突增 50%」），通過郵件或消息推送及時通知相關人員。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;自助分析與可視化&lt;/strong&gt;：業務方能夠靈活分析作弊行為特徵（如羊毛黨設備型號分佈、異常行為時間規律）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;接入 TDA 自助分析平台，支持 SQL 查詢與拖拽式可視化分析，無需依賴數據團隊。預置常用分析儀表盤，降低使用門檻。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;離線挖掘與模型優化&lt;/strong&gt;：數據同學能夠於歷史數據挖掘作弊模式，優化策略規則與機器學習模型。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;將全量數據存儲至 Hive，支持 Spark、Flink 等分佈式計算引擎進行進一步的複雜分析。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;通過便捷的數據分析能力，系統不僅提升了風控策略的迭代效率，還賦能業務方自主探索數據價值，實現從「被動響應」到「主動洞察」的轉變。&lt;/p&gt; 
&lt;h1&gt;04 總結&lt;/h1&gt; 
&lt;p&gt;本文介紹了基於 Flink 的實時反作弊流式過濾系統，圍繞架構設計、挑戰應對及優化方案展開。通過特徵計算和配置化管理，提升了系統的檢測效率和穩定性。實踐表明，該方案在提升數據處理時效性與反作弊效果方面均取得顯著成效。未來，將進一步優化策略檢測機制，提升檢測精準度，並探索更智能的風險識別手段。&lt;/p&gt; 
&lt;p&gt;------END-----&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;推薦閲讀&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247604182%26idx%3D1%26sn%3D224203a0b523de10d3b6365d9a3a0aa5%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;百度智能雲 xDeepSeek，最具性價比的 DeepSeek 一體機合集來了！&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247604157%26idx%3D1%26sn%3D4f72a1ce996776b78cf02f13e7e74c2c%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;圖引擎在智能體開發場景的應用實踐&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247604082%26idx%3D1%26sn%3D997d754d2058e4d0fc83d6209da36c28%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;直播間互動框架性能優化與穩定性實踐&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247604026%26idx%3D1%26sn%3Db6c6367e9bcbe2dab70a1282140ea740%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;百度網盤防雪崩架構實踐&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg5MjU0NTI5OQ%3D%3D%26mid%3D2247603987%26idx%3D1%26sn%3D4a88159ec791a37e75053139e0b4682c%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;如何在百度百舸部署滿血版 DeepSeek-V3、DeepSeek-R1 模型&lt;/a&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4939618/blog/17819722</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4939618/blog/17819722</guid>
            <pubDate>Mon, 17 Mar 2025 06:49:09 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>國家統計局：國產人工智能大模型異軍突起</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;國家統計局新聞發言人、國民經濟綜合統計司司長付凌暉在國務院新聞辦公室舉行的新聞發佈會上表示，從前兩個月情況來看，科技創新不斷取得新突破，新產業發展向好，數字經濟、綠色經濟持續壯大，傳統產業轉型升級步伐穩步推進，新質生產力發展取得新進展。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;新興產業保持較快增長。前兩個月，規模以上高技術製造業增加值同比增長 9.1%，比上年全年加快 0.2 個百分點。國產人工智能大模型異軍突起，「人工智能+」等創新產品跑出了加速度，推動生產方式變革，帶動高端製造快速發展。1-2 月份，集成電路圓片、工業機器人、動車組、民用無人機等高技術產品產量同比分別增長 19.6%、27%、64%、91.5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;數字經濟活力不斷釋放。各地區各部門加快推進產業數字化和數字產業化，數字經濟發展勢頭向好。從行業來看，前兩個月，規模以上數字產品製造業增加值同比增長 9.1%，信息傳輸軟件和信息技術服務業生產指數增長 9.3%。從產品來看，3D 打印設備、虛擬現實設備等智能產品產量分別增長 30.2%、37.7%。5G 規模化應用持續推進，春節期間 5G 移動互聯網用戶接入流量比上年同期增長 35%，佔移動互聯網用戶接入流量的比重達到 60.9%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;綠色經濟打造新增長點。綠色轉型紮實推進，為新質生產力的發展注入了新動力。前兩個月，規模以上工業風力、太陽能發電量同比分別增長 10.4% 和 27.4%，新能源汽車、汽車用鋰離子動力電池、碳纖維及其複合材料等綠色產品的產量分別增長 47.7%、35.4%、51.5%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;產業轉型升級步伐穩健。產業數字化轉型、智能化升級為新質生產力發展增添新來源。前兩個月，製造業技改投資同比增長 10%，快於全部投資 5.9 個百分點。目前，我國已經建成了 3 萬多家基礎級智能工廠、1200 餘家先進級智能工廠、230 餘家卓越級智能工廠，將有效賦能產業轉型升級。(來源：光明網)&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339377</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339377</guid>
            <pubDate>Mon, 17 Mar 2025 06:46:09 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>小米大模型團隊登頂音頻推理 MMAU 榜</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;@小米技術，官微今日&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F6486870325%2FPiWm5dWt9%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;發文稱&lt;/a&gt;&lt;/u&gt;，小米大模型團隊在音頻推理領域取得突破性進展。&lt;strong&gt;受 DeepSeek-R1 啓發，團隊率先將強化學習算法應用於多模態音頻理解任務，僅用一週時間便以 64.5% 的 SOTA 準確率登頂國際權威的 MMAU 音頻理解評測榜首，現同步開源&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0317/143932_ioaO_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0317/144349_iKQr_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;官方全文如下：&lt;/p&gt; 
&lt;h3&gt;強化學習展現「反直覺」優勢 —— 小米大模型團隊登頂音頻推理 MMAU 榜&lt;/h3&gt; 
&lt;p&gt;面對一段汽車行駛中的座艙錄音，AI 能否判斷出汽車是否存在潛在的故障？在交響樂演出現場，AI 能否推測出作曲家創造這首音樂時的心情？在早高峯地鐵站混亂的腳步聲潮中，AI 能否預判閘機口可能發生的衝撞風險？在大模型時代，人們已經不滿足於機器僅僅識別説話的內容、聲音的種類，更期望機器具備複雜推理的能力。&lt;/p&gt; 
&lt;p&gt;MMAU（Massive Multi-Task Audio Understanding and Reasoning）評測集（&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2410.19168&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/2410.19168&lt;/a&gt;）是這種音頻推理能力的量化標尺，它通過一萬條涵蓋語音、環境聲和音樂的音頻樣本，結合人類專家標註的問答對，測試模型在 27 種技能，如跨場景推理、專業知識等應用上的表現，期望模型達到接近人類專家的邏輯分析水平。&lt;/p&gt; 
&lt;p&gt;作為基準上限，人類專家在 MMAU 上的準確率為 82.23%。這是一個很難的評測集，目前 MMAU 官網榜單上表現最好的模型是來自 OpenAI 的 GPT-4o，準確率為 57.3%。緊隨其後的是來自 Google DeepMind 的 Gemini 2.0 Flash，準確率為 55.6%。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-3b140b978b8e575f07877afe084fdcbad6f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;MMAU 任務示例圖片來自 MMAU 論文&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;來自阿里的 Qwen2-Audio-7B 模型在此評測集上的準確率為 49.2%。由於它的開源特性，我們嘗試使用一個較小的數據集，清華大學發佈的 AVQA 數據集（https://mn.cs.tsinghua.edu.cn/avqa/），對此模型做微調。AVQA 數據集僅包含 3.8 萬條訓練樣本，通過全量有監督微調（SFT），模型在 MMAU 上的準確率提升到了 51.8%。這並不是一個特別顯著的提升。&lt;/p&gt; 
&lt;p&gt;DeepSeek-R1 的發佈為我們在該項任務上的研究帶來了啓發。DeepSeek-R1 的 Group Relative Policy Optimization (GRPO) 方法，讓模型僅通過 &quot;試錯-獎勵&quot; 機制就能使自主進化，湧現出類似人類的反思、多步驗證等推理能力。在同一時間，卡內基梅隆大學發佈的論文預印本「All Roads Lead to Likelihood: The Value of Reinforcement Learning in Fine-Tuning (https://arxiv.org/abs/2503.01067) 」，通過精巧的實驗得出了一個有趣的論斷：當任務存在明顯的生成-驗證差距（Generation-Verification Gap），即任務生成結果的難度遠大於驗證結果正確性的難度時，強化學習比起有監督微調具有獨特優勢，&lt;strong&gt;而 AQA 任務恰好是完美的生成-驗證差距顯著的任務。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;打個比方來説，離線微調方法，如 SFT，有點像背題庫，你只能根據已有的題目和答案訓練，但遇到新題可能不會做；而強化學習方法，如 GRPO，像老師在要求你多想幾個答案，然後老師告訴你哪一個答案好，讓你主動思考，激發出自身的能力，而不是被「填鴨式」教學。當然，如果訓練量足夠，比如有學生願意花很多年的時間來死記硬背題庫，也許最終也能達到不錯的效果，但效率太低，浪費太多時間。而主動思考，更容易快速地達到舉一反三的效果。強化學習的實時反饋可能會幫助模型更快鎖定高質量答案的分佈區域，而離線方法需要遍歷整個可能性空間，效率要低得多。&lt;/p&gt; 
&lt;p&gt;基於上述洞察，&lt;strong&gt;我們嘗試將 DeepSeek-R1 的 GRPO 算法遷移到 Qwen2-Audio-7B 模型上&lt;/strong&gt;。令人驚喜的是，在僅使用 AVQA 的 3.8 萬條訓練樣本的情況下，&lt;strong&gt;強化學習微調後的模型在 MMAU 評測集上實現了 64.5% 的準確率，這一成績比目前榜單上第一名的商業閉源模型 GPT-4o 有近 10 個百分點的優勢。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;有趣的是，當我們在訓練中強制要求模型輸出 &amp;lt;thinking&amp;gt;&amp;lt;/thinking&amp;gt; 推理過程時（類似傳統思維鏈方法），準確率反而下降至 61.1%。這説明顯式的思維鏈結果輸出可能並不利於模型的訓練。&lt;/p&gt; 
&lt;p&gt;我們的實驗揭示了幾個和傳統認知不同的結論：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;關於微調方法：強化學習在 3.8 萬條數據集上的表現顯著超過監督學習在 57 萬條數據集上的結果&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;關於參數規模：相比千億級模型，7B 參數的模型通過強化學習也可展現強推理能力&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;關於隱式推理：顯式思維鏈輸出反而成為性能瓶頸&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;儘管當前準確率已突破 64%，但距離人類專家 82% 的水平仍有差距。在我們當前的實驗中，強化學習策略還是比較粗糙，訓練過程對思維鏈的引導並不充分，我們會在後續做進一步探索。&lt;/p&gt; 
&lt;p&gt;此次實驗驗證了強化學習在音頻推理領域的獨特價值，也為後續研究打開了一扇新的大門。當機器不僅能 &quot;聽見&quot; 聲音，還能 &quot;聽懂&quot; 聲音背後的因果邏輯時，真正的智能聽覺時代將會來臨。&lt;/p&gt; 
&lt;p&gt;我們把訓練代碼、模型參數開源，並提供了技術報告，供學術界產業界參考交流。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;訓練代碼：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fxiaomi-research%2Fr1-aqa&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaomi-research/r1-aqa&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;模型參數：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fhuggingface.co%2Fmispeech%2Fr1-aqa&quot; target=&quot;_blank&quot;&gt;https://huggingface.co/mispeech/r1-aqa&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;技術報告：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farxiv.org%2Fabs%2F2503.11197&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/abs/2503.11197&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;交互 Demo：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=http%3A%2F%2F120.48.108.147%3A7860%2F&quot; target=&quot;_blank&quot;&gt;http://120.48.108.147:7860/&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339374</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339374</guid>
            <pubDate>Mon, 17 Mar 2025 06:43:09 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>深圳市監局回應翻新機流入「百億補貼」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 14 日，深圳市場監管官方賬號&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F3096706037%2FPivbVcoJ8%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;發佈瞭如下情況通報&lt;/a&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0317/142845_zd5R_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;深圳市場監管局表示，「近日有媒體報道稱，華強北市場有翻新手機流入某電商平台「百億補貼」活動。此前其已聯合轄區公安局、屬地街道辦等單位對後封機、翻新機的生產、銷售鏈條開展了多輪專項治理；針對報道中提及的線索，深圳市場監管局高度重視，已第一時間組織執法人員到華強北及周邊手機銷售市場進行覈查。」&lt;/p&gt; 
&lt;p&gt;此前，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOhcR-SyMPDXAiHeu0rH3iw&quot; target=&quot;_blank&quot;&gt;據新京報貝殼財經記者暗訪發現&lt;/a&gt;&lt;/u&gt;，位於深圳的華強北市場有大量翻新機、改裝機、瑕疵機進行二次包裝後，通過購物平台的「百億補貼」專區流入市場，但因平台上店鋪信息不透明、不公開等原因，導致消費者維權難，甚至維權失敗。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;344&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0317/143320_EUun_2720166.png&quot; width=&quot;1266&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0317/143355_fGc2_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;img height=&quot;14&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0317/143331_Ri6R_2720166.png&quot; width=&quot;14&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;報道指出，《產品質量法》明確規定，對於不具備產品應具備使用性能而事先未作説明或不符合產品説明、實物樣品等方式表明的質量狀況等，銷售者應當負責修理、更換、退貨並賠償損失。因此，如果平台對消費者拒絕履行以上法定義務的，就侵犯了消費者的合法權益。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339373</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339373</guid>
            <pubDate>Thu, 06 Mar 2025 06:34:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>百川智能聯合創始人焦可、陳煒鵬出走，均開啓 AI 領域創業</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;藍鯨新聞從多位知情人士處獨家獲悉，大模型六小虎之一的百川智能創始團隊出現變動，其中，聯合創始人焦可已經離職，另一位聯合創始人陳煒鵬也將離職，目前還在走內部流程。另據知情人士稱，焦可和陳煒鵬兩人都已經分別開始 AI 領域的創業。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;焦可和陳煒鵬都是在百川智能創立早期就加入公司的創始團隊成員。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;焦可在本科期間就讀於清華大學計算機專業，和王小川是校友，之後碩士就讀於中國科學院計算技術研究所碩士。知情人士稱，在百川智能期間，焦可主要負責互聯網業務。知情人士透露，目前焦可已經在 AI 語音方向創業，且正在尋求融資。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-4ace6aceb943f52a522046a798c49026095.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;em&gt;前百川智能聯合創始人焦可&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;另一位聯合創始人陳煒鵬在百川智能期間主要負責大語言模型技術部分，同時也曾在搜狗擔任高管。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;資料顯示，陳煒鵬 2012 年畢業於哈爾濱工業大學，在搜狗時，陳煒鵬曾擔任搜狗搜索研發總經理，負責搜狗通用/垂直搜索和推薦系統的研發工作。搜狗被騰訊收購後，陳煒鵬加入 Soul，擔任技術 VP，負責算法能力建設，推動內容理解、推薦技術和 AIGC 技術在社交場景的應用和落地。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;317&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d0101b72f1883ead7d60a06095868407a36.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;margin-left:0px; margin-right:0px; text-align:justify&quot;&gt;&lt;em&gt;百川智能聯合創始人陳煒鵬&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;知情人士透露，雖然還沒走完離職流程，但陳煒鵬目前已經在籌備創業，項目為 AI Coding 方向，並在陸續接觸一些投資人。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百川的這兩位聯創變動或與公司 All in AI 醫療的戰略調整有關。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339369</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339369</guid>
            <pubDate>Thu, 06 Mar 2025 06:24:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>華為餘承東預熱「想不到」新品：它確實是手機，又不止是手機</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;為常務董事、終端 BG 董事長、智能汽車解決方案 BU 董事長餘承東今日&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fweibo.com%2F1100856704%2FPiVvlj04a%3Fpagetype%3Dprofilefeed&quot; target=&quot;_blank&quot;&gt;發佈一條預熱視頻&lt;/a&gt;&lt;/u&gt;：&lt;strong&gt;「想不到」新品確實是手機，又不止是手機&lt;/strong&gt;，3 月 20 日揭曉答案。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-145f75d4bd3807389c982517da61f8c9d79.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;從視頻中可以看到，餘承東手持一款居中打孔的手機產品，但未能透露更多信息。此前官方宣稱「1610 大開想象」，有網友猜測該數字在暗示新機的屏幕比例變為 16:10。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-27a5d1a209516e8e4542880996f440a648e.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;相關閲讀&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338389&quot; target=&quot;news&quot;&gt;餘承東預告：首款原生鴻蒙正式版手機下週發佈&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339367</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339367</guid>
            <pubDate>Thu, 06 Mar 2025 06:16:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>廣東組建總規模 100 億元的人工智能與機器人產業投資基金</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;恆健控股公司與中國工商銀行廣東省分行、工銀金融資產投資有限公司 3 月 16 日簽約，共同推動組建總規模 100 億元的人工智能與機器人產業投資基金。該基金是在國家進一步擴大金融資產投資公司（AIC）股權投資試點後，由廣東省金融系統和國資系統共同組建的首隻廣東省屬 AIC 股權投資基金。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據合作協議，人工智能與機器人產業投資基金總規模 100 億元，首期規模 20 億元，將重點圍繞省內外人工智能、機器人等科技創新和先進製造領域產業鏈進行投資佈局，為相關項目提供行業上下游資源以及相關服務賦能，助力加快發展壯大新質生產力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;340&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-67e9d0200a6951938b5f73473343a7992bb.png&quot; width=&quot;700&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，該基金已儲備擬投資項目 10 餘個。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「接下來，基金將發揮簽約三方作為耐心資本的優勢，通過提供全生命週期的投貸聯動服務，充分挖掘全國產業鏈鏈主項目、上下游優質項目和省級重點科技項目，重點投資人工智能與機器人產業鏈中的科技型、製造業核心企業，支持廣東省人工智能及機器人產業鏈關鍵核心領域高質量發展，助力廣東打造全球人工智能與機器人產業創新高地。」&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339365</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339365</guid>
            <pubDate>Thu, 06 Mar 2025 06:12:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>傅利葉開源全尺寸人形機器人數據集 Fourier ActionNet</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上海機器人企業傅利葉&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOUnrU8UTjlaBsvVUYFtyag&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;正式開源全尺寸人形機器人數據集 &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Faction-net.org%2F&quot; target=&quot;_blank&quot;&gt;Fourier ActionNet&lt;/a&gt;，併發布全球首個全流程工具鏈。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;首批上線超 3 萬條高質量真機訓練數據，包含多種自由度靈巧手的訓練數據及專門針對手部任務的模仿學習數據，面向全球開發者及科研機構開源共享，提供從數據採集、訓練、部署的一站式解決方案。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告稱，Fourier ActionNet 數據集囊括傅利葉 GRx 系列所有機型的各類任務訓練，完整記錄機器人在真實環境中的任務執行數據，涵蓋了對常用工具、家居用品、食物等多種物體的精確取放、傾倒等操作，以及在不同環境條件下實現泛化執行。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;多模態+高質量+萬級體量：&lt;/strong&gt;萬級真機訓練數據，包含專門針對手部任務的模仿學習數據，適配多自由度靈巧手任務；&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;356&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-1a209cbc17be4d851c785485ac5d53783d3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;VLM 標註+人工核驗：&lt;/strong&gt;所有數據均採用視覺語言模型（VLM）進行自動標註，並通過人工二次核驗，確保數據精度與準確性。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;除了數據集的開源以外，傅利葉同步開放了全球首個包含採集算法、訓練算法以及數據部署算法的全流程工具鏈。開源的訓練框架（如 DP、ACT、iDP3）和部署工具，進一步降低了人形機器人技術研發門檻。&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;自帶數據質量評估：&lt;/strong&gt;基於擴散策略（DP）、Transformer 動作分塊策略（ACT）及改進 3D 擴散策略（iDP3）對數據集進行系統性驗證，在 GRx 全系列機型中均可穩定執行開櫃門、抓取檸檬、傾倒豆子等高難度任務；&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;224&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-e17b14af3900b54606079ee3bcdd1ae14ba.gif&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;配套開發工具支持：&lt;/strong&gt;同步開源基於 LeRobot 生態的 DP、ACT、iDP3 等主流訓練框架和部署框架，提供從數據管理到算法部署的全流程支持。&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339341</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339341</guid>
            <pubDate>Thu, 06 Mar 2025 05:44:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>得物 Android Crash 治理實踐</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;h1&gt;一、前言&lt;/h1&gt; 
&lt;p&gt;通過修復歷史遺留的 Crash 漏報問題（包括端側 SDK 採集的兼容性優化及 Crash 平台的數據消費機制完善），得物 Android 端的 Crash 監控體系得到顯著增強，使得歷史 Crash 數據的完整捕獲能力得到系統性改善，相應 Crash 指標也有所上升，經過架構以及各團隊的共同努力下，崩潰率已從最高的萬 2 降至目前的萬 1.1 到萬 1.5，其中疑難問題佔比約 90%、因系統 bug 導致的 Crash 佔比約 40%，在本文中將簡要介紹一些較典型的系統 Crash 的治理過程。&lt;/p&gt; 
&lt;h1&gt;二、DNS 解析崩潰&lt;/h1&gt; 
&lt;h2&gt;背景&lt;/h2&gt; 
&lt;p&gt;Android11 及以下版本在 DNS 解析過程中的有幾率產生野指針問題導致的 Native Crash，其中 Android9 佔比最高。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;堆棧與上報趨勢&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;at libcore.io.Linux.android_getaddrinfo(Linux.java)
at libcore.io.BlockGuardOs.android_getaddrinfo(BlockGuardOs.java:172)
at java.net.InetAddress.parseNumericAddressNoThrow(InetAddress.java:1631)
at java.net.Inet6AddressImpl.lookupAllHostAddr(Inet6AddressImpl.java:96)
at java.net.InetAddress.getAllByName(InetAddress.java:1154)

#00 pc 000000000003b938  /system/lib64/libc.so (android_detectaddrtype+1164)
#01 pc 000000000003b454  /system/lib64/libc.so (android_getaddrinfofornet+72)
#02 pc 000000000002b5f4  /system/lib64/libjavacore.so (_ZL25Linux_android_getaddrinfoP7_JNIEnvP8_jobjectP8_jstringS2_i+336)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//cace5743475094d99aeed5e0d4c7bb62.jpeg&quot; alt=&quot;上報趨勢.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;問題分析&lt;/h2&gt; 
&lt;p&gt;崩潰入口方法 InetAddress.getAllByName 用於根據指定的主機名返回與之關聯的所有 IP 地址，它會根據系統配置的名稱服務進行解析，沿着調用鏈查看源碼發現在 parseNumericAddressNoThrow 方法內部調用 Libcore.os.android_getaddrinfo 時中有 try catch 的容錯邏輯，繼續查看後續調用的 c++的源碼，在調用 android_getaddrinfofornet 函數返回值不為 0 時拋出 GaiException 異常。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;https://cs.android.com/android/platform/superproject/+/android-9.0.0_r49:libcore/ojluni/src/main/java/java/net/InetAddress.java

static InetAddress parseNumericAddressNoThrow(String address) {
       // Accept IPv6 addresses (only) in square brackets for compatibility.
       if (address.startsWith(&quot;[&quot;) &amp;amp;&amp;amp; address.endsWith(&quot;]&quot;) &amp;amp;&amp;amp; address.indexOf(&#39;:&#39;) != -1) {
           address = address.substring(1, address.length() - 1);
       }
       StructAddrinfo hints = new StructAddrinfo();
       hints.ai_flags = AI_NUMERICHOST;
       InetAddress[] addresses = null;
       try {
           addresses = Libcore.os.android_getaddrinfo(address, hints, NETID_UNSET);
       } catch (GaiException ignored) {
       }
       return (addresses != null) ? addresses[0] : null;
   }
&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;https://cs.android.com/android/platform/superproject/+/master:libcore/luni/src/main/native/libcore_io_Linux.cpp?q=Linux_android_getaddrinfo&amp;amp;ss=android%2Fplatform%2Fsuperproject

static jobjectArray Linux_android_getaddrinfo(JNIEnv* env, jobject, jstring javaNode,
        jobject javaHints, jint netId) {
    ......
    int rc = android_getaddrinfofornet(node.c_str(), NULL, &amp;amp;hints, netId, 0, &amp;amp;addressList);
    std::unique_ptr&amp;lt;addrinfo, addrinfo_deleter&amp;gt; addressListDeleter(addressList);
    if (rc != 0) {
        throwGaiException(env, &quot;android_getaddrinfo&quot;, rc);
        return NULL;
    }
    ......
    return result;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;解決過程&lt;/h2&gt; 
&lt;p&gt;解決思路是代理 android_getaddrinfofornet 函數，捕捉調用原函數過程中出現的段錯誤信號，接着吃掉這個信號並返回-1，使之轉換為 JAVA 異常進而走進 parseNumericAddressNoThrow 方法的容錯邏輯，和負責網絡的同學提前做了溝通，確定此流程對業務沒有影響後開始解決。&lt;/p&gt; 
&lt;p&gt;首先使用 inline-hook 代理了 android_getaddrinfofornet 函數，接着使用字節封裝好的 native try catch 工具做吃掉段錯誤信號並返回-1 的，字節工具內部原理是在 try 塊的開始使用 sigsetjmp 打個錨點並快照當前寄存器的值，然後設置信號量處理器並關聯當前線程，在 catch 塊中解綁線程與信號的關聯並執行業務兜底代碼，在捕捉到信號時通過 siglongjmp 函數長跳轉到 catch 塊中，感興趣的同學可以用下面精簡後的 demo 試試，以下代碼保存為 mem_err.c，執行 gcc ./mem_err.c;./a.out&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;setjmp.h&amp;gt;

struct sigaction old;
static sigjmp_buf buf;

void SIGSEGV_handler(int sig, siginfo_t *info, void *ucontext) {
    printf(&quot;信號處理 sig: %d, code: %d\n&quot;, sig, info-&amp;gt;si_code);
    siglongjmp(buf, -1);
}

int main() {
    if (!sigsetjmp(buf, 0)) {
        struct sigaction sa;

        sa.sa_sigaction = SIGSEGV_handler;
        sigaction(SIGSEGV, &amp;amp;sa, &amp;amp;old);

        printf(&quot;try exec\n&quot;);
        //產生段錯誤
        int *ptr = NULL;
        *ptr = 1;
        printf(&quot;try-block end\n&quot;);//走不到
    } else {
        printf(&quot;catch exec\n&quot;);
        sigaction(SIGSEGV, &amp;amp;old, NULL);
    }
    printf(&quot;main func end\n&quot;);
    return 0;
}

//輸出以下日誌
//try exec
//信號處理 sig: 11, code: 2
//catch exec
//main func end
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;em&gt;inline-hook 庫: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytedance%2Fandroid-inline-hook&quot; target=&quot;_blank&quot;&gt;https://github.com/bytedance/android-inline-hook&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;字節 native try catch 工具: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fbytedance%2Fandroid-inline-hook%2Fblob%2Fmain%2Fshadowhook%2Fsrc%2Fmain%2Fcpp%2Fcommon%2Fbytesig.c&quot; target=&quot;_blank&quot;&gt;https://github.com/bytedance/android-inline-hook/blob/main/shadowhook/src/main/cpp/common/bytesig.c&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;h1&gt;三、MediaCodec 狀態異常崩潰&lt;/h1&gt; 
&lt;h2&gt;背景&lt;/h2&gt; 
&lt;p&gt;在 Android 11 系統庫的音視頻播放過程中，偶爾會出現因狀態異常導致的 SIGABRT 崩潰。音視頻團隊反饋指出，這是 Android 11 的一個系統 bug。隨後，我們協助音視頻團隊通過 hook 解決了這一問題。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;堆棧與上報趨勢&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#00 pc 0000000000089b1c  /apex/com.android.runtime/lib64/bionic/libc.so (abort+164)
#01 pc 000000000055ed78  /apex/com.android.art/lib64/libart.so (_ZN3art7Runtime5AbortEPKc+2308)
#02 pc 0000000000013978  /system/lib64/libbase.so (_ZZN7android4base10SetAborterEONSt3__18functionIFvPKcEEEEN3$_38__invokeES4_+76)
#03 pc 0000000000006e30  /system/lib64/liblog.so (__android_log_assert+336)
#04 pc 0000000000122074  /system/lib64/libstagefright.so (_ZN7android10MediaCodec37postPendingRepliesAndDeferredMessagesENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEERKNS_2spINS_8AMessageEEE+720)
#05 pc 00000000001215cc  /system/lib64/libstagefright.so (_ZN7android10MediaCodec37postPendingRepliesAndDeferredMessagesENSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEi+244)
#06 pc 000000000011c308  /system/lib64/libstagefright.so (_ZN7android10MediaCodec17onMessageReceivedERKNS_2spINS_8AMessageEEE+8752)
#07 pc 0000000000017814  /system/lib64/libstagefright_foundation.so (_ZN7android8AHandler14deliverMessageERKNS_2spINS_8AMessageEEE+84)
#08 pc 000000000001d9cc  /system/lib64/libstagefright_foundation.so (_ZN7android8AMessage7deliverEv+188)
#09 pc 0000000000018b48  /system/lib64/libstagefright_foundation.so (_ZN7android7ALooper4loopEv+572)
#10 pc 0000000000015598  /system/lib64/libutils.so (_ZN7android6Thread11_threadLoopEPv+460)
#11 pc 00000000000a1d6c  /system/lib64/libandroid_runtime.so (_ZN7android14AndroidRuntime15javaThreadShellEPv+144)
#12 pc 0000000000014d94  /system/lib64/libutils.so (_ZN13thread_data_t10trampolineEPKS_+412)
#13 pc 00000000000eba94  /apex/com.android.runtime/lib64/bionic/libc.so (_ZL15__pthread_startPv+64)
#14 pc 000000000008bd80  /apex/com.android.runtime/lib64/bionic/libc.so (__start_thread+64)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6005703c8fc9279c6cdaef63e6e46c30.jpeg&quot; alt=&quot;狀態異常崩潰上報趨勢.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;問題分析&lt;/h2&gt; 
&lt;p&gt;根據堆棧內容分析 Android11 的源碼以及結合 SIGABRT 信號採集到的信息 (postPendingRepliesAndDeferredMessages: mReplyID == null, from kWhatRelease:STOPPING following kWhatError:STOPPING)，找到崩潰發生在 onMessageReceived 函數處理 kWhatRelease 類型消息的過程中，onMessageReceived 函數連續收到兩條消息，第一條是 kWhatError:STOPPING，第二條是 kWhatRelease:STOPPING 此時因 mReplyID 已經被置為空，因此走到判空拋異常的邏輯。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2F_%2Fandroid%2Fplatform%2Fframeworks%2Fav%2F%2B%2Frefs%2Ftags%2Fandroid-11.0.0_r48%3Amedia%2Flibstagefright%2FMediaCodec.cpp%3Bl%3D2280%3Bdrc%3D789055bbcb4560b42faf19103b1cda5534e8f9cb%3Bbpv%3D0%3Bbpt%3D0&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/_/android/platform/frameworks/av/+/refs/tags/android-11.0.0_r48:media/libstagefright/MediaCodec.cpp;l=2280;drc=789055bbcb4560b42faf19103b1cda5534e8f9cb;bpv=0;bpt=0&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//2e886281ace270773ec46a5dddcccff5.jpeg&quot; alt=&quot;問題分析 1.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet//384b879e4dd29cd1ebaa36ab92bbc4fb.jpeg&quot; alt=&quot;問題分析 2.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet//2b427bf5aad2f88d2301a5b30a09292c.jpeg&quot; alt=&quot;問題分析 3.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet//b5cf5aab8238a793cd8a1e8ed5fea76b.jpeg&quot; alt=&quot;問題分析 4.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 對比 Android12 的源碼，在處理 kWhatRelease 事件且狀態為 STOPPING 拋異常前，增加了對 mReplyID 不為空的判斷來規避這個問題。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2F_%2Fandroid%2Fplatform%2Fframeworks%2Fav%2F%2B%2Fca0c3286a4790a4de2d90cb275ae89a9601b805b%3Amedia%2Flibstagefright%2FMediaCodec.cpp%3Bdlc%3D7327aab894f6c456ea16c95b64134841da8d5737&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/_/android/platform/frameworks/av/+/ca0c3286a4790a4de2d90cb275ae89a9601b805b:media/libstagefright/MediaCodec.cpp;dlc=7327aab894f6c456ea16c95b64134841da8d5737&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//c877bb10835e29a63132081ad488047e.jpeg&quot; alt=&quot;規避這個問題.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;解決過程&lt;/h2&gt; 
&lt;p&gt;Android12 的修復方式意味着上述三個條件結合下吃掉異常是符合預期的，接下來就是想辦法通過 hook Android11 使邏輯對齊 Android12。&lt;/p&gt; 
&lt;p&gt;【初探】最先想到的辦法是代理相關函數通過判斷走到這個場景時提前 return 出去來規避，音視頻的同學嘗試後發現不可行，原因如下：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;void MediaCodec::postPendingRepliesAndDeferredMessages(std::string origin, status_t err): 匹配 origin 是否為特徵字符串 (postPendingRepliesAndDeferredMessages: mReplyID == null, from kWhatRelease:STOPPING following kWhatError:STOPPING)；很多設備找不到這個符號不可行；&lt;/li&gt; 
 &lt;li&gt;void MediaCodec::onMessageReceived(const sp&amp;amp;msg): 已知 MediaCodec 實例的內存首地址，需要通過 hardcode 偏移量來獲取 mReplay、mState 兩個字段，這裏又缺少可供校驗正確性的特徵，風險略大擔心有不同機型的兼容性問題 (不同機型新增、刪除字段導致偏移量不準)。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;【踩坑】接着嘗試使用與修復 DNS 崩潰類似思路的保護方案，使用 inline-hook 代理 onMessageReceived 函數調用原函數時使用 setjmp 打錨點，然後使用 plt hook 代理_android_log_assert 函數並在內部檢測錯誤信息為特徵字符串時通過 longjmp 跳轉到 onMessageReceived 函數的錨點並作 return 操作，精簡後的 demo 如下：&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Plt-hook 庫: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fiqiyi%2FxHook&quot; target=&quot;_blank&quot;&gt;https://github.com/iqiyi/xHook&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;setjmp.h&amp;gt;
#include &amp;lt;csignal&amp;gt;

static thread_local jmp_buf _buf;
void *origin_onMessageReceived = nullptr;
void *origin__android_log_assert = nullptr;

void _android_log_assert_proxy(const char* cond, const char *tag, const char* fmt, ...) {
    //模擬 liblog.so 的__android_log_assert 函數
    std::cout &amp;lt;&amp;lt; &quot;__android_log_assert start&quot; &amp;lt;&amp;lt; std::endl;
    if (!strncmp(fmt, &quot;postPendingRepliesAndDeferredMessages: mReplyID == null&quot;, 55)) {
        longjmp(_buf, -1);
    }
    //模擬調用 origin__android_log_assert，產生崩潰 
    raise(SIGABRT);
}

void onMessageReceived_proxy(void *thiz, void *msg) {
    std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy start&quot; &amp;lt;&amp;lt; std::endl;
    if (!setjmp(_buf)) {
        //模擬調用 onMessageReceived 原函數 (origin_onMessageReceived) 進入崩潰流程
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 1&quot; &amp;lt;&amp;lt; std::endl;
        _android_log_assert_proxy(nullptr, nullptr, &quot;postPendingRepliesAndDeferredMessages: mReplyID == null, from kWhatRelease:STOPPING following kWhatError:STOPPING&quot;);
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 2&quot; &amp;lt;&amp;lt; std::endl;//走不到
    } else {
        //保護後從此處返回
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 3&quot; &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy end&quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    std::cout &amp;lt;&amp;lt; &quot;main func start&quot; &amp;lt;&amp;lt; std::endl;
    /**
     inline-hook: shadowhook_hook_sym_name(&quot;libstagefright.so&quot;,&quot;_ZN7android10MediaCodec17onMessageReceivedERKNS_2spINS_8AMessageEEE&quot;,(void *) onMessageReceived_proxy, (void **) &amp;amp;origin_onMessageReceived);
     plhook: xh_core_register(&quot;libstagefright.so&quot;, &quot;__android_log_assert&quot;, (void *) (_android_log_assert_proxy), (void **) (&amp;amp;origin__android_log_assert));
     */
    //模擬調用 libstagefright.so 的_ZN7android10MediaCodec17onMessageReceivedERKNS_2spINS_8AMessageEEE 函數
    onMessageReceived_proxy(nullptr, nullptr);
    std::cout &amp;lt;&amp;lt; &quot;main func end&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}

/**
日誌輸出
 main func start
onMessageReceived_proxy start
onMessageReceived_proxy 1
__android_log_assert start
onMessageReceived_proxy 3
onMessageReceived_proxy end
main func end
*/
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;線下一陣操作猛如虎經測試保護邏輯符合預期，但是在灰度期間踩到棧溢出保護導致錯誤轉移的坑，堆棧如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#00 pc 000000000004e40c  /apex/com.android.runtime/lib64/bionic/libc.so (abort+164)
#01 pc 0000000000062730  /apex/com.android.runtime/lib64/bionic/libc.so (__stack_chk_fail+20)
#02 pc 000000000000a768 /data/app/~~JaQm4SU8wxP7T2GaSWxYkQ==/com.shizhuang.duapp-N5RFIB8WurdccMgAVsBang==/lib/arm64/libduhook.so (_ZN25CrashMediaCodecProtection5proxyEPvS0_)
#03 pc 0000000001091c0c  [anon:scudo:primary]
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;*關於棧溢出保護機制感興趣的同學可以參考這篇文章&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbbs.kanxue.com%2Fthread-221762-1.htm&quot; target=&quot;_blank&quot;&gt;https://bbs.kanxue.com/thread-221762-1.htm&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;（CSPP 第 3 版 &quot;3.10.3 內存越界引用和緩衝區溢出&quot;章節講的更詳細）*&lt;/p&gt; 
&lt;p&gt;longjmp 函數只是恢復寄存器的值後從錨點處再次返回，過程中也唯一可能會操作棧禎只有 inline-hook，當時懷疑是與 setjmp/longjmp 機制不兼容，由於 inline-hook 內部邏輯大量使用匯編來實現排查起來比較困難，因此這個問題困擾比較久，網上的資料提到可以使用代理出錯函數 (__stack_chk_fail) 或者編譯 so 時增加參數不讓編譯器生成保護代碼來繞過，這兩種方式影響面都比較大所以未採用。有了前面的懷疑點想到使用 c++的 try catch 機制來做跨函數域的跳轉，大致的思路同上只是把 setjmp 替換為 c++的 try catch，把 longjmp 替換為 throw exception，精簡後的 demo 如下：&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;c++異常機制介紹: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbaiy.cn%2Fdoc%2Fcpp%2Finside_exception.htm&quot; target=&quot;_blank&quot;&gt;https://baiy.cn/doc/cpp/inside_exception.htm&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;csignal&amp;gt;

void *origin_onMessageReceived = nullptr;
void *origin__android_log_assert = nullptr;

class MyCustomException : public std::exception {
public:
    explicit MyCustomException(const std::string&amp;amp; message)
            : msg_(message) {}

    virtual const char* what() const noexcept override {
        return msg_.c_str();
    }

private:
    std::string msg_;
};

void _android_log_assert_proxy(const char* cond, const char *tag, const char* fmt, ...) {
    //模擬 liblog.so 的__android_log_assert 函數
    std::cout &amp;lt;&amp;lt; &quot;__android_log_assert start&quot; &amp;lt;&amp;lt; std::endl;
    if (!strncmp(fmt, &quot;postPendingRepliesAndDeferredMessages: mReplyID == null&quot;, 55)) {
        throw MyCustomException(&quot;postPendingRepliesAndDeferredMessages: mReplyID == null&quot;);
    }
    //模擬調用 origin__android_log_assert，產生崩潰
    raise(SIGABRT);
}

void onMessageReceived_proxy(void *thiz, void *msg) {
    std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy start&quot; &amp;lt;&amp;lt; std::endl;
    try {
        //模擬調用 onMessageReceived 原函數 (origin_onMessageReceived) 進入崩潰流程
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 1&quot; &amp;lt;&amp;lt; std::endl;
        _android_log_assert_proxy(nullptr, nullptr, &quot;postPendingRepliesAndDeferredMessages: mReplyID == null, from kWhatRelease:STOPPING following kWhatError:STOPPING&quot;);
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 2&quot; &amp;lt;&amp;lt; std::endl;//走不到
    } catch (const MyCustomException&amp;amp; e) {
        //保護後從此處返回
        std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy 3&quot; &amp;lt;&amp;lt; std::endl;
    }
    std::cout &amp;lt;&amp;lt; &quot;onMessageReceived_proxy end&quot; &amp;lt;&amp;lt; std::endl;
}

int main() {
    std::cout &amp;lt;&amp;lt; &quot;main func start&quot; &amp;lt;&amp;lt; std::endl;
    /**
     inline-hook: shadowhook_hook_sym_name(&quot;libstagefright.so&quot;,&quot;_ZN7android10MediaCodec17onMessageReceivedERKNS_2spINS_8AMessageEEE&quot;,(void *) onMessageReceived_proxy, (void **) &amp;amp;origin_onMessageReceived);
     plhook: xh_core_register(&quot;libstagefright.so&quot;, &quot;__android_log_assert&quot;, (void *) (_android_log_assert_proxy), (void **) (&amp;amp;origin__android_log_assert));
     */
    //模擬調用 libstagefright.so 的_ZN7android10MediaCodec17onMessageReceivedERKNS_2spINS_8AMessageEEE 函數
    onMessageReceived_proxy(nullptr, nullptr);
    std::cout &amp;lt;&amp;lt; &quot;main func end&quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}

/**
日誌輸出
 main func start
onMessageReceived_proxy start
onMessageReceived_proxy 1
__android_log_assert start
onMessageReceived_proxy 3
onMessageReceived_proxy end
main func end
*/
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;灰度上線後發現有設備走到了_android_log_assert 代理函數中的 throw 邏輯，但是未按預期走到 catch 塊而是把錯誤又轉移為&quot; terminating with uncaught exception of type&quot; ，有點搞心態啊。&lt;/p&gt; 
&lt;p&gt;【柳暗花明】C++的異常處理機制在 throw 執行時，會開始在調用棧中向上查找匹配的 catch 塊，檢查每一個函數直到找到一個具有合適類型的 catch 塊，上述的錯誤信息代表未找到匹配的 catch 塊。從轉移的堆棧中注意到沒有 onMessageReceived 代理函數的堆棧，此時基於 inline-hook 的原理 (修改原函數前面的彙編代碼跳轉到代理函數) 又懷疑到它身上，再次排查代碼時發現代理函數開頭漏寫了一個宏，在 inline-hook 中 SHADOWHOOK_STACK_SCOPE 就是來管理棧禎的，因此出現找不到 catch 塊以及前面 longjmp 的問題就不奇怪了。加上這個宏以後柳暗花明，重新放量後保護邏輯按預期執行並且保護生效後視頻播放正常。和音視頻的小夥伴一努力下，經歷了幾個版本終於解決了這個系統 bug，目前僅剩老版本 App 有零星的上報。&lt;/p&gt; 
&lt;h1&gt;四、bio 多線程環境崩潰&lt;/h1&gt; 
&lt;h2&gt;背景&lt;/h2&gt; 
&lt;p&gt;Android 11 Socket close 過程中在多線程場景下有幾率產生野指針問題導致 Native Crash，現象是多個線程同時 close 連接時，一個線程已銷燬了 bio 的上下文，另外一個線程仍執行 close 並在此過程中嘗試獲取這個 bio 有多少未寫出去的字節數時出現野指針導致的段錯誤。此問題從 21 年首次上報以來在得物的 Crash 列表中一直處於較前的位置。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;堆棧與上報趨勢&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;at com.android.org.conscrypt.NativeCrypto.SSL_pending_written_bytes_in_BIO(Native method)
at com.android.org.conscrypt.NativeSsl$BioWrapper.getPendingWrittenBytes(NativeSsl.java:660)
at com.android.org.conscrypt.ConscryptEngine.pendingOutboundEncryptedBytes(ConscryptEngine.java:566)
at com.android.org.conscrypt.ConscryptEngineSocket.drainOutgoingQueue(ConscryptEngineSocket.java:584)
at com.android.org.conscrypt.ConscryptEngineSocket.close(ConscryptEngineSocket.java:480)
at okhttp3.internal.Util.closeQuietly_aroundBody0(Util.java:1)
at okhttp3.internal.Util$AjcClosure1.run(Util.java:1)
at org.aspectj.runtime.reflect.JoinPointImpl.proceed(JoinPointImpl.java:3)
at com.shizhuang.duapp.common.aspect.ThirdSdkAspect.t(ThirdSdkAspect.java:1)
at okhttp3.internal.Util.closeQuietly(Util.java:3)
at okhttp3.internal.connection.ExchangeFinder.findConnection(ExchangeFinder.java:42)
at okhttp3.internal.connection.ExchangeFinder.findHealthyConnection(ExchangeFinder.java:1)
at okhttp3.internal.connection.ExchangeFinder.find(ExchangeFinder.java:6)
at okhttp3.internal.connection.Transmitter.newExchange(Transmitter.java:5)
at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:5)

#00 pc 0000000000064060  /system/lib64/libcrypto.so (bio_ctrl+144)
#01 pc 00000000000615d8  /system/lib64/libcrypto.so (BIO_ctrl_pending+40)
#02 pc 00000000000387dc  /apex/com.android.conscrypt/lib64/libjavacrypto.so (_ZL45NativeCrypto_SSL_pending_written_bytes_in_BIOP7_JNIEnvP7_jclassl+20)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//762b069e36bfdf6a16969929dc4820ab.jpeg&quot; alt=&quot;bio 多線程.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;問題分析&lt;/h2&gt; 
&lt;p&gt;從設備分佈上看，出問題都全是 Android 11 且各個國內廠商的設備都有，懷疑是 Android 11 引入的 bug，對比了 Android 11 和 Android 12 的源碼，發現在 Android12 崩潰堆棧中的相關類 com.android.org.conscrypt.NativeSsl$BioWrapper 有四個方法增加了讀寫鎖，此時懷疑是多線程問題，通過搜索 Android 源碼的相關 issue 以及差異代碼的 MR 描述信息，進一步確認此結論。通過源碼進一步分析發現 NativeSsl 的所有加鎖的方法，會分發到 NativeCrypto.java 中的 native 方法，最終調用到 native_crypto.cc 中的 JNI 函數，如果能 hook 到相關的 native 函數並在 Native 層實現與 Android12 相同的讀寫鎖邏輯，這個問題就可以解決了。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2Fplatform%2Fsuperproject%2F%2B%2Fandroid-12.0.0_r1%3Aexternal%2Fconscrypt%2Frepackaged%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fandroid%2Forg%2Fconscrypt%2FNativeSsl.java&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:external/conscrypt/repackaged/common/src/main/java/com/android/org/conscrypt/NativeSsl.java&lt;/a&gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2Fplatform%2Fsuperproject%2F%2B%2Fandroid-11.0.0_r48%3Aexternal%2Fconscrypt%2Frepackaged%2Fcommon%2Fsrc%2Fmain%2Fjava%2Fcom%2Fandroid%2Forg%2Fconscrypt%2FNativeCrypto.java&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/platform/superproject/+/android-11.0.0_r48:external/conscrypt/repackaged/common/src/main/java/com/android/org/conscrypt/NativeCrypto.java&lt;/a&gt; &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2Fplatform%2Fsuperproject%2F%2B%2Fandroid-11.0.0_r48%3Aexternal%2Fconscrypt%2Fcommon%2Fsrc%2Fjni%2Fmain%2Fcpp%2Fconscrypt%2Fnative_crypto.cc&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/platform/superproject/+/android-11.0.0_r48:external/conscrypt/common/src/jni/main/cpp/conscrypt/native_crypto.cc&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;h2&gt;解決過程&lt;/h2&gt; 
&lt;p&gt;通過 JNI hook 代理 Android12 中增加鎖的相關函數，當走到代理函數中時，先分發到 JAVA 層通過反射獲取 ReadWriteLock 實例並上鎖再通過跳板函數調用原來的 JNI 函數，此時就完成了對 Android12 增量鎖邏輯的復刻。經歷了兩個版本的灰度 hook 方案已穩定在線上運行，期間無因 hook 導致的網絡不可用和其它崩潰問題，目前開關放全量的版本崩潰設備數已降為 0。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//1d7fbf50827b984c3a640932e1cc29f8.jpeg&quot; alt=&quot;解決過程.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;em&gt;JNI hook 原理，以及詳細修復過程: &lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.dewu-inc.com%2Farticle%2FMTMwNDU%3FfromType%3Dpersonal_blog&quot; target=&quot;_blank&quot;&gt;https://blog.dewu-inc.com/article/MTMwNDU?fromType=personal_blog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;h1&gt;五、小米 Android15 焦點處理空指針崩潰&lt;/h1&gt; 
&lt;h2&gt;背景&lt;/h2&gt; 
&lt;p&gt;隨着 Android15 開放公測，焦點處理過程中發生的空指針問題逐步增多，並在 1 月份上升到 Top。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;堆棧與上報趨勢&lt;/em&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;java.lang.NullPointerException: Attempt to invoke virtual method &#39;android.view.ViewGroup$LayoutParams android.view.View.getLayoutParams()&#39; on a null object reference
at android.view.ViewRootImpl.handleWindowFocusChanged(ViewRootImpl.java:5307)
at android.view.ViewRootImpl.-$$Nest$mhandleWindowFocusChanged(Unknown Source:0)
at android.view.ViewRootImpl$ViewRootHandler.handleMessageImpl(ViewRootImpl.java:7715)
at android.view.ViewRootImpl$ViewRootHandler.handleMessage(ViewRootImpl.java:7611)
at android.os.Handler.dispatchMessage(Handler.java:107)
at android.os.Looper.loopOnce(Looper.java:249)
at android.os.Looper.loop(Looper.java:337)
at android.app.ActivityThread.main(ActivityThread.java:9568)
at java.lang.reflect.Method.invoke(Native Method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:593)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:935)
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;問題分析&lt;/h2&gt; 
&lt;p&gt;通過分析 ASOP 的源碼，崩潰的觸發點是 mView 字段為空。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcs.android.com%2Fandroid%2Fplatform%2Fsuperproject%2Fmain%2F%2B%2Fmain%3Aframeworks%2Fbase%2Fcore%2Fjava%2Fandroid%2Fview%2FViewRootImpl.java%3Bdrc%3D98e96368cc73432efbacd6fbcf61fe789dcec0ee%3Bl%3D7243%3Fq%3DViewRootImpl&quot; target=&quot;_blank&quot;&gt;https://cs.android.com/android/platform/superproject/main/+/main:frameworks/base/core/java/android/view/ViewRootImpl.java;drc=98e96368cc73432efbacd6fbcf61fe789dcec0ee;l=7243?q=ViewRootImpl&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//6ef92423ea54dacac32d11f199709f51.jpeg&quot; alt=&quot;問題分析 5.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 源碼中 mView 為空的情況有兩種：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;未調用 setView 方法前觸發窗口焦點變化事件（只有 setView 方法才會給 mView 賦不為空的值）。&lt;/li&gt; 
 &lt;li&gt;先正常調用 setView 使 mView 不為空，其它地方置為空。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;結合前置判斷了 mAdded 為 true 才會走到崩潰點，在源碼中尋找到只有先正常調用 setView 以後在調用 dispatchDetachedFromWindow 時才滿足 mAdded=true、mView=null 的條件，從採集的 logcat 日誌中可以證明這一點，此時基本可以定位根因是窗口銷燬與焦點事件處理的時序問題。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet//05361c2af0c5fdaacfe67f2ce9943873.jpeg&quot; alt=&quot;時序問題.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt; &lt;img src=&quot;https://oscimg.oschina.net/oscnet//07d6ba4611ff6ac317c0dd892538a158.jpeg&quot; alt=&quot;時序問題 2.jpeg&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;h2&gt;解決過程&lt;/h2&gt; 
&lt;p&gt;在問題初期，嘗試通過 Hook 攔截 handleWindowFocusChanged 方法增加防禦：當檢測到 mView 為空時直接中斷後續邏輯執行。本地驗證階段，通過在 Android 15 設備上高頻觸發商詳頁 Dialog 彈窗的焦點獲取與關閉操作，未復現線上崩潰問題。考慮到 Hook 方案的侵入性風險 ，且無法本地測試，最終放棄此方案上線。&lt;/p&gt; 
&lt;p&gt;通過崩潰日誌分析發現，問題設備 100% 集中在小米/紅米機型，而該品牌在 Android 15 DAU 中僅佔 36% ，因此懷疑是 MIUI 對 Android15 某些定製功能有 bug。經與小米技術團隊數週的溝通與聯合排查，最終小米在 v2.0.28 版本修復了此問題，需要用戶升級 ROM 解決，目前&amp;gt;=2.0.28 的 MIUI 設備無此問題的上報。&lt;/p&gt; 
&lt;h1&gt;六、總結&lt;/h1&gt; 
&lt;p&gt;通過上述問題的治理，系統 bug 類的崩潰顯著減少，希望這些經驗對大家有所幫助。&lt;/p&gt; 
&lt;p&gt;文 / 亞鵬&lt;/p&gt; 
&lt;p&gt;關注得物技術，每週更新技術乾貨&lt;/p&gt; 
&lt;p&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/p&gt; 
&lt;p&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/5783135/blog/17893964</link>
            <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/17893964</guid>
            <pubDate>Thu, 06 Mar 2025 03:57:00 GMT</pubDate>
            <author>原創</author>
        </item>
        <item>
            <title>騰訊應用寶專區全量上線微軟應用商店</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;騰訊應用寶剛剛&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FC38ZfBMSqw8irkXtwlqFGQ&quot; target=&quot;_blank&quot;&gt;發佈公告&lt;/a&gt;&lt;/u&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;3 月 17 日，&lt;strong&gt;微軟應用商店騰訊應用寶專區（Tencent MyApp Hub）在 Windows 端全面上線&lt;/strong&gt;，中國區系統在 Windows 10 version 1903 build 18362 以上版本的電腦用戶，可以在桌面任務欄或開始菜單中打開微軟應用商店（版本需為 22502.1401.4.0 或更高），通過騰訊應用寶專區下載安裝熱門移動應用，安裝完成的移動應用會在桌面生成快捷方式，雙擊即可打開使用。&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;608&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0317/114340_PJlu_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
 &lt;p&gt;騰訊應用寶專區的上線不僅為用戶在 PC 場景提供了更加便捷的移動應用使用體驗，同時也為應用開發者開闢了全新的市場增長機遇。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;據介紹，此次騰訊應用寶與微軟應用商店的合作，是微軟在國內首次給第三方開放系統級的入口和資源組件，顛覆了原來下載需要歷經：安裝下載器 - 安裝市場 - 安裝 apk- 打開應用的過程，縮短了轉化鏈路，為移動應用開發者提供了全新的 PC 端分發渠道。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0317/114453_IUAc_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;深度適配的應用和遊戲不僅可以在微軟應用商店騰訊應用寶專區下載安裝，還能通過 Windows 搜索欄以及開始菜單中的推薦欄等多渠道進行推廣，助力開發者大幅提升曝光率與用戶增長。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;720&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0317/114536_f0hO_2720166.png&quot; width=&quot;1080&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在技術層面，針對移動應用開發者，騰訊應用寶為其提供了適配指導文檔、開發工具鏈與專屬的技術對接團隊，通過騰訊應用寶內置的跨端引擎技術，開發者能夠將手機應用的 ARM 指令實時翻譯為 PC 端的 X86 指令，無需重新打包應用即可在 PC 上流暢運行，大幅降低了中小開發者的適配門檻，不僅為開發者節省了大量的時間和資源投入，也讓他們能夠更加專注於核心產品的創新與優化。&lt;/p&gt; 
&lt;p&gt;基於微軟應用商店騰訊應用寶專區與移動應用進行的深度適配，用戶在 PC 上可以享受與移動端一致的原生體驗，同時藉助 PC 硬件優勢（如鍵鼠操作、大屏幕顯示等）獲得更高效的操作體驗。&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;閲讀更多：&lt;a href=&quot;https://www.oschina.net/news/294797&quot; target=&quot;news&quot;&gt;騰訊應用寶與 Microsoft Store 達成合作，Windows 可直接運行移動應用&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339214</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339214</guid>
            <pubDate>Thu, 06 Mar 2025 03:46:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Debian 12.10 發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;Debian 12.10 已發佈，作為 Debian 12 &quot;Bookworm&quot; Linux 發行版最新的常規更新。&lt;/p&gt; 
&lt;p&gt;Debian 12.10 提供了最新更新的安裝媒介，為這個 Linux 發行版帶來了數十個軟件包更新，包括各種錯誤修復和安全修復。&lt;/p&gt; 
&lt;p&gt;Debian 12.10 現在使用的是更新的 Linux 6.1 內核版本，OpenH264 軟件包修復了 Cisco 下載 URL，Xen 軟件包修復了與 Linux 6.12 及更高版本啓動的問題，以及其他一些修復。&lt;/p&gt; 
&lt;p&gt;如果你對 Debian 12.10 的數十個安全更新和各種更改的軟件包感興趣，可以通過&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.debian.org%2FNews%2F2025%2F20250315&quot; target=&quot;_blank&quot;&gt;Debian.org 公告&lt;/a&gt;找到所有詳細信息。&lt;/p&gt; 
&lt;p&gt;與此同時，&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.phoronix.com%2Fsearch%2FDebian%2B13&quot; target=&quot;_blank&quot;&gt;Debian 13&lt;/a&gt;作為下一個主要的 Debian GNU/Linux 特性發布版，預計將在 2025 年晚些時候發佈。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339211/debian-12-10-released</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339211/debian-12-10-released</guid>
            <pubDate>Thu, 06 Mar 2025 03:37:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>深度求索公司申請多枚 DeepSeekChat 商標</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;天眼查 APP 資料顯示，杭州深度求索人工智能基礎技術研究有限公司近日申請註冊多枚 DeepSeek Chat 商標，國際分類涉及教育娛樂、廣告銷售等，當前商標狀態為等待實質審查中。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;323&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7d483a5258f2222951400c26dfdaa871c06.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339209</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339209</guid>
            <pubDate>Thu, 06 Mar 2025 03:22:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>英特爾新任華人 CEO 陳立武薪酬曝光：最高可達 5 億元</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;據媒體報道，英特爾公司近日公佈了其新任 CEO 陳立武 (Lip-BuTan) 的薪酬方案。根據英特爾在週五提交的監管文件，如果陳立武能夠在未來幾年實現設定的績效目標，他的總薪酬將達到大約 6900 萬美元（約合 5 億元人民幣）。&lt;/p&gt; 
&lt;p&gt;據瞭解，陳立武的薪酬組合包括多個部分：100 萬美元的基本工資、相當於基本工資 200% 的績效獎金，以及價值 6600 萬美元的長期股權獎勵、股票期權和入職激勵。此外，陳立武還同意在上任後的前 30 天內購買價值 2500 萬美元的英特爾股票。英特爾在一份聲明中稱「陳立武的購股行為反映出他對英特爾的信心，以及致力於創造股東價值的承諾。」&lt;/p&gt; 
&lt;p&gt;陳立武將於 3 月 18 日正式上任，並同時重新加入英特爾董事會。值得一提的是，他的任命具有里程碑式的意義，因為他是英特爾成立 57 年來首位華人 CEO。在英特爾宣佈這一任命後，其股價在週四飆升了 15%，今年累計漲幅已達到 20%。&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#d35400&quot;&gt;&lt;strong&gt;相關閲讀&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338619/lip-bu-tan-remaking-intel-future&quot; target=&quot;news&quot;&gt;英特爾新任 CEO 陳立武發佈全員信：目標重新成為世界級產品公司&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338502/intel-appoints-lip-bu-tan-chief-executive-officer&quot; target=&quot;news&quot;&gt;英特爾迎來首位華裔掌舵人——任命陳立武為 CEO&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339206</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339206</guid>
            <pubDate>Thu, 06 Mar 2025 03:13:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>特斯拉中國版 FSD 首個迭代曝光：支持 HW3.0 車型、內部員工已收到推送</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;3 月 15 日消息，有自稱是特斯拉中國員工的用戶在 NGA 論壇發文稱，搭載 HW4.0 芯片的特斯拉車型已經收到第一批 FSD 推送，效果不是很理想，堪比「一個美國老司機還沒拿到中國駕照就直接上路」。&lt;/p&gt; 
&lt;p&gt;據稱，他自己（他有兩台車）搭載 HW3.0 的 Model3 性能版已於前天收到 V12.6.4 內測版推送，目前已經完成 350 公里測試，這也是特斯拉中國版 FSD 首個迭代版本，或者説第二個特斯拉 FSD 中國版。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-1216865105d3d3303233a753e0d45abf157.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;他表示，第二個版本相比首個版本進步神速，沒有出現任何一次闖紅燈和嚴重違章情況。「上下班 120 公里 80% 國道 20% 城區，退出接管不超過 3 次，不退出接管大概 5-8 次吧。」他認為，特斯拉中國版 FSD 現階段還處於訓練中。由於 HW4.0 車型版本更高且擁有更高的算力上限，他認為新版本相比之前的測試表現會實現更超預期的提升。&lt;/p&gt; 
&lt;p&gt;此前還有消息稱，特斯拉正在與百度合作以提升其 FSD 駕駛輔助系統的性能表現，&lt;span style=&quot;color:#d35400&quot;&gt;&lt;strong&gt;但特斯拉方面予以否認，稱其和百度的合作僅限於地圖導航層面&lt;/strong&gt;&lt;/span&gt;。特斯拉 2 月 25 日宣佈在中國大陸推送類似於美國市場推出的具有全自動駕駛能力的 FSD 功能——城市道路 Autopilot 自動輔助駕駛，但實際表現褒貶不一，引起大範圍爭議。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339201</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339201</guid>
            <pubDate>Thu, 06 Mar 2025 03:01:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Gemini 將取代 Google Assistant</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌在官方博客發文&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.google%2Fproducts%2Fgemini%2Fgoogle-assistant-gemini-mobile%2F&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;，將用 AI 模型 Gemini 全面取代 Android 手機上的 Google Assistant。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;618&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0317/104957_VvA7_2720166.png&quot; width=&quot;1918&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;除了運行 Android 9 或更早版本，並且 RAM 小於 2GB 的手機，其餘 Android 手機上的原版 Google Assistant 將在今年晚些時候停用，並從商店下架。&lt;/p&gt; 
&lt;p&gt;谷歌還宣佈，Android 手錶、汽車、平板電腦和耳機等設備上的 Google Assistant 也將升級到 Gemini，並將在未來幾個月內讓 Gemini 支持音箱、顯示器和電視，目前正在 Nest Mini 和 Audio 上測試。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-82c614a858bcd93ce49af43e8538394dc81.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Google Assistant 最初發佈於 2016 年 5 月，最初只支持 Pixel 系列手機，後來陸續開放給其他各類 Android 設備，並推出 iOS 應用。Google Assistant 依託谷歌的自然語言處理算法，交互類似於更早的 Google Now，但是可以雙向對話，結果以卡片形式呈現。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339198/google-assistant-upgrading-to-gemini-mobile</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339198/google-assistant-upgrading-to-gemini-mobile</guid>
            <pubDate>Thu, 06 Mar 2025 02:52:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>中金：人形機器人有望提升社會效能</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;中金公司研報稱，人形機器人有望提升社會效能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在力量型、靈巧型和空間移動導航等領域，人形機器人效率或將高於人工；在公共服務領域，從商業表演到迎賓接待，已有人形機器人的應用，未來有望拓展到更復雜的交互場景；在特種場景中，某企業的先行者系列已可在高危環境巡檢，未來救援等場景應用潛力大。總體而言，人形機器人的發展趨勢是從專用場景向通用場景滲透。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;233&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-5bbbb9066f3724346ba8ccbda092e29cb52.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;並且有望填補勞動力缺口。全球人口增速放緩，聯合國人口司數據顯示，2023 年全球總人口增速為 0.9%，較 1980 年 1.8% 的增速呈現大幅放緩，此外，老齡化人口占比擴大，勞動力人口占比下降，根據聯合國人口司預計，未來 10 年主要經濟體的老齡化人口占比繼續擴大，或全部達到 20% 以上份額。這導致用工成本上升，人形機器人有望彌補勞動力缺口，提高工作效率，助力企業降本增效，應對未來勞動力結構新形勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;人形機器人作為提升生產效率的利器，比工業機器人更靈活，可勝任更多任務，推動生產柔性化，提高生產效率。其發展可帶動產業鏈技術升級，核心零部件技術雖相對成熟，但國產力量仍需提升，中國應着眼全產業鏈佈局，以人形機器人為抓手帶動上游零部件技術攻關與產業升級。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;預測隨着成本的降低，未來中國人形機器人市場將較快增長。2030 年出貨量有望達到 35 萬台，2024 至 2030 年的複合增長率有望達到 317%；市場規模也將迅速擴張，2030 年預計達 581 億元，複合增長率 259%，有望成為經濟增長重要驅動力。隨着市場擴大，關鍵零部件的需求有望大增，以後對供應質量和穩定性要求會更高，產業協同發展是趨勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;233&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-6a227a5885514545a3bac17ca560eb81061.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339195</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339195</guid>
            <pubDate>Thu, 06 Mar 2025 02:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>倉頡開源智能體開發框架：Cangjie Magic</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;倉頡社區正式推出 Agent 開發框架 Cangjie Magic。&lt;/p&gt; 
&lt;p&gt;作為首個基於倉頡編程語言原生構建的 LLM Agent 開發平台，該框架通過三大核心技術突破重構智能體開發範式：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;獨創 Agent DSL 架構 - 基於倉頡語言特性設計的領域專用語言，實現智能體建模的聲明式編程；&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;原生支持 MCP（Model Context Protocol）通信協議；&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;智能調度引擎 - 集成模塊化服務調用機制與動態任務規劃算法&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;其核心組件 Cangjie Agent DSL 通過語義化建模語言，為開發者提供從智能體定義、行為編排到運行監控的全生命週期管理方案，顯著降低多智能體系統開發複雜度。目前該框架已完成對鴻蒙、Windows、macOS 及 Linux 系統的全平台適配，形成桌面端生態閉環。&lt;/p&gt; 
&lt;p&gt;值得關注的是，官方技術路線圖披露，基於倉頡語言的跨平台編譯能力，計劃於 Q3 季度通過突破性移動端支持方案，實現 Android/iOS 原生接口的智能體調用能力。這一技術演進將打通智能體開發的&quot;最後一公里&quot;，為構建全域智能應用奠定基礎。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;Cangjie Magic 項目介紹&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;倉頡 AgentDSL&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;模型輕鬆適配 | 多 Agent 協同 | 極簡開發&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-0c787707a9f3e2148b2284039d6636a751f.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;Cangjie Agent DSL 是一個用於定義和管理 Agent 的專用語言。它允許開發人員通過結構化的系統提示詞、工具和各類協作策略來增強 Agent 的功能。通過結構化的系統提示詞、工具以及各類協作策略，極大地增強了 Agent 的功能與靈活性。&lt;/p&gt; 
&lt;p&gt;Cangjie Agent DSL 被設計為倉頡語言的 eDSL，即在倉頡語言中通過元編程機制實現了嵌入式的 DSL，且倉頡語言作為它的宿主語言。這意味着 Agent DSL 編寫的代碼最終都被轉換為普通的倉頡代碼，並最終由倉頡編譯器完成編譯。&lt;/p&gt; 
&lt;p&gt;倉頡編程語言具有多範式編程，高性能，高併發，易擴展等特性，基於倉頡編程語言構建的 LLM Agent 開發框架將會為 AI Agent 開發帶來全新開發體驗。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;開發者可通過以下鏈接訪問 Cangjie Magic 項目並獲取更多詳細信息：&lt;em&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgitcode.com%2FCangjie-TPC%2FCangjieMagic&quot; target=&quot;_blank&quot;&gt;https://gitcode.com/Cangjie-TPC/CangjieMagic&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339193</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339193</guid>
            <pubDate>Thu, 06 Mar 2025 02:25:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>效力 14 年後，特斯拉 CAE 碰撞安全首席工程師宣佈離職</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;特斯拉 CAE 碰撞安全首席工程師 Petter Winberg 在為公司效力 14 年後，於近日宣佈離職。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;他在 linkedin 的離職聲明中寫道：「&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;Elon，2011 年：「我希望特斯拉汽車成為地球上最安全的汽車」 我：「接受挑戰」&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在開發了 Model S、S-DM、X、3、Y、Y-SP 以及未來的碰撞架構之後，我認為現在是時候離開了。謝謝特斯拉，繼續勇往直前！多麼了不起的團隊，我會想念你們所有人。」&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-658a279c3c89276e9a272539459a1c4ea04.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;electrek 主編、聯合創始人 Frederic Lambert 稱，過去十多年來，Petter Winberg 一直領導特斯拉的碰撞安全架構。他和他的團隊打造了特斯拉在獨立碰撞測試中令人難以置信的被動安全性能。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/339192</link>
            <guid isPermaLink="false">https://www.oschina.net/news/339192</guid>
            <pubDate>Thu, 06 Mar 2025 02:23:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>