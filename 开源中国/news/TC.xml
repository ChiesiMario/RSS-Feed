<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 25 Jun 2025 16:49:40 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>低代碼平台這麼多，Oinone 有何特別之處？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;Oinone 是一個低代碼平台，但又跟傳統低代碼平台不一樣。&lt;/p&gt; 
&lt;p&gt;對此，數式 Oinone 引入了一個新概念——企業級產品化引擎，是一個&lt;span style="background-color:#ffffff; color:#1f2328"&gt;集標準化研發和敏捷交付於一體的平台。從公開資料來看，&lt;/span&gt;Oinone&amp;nbsp;&lt;span style="background-color:#ffffff; color:#1f2328"&gt;已經是一個很成熟的平台了。並且該&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#1a1a1a"&gt;平台的內核源碼也開源了，開源版本具備一些基礎特性和能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;僅僅基於 Oinone 這一套統一架構，就能支撐產品打磨與交付複用，軟件公司也能像搭樂高一樣構建屬於自己的標準產品體系。如此一來，長期存在的標品開發與定製交付割裂難題就解決了，讓研發重心真正迴歸產品打磨，避免定製綁架，積累企業自身的產品化能力。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;聽起來有些誇張，具體是怎麼實現的呢？7 月 4 日晚，&lt;span style="color:#2980b9"&gt;數式 Oinone 技術總監王海明&lt;/span&gt;將做客開源中國直播欄目《技術領航》，在實戰環節，王海明將全面展示數式 Oinone 在數字化建設中的全棧能力：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;首先分別從後端研發與前端開發視角，呈現開箱即用的標準化功能模塊如何快速滿足企業基礎需求。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
  &lt;li&gt;隨後重點展開個性化二次開發深度演示：依次剖析後端業務邏輯定製、前端交互優化設計，以及無代碼模式下的可視化配置方案，完整呈現從標準化產品到個性化定製的平滑過渡路徑，幫助觀眾理解如何基於統一平台實現"標準化功能直接調用+個性化需求靈活擴展"的敏捷開發模式。&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;&lt;strong&gt;至於 Oinone &amp;nbsp;所宣傳的&lt;span style="background-color:#ffffff; color:#1f2328"&gt;「集標準化研發和敏捷交付於一體」，是不是誇張，到時候就知道了！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;直播主題：&lt;/strong&gt;滿足個性化需求，企業級產品化引擎 Oinone 實戰演示&lt;/p&gt; 
&lt;div&gt; 
 &lt;ul&gt; 
 &lt;/ul&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;strong&gt;直播時間：&lt;/strong&gt;7 月 4 日週五 19:00-20:00&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;直播平台：&lt;/strong&gt;視頻號 「OSC 開源社區」&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;直播嘉賓：&lt;/strong&gt;王海明，數式 Oinone 技術總監&lt;/p&gt; 
&lt;div&gt; 
 &lt;p&gt;&lt;strong&gt;直播亮點：&lt;/strong&gt;&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;詳解低代碼平台 Oinone 一體化架構及其全棧能力&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;如何基於 Oinone 搭建業務產品？如何基於業務產品做交付？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;作為一名研發，要如何脫離交付項目「泥潭」？&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;實操演示：標準化開箱即用，以及個性化二次開發深度演示&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;img height="706" src="https://oscimg.oschina.net/oscnet/up-a8fb468294a2b29c1ed3636883550f65bce.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;ul&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
 &lt;div&gt; 
  &lt;p&gt;&lt;strong&gt;直播福利：&lt;/strong&gt;&lt;/p&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt;
  &amp;nbsp; 
&lt;/div&gt; 
&lt;p&gt;本次直播中，我們將有 5 輪抽獎，參與就有機會獲得 OSC T 恤、馬建倉蛇年公仔（限量版）、代碼聖盃、馬克杯、冰箱貼等。特別值得一提的是，我們將送出 5 本由數式 CEO 陳鵬程撰寫的技術書籍《精講面向軟件公司的低代碼平台》，立即掃碼預約直播吧！&lt;/p&gt; 
&lt;p&gt;&lt;img height="374" src="https://oscimg.oschina.net/oscnet/up-13a1563ccd37e58e03a903a2981244ad66e.jpg" width="400" referrerpolicy="no-referrer"&gt;&lt;br&gt; &lt;br&gt; 我們還建了一個交流羣，可以經進來嘮嘮嗑，或者你有好的開源項目，也歡迎推薦過來呀~&lt;/p&gt; 
&lt;p&gt;&lt;img height="200" src="https://oscimg.oschina.net/oscnet/up-500a286b215fe8d8b5219b218bdd2e9d451.png" width="200" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="text-align:left"&gt;&lt;strong&gt;關於數式 Oinone&lt;/strong&gt;&lt;/p&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;p&gt;數式 Oinone 是一款企業級產品化引擎：用低代碼驅動標準化研發與敏捷交付的一體化平台。圍繞 「企業級產品化、標準化研發與敏捷交付」 三項核心突破，數式 Oinone 為開發者、研發團隊帶來從能力沉澱到規模化交付的完整體系。&lt;/p&gt; 
  &lt;p&gt;官網：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.oinone.top%2F" rel="nofollow" target="_blank"&gt;https://www.oinone.top/&lt;/a&gt;&lt;/p&gt; 
  &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
  &lt;h1&gt;6.2.0 版本&lt;/h1&gt; 
  &lt;ul&gt; 
   &lt;li&gt;GitHub: 
    &lt;ul&gt; 
     &lt;li&gt;後端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Foinone%2Foinone-pamirs" rel="nofollow" target="_blank"&gt;https://github.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
     &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Foinone%2Foinone-kunlun" rel="nofollow" target="_blank"&gt;https://github.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;Gitee: 
    &lt;ul&gt; 
     &lt;li&gt;後端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-pamirs" rel="nofollow"&gt;https://gitee.com/oinone/oinone-pamirs&lt;/a&gt;&lt;/li&gt; 
     &lt;li&gt;前端:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href="https://gitee.com/oinone/oinone-kunlun" rel="nofollow"&gt;https://gitee.com/oinone/oinone-kunlun&lt;/a&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;hr&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;《技術領航》是開源中國 OSCHINA 推出的一檔直播欄目，旨在為&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;開源軟件、商業產品、前沿技術、知名品牌活動等各類項目&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;提供一個展示平台，基本上每週五晚上開播&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;欄目邀請項目的創始人、核心團隊成員或資深用戶作為嘉賓，通過路演式直播分享項目的亮點和經驗，有助於提高項目的知名度，吸引更多的用戶和開發者關注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:left"&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果你手上也有好的項目，想要跟同行交流分享，歡迎聯繫我，欄目隨時開放～&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p style="color:#333333; margin-left:0px; margin-right:0px; text-align:center"&gt;&lt;img height="537" src="https://oscimg.oschina.net/oscnet/up-4dd54c1b0b817689ceefa15aa66d79cfae8.png" width="400" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/3859945/blog/18638239</link>
      <guid isPermaLink="false">https://my.oschina.net/u/3859945/blog/18638239</guid>
      <pubDate>Sat, 10 May 2025 13:55:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>一個 40 歲程序員，想做 AI 時代的 HTTP 協議</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;p&gt;大家好，我叫常高偉。寫下這篇東西的時候，我已經離開阿里快一年了。很多人問我，一個在華為、阿里幹了近二十年的老程序員，40 多歲了，為什麼還要出來折騰？折騰的，甚至還是一個聽起來很不現實，甚至有點瘋狂的項目：為 AI Agent 之間的溝通，制定一套開放的網絡協議（ANP）。有人給我起了個外號，叫「當代堂吉訶德」。這個比喻很形象，因為剛開始的時候，除了一個遙遠的「故事」，我一無所有。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;一、一個困擾我十年的問題&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;故事的起點，要回到十多年前。那時我還在通信行業工作。在通信行業，移動、聯通、電信的設備天生就是要互聯互通的，這是刻在骨子裏的規則。可在互聯網，我發現微信、來往、飛信，彼此都是孤島。我當時很困惑，以為是技術問題，想着做個「個人門戶」就能解決。很快就發現自己太天真了，大廠的數據主權是他們最核心的壁壘，不可能開放。後來我明白了，這是商業問題，封閉生態的效率在當時就是更高。&lt;/p&gt; 
&lt;p&gt;這個問題，就這麼斷斷續續地在我腦子裏盤旋了十年。直到 2024 年，AI Agent 的浪潮來了。我突然意識到，轉機出現了。未來的個人 AI 助手，要想發揮最大價值，就必須能訪問所有信息。這意味着數據必須迴歸個人，互聯網必須再次走向開放。當 AI 處理任務的成本足夠低，開放網絡的綜合效率（使用體驗、使用成本（交易成本+時間成本））終將超過封閉的平台。&lt;/p&gt; 
&lt;p&gt;這是我思考的「第一性原理」。而要支撐起一個開放、互通的智能體網絡，最底層的基石，就是一套統一的協議——就像 HTTP 之於 Web 時代一樣。並且我發現，這裏存在一個巨大的技術空白。那個念頭壓不住了，隔三差五就往外冒。我花了一整週的時間反覆推演，最後確認這不是妄想。儘管對 40 多歲、斷了收入、未來能不能再找到工作這些問題充滿了恐懼，但一種使命感推着我必須走出去。&lt;/p&gt; 
&lt;p&gt;我後來一篇隨筆寫過：「我不知道多少人能夠聽到，屬於你的使命召喚？我當時真的聽到了」。這種感覺當時真的很清晰。並且，我真的不想錯過這次技術浪潮。「當一個大的技術浪潮來臨的時候，我們要做的只有一件事情：保持在場（Be There）」。&lt;/p&gt; 
&lt;p&gt;離開阿里，也許是保持在場唯一的方法。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;二、無響應之地，即絕望之地&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;離開後的頭半年，是我最難熬的日子。我不敢告訴任何人我在做什麼，因為連我自己都覺得這事兒「很大很空」，像天方夜譚。我只是悶頭看資料、寫代碼，拿出了協議的第一個版本，發到網上。然後，石沉大海。沒有正反饋，也沒有負反饋。那種感覺，就像對着深淵呼喊，卻連一點回聲都沒有。&lt;/p&gt; 
&lt;p&gt;這是一種絕望的感覺：無響應之地，即絕望之地。&lt;/p&gt; 
&lt;p&gt;後來我試着把想法發給朋友，大多沒了下文。有的朋友比較直接：「這事未來可能需要，但做不成，也不該是你來做。」自我懷疑像野草一樣瘋長。我混跡在各種技術社羣，卻不敢介紹自己的項目，怕被人覺得不靠譜。那段時間，協議本身的設計也遇到了瓶頸。感覺自己選錯了方向，進退兩難。僅靠使命感，或許真的撐不過半年。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;三、同路人，在縫隙中聚集&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;轉機出現在我決定硬着頭皮走出去之後。2024 年 10 月，在一個出海社羣裏，我鼓起最大勇氣，介紹了我的項目。沒想到，立刻有人加我好友，説「你這個東西還蠻有想法的」。這是我收到的第一個正向反饋，至今都記得。&lt;/p&gt; 
&lt;p&gt;後來，通過朋友介紹，我認識了一位海外做智能體創業的朋友。他看到我的東西，脫口而出：「你這個協議非常不錯。」那一刻，我感覺像是找到了知己。他後來成了我事實上的「聯合發起人」，還把我引薦給了 W3C 的「Web Agent」工作組。我把工作組所有的歷史郵件和技術文檔翻了個遍，又從牛津大學一個類似的項目裏汲取了養分，加上之前對 Web 3.0 去中心化理念的思考，ANP 協議的技術路線終於清晰了起來。&lt;/p&gt; 
&lt;p&gt;真正的東風，來自行業本身。2025 年 3 月份 Anthropic 發佈 MCP 協議，以及谷歌發佈 A2A，整個行業開始意識到協議的重要性。因為我一直在公眾號和社區裏分享思考，很快就有人找了過來。我的公眾號粉絲開始上漲，加我的人也越來越多。聲網 RTE 社區邀請我去做線上分享，那是我第一次面對幾千人完整地介紹 ANP，效果出乎意料的好。關注的人多了，我順勢建起了開源社區。現在，ANP 協議在 GitHub 上有了很多的貢獻者，我們的線上討論羣也聚集了上千位同路人。今年 4 月，在互聯網協會成立了智能體互聯網工作組，我們是核心參與方。5 月，我們又牽頭在 W3C 成立了 AI Agent Protocol 社區組，很多國內外的大廠比如華為、谷歌、字節、微軟、螞蟻、中移動等，都是社區組成員。雪球，就這麼滾了起來。這一切，都是當初那個在絕望中掙扎的我，完全無法預料的。&lt;/p&gt; 
&lt;p&gt;一位大廠前技術高管給我留言：「請保持在技術深水區游泳的勇氣。真正的協議戰爭從來不是功能堆砌，而是世界觀的對決」。我不再是一個人了。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;四、功成，不必在我&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;質疑聲一直都在。有人覺得這事沒商業模式，有人覺得技術還不成熟。我現在心態很平和，有價值的思考我聽，純粹的吐槽自動過濾。我判斷自己成功的概率，可能有三成。最大的風險，已經不是大廠下場競爭，而是大模型技術本身的發展，如果一個足夠好用的智能體遲遲無法誕生，那協議也就成了無源之水。&lt;/p&gt; 
&lt;p&gt;但我也想清楚了，什麼叫成功。如果 ANP 最終沒有成為主流，但它的核心理念和設計能成為未來行業標準的一部分養料，那我們社區的目標也就達成了。歸根結底，我們想構建的是一個開放的互聯網，這是我們社區的理念，也是我們社區最有價值的東西。只要我們的理念能夠成功，就是我們社區的成功。所謂「功成不必在我」。如果有其他人或組織有同樣的理念，我們社區會無保留開放我們的技術。&lt;/p&gt; 
&lt;p&gt;在一次分享的結尾，我放了一頁 PPT，上面寫着「連接即力量」。我真正想説的是，我們希望互聯網迴歸到最原始的、開放連接的設想：只要一個人能夠自由地連接信息、連接他人、連接工具，他就擁有了改變世界的能力。&lt;/p&gt; 
&lt;p&gt;最後，做自己熱愛的事情，事情本身會滋養人的。希望你也能夠找到你真正熱愛的事情。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;我們的開源社區：&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;GitHub: &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fagent-network-protocol%2FAgentNetworkProtocol" target="_blank"&gt;https://github.com/agent-network-protocol/AgentNetworkProtocol&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="color:#252933; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span&gt;如果你也對智能體通信協議感興趣，或者有類似的需求，歡迎聯繫我們：&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;微信：flow10240&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p style="margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;郵箱：chgaowei@gmail.com&lt;/span&gt;&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/9297178/blog/18638237</link>
      <guid isPermaLink="false">https://my.oschina.net/u/9297178/blog/18638237</guid>
      <pubDate>Sat, 10 May 2025 13:51:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>圖形格式 PNG 發佈 3.0 版本規範</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;PNG（Portable Network Graphics），便攜式網絡圖形，是一種採用無損壓縮算法的位圖格式，支持索引、灰度、RGB 三種顏色方案以及 Alpha 通道等特性。其設計目的是試圖替代 GIF 和 TIFF 文件格式，同時增加一些 GIF 文件格式所不具備的特性。PNG 文件的擴展名為.png。&lt;/p&gt; 
&lt;p&gt;6 月 24 日，&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.w3.org%2FTR%2Fpng-3%2F" target="_blank"&gt;PNG 正式發佈 3.0 版本規範&lt;/a&gt;，並標記為「Recommendation（推薦）」狀態，意味着正式成為 W3C 標準。&lt;/p&gt; 
&lt;p&gt;&lt;img height="930" src="https://static.oschina.net/uploads/space/2025/0625/192132_To5V_2720166.png" width="1636" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"&gt;PNG 3.0 規範支持 HDR（高動態範圍）功能，能夠在保證色彩豐富度的同時，實現更高的亮度和對比度，增強圖像的視覺效果。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color:#ffffff; color:rgba(0, 0, 0, 0.9)"&gt;此外，它還支持 APNG 動畫，使 PNG 格式能夠用於動畫製作，並且正式支持 Exif 數據，可以存儲如版權信息、相機鏡頭和照片的 GPS 位置等附加信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;目前，多個瀏覽器和軟件（如 Chrome、Safari、Firefox、iOS/macOS、Photoshop 等）以及一些硬件和工具都已支持新的 PNG 規範。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357264/png-3-spec</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357264/png-3-spec</guid>
      <pubDate>Sat, 10 May 2025 11:25:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Oasis —— 3D 打印智能玻璃容器</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                        
                                                                                    &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Oasis 是一款完全開源、主要由 3D 打印而成的智能玻璃容器。它為苔蘚、蕨類植物、蘭花等喜濕植物提供了理想的生長環境。其設計包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://oasis-terrarium.com/docs/random_notes/#light-intensity"&gt;大功率 LED 照明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;為植物提供水分並保持高濕度的噴霧器&lt;/li&gt;
&lt;li&gt;風扇用於空氣流通&lt;/li&gt;
&lt;li&gt;用於監測環境條件的溫度/濕度傳感器&lt;/li&gt;
&lt;li&gt;wifi 連接允許通過手機或電腦進行控制和配置（參見&lt;a href="https://oasis-terrarium.com/docs/usage_guide/#web-interface"&gt;網絡界面&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;外部尺寸：直徑約 8 英寸，高約 13 英寸&lt;/li&gt;
&lt;/ul&gt;

&lt;p style="text-align:start"&gt;&lt;img alt="" height="489" src="https://static.oschina.net/uploads/space/2025/0625/153625_COKE_4252687.jpg" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;訪問網站查看圖片、構建細節等：&lt;a href="https://oasis-terrarium.com/"&gt;https://oasis-terrarium.com&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/oasis</link>
      <guid isPermaLink="false">https://www.oschina.net/p/oasis</guid>
      <pubDate>Sat, 10 May 2025 10:49:00 GMT</pubDate>
    </item>
    <item>
      <title>國家網絡身份認證公共服務管理辦法 7 月 15 日起施行</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;公安部等部門近日聯合公佈的《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.mps.gov.cn%2Fn6557558%2Fc10087550%2Fcontent.html" target="_blank"&gt;國家網絡身份認證公共服務管理辦法&lt;/a&gt;》（以下簡稱《管理辦法》）將於 2025 年 7 月 15 日起施行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="286" src="https://oscimg.oschina.net/oscnet/up-4b433ec984b38d283dee4d9335da41dbb7a.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理辦法》共 16 條，主要規定四方面內容。一是明確了國家網絡身份認證公共服務及網號、網證的概念、申領方式；二是明確了使用國家網絡身份認證公共服務的效力、應用場景；三是強調了國家網絡身份認證公共服務平台、互聯網平台等對數據安全和個人信息保護的責任；四是對未成年人申領、使用國家網絡身份認證公共服務作出特殊規定。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理辦法》明確網號、網證的自願使用原則，鼓勵有關主管部門、重點行業、互聯網平台按照用戶自願原則推廣應用，但同時保留、提供現有的或者其他合法方式進行登記、核驗身份。《管理辦法》鼓勵互聯網平台接入國家網絡身份認證公共服務，但應當保障未使用網號、網證的用戶與使用網號、網證的用戶享有同等服務。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;《管理辦法》嚴格依照個人信息保護法等規定，充分保護公民個人信息權益。在信息收集方面，對選擇使用網號、網證登記、核驗真實身份的用戶，除法律、行政法規另有規定或者用戶同意外，互聯網平台不得要求用戶另行提供明文身份信息。在信息提供方面，國家網絡身份認證公共服務平台堅持「最小化提供」原則，對依法需要核驗用戶真實身份但無需留存法定身份證件信息的，僅向互聯網平台提供核驗結果；對依法確需獲取、留存用戶法定身份證件信息的，經用戶單獨同意，可以向互聯網平台提供必要的明文身份信息。對法律、行政法規規定應當履行協助義務的，國家網絡身份認證公共服務平台應當依法提供相關信息，但提供的信息僅限網號、網證對應的真實身份信息和認證日誌信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，國家網絡身份認證公共服務平台已經上線運行，用戶可通過國家網絡身份認證 App 申領並使用網號、網證，以減少相關服務管理環節對個人信息的採集、留存，實現公民身份信息「可用不可見」，同時降低互聯網平台在個人信息保護方面的投入成本。（科技日報）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357253</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357253</guid>
      <pubDate>Sat, 10 May 2025 10:27:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>對話 MoonBit 張宏波 ：很多 AI Coding 只提供情緒價值，而我們要重做一門編程語言</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;img height="1080" src="https://oscimg.oschina.net/oscnet/up-8342e8624d18299ad8c0db9edcfd1135b17.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;作者&lt;/span&gt;&lt;em&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;週一笑&lt;/span&gt;&lt;/span&gt;&lt;br&gt; &lt;span&gt;編輯&lt;/span&gt;&lt;em&gt;&lt;span&gt;｜&lt;/span&gt;&lt;span style="color:#999999"&gt;&lt;span&gt;王兆洋&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;2022 年末，當 ChatGPT 的火種剛剛在全球點燃，引發第一波的震撼與驚歎時，張宏波進行了一項實驗。他將自己剛剛孕育雛形的編程語言&lt;/span&gt;&lt;span&gt;MoonBit&lt;/span&gt;&lt;span&gt;的文法（Grammar）——一段描述語言規則的枯燥文本，餵給了那個強大的新模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;結果讓他始料未及。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;「它就能生成 MoonBit 代碼，雖然它之前從未‘見過’這門語言」，時隔兩年多，張宏波回憶起那一刻，依然反覆使用一個詞：「不可思議。」&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;那一刻的「不可思議」，如今已結出果實。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2025 年 6 月 18 日，經過無數次的迭代與優化，MoonBit 發佈了它的 Beta 正式版。它正在擺脫「實驗性技術」的標籤，演進為一門適用於企業正式場景的工具。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;或許大多數人對「編程語言」的認知還停留在大學課堂上的 C 語言，或是如今因 AI 而無處不在的 Python。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;簡單來説，MoonBit 就是一門全新的編程語言，和它們一樣，是構建所有軟件的基石。它的目標是成為一門可以用來開發網站、APP、服務器後台等各種應用的「通用語言」。但在 AI 時代，它選擇了一條與前輩們截然不同的道路。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;近年來，像 GitHub Copilot、Cursor 這樣能幫你自動寫代碼的 AI coding 工具層出不窮，AI coding 工具的主要目標是提升開發者在現有語言上的編程效率，張宏波和他的團隊也是這些工具的重度用戶，他坦言，AI 的輔助讓他「一天提交七八個 PR」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;但這些工具終究是「外掛」，是在現有語言的規則下進行輔助。而 MoonBit 所做的，是從源頭開始，重新設計一張更適合「AI 副駕駛」來閲讀和馳騁的地圖。這就是 MoonBit「AI 原生」的核心理念：它並非要自己成為一個 AI，而是要創造一門能讓 AI 用起來最得心應手、最不容易出錯的語言。它的語法、類型系統、錯誤處理機制等，在設計之初就深度考慮瞭如何讓 AI 更容易地理解、生成和驗證代碼，從而解決 AI 編程中「代碼寫出來但不知道怎麼維護」等痛點，保證代碼的可維護性 。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;張宏波舉了一個例子，MoonBit 使用 let x = 3 而不是類似 Go 語言的 x := 3。因為 let 關鍵字為 AI 提供了一個明確的「新變量聲明」信號，讓 AI 在生成代碼時可以做「受限解碼」，從而更可靠。而後者則有歧義，AI 難以判斷是新聲明還是賦值，容易出錯 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;簡單來説，一個設計良好的&lt;/span&gt;&lt;span&gt;AI 原生&lt;/span&gt;&lt;span&gt;語言，能讓通用的 AI Coding 工具在操作這門語言時表現得更好。更進一步，MoonBit 團隊正在開發自己的 AI 編程 Agent。因為完全掌控 MoonBit 的工具鏈，所以可以做到通用工具無法實現的功能。例如，通過分析代碼結構，併發地讓 AI 去修復多個 Bug，而不是像其他工具那樣只能一個一個地串行修復。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;要實現如此構想，需要對編程語言的整個工具鏈有極強的掌控力與理解。而這一切，正來源於張宏波近二十年的技術積累。時間撥回到 2009 年，他在清華大學與微軟亞洲研究院的聯合培養項目中，完成了自己的本科畢業設計——一門名為「悟空」的動畫編程語言 。此後，從研究可以創造新語言的「元編程語言」，到進入賓夕法尼亞大學攻讀博士，他的學術路徑始終精準地指向編譯與語言設計這個基礎軟件領域最核心的地帶 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;一個偶然的機遇讓他的人生軌跡從學術轉向工業。當時，金融巨頭彭博社（Bloomberg）急需一位能維護其核心交易軟件的 OCaml 編譯器專家，這個小眾而關鍵的崗位，讓彭博為還在讀博的張宏波開出了難以拒絕的條件，最終使他中斷學業，投身華爾街 。在彭博，他再次展現了自己的天賦與熱情——為了統一公司上千萬行 JavaScript 前端代碼與 OCaml 後端的技術棧，他在業餘時間，獨自開發了一個能將 OCaml 高效編譯成可讀 JavaScript 的編譯器。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;這個無心插柳的項目，後來演變成了知名的開源項目 BuckleScript（ReScript 的前身），並吸引了另一家科技巨頭 Facebook 的注意。2017 年，當張宏波決定回國時，Facebook 為了留住這位關鍵的編譯器開發者，破例允許他作為唯一的員工在中國遠程辦公 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;在 Facebook 的五年，是他技術生涯的成熟期，也是一段漫長的蓄力。直到 2022 年，幾個關鍵節點彙集到了一起：個人上，他渴望在優厚的薪資之外，尋求更大的挑戰和創造空間；外部，他昔日在清華的導師 Harry &lt;/span&gt;&lt;span&gt;沈向洋&lt;/span&gt;&lt;span&gt;向他發出了加入 IDEA 研究院（粵港澳大灣區數字經濟研究院）的邀請，在「加入已經擁有數百人團隊的某編程語言團隊」和「從零開始組建自己的團隊」之間，他選擇了後者——那個更具不確定性，也更具想象力的選項。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;於是，在深圳，MoonBit 項目正式立項。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;命運的奇妙之處在於它的時機。MoonBit 項目啓動於 2022 年 10 月，一個月後，ChatGPT 發佈，引爆了全球的 AI 浪潮。當所有主流編程語言——Java、Python、Rust——都已在 AI 時代來臨前定型，只能在現有基礎上「嫁接」AI 能力時，MoonBit 這門「生於 AI 紀元之初」的語言，獲得了一個千載難逢的歷史機遇。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="428" src="https://oscimg.oschina.net/oscnet/up-e39c86ac937a5c9d8a3bb426b93b8edddf9.png" width="750" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;「我們幾乎是沒有浪費任何時間」，張宏波説 。從使用 Llama 模型第一次在他個人電腦上成功生成 MoonBit 代碼的那天起，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;團隊就決定「All-in」 AI。他們開始從語言設計的最底層，從語法的每一個細節，去思考如何讓 AI 能更可靠、更高效地生成代碼。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;兩年半後的今天，MoonBit Beta 版本中，在語言層面提供了原生的異步與錯誤處理機制。相較於 Python 需要通過 async/await 和第三方庫實現的異步模型，MoonBit 提供了一種更自然、零語法負擔的併發範式，並在編譯期就能追蹤錯誤傳播路徑，為構建穩定、可維護的智能系統打下了堅實基礎。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;MoonBit 的故事，既是張宏波個人技術生涯的延續，也是對「AI 時代，編程究竟該如何演變？」的另一種回答。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;在 MoonBit Beta 正式發佈，在架構穩定性和工程實用性上取得關鍵突破，正式進入可落地應用的新階段，朝着可被實際部署的基礎設施技術前進的關鍵節點，我們和張宏波聊了聊，以下為對話實錄，經不改變原意的編輯。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#fffed5"&gt;AI Coding 有時候提供的只是情緒價值，我們要從底層做一門新語言，這才是 AI 編程的未來&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;人&lt;/span&gt;&lt;span style="color:#454545"&gt;：您如&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="color:#454545"&gt;何理解「AI 原生」編程語言這個概念？在這個理念上，MoonBit 與業界其他探索者有何不同？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在大模型時代，Python 可能並沒有大家想象中那麼大的優勢，它只是起步快一點。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;對於「AI 原生」，很多人有不同的理解。比如 Mojo，它的創始人 Chris Lattner 是 LLVM 項目的奠基人，他對「AI 原生」的理解是，讓 Mojo 這門語言非常適合開發高性能計算程序。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我們認為，AI 原生編程語言的核心議題是：如何讓 AI 更高、更好、更高效地、甚至是併發地生成目標代碼。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;為什麼我覺得這個方向的市場是最大的？開發高性能算子固然重要，但這就像用 C 語言寫操作系統內核，是金字塔尖少數人的工作，需求量有限 。而 AI agent，我們自己也開發了很多，它的生態其實很小，核心邏輯可能就幾千行代碼，很難構成真正的技術護城河，一個通用的庫就能解決大部分問題。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，我們對「AI 原生」的理解聚焦於賦能大模型本身。我們希望大模型可以更高效、併發地生成可靠、高性能的 MoonBit 代碼。這意味着最終生成的代碼不僅可信度要更好、性能要高，而且整個生成過程也必須是快速且可靠的 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;span style="color:#454545"&gt;：這個「為 AI 而設計」的理念，具體是如何影響 MoonBit 語言本身的設計決策的？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;這個理念帶來了深刻的變化，很多傳統語言設計中非常重視的特性，在我們看來優先級就沒有那麼高了 。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;最直接的一點就是，我們不會像過去那樣，過度強調語法是不是要節省一兩個字符，&lt;/span&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;因為未來絕大部分代碼都將由 AI 生成，為人類節省幾秒鐘的打字時間意義不大。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;更重要的是，你需要在一個巨大的設計空間裏找到一個精妙的平衡點。這個空間的兩端，一端是像 Python、 JavaScript 這樣最自由（liberal）的語言，另一端是像 Rust，尤其是 Lean（一種用於形式化數學證明的邏輯編程語言）那樣最嚴格的語言 。Lean 的嚴格性可以從數學上證明代碼的正確性，但正因如此，它對人類來説極難書寫 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;我們的實踐經驗是，如果一門語言過於複雜，以至於人類專家都很難一次性寫對，那麼 AI 大概率也無法穩定地生成正確的代碼 。我們發現，如果一個大模型在某個問題上嘗試一兩次都無法搞定，那它基本就永遠也搞不定了，至少以目前的技術水準是這樣。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，MoonBit 的選擇是在中間找到一個最佳平衡（sweet spot）。我們既要保證代碼的可靠性，又不能讓類型系統過於複雜，以至於超出 AI 的能力邊界。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：既然 AI 是核心，那麼在您看來，一個真正的「AI 原生」語言，未來需要在語言層面提供什麼樣的功能？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我認為它會深度影響語言的設計，而不僅僅是一個外掛。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我們現在主要關注的是代碼生成，但這只是開始。例如，未來我們可能會有新的語法特性來原生支持 AI。比如我寫完一個函數，我希望語言能直接支持生成它的文檔字符串（doc string），而不是像現在這樣需要通過外部插件來完成。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;這就像一門為數據庫設計的語言，如果它不在語法層面提供對數據庫操作的支持，只是通過外掛庫來連接，那麼它就不能算「數據庫原生」的。AI 原生語言也是同樣的道理，它需要在語言的基因裏就植入與 AI 協同的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：很多開發者擔心，AI 生成的代碼雖然快，但項目做大後會變得難以維護，像一個「黑盒」。MoonBit 作為一門「為 AI 而生」的語言，是如何從設計上解決這個「可維護性」問題的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;這個擔憂非常普遍，也切中了要害。我之前也看到有人吐槽説，用 AI 兩天寫了一個視頻編輯器，但完全不知道後續該怎麼維護。這通常是因為代碼是用動態語言寫的，正所謂「動態語言一時爽，重構火葬場」。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，解決這個問題的核心在於&lt;/span&gt;&lt;strong&gt;&lt;span&gt;代碼的可維護性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，而這正是需要從編程語言的底層設計上來保證的。比如，MoonBit 擁有一個非常強大的靜態類型系統。我們會為每個代碼包（package）自動生成一個形式化的「簽名」（我們稱之為&lt;/span&gt;&lt;span&gt;MBI 文件&lt;/span&gt;&lt;span&gt;），它就像一份精確的接口摘要。當你需要理解或維護一段代碼時，你不再需要去閲讀海量的實現細節，只需查看這份由工具保證其正確性的摘要文檔即可，大大降低了維護成本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;&lt;span&gt;此外，我們還非常注重語言的「&lt;/span&gt;&lt;span&gt;局部化&lt;/span&gt;&lt;span&gt;」（localization）設計。這意味着，當你修改一個函數時，它的影響應該被嚴格限制在局部，不會意外地波及到其他不相關的代碼。很多語言，比如 C++或者 OCaml，改動一個地方可能會導致全局語義發生變化，這對於人類和 AI 來説都是一場災難。一個具有良好局部性的語言，能讓 AI 在處理代碼時，只用聚焦於當前的小代碼塊，極大地簡化了上下文，從而提升了維護性和可靠性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：您認為在 AI 時代，編程語言本身的價值會發生變化嗎？它會更偏向於讓人類使用，還是讓 AI 使用？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我認為未來是人機協同的模式，而不是單純給 AI 用的語言。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我個人感覺，AI 的智能水平可能正在接近一個平台期，指望它很快變得比人聰明很多並不現實。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;只要人類還需要審查（review）、理解和維護代碼，那麼語言就必須同時兼顧人類和機器的可讀性。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;有趣的是，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;AI 的出現，反而可能會淘汰掉一些「過度為人類交互而設計」的東西&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如曾經有一個叫「結構化編輯器」的概念，它通過限制你的編輯方式來確保語法永遠正確。這種模式對人類的交互很友好，但對大模型來説卻是一種束縛，因為它破壞了代碼作為純文本的自由格式，反而不利於 AI 的理解和生成。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;所以，未來的編程語言設計，需要在兩者之間找到新的平衡：它要足夠結構化和清晰，以便機器能高效、可靠地處理；同時也要保持足夠的簡潔和直觀，讓人類能夠輕鬆地審查和驗證 AI 生成的結果。這正是我們在 MoonBit 中努力探索的方向。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：您提到 AI 能極大提升效率，在 MoonBit 團隊內部，你們具體是如何利用 AI 來輔助日常工作的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我們每天都在高強度地使用 AI，可以説，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果沒有 AI，我的個人生產力會大幅下降&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。特別是現在我需要花更多精力帶領團隊、考慮各方面的事情，寫代碼的時間越來越少。AI 的輔助真的可以讓我的生產力翻倍地提高。舉個例子，就在前一天，我在不到 24 小時內，利用 AI 輔助完成了七八個代碼提交（Commit/PR），這在過去是難以想象的。這些工作有的是修復 Bug，有的是補充文檔和註釋，AI 都能處理得很好。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;除了個人提效，我們還在探索更有組織性的 AI 用法。比如，MoonBit 現在最缺的就是生態庫，我們暢想在年底之前，能有上百個「AI Agent」在夜以繼日地為 MoonBit 寫代碼，將其他語言的成熟生態（比如一些加密算法庫）高效地「搬運」過來。這比僱傭 100 個工程師要容易得多。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;更進一步，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;因為我們完全掌控 MoonBit 的語言和工具鏈，我們可以開發出比通用工具更高效的 AI Agent。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;例如，當需要修復代碼庫中的多個警告或 Bug 時，通用工具可能只能一個一個地串行修復。而我們的 Agent 可以利用對 MoonBit 代碼結構的深度理解，先將代碼庫智能地拆分成許多互不影響的小塊，然後併發地讓大模型去並行修復，最後再將結果安全地合併回來。這種利用語言設計來優化 AI 工作流的能力，是我們的核心優勢之一。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：你們團隊也使用 Cursor 等通用 AI 編程工具。作為資深開發者和語言設計者，如何評價這些當紅產品？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我們團隊確實都用，包括 Cursor、Copilot、Codex，以及我們自己的 moon-agent。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我個人感覺，還是小團隊更有活力，比如 Cursor 的整體體驗就要比 Copilot 強很多。可以説，如果 Copilot 做得足夠好，根本不會留給 Cursor 這樣的初創公司機會。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;但同時，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我也認為像 Cursor 這類產品的技術護城河並沒有大家想象中那麼高&amp;nbsp;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。它的核心功能可以分為兩部分：一個是你打字時實時補全代碼（tap-to-type），另一個是基於對話的 Agent。前者技術含量更高，可能需要訓練專門的小模型，&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;但它提供的更多是一種讓你感覺編碼更快的「情緒價值」，對生產力的根本提升有限。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;真正能大幅提升生產力的是後者，即 Agent 幫你編寫完整的代碼塊，而這部分的技術門檻並不算特別高，更多是依賴底層大模型（基模）的能力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;此外，&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;過度依賴通用 AI 編程工具還存在被「卡脖子」的風險&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;比如 Google 之前就限制過插件的安裝。我們做 MoonBit，堅持自己寫底層的語言服務，就是希望站在產業鏈更上游的位置，不把自己的命運交到別人手裏。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我們的策略是，不做通用的 AI 編程工具，而是專注於為 MoonBit 這一門語言提供最強大、最深度的 AI 增強功能，這才是我們自己寬廣的護城河。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span style="background-color:#fffed5"&gt;比現有主流語言都好一個數量級以上，才能搶奪市場，beta 版發佈意味着進入穩定期&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我注意到 MoonBit 初期非常強調在 WebAssembly 領域的優勢，這是出於怎樣的戰略考量？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;這是一個刻意的戰略選擇，很多人會誤以為 MoonBit 只做 WebAssembly，其實我們支持所有主流後端，包括 JavaScript 和原生機器碼。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我們之所以首先聚焦 WebAssembly，是因為新語言的推廣週期非常長，動輒需要數年才能獲得第一個真正的商業用戶。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;作為一個有資金支持的機構項目，我們不可能像個人愛好者那樣「為愛發電」，等上十年再拿出成果。我們需要在一年、兩年、三年，每年都交付出實實在在的東西，讓大家看到進展。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;要在這麼短的時間內讓開發者願意嘗試一門全新的語言，唯一的辦法，就是在某個特定的、有痛點的平台上，做到比所有現有主流語言都好一個數量級以上。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;我們審視了一圈，發現 WebAssembly 就是那個機會。它在 2017 年才發佈 1.0 標準，而所有現在的主流語言，其核心設計都早已在那之前定型，它們在編譯到 Wasm 時，或多或少都有歷史包袱，導致性能和體積表現都不理想。最典型的例子就是 Go，一個「Hello World」程序編譯成 Wasm 後體積竟高達 1.8 兆，這與 Wasm 輕量的初衷背道而馳。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;MoonBit 作為一門沒有歷史包袱的新語言，完全可以為 Wasm 進行深度優化。我們的判斷是，我們有希望在這個單點上做到比所有對手都好一個數量級。事實也證明瞭這個策略的成功。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;我們早期的商業客戶，包括付費客戶，幾乎都是看中了我們在 Wasm 後端上的搶眼表現，這讓我們獲得了寶貴的初始動力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。有了這個根據地，我們才不會焦慮，可以更有耐心地去做更宏大的事情，比如完善我們的原生和 JavaScript 後端。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：你們近期宣佈項目進入了 Beta 里程碑，這對用戶和社區意味着什麼？&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Beta 版本的發佈主要意味着三件事。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第一，語言特性已經足夠豐富，覆蓋了工業級開發的核心需求&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;包括完善的異步支持、泛型和錯誤處理。坦白説，我們 Beta 版的特性比 Go 1.0 發佈時還要全面。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第二，也是更重要的，語法進入了穩定期。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;在此之前，為了追求最佳設計，我們迭代非常快，可能今天寫的代碼，兩週後就因為語法變動而無法編譯了。進入 Beta 階段後，我們承諾不會再輕易進行破壞性的語法修改，這意味着用戶可以放心地在生產項目中使用 MoonBit，不用再擔心當「小白鼠」了。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;第三，我們將建立更正規的社區溝通機制。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;過去很多決策是內部決定的，未來任何涉及語言語法的改動，我們都會通過公開的 RFC（Request for Comments）流程，與社區提前溝通，讓大家更早地參與進來，培養一種共建的參與感。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：MoonBit 作為一門新語言，如何解決生態冷啓動的問題？我注意到你們提到了「無縫融合 Python 生態」。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;生態確實是新語言最大的挑戰。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;關於 Python 生態，我們的策略是「複用」而非「重造」。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Python 的官方解釋器 CPython 是用 C 語言寫的。由於 MoonBit 現在支持直接編譯到 C 代碼，我們就能實現與 C 的良好互操作，從而直接調用 CPython 的運行時。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;這意味着，我們可以為成熟的 Python 庫（如 Matplotlib、PyQt 等）編寫綁定（binding），讓開發者可以在 MoonBit 項目中直接使用它們，比如快速搭建一個 UI 原型。這提供了一條漸進式的遷移路徑：你可以先用 Python 庫快速出成果，然後逐步地、在性能瓶頸處用原生的 MoonBit 代碼重寫那部分功能，極大地降低了遷移成本和風險。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：MoonBit 的長期商業模式是什麼？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：我們長期的願景，是成為一家軟件服務公司，而非像 JetBrains 那樣售賣開發工具。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我們的商業化分兩步走。短期內，通過為有深度定製需求（比如修改編譯器）的大客戶提供授權和服務，我們完全可以覆蓋一個十幾人團隊的開銷，保證生存。我們的早期付費客戶，比如那家數據庫公司，就是有這樣的需求。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;但我們真正的目標在更遠處。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;當 MoonBit 生態成熟，擁有百萬級用戶和我們完全掌控的工具鏈（從 IDE 到包管理）後，我們將有能力打造一個前所未有的、高效的代碼交付雲平台。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;在這個平台上，用戶只需通過自然語言提出需求（Prompt），我們的 AI Agent 就能利用對 MoonBit 語言的深度理解，自動地為你生成、構建、測試甚至部署一整個軟件服務。我們最終向用戶交付的，是一個可以直接使用的軟件服務，而不僅僅是代碼。為了保護這個長遠目標，避免未來被雲廠商「摘桃子」，我們對編譯器的核心部分保留了所有權，這也是我們開源策略中相對保守一面的原因。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一位編程語言「老兵」的二十年&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在創立 MoonBit 之前，您已經在 ReScript 等多個編程語言項目上取得了卓越成就。能和我們分享一下您的這段技術歷程嗎？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我從 2009 年的本科畢設就開始做編程語言了。當時在清華大學和微軟亞洲研究院（MSRA）的聯合培養項目中，我開發了一款名叫「悟空」的動畫編程語言，算是一個小型的領域特定語言（DSL）吧。從那時算起，到現在快 20 年了。我的碩士課題則是一門「元編程語言」，即一種可以用來創造新編程語言的語言 。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;我本來是在賓夕法尼亞大學讀編程語言的博士，但人生軌跡因為 OCaml 發生了變化。OCaml 是我深度參與維護的一門函數式編程語言。當時，紐約的彭博社（Bloomberg）收購了一家法國公司，其核心的金融衍生品定價軟件就是用 OCaml 的一個內部方言（dialect）寫的。市場上懂 OCaml 的人才非常稀缺，他們找不到人，於是就找到了我，並給了一份非常優厚的錄用信。最終我決定中止學業，碩士畢業後就直接去了紐約，負責維護他們那個私有的 OCaml 編譯器。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;在彭博工作期間，我又利用業餘時間開啓了一個新項目。當時（大約 2014 年），彭博已經擁有上千萬行用 JavaScript 寫的前端 UI 代碼，而後端則在使用 OCaml。為了統一技術棧，我寫了一個編譯器，可以把 OCaml 編譯成非常可讀、高效的 JavaScript 代碼。我的法國老闆（OCaml 正是法國人開發的）看到後非常喜歡，就讓我放下原來的業務，全職投入這個項目。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：這應該就是後來知名的 BuckleScript/ReScript 項目的前身了。聽説後來 Facebook 也因為這個項目向您拋出了橄欖枝？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是的。這個項目後來以 BuckleScript 的名字開源了，成了當時公司最受歡迎的開源項目之一 。到 2017 年，我個人想回國發展，但就在這時，Facebook 聯繫到我，説他們內部的 Facebook Chats 和 Messenger 等產品深度使用了我的編譯器，如果我走了，項目就沒人維護了，而他們內部有幾十人的團隊依賴這個工具鏈。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;為了留住我，Facebook 做出了一個破例的決定：允許我一個人在中國遠程辦公，繼續維護這個項目。要知道，Facebook 在中國是沒有辦公室的 。於是，我回國後，從 2017 年到 2022 年，一直在 Facebook 遠程參與這個項目。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它也逐漸從 BuckleScript 演進成了一門獨立的、專門用於 Web 開發的編程語言——ReScript。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：是什麼契機讓您最終決定離開 Facebook，創立 MoonBit 呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;到了 2022 年，幾個因素彙集到了一起。首先，我在 ReScript 這個項目上已經投入了五六年，而 Facebook 的待遇非常優厚，我一個人在國內，薪資是按照硅谷頂尖標準來支付的。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;對我個人而言，我開始想追求一些薪資之外的東西。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我之前在微軟亞洲研究院的導師 Harry，他從微軟退休以後，也回到了深圳。我們見了一面，深聊了一次 。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;他建議我來 IDEA 研究院這邊，靈活性會更大，可以組建自己的團隊。和自己的導師合作，彼此知根知底，完全不用擔心信任問題。&lt;/span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;於是，我便來到了 IDEA，從零開始，創立了 MoonBit。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;套殼與否取決於你的 added value&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：提到「國產編程語言」，很多人會聯想到「套殼」的爭議。您如何看待這個問題？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;「套殼」現象確實很多 。但我們不擔心這個問題，因為 MoonBit 的代碼是完全公開的，我們甚至幾乎沒有使用任何第三方依賴，一切都是從零構建。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;我認為，判斷是否「套殼」的關鍵標準在於，你提供了多大的價值增量（added value）。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;span&gt;比如，用 JavaScript 的 eval 函數，五行代碼就能做出一個「新語言」，但這沒有價值。相比之下，微軟的 TypeScript，雖然它最終也編譯成 JavaScript，但沒人會説它是套殼，因為它提供了一套強大而完善的類型系統，解決了 JavaScript 的原生痛點，帶來了巨大的價值增量 。反面例子是曾經的 CoffeeScript，它在很大程度上只是換了一套語法，提供的價值增量有限，那更像是一種套殼。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：作為國內為數不多投身基礎軟件核心領域的團隊，您覺得目前中國的技術環境缺少什麼？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;：我個人覺得，我們最缺的可能不是技術，也不是人才，而是兩樣東西：信心和伯樂。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;span&gt;首先是信心。我們需要有一種發自內心的信念，覺得我們自己能做出世界一流的東西，而不是總想着等國外做出來了我們再去模仿。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;這種信仰必須是基於真實實力的，不是盲目自信。我之所以有信心做 MoonBit，也是因為我過去的經歷，比如 ReScript，它的技術含量其實已經比谷歌的 Dart 語言高很多，但因為種種非技術因素，沒有達到應有的高度，這是我一直的遺憾。這份遺憾，也成了我做 MoonBit 的動力。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;&lt;span&gt;其次，我們缺少「伯樂」。中國的千里馬非常多，尤其是 90 後、00 後這一代，既有天賦又極其勤奮，他們的綜合能力，我個人覺得甚至比美國同齡人要強很多。但我們的文化環境，可能缺少那種由衷欣賞、不計回報去提攜和傳播好技術的「伯樂」氛圍。很多時候，你得先「拜碼頭」，或者用商業合作的方式才能獲得關注。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;這也是我們想把 MoonBit 做成的原因之一。我們不僅僅是想做出一門很多人用的語言，更希望把它成功地商業化。當我們成功之後，我們自己就能成為「伯樂」，因為我們真正懂技術，可以去識別和扶持下一代更聰明的年輕人，帶動一個良性的產業鏈發展。所以，我深切地感受到，我們缺的是伯樂，而不是千里馬。&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&amp;nbsp;&lt;/h2&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用 AI 吧，使勁用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：對於那些在 AI 時代希望提升自己競爭力的開發者，您有什麼建議？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我的建議是高強度地去使用它，並且去理解它的能力邊界。AI 不是萬能的，你要清楚地知道它擅長做什麼，不擅長做什麼。比如，讓 AI 串行地去修改一百個編譯警告，效率可能還不如有經驗的開發者手動修改來得快。但如果你懂得利用工具，讓 AI 去併發地處理這些任務，效率就會指數級提升。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;AI 無疑會加劇馬太效應，拉大個體間的差距。厲害的人用上好的 AI 工具會變得更厲害。所以，年輕人應該更主動、更高強度地去擁抱它，瞭解它的脾性，而不是簡單地把它當成一個黑盒。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：對於那些想要嘗試 MoonBit 的開發者，您有什麼想説的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，我們的工具鏈非常好用。我們提供了一流的在線 IDE，你不需要在本地安裝任何東西，打開瀏覽器就能立即開始編寫 MoonBit 代碼。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;span&gt;其次，現在加入是一個非常好的時機。MoonBit 剛剛進入 Beta 階段，生態系統還是一片全新的大陸。更早地參與進來，你不僅可以見證一門編程語言從零到一的成長過程，更有機會成為早期生態的核心貢獻者，留下自己的印記。MoonBit 本身在數據處理等方面有很多非常有意思的特性，我們把數據變換的體驗做得非常好，相信會給你帶來不一樣的感受。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;硅星人&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最後，對於那些有志於投身基礎技術領域的年輕人，您有什麼經驗可以分享？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="color:#303030; margin-left:0; margin-right:0; text-align:justify"&gt;&lt;strong&gt;&lt;strong&gt;&lt;span style="background-color:#b3e0e3; color:#454545"&gt;張宏波&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：我的建議是，要做好打持久戰的準備，並且先在產業界充分歷練。基礎軟件是一個週期特別長的領域，它不可能讓你一夜暴富，而是一個慢工出細活的過程。以我自己為例，我也是在個人職業生涯和財務上有了足夠的積累，不再為生計擔憂之後，才全身心投入到這件事情中來的。這個領域需要深厚的經驗積累，所以，年輕人如果心懷此志，最好先在相關的崗位上磨礪數年，再來挑戰。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357239</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357239</guid>
      <pubDate>Sat, 10 May 2025 09:26:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>德國汽車企業就開源軟件開發達成非競爭性合作</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;德國汽車行業的 11 家公司已就開源軟件開發達成非競爭性合作&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在德國汽車工業協會（VDA）的支持下，包括寶馬集團、大陸集團、ETAS GmbH 等 11 家汽車企業於 2025 年 6 月 24 日在第 29 屆國際汽車電子大會上簽署了在開源軟件開發方面進行前競爭性合作的&lt;strong&gt;諒解備忘錄 (Memorandum of Understanding，MoU)&lt;/strong&gt;，旨在提升汽車軟件開發的速度、效率和安全性，為建立開放協作的生態系統奠定基礎。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0625/171504_8ecy_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;隨着車輛軟件重要性與複雜性的增加，行業急需加快開發速度、提升效率並確保高質量與安全性。&lt;strong&gt;因大量車輛軟件用戶無法直接接觸且不具差異化，所以可在開放協作生態中聯合開發相應軟件模塊&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;為使汽車系列軟件滿足功能安全需求，相關方開發了開創性的開源開發流程，為按相關標準認證做好準備，並通過 「代碼優先」 方法實現標準化及加快開發速度，即提供可執行軟件模塊而非詳細規格説明。&lt;/p&gt; 
&lt;p&gt;軟件開發在 Eclipse 基金會透明且無供應商依賴的環境中進行，屬於 S-CORE 項目一部分，該生態系統開放，既通過與行業標準軟件互操作性體現，也對歐洲及國際其他公司貢獻協作開放。&lt;/p&gt; 
&lt;p&gt;該倡議時間規劃顯示，2026 年將推出適用於自動駕駛平台系列開發的軟件範圍，其模塊化軟件範圍可調整或擴展，作為定製發行版供行業用於系列開發，使製造商和供應商能專注於差異化特性，同時共同維護核心組件，為創新奠定堅實基礎，也讓企業能專注於為客戶創造差異化的部分。&lt;/p&gt; 
&lt;p&gt;VDA 主任馬庫斯・博利希表示，各方正共同構建一個面向未來且強大的軟件生態系統，該系統開放、透明且安全。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357237</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357237</guid>
      <pubDate>Sat, 10 May 2025 09:18:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>大促數據庫壓力激增，如何一眼定位 SQL 執行來源？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class="rich_media_content js_underline_content
                       autoTypeSetting24psection
            " id="js_content"&gt; 
 &lt;p data-nodeid="1247" data-pm-slice="0 0 []" style="margin-bottom: 8px;text-indent: 2em;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;你是否曾經遇到過這樣的情況：在大促活動期間，用戶訪問量驟增，數據庫的壓力陡然加大，導致響應變慢甚至服務中斷？更讓人頭疼的是，當你試圖快速定位問題所在時，卻發現難以確定究竟是哪個業務邏輯中的 &amp;nbsp;SQL 語句成為了性能瓶頸。面對這樣的困境，本篇文章提出了對 SQL 進行 「染色」 的方法來幫助大家&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1379"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;一眼定位問題 SQL，而無需再在多處邏輯中輾轉騰挪&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;。本文的思路主要受之前郭忠強老師發佈的，如何一眼定位 SQL 的代碼來源：一款 SQL 染色標記的簡易 MyBatis&lt;/span&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;插件 &amp;nbsp;文章啓發，我在這個基礎上對邏輯進行了簡化，去除了一些無關的邏輯和工具類，並只對查詢 SQL 進行染色，使這個插件「更輕」。此外，本文除了提供 &amp;nbsp;Mybatis 攔截器的實現以外，還提供了針對 ibatis 框架實現攔截的方法，用於切入相對比較老的應用，希望對大家有所啓發~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1248" style="margin-bottom: 8px;text-indent: 2em;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;在文章開展之前，我們先來瞭解一下什麼是 SQL 染色：染色的含義是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1385"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;在 SQL 執行前，在 SQL 上進行註釋打標，標記內容為這條 SQL 對應的是 Mapper 文件中的哪條 SQL 以及相關的方法執行堆棧&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: normal;"&gt;，如下為在 SGM 的 SQL 執行監控端能直接看到 SQL 染色信息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section data-nodeid="1249" style="margin-bottom: 8px;text-align: left;" nodeleaf=""&gt; 
  &lt;img src="https://oscimg.oschina.net/oscnet/fe12d217-d240-4765-b861-5d0f7c45c70b.png" alt="image.png" class="rich_pages wxw-img" data-ratio="0.5175925925925926" data-type="png" data-w="1080" data-imgfileid="100029296" referrerpolicy="no-referrer"&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1250" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;這樣便能夠非常輕鬆地看到到底是什麼邏輯執行了哪段 SQL，並且經過實際生產性能驗證，染色操作耗時在 0 ~ 1ms 左右：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="css"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;0ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__selector-attr"&gt;[JSF-BZ-22000-366-T-20]&lt;/span&gt;&amp;nbsp;INFO c&lt;span class="code-snippet__selector-class"&gt;.j.b.t.s.SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__selector-attr"&gt;[67]&lt;/span&gt;&amp;nbsp;- SQL 染色耗時：&lt;span class="code-snippet__number"&gt;1ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1251" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="text"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;現在我們已經對 SQL 染色有了基本的瞭解，下面將介紹兩種實現染色的方式：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;strong data-nodeid="1397"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 攔截器實現和基於 AspectJ 織入實現&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;。在接下來的內容中我會展示染色實現的源碼信息，但是並不複雜，代碼量只有百行，所以大家可以直接將文章中的代碼邏輯複製到項目中實現即可。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h3_1"&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid="1253" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;快速接入 SQL 染色&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1256" style="margin-bottom: 8px;text-align: left;"&gt;&lt;strong data-nodeid="1405"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 框架應用接入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：跳轉 「全量源碼」 小節，複製攔截器源碼到應用中，並在 Mybatis 攔截器配置中添加該攔截器便可以生效，注意修改源碼中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1403" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;com.your.package&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;包路徑為當前應用的有效包路徑&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;p data-nodeid="1258" style="margin-bottom: 8px;text-align: left;"&gt;&lt;strong data-nodeid="1410"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;非 Mybatis 框架應用接入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：參考 「基於 AspectJ 織入實現」 小節，通過對 SQL 執行相關 Jar 包進行攔截實現&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;span id="OSC_h3_2"&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid="1259" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;Mybatis 攔截器實現&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; 
 &lt;p data-nodeid="1260" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在展示具體實現前，我還是想通過給大家介紹原理的形式一步步將其實現，這樣也能加深大家對 Mybatis 框架的理解，也歡迎大家閲讀、訂閲專欄，由 Mybatis 源碼暢談軟件設計。如果不想看實現原理，直接看實現的話請跳轉&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1421"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;全量源碼&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;小節。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_3"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1261" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;攔截器的作用範圍&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1262" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Mybatis 的攔截器不像 Spring 的 AOP 機制，它並不能在任意邏輯處進行切入。在 Mybatis 源碼的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1424" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;類中，定義了它的攔截器的作用範圍，即創建「四大處理器」時調用的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1426" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;protected&lt;/span&gt;&amp;nbsp;final&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;interceptorChain =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newParameterHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;MappedStatement mappedStatement,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;parameterObject,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;parameterHandler = mappedStatement.&lt;span class="code-snippet__title"&gt;getLang&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;createParameterHandler&lt;/span&gt;(mappedStatement,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parameterObject, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(parameterHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newResultSetHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement mappedStatement, RowBounds rowBounds,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;resultSetHandler =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;DefaultResultSetHandler&lt;/span&gt;(executor, mappedStatement, parameterHandler,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; resultHandler, boundSql, rowBounds);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(resultSetHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newStatementHandler&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement mappedStatement,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&amp;nbsp;parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;statementHandler =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;(executor, mappedStatement, parameterObject,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(statementHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newExecutor&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Transaction transaction, ExecutorType executorType&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executorType = executorType ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;&amp;nbsp;? defaultExecutorType : executorType;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 創建具體的 Executor 實現類&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;executor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;BATCH&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BatchExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;REUSE&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ReuseExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cacheEnabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1262" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;是讓攔截器生效的邏輯，它具體是如何做的呢：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 所有配置的攔截器&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;final&amp;nbsp;&lt;span class="code-snippet__title"&gt;List&lt;/span&gt;&amp;lt;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;gt; interceptors =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__built_in"&gt;Object&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;target&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;interceptor : interceptors) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 注意 target 引用不斷變化，會不斷引用已經添加攔截器的對象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = interceptor.&lt;span class="code-snippet__title"&gt;plugin&lt;/span&gt;(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1265" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;實現非常簡單，內部定義了集合來保存所有配置的攔截器，執行&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1432" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;pluginAll&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法時會遍歷該集合，逐個調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1434" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Interceptor#plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法來 「不斷地疊加攔截器」（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1436" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;interceptor.plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法執行時，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1438" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;引用不斷變更）。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;blockquote&gt; 
  &lt;p data-nodeid="1268" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;注意這裏使用到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1461"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;責任鏈模式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1445" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的命名中包含&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1447" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Chain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;也能聯想到該模式，之後我們在使用責任鏈時也可以考慮在命名中增加&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1449" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Chain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;以增加可讀性。&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1451" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InterceptorChain&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;將多個攔截器串聯在一起，每個攔截器負責其特定的邏輯處理，並在執行完自己的邏輯後，調用下一個攔截器或目標方法，這樣設計允許不同的攔截器之間的邏輯&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1462"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;解耦&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，同時提供了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1463"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;可擴展性&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;/blockquote&gt; 
 &lt;p data-nodeid="1269" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;由此可知，攔截器的作用範圍是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1465" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1467" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1469" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1471" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;處理器（Handler），但是攔截它們又能實現什麼效果呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1270" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要弄清楚這個問題，首先我們需要了解攔截器能夠切入的粒度。在 Mybatis 框架中，定義攔截器時需要使用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1474" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;@Intercepts&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1476" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;@Signature&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;註解來&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1482"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;配置切入的方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="ruby"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Intercepts&lt;/span&gt;({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Signature&lt;/span&gt;(method =&amp;nbsp;&lt;span class="code-snippet__string"&gt;"prepare"&lt;/span&gt;, type =&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;, args = {&lt;span class="code-snippet__title"&gt;Connection&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Integer&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;implements&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__regexp"&gt;//&lt;/span&gt;&amp;nbsp;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1271" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;每個攔截器切入的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;strong data-nodeid="1490"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;粒度是方法級別的&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的，比如在我們定義的這個攔截器中，切入的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1488" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，那麼如果我們瞭解了四個處理器方法的作用是不是就能知道 Mybatis 攔截器所能實現的功能了？所以接下來我們簡單瞭解一下它們的各個方法的作用：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1275" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1491" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 核心方法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1493" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;setParameters&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，它的作用主要是將 Java 對象轉換為 SQL 語句中的參數，並處理參數的設置和映射，所以攔截器切入它能&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1498"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;對 SQL 執行的入參進行修改&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ParameterHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;Object&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;getParameterObject&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;setParameters&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;(&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__params"&gt;PreparedStatement ps&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;) throws SQLException&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1276" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 負責將 SQL 查詢返回的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1501" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSet&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;結果集轉換為 Java 對象，攔截器切入它的方法能&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1506"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;對結果集進行處理&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ResultSetHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 處理 Statement 對象並返回結果對象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;stmt SQL 語句執行後返回的 Statement 對象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@return&lt;/span&gt;&amp;nbsp;映射後的結果對象列表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleResultSets&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement stmt)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 處理 Statement 對象並返回一個 Cursor 對象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 它用於處理從數據庫中獲取的大量結果集，與傳統的 List 或 Collection 不同，Cursor 提供了一種流式處理結果集的方式，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 這在處理大數據量時非常有用，因為它可以避免將所有數據加載到內存中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;stmt SQL 語句執行後返回的 Statement 對象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@return&lt;/span&gt;&amp;nbsp;遊標對象，用於迭代結果集&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleCursorResultSets&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement stmt)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;* 處理存儲過程的輸出參數&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*&amp;nbsp;&lt;span class="code-snippet__doctag"&gt;@param&lt;/span&gt;&amp;nbsp;cs 存儲過程調用的 CallableStatement 對象&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;handleOutputParameters&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(CallableStatement cs)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1283" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1507" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 它的方法很多，概括來説它負責數據庫操作，包括增刪改查等基本的 SQL 操作、管理緩存和事務的提交與回滾，所以攔截器切入它主要是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1512"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;管理執行過程或事務&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;ResultHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;NO_RESULT_HANDLER&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於執行更新操作（包括插入、更新和刪除），它接受一個 `MappedStatement` 對象和更新參數，並返回受影響的行數&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;update&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於執行查詢操作，接受 `MappedStatement` 對象（包含 SQL 語句的映射信息）、查詢參數、分頁信息、結果處理器等，並返回查詢結果的列表&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; CacheKey cacheKey, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;queryCursor&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於刷新批處理語句並返回批處理結果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; List&amp;lt;BatchResult&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;flushStatements&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於提交事務，參數 `required` 表示是否必須提交事務&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;commit&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;required)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於回滾事務。參數 `required` 表示是否必須回滾事務&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;rollback&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;required)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於創建緩存鍵，緩存鍵用於標識緩存中的唯一查詢結果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; CacheKey&amp;nbsp;&lt;span class="code-snippet__title"&gt;createCacheKey&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於檢查某個查詢結果是否已經緩存在本地&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;isCached&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, CacheKey key)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於清空一級緩存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;clearLocalCache&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於延遲加載屬性&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;deferLoad&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&amp;lt;?&amp;gt; targetType)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於獲取當前的事務對象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; Transaction&amp;nbsp;&lt;span class="code-snippet__title"&gt;getTransaction&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於關閉執行器。參數 `forceRollback` 表示是否在關閉時強制回滾事務&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;close&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;forceRollback)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;isClosed&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 該方法用於設置執行器的包裝器&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;setExecutorWrapper&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Executor executor)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;ul class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1287" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-nodeid="1513" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;: 它的主要職責是準備（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1515" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;）、「承接」封裝 SQL 執行參數的邏輯，執行 SQL（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1517" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;update&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;/&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1519" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;）和「承接」處理結果集的邏輯，這裏描述成「承接」的意思是這兩部分職責並不是由它處理，而是分別由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1521" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1523" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成，所以攔截器切入它主要是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1528"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在準備和執行階段對 SQL 進行加工等&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; Statement&amp;nbsp;&lt;span class="code-snippet__title"&gt;prepare&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Connection connection, Integer transactionTimeout)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;parameterize&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;batch&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;update&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement, ResultHandler resultHandler)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;queryCursor&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Statement statement)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; BoundSql&amp;nbsp;&lt;span class="code-snippet__title"&gt;getBoundSql&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; ParameterHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;getParameterHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1288" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;為了加深大家對這四個處理器的理解，瞭解它在查詢 SQL 執行時作用的時機，我們來看一下查詢 SQL 執行時的流程圖：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section data-nodeid="1290" style="margin-bottom: 8px;text-align: left;" nodeleaf=""&gt; 
  &lt;img src="https://oscimg.oschina.net/oscnet/11f9fe6e-8276-482a-be20-4ead1b5f1d20.png" alt="image.png" class="rich_pages wxw-img" data-ratio="0.37222222222222223" data-type="png" data-w="1080" data-imgfileid="100029298" referrerpolicy="no-referrer"&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1291" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;每個聲明 SQL 查詢語句的 Mapper 接口都會被&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1534" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperProxy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;代理，接口中每個方法都會被定義為&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1536" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperMethod&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，藉助&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1538" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;PlainMethodInvoker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;執行（動態代理模式和策略模式），&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1540" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MapperMethod&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中組合了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1542" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1544" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MethodSignature&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1546" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象很重要，它的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1548" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand#name&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段記錄的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1550" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象的 ID 值（eg: org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor），根據它來獲取唯一的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1552" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;（每個&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1554" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象對應 XML 映射文件中一個&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1556" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;select&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1558" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;insert&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1560" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;update&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;, 或&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1562" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;lt;delete&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;標籤定義），&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1564" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlCommand#type&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段用來標記 SQL 的類型。當方法被執行時，會先調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1566" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlSession&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中的查詢方法&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1568" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultSqlSession#selectOne&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，接着由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1614"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;執行器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1574" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;去承接，默認類型是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1576" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，注意在這裏它會調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1578" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法獲取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1580" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，這個對象實際上最終都是在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1582" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StaticSqlSource#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法中獲取的，也就是説&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1615"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;此時我們定義在 Mapper 文件中的 SQL 此時已經被解析、處理好了（動態標籤等內容均已被處理）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，保存在了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1588" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象中。此時，要執行的 SQL 已經準備好了，它會接着調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1616"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SQL 處理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1594" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法創建與數據庫交互的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1596" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Statement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，其中記錄了要執行的 SQL 信息 ，而封裝 SQL 的執行參數則由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1617"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;參數處理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1602" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1604" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;TypeHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成，&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1606" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ResultSet&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;結果的處理：將數據庫中數據轉換成所需要的 Java 對象由&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1618"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;結果處理器&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;code data-nodeid="1612" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;DefaultResultSetHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1292" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;現在我們對攔截器的原理和查詢 SQL 的執行流程已經有了基本的瞭解，回過頭來再想一下我們的需求：「使用 Mybatis 的攔截器在 SQL 執行前進行打標」，那麼我們該選擇哪個方法作為切入點更合適呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1293" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;理論上來説在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1621" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;,&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1623" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1625" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;相關的方法中切入都可以，但實際上我們還要多考慮一步：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1627" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;ParameterHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;是用來處理參數相關的，在這裏切入一般我們是要對入參 SQL 的入參進行處理，所以不選擇這裏避免為後續同學維護時增加理解成本；&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1629" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;「有時不是很合適」，它其中有兩個&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1631" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，先被執行的方法，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1675"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;對應圖中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1635" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CacheExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;左側的直線&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1637" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1641" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor#query(MappedStatement, Object, RowBounds, ResultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在方法中它會去調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1643" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatement#getBoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法獲取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1645" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1676"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成 SQL 的處理和解析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，處理和解析後的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1651" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象是我們需要進行攔截處理的，隨後&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1677"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在該方法內部&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;調用另一個&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1657" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法：&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1659" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor#query(MappedStatement, Object, RowBounds, ResultHandler, CacheKey, BoundSql)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1678"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;對應圖中&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1663" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CacheExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;右側的曲線&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1665" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，它會將&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1669" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;作為入參去執行查詢邏輯，結合本次需求，選擇後者切入是合適的，因為它有&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1671" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;入參，對這個入參進行打標即可，我們來看一下&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1673" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的源碼：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;Executor delegate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 先調用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getBoundSql(parameterObject);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;CacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;key&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;createCacheKey(ms, parameterObject, rowBounds, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 在方法內部調用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CacheKey key, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 二級緩存相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Cache&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;cache&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getCache();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cache !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; flushCacheIfRequired(ms);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(ms.isUseCache() &amp;amp;&amp;amp; resultHandler ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ensureNoOutParams(ms, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@SuppressWarnings("unchecked")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(list ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 執行查詢邏輯（被攔截）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tcm.putObject(cache, key, list);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;list;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 執行查詢邏輯（被攔截）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1294" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;它使用了靜態代理模式，其中封裝的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1680" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Executor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;實現類型為&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1682" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SimpleExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在註釋中標記了「被攔截」處的方法會讓攔截器生效。那麼前文中為什麼要説它「有時不是很合適」呢？我們來看一種情況，將 Mybatis 配置中的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1684" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;cacheEnable&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;置為 false，那麼在創建執行器時實際類型不是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1686" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;CachingExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;而是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1688" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SimpleExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，如下源碼所示：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;newExecutor&lt;/span&gt;(&lt;span class="code-snippet__params"&gt;Transaction transaction, ExecutorType executorType&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executorType = executorType ==&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;&amp;nbsp;? defaultExecutorType : executorType;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 創建具體的 Executor 實現類&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;executor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;BATCH&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BatchExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;ExecutorType&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;REUSE&lt;/span&gt;&amp;nbsp;== executorType) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ReuseExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;(&lt;span class="code-snippet__variable"&gt;this&lt;/span&gt;, transaction);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// false 不走這段邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(cacheEnabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; executor =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;CachingExecutor&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;) interceptorChain.&lt;span class="code-snippet__title"&gt;pluginAll&lt;/span&gt;(executor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1294" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;當有 SELECT 查詢語句被執行時，它會直接調用到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1691" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BaseExecutor#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，在方法內部調用另一個需要被攔截的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1693" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;abstract&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BaseExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Executor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getBoundSql(parameter);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// cache key 緩存操作&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;CacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;key&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;createCacheKey(ms, parameter, rowBounds, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 需要攔截的&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;query(ms, parameter, rowBounds, resultHandler, key, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@SuppressWarnings("unchecked")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;query&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;CacheKey key, BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1298" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;由於該方法是在方法內部被調用的，所以無法使攔截器生效&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;（動態代理），這也是説它「有時不是很合適」的原因所在。因為存在這種情況，我們現在也只能選擇&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1699" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;作為切入點了，那麼是選擇切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1701" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法還是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1703" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法呢？&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SimpleExecutor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;extends&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;BaseExecutor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&amp;lt;E&amp;gt; List&amp;lt;E&amp;gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;doQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;BoundSql boundSql)&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Statement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stmt&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Configuration&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;configuration&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ms.getConfiguration();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 創建 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;handler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 準備 Statement，其中會調用 StatementHandler#prepare 方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stmt = prepareStatement(handler, ms.getStatementLog());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 由 StatementHandler 執行 query 方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;handler.query(stmt, resultHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;finally&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; closeStatement(stmt);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1298" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根據源碼，要被執行打標的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1707" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象會在調用&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1709" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法前會將&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1711" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象封裝在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1713" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中，如果選擇切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1715" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，那麼在該方法執行前在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1717" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中拿到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1719" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象進行修改便能實現我們的需求；如果選擇切入&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1721" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#query&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，同樣是需要在該方法執行前想辦法獲取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1723" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，但是由於此時 SQL 信息已經被保存在了即將與數據庫交互的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1725" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Statement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象中，它的實現類有很多，比如常見的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1727" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;PreparedStatement&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，在其中獲取 SQL 字符串相對複雜，所有還是選擇&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1729" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler#prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法作為切點相對容易。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_4"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1302" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;攔截器的定義和源碼解析&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1303" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;接下來我們來對攔截器進行實現，首先我們先對攔截器的切入點進行定義：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="ruby"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__variable"&gt;@Intercepts&lt;/span&gt;({&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Signature&lt;/span&gt;(method =&amp;nbsp;&lt;span class="code-snippet__string"&gt;"prepare"&lt;/span&gt;, type =&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;, args = {&lt;span class="code-snippet__title"&gt;Connection&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Integer&lt;/span&gt;.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;implements&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;intercept(&lt;span class="code-snippet__title"&gt;Invocation&lt;/span&gt;&amp;nbsp;invocation) throws&amp;nbsp;&lt;span class="code-snippet__title"&gt;Throwable&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__regexp"&gt;//&lt;/span&gt;&amp;nbsp;...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1304" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;接着來實現其中的邏輯：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Intercepts({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Signature(method = "prepare", type = StatementHandler.class, args = {Connection.class, Integer.class})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Log&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;log&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;LogFactory.getLog(SQLMarkingInterceptor.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;intercept&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Invocation invocation)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 1. 找到 StatementHandler（SQL 執行時，StatementHandler 的實際類型為 RoutingStatementHandler）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;routingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getRoutingStatementHandler(invocation.getTarget());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(routingStatementHandler !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 其中 delegate 是實際類型的 StatementHandler （靜態代理模式），獲取到實際的 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;delegate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RoutingStatementHandler.class, routingStatementHandler,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"delegate"&lt;/span&gt;, StatementHandler.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 2. 找到 StatementHandler 之後便能拿到 SQL 相關信息，現在對 SQL 信息打標即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; marking(delegate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1304" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;將自定義的邏輯添加上了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1735" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;try-catch&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，避免異常影響正常業務的執行。在主要邏輯中，需要先在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1737" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;Invocation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中找到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1739" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;的實際被代理的對象，它被封裝在了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1741" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中，隨後在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1743" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中獲取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1745" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，對 SQL 進行打標即可（&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1747" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;marking&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法）。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h5_5"&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid="1308" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;獲取 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt; 
 &lt;p data-nodeid="1309" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;攔截&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1751" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;為什麼要獲取的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1753" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;類型呢？我們回到攔截器攔截&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1755" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;生效的源碼：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Configuration&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;protected&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;InterceptorChain&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;interceptorChain&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;InterceptorChain&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;StatementHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;newStatementHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Executor executor, MappedStatement mappedStatement,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 可以發現攔截器實際針對的是類型便是 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;(executor, mappedStatement, parameterObject,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 攔截器相關邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(StatementHandler) interceptorChain.pluginAll(statementHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1310" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;我們可以發現攔截器在生效時，針對的是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1758" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;類型，所以我們要獲取該類型，如下源碼：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;getRoutingStatementHandler&lt;/span&gt;(&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;&amp;nbsp;target)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; throws&amp;nbsp;&lt;span class="code-snippet__title"&gt;NoSuchFieldException&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;IllegalAccessException&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 如果被代理，那麼一直找到具體被代理的對象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;Proxy&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;isProxyClass&lt;/span&gt;(target.&lt;span class="code-snippet__title"&gt;getClass&lt;/span&gt;())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target =&amp;nbsp;&lt;span class="code-snippet__title"&gt;Proxy&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;getInvocationHandler&lt;/span&gt;(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;&amp;nbsp;plugin = (&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target =&amp;nbsp;&lt;span class="code-snippet__title"&gt;getFieldValue&lt;/span&gt;(&lt;span class="code-snippet__title"&gt;Plugin&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;class&lt;/span&gt;, plugin,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"target"&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;.&lt;span class="code-snippet__property"&gt;class&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 找到了 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1312" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;源碼中前兩步為處理代理關係的邏輯，因為&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1761" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;可能被代理，需要獲取到實際的被代理對象，找到之後返回即可。那麼後續為什麼還要獲取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1763" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;中的被代理對象呢？我們還需要再回到 Mybatis 的源碼中：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 代理對象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;final StatementHandler&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__title"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__function"&gt;(&lt;/span&gt;&lt;span class="code-snippet__function"&gt;&lt;span class="code-snippet__params"&gt;Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;ResultHandler resultHandler, BoundSql boundSql) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 在調用構造方法時，根據 statementType 字段為代理對象 delegate 賦值，那麼這樣便實現了複雜度隱藏，只由代理對象去幫忙路由具體的實現即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;switch&lt;/span&gt;&amp;nbsp;(ms.getStatementType()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;STATEMENT:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;PREPARED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;case&lt;/span&gt;&amp;nbsp;CALLABLE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;delegate&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;ExecutorException(&lt;span class="code-snippet__string"&gt;"Unknown statement type: "&lt;/span&gt;&amp;nbsp;+ ms.getStatementType());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1314" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;使用了靜態代理模式，實際的類型被賦值到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1767" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段中，我們需要在這個對象中獲取到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1769" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，獲取&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1771" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象則通過反射來完成。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h5_6"&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid="1316" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;染色打標 marking&lt;/span&gt;&lt;/span&gt;&lt;/h5&gt; 
 &lt;p data-nodeid="1317" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;現在我們已經獲取到了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1775" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;StatementHandler delegate&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，我們可以 SQL 進行打標了，但在打標之前我們需要先思考下要打標的內容是什麼：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;ol class="list-paddingleft-1"&gt; 
  &lt;li&gt;&lt;p data-nodeid="1320" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要清楚的知道被執行的 SQL 是定義在 Mapper 中的哪條：聲明在 Mapper 中各個方法的唯一 ID，也就是 StatementId&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li&gt;&lt;p data-nodeid="1322" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;要清楚的知道這條 SQL 被執行時，有哪些相關方法被執行了：方法的調用棧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p data-nodeid="1323" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根據我們所需去找相關的內容就好了，以下是源碼，需要注意的是由於所有類型的 SQL 都會執行到&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1780" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;prepare&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;方法，但我們只對 SELECT 語句進行打標，所以需要添加邏輯判斷：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;marking&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementHandler delegate)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;delegate.getBoundSql();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 實際的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;boundSql.getSql().trim();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只對 select 打標&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sql,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 獲取其基類中的 MappedStatement 即定義的 SQL 聲明對象，獲取它的 ID 值表示它是哪條 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BaseStatementHandler.class, delegate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"mappedStatement"&lt;/span&gt;, MappedStatement.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;mappedStatement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法調用棧&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按順序創建打標的內容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 打標&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sql = String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 反射更新&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(BoundSql.class,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"sql"&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.set(boundSql, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1324" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;執行打標的邏輯是修改&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1783" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;BoundSql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;對象，將其中的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1785" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;sql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;字段用打標後的 SQL 替換掉。獲取方法調用棧的邏輯我們具體來看一下，其實並不複雜，在全量堆棧信息中將不需要關注的堆棧排除掉，需要注意將&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1787" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;!className.startsWith("com.your.package")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;修改成有效的路徑判斷：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="typescript"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;trace&lt;/span&gt;() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 全量調用棧&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StackTraceElement&lt;/span&gt;[] stackTraceArray =&amp;nbsp;&lt;span class="code-snippet__title"&gt;Thread&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;currentThread&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;getStackTrace&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(stackTraceArray.&lt;span class="code-snippet__property"&gt;length&lt;/span&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;EMPTY&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;gt; methodInfoList =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(int i = stackTraceArray.&lt;span class="code-snippet__property"&gt;length&lt;/span&gt;&amp;nbsp;-&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;&amp;nbsp;-&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;; i &amp;gt;=&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;; i--) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StackTraceElement&lt;/span&gt;&amp;nbsp;stackTraceElement = stackTraceArray[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 排除掉不想看到的內容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;className = stackTraceElement.&lt;span class="code-snippet__title"&gt;getClassName&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!className.&lt;span class="code-snippet__title"&gt;startsWith&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"com.your.package"&lt;/span&gt;) || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"FastClassBySpringCGLIB"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"EnhancerBySpringCGLIB"&lt;/span&gt;) || stackTraceElement.&lt;span class="code-snippet__title"&gt;getMethodName&lt;/span&gt;().&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"lambda$"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 過濾攔截器相關&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"Interceptor"&lt;/span&gt;) || className.&lt;span class="code-snippet__title"&gt;contains&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"Aspect"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只拼接類和方法，不拼接文件名和行號&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;methodInfo =&amp;nbsp;&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;.&lt;span class="code-snippet__title"&gt;format&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;"%s#%s"&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; className.&lt;span class="code-snippet__title"&gt;substring&lt;/span&gt;(className.&lt;span class="code-snippet__title"&gt;lastIndexOf&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;'.'&lt;/span&gt;) +&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stackTraceElement.&lt;span class="code-snippet__title"&gt;getMethodName&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methodInfoList.&lt;span class="code-snippet__title"&gt;add&lt;/span&gt;(methodInfo);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(methodInfoList.&lt;span class="code-snippet__title"&gt;isEmpty&lt;/span&gt;()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;EMPTY&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 格式化結果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;&amp;nbsp;stringJoiner =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;" ==&amp;gt; "&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__title"&gt;String&lt;/span&gt;&amp;nbsp;method : methodInfoList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stringJoiner.&lt;span class="code-snippet__title"&gt;add&lt;/span&gt;(method);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;stringJoiner.&lt;span class="code-snippet__title"&gt;toString&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1324" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;以上便完成了 SQL 「染色」 攔截器的實現，將其添加到 mybatis 相關的攔截器配置中就可以生效了。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_7"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1328" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;全量源碼&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;com.jd.laf.config.spring.annotation.LafValue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;lombok.extern.slf4j.Slf4j;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.commons.lang3.StringUtils;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.BaseStatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.RoutingStatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.executor.statement.StatementHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.mapping.BoundSql;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.mapping.MappedStatement;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.apache.ibatis.plugin.*;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;org.springframework.stereotype.Service;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.lang.reflect.Field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.lang.reflect.Proxy;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.sql.Connection;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.util.*;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;java.util.concurrent.ConcurrentHashMap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;import&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;org.apache.commons.lang3.StringUtils.EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Service&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Intercepts({&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; @Signature(method = "prepare", type = StatementHandler.class, args = {Connection.class, Integer.class})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SQLMarkingInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;implements&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Interceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 默認線程棧數組下標&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 是否開啓 SQL 染色標記&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@LafValue("sql.marking.enable")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;boolean&lt;/span&gt;&amp;nbsp;enabled;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;Map&amp;lt;String, Field&amp;gt; FIELD_CACHE =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;ConcurrentHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;intercept&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Invocation invocation)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!enabled) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 1. 找到 StatementHandler（SQL 執行時，StatementHandler 的實際類型為 RoutingStatementHandler）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;RoutingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;routingStatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getRoutingStatementHandler(invocation.getTarget());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(routingStatementHandler !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 其中 delegate 是實際類型的 StatementHandler （靜態代理模式），獲取到實際的 StatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementHandler&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;delegate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; RoutingStatementHandler.class, routingStatementHandler,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"delegate"&lt;/span&gt;, StatementHandler.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 2. 找到 StatementHandler 之後便能拿到 SQL 相關信息，現在對 SQL 信息打標即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; marking(delegate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;invocation.proceed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;RoutingStatementHandler&amp;nbsp;&lt;span class="code-snippet__title"&gt;getRoutingStatementHandler&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Object target)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 如果被代理，那麼一直找到具體被代理的對象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(Proxy.isProxyClass(target.getClass())) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = Proxy.getInvocationHandler(target);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;while&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;Plugin) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Plugin&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;plugin&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;(Plugin) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; target = getFieldValue(Plugin.class, plugin,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"target"&lt;/span&gt;, Object.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 找到了 RoutingStatementHandler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(target&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;RoutingStatementHandler) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;(RoutingStatementHandler) target;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 打標&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 1. 要清楚的知道被執行的 SQL 是定義在 Mapper 中的哪條&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 2. 要清楚的知道這條 SQL 被執行時方法的調用棧&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;marking&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementHandler delegate)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;BoundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;boundSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;delegate.getBoundSql();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 實際的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;boundSql.getSql().trim();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只對 select 打標&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sql,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 獲取其基類中的 MappedStatement 即定義的 SQL 聲明對象，獲取它的 ID 值表示它是哪條 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getFieldValue(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; BaseStatementHandler.class, delegate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"mappedStatement"&lt;/span&gt;, MappedStatement.class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;mappedStatement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法調用棧&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按順序創建打標的內容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 打標&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sql = String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 反射更新&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(BoundSql.class,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"sql"&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.set(boundSql, sql);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;* 獲取某類型 clazz 某對象 object 下某字段 fieldName 的值 fieldClass&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;*/&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&amp;lt;T&amp;gt; T&amp;nbsp;&lt;span class="code-snippet__title"&gt;getFieldValue&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Class&amp;lt;?&amp;gt; clazz, Object object, String fieldName, Class&amp;lt;T&amp;gt; fieldClass)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException, IllegalAccessException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 獲取到目標類的字段&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;field&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;getField(clazz, fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;fieldClass.cast(field.get(object));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;String&amp;nbsp;&lt;span class="code-snippet__title"&gt;trace&lt;/span&gt;&lt;span class="code-snippet__params"&gt;()&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; StackTraceElement[] stackTraceArray = Thread.currentThread().getStackTrace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(stackTraceArray.length &amp;lt;= DEFAULT_INDEX) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedList&amp;lt;String&amp;gt; methodInfoList =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;i&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceArray.length -&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;&amp;nbsp;- DEFAULT_INDEX; i &amp;gt;= DEFAULT_INDEX; i--) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StackTraceElement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stackTraceElement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceArray[i];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;className&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;stackTraceElement.getClassName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(!className.startsWith(&lt;span class="code-snippet__string"&gt;"com.your.package"&lt;/span&gt;) || className.contains(&lt;span class="code-snippet__string"&gt;"FastClassBySpringCGLIB"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; || className.contains(&lt;span class="code-snippet__string"&gt;"EnhancerBySpringCGLIB"&lt;/span&gt;) || stackTraceElement.getMethodName().contains(&lt;span class="code-snippet__string"&gt;"lambda$"&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 過濾攔截器相關&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(className.contains(&lt;span class="code-snippet__string"&gt;"Interceptor"&lt;/span&gt;) || className.contains(&lt;span class="code-snippet__string"&gt;"Aspect"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 只拼接類和方法，不拼接文件名和行號&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;methodInfo&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;"%s#%s"&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; className.substring(className.lastIndexOf(&lt;span class="code-snippet__string"&gt;'.'&lt;/span&gt;) +&amp;nbsp;&lt;span class="code-snippet__number"&gt;1&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stackTraceElement.getMethodName()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; methodInfoList.add(methodInfo);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(methodInfoList.isEmpty()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;EMPTY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 格式化結果&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StringJoiner&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;stringJoiner&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;StringJoiner&lt;/span&gt;(&lt;span class="code-snippet__string"&gt;" ==&amp;gt; "&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;(String method : methodInfoList) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stringJoiner.add(method);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;stringJoiner.toString();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;Field&amp;nbsp;&lt;span class="code-snippet__title"&gt;getField&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(Class&amp;lt;?&amp;gt; clazz, String fieldName)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;NoSuchFieldException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Field field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;cacheKey&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;"%s.%s"&lt;/span&gt;, clazz.getName(), fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(FIELD_CACHE.containsKey(cacheKey)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field = FIELD_CACHE.get(cacheKey);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;else&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field = clazz.getDeclaredField(fieldName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; field.setAccessible(&lt;span class="code-snippet__literal"&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; FIELD_CACHE.put(cacheKey, field);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;field;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1329" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;基於 AspectJ 織入實現&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;p data-nodeid="1331" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;這種方法主要用於在未使用 Mybatis 框架的系統中，&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1797"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;基於 AspectJ 實現對 Maven 依賴中 Jar 包類的織入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，完成 SQL 染色打標的操作。同時，這種方法並不限於此，大家可以借鑑這種方法用於其他 Jar 包的織入，而不侷限於 Spring 提供的 AOP 機制，畢竟 Spring 的 AOP 只能對 Bean 進行織入。所以在本小節中，更注重方法的介紹。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_8"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1332" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;添加依賴和配置插件&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1333" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;藉助 AspectJ 在&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1804"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;編譯期&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;實現對 Maven 依賴中 Jar 包類的織入，這與運行時織入（如 Spring AOP 使用的代理機制）不同，編譯期織入是在生成的字節碼中直接包含切面邏輯，生成的類文件已經包含了切面代碼。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;p data-nodeid="1334" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;首先，需要先添加依賴：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="xml"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;dependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.aspectj&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;aspectjrt&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8.13&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;dependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1334" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;並且在 Maven 的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1807" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;plugins&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;標籤下添加&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1809" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;aspectj-maven-plugin&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;插件配置，否則無法實現在編譯期織入：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="xml"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.codehaus.mojo&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;aspectj-maven-plugin&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.11&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;version&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;configuration&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 解決與 Lombok 的衝突 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;forceAjcCompile&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;true&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;forceAjcCompile&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;sources&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectories&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectory&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;${project.build.directory}/classes&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectory&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDirectories&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- JDK 版本 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;complianceLevel&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;complianceLevel&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;1.8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;target&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 展示織入信息 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;showWeaveInfo&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;true&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;showWeaveInfo&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;&amp;lt;!-- 重點！配置要織入的 maven 依賴 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependencies&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;org.apache.ibatis&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;groupId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;ibatis-sqlmap&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;artifactId&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;weaveDependencies&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;configuration&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;executions&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;execution&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goals&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goal&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;compile&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goal&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;goals&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;execution&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;executions&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__tag"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&lt;span class="code-snippet__name"&gt;plugin&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__tag"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1337" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="xml"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;解決與 Lombok 的衝突配置內容不再解釋，詳細請看 CSDN: AspectJ 和 lombok。重點需要關注的配置內容是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1816" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;weaveDependency&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;標籤：配置織入依賴（詳細可參見 Maven: aspectj-maven-plugin 官方文檔），也就是説如果我們想對&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1822" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlExecutor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;進行織入，那麼需要將它對應的 Maven 依賴添加到這個標籤下才能生效，否則無法完成織入。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;p data-nodeid="1339" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成以上內容之後，現在去實現對應的攔截器即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id="OSC_h4_9"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1340" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;font-weight: bold;"&gt;攔截器實現&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1341" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;攔截器的實現原理非常簡單，要織入的方法是&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1827" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;com.ibatis.sqlmap.engine.execution.SqlExecutor#executeQuery&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，這個方法的簽名如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;executeQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementScope statementScope, Connection conn, String sql, Object[] parameters,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;skipResults,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;maxResults, RowHandlerCallback callback)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;p data-nodeid="1341" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;根據我們的訴求：在 SQL 執行前對 SQL 進行染色打標，那麼可以直接在這個方法的第三個參數&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1830" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;String sql&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;上打標，以下是攔截器的實現：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Slf4j&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__meta"&gt;@Aspect&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;private&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;static&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;final&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;DEFAULT_INDEX&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__meta"&gt;@Around("execution(* com.ibatis.sqlmap.engine.execution.SqlExecutor.executeQuery(..))")&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;Object&amp;nbsp;&lt;span class="code-snippet__title"&gt;aroundExecuteQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(ProceedingJoinPoint joinPoint)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;Throwable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 獲取方法參數&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] args = joinPoint.getArgs();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;sqlTemplate&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;""&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;arg2&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(arg2&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;String) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 實際的 SQL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sqlTemplate = (String) arg2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(StringUtils.containsIgnoreCase(sqlTemplate,&amp;nbsp;&lt;span class="code-snippet__string"&gt;"select"&lt;/span&gt;)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;try&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// SQL 聲明的 ID&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;mappedStatementId&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;""&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;Object&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;arg0&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;args[&lt;span class="code-snippet__number"&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(arg0&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;instanceof&lt;/span&gt;&amp;nbsp;StatementScope) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;StatementScope&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statementScope&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;(StatementScope) arg0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;MappedStatement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;statement&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;statementScope.getStatement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;if&lt;/span&gt;&amp;nbsp;(statement !=&amp;nbsp;&lt;span class="code-snippet__literal"&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mappedStatementId = statement.getId();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 方法調用棧&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;trace&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;trace();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 按順序創建打標的內容&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; LinkedHashMap&amp;lt;String, Object&amp;gt; markingMap =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;LinkedHashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STATEMENT_ID"&lt;/span&gt;, mappedStatementId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; markingMap.put(&lt;span class="code-snippet__string"&gt;"STACK_TRACE"&lt;/span&gt;, trace);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;marking&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;"[SQLMarking] "&lt;/span&gt;.concat(markingMap.toString());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 先打標後 SQL，避免有些平台展示 SQL 時進行尾部截斷，而看不到染色信息&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;String&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;markingSql&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;String.format(&lt;span class="code-snippet__string"&gt;" /* %s */ %s"&lt;/span&gt;, marking, sqlTemplate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;] = markingSql;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;catch&lt;/span&gt;&amp;nbsp;(Exception e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 發生異常的話恢復最原始 SQL 保證執行&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; args[&lt;span class="code-snippet__number"&gt;2&lt;/span&gt;] = sqlTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; log.error(e.getMessage(), e);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__comment"&gt;// 正常執行邏輯&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;return&lt;/span&gt;&amp;nbsp;joinPoint.proceed(args);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1344" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="java"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;邏輯上非常簡單，獲取了&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1833" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;MappedStatementId&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;和線程的執行堆棧以註釋的形式標記在 SELECT 語句前，注意如果大家要&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong data-nodeid="1841"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;對 INSERT 語句進行打標時，需要將標記打在 SQL 的最後&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;，因為部分插件如&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1839" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;InsertStatementParser&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;會識別 INSERT，如果註釋在前，INSERT 識別會有誤報錯。&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;span id="OSC_h4_10"&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid="1346" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;驗證織入&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt; 
 &lt;p data-nodeid="1347" style="margin-bottom: 8px;text-align: left;"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;完成以上工作後，我們需要驗證攔截器是否織入成功，因為織入是在編譯期完成的，所以執行以下 Maven 編譯命令即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="nginx"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__attribute"&gt;mvn&lt;/span&gt;&amp;nbsp;clean compile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1348" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="shell"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;在控制枱中可以發現如下日誌信息提示織入成功：&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="cs"&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] --- aspectj-maven-plugin:&lt;span class="code-snippet__number"&gt;1.11&lt;/span&gt;:compile (&lt;span class="code-snippet__literal"&gt;default&lt;/span&gt;) @ ---&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] Showing AJC message detail&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;for&lt;/span&gt;&amp;nbsp;messages of types: [error, warning, fail]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;[&lt;span class="code-snippet__meta"&gt;INFO&lt;/span&gt;] Join point&amp;nbsp;&lt;span class="code-snippet__string"&gt;'method-execution(void com.ibatis.sqlmap.engine.execution.SqlExecutor.executeQuery(com.ibatis.sqlmap.engine.scope.StatementScope, java.sql.Connection, java.lang.String, java.lang.Object[], int, int, com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback))'&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;in&lt;/span&gt;&amp;nbsp;Type&amp;nbsp;&lt;span class="code-snippet__string"&gt;'com.ibatis.sqlmap.engine.execution.SqlExecutor'&lt;/span&gt;&amp;nbsp;(SqlExecutor.java:&lt;span class="code-snippet__number"&gt;163&lt;/span&gt;) advised&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;by&lt;/span&gt;&amp;nbsp;around advice&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;from&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__string"&gt;'com.your.package.sqlmarking.SqlExecutorInterceptor'&lt;/span&gt;&amp;nbsp;(SqlExecutorInterceptor.&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;(&lt;span class="code-snippet__keyword"&gt;from&lt;/span&gt;&amp;nbsp;SqlExecutorInterceptor.java))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid="1348" style="margin-bottom: 8px;text-align: left;"&gt;&lt;code data-language="shell"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;並且在相應的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code data-nodeid="1846" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;target/classes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;目錄下的&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;code data-nodeid="1848" data-backticks="1"&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;SqlExecutor.class&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;span leaf=""&gt;&lt;span textstyle="" style="font-size: 16px;letter-spacing: normal;"&gt;&amp;nbsp;文件中也能發現被織入的邏輯：&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt; 
 &lt;section class="code-snippet__fix code-snippet__js"&gt; 
  &lt;pre class="code-snippet__js" data-lang="java"&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;class&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutor&lt;/span&gt;&amp;nbsp;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;public&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;void&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;executeQuery&lt;/span&gt;&lt;span class="code-snippet__params"&gt;(StatementScope statementScope, Connection conn, String sql, Object[] parameters,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;skipResults,&amp;nbsp;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&lt;span class="code-snippet__type"&gt;int&lt;/span&gt;&lt;/span&gt;&lt;span class="code-snippet__params"&gt;&amp;nbsp;maxResults, RowHandlerCallback callback)&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;throws&lt;/span&gt;&amp;nbsp;SQLException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; JoinPoint.&lt;span class="code-snippet__type"&gt;StaticPart&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var10000&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;ajc$tjp_0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] var24 =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;[]{statementScope, conn, sql, parameters, Conversions.intObject(skipResults), Conversions.intObject(maxResults), callback};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;JoinPoint&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var23&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;Factory.makeJP(var10000,&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;,&amp;nbsp;&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;, var24);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;span class="code-snippet__type"&gt;SqlExecutorInterceptor&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__variable"&gt;var26&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__operator"&gt;=&lt;/span&gt;&amp;nbsp;SqlExecutorInterceptor.aspectOf();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Object[] var25 =&amp;nbsp;&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;Object&lt;/span&gt;[]{&lt;span class="code-snippet__built_in"&gt;this&lt;/span&gt;, statementScope, conn, sql, parameters, Conversions.intObject(skipResults), Conversions.intObject(maxResults), callback, var23};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var26.aroundExecuteQuery((&lt;span class="code-snippet__keyword"&gt;new&lt;/span&gt;&amp;nbsp;&lt;span class="code-snippet__title"&gt;SqlExecutor$AjcClosure1&lt;/span&gt;(var25)).linkClosureAndJoinPoint(&lt;span class="code-snippet__number"&gt;69648&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&amp;nbsp; &amp;nbsp; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span leaf=""&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;/section&gt; 
 &lt;section style="text-align: center;margin-bottom: 8px;" data-pm-slice="0 0 []"&gt; 
  &lt;span style="font-size: 16px;letter-spacing: normal;"&gt;&lt;span leaf=""&gt;&lt;img alt="圖片" class="rich_pages wxw-img" data-imgfileid="100028809" data-ratio="1" data-s="300,640" src="https://oscimg.oschina.net/oscnet/46c7d8db-baf6-4d84-b93c-634d251ca487.png" data-type="webp" data-w="396" style="pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style="text-align: center;margin-bottom: 8px;" data-pm-slice="0 0 []"&gt; 
  &lt;span style="font-size: 16px;letter-spacing: normal;"&gt;&lt;span leaf=""&gt;掃一掃，加入技術交流羣&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style="display: none;"&gt; 
  &lt;mp-style-type data-value="3"&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style="color: #858585; font-size: 13px;"&gt;本文分享自微信公眾號 - 京東雲開發者（JDT_Developers）。&lt;br&gt;如有侵權，請聯繫 support@oschina.cn 刪除。&lt;br&gt;本文參與「&lt;a href="https://www.oschina.net/sharing-plan" target="_blank"&gt;OSC 源創計劃&lt;/a&gt;」，歡迎正在閲讀的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/4090830/blog/18604552</link>
      <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/18604552</guid>
      <pubDate>Sat, 10 May 2025 08:35:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Anthropic 未經許可使用書籍訓練 AI 模型屬於「合理使用」</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;美國舊金山聯邦法官威廉・阿爾蘇普（William Alsup）&lt;u&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.reuters.com%2Flegal%2Flitigation%2Fanthropic-wins-key-ruling-ai-authors-copyright-lawsuit-2025-06-24%2F" target="_blank"&gt;裁定&lt;/a&gt;&lt;/u&gt;，&lt;strong&gt;Anthropic 在未經作者許可的情況下使用已出版書籍訓練其 AI 模型屬於「合理使用 (fair use)」&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0625/153420_i6T1_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;這標誌着法院首次認可 AI 公司的主張，即當 AI 公司使用受版權保護的材料訓練大型語言模型（LLM）時，合理使用原則可使其免於承擔責任。&lt;/p&gt; 
&lt;p&gt;法官指出，AI 模型對作品的訓練類似於讀者閲讀並從中汲取靈感以創作新內容，而非複製或取代原作。然而，判決也指出，Anthropic 在 2021 年至 2022 年期間從 Books3、Library Genesis 和 Pirate Library Mirror 等來源下載的超過 700 萬本盜版電子書不屬於合理使用，這部分內容將面臨陪審團審判。Anthropic 曾花費數百萬美元購買並掃描大量印刷書籍，將其轉換為數字格式用於內部研究。&lt;/p&gt; 
&lt;p&gt;這一裁決被認為是 AI 行業在版權合理使用方面的一個重要里程碑。同時對作者、藝術家和出版商是一個打擊，他們已對 OpenAI、Meta、Midjourney、Google 等公司提起數十起訴訟。儘管這一裁決並不能保證其他法官會效仿阿爾蘇普法官的做法，但它為支持科技公司而非創作者的先例奠定了基礎。&lt;/p&gt; 
&lt;p&gt;這些訴訟通常取決於法官如何解釋合理使用原則，這是版權法中一個出了名難以界定的例外條款，該條款自 1976 年以來就未更新過 —— 那時互聯網尚未出現，更不用説生成式 AI 訓練數據集的概念了。&lt;/p&gt; 
&lt;p&gt;合理使用裁決會考慮作品的使用目的（模仿和教育用途可能是可行的）、是否為商業利益而複製（你可以寫《星球大戰》同人小説，但不能出售），以及衍生作品與原作相比的轉換性程度。&lt;/p&gt; 
&lt;p&gt;像 Meta 這樣的公司在為使用受版權保護的作品進行訓練辯護時也提出了類似的合理使用論點，不過在本週的裁決之前，法院會如何裁決還不太明確。&lt;/p&gt; 
&lt;p&gt;在這起具體的 Bartz 訴 Anthropic 案中，原告作者團體還對 Anthropic 獲取和存儲他們作品的方式提出了質疑。根據訴訟稱，Anthropic 試圖創建一個 「中央圖書館」，收錄 「世界上所有的書籍」 並 「永久」 保存。但這些受版權保護的數百萬本書籍是從盜版網站免費下載的，這顯然是非法的。&lt;/p&gt; 
&lt;p&gt;儘管法官承認 Anthropic 對這些材料的訓練屬於合理使用，但法院將對 「中央圖書館」 的性質進行審判。&lt;/p&gt; 
&lt;p&gt;「我們將對用於創建 Anthropic 中央圖書館的盜版副本及其造成的損害進行審判」， 阿爾蘇普法官在裁決中寫道，「Anthropic 後來購買了一本之前從互聯網上竊取的書，並不能免除其盜竊責任，但可能會影響法定損害賠償的程度。」&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀：&lt;a href="https://www.oschina.net/news/353744" target="news"&gt;Reddit&amp;nbsp;起訴 Anthropic 未經許可使用其數據訓練 AI 模型&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357201</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357201</guid>
      <pubDate>Sat, 10 May 2025 07:34:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>WinRAR「壓縮包」再度開售，價格和 5 份 WinRAR 正版授權相當</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;WinRAR 官方手提包周邊於 2025 年 2 月首次由 WinRAR 與製造商 Tern 聯動推出，當時迅速售罄。近日，Tern &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Ftern_et%2Fstatus%2F1935705139429470405" target="_blank"&gt;宣佈這款「壓縮包」再次開售&lt;/a&gt;，並將於 9 月開始發貨。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1052" src="https://static.oschina.net/uploads/space/2025/0625/150540_IMgE_2720166.png" width="1300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="858" src="https://static.oschina.net/uploads/space/2025/0625/150922_XENV_2720166.png" width="1146" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;以下是具體信息：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;價格&lt;/strong&gt; ：定價 150 美元，按現匯率約合 1077 元人民幣，相當於購買五份正版 WinRAR 軟件的費用。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;設計&lt;/strong&gt; ：尺寸為 21.4×14×7 釐米，外形參考 WinRAR 的圖標設計，呈現出經典的粉、藍、綠三色書本被皮帶捆紮的設計，此次版本的肩帶改為可拆卸式，使用夾子固定，方便用戶根據需要調整。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;購買方式及發貨時間&lt;/strong&gt; ：在 Tern 官網售賣，支持全球 DHL 郵寄，將於 2025 年 9 月發貨。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;em&gt;購買地址：https://in.tern.et/products/winrar-archive-messenger-bag-prod&lt;/em&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357195/winrar-archive-messenger-bag</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357195/winrar-archive-messenger-bag</guid>
      <pubDate>Sat, 10 May 2025 07:10:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>投資 140 億卻成競爭對手，微軟遭遇 ChatGPT 企業市場</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;彭博社最新報道稱，微軟正面臨一個尷尬局面：儘管該公司努力向企業推銷 Copilot AI 助手，但越來越多的員工卻更青睞其合作伙伴 OpenAI 的 ChatGPT，這一現象正在企業市場引發激烈競爭。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;知名藥企安進公司的經歷完美詮釋了這一市場變化。去年春天，安進宣佈為旗下 2 萬名員工購買微軟 Copilot，成為微軟在生成式 AI 領域的重要客戶案例。然而，僅僅 13 個月後，安進員工卻紛紛轉向使用 OpenAI 的 ChatGPT。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;安進高級副總裁肖恩·布魯伊希表示："OpenAI 成功的祕訣在於，他們把產品做得極具趣味性。"他指出，ChatGPT 在研究和科學文獻總結等任務中表現尤為出色，而 Copilot 更多是在配合微軟自家軟件使用時才顯現優勢。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;這種現象讓微軟與 OpenAI 之間的關係變得更加微妙。作為 OpenAI 的最大投資方，微軟已累計投資近 140 億美元，但現在卻發現自己在企業市場與被投資方直接競爭。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="333" src="https://oscimg.oschina.net/oscnet/up-4e4e30f181b826c01ebfb42865d828ee27e.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;微軟銷售團隊反映，在推廣 Copilot 時經常措手不及，而公司又迫切希望快速擴大客戶基礎。與此同時，OpenAI 也在積極擴張企業業務，近期更是收購了 AI 代碼助手 Windsurf，直接對標微軟的 GitHub Copilot。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;儘管兩款產品都基於 OpenAI 的大語言模型，但用戶體驗存在顯著差異。許多企業發現，員工普遍更偏愛 ChatGPT，主要原因包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:0"&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;更新速度&lt;/strong&gt;：OpenAI 的模型更新在微軟軟件中往往延遲數週才能落地&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;用戶熟悉度&lt;/strong&gt;：很多職場人士早已在個人場景中體驗過 ChatGPT&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;功能體驗&lt;/strong&gt;：ChatGPT 在某些專業任務中表現更優&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;微軟解釋稱，延遲更新是因為需要進行企業級安全測試和用戶體驗驗證。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;面對這一競爭態勢，不同企業採取了不同策略。紐約人壽保險公司決定在 12000 名員工中同時推廣 ChatGPT 和 Copilot，根據使用反饋決定最終選擇。金融科技公司 Finastra 選擇微軟 Copilot，看重其與微軟辦公軟件的深度整合優勢。貝恩諮詢公司則向 16000 名員工部署 ChatGPT，絕大多數員工日常使用，而僅有約 2000 名員工使用 Copilot 且主要搭配 Excel。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;OpenAI 表示已擁有 300 萬付費企業用戶，短短几個月內增長 50%。微軟則回應稱 Copilot 已覆蓋 70% 的財富 500 強企業，付費用戶數量比去年同期增加兩倍。在定價方面，微軟 Copilot 每用戶每月 30 美元，相比 ChatGPT 企業版的 60 美元更具價格優勢，但 OpenAI 也推出了按使用量收費的靈活方案。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Gartner 分析師傑森·王認為，目前許多公司仍在小範圍測試階段，市場競爭格局尚未完全確定，但這無疑是"OpenAI 與微軟之間的正面對決"。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357193</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357193</guid>
      <pubDate>Sat, 10 May 2025 07:10:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>支付寶為 AI 開發者提供國內首個「AI 打賞」服務</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;支付寶宣佈為 AI 開發者提供國內首個「AI 打賞」服務，並首發上線螞蟻百寶箱平台、阿里雲百鍊，為開發者提供便捷收款能力，進一步推動 AI 技術的商業化應用。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;據介紹，「AI 打賞」服務旨在滿足 AI 智能體內收取讚賞、小費等需求，為開發者提供一種輕量化的收款解決方案。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;個人開發者只需登錄螞蟻百寶箱平台或阿里雲百鍊，選擇開通「AI 打賞」功能並給智能體掛載該服務，即可快速啓用打賞功能。開通後，用戶打賞的金額將直接轉入開發者賬戶。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="546" src="https://oscimg.oschina.net/oscnet/up-d77d6a355574699398813e0bde3af584ec9.png" width="300" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;值得一提的是，今年 4 月，支付寶曾推出國內首個支付 MCP，助力 AI 開發者具備支付收款能力，實現服務訂閲、付費解鎖等商業化功能。而此次推出的「AI 打賞」服務，則更側重於讓用戶主動表達讚賞和感謝，兩者結合將形成基礎付費與靈活激勵並存的多元服務模式。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357178</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357178</guid>
      <pubDate>Sat, 10 May 2025 06:09:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>AI 編輯器 Void 發佈 Beta，可作為 Cursor 開源替代方案</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;Void 是一款開源 AI 編輯器，可作為 Cursor 的替代品。Void&amp;nbsp;支持跟 Cursor 一樣的功能，比如 Tab 補全代碼，Ctrl + K 編輯選中內容，支持用 AI 搜索代碼庫，支持編輯和查看底層提示。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-a9e2f51d6bea16cac1680764e79150155e1.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fvoideditor%2Fvoid%2Freleases%2Ftag%2Fbeta" target="_blank"&gt;Void 最近發佈了 Beta 版本&lt;/a&gt;，其作為 VS Code 的分支，旨在解決私有 AI 輔助編程工具的安全隱私和費用問題。閉源編輯器可能需要通過後端發送私有代碼數據，這會帶來隱私問題，另一個問題是持續的訂閲費用。&lt;/p&gt; 
&lt;p&gt;Void 提供了多種選項，確保開發者能控制自己的數據。它能利用多種大模型，可以使用任何本地的 LLM 驅動，也可以使用 Claude、GPT 或 Gemini 的 API，不會留存你的數據，避開了第三方中間人。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357154/void-editor-beta</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357154/void-editor-beta</guid>
      <pubDate>Sat, 10 May 2025 03:56:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>ElevenLabs 發佈移動端 AI 語音工具 APP</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;ElevenLabs 是一家專注於開發人工智能語音模型和工具的 AI 公司，近日&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Felevenlabs.io%2Fblog%2Fintroducing-the-elevenlabs-app" target="_blank"&gt;宣佈&lt;/a&gt;推出官方 ElevenLabs 移動應用，為用戶提供最強大的 AI 語音工具，支持 iOS 和 Android 用戶隨時隨地將文本轉成語音片段。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e444a0db29602ba48998df1adbdf75133fd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，&lt;span&gt;ElevenLabs 的免費套餐為用戶提供大約 10 分鐘的音頻生成時間。網頁版與移動版應用之間共享信用額度，用戶可以根據自身需求選擇不同的模型，在成本與音質之間進行平衡。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span&gt;應用還接入了 ElevenLabs 最新的 v3 alpha 文本轉語音模型，該模型允許用戶通過標籤控制語音的情感表達。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-0bd8cefff977a3158c5aa87f0aa53985792.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀：&lt;a href="https://www.oschina.net/news/353936/eleven-v3-alpha" target="_blank"&gt;ElevenLabs 發佈文本轉語音模型 Eleven v3（Alpha 版）&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357151/elevenlabs-app</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357151/elevenlabs-app</guid>
      <pubDate>Sat, 10 May 2025 03:41:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>加州法院裁定使用版權內容訓練 AI 合規</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style="color:#000000"&gt;美國加州北區地方法院&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstorage.courtlistener.com%2Frecap%2Fgov.uscourts.cand.434709%2Fgov.uscourts.cand.434709.231.0_2.pdf" target="_blank"&gt;裁定&lt;/a&gt;&lt;span style="color:#000000"&gt;，Anthropic 公司在未經作者許可的情況下，使用已出版的書籍訓練其 AI 模型是合法的。這標誌着法院首次認可 AI 公司的説法，即合理使用原則可以免除 AI 公司在使用受版權保護的材料訓練大語言模型（LLM）時的過錯。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="373" src="https://oscimg.oschina.net/oscnet/up-882fd79bf13f9f7781721a1a048d0fa9333.png" width="700" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;根據科技媒體 AppleInsider 的報道，許多創作者和藝術家長期以來都在為人工智能公司未經許可抓取其作品而苦惱。這些公司利用抓取的數據來訓練大型語言模型（LLM），並將其商業化，然而內容的原創者卻未能得到應有的補償。對此，Andrea Bartz、Charles Graeber 和 Kirk Wallace Johnson 於 2024 年向法院提起訴訟，指控 Anthropic 公司侵犯其版權，使用了盜版材料。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;法官 William Alsup 在裁決中支持了雙方的部分請求，但最終認為用於訓練特定大語言模型的副本屬於合理使用。這一裁定意味着 AI 公司在訓練其模型時可以合法使用受版權保護的內容，而這也讓眾多藝術家、音樂家和作家感到失望。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;對於這些創作者來説，這項決定可能會使他們面臨更大的商業風險，AI 模型的生成能力有可能進一步侵蝕他們的作品價值。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Alsup 法官&lt;/span&gt;&lt;span style="background-color:#ffffff; color:#242424"&gt;在判決書中明確表示:"我們將就 Anthropic 公司用於創建中央圖書館的盜版書籍及其造成的損失進行審理。Anthropic 公司後來購買了之前從網上盜取的書籍，這並不能免除其盜竊責任，但這可能會影響法定賠償的數額。"&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357149</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357149</guid>
      <pubDate>Sat, 10 May 2025 03:26:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Redis 是單線程模型？</title>
      <description>&lt;div class="content"&gt;
                                                                                                                    
                                                                                                                                                    &lt;span id="OSC_h1_1"&gt;&lt;/span&gt; 
&lt;h1&gt;一、背景&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用過 Redis 的同學肯定都瞭解過一個説法，説 Redis 是單線程模型，那麼實際情況是怎樣的呢？&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;其實，我們常説 Redis 是單線程模型，&lt;strong&gt;是指 Redis 採用單線程的事件驅動模型，只有並且只會在一個主線程中執行 Redis 命令操作&lt;/strong&gt;，這意味着它在處理請求時不使用複雜的上下文切換或鎖機制。儘管只是單線程的架構，但 Redis 通過非阻塞的 I/O 操作和高效的事件循環來處理大量的併發連接，性能仍然非常高。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;然而在 Redis4.0 開始也引入了一些後台線程執行異步淘汰、異步刪除過期 key、異步執行大 key 刪除等任務，然後，在 Redis6.0 中引入了多線程 IO 特性，將 Redis 單節點訪問請求從 10W 提升到 20W。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;而在去年 Valkey 社區發佈的 Valkey8.0 版本，在 I/O 線程系統上進行了重大升級，特別是異步 I/O 線程的引入，使主線程和 I/O 線程能夠並行工作，可實現最大化服務吞吐量並減少瓶頸，使得 Valkey 單節點訪問請求可以提升到 100W。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;那麼在 Redis6.0 和 Valkey8.0 中多線程 IO 是怎麼回事呢？是否改變了 Redis 原有單線程模型？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;2024 年，Redis 商業支持公司 Redis Labs 宣佈 Redis 核心代碼的許可證從 BSD 變更為 RSALv2，明確禁止雲廠商提供 Redis 託管服務，這一決定直接導致社區分裂。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;為維護開源自由，Linux 基金會聯合多家科技公司（包括 AWS、Google、Cloud、Oracle 等）宣佈支持 Valkey，作為 Redis 的替代分支。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Valkey8.0 系 Valkey 社區發佈的首個主要大版本。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;最新消息，在 Redis 項目創始人 antirez 今年加入 Redis 商業公司 5 個月後，Redis 宣傳從 Redis8 開始，Redis 項目重新開源。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;本篇文章主要介紹 Redis6.0 多線程 IO 特性。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_2"&gt;&lt;/span&gt; 
&lt;h1&gt;二、Redis6.0 多線程 IO 概述&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多線程 IO，但多線程部分只是用來處理網絡數據的讀寫和協議解析，&lt;strong&gt;執行命令仍然是單線程。默認是不開啓的&lt;/strong&gt;，需要進程啓動前開啓配置，並且在運行期間無法通過&lt;strong&gt;&amp;nbsp;config set&amp;nbsp;&lt;/strong&gt;命令動態修改。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;參數與配置&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;多線程 IO 涉及下面兩個配置參數：&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;# io-threads 4 &amp;nbsp;IO 線程數量
# io-threads-do-reads no &amp;nbsp;讀數據及數據解析是否也用 IO 線程&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;表示 IO 線程數量，&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;設置為 1 時（代碼中默認值），表示只使用主線程，不開啓多線程 IO。因此，若要配置開啓多線程 IO，需要設置&lt;strong&gt;&amp;nbsp;io-threads&amp;nbsp;&lt;/strong&gt;大於 1，但不可以超過最大值 128。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;但在默認情況下，Redis 只將多線程 IO 用於向客戶端寫數據，因為作者認為通常使用多線程執行讀數據的操作幫助不是很大。如果需要使用多線程用於讀數據和解析數據，則需要將參數&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;設置為&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;此兩項配置&lt;strong&gt;參數在 Redis 運行期間無法通過&amp;nbsp;config set&amp;nbsp;命令修改，並且開啓 SSL 時，不支持多線程 IO 特性。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;若機器 CPU 將至少超過 4 核時，則建議開啓，並且至少保留一個備用 CPU 核，使用超過 8 個線程可能並不會有多少幫助。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;執行流程概述&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多線程 IO 後，讀寫數據執行流程如下所示：&lt;/span&gt;&lt;/p&gt; 
&lt;div style="text-align:left"&gt; 
 &lt;img src="https://static001.geekbang.org/infoq/f1/f1751e15cbe5116df1883b0155195ec5.png" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;流程簡述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;主線程負責接收建立連接請求，獲取 socket 放入全局等待讀處理隊列。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程處理完讀事件之後，通過 RR（Round Robin）將這些連接分配給這些 IO 線程，也會分配給主線程自己。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程先讀取分配給自己的客戶端數據，然後阻塞等待其他 IO 線程讀取 socket 完畢。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 線程將請求數據讀取並解析完成（這裏只是讀數據和解析、並不執行）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程通過單線程的方式執行請求命令。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程通過 RR（Round Robin）將回寫客戶端事件分配給這些 IO 線程，也會分配給主線程自己。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程同樣執行部分寫數據到客戶端，然後阻塞等待 IO 線程將數據回寫 socket 完畢。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;設計特點&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;IO 線程要麼同時在讀 socket，要麼同時在寫，不會同時讀和寫。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 線程只負責讀寫 socket 解析命令，不負責命令執行。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程也會參與數據的讀寫。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_5"&gt;&lt;/span&gt; 
&lt;h1&gt;三、源碼分析&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;多線程 IO 相關源代碼都在源文件 networking.c 中最下面。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_6"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;初始化&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;主線程在 main 函數中調用 InitServerLast 函數，InitServerLast 函數中調用&lt;strong&gt;initThreadedIO 函數&lt;/strong&gt;，在 initThreadedIO 函數中根據配置文件中的線程數量，創建對應數量的 IO 工作線程數量。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;/* Initialize the data structures needed for threaded I/O. */
void&amp;nbsp;initThreadedIO(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp; io_threads_active =&amp;nbsp;0;&amp;nbsp;/* We start with threads not active. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Don't spawn any thread if the user selected a single thread:
&amp;nbsp; &amp;nbsp; &amp;nbsp;* we'll handle I/O directly from the main thread. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1)&amp;nbsp;return;
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num &amp;gt; IO_THREADS_MAX_NUM) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverLog(LL_WARNING,"Fatal: too many I/O threads configured. "
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;"The maximum number is %d.", IO_THREADS_MAX_NUM);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;exit(1);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Spawn and initialize the I/O threads. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;i =&amp;nbsp;0; i &amp;lt; server.io_threads_num; i++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Things we do for all the threads including the main thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_list[i] =&amp;nbsp;listCreate();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(i ==&amp;nbsp;0)&amp;nbsp;continue;&amp;nbsp;/* Thread 0 is the main thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Things we do only for the additional threads. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_t&amp;nbsp;tid;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_init(&amp;amp;io_threads_mutex[i],NULL);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[i] =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[i]);&amp;nbsp;/* Thread will be stopped. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pthread_create(&amp;amp;tid,NULL,IOThreadMain,(void*)(long)i) !=&amp;nbsp;0) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverLog(LL_WARNING,"Fatal: Can't initialize IO thread.");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;exit(1);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads[i] = tid;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如果&lt;strong&gt;&amp;nbsp;io_threads_num&amp;nbsp;&lt;/strong&gt;的數量為 1，則只運行主線程，&lt;strong&gt;&amp;nbsp;io_threads_num&amp;nbsp;&lt;/strong&gt;的 IO 線程數量不允許超過 128。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;序號為 0 的線程是主線程，因此實際的工作線程數目是 io-threads - 1。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;初始化流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;為包括主線程在內的每個線程分配 list 列表，用於後續保存待處理的客戶端。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;為主線程以外的其他 IO 線程初始化互斥對象 mutex，但是立即調用 pthread_mutex_lock 佔有互斥量，將 io_threads_pending[i]設置為 0，接着創建對應的 IO 工作線程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;佔用互斥量是為了創建 IO 工作線程後，可暫時等待後續啓動 IO 線程的工作，因為 IOThreadMain 函數在 io_threads_pending[id] == 0 時也調用了獲取 mutex，所以此時無法繼續向下運行，等待啓動。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;在 startThreadedIO 函數中會釋放 mutex 來啓動 IO 線程工作。何時調用 startThreadedIO 打開多線程 IO，具體見下文的「多線程 IO 動態暫停與開啓」。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;IO 線程主函數&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;IO 線程主函數代碼如下所示：&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;*IOThreadMain(void&amp;nbsp;*myid)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* The ID is the thread number (from 0 to server.iothreads_num-1), and is
&amp;nbsp; &amp;nbsp; &amp;nbsp;* used by the thread to just manipulate a single sub-array of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;long&amp;nbsp;id = (unsigned&amp;nbsp;long)myid;
&amp;nbsp; &amp;nbsp;&amp;nbsp;char&amp;nbsp;thdname[16];
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;snprintf(thdname,&amp;nbsp;sizeof(thdname),&amp;nbsp;"io_thd_%ld", id);
&amp;nbsp; &amp;nbsp;&amp;nbsp;redis_set_thread_title(thdname);
&amp;nbsp; &amp;nbsp;&amp;nbsp;redisSetCpuAffinity(server.server_cpulist);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for start */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;0; j &amp;lt;&amp;nbsp;1000000; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_pending[id] !=&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the main thread a chance to stop this thread. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_pending[id] ==&amp;nbsp;0) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_unlock(&amp;amp;io_threads_mutex[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(io_threads_pending[id] !=&amp;nbsp;0);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("[%ld] %d to handle\n", id, (int)listLength(io_threads_list[id]));
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Process: note that the main thread will never touch our list
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* before we drop the pending count to 0. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[id],&amp;amp;li);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_op == IO_THREADS_OP_WRITE) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;writeToClient(c,0);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;if&amp;nbsp;(io_threads_op == IO_THREADS_OP_READ) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;readQueryFromClient(c-&amp;gt;conn);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;serverPanic("io_threads_op value is unknown");
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[id]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[id] =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("[%ld] Done\n", id);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;從 IO 線程主函數邏輯可以看到：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;如果 IO 線程等待處理任務數量為 0，則 IO 線程一直在空循環，因此後面主線程給 IO 線程分發任務後，需要設置 IO 線程待處理任務數&lt;strong&gt;&amp;nbsp;io_threads_pending[id]&amp;nbsp;&lt;/strong&gt;，才會觸發 IO 線程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果 IO 線程等待處理任務數量為 0，並且未獲取到 mutex 鎖，則會等待獲取鎖，暫停運行，由於主線程在創建 IO 線程之前先獲取了鎖，因此 IO 線程剛啓動時是暫停運行狀態，需要等待主線程釋放鎖，啓動 IO 線程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 線程待處理任務數為 0 時，獲取到鎖並再次釋放鎖，是為了讓主線程可以暫停 IO 線程。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;只有 io_threads_pending[id]不為 0 時，則繼續向下執行操作，根據 io_threads_op 決定是讀客戶端還是寫客戶端，從這裏也可以看出 IO 線程要麼&lt;strong&gt;同時讀&lt;/strong&gt;，要麼&lt;strong&gt;同時寫&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h2_7"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;讀數據流程&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;主線程將待讀數據客戶端加入隊列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;當客戶端連接有讀事件時，會觸發調用 readQueryFromClient 函數，在該函數中會調用 postponeClientRead。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;readQueryFromClient(connection *conn) {
&amp;nbsp; &amp;nbsp; client *c = connGetPrivateData(conn);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;nread, readlen;
&amp;nbsp; &amp;nbsp; size_t qblen;
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Check if we want to read from the client later when exiting from
&amp;nbsp; &amp;nbsp; &amp;nbsp;* the event loop. This is the case if threaded I/O is enabled. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(postponeClientRead(c))&amp;nbsp;return;
&amp;nbsp; &amp;nbsp; ......以下省略
}


/* Return 1 if we want to handle the client read later using threaded I/O.
&amp;nbsp;* This is called by the readable handler of the event loop.
&amp;nbsp;* As a side effect of calling this function the client is put in the
&amp;nbsp;* pending read clients and flagged as such. */
int&amp;nbsp;postponeClientRead(client *c) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_active &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; server.io_threads_do_reads &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !ProcessingEventsWhileBlocked &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !(c-&amp;gt;flags &amp;amp; (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_READ;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; listAddNodeHead(server.clients_pending_read,c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;如果開啓多線程，並且開啓多線程讀（io_threads_do_reads 為 yes），則將客戶端標記為 CLIENT_PENDING_READ，並且加入 clients_pending_read 列表。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;然後 readQueryFromClient 函數中就立即返回，主線程沒有執行從客戶端連接中讀取的數據相關邏輯，讀取了客戶端數據行為等待後續各個 IO 線程執行。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;主線程分發並阻塞等待&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;主線程在 beforeSleep 函數中會調用 handleClientsWithPendingReadsUsingThreads 函數。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;/* When threaded I/O is also enabled for the reading + parsing side, the
&amp;nbsp;* readable handler will just put normal clients into a queue of clients to
&amp;nbsp;* process (instead of serving them synchronously). This function runs
&amp;nbsp;* the queue using the I/O threads, and process them in order to accumulate
&amp;nbsp;* the reads in the buffers, and also parse the first command available
&amp;nbsp;* rendering it in the client structures. */
int&amp;nbsp;handleClientsWithPendingReadsUsingThreads(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!io_threads_active || !server.io_threads_do_reads)&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;processed =&amp;nbsp;listLength(server.clients_pending_read);
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processed ==&amp;nbsp;0)&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("%d TOTAL READ pending clients\n", processed);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Distribute the clients across N different lists. */
&amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_read,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;item_id =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;target_id = item_id % server.io_threads_num;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeTail(io_threads_list[target_id],c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; item_id++;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the start condition to the waiting threads, by setting the
&amp;nbsp; &amp;nbsp; &amp;nbsp;* start condition atomic var. */
&amp;nbsp; &amp;nbsp; io_threads_op = IO_THREADS_OP_READ;
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;count =&amp;nbsp;listLength(io_threads_list[j]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[j] = count;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Also use the main thread to process a slice of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[0],&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;readQueryFromClient(c-&amp;gt;conn);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[0]);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for all the other threads to end their work. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;unsigned&amp;nbsp;long&amp;nbsp;pending =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending += io_threads_pending[j];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending ==&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("I/O READ All threads finshed\n");
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Run the list of clients again to process the new buffers. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(listLength(server.clients_pending_read)) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ln =&amp;nbsp;listFirst(server.clients_pending_read);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_READ;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listDelNode(server.clients_pending_read,ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(c-&amp;gt;flags &amp;amp; CLIENT_PENDING_COMMAND) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_COMMAND;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processCommandAndResetClient(c) == C_ERR) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* If the client is no longer valid, we avoid
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* processing the client later. So we just go
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* to the next. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;continue;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;processInputBuffer(c);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;processed;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;先檢查是否開啓多線程，以及是否開啓多線程讀數據（io_threads_do_reads），未開啓直接返回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;檢查隊列 clients_pending_read 長度，為 0 直接返回，説明沒有待讀事件。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;遍歷 clients_pending_read 隊列，通過 RR 算法，將隊列中的客戶端循環分配給各個 IO 線程，包括主線程本身。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;設置 io_threads_op = IO_THREADS_OP_READ，並且將 io_threads_pending 數組中各個位置值設置為對應各個 IO 線程分配到的客戶端數量，如上面介紹，目的是為了使 IO 線程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程開始讀取客戶端數據，因為主線程也分配了任務。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程阻塞等待，直到所有的 IO 線程都完成讀數據工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程執行命令。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;IO 線程讀數據&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 IO 線程主函數中，如果&lt;strong&gt;&amp;nbsp;io_threads_op == IO_THREADS_OP_READ&amp;nbsp;，&lt;/strong&gt;則調用 readQueryFromClient 從網絡中讀取數據。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;&lt;strong&gt;IO 線程讀取數據後，不會執行命令。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 readQueryFromClient 函數中，最後會執行 processInputBuffer 函數，在 processInputBuffe 函數中，如 IO 線程檢查到客戶端設置了 CLIENT_PENDING_READ 標誌，則不執行命令，直接返回。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ......省略
/* If we are in the context of an I/O thread, we can't really
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* execute the command here. All we can do is to flag the client
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* as one that needs to process the command. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(c-&amp;gt;flags &amp;amp;&amp;nbsp;CLIENT_PENDING_READ) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_COMMAND;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ...... 省略&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_8"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;寫數據流程&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;命令處理完成後，依次調用：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;addReply--&amp;gt;prepareClientToWrite--&amp;gt;clientInstallWriteHandler，將待寫客戶端加入隊列 clients_pending_write。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;clientInstallWriteHandler(client *c) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Schedule the client to write the output buffers to the socket only
&amp;nbsp; &amp;nbsp; &amp;nbsp;* if not already done and, for slaves, if the slave can actually receive
&amp;nbsp; &amp;nbsp; &amp;nbsp;* writes at this stage. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!(c-&amp;gt;flags &amp;amp;&amp;nbsp;CLIENT_PENDING_WRITE) &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (c-&amp;gt;replstate ==&amp;nbsp;REPL_STATE_NONE&amp;nbsp;||
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;(c-&amp;gt;replstate ==&amp;nbsp;SLAVE_STATE_ONLINE&amp;nbsp;&amp;amp;&amp;amp; !c-&amp;gt;repl_put_online_on_ack)))
&amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Here instead of installing the write handler, we just flag the
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* client and put it into a list of clients that have something
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* to write to the socket. This way before re-entering the event
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* loop, we can try to directly write to the client sockets avoiding
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* a system call. We'll only really install the write handler if
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* we'll not be able to write the whole reply at once. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags |=&amp;nbsp;CLIENT_PENDING_WRITE;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeHead(server.clients_pending_write,c);
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在 beforeSleep 函數中調用 handleClientsWithPendingWritesUsingThreads。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;int&amp;nbsp;handleClientsWithPendingWritesUsingThreads(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;processed =&amp;nbsp;listLength(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(processed ==&amp;nbsp;0)&amp;nbsp;return&amp;nbsp;0;&amp;nbsp;/* Return ASAP if there are no clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* If I/O threads are disabled or we have few clients to serve, don't
&amp;nbsp; &amp;nbsp; &amp;nbsp;* use I/O threads, but thejboring synchronous code. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1&amp;nbsp;||&amp;nbsp;stopThreadedIOIfNeeded()) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;handleClientsWithPendingWrites();
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Start threads if needed. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(!io_threads_active)&amp;nbsp;startThreadedIO();
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("%d TOTAL WRITE pending clients\n", processed);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Distribute the clients across N different lists. */
&amp;nbsp; &amp;nbsp; listIter li;
&amp;nbsp; &amp;nbsp; listNode *ln;
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_write,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;item_id =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; c-&amp;gt;flags &amp;amp;= ~CLIENT_PENDING_WRITE;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;target_id = item_id % server.io_threads_num;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;listAddNodeTail(io_threads_list[target_id],c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; item_id++;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Give the start condition to the waiting threads, by setting the
&amp;nbsp; &amp;nbsp; &amp;nbsp;* start condition atomic var. */
&amp;nbsp; &amp;nbsp; io_threads_op = IO_THREADS_OP_WRITE;
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;count =&amp;nbsp;listLength(io_threads_list[j]);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; io_threads_pending[j] = count;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Also use the main thread to process a slice of clients. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(io_threads_list[0],&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;writeToClient(c,0);
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(io_threads_list[0]);
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Wait for all the other threads to end their work. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;while(1) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;unsigned&amp;nbsp;long&amp;nbsp;pending =&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int&amp;nbsp;j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending += io_threads_pending[j];
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending ==&amp;nbsp;0)&amp;nbsp;break;
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(tio_debug)&amp;nbsp;printf("I/O WRITE All threads finshed\n");
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Run the list of clients again to install the write handler where
&amp;nbsp; &amp;nbsp; &amp;nbsp;* needed. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;listRewind(server.clients_pending_write,&amp;amp;li);
&amp;nbsp; &amp;nbsp;&amp;nbsp;while((ln =&amp;nbsp;listNext(&amp;amp;li))) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; client *c =&amp;nbsp;listNodeValue(ln);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;/* Install the write handler if there are pending writes in some
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;* of the clients. */
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(clientHasPendingReplies(c) &amp;amp;&amp;amp;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;connSetWriteHandler(c-&amp;gt;conn, sendReplyToClient) == AE_ERR)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;freeClientAsync(c);
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp; }
&amp;nbsp; &amp;nbsp;&amp;nbsp;listEmpty(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;processed;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;判斷 clients_pending_write 隊列的長度，如果為 0 則直接返回。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;判斷是否開啓了多線程，若只有很少的客戶端需要寫，則不使用多線程 IO，直接在主線程完成寫操作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;如果使用多線程 IO 來完成寫數據，則需要判斷是否先開啓多線程 IO（因為會動態開啓與暫停）。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;遍歷 clients_pending_write 隊列，通過 RR 算法，循環將所有客戶端分配給各個 IO 線程，包括主線程自身。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;設置 io_threads_op = IO_THREADS_OP_WRITE，並且將 io_threads_pending 數組中各個位置值設置為對應的各個 IO 線程分配到的客戶端數量，目的是為了使 IO 線程工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;主線程開始寫客戶端數據，因為主線程也分配了任務，寫完清空任務隊列。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;阻塞等待，直到所有 IO 線程完成寫數據工作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;再次遍歷所有客戶端，如果有需要，為客戶端在事件循環上安裝寫句柄函數，等待事件回調。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;多線程 IO 動態暫停與開啓&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;從上面的寫數據的流程中可以看到，在 Redis 運行過程中多線程 IO 是會動態暫停與開啓的。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在上面的寫數據流程中，先調用 stopThreadedIOIfNeeded 函數判斷是否需要暫停多線程 IO，&lt;strong&gt;當等待寫的客戶端數量低於線程數的 2 倍時，會暫停多線程 IO，&lt;/strong&gt;否則就會打開多線程。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;int&amp;nbsp;stopThreadedIOIfNeeded(void)&amp;nbsp;{
&amp;nbsp; &amp;nbsp;&amp;nbsp;int&amp;nbsp;pending = listLength(server.clients_pending_write);
&amp;nbsp; &amp;nbsp;&amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* Return ASAP if IO threads are disabled (single threaded mode). */
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(server.io_threads_num ==&amp;nbsp;1)&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp;
&amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(pending &amp;lt; (server.io_threads_num*2)) {
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;if&amp;nbsp;(io_threads_active) stopThreadedIO();
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;1;
&amp;nbsp; &amp;nbsp; }&amp;nbsp;else&amp;nbsp;{
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;return&amp;nbsp;0;
&amp;nbsp; &amp;nbsp; }
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;在寫數據流程 handleClientsWithPendingWritesUsingThreads 函數中，stopThreadedIOIfNeeded 返回 0 的話，就會執行下面的 startThreadedIO 函數，開啓多線程 IO。&lt;/span&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;void&amp;nbsp;startThreadedIO(void) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(server.io_threads_active&amp;nbsp;==&amp;nbsp;0);
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_unlock(&amp;amp;io_threads_mutex[j]);
&amp;nbsp; &amp;nbsp; server.io_threads_active&amp;nbsp;=&amp;nbsp;1;
}


void&amp;nbsp;stopThreadedIO(void) {
&amp;nbsp; &amp;nbsp;&amp;nbsp;/* We may have still clients with pending reads when this function
&amp;nbsp; &amp;nbsp; &amp;nbsp;* is called: handle them before stopping the threads. */
&amp;nbsp; &amp;nbsp;&amp;nbsp;handleClientsWithPendingReadsUsingThreads();
&amp;nbsp; &amp;nbsp;&amp;nbsp;serverAssert(server.io_threads_active&amp;nbsp;==&amp;nbsp;1);
&amp;nbsp; &amp;nbsp;&amp;nbsp;for&amp;nbsp;(int j =&amp;nbsp;1; j &amp;lt; server.io_threads_num; j++)
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;pthread_mutex_lock(&amp;amp;io_threads_mutex[j]);
&amp;nbsp; &amp;nbsp; server.io_threads_active&amp;nbsp;=&amp;nbsp;0;
}&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;從上面的代碼中可以看出：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;開啓多線程 IO 是通過釋放 mutex 鎖來讓 IO 線程開始執行讀數據或者寫數據動作。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;暫停多線程 IO 則是通過加鎖來讓 IO 線程暫時不執行讀數據或者寫數據動作，此處加鎖後，IO 線程主函數由於無法獲取到鎖，因此會暫時阻塞。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;span id="OSC_h1_10"&gt;&lt;/span&gt; 
&lt;h1&gt;四、性能對比&lt;/h1&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;測試環境&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;兩台物理機配置：CentOS Linux release 7.3.1611(Core) ，12 核 CPU1.5GHz，256G 內存（free 128G）。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_12"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;Redis 版本&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用 Redis6.0.6，多線程 IO 模式使用線程數量為 4，即&lt;strong&gt;&amp;nbsp;io-threads 4&amp;nbsp;&lt;/strong&gt;，參數&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;分別設置為&lt;strong&gt;&amp;nbsp;no&amp;nbsp;&lt;/strong&gt;和&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;，進行對比測試。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h2_13"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;壓測命令&lt;/span&gt;&lt;/h2&gt; 
&lt;pre&gt;&lt;code class="language-auto"&gt;redis-benchmark -h 172.xx.xx.xx -t set,get -n 1000000 -r 100000000 --threads ${threadsize} -d ${datasize} -c ${clientsize}


單線程 threadsize 為 1，多線程 threadsize 為 4
datasize 為 value 大小，分別設置為 128/512/1024
clientsize 為客戶端數量，分別設置為 256/2000
如：./redis-benchmark -h 172.xx.xx.xx -t set,get -n 1000000 -r 100000000 --threads 4 -d 1024 -c 256&lt;/code&gt;&lt;/pre&gt; 
&lt;span id="OSC_h2_14"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;統計結果&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;當&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;為&lt;strong&gt;&amp;nbsp;no&amp;nbsp;&lt;/strong&gt;時，統計圖表如下所示（c 2000 表示客戶端數量為 2000）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="300" src="https://oscimg.oschina.net/oscnet/up-604470825e1668f75a0927b74d09cdd58e1.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;當&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;為&lt;strong&gt;&amp;nbsp;yes&amp;nbsp;&lt;/strong&gt;時，統計圖表如下所示（c 256 表示客戶端數量為 256）。&lt;/span&gt;&lt;/p&gt; 
&lt;div style="text-align:left"&gt; 
 &lt;img height="303" src="https://oscimg.oschina.net/oscnet/up-c53c725b46c9562ff0702a925aec3b10067.png" width="500" referrerpolicy="no-referrer"&gt; 
&lt;/div&gt; 
&lt;span id="OSC_h2_15"&gt;&lt;/span&gt; 
&lt;h2&gt;&lt;span style="color:#000000"&gt;結論&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;使用 redis-benchmark 做 Redis6 單線程和多線程簡單 SET/GET 命令性能測試：&lt;/span&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;從上面可以看到 GET/SET 命令在設置 4 個 IO 線程時，QPS 相比於大部分情況下的單線程，性能幾乎是翻倍了。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;連接數越多，多線程優勢越明顯。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;value 值越小，多線程優勢越明顯。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用多線程讀命令比寫命令優勢更加明顯，當 value 越大，寫命令越發沒有明顯的優勢。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;參數&lt;strong&gt;&amp;nbsp;io-threads-do-reads&amp;nbsp;&lt;/strong&gt;為 yes，性能有微弱的優勢，不是很明顯。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;總體來説，以上結果基本符合預期，結果僅作參考。&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h1_16"&gt;&lt;/span&gt; 
&lt;h1&gt;五、6.0 多線程 IO 不足&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;儘管引入多線程 IO 大幅提升了 Redis 性能，但是 Redis6.0 的多線程 IO 仍然存在一些不足：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;CPU 核心利用率不足：當前主線程仍負責大部分的 IO 相關任務，並且當主線程處理客戶端的命令時，IO 線程會空閒相當長的時間，同時值得注意的是，主線程在執行 IO 相關任務期間，性能受到最慢 IO 線程速度的限制。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;IO 線程執行的任務有限：目前，由於主線程同步等待 IO 線程，線程僅執行讀取解析和寫入操作。如果線程可以異步工作，我們可以將更多工作卸載到 IO 線程上，從而減少主線程的負載。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;不支持帶有 TLS 的 IO 線程。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;最新的 Valkey8.0 版本中，通過引入異步 IO 線程，將更多的工作轉移到 IO 線程執行，同時通過&lt;strong&gt;批量預讀取內存數據&lt;/strong&gt;減少內存訪問延遲，大幅提高 Valkey 單節點訪問 QPS，單個實例每秒可處理 100 萬個請求。我們後續再詳細介紹 Valkey8.0 異步 IO 特性。&lt;/span&gt;&lt;/p&gt; 
&lt;span id="OSC_h1_17"&gt;&lt;/span&gt; 
&lt;h1&gt;六、總結&lt;/h1&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 引入多線程 IO，但多線程部分只是用來處理網絡數據的讀寫和協議解析，&lt;strong&gt;執行命令仍然是單線程&lt;/strong&gt;。通過開啓多線程 IO，並設置合適的 CPU 數量，可以提升訪問請求一倍以上。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;Redis6.0 多線程 IO 仍然存在一些不足，沒有充分利用 CPU 核心，在最新的 Valkey8.0 版本中，引入異步 IO 將進一步大幅提升 Valkey 性能。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;往期回顧&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;1.&lt;/span&gt;得物社區活動：組件化的演進與實踐&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;2.&lt;/span&gt;從 CPU 冒煙到絲滑體驗：算法 SRE 性能優化實戰全揭祕｜得物技術&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;3.&lt;/span&gt;CSS 闖關指南：從手寫地獄到「類」積木之旅｜得物技術&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;4.&lt;/span&gt;以細節詮釋專業，用成長定義價值——對話@孟同學 ｜得物技術&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#586c90"&gt;5.&lt;/span&gt;大語言模型的訓練後量化算法綜述 | 得物技術&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;文 / 竹徑&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;關注得物技術，每週更新技術乾貨&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;要是覺得文章對你有幫助的話，歡迎評論轉發點贊～&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#3e3e3e"&gt;未經得物技術許可嚴禁轉載，否則依法追究法律責任。&lt;/span&gt;&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/u/5783135/blog/18628004</link>
      <guid isPermaLink="false">https://my.oschina.net/u/5783135/blog/18628004</guid>
      <pubDate>Sat, 10 May 2025 03:15:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>Firefox 140.0 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Firefox 140.0 現已發佈，具體更新內容如下：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;新的&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;垂直標籤頁：現在可以同時顯示更多或更少的固定標籤頁，以便更快地訪問重要窗口。只需拖動分隔線即可調整固定標籤頁部分的大小。&lt;/p&gt; &lt;p&gt;&lt;img height="345" src="https://oscimg.oschina.net/oscnet/up-5d6fd6370e9987a3a0c35f64f0956842275.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt;自定義搜索引擎：Firefox 現在支持添加更多搜索引擎。要添加自定義引擎，右鍵單擊受支持網站的搜索欄，然後選擇「添加搜索引擎」，或前往「設置」&amp;gt;「搜索」&amp;gt;「添加」（位於搜索快捷方式表格下方）手動輸入搜索 URL。&lt;/li&gt; 
 &lt;li&gt;Firefox 擴展程序：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.mozilla.org%2Fen-US%2Fkb%2Fcustomize-firefox-controls-buttons-and-toolbars" target="_blank"&gt;自定義工具欄&lt;/a&gt;，並可選擇移除擴展程序快捷方式，讓你更好地掌控瀏覽器。隱藏按鈕後，可以隨時通過點擊 Firefox 菜單中的「擴展程序」菜單項再次訪問擴展程序面板。&lt;/li&gt; 
 &lt;li&gt;現在可以通過右鍵單擊一個選項卡（或多個選定的選項卡）並選擇「Unload Tab」來卸載標籤頁。這可以減少 Firefox 的內存和 CPU 佔用，從而提高性能。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.mozilla.org%2Fkb%2Fwebsite-translation%23w_translate-the-full-page" target="_blank"&gt;整頁翻譯&lt;/a&gt;現在優先翻譯當前視圖附近的內容，從而提升速度和響應能力。除非滾動到視圖之外的內容，否則系統會跳過該內容，從而減少不必要的資源佔用。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.mozilla.org%2Fkb%2Fhow-do-i-use-firefox-spell-checker" target="_blank"&gt;阿拉伯語版本的 Firefox 現在為 Firefox 拼寫檢查器&lt;/a&gt;配備了內置阿拉伯語詞典。&lt;/li&gt; 
 &lt;li&gt;為意大利、波蘭和奧地利的用戶啓用&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.mozilla.org%2Fkb%2Fautomatically-fill-your-address-web-forms" target="_blank"&gt;地址自動填充功能。&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong style="color:#333333"&gt;Fixed&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;各種&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.mozilla.org%2Fsecurity%2Fadvisories%2Fmfsa2025-51" target="_blank"&gt;安全&lt;/a&gt;修復。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Changed&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblog.mozilla.org%2Fmozilla%2Fbuilding-whats-next%2F" target="_blank"&gt;根據服務關閉公告&lt;/a&gt;，Pocket 工具欄圖標以及新標籤頁上的 Pocket 集成已被刪除。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Enterprise&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsupport.mozilla.org%2Fkb%2Ffirefox-enterprise-140-release-notes" target="_blank"&gt;可以在 Firefox for Enterprise 140 發行説明&lt;/a&gt;中找到有關策略更新和企業特定錯誤修復的信息。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Developer&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;改進了 Inspector 面板中的搜索功能，幫助開發者更有效地搜索當前頁面的 DOM。支持按匹配元素數量對結果進行排序、支持「偽」選擇器狀態等。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;Web 平台&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;增加了對 Linux、macOS 和 Windows 中的&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fdocs%2FWeb%2FAccessibility%2FARIA%2FReference%2FAttributes%2Faria-keyshortcuts" target="_blank"&gt;aria-keyshortcuts&lt;/a&gt;平台支持。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fdocs%2FWeb%2FAPI%2FCookieStore" target="_blank"&gt;增加了對 CookieStore API&lt;/a&gt;&amp;nbsp;的支持，這是一種用於在 HTML 文檔和 service workers 中運行的腳本的異步 cookie API。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fdocs%2FWeb%2FAPI%2FCSS_Custom_Highlight_API" target="_blank"&gt;新增了對 Custom Highlight API&lt;/a&gt;&amp;nbsp;的支持，允許設置任意文本範圍的樣式。目前尚未包含對&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fdocs%2FWeb%2FCSS%2Ftext-decoration" target="_blank"&gt;文本裝飾&lt;/a&gt;的支持，計劃在即將發佈的版本中實現。&lt;/li&gt; 
 &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fdocs%2FWeb%2FAPI%2FElement%2Fpointerrawupdate_event" target="_blank"&gt;添加了對 pointerrawupdate&lt;/a&gt;&amp;nbsp;事件的支持。此事件在指針數據可用時立即觸發（通常在主&lt;code&gt;pointermove&lt;/code&gt;事件之前），從而提供對指針移動的低延遲訪問。與&lt;code&gt;pointermove&lt;/code&gt;不同，它會執行額外的命中測試來確定目標，並且觸發頻率更高，即使只添加了一個監聽器，也可能會影響性能。此事件適用於需要高精度輸入處理且無法僅使用&amp;nbsp;&lt;span style="color:#000000"&gt;coalesced&amp;nbsp;&lt;/span&gt;&lt;code&gt;pointermove&lt;/code&gt;事件實現流暢交互的應用程序。&lt;/li&gt; 
 &lt;li&gt;Service Worker 現已在隱私瀏覽模式下可用。&lt;/li&gt; 
 &lt;li&gt;Firefox 現在對&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;元素&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FReference%2FElements%2FHeading_Elements%23specifying_a_uniform_font_size_for_h1" target="_blank"&gt;應用統一的用戶代理 (UA) 樣式&lt;/a&gt;，無論它們是在&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;還是&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;內使用。&lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;Firefox 現在將在序列化 HTML 屬性時轉義小於 (&lt;code&gt;&amp;lt;&lt;/code&gt;) 和大於 (&lt;code&gt;&amp;gt;&lt;/code&gt;) 符號，從而使針對網站的某些 mXSS 攻擊更加困難。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;未解決&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;使用某些深色主題的用戶可能會遇到側邊欄文本對比度問題。一種解決方法是使用內置深色主題或系統主題。此問題已在&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fbugzilla.mozilla.org%2Fshow_bug.cgi%3Fid%3D1971487" target="_blank"&gt;Bug 1971487&lt;/a&gt;&lt;br&gt; 中記錄，並將在後續版本中修復。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;更新説明：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.mozilla.org%2Fen-US%2Ffirefox%2F140.0%2Freleasenotes%2F" target="_blank"&gt;https://www.mozilla.org/en-US/firefox/140.0/releasenotes/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357139/firefox-140-0-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357139/firefox-140-0-released</guid>
      <pubDate>Sat, 10 May 2025 02:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Ubuntu 默認主題的「回收站」應用圖標將更新</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Ubuntu 貢獻者&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fubuntu%2Fyaru%2Fissues%2F1170" target="_blank"&gt;目前正在構思&lt;/a&gt;一個新的垃圾桶圖標，該圖標最早可能在 10 月份 Ubuntu 25.10 發佈時出現在 Dock 欄中。&lt;/p&gt; 
&lt;p&gt;關於 Ubuntu 垃圾桶圖標外觀的討論在 2019 年持續進行，直到同年 3 月結束。今年 5 月，該討論再次重啓，並定期更新圖標建議。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5b02880cb80a289c29cbfec182c0689f9b6.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;現有垃圾桶圖標的主要缺陷在於，沒有回收圖標，它看起來更像一個信箱，而不是一個垃圾桶。當垃圾桶裏有文件時，裏面的文件看起來相當整齊，就像信件一樣，這更讓人覺得它是一個郵箱，而不是垃圾桶。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-cd86113e7df0a39fd3981f4d372b785a065.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;垃圾桶圖標位於左側 Dock 底部，看起來像一個信箱&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;目前建議的設計方案是頂部完全打開，以便更清楚地顯示它是一個垃圾桶；當裏面有文件時，會顯示皺巴巴的紙張。設計師 ochi12 發佈了多個圖標版本，並將它們設置為不同的尺寸，以測試在不同用例下的效果。最新版本的圖標在縮小尺寸後似乎依然能夠正常顯示。&lt;/p&gt; 
&lt;p&gt;目前，設計師仍在聽取其他貢獻者的反饋，因此，即使最終達成一致，目前做出的修改也不太可能最終在 Ubuntu 中實現。這一點也很重要，因為這些修改可能永遠不會被達成一致，我們也就可能永遠看不到它們真正實現。&lt;/p&gt; 
&lt;p&gt;值得注意的是，一些評論者表示他們喜歡現有的垃圾桶圖標，希望它不要改變，這體現了垃圾桶圖標本身的主觀性。希望我們能夠就設計達成共識，以便 Ubuntu 用戶在升級到即將發佈的 Ubuntu 版本時能夠獲得更新鮮的體驗。&lt;/p&gt; 
&lt;p&gt;距離 10 月份 Ubuntu 25.10 發佈還有很長一段時間，所以我們到那時就可以看到新的圖標，但如果沒有，也許我們會在 Ubuntu 26.04 LTS 中看到它。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357137</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357137</guid>
      <pubDate>Sat, 10 May 2025 02:40:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Electron 37.0.0 發佈，跨平台桌面應用開發工具</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Electron 是一個使用 JavaScript、HTML 和 CSS 構建跨平台的桌面應用程序。它基於 Node.js 和 Chromium，被 Atom 編輯器和許多其他應用程序使用。Electron 兼容 Mac、Windows 和 Linux，可以構建出三個平台的應用程序。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;Electron v37.0.0 現已發佈，一些更新內容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p style="text-align:start"&gt;&lt;strong&gt;Stack Upgrades&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Chromium&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;138.0.7204.35&lt;/code&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fnew-in-chrome-138%2F" target="_blank"&gt;New in 138&lt;/a&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeveloper.chrome.com%2Fblog%2Fnew-in-chrome-137%2F" target="_blank"&gt;New in 137&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;Node&lt;code&gt;22.16.0&lt;/code&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv22.16.0%2F" target="_blank"&gt;Node 22.16.0 blog post&lt;/a&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;V8&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;13.8&lt;/code&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Breaking Changes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;增加了對 Web Serial &amp;amp; WebUSB blocklists 的支持。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F46600" target="_blank"&gt;#46600&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復了實用程序進程因未處理的拒絕而崩潰的問題。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F45921" target="_blank"&gt;#45921&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;修復了在調用 process.exit 後運行用戶腳本的 utilityProcess 問題。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F47492" target="_blank"&gt;#47492&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;刪除了通過將&lt;code&gt;ProtocolResponse.session&lt;/code&gt;的屬性設置為&lt;code&gt;null&lt;/code&gt;來創建新隨機會話的棄用功能。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F46264" target="_blank"&gt;#46264&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;改進&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;改進了 Windows 上的 ASAR 完整性檢查。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F46509" target="_blank"&gt;#46509&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;改進了 macOS 上不請求縮略圖時 deskCapturer.getSources 的性能。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F46138" target="_blank"&gt;#46138&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;已移除/棄用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;棄用&lt;code&gt;NativeImage.getBitmap()&lt;/code&gt;並修復了不正確的文檔。&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Fpull%2F46696" target="_blank"&gt;#46696&amp;nbsp;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="text-align:start"&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;34.xy 支持終止&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.electronjs.org%2Fdocs%2Flatest%2Ftutorial%2Felectron-timelines%23version-support-policy" target="_blank"&gt;根據項目支持政策&lt;/a&gt;， Electron 34.xy 已終止支持。鼓勵開發者和應用程序升級到較新版本的 Electron。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;更多詳情可查看更新説明：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Felectron%2Felectron%2Freleases%2Ftag%2Fv37.0.0" target="_blank"&gt;https://github.com/electron/electron/releases/tag/v37.0.0&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357136/electron-37-0-0-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357136/electron-37-0-0-released</guid>
      <pubDate>Sat, 10 May 2025 02:39:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>開源 AI 助手平台 Cherry Studio 企業版開啓公測</title>
      <description>&lt;div class="content"&gt;
                                                                    
                                                        &lt;p&gt;Cherry Studio &lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FFHtJqZlULDhRw7fT1ALagA" target="_blank"&gt;宣佈&lt;/a&gt;其企業版已開始公測，這是專為企業打造的私有化 AI 生產力平台。&lt;/p&gt; 
&lt;p style="color:#1f2329; margin-left:0; margin-right:0; text-align:start"&gt;&lt;span style="color:#1f2329"&gt;&lt;span&gt;下表展示了兩個版本之間的定位與功能差異：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;table cellspacing="0" style="-webkit-tap-highlight-color:transparent; -webkit-text-stroke-width:0px; background-color:#ffffff; border-collapse:collapse; border-color:#dee0e3; box-sizing:border-box !important; color:rgba(0, 0, 0, 0.9); display:table; font-family:&amp;quot;PingFang SC&amp;quot;,system-ui,-apple-system,&amp;quot;system-ui&amp;quot;,&amp;quot;Helvetica Neue&amp;quot;,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei UI&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,Arial,sans-serif; font-size:15px; font-style:normal; font-variant-caps:normal; font-variant-ligatures:normal; font-weight:400; letter-spacing:0.544px; margin:0px 0px 10px; max-width:626px !important; min-width:297px; orphans:2; outline:0px; overflow-wrap:break-word !important; padding:0px; text-align:justify; text-decoration-color:initial; text-decoration-style:initial; text-decoration-thickness:initial; text-transform:none; white-space:normal; widows:2; width:626px; word-spacing:0px"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;對比維度&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;社區版 （Community）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;企業版 （Enterprise）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目標用戶&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;個人開發者、AI 愛好者&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中小型企業、大型企業內部團隊、對數據安全有高要求的組織&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;開源策略&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;✅ Github 開源&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;⭕️ 針對夥伴客戶端源碼開放&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;商業模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;個人免費 / 商用授權&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;買斷+可選服務費&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心差異&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;專注於個人生產力&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;企業集中管理能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;部署方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;客戶端應用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;客戶端 + 服務端私有化部署&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心價值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;強大的個人 AI 輔助工具&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
   &lt;td style="border-color:#cccccc; border-style:solid; border-width:1px; white-space:normal"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;安全、可控、高效的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.cherry-ai.com%2Fenterprise" target="_blank"&gt;https://www.cherry-ai.com/enterprise&lt;/a&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;點擊查看企業版體驗手冊：&lt;/p&gt; 
 &lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;https://doc.weixin.qq.com/doc/w3_ASIAPQaBALgCNdQv1pcxUTJGhXLsX?scode=APkA7AeJABIVWchL1vASIAPQaBALg&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:rgba(0, 0, 0, 0.9); margin-left:0; margin-right:0; text-align:justify"&gt;Cherry Studio 是一款支持多個大語言模型（LLM）服務商的開源桌面客戶端，兼容 Windows、Mac 和 Linux 系統。&lt;/p&gt; 
&lt;p style="color:#333333; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-23dab8c50bfcc8126ab84229b00dbc2115c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/357134</link>
      <guid isPermaLink="false">https://www.oschina.net/news/357134</guid>
      <pubDate>Sat, 10 May 2025 02:22:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
  </channel>
</rss>
