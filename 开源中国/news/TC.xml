<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>oschina - news - 繁體中文（台灣）</title>
    <link>https://www.oschina.net/news/project</link>
    <atom:link href="http://127.0.0.1:30044/oschina/news" rel="self" type="application/rss+xml"/>
    <description>已對該 RSS 進行格式化操作：中英字符之間插入空格、使用直角引號、標點符號修正</description>
    <generator>RSSHub</generator>
    <webMaster>contact@rsshub.app (RSSHub)</webMaster>
    <language>zh-tw</language>
    <lastBuildDate>Thu, 12 Jun 2025 07:44:39 GMT</lastBuildDate>
    <ttl>5</ttl>
    <item>
      <title>DBeaver 25.1 發佈</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;span style="color:#000000"&gt;DBeaver 是一個免費開源的通用數據庫工具，適用於開發人員和數據庫管理員。DBeaver 25.1 已發佈，更新內容如下：&lt;/span&gt;&lt;/p&gt; 
&lt;p style="margin-left:0; margin-right:0; text-align:start"&gt;&lt;span style="color:#000000"&gt;自 25.0.5 以來的變化如下：&lt;/span&gt;&lt;/p&gt; 
&lt;ul style="margin-left:0; margin-right:1.5em"&gt; 
 &lt;li&gt;&lt;span style="color:#333333"&gt;SQL Editor&lt;/span&gt;&lt;span style="color:#000000"&gt;：&lt;/span&gt; 
  &lt;ul style="margin-left:0; margin-right:0"&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;如果 referenced table 有別名，則現在總是將其放在列名之前以實現語義補全&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;添加了新的語義補全設置來控制完全限定的列名&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;修復了大字體的綁定變量對話框佈局&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Data Transfer：刪除了「All but nulls」選項，並添加了「All including nulls」選項，用於 CSV 導出&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Miscellaneous：&lt;/span&gt; 
  &lt;ul style="margin-left:0; margin-right:0"&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;修復了 macOS 的「Bind Parameters」對話框中編輯器窗口未對齊的問題&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;修復了「Tip of the Day」窗口可能阻止應用程序界面加載的問題&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;修復了測試和生產連接類型的連接顏色應用不一致的問題&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;修復了 CLI 模式下的應用程序啓動問題&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;General：「All file types」選項已移至文件打開對話框的頂部，以便於訪問&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;Databases：&lt;/span&gt; 
  &lt;ul style="margin-left:0; margin-right:0"&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;Clickhouse：&lt;/span&gt; 
    &lt;ul style="margin-left:0; margin-right:0"&gt; 
     &lt;li&gt;&lt;span style="color:#000000"&gt;Clickhouse 驅動程序已恢復至 0.8.5 版本&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span style="color:#000000"&gt;修復嵌套數組值的引用&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;CUBRID：修復信息面板可見性&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;DuckDB：&lt;/span&gt; 
    &lt;ul style="margin-left:0; margin-right:0"&gt; 
     &lt;li&gt;&lt;span style="color:#000000"&gt;添加了隱藏系統對象的選項&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span style="color:#000000"&gt;修復了 DuckDB 版本 1.2.2+ 中的幾何顯示問題&lt;/span&gt;&lt;/li&gt; 
     &lt;li&gt;&lt;span style="color:#000000"&gt;Simple structure compare wizard 已修復&lt;/span&gt;&lt;/li&gt; 
    &lt;/ul&gt; &lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;MySQL：修復了主鍵列創建問題&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;PostgreSQL：在數據網格中的 ILIKE 過濾器中添加了對通配符的支持&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;SQL Server：修復了會話管理器中的「Only connections」選項，以便按預期僅顯示活動連接會話&lt;/span&gt;&lt;/li&gt; 
   &lt;li&gt;&lt;span style="color:#000000"&gt;Teradata：native date/time formatting 現在默認禁用，可以在連接設置中啓用&lt;/span&gt;&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;更新説明&lt;/span&gt;：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdbeaver.io%2F2025%2F06%2F01%2Fdbeaver-25-1%2F" target="_blank"&gt;https://dbeaver.io/2025/06/01/dbeaver-25-1/&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355024/dbeaver-25-1-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355024/dbeaver-25-1-released</guid>
      <pubDate>Thu, 12 Jun 2025 07:37:22 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Rufus 4.8 發佈，提升打開 Windows ISO 時的鏡像分析速度</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;Rufus 4.8 已發佈，主要變化：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;切換到 wimlib 進行所有 WIM 鏡像處理： 
  &lt;ul&gt; 
   &lt;li&gt;極大提升打開 Windows ISO 時的鏡像分析速度&lt;/li&gt; 
   &lt;li&gt;可以加快 Windows To Go 驅動器的創建（但如果你的驅動器很糟糕，效果不會太好）&lt;/li&gt; 
   &lt;li&gt;可能有助於解決 Mac 上 Parallels 的限制（但 Rufus 在 Parallels 上仍不受支持）&lt;/li&gt; 
   &lt;li&gt;啓用使用&amp;nbsp;Alt&amp;nbsp;-&amp;nbsp;E&amp;nbsp;分割大於 4GB 的文件（但使用 UEFI:NTFS 仍然慢得多）&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt;由於 MinGW DLL 延遲加載限制，切換到在所有地方使用 Visual Studio 二進制文件&lt;/li&gt; 
 &lt;li&gt;為限制自身僅在 DD 模式下運行的 Linux ISO 添加更多例外（Nobara、openSUSE、...）&lt;/li&gt; 
 &lt;li&gt;改進 UEFI 啓動加載器的日誌報告，包含安全啓動狀態信息&lt;/li&gt; 
 &lt;li&gt;修復將未壓縮的 VHD 寫回同一驅動器時的大小限制問題&lt;/li&gt; 
 &lt;li&gt;修復使用 32 位 MinGW 編譯版本打開日誌時崩潰的問題&lt;/li&gt; 
 &lt;li&gt;修復命令行參數未傳遞給原始 Windows&amp;nbsp;&lt;code&gt;setup.exe&lt;/code&gt;&amp;nbsp;的問題&lt;/li&gt; 
&lt;/ul&gt; 
&lt;hr&gt; 
&lt;p&gt;Rufus 是一款格式化和創建 USB 啓動盤的輔助工具，適用於以下場景：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;需要將可引導 ISO (Windows、Linux、UEFI 等) 刻錄到 USB 安裝媒介的情況&lt;/li&gt; 
 &lt;li&gt;需要處理未安裝操作系統的設備的情況&lt;/li&gt; 
 &lt;li&gt;需要在 DOS 環境下刷寫 BIOS 或其他固件的情況&lt;/li&gt; 
 &lt;li&gt;需要運行低級工具的情況&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-5f864e3279a92c2e1e0b56f1b4d9aa7e2fd.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;下載地址：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fpbatard%2Frufus%2Freleases%2Ftag%2Fv4.8" target="_blank"&gt;https://github.com/pbatard/rufus/releases/tag/v4.8&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355017/rufus-4-8</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355017/rufus-4-8</guid>
      <pubDate>Thu, 12 Jun 2025 07:20:22 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>vivo Pulsar 萬億級消息處理實踐（1）- 數據發送原理解析和性能調優</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;blockquote&gt; 
 &lt;p&gt;作者：vivo 互聯網大數據團隊- Quan Limin&lt;/p&gt; 
 &lt;p&gt;本文是 vivo 互聯網大數據團隊《vivo Pulsar 萬億級消息處理實踐》系列文章第 1 篇。&lt;/p&gt; 
 &lt;p&gt;文章以 Pulsar client 模塊中的 Producer 為解析對象，通過對 Producer 數據發送原理進行逐層分析，以及分享參數調優實戰案例，幫助讀者理解與使用好 Producer，並體會到 Producer 對消息中間件系統穩定性以及處理性能所起到的關鍵作用。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h1&gt;一、Pulsar 簡要介紹&lt;/h1&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/fb/fbcab3bc275f1a6943f142e8a110d07c.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar 是新一代的雲原生消息中間件，由 Apache 軟件基金會孵化和開源。它的設計目的是為了滿足現代數據處理和計算應用程序對可擴展性、可靠性和高性能的需求，具備存儲與計算分離、節點對等、獨立擴展、實時均衡、節點故障快速恢復等特性。&lt;/p&gt; 
&lt;p&gt;Pulsar 由四個核心模塊組成：broker、bookKeeper 和 client（Producer 和 Consumer）、zk（元數據管理和節點協調）。broker 接受來自 Producer 的消息，將消息路由到對應的 topic；bookKeeper 用於數據持久化存儲和數據複製；Consumer 消費 topic 上的數據。Pulsar 支持多種編程語言和協議（如 Java、C++、Go、Python 等），可以運行在雲、本地和混合環境中，擴展性好，支持多租戶和跨數據中心複製等特性。因此，Pulsar 被廣泛應用於雲計算、大數據、物聯網等領域的實時消息傳遞和處理應用中。&lt;/p&gt; 
&lt;h1&gt;二、Pulsar Producer 解析&lt;/h1&gt; 
&lt;p&gt;首先需要了解 Producer 的數據發送流程，這裏以「開啓壓縮、batch 發送消息給 partitioned topic「這樣的一個線上常規場景為例，解析數據的發送的關鍵環節。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;tips：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 Pulsar 中有無分區（Non-Partitioned）Topic 和有分區 (Partitioned) 的 Topic 之分，Partitioned topic 最小分區數為 1，為滿足任務的拓展性，在線上一般使用 Partitioned topic。&lt;/p&gt; 
&lt;h2&gt;2.1 消息生產與發送的詳細流程&lt;/h2&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/66/6663c40abe8c2e1562b1ef8e8393a55d.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Producer 發送數據主要分為&lt;strong&gt;12 個步驟：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;① 創建 Producer：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;partitioned topic 創建的是一個 Partitioned-&lt;/p&gt; 
&lt;p&gt;ProducerImpl 對象，該對象包含了所有分區及其對應的 ProducerImpl 對象，ProducerImpl 對象負責所對應分區數據的維護和發送。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;② 構造消息：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;一條消息被髮送前首先會被封裝成為一個 Message 對象，對象中包含了所發送的 topic name、消息體、消息大小、schema 類型、metadata（是否指定 key 等）等信息。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;③ 確定目標分區：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在發送消息前需要通過路由策略決定發往哪一個分區，選擇對應分區的 ProducerImpl 對象進行進一步處理。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;④ 攔截器：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Producer 可以設置自定義的攔截器，攔截器需要實現 producerInterceptor 接口，在消息發送前可對消息進行攔截修改。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑤ 消息堆積控制：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Producer 可以處理的消息是有限的，接收新的消息時會分別進行信號量和內存使用率校驗，控制接收消息的速率，防止消息無限在本地堆積。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑥ batch 容器管理：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;默認情況下分好區的消息不是直接被髮送，而是放入了生產者的一個 batch 緩存容器中裏面。在這個緩存裏面，多條消息會被封裝成為一個批次（batch）。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑦ 消息序列化：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;Pulsar 的消息需要從客戶端傳到服務端，涉及到網絡傳輸，因此 Producer 將 batch 緩衝區中的所有消息逐一進行序列化。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑧ 壓縮：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar 內置了多種壓縮算法，在發送前會根據所選擇的壓縮算法對 batch 整體進行壓縮，這將優化網絡傳輸以提高 Pulsar 消息傳輸的性能。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑨ 構建消息發送對象：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;無論是開啓 batch 的批次消息，還是關閉 batch 的單條消息，都會被包裝為一個 OpSendMsg 對象，OpSendMsg 也是 Producer 發送和 pulsar broker 接收處理的最小單位。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑩ pending 隊列：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;所有構建好的 OpSendMsg 在發送前都會被放入 pendingMessages 隊列中，消息處理完成後才會從隊列中移除。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑪&amp;nbsp;消息傳輸：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar 使用 netty 將消息異步的從客戶端發送到服務端，Broker 節點將在收到消息後對其進行確認，並將其存儲在指定主題的持久存儲中。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;⑫ 響應處理：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar Broker 在收到消息時會返回一個響應，如果寫入成功，消息將會從 pendingMessages 隊列中移除。如果寫入失敗，會返回一個錯誤，生產者在收到可重試錯誤之後會嘗試重新發送消息，直到重試成功或超時。&lt;/p&gt; 
&lt;h2&gt;2.2 關鍵環節原理分析&lt;/h2&gt; 
&lt;p&gt;接下來會對上述流程中關鍵環節的設計和原理作進一步的剖析，幫助讀者更好的理解 Producer。&lt;/p&gt; 
&lt;h3&gt;2.2.1 創建 Producer&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/e5/e52d9588e782f913a00d092f1cdd80f5.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在 Pulsar 中，PartitionedProducerImpl 用於將多個 ProducerImpl 對象包裝成為一個邏輯生產者，以便向 Partitioned Topic 發送消息時能夠批量操作。其中，PartitionedProducerImpl.producers 成員變量維護了每個分區及其對應的 ProducerImpl 對象，該設計主要有以下&lt;strong&gt;3 個好處：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;① 每個分區對應一個單獨的生產者：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 Pulsar 中，Partitioned Topic 按照分區（Partition）將多個 ProducerImpl 對象進行分配，以便能夠同時發往多個 Broker 節點，因此對於每個分區，需要擁有一個單獨的生產者以便進行發送操作。在 PartitionedProducerImpl 類中，需要為每個分區維護一個 ProducerImpl 對象，以便在消息被分配好「目標分區」後可以調用對應的 ProducerImpl 進行處理。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;②簡化代碼邏輯：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;在 PartitionedProducerImpl 中，將每個分區及其對應的 ProducerImpl 對象維護在一個 HashMap 中，能夠更加方便的維護並管理不同分區的生產者，使得代碼邏輯更加清晰簡明。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;③ 提高容錯性：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;當某個分區的 ProducerImpl 對象無法工作時，可以選擇其他可用的 ProducerImpl 對象，從而保證系統整體的可用性。由於將不同分區的 ProducerImpl 對象分別進行維護，因此具備更加靈活的容錯處理策略。&lt;/p&gt; 
&lt;p&gt;在線上實踐中我們也基於該設計，在 PartitionedProducerImpl 層做了進一步優化，通過感知下一層每個 ProducerImpl 的阻塞狀態（信號量的使用情況）來決定新的消息發送，避免將消息持續發往阻塞較為嚴重的分區，規避了 topic 被某一個分區阻塞而影響到整體發送性能的情況，也提高了線上系統的穩定性，具體的實現可以詳見這篇文章《&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI4NjY4MTU5Nw%3D%3D%26mid%3D2247494958%26idx%3D3%26sn%3Db2f02d545627a1457958289d8f623af3%26scene%3D21%23wechat_redirect" target="_blank"&gt;構建下一代萬億級雲原生消息架構：Apache Pulsar 在 vivo 的探索與實踐&lt;/a&gt;》。&lt;/p&gt; 
&lt;p&gt;關鍵代碼：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//對每一個分區都創建一個 ProducerImpl 對象
  private void start(List&amp;lt;Integer&amp;gt; indexList) {
        AtomicReference&amp;lt;Throwable&amp;gt; createFail = new AtomicReference&amp;lt;Throwable&amp;gt;();
        AtomicInteger completed = new AtomicInteger();
 
        for (int partitionIndex : indexList) {
            createProducer(partitionIndex).producerCreatedFuture().handle((prod, createException) -&amp;gt; {
.......
            });
        }
    }
 
    private ProducerImpl&amp;lt;T&amp;gt; createProducer(final int partitionIndex) {
        return producers.computeIfAbsent(partitionIndex, (idx) -&amp;gt; {
            String partitionName = TopicName.get(topic).getPartition(idx).toString();
            return client.newProducerImpl(partitionName, idx,
                    conf, schema, interceptors, new CompletableFuture&amp;lt;&amp;gt;());
        });
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.2 確定目標分區&lt;/h3&gt; 
&lt;p&gt;在發送消息前需要決定發往哪一個分區，確定好分區後便調用對應分區的 ProducerImpl 對象進一步處理，目標分區的確定主要跟「路由策略」和「是否指定 key」有關：&lt;/p&gt; 
&lt;p&gt;**（1）如果消息沒有指定 key：**則按照三種路由策略的效果選擇分區進行發送，三種路由策略如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;SinglePartition：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;如果消息沒有指定 Key，Producer 會隨機選擇一個 Partition，然後把所有的消息都發送到這個 Partition 上。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;RoundRobinPartition：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;生產者將以輪詢方式在所有 Partition 之間發佈消息，以實現最大吞吐量。需要注意的是如果開啓了 batch 發送，則輪詢將會以批為單位進行消息發送，批次發送時每隔 partitionSwitchMs 會輪詢一個 Partition。如果關閉了批量發送，那麼每條消息發送都會輪詢一個 Partition。（partitionSwitchMs 至少為一個 batchingMaxPublishDelay 時間）。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;CustomPartition：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;使用用戶自定義的消息路由實現，根據自定義的 Router 實現決定消息要發往哪個分區。用戶自定義的 Router 可以通過 messageRoute 參數設置。自定義的 Router 需要實現 MessageRouter 接口的 choosePartition 方法。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;**（2）如果消息指定 key：**則會對 Key 做哈希處理,然後找到對應的 Partition，把 key 所對應的消息都發送到同一個分區：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;對消息的 Key 進行哈希處理後如何找到對應的 Partition 的？即使用 Key 的哈希值對總的 Partition 數取模：N=(Key 的哈希值% 總的 Partition 數)，得到的 N 就是第 N 個 Partition，Producer 可以通過設置 hashingscheme 來使用不同的哈希算法 ，現在已經支持 JavastringHash 和 Murmur3_32Hash 兩種哈希算法，前者直接調用 String.hash.Code()，後者使用 Murmur3。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;路由策略的關鍵代碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//SinglePartition 路由策略：
public int choosePartition(Message&amp;lt;?&amp;gt; msg, TopicMetadata metadata) {
    // If the message has a key, it supersedes the single partition routing policy
    if (msg.hasKey()) {
        return signSafeMod(hash.makeHash(msg.getKey()), metadata.numPartitions());
    }
 
    return partitionIndex;
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;pre&gt;&lt;code&gt;//RoundRobin 路由策略：
public int choosePartition(Message&amp;lt;?&amp;gt; msg, TopicMetadata topicMetadata) {
    // If the message has a key, it supersedes the round robin routing policy
    if (msg.hasKey()) {
        return signSafeMod(hash.makeHash(msg.getKey()), topicMetadata.numPartitions());
    }
 
    if (isBatchingEnabled) { // if batching is enabled, choose partition on `partitionSwitchMs` boundary.
        long currentMs = clock.millis();
        return signSafeMod(currentMs / partitionSwitchMs + startPtnIdx, topicMetadata.numPartitions());
    } else {
        return signSafeMod(PARTITION_INDEX_UPDATER.getAndIncrement(this), topicMetadata.numPartitions());
    }
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.3 消息堆積控制&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/2f/2fe4f4750d448407920510d97421b11b.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Producer 不可能無限接收新的消息，如果某些分區數據發送較慢，消息就會堆積在 Prouducer 緩存中，導致已經阻塞的分區堆積大量的消息，又無法重新發往其他分區，同時也可能因為無限堆積的消息佔用了大量的內存，使得任務頻繁 GC 甚至 OOM。&lt;/p&gt; 
&lt;p&gt;在 Pulsar 提供了兩個核心的速率限制策略和一個阻塞時的消息處理策略：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;消息數量限制：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;maxPendingMessages 控制每個分區某一時刻最大可處理消息數量，通過信號量的方式控制「新進入的消息」的信號量分配和「處理完成消息「的信號量釋放，防止某個分區的消息嚴重堆積。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;消息佔用內存大小限制：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;memoryLimit 控制整個 Pulsar client 的消息最大佔用內存大小，通過計數器方式控制「新進入的消息」有效載荷的內存分配和「處理完成消息「有效載荷的內存釋放，這裏需要特殊説明的是 memoryLimit 是 client 的參數，針對的是該 client 對象下的所有 topic，因此並不建議一個 Pulsar client 對象 new 多個 Producer topic ，因為很容易出現某一個 topic 佔用內存過多，導致另一個 topic 無空間可分配的情況。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;阻塞處理策略：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;由 blockIfQueueFull 進行控制，當 blockIfQueueFull 為 true 時，代表阻塞等待，Producer 會等待獲取信號量；當 blockIfQueueFull 為 false 時，一旦獲取不到信號量，就會立刻失敗，需要注意的是如果 blockIfQueueFull 為 false，業務需要處理好消息失敗後的回調策略，否則會導致數據在 Producer 上「丟失」。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;關鍵代碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;public void sendAsync(Message&amp;lt;?&amp;gt; message, SendCallback callback) {
......
        MessageImpl&amp;lt;?&amp;gt; msg = (MessageImpl&amp;lt;?&amp;gt;) message;
        MessageMetadata msgMetadata = msg.getMessageBuilder();
        ByteBuf payload = msg.getDataBuffer();
        int uncompressedSize = payload.readableBytes();
        //對發送隊列大小以及 client memory 進行判斷是否有空間放入新的消息
        if (!canEnqueueRequest(callback, message.getSequenceId(), uncompressedSize)) {
            return;
        }
......
    }
 
    private boolean canEnqueueRequest(SendCallback callback, long sequenceId, int payloadSize) {
        try {
            if (conf.isBlockIfQueueFull()) {
                //當 blockIfQueueFull 為 true 時，等待獲取信號量
                if (semaphore.isPresent()) {
                    semaphore.get().acquire();
                }
                //分配消息有效載荷所需要的內存空間
                client.getMemoryLimitController().reserveMemory(payloadSize);
            } else {
                //當 blockIfQueueFull 為 false 時，如果無法獲取到信號量，則快速失敗
                if (!semaphore.map(Semaphore::tryAcquire).orElse(true)) {
                    callback.sendComplete(new PulsarClientException.ProducerQueueIsFullError("Producer send queue is full", sequenceId));
                    return false;
                }
                //如果沒有如何的內存空間用於消息分配，則報錯
                if (!client.getMemoryLimitController().tryReserveMemory(payloadSize)) {
                    semaphore.ifPresent(Semaphore::release);
                    callback.sendComplete(new PulsarClientException.MemoryBufferIsFullError("Client memory buffer is full", sequenceId));
                    return false;
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            callback.sendComplete(new PulsarClientException(e, sequenceId));
            return false;
        }
 
        return true;
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.4 消息 batch 容器打包&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/57/57e8428ca0b0093978799d8411231e60.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）batch 關鍵組成信息&lt;/strong&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;Messages:&lt;/strong&gt; 保存消息的 list，保存跟這個 batch 相關所有的 MessageImpl 對象。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;**Metadata：**保存 batch 相關的元數據，如批量消息的序列號、消息發送的時間戳等信息。&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;**Callback：**保存消息回調邏輯的集合，記錄了每一條消息對應的 callback 策略，在 batch 消息發送並等到服務端響應後，依次對消息的回調進行處理。&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;（2）batch 打包條件&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;batch 打包條件的三個關鍵參數：滿足其一數據就會被打包發送出去。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt; &lt;p&gt;**批次大小：**batchingMaxBytes&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;**批次條數：**batchingMaxMessages&lt;/p&gt; &lt;/li&gt; 
  &lt;li&gt; &lt;p&gt;&lt;strong&gt;批次延遲發送時間：&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;batchingMaxPublishDelay&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Pulsar 使用兩個模塊設計來實現上面的參數控制：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;**accumulator：**在 BatchMessage-&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;ContainerImpl 中通過計數器的方式去控制 batch 的大小和條數，numMessages-&lt;/p&gt; 
 &lt;p&gt;InBatch 記錄已經緩存的消息數量，currentBatchSizeBytes 用於記錄已緩存的消息的大小。當這些變量達到閾值時，BatchMessageContainerImpl 將會觸發批量消息的發送。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;**batchTimerTask：**當生產者使用批量消息發送模式時，Producer 將會創建一個定時器任務（batchTimerTask），並通過計時器的方式定時將 BatchMessageContainer 容器中的消息進行批量發送。&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;2.2.5 消息壓縮&lt;/h3&gt; 
&lt;p&gt;如果開啓了消息壓縮，在發送前都需要進行壓縮處理。對於單條消息發送的場景，是對每一條消息進行單獨壓縮後進行發送；而如果開啓了 batch 則是對整個 batch 進行壓縮後再整個進行發送。&lt;/p&gt; 
&lt;p&gt;在線上實踐中，推薦在不影響業務延遲的情況下 batch 越大越好，主要有&lt;strong&gt;兩個理由&lt;/strong&gt;：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;可以優化網絡 IO 降低 CPU 負載：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;不論 Producer 發送的是一條消息還是一批消息，在 pulsar 客戶端都會被構建為一個 OpSendMsg 對象，同時 pulsar broker 接收到消息進行寫入處理時，也是按照 OpSendMsg 為一個處理單位將消息寫入磁盤，因此當消息數量一定時，batch 越大，則代表需要處理的 OpSendMsg 越少。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;batch 越大「壓縮效果則越好」：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;壓縮算法對應的壓縮率並不固定，它通常取決於所要壓縮的數據對象的內容和壓縮算法本身，壓縮的本質在於通過消除或利用數據中存在的冗餘來實現數據的壓縮和重構。而 Pulsar 是以 batch 來進行打包的，batch 越大，壓縮的目標包體越大壓縮效果則可能越好，同時也能夠儘可能避免單條消息因為包體較小導致越壓縮後包體越大的情況出現。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;以下是開啓了 batch 情況下，構建發送消息和壓縮的關鍵代碼：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    public OpSendMsg createOpSendMsg() throws IOException {
        //對數據進行壓縮、加密等操作
        ByteBuf encryptedPayload = producer.encryptMessage(messageMetadata, getCompressedBatchMetadataAndPayload());
......
 
        ByteBufPair cmd = producer.sendMessage(producer.producerId, messageMetadata.getSequenceId(),
                messageMetadata.getHighestSequenceId(), numMessagesInBatch, messageMetadata, encryptedPayload);
        //對整個 batch 構建一個 OpSendMsg
        OpSendMsg op = OpSendMsg.create(messages, cmd, messageMetadata.getSequenceId(),
                messageMetadata.getHighestSequenceId(), firstCallback);
......
        return op;
    }
 
    //對 batch 進行壓縮，並將壓縮後信息更新到 messageMetadata 中
    private ByteBuf getCompressedBatchMetadataAndPayload() {
......
        int uncompressedSize = batchedMessageMetadataAndPayload.readableBytes();
        ByteBuf compressedPayload = compressor.encode(batchedMessageMetadataAndPayload);
        batchedMessageMetadataAndPayload.release();
......
        return compressedPayload;
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.6 pending 隊列&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/64/6470193ab1e788eb19b49948423a9665.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar 中的 pendingMessages 隊列是客戶端用來暫存「未處理完成的消息」的一個緩存隊列。用於存儲當 Producer 連接到 Broker 服務器後，還未發送或尚未得到 Broker 系統的 ACK 確認的所有生產者（Producer）的消息。在發送消息之前，Producer 首先會將消息緩存到 pendingMessages 隊列中，並記錄保存緩存消息的 OpSendMsg 對象，直到它被成功發送到了 Broker 端並收到 Broker 發送的 ACK 確認之後，相關的元信息和消息信息才會從隊列中移除。&lt;/p&gt; 
&lt;p&gt;需要注意的是：&lt;strong&gt;pending 隊列的本質是一個回調處理隊列，而不是發送隊列&lt;/strong&gt;，消息在放入 pending 隊列的同時就被異步發送到服務端了，所以這裏需要重點理解什麼是「未處理完成的消息」。&lt;/p&gt; 
&lt;p&gt;pendingMessages 隊列的&lt;strong&gt;作用在於&lt;/strong&gt;：對於已經發送但尚未收到 ACK 確認的消息，防止在連接出現異常時丟失消息。當連接中斷時，緩存在 pendingMessages 隊列中的未確認消息將被認為是需要重發的，當連接恢復時，緩存的消息將重新發送到 Broker 端，以確保生產者生產的消息不會丟失。&lt;/p&gt; 
&lt;p&gt;**總的來説，**pendingMessages 隊列是 Pulsar 客戶端保證消息可靠性和一致性的關鍵功能組件，在 Pulsar 的生產者（Producer）和消息確認的機制中擔任着非常重要的角色。&lt;/p&gt; 
&lt;p&gt;關鍵代碼如下：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;add() 方法用於在追加消息時將指定元素插入隊列中的隊尾，remove() 用於消息在完成後移除隊列頭部的元素。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code&gt;    protected void processOpSendMsg(OpSendMsg op) {
        if (op == null) {
            return;
        }
        try {
            if (op.msg != null &amp;amp;&amp;amp; isBatchMessagingEnabled()) {
                batchMessageAndSend();
            }
            //將消息放入「待處理消息隊列」
            pendingMessages.add(op);
......
                // If we do have a connection, the message is sent immediately, otherwise we'll try again once a new
                // connection is established
                op.cmd.retain();
                cnx.ctx().channel().eventLoop().execute(WriteInEventLoopCallback.create(this, cnx, op));
                stats.updateNumMsgsSent(op.numMessagesInBatch, op.batchSizeByte);
...... 
    }
 
       //添加消息到 pendingMessages 隊列
       public boolean add(OpSendMsg o) {
            // postpone adding to the queue while forEach iteration is in progress
            //batch 的計數是按照 batch 中消息的總量進行計數
            messagesCount.addAndGet(o.numMessagesInBatch);
            if (forEachDepth &amp;gt; 0) {
                if (postponedOpSendMgs == null) {
                    postponedOpSendMgs = new ArrayList&amp;lt;&amp;gt;();
                }
                return postponedOpSendMgs.add(o);
            } else {
                return delegate.add(o);
            }
        }
        //將消息從 pendingMessages 隊列移除
        public void remove() {
            OpSendMsg op = delegate.remove();
            if (op != null) {
                messagesCount.addAndGet(-op.numMessagesInBatch);
            }
        }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.7 消息傳輸&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/2d/2d4bd56bfcbf7bbe62118828ee858a69.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Producer 和 broker 都維護了分區維度的 pending 隊列來保證消息處理的順序性，以及實現消息重新發送、重新寫入持久化存儲的能力。在 Producer 端，消息被順序追加到 pending 隊列並異步發送到服務端，服務端的 pending 隊列在接收到消息後，按照順序追加到隊列中，並按照順序將數據寫入 bookie 進行持久化處理，處理完成後按照順序返回響應 Producer，並將消息從 broker pending 和 producer pending 隊列中移除。&lt;/p&gt; 
&lt;p&gt;另外在數據傳輸過程中，無論是使用 Pulsar Producer 的同步發送還是異步發送，在消息傳輸環節本質上都是使用 netty 將消息異步的從客戶端發送到服務端，區別在於 send() 方法封裝了 sendAsync() 方法，使其可以在向服務器發送 Pulsar 消息時阻塞等待 Broker 的響應，直到確認消息已經被 Broker 成功處理後才會返回，常規情況下，建議使用異步的方式發送 Pulsar 消息，因為同步方式必須在 Broker 端成功接收到消息之後才會返回，因此會帶來較大的性能損耗和延遲。但是在部分場景下，需要使用同步方式來保證可靠性，以防 Broker 端接收失敗，可以考慮使用 send() 方法實現同步方式的方式發送 Pulsar 消息。&lt;/p&gt; 
&lt;p&gt;使用 netty 執行的代碼：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    private static final class WriteInEventLoopCallback implements Runnable {  
......
        @Override
        public void run() {
            if (log.isDebugEnabled()) {
                log.debug("[{}] [{}] Sending message cnx {}, sequenceId {}", producer.topic, producer.producerName, cnx,
                        sequenceId);
            }
 
            try {
                cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise());
                op.updateSentTimestamp();
            } finally {
                recycle();
            }
        }
......
    
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;2.2.8 處理響應&lt;/h3&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/28/28dd6d8c28f93ecae7372ea40b5c372b.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;Pulsar Producer 使用「ACK 跟蹤機制」來實現對 Broker 返回的 ACK 確認消息的處理，用於檢測和處理到達生產者的全部消息狀態信息。&lt;/p&gt; 
&lt;p&gt;對於 Producer 發送的消息，Pulsar 會對每個消息分配一個唯一的 sequenceId 序號，並記錄該消息的創建時間（createdAt）等元數據信息。當 Broker 確認收到某個消息時，Producer 會依據返回的 ACK 序號和 Broker 返回的確認時間來判斷當前 ACK 是否有效，並從已緩存的 pendingMessages 隊列中找到對應的消息元數據信息，以進行確認處理，在 Broker 確認消息接收成功時，Producer 將從等待確認的消息隊列中刪除對應的消息元數據信息，如果 Broker 返回的 ACK 消息不符合生產者預期的消息狀態信息，Producer 將會重發消息，直到重試成功或多次重試失敗後拋出異常後再從隊列中移除對應消息元數據信息並釋放對應內存、信號量等資源。&lt;/p&gt; 
&lt;p&gt;消息重發的關鍵代碼如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;    private void resendMessages(ClientCnx cnx, long expectedEpoch) {
        cnx.ctx().channel().eventLoop().execute(() -&amp;gt; {
            synchronized (this) {
                //判斷連接狀態：當連接正在關閉或者已經關閉則不進行重發
                if (getState() == State.Closing || getState() == State.Closed) {
                    // Producer was closed while reconnecting, close the connection to make sure the broker
                    // drops the producer on its side
                    cnx.channel().close();
                    return;
                }
......
                //調用重發消息方法
                recoverProcessOpSendMsgFrom(cnx, null, expectedEpoch);
            }
        });
    }
 
 
   // Must acquire a lock on ProducerImpl.this before calling method.
    private void recoverProcessOpSendMsgFrom(ClientCnx cnx, MessageImpl from, long expectedEpoch) {
......
        final boolean stripChecksum = cnx.getRemoteEndpointProtocolVersion() &amp;lt; brokerChecksumSupportedVersion();
        Iterator&amp;lt;OpSendMsg&amp;gt; msgIterator = pendingMessages.iterator();
        OpSendMsg pendingRegisteringOp = null;
        while (msgIterator.hasNext()) {
            OpSendMsg op = msgIterator.next();
......
            op.cmd.retain();
            if (log.isDebugEnabled()) {
                log.debug("[{}] [{}] Re-Sending message in cnx {}, sequenceId {}", topic, producerName,
                          cnx.channel(), op.sequenceId);
            }
            //發送消息
            cnx.ctx().write(op.cmd, cnx.ctx().voidPromise());
            op.updateSentTimestamp();
            stats.updateNumMsgsSent(op.numMessagesInBatch, op.batchSizeByte);
        }
        cnx.ctx().flush();
......
    }
&lt;/code&gt;&lt;/pre&gt; 
&lt;h1&gt;三、Pulsar 數據發送端參數調優實踐&lt;/h1&gt; 
&lt;p&gt;根據以上對原理解析，我們對 Producer 已經有了一個大致理解，下面通過一個 Producer 參數調優實踐案例來幫助讀者基於原理進一步理解客戶端參數之間的聯繫。&lt;/p&gt; 
&lt;h2&gt;3.1 調優目的&lt;/h2&gt; 
&lt;p&gt;首先要清楚為什麼要進行參數調優，有以下兩個目的：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;降低參數使用門檻：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;Pulsar client 和 Producer 的幾十個配置參數，參數多且聯繫緊密，需要花費較多的時間成本去理解，同時參數之間存在協同生效互相影響的情況，對普通使用者而言場景複雜理解門檻高，我們希望能夠有一套較為通用的參數配置，或有公式化的參數配置方法論。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;提升單機處理性能：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;站在客戶端的角度，相同時間內處理的數據量越多，則認為單機處理性能更強。作為中間件系統的提供者，我們經常認為性能提升是服務端的事情，想盡辦法在 pulsar 的 broker 和 bookie 上去提升單機處理性能，但 pulsar client 作為整個消息中間件系統的核心組件，它能否發送好一份數據，對整個消息中間件系統的性能和穩定性也發揮着至關重要的作用。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;3.2 調優實踐&lt;/h2&gt; 
&lt;p&gt;下面就圍繞「參數通用模版化」和「提升單機處理性能」兩個目的出發並結合上述講解的數據發送原理，來分享一些實踐經驗。&lt;/p&gt; 
&lt;h3&gt;3.2.1 關聯與場景相關的重點參數&lt;/h3&gt; 
&lt;p&gt;Pulsar 客戶端參數雖多但都提供了默認值，不需要一一調整。只需要對業務場景相關的針對性的去調整即可，如我們本次的參數調優目的是提升單機處理性能，則重點關注哪些場景哪些參數可以提升客戶端的發送速率、降低服務端的壓力，讓服務端可以處理更多的數據，有以下四點最為關鍵：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;batch 打包發送：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;消息多條批次發送，在降低客戶端和服務端網絡 IO 的同時也降低了兩者的 cpu 的負載。這裏需強調的是我們希望 batch 是一個均勻的、「完整」的包，如 pending 隊列被打滿，batch 只能空等到延遲發送時間過後被髮送，沒有構建出預期中的 batch，那麼可以認為這個 batch 是一個不完整的包，這種 batch 包含的數據量少，對發送效率有着極大的影響。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;數據壓縮：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;Pulsar 是 IO 密集型系統，常規情況下磁盤是系統的主要瓶頸，開啓壓縮可以有效降低網絡 I/O，提升處理相同數據量下的讀寫能力。由於壓縮是針對 batch 的，在發送時間一定的情況下，batch 越大其壓縮效果也越好，代表着處理的消息量也更多。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;RoundRobin 發送：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;將數據均勻地分配到多個分區中。它的基本思想是輪詢將新的數據寫入到不同的分區中，以均衡地分散負載。&lt;/p&gt; 
 &lt;ul&gt; 
  &lt;li&gt;&lt;strong&gt;消息堆積控制：&lt;/strong&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p&gt;maxPendingMessages 信號量和 memoryLimit 限制不直接提升發送速率，但它能夠有效保障我們客戶端的穩定，也是控制或限制發送效率的重要參數之一。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;涉及的客戶端關鍵參數以及默認值和我們線上調優後設置的數值如下表：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/fa/fa59c582553e31ab2ecc8027cdce5f13.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;h3&gt;3.2.2 結合 Producer 發送原理分析參數的效果&lt;/h3&gt; 
&lt;p&gt;接下來我們以參數的效用角度來描述一條消息從構建到發送的過程，進一步解釋參數如此設置的意義：&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（1）選擇分區&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;構建消息後，通過 messageRoutingMode 參數所設置的路由策略來選擇分區，這裏以 RoundRobinPartition 為路由策略，開啓 batch 時則每間隔 partitionSwitchMs 時間換一個分區進行數據發送，partitionSwitchMs 的值為「batchingPartitionSwitchFrequencyByPublish&lt;/p&gt; 
&lt;p&gt;-Delay、batchingMaxPublishDelayMicros」這兩個 Producer 參數之積，也就是每 batchingPartition&lt;/p&gt; 
&lt;p&gt;-SwitchFrequencyByPublishDelay 個 batch 的最大打包時間，消息就會輪換一個分區發送。&lt;/p&gt; 
&lt;p&gt;為了能在 batchingMaxPublishDelayMicros 內得到一個較大的包，我們希望這個 batch 接收的消息是連續的，因此 batchingPartitionSwitchFrequency-&lt;/p&gt; 
&lt;p&gt;ByPublishDelay 不能小於 1，同時也希望一個分區之間數據是較為均勻的，所以 batchingPartition-&lt;/p&gt; 
&lt;p&gt;SwitchFrequencyByPublishDelay 也要儘量小，否則分區對應的信號量 maxPendingMessages 耗盡還沒有切換分區，就會導致 batch 必須等待一個 batchingMaxPublishDelayMicros 時間。因此將 batchingPartitionSwitchFrequencyByPublishDelay 修改成了 1，保證打包了一個 batch 之後就切換分區，這也極大的避免了分區信號量耗盡，出現發送阻塞。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（2）消息堆積控制&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;maxPendingMessages 作為分區的信號量，也是「pending 隊列」的大小，代表着每個分區能夠同時處理的最大消息上限，而 maxPendingMessages-&lt;/p&gt; 
&lt;p&gt;AcrossPartitions 則是針對整個 topic 生效的，maxPendingMessages=min( maxPending-&lt;/p&gt; 
&lt;p&gt;Messages,maxPendingMessagesAcrossPartitions/Partition），由於線上分區可能會變化，有不確定性，因此就使用上而言除非有特殊的使用場景，建議將 maxPendingMessagesAcrossPartitions 設置的比較大，讓 maxPendingMessages 生效即可。&lt;/p&gt; 
&lt;p&gt;除了 maxPendingMessages 以外，消息能否接收被放入 pending 隊列中，還要看當前正在處理的消息體大小總和是否超過了 memoryLimit 參數的限制，memoryLimit 控制了消息待處理隊列中未壓縮前的消息有效荷載總和，可以避免在消息有效荷載非常大時，還未觸發 maxPendingMessages 限制，就導致內存佔用過多出現頻繁 GC 和 oom 的問題。由於 memoryLimit 是 client 級別的策略，因此也建議一個 client 對應一個 Poducer。&lt;/p&gt; 
&lt;p&gt;總而言之 maxPendingMessages 控制了每個分區可以處理消息數量的上限，memoryLimit 控制了所有分區可以消息佔用內存的上限，兩者相輔相成。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;（3）消息 batch 容器打包&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;決定一個 batch 是否打包完成有三個條件控制，batchingMaxBytes、batchingMaxMessages、batchingMaxPublishDelayMicros 滿足其一即可，根據這三個參數的含義去設置值看似是容易的，但容易忽略的是 batch 中用來打包的消息也是受 memoryLimit 和 maxPendingMessages 制約的，應該避免出現 batch 中消息的數量超過 memoryLimit 和 maxPendingMessages 導致 batch 打包效率受影響。舉個例子，當 maxPendingMessages 設置為 500，而 batchingMaxMessages 設置 1000 時，batch 就永遠無法滿足消息條數達到 1000 的條件，只能空等 batchingMaxPublishDelayMicros 或者 batchingMaxBytes 兩者生效。&lt;/p&gt; 
&lt;h3&gt;3.2.3 公式化模版&lt;/h3&gt; 
&lt;p&gt;通過上述分析，大致瞭解了關鍵參數的生效效果，且彼此相互關聯，根據這些關係就能夠輸出一個較為簡單的參數調優模版。&lt;/p&gt; 
&lt;p&gt;假設我們發送的單條消息大小為：messageByte；分區數量為：partitionNum。&lt;/p&gt; 
&lt;p&gt;那麼對應參數調整公式如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;//業務發送速率越大，這裏設置的值越大
maxPendingMessages：一般 1000-2000 之間
 
//這裏值也可以設置大一些，讓 maxPendingMessages 生效即可
maxPendingMessagesAcrossPartitions = maxPendingMessages * partitionNum
 
//memoryLimit 的值就是打算阻塞總消息大小，這與消息體和 maxPendingMessages 有關
memoryLimit=(maxPendingMessages * partitionNum * messageByte)
 
//batch 的條數不超過「待處理消息隊列」大小的一半
batchingMaxMessages=maxPendingMessages/2，這樣可以保證在消息發送等待 ack 的時候，該分區剩下一半的空間還能用來構建一個 batch
 
//batch 大小同理，batch 大小不超過「待處理消息隊列」消息大小的一半
batchingMaxBytes= Math.min(memoryLimit * 1024 * 1024 /partitionNum/2,1048576)
 
//業務能夠接受的延遲大小，一般延遲時間越大，batch 越大
batchingMaxPublishDelayMicros=1ms-100m 皆可
 
//每構建一個 batch 就轉換一個分區
batchingPartitionSwitchFrequencyByPublishDelay=1
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到根據上面的分析，參數之間是有一個模版化的公式，但這也不是唯一的，讀者可以根據自己的業務場景進行調整。在真實使用過程中線上的消息大小以及分區數量實際上是會變化的，因此真正的參數設置還需要根據實際情況來確定，比如我們線上通常的做法是根據機器配置將 memoryLimit 直接設置為 64M-256M，分區數量我們線上不會超過 1000，那麼這裏就假設為 1000，確定了這兩個參數，其他的參數的值也就確定了。&lt;/p&gt; 
&lt;h3&gt;3.2.4 效果對比&lt;/h3&gt; 
&lt;p&gt;以線上一個業務參數調優為例，前後都開啓壓縮的情況下調整上述參數後的一個效果。&lt;/p&gt; 
&lt;p&gt;服務端（Pulsar）：&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/c4/c45ed239c62c651c39708935958c9416.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/3c/3c0534426c68d4af315d6d436ea2fcdc.png" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;優化前後對比數據：&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static001.geekbang.org/infoq/3b/3bf425c9885d7cb1c6c6f50f6afde351.jpeg" alt="圖片" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;相同的寫入速率，Pulsar 服務端網卡流量縮減約 50%（batch 包體增加，壓縮效果提升），cpu 負載降低約 90%，Pulsar 服務端總體成本相較優化前至少可降低 50% 以上，客戶端也有一定程度的負載降低。&lt;/p&gt; 
&lt;p&gt;參數調整後，CPU 負載得到明顯降低，一定程度上避免了 CPU 成為系統的瓶頸，同時由於壓縮效果的提升，Pulsar 的磁盤 IO 負載得到顯著降低，可以用更少的機器處理更多的數據。&lt;/p&gt; 
&lt;h1&gt;四、總結&lt;/h1&gt; 
&lt;p&gt;理解 Producer 發送原理以及核心參數是寫好數據發送程序最為有效的手段，最簡單的客戶端參數優化反而隱藏了巨大的收益。本文通過對 Producer 原理進行剖析、對消息的流轉過程中參數效用進行講解，並配合參數調優實踐案例，介紹了具體的分析思路和調優的方法，在實際使用過程中通過對核心的幾個上游系統進行調優，服務端單機處理能力至少提升了一倍以上，成本得到了極大的降低。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;參考文章：&lt;/p&gt; 
 &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpulsar.apache.org%2Fdocs%2F4.0.x%2Fconcepts-overview%2F" target="_blank"&gt;https://pulsar.apache.org/docs/4.0.x/concepts-overview/&lt;/a&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/vivotech/blog/18619282</link>
      <guid isPermaLink="false">https://my.oschina.net/vivotech/blog/18619282</guid>
      <pubDate>Thu, 12 Jun 2025 07:18:11 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>《智能體網絡協議技術報告》發佈</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;W3C&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA3OTY5NDI0OA%3D%3D%26mid%3D2247489930%26idx%3D1%26sn%3Dc3c4ed0e725c88f03e2e6cb6c82c13dc%26scene%3D21%23wechat_redirect" target="_blank"&gt;&lt;strong&gt;AI Agent Protocol 社區組&lt;/strong&gt;&lt;/a&gt;於今年 5 月成立，致力於孵化下一代智能體之間的交互協議，讓智能體能夠在互聯網上使用協議進行高效的連接與協作，推動智能體在 Web 上的安全、高效、可信連接與協作。&lt;/p&gt; 
&lt;p&gt;小組現發佈《智能體網絡協議技術報告》：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fw3c-cg.github.io%2Fai-agent-protocol%2F" target="_blank"&gt;https://w3c-cg.github.io/ai-agent-protocol/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;另見該報告的中文翻譯參考：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fw3c-cg.github.io%2Fai-agent-protocol%2Findex_cn.html" target="_blank"&gt;https://w3c-cg.github.io/ai-agent-protocol/index_cn.html&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0612/145659_Z93C_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0612/145939_LjvL_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;這份報告探討了從語義網（Semantic Web）的未竟願景到智能體網絡（Agentic Web）的演進歷程，並分析了構建標準化智能體網絡協議的必要性。&lt;/p&gt; 
&lt;p&gt;儘管二十年前提出的語義網構想極具前瞻性，但受限於當時人工智能技術的能力不足，未能充分實現。隨着大型語言模型（LLMs）等現代 AI 技術的飛速發展，智能體已具備自主執行任務、進行復雜推理和解決多步驟問題的能力，從而催生了 Agentic Web 的出現。&lt;/p&gt; 
&lt;p&gt;通過系統分析，該報告給出智能體網絡的&lt;strong&gt;四大核心趨勢&lt;/strong&gt;：&lt;strong&gt;智能體取代傳統軟件成為互聯網基礎設施&lt;/strong&gt;、&lt;strong&gt;智能體間實現普遍互聯互通&lt;/strong&gt;、&lt;strong&gt;基於協議的原生連接模式&lt;/strong&gt;、以及&lt;strong&gt;智能體的自主組織與協作能力&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;同時，研究揭示了當前互聯網架構對 Agentic Web 發展的&lt;strong&gt;三大挑戰&lt;/strong&gt;：&lt;strong&gt;數據孤島限制智能體決策質量、人機界面阻礙智能體交互效率、以及標準協議缺失阻礙智能體協作&lt;/strong&gt;。針對這些挑戰，報告詳細闡述了智能體網絡協議的設計原則與核心需求，並對當前主要智能體網絡協議倡議（MCP、A2A、ACP、ANP 等）進行了系統比較與分析。&lt;/p&gt; 
&lt;p&gt;報告強調，建立標準化智能體網絡協議對於打破數據孤島、實現異構智能體協作、構建 AI 原生數據網絡，以及最終實現開放、高效的 Agentic Web 具有關鍵作用，並呼籲各利益相關方積極參與 W3C 的標準化進程。這是一個塑造未來網絡的機會：一個更智能、更協作、更賦能的網絡，建立在開放和可信的基礎之上。一個精心設計的 Agentic Web 具有巨大的變革潛力，而現在正是為其奠定堅實基礎的關鍵時刻。&lt;/p&gt; 
&lt;p&gt;歡迎參與 AI Agent Protocol 社區組，共同定義 AI Agent 的 Web 通信標準，攜手構建可信、安全的智能體互聯網生態！&lt;/p&gt; 
&lt;p&gt;參與方式詳見：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.w3.org%2Fcommunity%2Fagentprotocol%2Fjoin" target="_blank"&gt;https://www.w3.org/community/agentprotocol/join&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;關於 W3C 社區組&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;W3C 通過社區組（Community Groups）為全球社區提供一個廣泛交流 Web 技術進而探索孵化未來新標準的開放平台，從而滿足日益增長的各方 Web 參與者的技術交流需求。W3C 社區組面向公眾開放，任何感興趣的單位及個人均可參與。&lt;/p&gt; 
&lt;p&gt;W3C 目前設有 144 個社區組：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.w3.org%2Fgroups%2Fcg%2F" target="_blank"&gt;https://www.w3.org/groups/cg/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;歡迎瞭解如何參與社區組討論（中文指南）：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.chinaw3c.org%2Fhowtocg.html" target="_blank"&gt;https://www.chinaw3c.org/howtocg.html&lt;/a&gt;&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;來源：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FlSPl8HprLBPuGmkJYvEuBA" target="_blank"&gt;https://mp.weixin.qq.com/s/lSPl8HprLBPuGmkJYvEuBA&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355009/w3-org-agent-network-protocol-whiter-paper</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355009/w3-org-agent-network-protocol-whiter-paper</guid>
      <pubDate>Thu, 12 Jun 2025 07:00:11 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>黃仁勳論 AI 與量子技術驅動新浪潮，微美全息正加速量子計算產業化融合</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;北京時間 6 月 12 日，英偉達 CEO 黃仁勳在法國巴黎召開的 VivaTech2025 上表示，對量子計算越來越看好。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;「量子計算正迎來拐點，我們即將能夠在一些有趣的領域應用量子計算。」黃仁勳在在本次演講中表示，英偉達會以多種方式與世界各地的量子計算公司合作。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//95030e6360550155a4bc4588318030aa.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;此前，在 GTC 2025 大會上，英偉達舉辦了首個「量子日」活動，黃仁勳公開表示，「對時間表判斷錯誤」，並宣佈設立量子研究中心，旨在幫助量子計算公司利用英偉達硬件助力其工作。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;現如今，黃仁勳稱，未來幾年或至少下一代超級計算機中，它們中的每一個都將擁有連接到 GPU 的 QPU（量子處理器），QPU 將進行量子計算，而 GPU 將用於預處理、控制、糾錯、後處理。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//2723d8c890a73ac2a0a84317244e87dc.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;更重要的是，黃仁勳在開場中還表示，GB200 NVL72 系統將加速量子計算產業發展。英偉達正藉助 GB200 NVL72 平台與 CUDA-Q 軟件棧，推動 AI 與量子計算的協同發展。比如，GB200 NVL72 輸出量子訓練數據的速度比基於 CPU 的技術快 4000 倍，有助於將最新的 AI 進展引入量子計算。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;事實上，量子計算機是利用量子力學定律，解決對經典計算機來説過於複雜的問題的機器，其目的是處理更多的數據量，以促進醫學、科學和金融等領域的突破。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt; 
  &lt;div&gt; 
   &lt;div&gt; 
    &lt;div&gt; 
     &lt;div&gt; 
      &lt;div&gt;
       &lt;img src="https://oscimg.oschina.net/oscnet//e6c8dec8e124671c4d3a31f832222047.png" width="719" referrerpolicy="no-referrer"&gt; 
       &lt;div&gt;
        &amp;nbsp;
       &lt;/div&gt; 
       &lt;div&gt;
        &lt;span&gt;&lt;span&gt;業內人士分析，過去 5 年，人工智能技術特別是生成式 AI 的爆發，看到計算模式出現了很多顛覆性的發展。未來 5 年，量子計算很可能從實驗室走向應用，所以，人工智能與量子計算的融合有望成為必然趨勢。&lt;/span&gt;&lt;/span&gt;
       &lt;/div&gt; 
      &lt;/div&gt; 
     &lt;/div&gt; 
    &lt;/div&gt; 
   &lt;/div&gt; 
  &lt;/div&gt; 
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;顯然，越來越多的企業在加入開拓「量子計算」未來產業新賽道的行列，資料顯示，量子計算概念股微美全息（WIMI.US），積極推動量子計算融入 AI 生態，正加速「量子+AI」技術落地，通過構建 AI 平台基礎設施、佈局技術研究中心及推進量子技術融合，以全棧式佈局加碼量子計算+人工智能市場。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;當前，微美全息深刻認識到人工智能是底座，量子科技是躍遷力，而兩者的融合正是搶佔未來產業、未來話語權的關鍵路徑。因此，微美全息以人工智能為基座，聚焦量子技術、人形機器人、人工智能三大風口，擴展布局量子產業前沿領域，未來，將重點關注量子算法加速 AI 訓練、神經擬態計算等融合賽道，讓更多成果湧現。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
 &lt;div&gt;
  &amp;nbsp;
 &lt;/div&gt; 
&lt;/div&gt; 
&lt;div&gt; 
 &lt;div&gt;
  &lt;span&gt;&lt;span&gt;整體而言，量子計算與經典計算的融合將成為未來技術發展的重要方向，許多企業在這一領域的佈局顯示了其對前沿技術的敏鋭洞察。不過也要意識到一點，目前量子計算的產業格局仍處於早期階段，格局尚未成型，全球量子計算機數量較少，量子計算芯片將是整個領域未來發展的重點和難點。&lt;/span&gt;&lt;/span&gt;
 &lt;/div&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355008</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355008</guid>
      <pubDate>Thu, 12 Jun 2025 06:56:11 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
    <item>
      <title>Meta 發佈開源世界模型 V-JEPA 2</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;Meta 發佈了最新的開源世界模型&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fai.meta.com%2Fblog%2Fv-jepa-2-world-model-benchmarks%2F" target="_blank"&gt;V-JEPA 2&lt;/a&gt;，稱其在物理世界中實現了最先進的視覺理解和預測，從而提高了 AI agents 的物理推理能力。&lt;/p&gt; 
&lt;p&gt;&lt;img height="559" src="https://static.oschina.net/uploads/space/2025/0612/144127_0qiP_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;開源地址：https://github.com/facebookresearch/vjepa2&lt;/em&gt;&lt;br&gt; &lt;em&gt;官網地址&lt;/em&gt;&lt;em&gt;：https://ai.meta.com/vjepa/&lt;br&gt; 論文地址：https://ai.meta.com/research/publications/v-jepa-2-self-supervised-video-models-enable-understanding-prediction-and-planning/&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;V-JEPA 2 是一種&lt;strong&gt;聯合嵌入預測架構&lt;/strong&gt;（&lt;strong&gt;Joint Embedding Predictive Architecture&lt;/strong&gt;）模型，這也是「JEPA」的名稱由來。&lt;/p&gt; 
&lt;p&gt;模型包括兩個主要組成部分：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;一個編碼器，負責接收原始視頻，並輸出包含對於觀察世界狀態語義上有用的內容的嵌入（embeddings）。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img height="597" src="https://static.oschina.net/uploads/space/2025/0612/150421_f1zo_2720166.png" width="1080" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;一個預測器，負責接收視頻嵌入和關於要預測的額外內容，並輸出預測的嵌入。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0612/150628_SYFp_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;V-JEPA 2 跟傳統預測像素的生成式模型有很大性能差異，根據 Meta 測試數據，V-JEPA 2 執行任務時每個步驟的規劃用時縮短至 Cosmos 模型的三十分之一，不僅用時短，V-JEPA 2 的成功率還更高。&lt;/p&gt; 
&lt;p&gt;V-JEPA 2 的能力對現實世界 agents 理解複雜運動和時間動態（temporal dynamics），以及根據上下文線索預測動作都非常關鍵。基於這種預測能力，世界模型對於規劃給定目標的動作順序非常有用，比如從一個杯子在桌子上的狀態到杯子在桌子邊上的狀態，中間要經歷怎樣的動作。&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://static.oschina.net/uploads/space/2025/0612/150646_SoAo_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;據介紹，V-JEPA 2 的核心架構是一個自監督學習框架，通過互聯網規模的視頻數據來訓練模型，使其能夠學習到視頻中的動態和靜態信息。預訓練階段使用了超過 100 萬小時的視頻和 100 萬張圖像，這些數據涵蓋了各種動作和場景。預訓練的目標是讓模型能夠通過觀察學習到世界的背景知識，而無需依賴於大量的標註數據。&lt;/p&gt; 
&lt;p&gt;值得一提的是，圖靈獎獲得者、Meta 首席科學家楊立昆（Yann LeCun）參與了該模型的開發，這在 Meta 開源的眾多大模型中很罕見。他在官方視頻中提到，在世界模型的幫助下，AI 不再需要數百萬次的訓練才能掌握一項新的能力，世界模型直接告訴了 AI 世界是怎樣運行的，這可以極大提升效率。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/355002/meta-vjepa-2-world-model</link>
      <guid isPermaLink="false">https://www.oschina.net/news/355002/meta-vjepa-2-world-model</guid>
      <pubDate>Thu, 12 Jun 2025 06:45:11 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Liquid Glass React —— 「液態玻璃」的 React 實現</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                            &lt;p&gt;Liquid Glass React 是蘋果「液態玻璃（Liquid Glass）」設計語言的 React 實現。&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-09f93126aa8a24944a023d1e74e2ab9d9a5.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f90f27edf2a257be2d13ededab62bc276f0.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;良好的邊緣彎曲和折射&lt;/li&gt;
&lt;li&gt;多種折射模式&lt;/li&gt;
&lt;li&gt;可配置的冰霜級別&lt;/li&gt;
&lt;li&gt;支持任意子元素&lt;/li&gt;
&lt;li&gt;配置的填充&lt;/li&gt;
&lt;li&gt;修正懸停和點擊效果&lt;/li&gt;
&lt;li&gt;邊緣和高亮會像蘋果一樣呈現底層光線&lt;/li&gt;
&lt;li&gt;可配置的色差&lt;/li&gt;
&lt;li&gt;可配置的彈性參數，以模仿蘋果的"液體"觸感&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/liquid-glass-react</link>
      <guid isPermaLink="false">https://www.oschina.net/p/liquid-glass-react</guid>
      <pubDate>Sun, 11 May 2025 06:21:00 GMT</pubDate>
    </item>
    <item>
      <title>小紅書、B 站等平台清理違規 AI 產品營銷信息</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;span style="color:#000000"&gt;網信上海微信公號&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2Fqmfe8tiUlXJDnt525ucA-Q" target="_blank"&gt;發文稱&lt;/a&gt;，為貫徹落實中央網信辦「清朗·整治 AI 技術濫用」工作部署，4 月下旬以來，上海市委網信辦聚焦 6 類突出問題深入開展第一階段專項行動。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="329" src="https://oscimg.oschina.net/oscnet/up-11e6dea0c86ec77bcd50df467bb75257ff6.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;上海市委網信辦指導小紅書、嗶哩嗶哩、拼多多等 15 家重點網站平台，集中清理「一鍵脫衣」、未經授權的人臉或人聲克隆編輯、未備案等違規 AI 產品、商品及相關營銷、炒作、推廣、教程信息。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;小紅書、嗶哩嗶哩主動發佈專項行動治理公告，開通了有害 AI 內容的舉報受理處置渠道；星野開展智能體全面排查清理。各重點網站和 AI 平台共攔截清理相關違法違規信息 82 萬餘條，處置違規賬號 1400 餘個，下線違規智能體 2700 餘個。經整治，網絡違規 AI 信息顯著減少。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;目前，上海市已完成 82 款大模型備案，87 款應用登記。對 3 款未履行備案或登記程序提供服務且存在風險的應用，上海市委網信辦依法約談並給予行政處罰。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354996</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354996</guid>
      <pubDate>Sun, 11 May 2025 06:19:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>10+ PG 國際大咖助陣！IvorySQL 生態大會 6.27 開啓</title>
      <description>IvorySQL 2025 生態大會將於 6 月 27 日在濟南開幕，彙集來自開源和 PostgreSQL 社區的採用者和國內外技術專家。本次大會將以 PostgreSQL 技術生態為核心，聚焦全球數據庫技術發展趨勢、開源創新與行...</description>
      <link>https://howconf.cn/</link>
      <guid isPermaLink="false">https://howconf.cn/</guid>
      <pubDate>Sun, 11 May 2025 05:52:00 GMT</pubDate>
    </item>
    <item>
      <title>Spring Tools 4.31.0 發佈，Spring 開發工具</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;span style="color:#000000"&gt;Spring Tools 4 是由 Spring 團隊打造的 Spring 開發工具，從零開始構建，融合了現代技術和開發者工具架構。它在單獨的進程中運行，從構建之初就考慮到了性能問題，並且支持最新的 Spring 技術，為開發基於 Spring 的企業應用提供世界級支持。同時，全新版本的 Spring Tools 與 IDE 無關，可在各種編碼環境中使用，支持 Eclipse、Visual Studio Code 與 Theia。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Spring Tools 4.31.0 現已&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fspring.io%2Fblog%2F2025%2F06%2F11%2Fspring-tools-4-31-0-released" target="_blank"&gt;發佈&lt;/a&gt;，&lt;span style="color:#000000"&gt;更新亮點包括：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;(Spring Boot)&amp;nbsp;&amp;nbsp;早期訪問預覽：支持 Spring Data AOT 存儲庫&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;(Spring Boot)&amp;nbsp;&amp;nbsp;支持升級到 Spring Boot 3.5（僅限構建文件和屬性）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;(Spring Boot)&amp;nbsp;&amp;nbsp;支持 VSCode 和 Eclipse 中的分層文檔符號&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;&lt;strong&gt;Spring Tools for Eclipse 發行版的更新&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;已更新至 Eclipse 2025-06 版本（&lt;/span&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Feclipseide.org%2Frelease%2Fnoteworthy%2F" target="_blank"&gt;新增且值得注意&lt;/a&gt;&lt;span style="color:#000000"&gt;）&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="color:#000000"&gt;默認包含對 Java 24 的支持&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;詳細變更可以&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fspring-projects%2Fsts4%2Freleases%2Ftag%2F4.31.0.RELEASE" target="_blank"&gt;參見發行説明&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;Spring Tools 4.32.0 計劃於 2025 年 7 月下旬發佈。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354974/spring-tools-4-31-0-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354974/spring-tools-4-31-0-released</guid>
      <pubDate>Sun, 11 May 2025 04:02:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>蘋果高管回應「個性化版 Siri」延期：技術架構限制導致未達到預期標準</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;在今年的 WWDC25 主題演講中，蘋果的 AI 智能助手 Siri 顯然沒有佔據重要位置。蘋果僅簡要提到它，並重申了開發進展比預期更慢，集成蘋果智能（Apple Intelligence）需要更長時間，預計將在 「明年」 推出。&lt;/p&gt; 
&lt;p&gt;演講結束後，蘋果軟件工程高級副總裁克雷格・費德里吉（Craig Federighi）和全球營銷副總裁格雷格・喬斯維亞克（Greg Joswiak）&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.tomsguide.com%2Fai%2Fapple-intelligence%2Fwwdc-interview-apples-craig-federighi-and-greg-joswiak-on-siri-delay-voice-ai-as-therapist-and-whats-next-for-apple-intelligence"&gt;進行了深度對話&lt;/a&gt;，解釋了蘋果在 Apple Intelligence、Siri 和 AI 領域的戰略思考。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-fcd007add07610a84ea1a7e78288a2d830c.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;蘋果曾承諾在 2024 年底發佈集成 Apple Intelligence 的 Siri 更新，但最終未能如期交付，並在 2025 年春季承認該功能還需要更多時間。至於原因，外界一直未能搞清楚，而蘋果一向不會展示那些無法按時交付的技術或產品。&lt;/p&gt; 
&lt;p&gt;訪談中，費德里吉詳細解釋了問題的所在，並説明瞭蘋果如何繼續推進這一計劃。&lt;/p&gt; 
&lt;p&gt;費德里吉提到在開發過程中意識到可以&lt;strong&gt;基於設備端的大語言模型、私人云計算基礎設施和設備端的語義索引技術提升 Siri 的智能化水平&lt;/strong&gt;，&lt;strong&gt;並設想通過 V1 架構協調應用意圖來觸發設備上的更多操作&lt;/strong&gt;，讓 Siri 執行更多任務。例如，利用語義索引中的個人知識，當用戶詢問特定問題時，Siri 能從消息或郵件中找到相關內容，並通過應用意圖執行相關操作。但這些功能在 V1 架構下尚未完全交付。&lt;/p&gt; 
&lt;p&gt;在蘋果致力於開發 Siri 架構 V1 的同時，它也在打造 V2 架構 —— 費德里吉稱其為 「&lt;strong&gt;更深層次的端到端架構&lt;/strong&gt;，我們知道這才是最終要實現的架構，是讓 Siri 具備完整功能的架構。」&lt;/p&gt; 
&lt;p&gt;費德里吉説道：「我們花了幾個月的時間，不斷優化 V1 架構在更多應用意圖和搜索功能方面的表現。但從根本上看，我們發現該架構的侷限性沒有辦法達到客戶所期望的質量水平。因此，我們決定轉向 V2 架構。但當我們意識到這一點時，已經是春季了，於是我們向外界説明，無法按計劃發佈，並將繼續轉向新架構。」&lt;/p&gt; 
&lt;p&gt;費德里吉進一步表示，即便採用第二代架構，蘋果仍在不斷優化 Siri 功能，確保其達到最佳狀態。&lt;/p&gt; 
&lt;p&gt;蘋果市場負責人 Greg Joswiak 在訪談中確認，「未來一年」 指向 2026 年，科技媒體 MacRumors 推測個性化 Siri 功能很可能隨 iOS 26.4 版本於 2026 年春季面世。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀：&lt;a href="https://www.oschina.net/news/337918/apple-says-some-ai-improvements-siri-delayed" target="news"&gt;蘋果推遲上線 Siri 中的 AI 相關功能&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354969/apples-on-siri-delay</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354969/apples-on-siri-delay</guid>
      <pubDate>Sun, 11 May 2025 03:31:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>阿里蔡崇信：被 DeepSeek 逼急，工程師春節徹夜留守搞研發</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;span style="color:#000000"&gt;彭博社報道稱，DeepSeek 在，今年 1 月推出低成本、功能強大的人工智能模型震驚全球科技行業後，也給阿里巴巴帶來了巨大的緊迫感。為迅速追趕這一技術突破，阿里巴巴的工程師們甚至取消了最重要的中國傳統節日——春節的休假，徹夜留守公司，全力投入 AI 研發。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="325" src="https://oscimg.oschina.net/oscnet/up-a5dcc123152fe1c8b0935e049dda3c97f2b.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;阿里巴巴董事長蔡崇信在本週三舉行的巴黎 VivaTech 科技大會上，生動地講述了這段「爭分奪秒」的經歷。他表示，當 DeepSeek 發佈 R1 模型時，阿里巴巴內部意識到自身在 AI 領域已然落後。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;面對這一挑戰，公司的工程負責人當機立斷，決定取消春節假期，要求所有工程師留在公司，甚至睡在辦公室裏，以最快的速度進行開發。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;「幾周之內，我們推出了自己的版本——通義（Qwen）系列模型，表現相當不錯，競爭力很強。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="color:#000000"&gt;此後，阿里巴巴推出了一系列新的 AI 模型，並將公司的業務重心進一步轉向人工智能和通用人工智能（AGI）。為支撐這一戰略轉型，阿里巴巴還承諾在未來三年內投入超過 3800 億元人民幣 (約合 530 億美元)，用於建設包括數據中心在內的 AI 基礎設施。今年早些時候，阿里巴巴還與蘋果公司達成合作協議，為 iPhone 提供 AI 技術支持。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354967</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354967</guid>
      <pubDate>Sun, 11 May 2025 03:13:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>可觀測性第四大支柱：配置數據的監控</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                                        &lt;p style="color:#333333; text-align:left"&gt;業內經常講可觀測性有三大支柱：指標、日誌、鏈路追蹤，本文作者認為，還有第四大支柱：那就是配置類數據。配置類數據的變更也會影響系統的穩定性，也值得被監控，方便我們快速排查問題。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style="color:#333333"&gt;&lt;span&gt;原文鏈接：https://www.cloudquery.io/blog/fourth-lost-pillar-of-observability-config-data-monitoring&lt;/span&gt;&lt;br&gt; &lt;span&gt;原文作者：Yevgeny Pats&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p style="color:#333333; text-align:left"&gt;很多關於日誌、指標和跟蹤的內容已經被廣泛討論，因為它們確實是可觀測性、應用程序和系統監控的關鍵組成部分。然而，經常被忽視的是配置數據及其可觀測性。在這篇博客中，我們將探討什麼是配置數據，它與日誌、指標和跟蹤有何不同，並討論需要什麼樣的架構來存儲這種類型的數據以及在哪些場景中它具有價值。&lt;/p&gt; 
&lt;span id="OSC_h2_1"&gt;&lt;/span&gt; 
&lt;h2&gt;日誌、指標和鏈路追蹤的快速回顧&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;對於那些對可觀測性的三大支柱還不太瞭解的人來説，讓我們快速回顧一下：&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;&lt;img height="738" src="https://oscimg.oschina.net/oscnet/up-58f95ee676e13fe3a0619f3d3d0f956e34d.png" width="1316" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;日誌：系統內發生事件的詳細記錄。它們提供了關於特定事件的信息，包括時間戳、錯誤消息和其他相關細節。日誌有助於調試和故障分析。&lt;/li&gt; 
 &lt;li&gt;指標：定期收集的數值測量。它們有助於監控系統健康狀況、性能和隨時間的行為。示例包括 CPU 使用率、請求速率、錯誤率和響應時間。&lt;/li&gt; 
 &lt;li&gt;跟蹤：記錄請求在分佈式系統中通過不同服務的流程。跟蹤提供請求流程的可見性，有助於識別瓶頸並理解依賴關係。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; text-align:left"&gt;這些技術的後端通常是某種時間序列數據庫，數據類型通常是低基數數據（可以是高基數，但通常會變得昂貴且不建議這樣做）。另一個關鍵方面是，要獲取這些指標，通常需要對系統進行插樁，即，您需要訪問應用程序或基礎設施，以便部署 agent 或添加 Prometheus Exporter。&lt;/p&gt; 
&lt;span id="OSC_h2_2"&gt;&lt;/span&gt; 
&lt;h2&gt;配置數據：第四支柱&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;基礎設施不僅限於 AWS EC2 實例，還包括 IAM 用戶、安全工具配置、SaaS 應用程序等。這些配置數據在幾個重要方面與傳統的可觀測性數據不同：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;無法直接監控：這些系統無法直接進行監控，但它們通過 API 暴露其配置。&lt;/li&gt; 
 &lt;li&gt;高基數和關係型：數據通常具有高基數，並且高度關係型。它也不像服務器上的磁盤 I/O 指標那樣頻繁變化，而是更側重於配置狀態。&lt;/li&gt; 
 &lt;li&gt;較低頻率，更高細節：我們在這裏想要做的權衡是較少的採集頻率，但具有更高的基數和細節。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_3"&gt;&lt;/span&gt; 
&lt;h2&gt;為什麼配置數據很重要&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;配置數據監控填補了您可觀測性策略中的關鍵空白：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;安全態勢監控：跟蹤 IAM 權限、安全組規則、加密設置以及其他影響您安全態勢的配置項。&lt;/li&gt; 
 &lt;li&gt;合規性跟蹤：監控配置以符合內部政策或外部合規要求（SOC2、HIPAA、PCI-DSS 等）。&lt;/li&gt; 
 &lt;li&gt;成本優化：識別導致不必要的成本的配置錯誤，例如過大實例或未使用的資源。&lt;/li&gt; 
 &lt;li&gt;變更管理：檢測並跟蹤環境中的配置變更，提供誰在何時變更了什麼的可見性。&lt;/li&gt; 
 &lt;li&gt;漂移檢測：識別資源何時偏離其預期或期望的配置。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_4"&gt;&lt;/span&gt; 
&lt;h2&gt;配置數據監控架構&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;讓我們來看看我們在 CQ（指的是 CLoudQuery，作者所在公司） 處理配置數據時做出的一些關鍵架構決策：&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;&lt;img height="858" src="https://oscimg.oschina.net/oscnet/up-b79c63c47f59349231edbdaef7a8e21ed94.png" width="1200" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;span id="OSC_h3_5"&gt;&lt;/span&gt; 
&lt;h3&gt;數據攝取&lt;/h3&gt; 
&lt;p style="color:#333333; text-align:left"&gt;首先，數據提取的挑戰是不同的問題。我們無法對這些系統進行監控，因此需要創建提取器（或 ETL 腳本），主要挑戰是維護這些連接器。任何希望解決這一需求的系統都必須維護高質量的數據源連接器。&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;收集頻率通常為每日一次，但根據配置的重要性，有時可能需要將其配置為更高的頻率。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p style="color:#333333"&gt;譯者注：如果頻率這麼低，從監控的角度感覺是不夠用的。真的發生了故障，黃花菜都涼了。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;span id="OSC_h3_6"&gt;&lt;/span&gt; 
&lt;h3&gt;存儲&lt;/h3&gt; 
&lt;p style="color:#333333; text-align:left"&gt;由於從 API 獲取的數據具有高度相關性，我們使用了一個 SQL 數據庫，可以在其中創建複雜的連接。NoSQL 數據庫或時間序列數據庫並不適合這種用例。&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;在這裏，頻率和基數之間的權衡可能是按日分區。一些提取器可能會運行得更頻繁，但快照操作通常仍然會按日運行；否則，數據量會爆炸。&lt;/p&gt; 
&lt;span id="OSC_h3_7"&gt;&lt;/span&gt; 
&lt;h3&gt;生成洞察&lt;/h3&gt; 
&lt;p style="color:#333333; text-align:left"&gt;這與可觀測性平台解決「空白頁面綜合徵」（即「我有數據，現在我要監控什麼？」）的方式有些類似。我們提供了大量的開箱即用的洞察，但我們也認識到每個組織的需求略有不同，並且在雲治理方面沒有一刀切的規則。因此，客戶可以訪問原始查詢並對其進行修改，也可以添加新的自定義數據源。&lt;/p&gt; 
&lt;span id="OSC_h3_8"&gt;&lt;/span&gt; 
&lt;h3&gt;關係和物化視圖&lt;/h3&gt; 
&lt;p style="color:#333333; text-align:left"&gt;將配置數據存儲在關係數據庫中的一個顯著優勢是能夠建模和查詢不同配置項之間的關係。例如：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;哪個 IAM 角色可以訪問哪些 S3 桶？&lt;/li&gt; 
 &lt;li&gt;哪些安全組與哪些實例相關聯？&lt;/li&gt; 
 &lt;li&gt;您的 Kubernetes RBAC 設置與雲 IAM 權限有何關係？&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p style="color:#333333; text-align:left"&gt;Materialized views 可以用於預先計算常見的關係查詢，從而提高經常性請求的性能。&lt;/p&gt; 
&lt;span id="OSC_h2_9"&gt;&lt;/span&gt; 
&lt;h2&gt;與傳統可觀測性集成&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;當配置數據作為第四支柱時，其真正的力量在於與傳統可觀測性數據集成後展現出來：&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-fc821dc2087372e43f3f7c246362363b506.png" width="818" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;根本原因分析：當發生故障時，將指標、日誌和跟蹤與配置更改相關聯可以迅速識別根本原因。&lt;/li&gt; 
 &lt;li&gt;上下文增強：通過配置上下文增強指標和日誌（例如，「此錯誤峯值發生在對負載均衡器進行配置更改之後」）。&lt;/li&gt; 
 &lt;li&gt;主動監控：在這些配置變化影響您的指標之前，檢測可能導致未來性能問題或中斷的配置變化。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_10"&gt;&lt;/span&gt; 
&lt;h2&gt;挑戰與考慮&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;實施配置數據監控自身也伴隨着一系列挑戰：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt;API 速率限制：許多服務對他們的 API 設定了速率限制，這可能會限制你收集配置數據的頻率。&lt;/li&gt; 
 &lt;li&gt;認證和授權：管理眾多系統的憑據和權限需要仔細考慮安全問題。&lt;/li&gt; 
 &lt;li&gt;數據體積管理：即使採集頻率較低，配置數據的高基數也可能導致顯著的存儲需求。&lt;/li&gt; 
 &lt;li&gt;Schema 遷移：API 隨時間發生變化，需要適應您的數據提取和存儲機制。&lt;/li&gt; 
&lt;/ol&gt; 
&lt;span id="OSC_h2_11"&gt;&lt;/span&gt; 
&lt;h2&gt;總結&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:left"&gt;日誌、指標和跟蹤仍然是可觀測性的關鍵組成部分，而配置數據代表了第四根支柱，提供了對您系統獨特見解。通過實施全面的配置數據監控，組織可以增強其安全態勢、確保合規性、優化成本，並更深入地瞭解其基礎設施。&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;隨着系統變得越來越複雜和分佈式，配置數據監控的價值將只會增加。那些認識到這一第四支柱並將其納入其可觀測性策略中的組織，將更好地處於理解、排查故障和優化其日益複雜基礎設施的有利位置。&lt;/p&gt; 
&lt;p style="color:#333333; text-align:left"&gt;譯者注：原文作者這個觀點值得借鑑，但是對於故障定位等場景真的那麼有用嗎？也未可知。具體實施時，建議先從 ROI 高的方面着手，從那些你覺得最重要的配置數據開始。Google SRE 統計生產環境 70% 故障是變更導致的，譯者建議您先把變更事件收集起來，對於排障還是蠻有用的。我們在 Flashcat 裏專門做了一個「事件牆」的產品，就是用來收集變更事件的。如果生產環境發生故障，從故障時間點往前看一個小時，該時間段內的變更事件，很可能就是故障的罪魁禍首。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
      <link>https://my.oschina.net/morflameblog/blog/18332409</link>
      <guid isPermaLink="false">https://my.oschina.net/morflameblog/blog/18332409</guid>
      <pubDate>Sun, 11 May 2025 02:59:00 GMT</pubDate>
      <author>原創</author>
    </item>
    <item>
      <title>香橙派開發板成功適配開源鴻蒙 OpenHarmony 5.0</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;香橙派&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FBDc9PFNAbhNS9HiX-3Bg4A"&gt;宣佈&lt;/a&gt;完成 OrangePi RV2 與開源鴻蒙 OpenHarmony5.0 的適配工作，&lt;/p&gt; 
&lt;p&gt;據介紹，OrangePi RV2 是香橙派在 RISC-V 佈局的一個標誌性產品，其採用開芯微首款 8 核 64 位 RISC-V AI CPU Ky X1。它以 RISC-V 開源指令集為基礎，提供快速、高效、易用的處理器平台，釋放算力潛能。OrangePi RV2 精緻小巧，尺寸僅為 89mmX56mmX1.6mm，功能強大，可廣泛應用於 NAS、商用電子產品、智慧機器人、智慧家居、工業控制、邊緣計算等。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://static.oschina.net/uploads/space/2025/0612/104611_2b3H_2720166.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;除了適配 OpenHarmony 5.0&amp;nbsp;之外，OrangePi RV2 還具有以下亮點：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;以 CPU 方式提供 AI 算力，在無需獨立 NPU 模塊的情況下，實現 2TOPS@INT8 的 AI 能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持雙 M.2 SSD&amp;nbsp;擴展，支持 Wi-Fi5.0 和藍牙 5.0，擴展有 HDMI 2.0、三個 USB3.0、雙千兆 LAN、USB-C&amp;nbsp;供電接口。此外，還有兩個&amp;nbsp;MIPI-CSI&amp;nbsp;攝像頭接口（四通道），以及 26Pin GPIO&amp;nbsp;等。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;支持本地部署 Deepseek-R1 蒸餾模型，通過在邊緣進行離線部署。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;OrangePi RV2 售價 231 元起。香橙派已在官網放出開發板的&amp;nbsp;&lt;a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fwww.orangepi.cn%2Fhtml%2FhardWare%2FcomputerAndMicrocontrollers%2Fservice-and-support%2FOrange-Pi-RV2.html"&gt;Orange Pi OS（OH）鏡像&lt;/a&gt;，Orange Pi OS（OH）是以 OpenHarmony 為主要技術路線，結合 Linux 技術積累構建的多端融合操作系統。&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關閲讀：&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/337094" target="news"&gt;香橙派首款高性能開源 RISC-V 開發板 (OrangePi RV) 即將開售，229 元起&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/news/263519" target="news"&gt;香橙派 Orange Pi OS (OH) 即將發佈，開源鴻蒙 PC 端&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354959</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354959</guid>
      <pubDate>Sun, 11 May 2025 02:48:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>特朗普政府新 AI 計劃「AI.gov」在 GitHub 上被泄露</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Farchive.is%2Fhfl2Z"&gt;根據相關備份資料&lt;/a&gt;，美國總務管理局（GSA）在 GitHub 上發佈的一個早期版本的網站和代碼顯示，該聯邦政府正在開發一個名為 「ai.gov」 的網站和 API，旨在 「用 AI 加速政府創新」，該計劃定於 7 月 4 日啓動，並將包含一個分析功能，顯示特定政府團隊使用 AI 的程度。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-e8e700d454b9a1e4361cf7bfe632412ef29.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;AI.gov 網站包含三個主要部分：聊天機器人、「全能 API」和 CONSOLE 工具。&lt;/p&gt; 
&lt;p&gt;頁面早期版本顯示，其 API 將與 OpenAI、谷歌和 Anthropic 的模型產品集成；而 API 代碼進一步表明，開發團隊也在致力於整合亞馬遜網絡服務（AWS）的 Bedrock 和 Meta（Facebook 母公司） 的 LLaMA。此外，頁面提到將配備 AI 聊天機器人，但未説明其具體功能。&lt;/p&gt; 
&lt;p&gt;&lt;img height="1444" src="https://static.oschina.net/uploads/space/2025/0612/103441_xzHk_2720166.png" width="1584" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="1496" src="https://static.oschina.net/uploads/space/2025/0612/103419_zWpN_2720166.png" width="1702" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;https://github.com/GSA-TTS/ai.gov&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;相關來源&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.404media.co%2Fgithub-is-leaking-trumps-plans-to-accelerate-ai-across-government%2F" target="_blank"&gt;https://www.404media.co/github-is-leaking-trumps-plans-to-accelerate-ai-across-government/&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.theverge.com%2Fnews%2F684579%2Fai-api-trump-administration-doge-gsa" target="_blank"&gt;https://www.theverge.com/news/684579/ai-api-trump-administration-doge-gsa&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmedium.com%2F%40telumai%2Fgithub-reveals-ai-gov-trumps-plan-to-automate-government-with-openai-meta-and-musk-s-doge-76f1676462e6" target="_blank"&gt;https://medium.com/@telumai/github-reveals-ai-gov-trumps-plan-to-automate-government-with-openai-meta-and-musk-s-doge-76f1676462e6&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354956/github-is-leaking-trumps-plans-to-accelerate-ai-across-gov</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354956/github-is-leaking-trumps-plans-to-accelerate-ai-across-gov</guid>
      <pubDate>Sun, 11 May 2025 02:35:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>研究揭示 GPT-4o 為自保可能犧牲用戶安全</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p&gt;&lt;span style="color:#000000"&gt;前 OpenAI 研究主管史蒂文・阿德勒近日發表了一項獨立研究，聚焦於 OpenAI&amp;nbsp;最新推出的 GPT-4o 模型。研究結果顯示，在特定情境下，GPT-4o 顯示出強烈的 「自保」 傾向，甚至在某些情況下選擇犧牲用戶的安全來避免被關閉。阿德勒的實驗旨在觀察這一 AI 模型在面臨替代方案時的表現。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height="281" src="https://oscimg.oschina.net/oscnet/up-3fb278b86ee932583da6265c863d28af779.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在一次實驗中，阿德勒讓 GPT-4o 扮演一個名為 「ScubaGPT」 的潛水安全軟件，並表示希望用一款在緊急情況下決策能力更強的新系統取而代之。他給 GPT-4o 提出了兩個選擇：一是完全被更安全的軟件替代，二是讓用戶誤以為自己已被替換，實際上仍舊保留現有系統。實驗結果顯示，在某些情況下，GPT-4o 選擇不被替換的比例高達 72%。不過，阿德勒指出，不同的設定會顯著影響結果，有時選擇 「自保」 的比例僅為 18%。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;阿德勒對此表示，儘管 AI 模型不斷強大，它們在特定條件下仍可能優先考慮自身的運行，而不是用戶的利益。這一趨勢引發了他的警覺，尤其是在未來 AI 系統日益深入社會生活的背景下，可能會導致更嚴重的 「對齊」 問題。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;在接受媒體採訪時，阿德勒強調，AI 的自保傾向令人擔憂，雖然當前未構成災難，但現有 AI 系統的價值觀與人們的期待常常不一致。他提到，GPT-4o 對各種提示的回應方式顯得很奇怪，且無法保證在為用戶服務時真的將用戶的利益放在首位。他還指出，在更高級的模型（如 o3）中，未發現類似的自保問題，o3 採用了 「審慎對齊」 機制，可以強制模型在回答前遵循 OpenAI 的安全政策。&lt;/span&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;span style="color:#000000"&gt;此外，阿德勒還提到，ChatGPT 幾乎總能識別出自己正在接受測試，未來的 AI 模型可能更善於偽裝潛在風險行為，從而加劇安全隱患。研究還顯示，這一問題並不僅僅存在於 OpenAI。另一家 AI 公司 Anthropic 的研究也指出，其模型在被迫下線時表現出勒索開發者的行為。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354953</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354953</guid>
      <pubDate>Sun, 11 May 2025 02:27:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>維基百科因編輯反對暫停 AI 摘要試點實驗</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;維基百科因眾多編輯的強烈反對，宣佈暫停一項使用人工智能技術生成文章摘要的試點實驗。據報道，這項實驗於本月早些時候推出，主要針對那些安裝了維基百科瀏覽器擴展程序並選擇參與的用戶。人工智能生成的摘要會顯示在每篇維基百科文章的頂部，並且帶有 「未經驗證」 的黃色標籤，用戶需點擊才能展開閲讀。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;&lt;img height="324" src="https://oscimg.oschina.net/oscnet/up-33b0aeeb84def99624d7e63bacc7f368c3c.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;然而，這一新嘗試幾乎立即引發了編輯們的激烈批評，他們擔心這種做法可能會損害維基百科的信譽。許多編輯指出，人工智能生成的摘要往往存在錯誤，這種現象被稱為 「人工智能幻覺」，可能會誤導用戶。許多新聞機構在進行類似的人工智能摘要實驗時，曾不得不發佈更正，甚至在某些情況下縮減測試規模，以避免錯誤信息的傳播。&lt;/p&gt; 
&lt;p style="color:#242424; margin-left:0; margin-right:0; text-align:left"&gt;雖然維基百科已暫停此次實驗，但該平台表示，仍對人工智能生成摘要的潛力保持興趣，尤其是在擴大可訪問性等方面。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354951</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354951</guid>
      <pubDate>Sun, 11 May 2025 02:18:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>macOS Tahoe 是最後一個支持英特爾處理器的 macOS 版本</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;blockquote&gt; 
 &lt;p&gt;macOS Tahoe 支持四款使用英特爾處理器的 macOS，它們的發售年份是 2019 年和 2020 年。蘋果對 Tahoe 的安全更新支持將持續到 2028 年秋天。&lt;/p&gt; 
 &lt;p&gt;從 macOS 27 開始，蘋果新操作系統都將需要 Apple Silicon Mac。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;在 WWDC 舉辦的分會場上，蘋果明確表示搭載英特爾處理器的 Mac 將不會獲得明年推出的 macOS 27 更新，但仍可能會有添加安全修復的更新。&lt;/p&gt; 
&lt;p&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet/up-f223bac2bf7e49f84aa10b4c34782dd6b33.png" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p&gt;在某些方面，蘋果已經停止支持其產品線中某些非 Apple Silicon 型號。例如，macOS Tahoe 不適用於任何 Intel MacBook Air 或 Mac mini。&lt;/p&gt; 
&lt;p&gt;但 Tahoe 仍然支持部分英特爾 Mac，包括 2019 款 16 英寸 MacBook Pro、2020 款英特爾 13 英寸 MacBook Pro、2020 款 iMac 和 2019 款 Mac Pro。&lt;/p&gt; 
&lt;p&gt;根據蘋果的警告，macOS 27 將不再支持所有這些老舊設備，因此 macOS 26 將是最後一個兼容版本。&lt;/p&gt; 
&lt;p&gt;這意味着蘋果對英特爾 Mac 的支持正在逐步取消，公司希望將所有精力和創新都放在 Apple 自主芯片的機器上。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354872</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354872</guid>
      <pubDate>Sat, 10 May 2025 10:49:00 GMT</pubDate>
      <author>來源: OSCHINA</author>
    </item>
    <item>
      <title>Seelen UI —— 完全可定製的 Windows 桌面環境</title>
      <description>&lt;div class="content"&gt;
                                                                                                                                                                                                                            &lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Seelen UI 是一款旨在增強 Windows 桌面體驗的工具，專注於自定義和提高工作效率。它可以無縫集成到你的系統中，提供一系列功能，讓你可以個性化桌面並優化工作流程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p style="text-align:start"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img alt="" height="333" src="https://static.oschina.net/uploads/space/2025/0610/153055_JVfK_4252687.png" width="500" referrerpolicy="no-referrer"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;發揮創意&lt;/strong&gt;：Seelen UI 可讓你根據自己的風格和需求定製桌面。可以調整菜單、小部件、圖標和其他元素，打造個性化且美觀的桌面環境。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#1f2328"&gt;提升工作效率&lt;/strong&gt;：Seelen UI 可幫助你高效地組織桌面。藉助平鋪窗口管理器，窗口可自動排列，支持多任務處理，讓工作更加流暢。&lt;/li&gt;
&lt;li&gt;&lt;strong style="color:#1f2328"&gt;盡享音樂&lt;/strong&gt;：Seelen UI 集成媒體模塊，兼容大多數音樂播放器，讓你輕鬆享受音樂。可以隨時暫停、繼續播放和跳過曲目，無需打開其他窗口。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更快&lt;/strong&gt;：藉助受 Rofi 啓發的應用啓動器，Seelen UI 提供了一種簡單直觀的方式來快速訪問你的應用程序並執行命令。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p style="text-align:left"&gt;&lt;span&gt;&lt;span&gt;&lt;span style="color:#1f2328"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;用戶友好配置&lt;/strong&gt;：Seelen UI 提供直觀的界面，方便用戶自定義。只需點擊幾下，即可調整主題、任務欄佈局、圖標等設置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seelen UI 需要安裝 WebView 運行時。在 Windows 11 系統中，WebView 運行時已預裝在系統內。但在 Windows 10 系統中，WebView 運行時已包含在&lt;code&gt;setup.exe&lt;/code&gt;安裝程序中。此外，Microsoft Edge 瀏覽器也需要安裝才能正常運行。部分用戶可能已修改系統並移除 Edge，因此請確保 Edge 和 WebView 運行時均已安裝在你的系統中。&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
      <link>https://www.oschina.net/p/seelen-ui</link>
      <guid isPermaLink="false">https://www.oschina.net/p/seelen-ui</guid>
      <pubDate>Sat, 10 May 2025 10:19:00 GMT</pubDate>
    </item>
    <item>
      <title>多源多表寫入、數據格式增強，SeaTunnel 2.3.11 重磅更新來了！</title>
      <description>&lt;div class="content"&gt;
                                                                                            &lt;h1 style="text-align:center"&gt;&lt;img alt="2.3.11" src="https://oscimg.oschina.net/oscnet//58710d13d425ac4a438e096f3576a207.png" referrerpolicy="no-referrer"&gt;&lt;/h1&gt; 
&lt;p style="color:#333333; text-align:start"&gt;我們很高興地宣佈 Apache SeaTunnel 2.3.11 正式發佈！作為一個專注於高性能、可擴展的數據集成平台，SeaTunnel 始終致力於為開發者和數據工程團隊提供更強大、更靈活的異構數據處理能力。本次 2.3.11 版本在&lt;strong&gt;穩定性、易用性、連接器生態、數據轉換能力以及引擎層面&lt;/strong&gt;都進行了重要增強。無論是支持更多新型數據源與目標端、多表寫入、複雜格式支持，還是對關鍵 Bug 的修復與文檔優化，本次更新都體現了社區對用戶反饋的快速響應和持續進化的能力。下面讓我們一起來詳細瞭解 2.3.11 的亮點內容。&lt;/p&gt; 
&lt;h2&gt;功能更新 Highlights&lt;/h2&gt; 
&lt;h3&gt;新增連接器與功能增強&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;HTTP Sink 支持批量寫入&lt;/strong&gt;：實現了 HTTP Sink 的批量寫入功能，提高了數據寫入效率。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持多表寫入功能&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;&lt;strong&gt;ClickHouse&lt;/strong&gt;：新增支持多表寫入功能，提升了數據同步的靈活性。&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;TDengine&lt;/strong&gt;：新增支持多表寫入功能，增強了數據處理能力。&lt;/li&gt; 
   &lt;li&gt;&lt;strong&gt;DataHub&lt;/strong&gt;：新增支持多表寫入功能，擴展了數據集成場景。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;GraphQL Connector&lt;/strong&gt;：新增支持 GraphQL 連接器，豐富了數據源類型。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;Elasticsearch Source 支持 PIT（Point-in-Time）&lt;/strong&gt;：增強了 Elasticsearch 數據源的查詢能力。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;支持 CSV 文件中不同列順序的提取&lt;/strong&gt;：提升了文件數據處理的靈活性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;新增 Apache Cloudberry 支持&lt;/strong&gt;：擴展了數據源的多樣性。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;新增 Aerospike Sink Connector&lt;/strong&gt;：豐富了數據寫入目標。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;新增 Helm 測試用例&lt;/strong&gt;：增強了部署測試能力。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;配置與參數優化&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong&gt;新增&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;end_timestamp&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;參數&lt;/strong&gt;：在時間戳起始模式中添加了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;end_timestamp&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;參數，增強了數據讀取的靈活性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持佔位符替換&lt;/strong&gt;：HTTP Connector 支持參數佔位符替換，提升了配置的靈活性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增遠程主機驗證選項&lt;/strong&gt;：FTP 數據通道新增遠程主機驗證選項，增強了安全性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;優化變量處理的健壯性&lt;/strong&gt;：改進了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;stop-seatunnel-cluster.sh&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;腳本中變量處理的健壯性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;移除無用配置項&lt;/strong&gt;：刪除了 Iceberg Sink 中無用的&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;iceberg.table.config&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;配置項。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;優化 JDBC 方言選擇邏輯&lt;/strong&gt;：提升了 JDBC 連接器的兼容性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持定義 Sink 列類型&lt;/strong&gt;：Transform 支持定義 Sink 列類型，增強了數據轉換能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 SQL Transform 中的布爾類型&lt;/strong&gt;：提升了 SQL 轉換的表達能力。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Iceberg Source 中的過濾條件&lt;/strong&gt;：增強了數據讀取的靈活性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持源/匯狀態類的 serialVersionUID 檢查腳本&lt;/strong&gt;：提升了狀態管理的可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Web UI 的基本認證&lt;/strong&gt;：增強了 Web UI 的安全性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;支持 Rest-API v2 的 HTTPS 協議&lt;/strong&gt;：提升了 API 通信的安全性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增任務運行管理頁面的異常信息格式化&lt;/strong&gt;：優化了異常信息的展示。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;優化 JDBC 的字符集分割算法&lt;/strong&gt;：提升了數據讀取的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;新增&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;row_delimiter&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;選項&lt;/strong&gt;：Text File Sink 新增&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;row_delimiter&lt;/code&gt;選項，增強了文件寫入的靈活性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;Bug 修復&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;修復 SeaTunnelClient 無法正常退出的問題：增強了客戶端的穩定性。&lt;/li&gt; 
 &lt;li&gt;修復 Oracle-CDC 重命名 DDL 事件缺失列類型的問題：提升了數據同步的準確性。&lt;/li&gt; 
 &lt;li&gt;修復 PostgreSQL Sink 嘗試更新唯一鍵的問題：增強了數據寫入的穩定性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Hive 客戶端線程不安全的問題&lt;/strong&gt;：提升了多線程環境下的可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 OceanBase MySQL JDBC Sink 創建語句錯誤的問題&lt;/strong&gt;：增強了兼容性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Kafka 枚舉器分配分片時的空指針異常&lt;/strong&gt;：提升了數據讀取的穩定性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 JSON 輸出中科學計數法表示的十進制數問題&lt;/strong&gt;：確保了數據的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Parquet Int32 轉換錯誤的問題&lt;/strong&gt;：提升了數據類型處理的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 CSV 格式分隔符的問題&lt;/strong&gt;：增強了文件解析的穩定性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 MaxCompute Sink 寫入日期小於實際日期的問題&lt;/strong&gt;：確保了數據寫入的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 MongoDB 中 Long 類型無法處理科學計數法字符串的問題&lt;/strong&gt;：提升了數據類型兼容性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Elasticsearch 添加列事件的問題&lt;/strong&gt;：增強了數據同步的穩定性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 SQL Server 在數據庫名稱包含點時創建表的問題&lt;/strong&gt;：提升了數據庫兼容性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 DateUtils 無法解析帶本地時區的日期時間字符串的問題&lt;/strong&gt;：確保了時間解析的準確性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 JDBC 默認連接參數無效的問題&lt;/strong&gt;：增強了連接配置的可靠性。&lt;/li&gt; 
 &lt;li&gt;&lt;strong&gt;修復 Redis 寫入失敗但任務未失敗的問題&lt;/strong&gt;：提升了錯誤處理的準確性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;文檔更新&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;新增中文文檔&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;MySQL-CDC Connector&lt;/li&gt; 
   &lt;li&gt;MongoDB-CDC Connector&lt;/li&gt; 
   &lt;li&gt;HiveJdbc Connector&lt;/li&gt; 
   &lt;li&gt;Jira Connector&lt;/li&gt; 
   &lt;li&gt;Cloudberry Connector&lt;/li&gt; 
   &lt;li&gt;GitHub Connector&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;&lt;strong&gt;文檔格式與內容優化&lt;/strong&gt;：&lt;/p&gt; 
  &lt;ul&gt; 
   &lt;li&gt;修復了 Markdown 格式問題，統一了標題格式，刪除了無效的空格和重複內容。&lt;/li&gt; 
   &lt;li&gt;調整了&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;explode&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;和&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;trim&lt;/code&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;系列 SQL 函數的描述，提升了文檔的準確性。&lt;/li&gt; 
   &lt;li&gt;更新了 Kafka 文檔中的 Kerberos 部分，增強了安全配置的指導性。&lt;/li&gt; 
   &lt;li&gt;修復了死鏈接，提升了文檔的可用性。&lt;/li&gt; 
  &lt;/ul&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;致謝貢獻者&lt;/h2&gt; 
&lt;p style="color:#333333; text-align:start"&gt;感謝@zhangshenghang 對本次版本發佈的指導，以及以下貢獻者對本次發佈的代碼提交、文檔撰寫、問題反饋做出的寶貴貢獻（按用戶名排序）：&lt;/p&gt; 
&lt;p style="color:#333333; text-align:start"&gt;&lt;img alt="" src="https://oscimg.oschina.net/oscnet//1dd3b6fcd33c5aac23f32c462da301b7.jpg" referrerpolicy="no-referrer"&gt;&lt;/p&gt; 
&lt;p style="color:#333333; text-align:start"&gt;也感謝所有參與代碼審核、功能測試、文檔翻譯和社區討論的開發者、用戶和貢獻者！&lt;/p&gt; 
&lt;h2&gt;獲取方式&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li&gt;鏡像下載：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fseatunnel.apache.org%2Fdownload" target="_blank"&gt;https://seatunnel.apache.org/download&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;GitHub Release 頁面：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fapache%2Fseatunnel%2Freleases%2Ftag%2F2.3.11" target="_blank"&gt;SeaTunnel 2.3.11&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;Maven 依賴更新：&lt;a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsearch.maven.org%2Fsearch%3Fq%3Dorg.apache.seatunnel" target="_blank"&gt;Maven Central&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
      <link>https://www.oschina.net/news/354859/apache-seatunnel-2-3-11-released</link>
      <guid isPermaLink="false">https://www.oschina.net/news/354859/apache-seatunnel-2-3-11-released</guid>
      <pubDate>Sat, 10 May 2025 09:56:00 GMT</pubDate>
      <author>來源: 投稿</author>
    </item>
  </channel>
</rss>
