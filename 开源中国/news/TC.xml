<?xml version="1.0" encoding="UTF-8"?>
<rss
    xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>開源中國-最新資訊</title>
        <link>https://www.oschina.net/news/project</link>
        <atom:link href="http://8.134.148.166:30044/oschina/news" rel="self" type="application/rss+xml"></atom:link>
        <description>開源中國-最新資訊 - Powered by RSSHub</description>
        <generator>RSSHub</generator>
        <webMaster>contact@rsshub.app (RSSHub)</webMaster>
        <language>en</language>
        <lastBuildDate>Mon, 24 Mar 2025 02:37:48 GMT</lastBuildDate>
        <ttl>5</ttl>
        <item>
            <title>Perplexity 欲收購 TikTok 並開源其算法</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;人工智能搜索初創公司 Perplexity 近日在官方博客&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.perplexity.ai%2Fhub%2Fblog%2Frebuilding-tiktok-in-america&quot; target=&quot;_blank&quot;&gt;發佈文章&lt;/a&gt;&lt;/u&gt;，提出收購（並改造）TikTok 的要約。&lt;/p&gt; 
&lt;p&gt;該公司寫道：「Perplexity 擁有獨特的優勢，可以在不造成壟斷的情況下重建 TikTok 算法，將世界一流的技術能力與 Little Tech 的獨立性結合起來。」&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2e5510e21cdce267c8df1b32cb6fc68d994.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;他們聲稱，他們擁有獨特的優勢，可以「不造成壟斷」地做到這一點，這與競爭對手或投資者財團可能進行的收購不同，後者可能會保持字節跳動的影響力。該計劃包括：&lt;/p&gt; 
&lt;ol&gt; 
 &lt;li&gt; &lt;p&gt;「在美國數據中心和美國監督下」從頭重建 TikTok 算&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;讓推薦系統「透明」且開源&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;使用 NVIDIA Dynamo 技術升級 AI 基礎設施&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;為視頻添加與 Perplexity 現有功能類似的引用功能&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;將 Perplexity 的搜索功能與 TikTok 的視頻庫相集成&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;為連接 Perplexity 和 TikTok 賬戶的用戶增強個性化（該初創公司聲稱，「這可以幫助在 TikTok 上展示更多相關內容」）&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;通過自動翻譯添加多語言功能&lt;/p&gt; &lt;/li&gt; 
&lt;/ol&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;全文如下&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在美國重建 TikTok 的願景&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 的使命一直是通過準確、透明且易於獲取的信息滿足全世界的好奇心。自 2022 年由一羣 AI 研究人員創立以來，我們一直致力於成為世界上最好的答案引擎。&lt;/p&gt; 
&lt;p&gt;TikTok 已成為最重要、最真實的創意表達和內容發現平台之一，連接着全球數百萬用戶。我們認為 Perplexity 可以讓 TikTok 變得更好。&lt;/p&gt; 
&lt;p&gt;我們很高興能夠分享我們所設想的未來：一個對每個人都更有用的 TikTok，用戶擁有易於使用的工具，可以讓他們深入瞭解並尋求真相，並由世界上最好的答案引擎提供支持。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;在美國建立透明的算法&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 擁有獨一無二的優勢，能夠重建 TikTok 算法而不會造成壟斷，將世界一流的技術能力與 Little Tech 的獨立性結合起來。任何投資者財團的收購實際上都可能讓字節跳動控制算法，而任何競爭對手的收購都可能在短視頻和信息領域造成壟斷。當內容信息流從外國政府和全球主義壟斷者的操縱中解放出來時，整個社會都會受益。&lt;/p&gt; 
&lt;p&gt;TikTok 的「為你推薦」推送針對每個用戶進行個性化設置，構建實時推薦系統對於保持短視頻平台的新鮮感和趣味性至關重要。Perplexity 將首先構建這些基本系統，以確保用戶獲得無縫體驗。該基礎設施將在美國數據中心開發和維護，並接受美國監管，確保符合國內隱私標準和法規。&lt;/p&gt; 
&lt;p&gt;TikTok 算法如今是一個黑匣子。我們認為這些推薦系統應該是透明的。為了消除用戶操縱的風險，我們建議以透明為指導原則從頭開始重建 TikTok 算法。我們承諾將 TikTok 打造成世界上最中立、最值得信賴的平台。為了實現這一目標，我們不僅致力於開發新算法，還致力於將 TikTok For You 信息開源。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;升級至世界一流的人工智能基礎設施&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 運行的先進 AI 基礎設施由 NVIDIA Dynamo 提供支持（在 2025 年 NVIDIA GPU 技術大會上宣佈，並提到 Perplexity 是其最喜歡的合作伙伴），可以輕鬆將 TikTok 的推薦模型擴展 100 倍，同時實現更快的推理速度，從而提高 TikTok 的推薦系統的標準，使其成為世界上最好的。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;利用 Perplexity 的引文和社區註釋功能增強對 TikTok 的信任&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 上的所有答案都包含引文，我們認為這對於創建值得信賴的信息生態系統至關重要。作為第一步，Perplexity 將立即將此功能擴展到 TikTok 視頻，讓用戶在觀看視頻時可以輕鬆實時交叉引用信息。&lt;/p&gt; 
&lt;p&gt;我們可以開發世界上最強大的上下文系統。該系統利用社區反饋和人工智能功能來突出顯示可靠信息。這種方法類似於我們在 X 上的 @AskPerplexity 帳戶，該帳戶已獲得超過 13 萬名粉絲，每天為數千名用戶提供上下文信息。通過將類似的功能引入 TikTok，我們可以確保用戶在滾動「為您推薦」信息流時能夠訪問世界一流的信息工具。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;打造全球最佳「搜索框」&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;將 Perplexity 的答案引擎與 TikTok 的豐富視頻庫相結合，我們將能夠打造世界上最好的搜索體驗，讓 TikTok 和 Perplexity 用戶隨時隨地通過任何媒介獲得他們尋求的答案。&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt; &lt;p&gt;使用 Perplexity 的答案引擎增強 TikTok 搜索：這將為用戶提供全面、引用充分的答案，將世界上最好的答案引擎與最大的用戶生成內容庫之一相結合。&lt;/p&gt; &lt;/li&gt; 
 &lt;li&gt; &lt;p&gt;將 TikTok 視頻引入 Perplexity：同時，Perplexity 的答案將通過 TikTok 視頻進行豐富，以將相關內容帶入專業、推理和深入研究。&lt;/p&gt; &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;無論您是在尋找 100 美元以下的最佳網球拍，試圖瞭解收益電話會議對股票的影響，還是想知道當地人喜歡吃飯的地方——我們都會始終致力於讓您獲得最好的結果。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;讓 TikTok 對每個人都有用&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;除了構建基礎設施之外，我們的首要任務是提升用戶在 TikTok 上發現的內容的信息價值。我們認為，用戶在平台上花費的時間應該是值得的，指標和優化應側重於用戶滿意度和信息價值，而不僅僅是參與度。&lt;/p&gt; 
&lt;p&gt;對於選擇將 Perplexity 和 TikTok 帳戶關聯的用戶，我們可以利用跨平台信號來改善個性化。Perplexity 通過問題和空間瞭解用戶的興趣，可以幫助在 TikTok 上展示更多相關內容。同樣，TikTok 上的內容偏好可以為 Perplexity 提供更個性化的答案。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;利用人工智能豐富內容&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;Perplexity 的 LLM 編排功能可通過為視頻添加上下文信息甚至多語言功能來改變 TikTok 體驗。通過自動翻譯和註釋，創作者可以輕鬆將影響力擴大到全球觀眾。&lt;/p&gt; 
&lt;p&gt;對於用戶來説，這將提供廣度和深度——提供對更多樣化內容的訪問，同時允許更深入地探索引起他們好奇心的話題。想象一下，觀看有關量子物理的視頻並能夠直接從該內容發起深入的研究查詢。這種集成將允許用戶在 TikTok 的滾動體驗和 Perplexity 強大的研究功能之間無縫過渡——所有這些都在單一、統一的 Feed 中完成。&lt;/p&gt; 
&lt;p&gt;從重建開源「為你推薦」算法到利用最新的 AI 基礎設施增強個性化，我們對 TikTok 可能實現的可能性感到興奮。將 Perplexity 在提供準確、值得信賴的答案方面的專業知識與 TikTok 充滿活力、富有創意的社區和豐富的視頻庫相結合，將使每個人都受益。由 Perplexity 重建和支持的 TikTok 將打造出世界上最偉大的創造力和知識發現平台。&lt;/p&gt; 
&lt;hr&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/330728&quot; target=&quot;news&quot;&gt;美國 AI 初創企業 Perplexity 尋求與 TikTok 合併&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/326518&quot; target=&quot;news&quot;&gt;字節 TikTok 算法負責人陳志傑或於近期離職，開啓 AI Coding 方向創業&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/295111/tiktok-preparing-us-copy-apps-core-algorithm-sources-say&quot; target=&quot;news&quot;&gt;TikTok 準備在美國複製一套該應用的核心算法&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340590/perplexity-rebuilding-tiktok-in-america</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340590/perplexity-rebuilding-tiktok-in-america</guid>
            <pubDate>Mon, 24 Mar 2025 02:29:22 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>​全球首個體重管理 AI 大模型 「減單」 發佈，基於 DeepSeek 等</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;安徽醫科大學聯閤中國科學技術大學附屬第一醫院和健康科技企業，近日在合肥發佈體重管理大模型智能助手「減單」，希望藉助 AI 技術提高減重的個性化幹預質量和診療效率。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據介紹，「減單」 模型的構建，基於 DeepSeek、OpenAI 及豆包三個大模型，結合過 40 萬名肥胖相關慢性疾病患者的管理數據，不斷訓練而成。與其他同類模型不同，「減單」 專注於生活方式的幹預，旨在應用於肥胖相關的慢性疾病管理。諾&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;用戶拍照上傳每餐食物，大模型智能助手自動識別分析營養成分和熱量，結合用戶健康檔案，生成個性化評價和膳食指導建議。此外，該模型的模塊化應用也將擴展至內分泌科、營養科及全科管理等領域，預計在未來三年內覆蓋超過 1 億名慢性病患者。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;根據《中國居民營養與慢性病狀況報告（2020 年）》，2018 年我國成人超重率和肥胖率分別為 34.3% 和 16.4%，6 歲至 17 歲兒童青少年超重率和肥胖率分別為 11.1% 和 7.9%，並呈逐年遞增趨勢。國家衞生健康委發佈的《體重管理指導原則（2024 年版）》指出，有研究預測，若該趨勢得不到有效遏制，2030 年我國成人、兒童超重肥胖率將分別達到 70.5% 和 31.8%。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;安徽醫科大學校長、中國科學技術大學臨牀醫學院執行院長翁建平介紹，AI 大模型智能助手結合專業化醫生的人工支持，可以實現對肥胖人羣「千人千策」式的個性化幹預，幫助老百姓從「被動治療」轉向「主動預防」。下一步，研發團隊將繼續優化「減單」的功能並致力於推廣，讓人工智能技術惠及我國更多的肥胖相關慢性疾病患者。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340589</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340589</guid>
            <pubDate>Mon, 24 Mar 2025 02:24:22 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>上海交大發布大模型 Venus，可讓蛋白質「定向進化」</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;上海交通大學特聘教授洪亮團隊近日發佈了大模型 Venus，其核心能力是讓蛋白質實現功能的「定向進化」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;團隊將 AI 與蛋白質設計與改造相結合，建立了全球最大的蛋白質數據集，基於該數據集訓練的模型，可以精準、高效地預測、設計蛋白質的功能，把蛋白質生產由「緩慢的試錯」變為「高效率的精準設計」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;如果想要強化目標蛋白質的某個功能，只需要提供該蛋白質的序列信息，Venus 就可以快速給出一批蛋白質序列改造方案，隨後結合實驗驗證得到最優改造方案。據悉，經過 Venus 系列模型設計的多款蛋白質已經實現了落地產業化，將助力阿爾茲海默等疾病的診斷。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;335&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-8fe0d70f558b02cbaba3a1c6707d54d13f8.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;洪亮團隊建立的蛋白質序列數據集 Venus-Pod（Venus-Protein Outsize Dataset）含有近 90 億條蛋白質序列，包含數億個功能標籤，是全球數據規模最大、功能批註標籤最多的數據集，也是另一行業知名模型——美國 ESM-C 模型訓練用的 21 億蛋白質序列的 4 倍體量。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;該數據集包含 36.2 億條陸地微生物蛋白質序列、26.4 億條海洋微生物蛋白質序列、24.3 億條抗體蛋白質序列、0.6 億條病毒蛋白質序列，覆蓋從常規地表生物到極端環境微生物的蛋白質序列信息，尤其是配備的數億功能標籤（蛋白質工作的溫度、酸鹼度、壓強等）。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「我們訓練了 Venus（啓明星）系列模型，與 DeepMind 團隊的 AlphaFold 預測蛋白質結構不同，這個模型學習自然界蛋白質序列的組織規則以及它與功能之間的關係，其預測蛋白質突變功能的精度位居行業榜單之首。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;洪亮表示，Venus 系列模型具備兩大核心功能：&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「AI 定向進化」與「AI 挖酶」。所謂「AI 定向進化」是指 Venus 系列模型可以對一個不盡如人意的蛋白質產品的多種性能進行優化，讓它成為一個「六邊形戰士」滿足應用需求。而「AI 挖酶」則是指 Venus 系列模型基於其海量的未知功能蛋白質數據集，可以「海選超能力戰士」，去精準發掘滿足苛刻應用需求的具備超常規功能的蛋白質，比如極度耐熱、極度耐酸、極度耐鹼、極度耐胃腸消化等。這些超常規功能的蛋白質在生物技術、醫藥研發和工業生產中具有巨大的應用潛力，能夠為相關領域帶來創新和突破。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340580</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340580</guid>
            <pubDate>Mon, 24 Mar 2025 02:13:22 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Docker 將原生支持運行 LLM</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.docker.com%2Fllm%2F&quot; target=&quot;_blank&quot;&gt;根據 Docker 官網消息&lt;/a&gt;&lt;/u&gt;，其即將推出 Docker Model Runner 工具，旨在通過容器化技術簡化 LLM 本地運行流程。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0324/100640_My7h_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;其主要功能包括：&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;模型獲取：支持從 Docker Hub 直接獲取 AI 模型，簡化配置流程。&lt;/li&gt; 
 &lt;li&gt;操作便捷：通過 Docker 命令行工具使用，符合開發者日常操作習慣。&lt;/li&gt; 
 &lt;li&gt;接口兼容：適配 OpenAI 標準接口，方便現有項目集成。&lt;/li&gt; 
 &lt;li&gt;運行效率：支持蘋果芯片和 NVIDIA 顯卡加速，提升本地計算性能。&lt;/li&gt; 
 &lt;li&gt;安全隔離：沿用 Docker 容器技術，保障運行環境的安全性。&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;當前開發者普遍使用 ollama 開源工具部署 AI 模型。相比而言，Docker Model Runner 對已在使用容器技術的開發者具有天然適配優勢。而 ollama 作為成熟的開源工具，擁有豐富的模型支持和活躍的社區資源。&lt;/p&gt; 
&lt;p&gt;有意思的是，ollama 本身也支持在 Docker 環境中運行，這為用戶提供了更多選擇空間。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340579/docker-model-runner-run-llms-natively</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340579/docker-model-runner-run-llms-natively</guid>
            <pubDate>Mon, 24 Mar 2025 02:13:22 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>騰訊混元自研深度思考模型「T1」發佈</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;騰訊已於近日&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F38ilIogkFK8tbgRFDSXdSw&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;正式推出自研深度思考模型混元 T1 正式版。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「T1」吐字快、能秒回，還擅長超長文處理，是騰訊自研的強推理模型，已經上線騰訊雲，即將在騰訊元寶灰度上線。通過大規模強化學習，並結合數學、邏輯推理、科學和代碼等理科難題的專項優化，混元 T1 正式版進一步提升了推理能力。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;公告稱，在體現推理模型基礎能力的常見 benchmark 上，如大語言模型評估增強數據集 MMLU-PRO 中，混元 T1 取得 87.2 分，僅次於 o1。在 CEval、AIME、Zebra Logic 等中英文知識及競賽級數學、邏輯推理的公開基準測試中，混元 T1 的成績也達到業界領先推理模型的水平。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;「T1」還在多項對齊任務、指令跟隨任務和工具利用任務中展現出了非常強的適應性。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;323&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-c5034efbc2180d11de8f1e91ba6bf5ff565.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;351&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-89b33c47634ba22094d141898c359f35e39.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;混元 T1 正式版沿用了混元 Turbo S 的創新架構，採用 Hybrid-Mamba-Transformer 融合模式。「這是工業界首次將混合 Mamba 架構無損應用於超大型推理模型。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;這一架構有效降低了傳統 Transformer 結構的計算複雜度，減少了 KV-Cache 的內存佔用，從而顯著降低了訓練和推理成本。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;混元 T1 在超長文本推理領域也展現出獨特優勢，能有效解決長文推理中常見的上下文丟失和長距離信息依賴問題。同時，混合 Mamba 架構針對長序列處理進行了專項優化，通過高效的計算方式，在確保長文本信息捕捉能力的同時大幅降低資源消耗，在相近的激活參數量下，實現瞭解碼速度提升 2 倍。&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340576</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340576</guid>
            <pubDate>Mon, 24 Mar 2025 02:01:22 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>《AppGallery 版本升級，好用小妙招請查收》</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;近期,鴻蒙應用市場（AppGallery）已升級到 6.0.2 版本。新版本帶來了哪些全新變化和實用小技巧？想要一鍵找到同類型更多應用，並同時高速下載，有什麼好方法呢？本期的跟手教程別錯過！&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;一、「應用更新」優化，長長的更新列表「不見了」&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;針對有用戶提到在「我的」頁面中看到「應用更新」展示的列表太長、佔版面等問題，新版本的 AppGallery 進行了優化。目前進入進入「應用市場&amp;gt;我的」你會發現頁面更清爽、長串的待更新應用列表不見了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;那更新列表去哪裏了呢？點擊進入「應用更新」，你可看到：應用更新列表在這裏，且已分成了「待更新」和「最近已更新」兩部分展示。「待更新」可提醒大家進行應用升級，「最近已更新」列表能幫助大家隨時查看更新記錄，瞭解應用更新後的新特性。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;此外，當所有應用均為最新版本時，在「我的」頁面就可以直接看到相應的提示，這對於有 「應用更新強迫症」的朋友來説無疑是一個福音。&amp;nbsp;&amp;nbsp;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;2.png&quot; height=&quot;333&quot; src=&quot;https://oscimg.oschina.net/oscnet//9a443ec842a34c20c679ca60a3ce582a.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;二、一鍵可達同類應用列表&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;接下來的小技巧，必須要敲黑板了！首先新版本的 AppGallery 在應用頁增加了&lt;strong&gt;腰部分類膠囊&lt;/strong&gt;的模塊，提供了超過 20 個分類膠囊，大家可以通過滑動選擇感興趣的膠囊，找到同類型應用列表；比如點擊了「房產與裝修」膠囊，常用的找房和裝修類 App&amp;nbsp;就出現眼前了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;同類應用太多，該怎麼選？可以看看 AppGallery 給你哪些推薦和實用解題思路。回到「房產與裝修」列表中，隨機選擇《貝殼找房》進入詳情頁，詳情頁下方可找到「相關專題」欄目，打開專題內容瀏覽，獲取使用技巧，如利用《貝殼找房》搜索短租的資源等。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;讓探索更高效，為你的選擇提供更有價值的參考，這麼好用的技巧要是不知道可真太浪費了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;3.png&quot; height=&quot;610&quot; src=&quot;https://oscimg.oschina.net/oscnet//ec965fbc9f249d96b8a34c622b1d7a69.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;三、應用同時下載能力增強&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;本次更新後， AppGallery 最多可支持同時下載或更新 3 個應用，這一改進將極大地提升大家在使用新機或有批量下載需求時的效率。眾所周知，HarmonyOS 5 應用下載速度和使用流暢度都有了很大的提升，如今可支持同時下載多個應用，必然會給大家帶來加倍的便利和快樂。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;4.png&quot; height=&quot;735&quot; src=&quot;https://oscimg.oschina.net/oscnet//b3a69f29699edeac988ee2b7dc1dae46.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;四、橫滑一下，就可獲取更多應用信息&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;在 AppGallery 版本升級後，應用詳情頁悄悄發生了變化。在應用信息欄的位置，輕輕往左一滑，就能看到應用分類、開發者信息和應用包體大小，針對「一眼鎖定」應用的用戶來説可幫了大忙，不用再滑到下面去檢索信息。這雖然是一個非常小的改變，但在為用戶檢索應用時，提供了更多參考維度。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;還要告訴你一個小技巧，應用分類的圖標就是一個分類膠囊，點擊後即可輕鬆進入同類應用列表了。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:center&quot;&gt;&lt;img alt=&quot;5.png&quot; height=&quot;802&quot; src=&quot;https://oscimg.oschina.net/oscnet//2b4db5f745415945cac452a69f850590.png&quot; width=&quot;600&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;&lt;strong&gt;五、「下載記錄」和「購買記錄」中的應用操作辦法&lt;/strong&gt;&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;最後一點可能對應用發燒友來説更感興趣，新版本的 AppGallery 除了能夠常規的管理應用下載記錄（長按操作）和購買記錄（滑動操作）之外，大家還可以隨時取消之前添加的「心願單」應用，這一功能雖然不常用，但也可解用戶所需。&lt;/p&gt; 
&lt;p style=&quot;color:#555555; margin-left:0; margin-right:0; text-align:left&quot;&gt;以上就是 AppGallery6.0.2 版本更新的實用小妙招。如果大家還在使用舊版本，不妨趕緊更新體驗一下。當然，AppGallery 的寶藏功能遠不止這些，更多驚喜等待你去探索發現！&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340252</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340252</guid>
            <pubDate>Fri, 21 Mar 2025 10:14:00 GMT</pubDate>
            <author>來源: 投稿</author>
        </item>
        <item>
            <title>OpenAI CEO 奧特曼 ：DeepSeek 教訓了我們，GPT-5 將免費開放</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;日前，&amp;nbsp;OpenAI CEO 奧特曼在與硅谷知名分析師 Ben Thompson&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fstratechery.com%2F2025%2Fan-interview-with-openai-ceo-sam-altman-about-building-a-consumer-tech-company%2F&quot; target=&quot;_blank&quot;&gt;對談&lt;/a&gt;&lt;/u&gt;中提到 DeepSeek。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/164748_HXaN_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;奧特曼認為 DeepSeek 確實是個很棒的團隊，也做出了很優秀的模型，&lt;strong&gt;但他們真正走紅的原因，並不完全是模型本身的能力&lt;/strong&gt;。&lt;br&gt; &amp;nbsp;&lt;br&gt; 「這對我們來説是一個教訓，那就是當我們隱藏一個功能時（思維鏈），我們給其他人留下了獲得病毒式傳播的機會。這是一個很好的警醒。它也讓我重新思考我們在免費層中提供的內容， GPT-5 將可以免費使用」，奧特曼這樣看 DeepSeek 的走紅。&lt;/p&gt; 
&lt;p style=&quot;color:#333333; margin-left:0; margin-right:0; text-align:justify&quot;&gt;奧特曼表示，OpenAI 其實早就有類似能力，只是過去出於謹慎考慮沒有對外開放，怕太智能會變得不可控。但現在回頭看，這種「保守」反而錯失了機會，「我們做的模型更好，但大家沒注意到，反而被別人搶走了注意力」，他還透露，GPT-5 會加入更多功能，思維鏈、聯網搜索、甚至更長記憶都有可能下放，算是一個明顯的轉向。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338735/openai-calls-deepseek-state-controlled&quot; target=&quot;news&quot;&gt;OpenAI 呼籲美國政府禁止 DeepSeek&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/338329/openai-chain-of-thought-monitoring&quot; target=&quot;news&quot;&gt;OpenAI 透露 CoT 思維鏈研究成果：CoT 監控可阻止大模型惡意行為&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/336125/openai-gpt-4-5&quot; target=&quot;news&quot;&gt;OpenAI 正式發佈 GPT-4.5 模型&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340236</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340236</guid>
            <pubDate>Fri, 21 Mar 2025 08:48:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>馬斯克：2024 年特斯拉 AI 投資約 100 億美元、FSD 安全水平將超過人類</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;特斯拉公司 CEO 埃隆・馬斯克今天在員工大會上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FCernBasher%2Fstatus%2F1902918128876544315&quot; target=&quot;_blank&quot;&gt;分享&lt;/a&gt;&lt;/u&gt;了公司在電動汽車、儲能、智能輔助駕駛、人工智能計算及人形機器人等業務板塊的最新動態。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-39bef0ad1f0e3c05326afa6e48d068ce7c8.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;馬斯克稱，特斯拉用於智能輔助駕駛訓練的 Cortex 算力中心目前已有超過 5 萬塊 GPU，且即將突破 10 萬塊大關，躋身全球前五大超級計算中心。&lt;/p&gt; 
&lt;p&gt;此外，Dojo 2 超級計算機即將問世，其將比第一代 Dojo 超級計算機強大 10 倍。目前，Dojo 超級計算機已在紐約超級工廠投入運行，承擔了特斯拉 5% 至 10% 的智能輔助駕駛訓練數據量。&lt;/p&gt; 
&lt;p&gt;馬斯克透露，2024 年特斯拉在人工智能方面的投資約達 100 億美元（現匯率約合 724.51 億元人民幣），其中約一半為內部投入，主要用於特斯拉自研的 AI 推理計算機、所有車輛傳感器以及 Dojo 超級計算機。&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-caf53effe89e63245f2c7f3bdf2d0223c1b.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;特斯拉全系現款在售車型均已搭載 AI 4 智能輔助駕駛硬件。儘管 AI 4 硬件設計於數年前，但至今仍無同類產品超越其性能。AI 4 不僅性能強大，且能耗極低。&lt;strong&gt;未來幾年，特斯拉將推出 AI 5、AI 6、AI 7 硬件&lt;/strong&gt;，但馬斯克強調，消費者不應因此延遲購買，因為特斯拉的技術進化永無止境，早入手即可早享受，現階段的 AI 4 對於特斯拉智能輔助駕駛硬件來説已經足夠。&lt;/p&gt; 
&lt;p&gt;馬斯克還表示，特斯拉的智能輔助駕駛系統在行駛過程中所需的幹預越來越少，&lt;strong&gt;最終將完全無需人工幹預，且行駛安全水平將超過人類駕駛，達到比人類安全 10 倍的水平&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;目前，在北美地區，特斯拉的智能輔助駕駛系統（北美稱 FSD）已經能夠實現從弗裏蒙特工廠下線的車輛在無人駕駛情況下自行開往目的地停車場，等待裝車長途運輸。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/339990/blackrock-ai-infrastructure-partnership&quot; target=&quot;news&quot;&gt;馬斯克 xAI 和微軟、貝萊德等組成新聯盟，共建 300 億美元 AI 基礎設施項目&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/334522/xai-grok3&quot; target=&quot;news&quot;&gt;馬斯克旗下 xAI 發佈 Grok 3 推理模型，聲稱超越 o1、R1&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340233</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340233</guid>
            <pubDate>Fri, 21 Mar 2025 08:38:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Minesweeper MCP Server —— 掃雷 MCP 服務器</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p&gt;Minesweeper MCP Server 是一個掃雷 MCP 服務器，讓 Claude 可以玩掃雷遊戲。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-0d7a16d356b0beb3c58ab8498176657e2fd.gif&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/minesweeper-mcp-server</link>
            <guid isPermaLink="false">https://www.oschina.net/p/minesweeper-mcp-server</guid>
            <pubDate>Fri, 21 Mar 2025 08:32:00 GMT</pubDate>
        </item>
        <item>
            <title>劉強東：技術算法不應壓榨最底層兄弟</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;3 月 21 日，據網傳截圖顯示，近日劉強東在朋友圈發文評價京東為快遞員繳納五險一金一事，對此，界面新聞向京東求證，對方回應，截圖內容屬實。劉強東稱，去年是創業 20 年以來最有成就感的時候，因為僅僅快遞小哥就有 1200 多個兄弟退休了。每人可領取數十萬公積金、每月 5350 元退休金，並享受醫保全覆蓋。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;劉強東稱，我們所學的知識、商業模式、技術算法都不應該是用來壓榨社會最底層的兄弟們的，我們的利潤、市值和財富更不應該建立在底層百姓無保障的生活之上的。&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;div style=&quot;text-align:start&quot;&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;劉強東呼籲所有快遞員和騎手都可以獲得五險一金待遇，因為今天中國幾大平台的利潤和市值完全可以支撐，期待各階層一起幸福生活。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;color:#222222; margin-left:0; margin-right:0&quot;&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img height=&quot;512&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/163026_g23O_4252687.png&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340231</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340231</guid>
            <pubDate>Fri, 21 Mar 2025 08:30:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>瀏覽器崩潰的第一性原理：內存管理的藝術</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                    
                                                                                                                                                    &lt;div class=&quot;rich_media_content js_underline_content
                       autoTypeSetting24psection
            &quot; id=&quot;js_content&quot;&gt; 
 &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;79&quot; data-source-title=&quot;&quot;&gt; 
  &lt;section class=&quot;js_blockquote_digest&quot;&gt; 
   &lt;section&gt;
     你是否曾經遇到過瀏覽器突然卡頓，甚至崩潰的情況？尤其是在打開多個標籤頁或運行復雜的網頁應用時，瀏覽器似乎變得異常脆弱。這種崩潰的背後，往往與內存管理息息相關。 
   &lt;/section&gt; 
  &lt;/section&gt; 
 &lt;/blockquote&gt; 
 &lt;section style=&quot;text-indent: 0em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;瀏覽器的內存管理機制決定了它能否高效地分配和釋放資源，而 JavaScript 引擎 V8 正是這一機制的核心。&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;本文將探討 V8 的內存管理機制，幫助你理解瀏覽器崩潰的根源，並學會如何優化內存使用，避免類似問題的發生。&lt;/span&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_1&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;3&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;一、內存管理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;底層語言（如 C 語言）擁有手動的內存管理原語，例如：&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;ree()&lt;/span&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;。相反，JavaScript 是在創建對象時自動分配內存，並在不再使用時自動釋放內存（垃圾回收）。這種自動化機制雖然方便，但也容易讓我們產生誤解，認為不需要關心內存管理，從而忽略潛在的內存問題。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_2&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;5&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;二、內存生命週期&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;無論使用何種編程語言，內存的生命週期通常都遵循以下步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ul data-nodeid=&quot;7&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;182&quot;&gt;分配內存&lt;/strong&gt;：根據需求分配所需的內存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;187&quot;&gt;使用內存&lt;/strong&gt;：對分配的內存進行讀寫操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;192&quot;&gt;釋放內存&lt;/strong&gt;：在內存不再需要時將其釋放。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;在底層語言中，內存的分配和釋放是顯式的，開發者需要手動管理。而在高級語言如 JavaScript 中，內存的分配和釋放大多是隱式的，由垃圾回收機制自動處理。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h3_3&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;15&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1 內存分配&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_4&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;16&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.1.1 值的初始化&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;為了不讓我們費心內存分配，JavaScript 在值初次聲明時自動分配內存。&lt;/span&gt;&lt;/p&gt; 
 &lt;pre data-nodeid=&quot;18&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;28&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為數值分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為字符串分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; o = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為對象及其包含的值分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 為數組及其包含的值分配內存（就像對象一樣）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yongtao&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; a + &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為函數（可調用的對象）分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 函數表達式也會分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;someElement.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;click&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    someElement.style.backgroundColor = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_5&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;19&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2.1 通過函數調用分配內存&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些函數調用的結果是為對象分配內存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;21&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; d = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Date&lt;/span&gt;(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為 Date 對象分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; e = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.createElement(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;div&quot;&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 為 DOM 元素分配內存&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有些方法為新值或新對象分配內存：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;23&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;azerty&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; s2 = s.substr(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// s2 是一個新的字符串&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 因為字符串是不可變的值，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// JavaScript 可能決定不分配內存，&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 只是存儲了 [0-3] 的範圍。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yeah yeah&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a2 = [&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;generation&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;no no&quot;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a3 = a.concat(a2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 有四個元素的新數組，由 a 和 a2 其中的元素連接而成。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h3_6&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;24&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.2 變量讀取&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用值通常涉及對分配的內存進行讀寫操作。無論是讀取變量值、訪問對象屬性，還是傳遞函數參數，都會使用到內存中的值。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_7&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;26&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;2.3 內存回收（垃圾回收）&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;當內存不再需要時，系統會將其釋放。大多數內存管理問題都出現在這一階段，尤其是如何確定已分配的內存何時不再需要。在底層語言中，開發者需要手動判斷並釋放內存，而 JavaScript 則通過垃圾回收機制自動完成這一任務。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_8&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;28&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;三、V8 的垃圾回收&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;垃圾回收的核心任務是識別內存中的「死區」，即不再使用的內存。一旦識別出這些區域，它們可以被重新用於新的內存分配或釋放回操作系統。一個對象如果不再被根對象或活躍對象引用，則被視為「死的」。根對象通常是活躍的，例如局部變量、全局對象或瀏覽器對象（如 DOM 元素）。&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;例如：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;31&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; obj = { &lt;span class=&quot;code-snippet__attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  g(); &lt;span class=&quot;code-snippet__comment&quot;&gt;// might contain an infinite loop.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; obj.x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於無法精確判斷對象是否會被再次引用（這相當於停機問題），垃圾回收器採用了一種寬鬆的定義：如果對象可以通過某個指針鏈從根對象到達，則該對象是活躍的，否則就是垃圾。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_9&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;33&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.1 V8 內存結構&lt;/span&gt;&lt;/h3&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;V8 的內存分為以下幾個主要部分：&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028741&quot; data-ratio=&quot;0.7166882276843467&quot; src=&quot;https://oscimg.oschina.net/oscnet/ca11da54-bc8b-4a09-9c14-3c4399c0411a.png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;35&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;219&quot;&gt;堆內存（Heap）&lt;/strong&gt;：&lt;br&gt;堆內存是 V8 中用於動態分配內存的區域，存儲 JavaScript 對象、閉包、函數等數據。堆內存進一步分為以下幾個區域：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;38&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;226&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;新生代&lt;/span&gt;&lt;/strong&gt;：用於存儲生命週期較短的對象（如臨時變量、局部變量等）。分為兩個半空間（From Space 和 To Space），採用 Scavenge 算法進行垃圾回收。新生代空間較小，垃圾回收頻率較高。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;233&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;老生代&lt;/span&gt;&lt;/strong&gt;：：用於存儲生命週期較長的對象（如全局變量、閉包等）。採用標記-清除（Mark-Sweep）和標記-整理（Mark-Compact）算法進行垃圾回收。老生代空間較大，垃圾回收頻率較低。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;240&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;代碼空間&lt;/span&gt;&lt;/strong&gt;：專門用於存儲 JIT（Just-In-Time）編譯生成的機器代碼。代碼空間與其他空間分離，因為代碼的生命週期通常較長，且需要高效訪問。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;247&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;大對象空間&lt;/span&gt;&lt;/strong&gt;：用於存儲較大的對象（如大數組、大字符串），避免頻繁複制。採用標記-清除和標記-整理算法進行垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;254&quot;&gt;&lt;span style=&quot;font-size: 16px;color: rgb(38, 107, 246);&quot;&gt;單元空間、屬性單元空間和映射空間&lt;/span&gt;&lt;/strong&gt;：些空間分別包含 Cells、PropertyCells 和 Maps。每個空間都包含大小相同的對象，並且對它們指向的對象類型有一定的限制，從而簡化了垃圾回收。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;260&quot;&gt;棧內存（Stack）&lt;/strong&gt;&lt;br&gt;棧內存用於存儲函數調用時的局部變量、參數和返回地址。棧內存的特點是分配和釋放速度快，但空間有限。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h3_10&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;51&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2 V8 垃圾回收機制&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_11&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;52&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.1 棧數據的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028742&quot; data-ratio=&quot;0.4969097651421508&quot; src=&quot;https://oscimg.oschina.net/oscnet/dd9587a0-84da-4c35-ab5e-3b2f0a559e6e.png&quot; data-type=&quot;png&quot; data-w=&quot;1618&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;棧數據的「垃圾回收」是通過函數調用和返回機制自動完成的。棧幀的內存釋放是隱式的，棧是連續的內存區域，內存分配和釋放通過指針移動實現。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;55&quot; style=&quot;text-align: left;&quot;&gt;&lt;code&gt;
   
   
   &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;38&quot; data-source-title=&quot;&quot;&gt;
 
    
    
    &lt;section class=&quot;js_blockquote_digest&quot;&gt;
  
     
     
     &lt;section&gt;
      
      
      
   為什麼需要區分「堆」和「棧」兩個存儲空間？為什麼不將所有數據直接存放在棧中？
  
     
     
     &lt;/section&gt;
 
    
    
    &lt;/section&gt;

   
   
   &lt;/blockquote&gt;&lt;/code&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;JavaScript 引擎需要用棧來維護程序執行期間的上下文狀態。如果棧空間過大，所有數據都存放在棧中，會影響上下文切換的效率，進而影響整個程序的執行效率。例如，當函數執行結束時，JavaScript 引擎只需將指針下移到上一個執行上下文的地址即可，棧幀的內存會自動回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_12&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;57&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;3.2.2 堆數據的垃圾回收&lt;/span&gt;&lt;/h4&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;代際假説是垃圾回收領域的一個重要理論，V8 的垃圾回收策略正是基於這一假説。代際假説包含兩個核心觀點：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;59&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;大多數對象的生命週期很短，分配後很快變得不可訪問。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;少數對象會存活較長時間。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;基於此，V8 將堆內存分為新生代和老生代兩個區域。新生代存放生命週期短的對象，老生代存放生命週期長的對象。V8 的垃圾回收器分為主垃圾回收器和副垃圾回收器。&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h5_13&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;65&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;副垃圾回收器主要負責新生代的垃圾回收。由於大多數小對象都分配在新生代，因此該區域的垃圾回收頻率較高。&lt;br&gt;新生代採用 Scavenge 算法，進行垃圾回收。該算法將新生代空間對半劃分為對象區域和空閒區域。&lt;br&gt;&lt;/span&gt;&lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028740&quot; data-ratio=&quot;0.5777063236870311&quot; src=&quot;https://oscimg.oschina.net/oscnet/20a6d122-d24b-4ae0-90ec-ec263472ba5c.png&quot; data-type=&quot;png&quot; data-w=&quot;933&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;br&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;新加入的對象存放在對象區域。當對象區域快滿時，副垃圾回收器會執行以下步驟：&lt;/span&gt;&lt;/p&gt; 
 &lt;ol data-nodeid=&quot;67&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;標記對象區域中的存活對象。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;將存活對象複製到空閒區域，並有序排列，消除內存碎片。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;角色翻轉：對象區域變為空閒區域，空閒區域變為對象區域。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於 &lt;strong data-nodeid=&quot;298&quot;&gt;Scavenge 算法&lt;/strong&gt;需要複製存活對象，如果新生代空間過大，複製操作會耗費較多時間。因此，新生代空間通常較小。為了應對新生代空間不足的問題，V8 採用了對象晉升策略：經過兩次垃圾回收後仍然存活的對象會被移動到老生代。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_14&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;75&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;主垃圾回收器：&lt;/span&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;老生代的對象通常較大，使用 &lt;strong data-nodeid=&quot;313&quot;&gt;Scavenge 算法&lt;/strong&gt;進行垃圾回收效率較低。因此，主垃圾回收器採用&lt;strong data-nodeid=&quot;314&quot;&gt;標記-清除&lt;/strong&gt;和&lt;strong data-nodeid=&quot;315&quot;&gt;標記-整理&lt;/strong&gt;算法。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;標記-清除：首先是標記過程階段。標記階段就是從一組根元素開始，遞歸遍歷調用棧，在這個遍歷過程中，能到達的元素稱為活動對象，沒有到達的元素就可以判斷為垃圾數據。標記過程和清除過程就是標記 - 清除算法 Mark-Sweep ，不過對一塊內存多次執行標記 - 清除算法後，會產生大量不連續的內存碎片。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028743&quot; data-ratio=&quot;0.4945770065075922&quot; src=&quot;https://oscimg.oschina.net/oscnet/ed116503-4d1e-493b-8d7f-3457262b4501.png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;碎片過多會導致大對象無法分配到足夠的連續內存，於是又產生了另外一種算法—標記-整理（Mark-Compact）&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;這個標記過程仍然與標記 - 清除算法裏的是一樣的，但後續步驟不是直接對可回收對象進行清理，而是讓所有存活的對象都向一端移動，然後直接清理掉端邊界以外的內存。V8 研究團隊 2016 年的一篇博文：在一次完整的垃圾回收之後，V8 的堆增長策略會根據活動對象的數量外加一些餘量來確定何時再進行垃圾回收。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028739&quot; data-ratio=&quot;0.4106029106029106&quot; src=&quot;https://oscimg.oschina.net/oscnet/7d262ac7-2d6e-4dff-9074-41b2a5be869f.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h5_15&quot;&gt;&lt;/span&gt; 
 &lt;h5 data-nodeid=&quot;80&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;全停頓和增量標記&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;由於 JavaScript 是運行在主線程之上的，一旦執行垃圾回收算法，都需要將正在執行的 JavaScript 腳本暫停下來，待垃圾回收完畢後再恢復腳本執行。我們把這種行為叫做全停頓（Stop-The-World）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;有研究數據表明，如果堆中的數據有 1.5GB，V8 實現一次完整的垃圾回收需要 1 秒以上的時間，這也是由於垃圾回收而引起 JavaScript 線程暫停執行的時間，若是這樣的時間花銷，那麼應用的性能和響應能力都會直線下降。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028745&quot; data-ratio=&quot;0.2915506035283194&quot; src=&quot;https://oscimg.oschina.net/oscnet/e32c7d49-8a28-410a-a60f-f0f1f13ba6dc.png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;83&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section style=&quot;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;
   
   
   &lt;code&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果在執行垃圾回收的過程中，佔用主線程時間過久，就像上面圖片展示的那樣，花費了 200 毫秒，在這 200 毫秒內，主線程是不能做其他事情的。比如頁面正在執行一個 JavaScript 動畫，因為垃圾回收器在工作，就會導致這個動畫在這 200 毫秒內無法執行的，這將會造成頁面的卡頓現象。&lt;br&gt;&lt;/span&gt;&lt;/code&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;為了降低老生代的垃圾回收而造成的卡頓，V8 將標記過程分為一個個的子標記過程，同時讓垃圾回收標記和 JavaScript 應用邏輯交替進行，直到標記階段完成，我們把這個算法稱為增量標記（Incremental Marking）算法，&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028744&quot; data-ratio=&quot;0.3201663201663202&quot; src=&quot;https://oscimg.oschina.net/oscnet/0d30149e-d536-4d77-ac3a-0c1865d98a4b.png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用增量標記算法，可以把一個完整的垃圾回收任務拆分為很多小的任務，這些小的任務執行時間比較短，可以穿插在其他的 JavaScript 任務中間執行，這樣當執行上述動畫效果時，就不會讓用戶因為垃圾回收任務而感受到頁面的卡頓了。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h2_16&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;86&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;四、內存泄漏與優化&lt;/span&gt;&lt;/h2&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;內存泄漏（Memory Leak）是指程序中已動態分配的堆內存由於某種原因程序未釋放或無法釋放，造成系統內存的浪費，導致程序運行速度減慢甚至系統崩潰等嚴重後果。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_17&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;88&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1 常見的內存泄漏場景及優化方案&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_18&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;89&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.1 意外的全局變量&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未使用 var、let 或 const 聲明的變量會隱式變為全局變量，直到頁面關閉才會被釋放。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;92&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;leak&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  leakedVar = &lt;span class=&quot;code-snippet__string&quot;&gt;&#39;This is a global variable&#39;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 意外的全局變量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;351&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;始終使用 var、let 或 const 聲明變量。啓用嚴格模式（&quot;use strict&quot;），避免意外創建全局變量。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_19&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;94&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.2 未清理的定時器或回調函數&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未清除的 setInterval 或 setTimeout 會持續持有引用，導致相關對象無法被回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;97&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; data = getData();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;setInterval(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  process(data); &lt;span class=&quot;code-snippet__comment&quot;&gt;// data 一直被引用，無法釋放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;360&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 clearInterval 或 clearTimeout 清除定時器。在組件銷燬或頁面卸載時清理定時器。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_20&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;99&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.3 未解綁的事件監聽器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;未移除的事件監聽器會持續持有對 DOM 元素或對象的引用，導致內存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;102&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; button = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myButton&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;button.addEventListener(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;click&#39;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;Button clicked&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果 button 被移除，但未解綁事件監聽器，會導致內存泄漏&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;369&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 removeEventListener 解綁事件監聽器。在組件銷燬或頁面卸載時解綁事件。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_21&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;104&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.4 閉包中的引用&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;閉包會捕獲外部函數的變量，如果閉包未被釋放，這些變量也會一直存在。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;107&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;createClosure&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; largeData = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1000000&lt;/span&gt;).fill(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;data&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(largeData[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;]); &lt;span class=&quot;code-snippet__comment&quot;&gt;// largeData 一直被閉包引用&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; closure = createClosure();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;378&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;免在閉包中捕獲不必要的變量。在不再需要閉包時，手動解除引用（例如將閉包設置為 null）。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h4_22&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;109&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.5 DOM 引用未釋放&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;如果 JavaScript 中保留了 DOM 元素的引用，即使該元素從頁面中移除，也無法被垃圾回收。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;112&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; element = &lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;code-snippet__string&quot;&gt;&#39;myElement&#39;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;document&lt;/span&gt;.body.removeChild(element); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 從 DOM 中移除&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// element 仍然被引用，無法釋放&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;387&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;在移除 DOM 元素後，將其引用設置為 null：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;114&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;element&lt;/span&gt; = null;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;span id=&quot;OSC_h4_23&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;115&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.1.6 緩存未清理&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;緩存對象（如 Map 或 WeakMap）如果未正確清理，會導致內存泄漏。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;示例：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;pre data-nodeid=&quot;118&quot; style=&quot;text-align: left;&quot;&gt;  
  
  &lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;
   
   
   &lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; cache = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;setCache&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;key, value&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cache.set(key, value);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// 如果緩存未清理，會持續增長&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
  
  
  &lt;/section&gt;&lt;/pre&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;strong data-nodeid=&quot;396&quot;&gt;優化：&lt;/strong&gt;&lt;br&gt;使用 WeakMap 或 WeakSet，它們不會阻止鍵對象的垃圾回收。定期清理緩存。&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;span id=&quot;OSC_h3_24&quot;&gt;&lt;/span&gt; 
 &lt;h3 data-nodeid=&quot;120&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2 內存泄漏檢查&lt;/span&gt;&lt;/h3&gt; 
 &lt;span id=&quot;OSC_h4_25&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;121&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.1 使用 Chrome 任務管理器&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 自帶的任務管理器可以幫助你快速發現內存佔用異常的任務。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;內存&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028747&quot; data-ratio=&quot;0.6096885813148789&quot; src=&quot;https://oscimg.oschina.net/oscnet/4a266a6f-5f33-4576-8745-89dbad18ebff.png&quot; data-type=&quot;png&quot; data-w=&quot;2890&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;124&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打開 Chrome 任務管理器：點擊 Chrome 右上角的三個點（菜單按鈕） &amp;gt; 更多工具 &amp;gt; 任務管理器。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查看內存佔用：關注內存佔用異常高的任務（如標籤頁、擴展程序、輔助框架等）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;檢查內存增長：觀察某個任務的內存佔用是否持續增長（即使頁面沒有操作）。如果某個任務的內存佔用不斷增加，可能是內存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_26&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;131&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.2 使用 Chrome 開發者工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Chrome 的開發者工具提供了強大的內存分析功能，可以幫助你定位內存泄漏。&lt;br&gt;&lt;/span&gt; 
  &lt;img alt=&quot;&quot; class=&quot;rich_pages wxw-img&quot; data-imgfileid=&quot;100028746&quot; data-ratio=&quot;0.6623970722781336&quot; src=&quot;https://oscimg.oschina.net/oscnet/243ee5e7-4a79-4326-8fd1-68e8488a7f46.png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot; referrerpolicy=&quot;no-referrer&quot;&gt; 
  &lt;br&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;步驟：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;133&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;打開開發者工具：右鍵點擊頁面，選擇，檢查，或者使用快捷鍵：Ctrl + Shift + I（Windows/Linux）或 Cmd + Option + I（Mac）。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;使用 Memory 面板：切換到 Memory 標籤。選擇以下工具之一進行分析：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;138&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Heap Snapshot：拍攝堆內存快照，分析內存分配情況。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation instrumentation on timeline：記錄內存分配的時間線，查看內存增長情況。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Allocation sampling：通過採樣分析內存分配。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;分析內存泄漏：&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;ul data-nodeid=&quot;147&quot; class=&quot;list-paddingleft-1&quot;&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;拍攝多個堆內存快照，比較快照之間的內存變化。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;查找未被釋放的對象（如 DOM 節點、事件監聽器等）。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
   &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
    &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
     &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;檢查 Retainers（持有者），找到導致內存泄漏的代碼。&lt;/span&gt; 
    &lt;/section&gt;&lt;/li&gt; 
  &lt;/ul&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h4_27&quot;&gt;&lt;/span&gt; 
 &lt;h4 data-nodeid=&quot;154&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;4.2.3 使用第三方工具&lt;/span&gt;&lt;/h4&gt; 
 &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;除了 Chrome 自帶的工具，還可以使用以下第三方工具進行內存分析：&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;ol data-nodeid=&quot;156&quot; class=&quot;list-paddingleft-1&quot;&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;Lighthouse：Chrome 的 Lighthouse 工具可以檢測頁面性能問題，包括內存泄漏。&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
  &lt;li style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;MemLab：Facebook 開源的 JavaScript 內存分析工具，專門用於檢測內存泄漏。&lt;/span&gt; 
   &lt;/section&gt; 
   &lt;section style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt; 
    &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;/span&gt; 
   &lt;/section&gt;&lt;/li&gt; 
 &lt;/ol&gt; 
 &lt;span id=&quot;OSC_h2_28&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;161&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;五、從崩潰到優化：內存管理的終極目標&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;瀏覽器的崩潰往往源於內存管理的不足，而 V8 引擎的內存管理機制正是解決這一問題的關鍵。通過理解 V8 的內存分配、垃圾回收機制以及常見的內存泄漏場景，我們可以更好地優化代碼，避免內存浪費和性能瓶頸。無論是開發者還是普通用戶，瞭解這些原理都能幫助我們更好地應對瀏覽器崩潰問題，提升應用的整體性能和用戶體驗。&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;span id=&quot;OSC_h2_29&quot;&gt;&lt;/span&gt; 
 &lt;h2 data-nodeid=&quot;163&quot; style=&quot;text-align: left;text-indent: 0em;line-height: 1.6em;margin-bottom: 8px;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;六、 總結&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;本文通過從常見的瀏覽器崩潰場景引出本篇文章的分享主題：V8 的內存管理， 文章主要介紹了 V8 垃圾回收的原理、常見的內存泄漏場景及其預防方案。&lt;/span&gt;&lt;/p&gt; 
 &lt;p style=&quot;text-align: left;line-height: 1.6em;margin-bottom: 8px;text-indent: 2em;&quot;&gt;&lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;最後，最重要的一點：歡迎評論區互動，一起交流學習，共同成長&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;font-size: 16px;letter-spacing: normal;&quot;&gt;&lt;img alt=&quot;圖片&quot; class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-imgfileid=&quot;100028749&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; src=&quot;https://oscimg.oschina.net/oscnet/fc371ec9-2b7f-4b7f-b317-4e6e306662bf.png&quot; data-type=&quot;webp&quot; data-w=&quot;396&quot; style=&quot;pointer-events: initial;width: 185px !important;visibility: visible !important;height: auto !important;&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;section style=&quot;text-align: center;margin-bottom: 8px;&quot;&gt; 
  &lt;span style=&quot;margin: 0px;padding: 0px;outline: 0px;max-width: 100%;box-sizing: border-box;overflow-wrap: break-word !important;font-size: 16px;border-width: 0px;border-style: solid;border-color: rgb(235, 238, 245);letter-spacing: normal;&quot;&gt;掃一掃，加入技術交流羣&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 16px;&quot;&gt;&lt;/span&gt; 
  &lt;span style=&quot;letter-spacing: normal;font-size: 12px;&quot;&gt;&lt;br&gt;&lt;/span&gt; 
 &lt;/section&gt; 
 &lt;p style=&quot;display: none;&quot;&gt; 
  &lt;mp-style-type data-value=&quot;3&quot;&gt;&lt;/mp-style-type&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;p style=&quot;color: #858585; font-size: 13px;&quot;&gt;本文分享自微信公眾號 - 京東雲開發者（JDT_Developers）。&lt;br&gt;如有侵權，請聯繫 support@oschina.cn 刪除。&lt;br&gt;本文參與「&lt;a href=&quot;https://www.oschina.net/sharing-plan&quot; target=&quot;_blank&quot;&gt;OSC 源創計劃&lt;/a&gt;」，歡迎正在閲讀的你也加入，一起分享。&lt;/p&gt;
                                                                                    &lt;/div&gt;
                                                                            </description>
            <link>https://my.oschina.net/u/4090830/blog/17955030</link>
            <guid isPermaLink="false">https://my.oschina.net/u/4090830/blog/17955030</guid>
            <pubDate>Fri, 21 Mar 2025 08:29:00 GMT</pubDate>
            <author>京東雲開發者</author>
        </item>
        <item>
            <title>Linux 內核越界寫入漏洞致權限提升</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcybersecuritynews.com%2Flinux-kernel-out-of-bounds-write-vulnerability%2F&quot; target=&quot;_blank&quot;&gt;Linux 內核存在近 20 年的嚴重漏洞&lt;/a&gt;&lt;/u&gt;，允許本地用戶獲取 root 權限，影響多版本系統。&lt;/p&gt; 
&lt;p&gt;該漏洞被分配的編號為 CVE-2025-0927，在 Linux 內核 HFS+文件系統驅動程序中存在越界寫入漏洞，影響運行至 6.12.0 版本內核的系統，已確認 Ubuntu 22.04 帶有 Linux 內核 6.5.0-18-generic 版本的系統存在漏洞。&lt;/p&gt; 
&lt;p&gt;根據 SSD 的安全公告，該漏洞存在於 HFS+驅動程序中，該驅動程序支持 Apple 的過時文件系統格式，該格式在 2017 年被 APFS 取代之前一直是 MacOS X 的主要文件系統。&lt;/p&gt; 
&lt;p&gt;該漏洞自初始 git 倉庫構建 1da177 以來一直存在，並且自 Linux 內核 2.6.12-rc2 版本以來一直未被檢測到。&lt;/p&gt; 
&lt;p&gt;該漏洞的核心在於 B 樹節點處理中的緩衝區溢出。易受攻擊的函數 fs/hfsplus/bnode.c 中的 hfs_bnode_read_key 未能正確驗證鍵大小的邊界條件：&lt;/p&gt; 
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-2f9a4d0f8d837764ff162322f00ccb86e82.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;在該代碼中，函數未實現適當的邊界檢查，允許攻擊者觸發越界寫操作，從而破壞內核內存。&lt;/p&gt; 
&lt;p&gt;Ubuntu 已發佈修復程序，管理員需立即更新。&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340228/inux-kernel-out-of-bounds-write-vulnerability</guid>
            <pubDate>Fri, 21 Mar 2025 08:28:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>AI 組件 ComfyUI 易被黑產盯上</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;隨着近幾年大模型的迅猛發展，以及安全對抗技術的持續迭代升級，黑產團夥逐漸將攻擊目標從傳統服務轉移到了 AI 相關服務。&lt;/p&gt; 
&lt;p&gt;近日，百度安全團隊捕獲到了一起&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FIPzuok7ej_ghTn59R9PRbA&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;針對大模型相關組件 ComfyUI 的攻擊事件&lt;/strong&gt;&lt;/a&gt;&lt;/u&gt;，經過深入分析，該事件背後團夥已實際針對國內不少公網 ComfyUI 進行了入侵。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;關於 ComfyUI&lt;/strong&gt;&lt;/p&gt; 
 &lt;p&gt;‌ComfyUI 是一款基於節點流程的 Stable Diffusion 操作界面，專為圖像生成任務設計。‌它通過將深度學習模型的工作流程簡化為圖形化節點，使用戶操作更加直觀和易於理解。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 提供了高度的可視化和擴展性，用戶可以通過拖放操作來構建和調整圖像生成流程，無需編寫代碼。‌作為大模型圖像生成領域的最熱門框架之一，其在 GitHub 斬獲了接近 7W Star，備受開發者喜愛，根據網絡空間測繪數據，全網共有近 2700 例 ComfyUI 服務，其中不乏無需密碼直接訪問的案例。&lt;/p&gt; 
 &lt;p&gt;ComfyUI 後台支持加載用戶指定的模型文件，同時用戶可以方便地管理模型。但給用戶帶來便利的同時，也存在一些安全隱患。&lt;/p&gt; 
 &lt;p&gt;&lt;img height=&quot;376&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161939_EGHc_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;百度安全在捕獲的攻擊事件中發現，攻擊者利用 ComfyUI 用戶錯誤配置問題，在無需認證的情況下進入到 ComfyUI 後台，同時利用後台模型加載功能安裝攻擊者提前上傳在 Hugging Face 的投毒模型文件，以便利用模型加載時的 pickle 反序列化邏輯，控制受害者機器，進一步滲透目標內網。&lt;/p&gt; 
&lt;p&gt;本次事件攻擊者主要利用了 ComfyUI 控制枱無身份鑑權的配置錯誤問題進入控制後台，並通過 ComfyUI-Manager 插件中的遠程下載功能從 Hugging Face 及其鏡像站等相關模型倉庫拉取投毒模型（.pth 後綴的文件），使得開發者在使用 ComfyUI 加載投毒模型時會因自身的 pickle 反序列化邏輯觸發惡意的 Loader，進而執行惡意 Bash 腳本，腳本會從攻擊者的服務器上拉取 C2 木馬進行遠程控制，C2 域名為 cloudflare.com 提供給普通用戶使用的隧道服務（用戶可以無需外部域名和 ip 就可以把內網的服務映射到外部），攻擊者濫用該服務，達成隱蔽控制的目的。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;696&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/162047_QvnF_2720166.png&quot; width=&quot;941&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;據 CVE 官方披露，ComfyUI 歷史存在多種漏洞類型，包括：任意文件讀取漏洞、遠程代碼執行漏洞、存儲 XSS 漏洞等。&lt;/p&gt; 
&lt;p&gt;相關漏洞已分配如下 CVE 編號：CVE-2024-10099、CVE-2024-21574、CVE-2024-21575、CVE-2024-21576、CVE-2024-21577。&lt;/p&gt; 
&lt;p&gt;本次事件主要利用的 ComfyUI 默認無身份鑑權機制的&quot;特性&quot;，從而直接訪問 ComfyUI 後台。但該「特性」官方並不認為是安全漏洞，歸因為用戶錯誤配置，在使用上官方始終認為使用者應自行注意，不要將 ComfyUI 對公網暴露或應該通過沙箱環境運行，以確保 ComfyUI 安全。&lt;/p&gt; 
&lt;p&gt;參考&amp;nbsp;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomfyanonymous%2FComfyUI%2Fdiscussions%2F5165&quot; target=&quot;_blank&quot;&gt;https://github.com/comfyanonymous/ComfyUI/discussions/5165&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340226</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340226</guid>
            <pubDate>Fri, 21 Mar 2025 08:21:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>CleanRL —— 深度強化學習庫</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                                                                                                                        
                                                                                    &lt;p style=&quot;text-align:start&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;CleanRL 是一個深度強化學習庫，提供具有研究友好功能的高質量 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;single-file&lt;/span&gt;&amp;nbsp;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;color:#1f2328&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span style=&quot;background-color:#ffffff&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;實現。該實現簡潔明瞭，但我們可以使用 AWS Batch 對其進行擴展以運行數千次實驗。CleanRL 的亮點包括：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span style=&quot;background-color:#ffffff; color:#1f2328&quot;&gt;Single-file&amp;nbsp;&lt;/span&gt;實現

&lt;ul&gt;
&lt;li&gt;關於算法變體的每個細節都被放入一個獨立的文件中。&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;ppo_atari.py&lt;/code&gt;只有 340 行代碼，但包含了 PPO 如何與 Atari 遊戲配合使用的所有實現細節，&lt;strong&gt;因此對於不想閲讀整個模塊庫的人來説，它是一個很好的參考實現&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://benchmark.cleanrl.dev/&quot;&gt;基準測試實施（ https://benchmark.cleanrl.dev&lt;/a&gt;上的 7 種以上算法和 34 種以上游戲）&lt;/li&gt;
&lt;li&gt;Tensorboard&amp;nbsp;Logging&lt;/li&gt;
&lt;li&gt;Local Reproducibility via Seeding&lt;/li&gt;
&lt;li&gt;遊戲視頻捕捉&lt;/li&gt;
&lt;li&gt;利用&lt;a href=&quot;https://wandb.ai/site&quot;&gt;權重和偏差進行實驗管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;與 Docker 和 AWS 進行雲集成&lt;/li&gt;
&lt;/ul&gt;

                                                                    &lt;/div&gt;
                                                                </description>
            <link>https://www.oschina.net/p/cleanrl</link>
            <guid isPermaLink="false">https://www.oschina.net/p/cleanrl</guid>
            <pubDate>Fri, 21 Mar 2025 08:20:00 GMT</pubDate>
        </item>
        <item>
            <title>快手搜索已全面接入 DeepSeek R1</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;快手搜索官方宣佈已全面接入 DeepSeek R1 的大模型能力，優化搜索效果與用戶體驗，未來也會持續探索智能搜索場景的商業化變現能力。&lt;/p&gt; 
&lt;p&gt;此前，快手已宣佈&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fir.kuaishou.com%2Fzh-hans%2Fnews-releases%2Fnews-release-details%2Fkuaishou-kling-ai-integrates-deepseek-lowering-entry-barrier-ai%2F&quot; target=&quot;_blank&quot;&gt;可靈 AI 已全面接入 DeepSeek-R1&lt;/a&gt;&lt;/u&gt;，在視頻生成、圖片生成等場景下，用戶可通過 DeepSeek 協助生成或者優化提示詞，將靈感轉化為專業提示詞，打造高質量創意視頻。&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;3436&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/161226_9Zcs_2720166.png&quot; width=&quot;2324&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340224</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340224</guid>
            <pubDate>Fri, 21 Mar 2025 08:12:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>印度人工智能快速發展隱憂猶存</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在美國斯坦福大學 2024 年底發佈的《全球人工智能實力排行榜》上，印度在全球 36 個國家 AI 活躍度綜合評估中排名第四位，僅次於美國、中國和英國。今年 2 月，印度總理莫迪提出了印度的「雙重 AI」願景。第一重「AI」是人工智能（Artificial Intelligence），第二重「AI」是有雄心的印度（Aspirational India）。隨後印度與法國在巴黎聯合主辦了「人工智能行動峯會」，向全世界展示了印度希望通過人工智能推動經濟轉型升級，實現跨越發展的目標。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度政府近年來不斷加大對人工智能領域的投入。2024 年 3 月，印度政府啓動「印度人工智能使命（India AI Mission）」，這是一項國家產業發展規劃，為印度人工智能初創企業提供包括 GPU（圖形處理器）關鍵算力在內的數字基礎設施服務以及政策和資金支持，計劃推動印度人工智能市場在 2024 年至 2027 年之間年均增長率達到 25% 至 35%，並在 2027 年創造 170 億美元的價值。全球統計數據庫（Statista）預計，2025 年，印度人工智能市場規模將超過 80 億美元。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;印度擁有龐大的人口基數和多樣化的市場需求，為人工智能技術應用提供了廣闊空間。在政府大力扶持下，阿達尼、塔塔、信實集團等印度本國大企業近年來不斷加大人工智能和數據中心建設投資，助推印度數字經濟發展。威普羅（Wipro）、菲爾洛普（Verloop）等印度本土私營人工智能企業也加大研發投資和應用推廣，加速拓展本土和周邊國家市場，特別是印度企業憑藉本國語言多樣性優勢，訓練適用廣泛的多語言數據模型，已經成功拿下多個東南亞、南亞國家政府訂單。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;但相較而言，印度自主研發人工智能技術面臨較大挑戰。研發偏基礎研究而非應用研究，基礎編程人員多，應用研究人才少，同時大量技術人才流失，大多流向美西方科技企業，研發投入整體仍顯不足，推動研究成果商業化的生態系統有待完善。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;針對本國企業在技術研發能力上的不足，印度政府藉助與世界頂尖人工智能研究機構和企業合作，利用世界現有先進技術實現應用層面的創新，加速自身技術突破。近年來，谷歌、微軟、亞馬遜、AMD 等國際科技企業高層頻頻造訪印度，科技巨頭們也紛紛宣佈大規模投資印度人工智能和大數據項目。今年 2 月初，OpenAI 首席執行官薩姆·奧爾特曼在會見印度鐵道、通信以及電子和信息技術部長阿什維尼·瓦伊什瑙時表示，印度是人工智能領域重要的市場，應當成為人工智能革命的領導者之一。在中國開源人工智能模型深度求索（DeepSeek）推出後，印度政府表示，將在本土服務器上部署 DeepSeek，並計劃再用 6 個月至 10 個月的時間，根據不同文化和語言需求設計開發出印度自己的開源人工智能基礎大模型。印度政府希望，屆時印度將在人工智能領域具備更強的國際競爭力，能夠為世界提供「另一個有希望的替代方案」。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;不過，在印度人工智能市場快速發展的背後也存在隱憂。有專家指出，人工智能熱潮可能衝擊印度以服務業為主的產業結構，人工智能的替代效應可能造成規模性失業和消費下滑，抑制人口紅利釋放，加大印度政府通過勞動密集型產業推動工業化的難度。一旦人工智能發展不能與工業製造業發展兼容，印度可能錯過本輪產業升級窗口期。 （經濟日報記者，王寶錕）&lt;/span&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340223</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340223</guid>
            <pubDate>Fri, 21 Mar 2025 08:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>Midjourney 核心開發者離職，加入 Cursor 負責開發 AI 編程 Agents</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;負責 Midjourney V2 至 V7 模型開發的核心工程師 theseriousadult 在 X 上&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2Fgallabytes%2Fstatus%2F1902864672728158610&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;&lt;/u&gt;已從公司離職。&lt;/p&gt; 
&lt;p&gt;theseriousadult 寫道：「&lt;strong&gt;&lt;em&gt;我幾乎從第一天起就一直在使用 Cursor，我真的很高興能開始從事長期以來在我的工作流程中如此重要的事情。語言模型將改變我們構建代碼和與代碼交互的方式，我想將其推向極限。&lt;/em&gt;&lt;/strong&gt;」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;2593&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/154821_Ouez_2720166.png&quot; width=&quot;1304&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;這位開發者在 Midjourney 的三年時間裏，主導了多個版本的模型迭代，以其對美學與創意的專注而聞名，其工作成果深受業界讚譽。離職後，theseriousadult 加入 Cursor 負責開發 AI 編程 Agents。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;閲讀更多&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/337993/anysphere-in-talks-for-close-to-10-billion-valuation&quot; target=&quot;news&quot;&gt;AI 編程神器 &quot;Cursor&quot; 估值達百億美元&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/320498/anysphere-acquires-supermaven&quot; target=&quot;news&quot;&gt;Cursor 母公司 Anysphere 收購 AI 編碼助手 Supermaven&lt;/a&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340219</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340219</guid>
            <pubDate>Fri, 21 Mar 2025 07:53:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>騰訊元寶新技能：支持分析複雜 Excel 表格</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;騰訊元寶&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FV3c4L5T9jvSMACo2JRtrxw&quot; target=&quot;_blank&quot;&gt;宣佈&lt;/a&gt;推出一項新功能，能夠幫助用戶分析複雜 Excel。「你只需要把表格給到元寶，元寶就能直接算、直接答，還能畫重點。」&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在過去，處理 Excel 表格往往需要用戶記住大量的函數和公式，稍有不慎就可能導致錯誤。現在，用戶只需將表格上傳至元寶平台，元寶就能直接進行分析，無需用戶手動輸入公式或進行復雜的操作。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;394&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-7eae121ba5a814f0370a2c7d0fc4f138ce3.png&quot; width=&quot;500&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在碰到體量很大、需要做複雜計算的表格時，可以切換到 Hunyuan，並關閉深度思考。這樣，快思考模型混元 Turbo S 就可以用代碼的方式進行快速分析。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;目前，騰訊元寶不僅支持本地上傳表格，還支持從微信和騰訊文檔直接導入。無論是電腦版、Web 版還是移動端，用戶都可以無縫切換。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/338559&quot; target=&quot;news&quot;&gt;騰訊元寶宣佈支持上傳、導出騰訊文檔&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340214</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340214</guid>
            <pubDate>Fri, 21 Mar 2025 07:36:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>百度：任何人無權觸碰用戶數據</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;在就 「謝廣軍女兒開盒」 事件發佈聲明後，百度於 3 月 20 日下午召開信息安全溝通會，針對事件的調查過程及結果進行現場説明，並展示經三方公證的「（2025）京精誠內經證字第 1642 號」公證書。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;img alt=&quot;&quot; height=&quot;492&quot; src=&quot;https://oscimg.oschina.net/oscnet/up-d450818c480c7db9cb2aaf28a87e1384093.webp&quot; width=&quot;300&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度安全負責人陳洋表示，&lt;strong&gt;百度任何職級的員工及高管均無權限觸碰用戶數據&lt;/strong&gt;。同時披露了事件調查結果：&lt;/span&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;事件發生以來，百度對當事員工的「歷史數據申請記錄」、「權限記錄」、「數據查詢」等多項權限和操作日誌進行了調查與審計，確認其沒有百度用戶個人身份信息的數據權限，也未登錄任何百度數據庫與服務器。經核實，確認開盒信息並非從百度泄露。該過程，全程經過三方現場公證。&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;針對「開盒事件」發生後網上流傳的「當事人承認家長給她數據庫」截圖，經核實發現，該截圖的信息內容不實，事實為博主收到家人紅包後，在平台曬出紅包截圖，博主回覆「我家長給的」，本意是想説明紅包的來源，與「開盒」無關，事件發生後的大量傳播信息均為不實。&lt;/span&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;並詳細講解了百度針對數據安全的多項防護措施：&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;用戶註冊賬號階段，即實施假名化處理，降低數據泄露風險，提高數據合規性；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;對數據實施加密，對敏感數據進行嚴格隔離，並依託數據安全管理平台，實現數據管理、權限控制及安全審計的統一管控；&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style=&quot;color:#000000&quot;&gt;遵循國際公認的風險控制理念，建立「基礎防守」、「制度&amp;amp;能力&amp;amp;風險專項」、「稽查&amp;amp;內部審計」三道安全防線。&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;百度表示，在相關政府部門的指導下，積極響應和倡議推進「反開盒」聯盟的成立，共同加強數據隱私防護，嚴厲打擊非法數據竊取及泄露行為，築牢網絡安全防線，共同維護清朗網絡空間。&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;相關閲讀：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;https://www.oschina.net/news/339949&quot; target=&quot;_blank&quot;&gt;百度就 「謝廣軍女兒開盒」 事件發佈聲明&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340213</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340213</guid>
            <pubDate>Fri, 21 Mar 2025 07:22:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
        <item>
            <title>13 年後，AlexNet 源代碼終於公開</title>
            <description>&lt;div class=&quot;content&quot;&gt;
                                                                    
                                                        &lt;p&gt;谷歌首席科學家 Jeff Dean 宣佈，他們與計算機歷史博物館（CHM）合作，&lt;u&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fcomputerhistory.org%2Fblog%2Fchm-releases-alexnet-source-code%2F&quot; target=&quot;_blank&quot;&gt;共同發佈了 AlexNet 的源代碼&lt;/a&gt;&lt;/u&gt;，並將長期保存這些代碼。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/150916_mJ2m_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;開放後的代碼庫如下：&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;520&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/150931_Gm2o_2720166.png&quot; width=&quot;1280&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;GitHub 鏈接：&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fcomputerhistory%2FAlexNet-Source-Code&quot; target=&quot;_blank&quot;&gt;https://github.com/computerhistory/AlexNet-Source-Code&lt;/a&gt;&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;AlexNet 是一個人工神經網絡，用於識別照片內容。它由當時的多倫多大學研究生 Alex Krizhevsky 和 Ilya Sutskever 以及他們的導師 Geoffrey Hinton 於 2012 年開發。&lt;/p&gt; 
&lt;p&gt;在計算機歷史上，AlexNet 的出現有着劃時代的意義。在它出現之前，很少有機器學習研究人員使用神經網絡。但在 AlexNet 出現之後，幾乎所有研究人員都會使用神經網絡。從 2012 年到 2022 年，神經網絡不斷取得進步，包括合成可信的人類聲音、擊敗圍棋冠軍選手、模擬人類語言並生成藝術作品…… 最終，OpenAI 於 2022 年發佈 ChatGPT…… 它是這一系列故事的重要起點。&lt;/p&gt; 
&lt;p&gt;「谷歌很高興將具有開創性意義的 AlexNet 項目的源代碼貢獻給計算機歷史博物館」，Jeff Dean 説，「這段代碼是 Alex Krizhevsky、Ilya Sutskever 和 Geoffrey Hinton 撰寫的標誌性論文《ImageNet Classification with Deep Convolutional Neural Networks》的基礎，該論文革新了計算機視覺領域，是有史以來被引用次數最多的論文之一。」&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2025/0321/151006_C9sF_2720166.png&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt; 
&lt;p&gt;&lt;em&gt;Google Scholar 數據顯示，AlexNet 相關論文被引量已經超過 17 萬。&lt;/em&gt;&lt;/p&gt; 
&lt;p&gt;除了代碼本身的價值，HuggingFace 聯合創始人 Thomas Wolf 還發現，代碼中的註釋也非常有啓發性。他説，「也許真正的歷史記錄是 AlexNet 代碼中每個實驗配置文件末尾的實驗記錄註釋。一個開創性的神經網絡正在誕生……」&lt;/p&gt; 
&lt;p&gt;&lt;img height=&quot;1454&quot; src=&quot;https://static.oschina.net/uploads/space/2025/0321/151021_yhzH_2720166.png&quot; width=&quot;1204&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/p&gt;
                                                                                &lt;/div&gt;
                                                                            </description>
            <link>https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</link>
            <guid isPermaLink="false">https://www.oschina.net/news/340212/chm-releases-alexnet-source-code</guid>
            <pubDate>Fri, 21 Mar 2025 07:11:00 GMT</pubDate>
            <author>來源: OSCHINA</author>
        </item>
    </channel>
</rss>